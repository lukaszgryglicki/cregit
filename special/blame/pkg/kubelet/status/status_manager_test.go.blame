0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
ce7a06715f84202018cc0482403baee6061bdade;pkg/kubelet/status_manager_test.go[pkg/kubelet/status_manager_test.go][pkg/kubelet/status/status_manager_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package status
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		kubeconfigmap "k8s.io/kubernetes/pkg/kubelet/configmap"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		kubepod "k8s.io/kubernetes/pkg/kubelet/pod"
0000000000000000000000000000000000000000;;		podtest "k8s.io/kubernetes/pkg/kubelet/pod/testing"
0000000000000000000000000000000000000000;;		kubesecret "k8s.io/kubernetes/pkg/kubelet/secret"
0000000000000000000000000000000000000000;;		statustest "k8s.io/kubernetes/pkg/kubelet/status/testing"
0000000000000000000000000000000000000000;;		kubetypes "k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generate new instance of test pod with the same initial value.
0000000000000000000000000000000000000000;;	func getTestPod() *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       "12345678",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: "new",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// After adding reconciliation, if status in pod manager is different from the cached status, a reconciliation
0000000000000000000000000000000000000000;;	// will be triggered, which will mess up all the old unit test.
0000000000000000000000000000000000000000;;	// To simplify the implementation of unit test, we add testSyncBatch() here, it will make sure the statuses in
0000000000000000000000000000000000000000;;	// pod manager the same with cached ones before syncBatch() so as to avoid reconciling.
0000000000000000000000000000000000000000;;	func (m *manager) testSyncBatch() {
0000000000000000000000000000000000000000;;		for uid, status := range m.podStatuses {
0000000000000000000000000000000000000000;;			pod, ok := m.podManager.GetPodByUID(uid)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				pod.Status = status.status
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod, ok = m.podManager.GetMirrorPodByPod(pod)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				pod.Status = status.status
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.syncBatch()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestManager(kubeClient clientset.Interface) *manager {
0000000000000000000000000000000000000000;;		podManager := kubepod.NewBasicPodManager(podtest.NewFakeMirrorClient(), kubesecret.NewFakeManager(), kubeconfigmap.NewFakeManager())
0000000000000000000000000000000000000000;;		podManager.AddPod(getTestPod())
0000000000000000000000000000000000000000;;		return NewManager(kubeClient, podManager, &statustest.FakePodDeletionSafetyProvider{}).(*manager)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateRandomMessage() string {
0000000000000000000000000000000000000000;;		return strconv.Itoa(rand.Int())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getRandomPodStatus() v1.PodStatus {
0000000000000000000000000000000000000000;;		return v1.PodStatus{
0000000000000000000000000000000000000000;;			Message: generateRandomMessage(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyActions(t *testing.T, manager *manager, expectedActions []core.Action) {
0000000000000000000000000000000000000000;;		manager.consumeUpdates()
0000000000000000000000000000000000000000;;		actions := manager.kubeClient.(*fake.Clientset).Actions()
0000000000000000000000000000000000000000;;		defer manager.kubeClient.(*fake.Clientset).ClearActions()
0000000000000000000000000000000000000000;;		if len(actions) != len(expectedActions) {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected actions, got: %+v expected: %+v", actions, expectedActions)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < len(actions); i++ {
0000000000000000000000000000000000000000;;			e := expectedActions[i]
0000000000000000000000000000000000000000;;			a := actions[i]
0000000000000000000000000000000000000000;;			if !a.Matches(e.GetVerb(), e.GetResource().Resource) || a.GetSubresource() != e.GetSubresource() {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected actions, got: %+v expected: %+v", actions, expectedActions)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyUpdates(t *testing.T, manager *manager, expectedUpdates int) {
0000000000000000000000000000000000000000;;		// Consume all updates in the channel.
0000000000000000000000000000000000000000;;		numUpdates := manager.consumeUpdates()
0000000000000000000000000000000000000000;;		if numUpdates != expectedUpdates {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected number of updates %d, expected %d", numUpdates, expectedUpdates)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) consumeUpdates() int {
0000000000000000000000000000000000000000;;		updates := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case syncRequest := <-m.podStatusChannel:
0000000000000000000000000000000000000000;;				m.syncPod(syncRequest.podUID, syncRequest.status)
0000000000000000000000000000000000000000;;				updates++
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return updates
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewStatus(t *testing.T) {
0000000000000000000000000000000000000000;;		syncer := newTestManager(&fake.Clientset{})
0000000000000000000000000000000000000000;;		testPod := getTestPod()
0000000000000000000000000000000000000000;;		syncer.SetPodStatus(testPod, getRandomPodStatus())
0000000000000000000000000000000000000000;;		verifyUpdates(t, syncer, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := expectPodStatus(t, syncer, testPod)
0000000000000000000000000000000000000000;;		if status.StartTime.IsZero() {
0000000000000000000000000000000000000000;;			t.Errorf("SetPodStatus did not set a proper start time value")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewStatusPreservesPodStartTime(t *testing.T) {
0000000000000000000000000000000000000000;;		syncer := newTestManager(&fake.Clientset{})
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       "12345678",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: "new",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PodStatus{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		startTime := metav1.NewTime(now.Time.Add(-1 * time.Minute))
0000000000000000000000000000000000000000;;		pod.Status.StartTime = &startTime
0000000000000000000000000000000000000000;;		syncer.SetPodStatus(pod, getRandomPodStatus())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := expectPodStatus(t, syncer, pod)
0000000000000000000000000000000000000000;;		if !status.StartTime.Time.Equal(startTime.Time) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected start time, expected %v, actual %v", startTime, status.StartTime)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getReadyPodStatus() v1.PodStatus {
0000000000000000000000000000000000000000;;		return v1.PodStatus{
0000000000000000000000000000000000000000;;			Conditions: []v1.PodCondition{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:   v1.PodReady,
0000000000000000000000000000000000000000;;					Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewStatusSetsReadyTransitionTime(t *testing.T) {
0000000000000000000000000000000000000000;;		syncer := newTestManager(&fake.Clientset{})
0000000000000000000000000000000000000000;;		podStatus := getReadyPodStatus()
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       "12345678",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: "new",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PodStatus{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		syncer.SetPodStatus(pod, podStatus)
0000000000000000000000000000000000000000;;		verifyUpdates(t, syncer, 1)
0000000000000000000000000000000000000000;;		status := expectPodStatus(t, syncer, pod)
0000000000000000000000000000000000000000;;		readyCondition := podutil.GetPodReadyCondition(status)
0000000000000000000000000000000000000000;;		if readyCondition.LastTransitionTime.IsZero() {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected: last transition time not set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestChangedStatus(t *testing.T) {
0000000000000000000000000000000000000000;;		syncer := newTestManager(&fake.Clientset{})
0000000000000000000000000000000000000000;;		testPod := getTestPod()
0000000000000000000000000000000000000000;;		syncer.SetPodStatus(testPod, getRandomPodStatus())
0000000000000000000000000000000000000000;;		syncer.SetPodStatus(testPod, getRandomPodStatus())
0000000000000000000000000000000000000000;;		verifyUpdates(t, syncer, 2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestChangedStatusKeepsStartTime(t *testing.T) {
0000000000000000000000000000000000000000;;		syncer := newTestManager(&fake.Clientset{})
0000000000000000000000000000000000000000;;		testPod := getTestPod()
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		firstStatus := getRandomPodStatus()
0000000000000000000000000000000000000000;;		firstStatus.StartTime = &now
0000000000000000000000000000000000000000;;		syncer.SetPodStatus(testPod, firstStatus)
0000000000000000000000000000000000000000;;		syncer.SetPodStatus(testPod, getRandomPodStatus())
0000000000000000000000000000000000000000;;		verifyUpdates(t, syncer, 2)
0000000000000000000000000000000000000000;;		finalStatus := expectPodStatus(t, syncer, testPod)
0000000000000000000000000000000000000000;;		if finalStatus.StartTime.IsZero() {
0000000000000000000000000000000000000000;;			t.Errorf("StartTime should not be zero")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expected := now.Rfc3339Copy()
0000000000000000000000000000000000000000;;		if !finalStatus.StartTime.Equal(expected) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, but got %v", expected, finalStatus.StartTime)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestChangedStatusUpdatesLastTransitionTime(t *testing.T) {
0000000000000000000000000000000000000000;;		syncer := newTestManager(&fake.Clientset{})
0000000000000000000000000000000000000000;;		podStatus := getReadyPodStatus()
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       "12345678",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: "new",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PodStatus{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		syncer.SetPodStatus(pod, podStatus)
0000000000000000000000000000000000000000;;		verifyUpdates(t, syncer, 1)
0000000000000000000000000000000000000000;;		oldStatus := expectPodStatus(t, syncer, pod)
0000000000000000000000000000000000000000;;		anotherStatus := getReadyPodStatus()
0000000000000000000000000000000000000000;;		anotherStatus.Conditions[0].Status = v1.ConditionFalse
0000000000000000000000000000000000000000;;		syncer.SetPodStatus(pod, anotherStatus)
0000000000000000000000000000000000000000;;		verifyUpdates(t, syncer, 1)
0000000000000000000000000000000000000000;;		newStatus := expectPodStatus(t, syncer, pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oldReadyCondition := podutil.GetPodReadyCondition(oldStatus)
0000000000000000000000000000000000000000;;		newReadyCondition := podutil.GetPodReadyCondition(newStatus)
0000000000000000000000000000000000000000;;		if newReadyCondition.LastTransitionTime.IsZero() {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected: last transition time not set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if newReadyCondition.LastTransitionTime.Before(oldReadyCondition.LastTransitionTime) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected: new transition time %s, is before old transition time %s", newReadyCondition.LastTransitionTime, oldReadyCondition.LastTransitionTime)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUnchangedStatus(t *testing.T) {
0000000000000000000000000000000000000000;;		syncer := newTestManager(&fake.Clientset{})
0000000000000000000000000000000000000000;;		testPod := getTestPod()
0000000000000000000000000000000000000000;;		podStatus := getRandomPodStatus()
0000000000000000000000000000000000000000;;		syncer.SetPodStatus(testPod, podStatus)
0000000000000000000000000000000000000000;;		syncer.SetPodStatus(testPod, podStatus)
0000000000000000000000000000000000000000;;		verifyUpdates(t, syncer, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUnchangedStatusPreservesLastTransitionTime(t *testing.T) {
0000000000000000000000000000000000000000;;		syncer := newTestManager(&fake.Clientset{})
0000000000000000000000000000000000000000;;		podStatus := getReadyPodStatus()
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       "12345678",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: "new",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PodStatus{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		syncer.SetPodStatus(pod, podStatus)
0000000000000000000000000000000000000000;;		verifyUpdates(t, syncer, 1)
0000000000000000000000000000000000000000;;		oldStatus := expectPodStatus(t, syncer, pod)
0000000000000000000000000000000000000000;;		anotherStatus := getReadyPodStatus()
0000000000000000000000000000000000000000;;		syncer.SetPodStatus(pod, anotherStatus)
0000000000000000000000000000000000000000;;		// No update.
0000000000000000000000000000000000000000;;		verifyUpdates(t, syncer, 0)
0000000000000000000000000000000000000000;;		newStatus := expectPodStatus(t, syncer, pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oldReadyCondition := podutil.GetPodReadyCondition(oldStatus)
0000000000000000000000000000000000000000;;		newReadyCondition := podutil.GetPodReadyCondition(newStatus)
0000000000000000000000000000000000000000;;		if newReadyCondition.LastTransitionTime.IsZero() {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected: last transition time not set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !oldReadyCondition.LastTransitionTime.Equal(newReadyCondition.LastTransitionTime) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected: new transition time %s, is not equal to old transition time %s", newReadyCondition.LastTransitionTime, oldReadyCondition.LastTransitionTime)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncPodIgnoresNotFound(t *testing.T) {
0000000000000000000000000000000000000000;;		client := fake.Clientset{}
0000000000000000000000000000000000000000;;		syncer := newTestManager(&client)
0000000000000000000000000000000000000000;;		client.AddReactor("get", "pods", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			return true, nil, errors.NewNotFound(api.Resource("pods"), "test-pod")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		syncer.SetPodStatus(getTestPod(), getRandomPodStatus())
0000000000000000000000000000000000000000;;		verifyActions(t, syncer, []core.Action{getAction()})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncPod(t *testing.T) {
0000000000000000000000000000000000000000;;		syncer := newTestManager(&fake.Clientset{})
0000000000000000000000000000000000000000;;		testPod := getTestPod()
0000000000000000000000000000000000000000;;		syncer.kubeClient = fake.NewSimpleClientset(testPod)
0000000000000000000000000000000000000000;;		syncer.SetPodStatus(testPod, getRandomPodStatus())
0000000000000000000000000000000000000000;;		verifyActions(t, syncer, []core.Action{getAction(), updateAction()})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncPodChecksMismatchedUID(t *testing.T) {
0000000000000000000000000000000000000000;;		syncer := newTestManager(&fake.Clientset{})
0000000000000000000000000000000000000000;;		pod := getTestPod()
0000000000000000000000000000000000000000;;		pod.UID = "first"
0000000000000000000000000000000000000000;;		syncer.podManager.AddPod(pod)
0000000000000000000000000000000000000000;;		differentPod := getTestPod()
0000000000000000000000000000000000000000;;		differentPod.UID = "second"
0000000000000000000000000000000000000000;;		syncer.podManager.AddPod(differentPod)
0000000000000000000000000000000000000000;;		syncer.kubeClient = fake.NewSimpleClientset(pod)
0000000000000000000000000000000000000000;;		syncer.SetPodStatus(differentPod, getRandomPodStatus())
0000000000000000000000000000000000000000;;		verifyActions(t, syncer, []core.Action{getAction()})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncPodNoDeadlock(t *testing.T) {
0000000000000000000000000000000000000000;;		client := &fake.Clientset{}
0000000000000000000000000000000000000000;;		m := newTestManager(client)
0000000000000000000000000000000000000000;;		pod := getTestPod()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup fake client.
0000000000000000000000000000000000000000;;		var ret *v1.Pod
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		client.AddReactor("*", "pods", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			switch action := action.(type) {
0000000000000000000000000000000000000000;;			case core.GetAction:
0000000000000000000000000000000000000000;;				assert.Equal(t, pod.Name, action.GetName(), "Unexpeted GetAction: %+v", action)
0000000000000000000000000000000000000000;;			case core.UpdateAction:
0000000000000000000000000000000000000000;;				assert.Equal(t, pod.Name, action.GetObject().(*v1.Pod).Name, "Unexpeted UpdateAction: %+v", action)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				assert.Fail(t, "Unexpected Action: %+v", action)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, ret, err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod.Status.ContainerStatuses = []v1.ContainerStatus{{State: v1.ContainerState{Running: &v1.ContainerStateRunning{}}}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Pod not found.")
0000000000000000000000000000000000000000;;		ret = nil
0000000000000000000000000000000000000000;;		err = errors.NewNotFound(api.Resource("pods"), pod.Name)
0000000000000000000000000000000000000000;;		m.SetPodStatus(pod, getRandomPodStatus())
0000000000000000000000000000000000000000;;		verifyActions(t, m, []core.Action{getAction()})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Pod was recreated.")
0000000000000000000000000000000000000000;;		ret = getTestPod()
0000000000000000000000000000000000000000;;		ret.UID = "other_pod"
0000000000000000000000000000000000000000;;		err = nil
0000000000000000000000000000000000000000;;		m.SetPodStatus(pod, getRandomPodStatus())
0000000000000000000000000000000000000000;;		verifyActions(t, m, []core.Action{getAction()})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Pod not deleted (success case).")
0000000000000000000000000000000000000000;;		ret = getTestPod()
0000000000000000000000000000000000000000;;		m.SetPodStatus(pod, getRandomPodStatus())
0000000000000000000000000000000000000000;;		verifyActions(t, m, []core.Action{getAction(), updateAction()})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Pod is terminated, but still running.")
0000000000000000000000000000000000000000;;		pod.DeletionTimestamp = new(metav1.Time)
0000000000000000000000000000000000000000;;		m.SetPodStatus(pod, getRandomPodStatus())
0000000000000000000000000000000000000000;;		verifyActions(t, m, []core.Action{getAction(), updateAction()})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Pod is terminated successfully.")
0000000000000000000000000000000000000000;;		pod.Status.ContainerStatuses[0].State.Running = nil
0000000000000000000000000000000000000000;;		pod.Status.ContainerStatuses[0].State.Terminated = &v1.ContainerStateTerminated{}
0000000000000000000000000000000000000000;;		m.SetPodStatus(pod, getRandomPodStatus())
0000000000000000000000000000000000000000;;		verifyActions(t, m, []core.Action{getAction(), updateAction()})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Error case.")
0000000000000000000000000000000000000000;;		ret = nil
0000000000000000000000000000000000000000;;		err = fmt.Errorf("intentional test error")
0000000000000000000000000000000000000000;;		m.SetPodStatus(pod, getRandomPodStatus())
0000000000000000000000000000000000000000;;		verifyActions(t, m, []core.Action{getAction()})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStaleUpdates(t *testing.T) {
0000000000000000000000000000000000000000;;		pod := getTestPod()
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset(pod)
0000000000000000000000000000000000000000;;		m := newTestManager(client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := v1.PodStatus{Message: "initial status"}
0000000000000000000000000000000000000000;;		m.SetPodStatus(pod, status)
0000000000000000000000000000000000000000;;		status.Message = "first version bump"
0000000000000000000000000000000000000000;;		m.SetPodStatus(pod, status)
0000000000000000000000000000000000000000;;		status.Message = "second version bump"
0000000000000000000000000000000000000000;;		m.SetPodStatus(pod, status)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("sync batch before syncPods pushes latest status, so we should see three statuses in the channel, but only one update")
0000000000000000000000000000000000000000;;		m.syncBatch()
0000000000000000000000000000000000000000;;		verifyUpdates(t, m, 3)
0000000000000000000000000000000000000000;;		verifyActions(t, m, []core.Action{getAction(), updateAction()})
0000000000000000000000000000000000000000;;		t.Logf("Nothing left in the channel to sync")
0000000000000000000000000000000000000000;;		verifyActions(t, m, []core.Action{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Log("Unchanged status should not send an update.")
0000000000000000000000000000000000000000;;		m.SetPodStatus(pod, status)
0000000000000000000000000000000000000000;;		verifyUpdates(t, m, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Log("... unless it's stale.")
0000000000000000000000000000000000000000;;		m.apiStatusVersions[pod.UID] = m.apiStatusVersions[pod.UID] - 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.SetPodStatus(pod, status)
0000000000000000000000000000000000000000;;		m.syncBatch()
0000000000000000000000000000000000000000;;		verifyActions(t, m, []core.Action{getAction(), updateAction()})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Nothing stuck in the pipe.")
0000000000000000000000000000000000000000;;		verifyUpdates(t, m, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shuffle returns a new shuffled list of container statuses.
0000000000000000000000000000000000000000;;	func shuffle(statuses []v1.ContainerStatus) []v1.ContainerStatus {
0000000000000000000000000000000000000000;;		numStatuses := len(statuses)
0000000000000000000000000000000000000000;;		randIndexes := rand.Perm(numStatuses)
0000000000000000000000000000000000000000;;		shuffled := make([]v1.ContainerStatus, numStatuses)
0000000000000000000000000000000000000000;;		for i := 0; i < numStatuses; i++ {
0000000000000000000000000000000000000000;;			shuffled[i] = statuses[randIndexes[i]]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return shuffled
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStatusEquality(t *testing.T) {
0000000000000000000000000000000000000000;;		pod := v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		containerStatus := []v1.ContainerStatus{}
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;			s := v1.ContainerStatus{
0000000000000000000000000000000000000000;;				Name: fmt.Sprintf("container%d", i),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			containerStatus = append(containerStatus, s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podStatus := v1.PodStatus{
0000000000000000000000000000000000000000;;			ContainerStatuses: containerStatus,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;			oldPodStatus := v1.PodStatus{
0000000000000000000000000000000000000000;;				ContainerStatuses: shuffle(podStatus.ContainerStatuses),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			normalizeStatus(&pod, &oldPodStatus)
0000000000000000000000000000000000000000;;			normalizeStatus(&pod, &podStatus)
0000000000000000000000000000000000000000;;			if !isStatusEqual(&oldPodStatus, &podStatus) {
0000000000000000000000000000000000000000;;				t.Fatalf("Order of container statuses should not affect normalized equality.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStatusNormalizationEnforcesMaxBytes(t *testing.T) {
0000000000000000000000000000000000000000;;		pod := v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		containerStatus := []v1.ContainerStatus{}
0000000000000000000000000000000000000000;;		for i := 0; i < 48; i++ {
0000000000000000000000000000000000000000;;			s := v1.ContainerStatus{
0000000000000000000000000000000000000000;;				Name: fmt.Sprintf("container%d", i),
0000000000000000000000000000000000000000;;				LastTerminationState: v1.ContainerState{
0000000000000000000000000000000000000000;;					Terminated: &v1.ContainerStateTerminated{
0000000000000000000000000000000000000000;;						Message: strings.Repeat("abcdefgh", int(24+i%3)),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			containerStatus = append(containerStatus, s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podStatus := v1.PodStatus{
0000000000000000000000000000000000000000;;			InitContainerStatuses: containerStatus[:24],
0000000000000000000000000000000000000000;;			ContainerStatuses:     containerStatus[24:],
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := normalizeStatus(&pod, &podStatus)
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		for _, s := range result.InitContainerStatuses {
0000000000000000000000000000000000000000;;			l := len(s.LastTerminationState.Terminated.Message)
0000000000000000000000000000000000000000;;			if l < 192 || l > 256 {
0000000000000000000000000000000000000000;;				t.Errorf("container message had length %d", l)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			count += l
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if count > kubecontainer.MaxPodTerminationMessageLogLength {
0000000000000000000000000000000000000000;;			t.Errorf("message length not truncated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStaticPod(t *testing.T) {
0000000000000000000000000000000000000000;;		staticPod := getTestPod()
0000000000000000000000000000000000000000;;		staticPod.Annotations = map[string]string{kubetypes.ConfigSourceAnnotationKey: "file"}
0000000000000000000000000000000000000000;;		mirrorPod := getTestPod()
0000000000000000000000000000000000000000;;		mirrorPod.UID = "mirror-12345678"
0000000000000000000000000000000000000000;;		mirrorPod.Annotations = map[string]string{
0000000000000000000000000000000000000000;;			kubetypes.ConfigSourceAnnotationKey: "api",
0000000000000000000000000000000000000000;;			kubetypes.ConfigMirrorAnnotationKey: "mirror",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset(mirrorPod)
0000000000000000000000000000000000000000;;		m := newTestManager(client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Create the static pod")
0000000000000000000000000000000000000000;;		m.podManager.AddPod(staticPod)
0000000000000000000000000000000000000000;;		assert.True(t, kubepod.IsStaticPod(staticPod), "SetUp error: staticPod")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := getRandomPodStatus()
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		status.StartTime = &now
0000000000000000000000000000000000000000;;		m.SetPodStatus(staticPod, status)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Should be able to get the static pod status from status manager")
0000000000000000000000000000000000000000;;		retrievedStatus := expectPodStatus(t, m, staticPod)
0000000000000000000000000000000000000000;;		normalizeStatus(staticPod, &status)
0000000000000000000000000000000000000000;;		assert.True(t, isStatusEqual(&status, &retrievedStatus), "Expected: %+v, Got: %+v", status, retrievedStatus)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Should not sync pod in syncBatch because there is no corresponding mirror pod for the static pod.")
0000000000000000000000000000000000000000;;		m.syncBatch()
0000000000000000000000000000000000000000;;		assert.Equal(t, len(m.kubeClient.(*fake.Clientset).Actions()), 0, "Expected no updates after syncBatch, got %+v", m.kubeClient.(*fake.Clientset).Actions())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Create the mirror pod")
0000000000000000000000000000000000000000;;		m.podManager.AddPod(mirrorPod)
0000000000000000000000000000000000000000;;		assert.True(t, kubepod.IsMirrorPod(mirrorPod), "SetUp error: mirrorPod")
0000000000000000000000000000000000000000;;		assert.Equal(t, m.podManager.TranslatePodUID(mirrorPod.UID), staticPod.UID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Should be able to get the mirror pod status from status manager")
0000000000000000000000000000000000000000;;		retrievedStatus, _ = m.GetPodStatus(mirrorPod.UID)
0000000000000000000000000000000000000000;;		assert.True(t, isStatusEqual(&status, &retrievedStatus), "Expected: %+v, Got: %+v", status, retrievedStatus)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Should sync pod because the corresponding mirror pod is created")
0000000000000000000000000000000000000000;;		verifyActions(t, m, []core.Action{getAction(), updateAction()})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("syncBatch should not sync any pods because nothing is changed.")
0000000000000000000000000000000000000000;;		m.testSyncBatch()
0000000000000000000000000000000000000000;;		verifyActions(t, m, []core.Action{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Change mirror pod identity.")
0000000000000000000000000000000000000000;;		m.podManager.DeletePod(mirrorPod)
0000000000000000000000000000000000000000;;		mirrorPod.UID = "new-mirror-pod"
0000000000000000000000000000000000000000;;		mirrorPod.Status = v1.PodStatus{}
0000000000000000000000000000000000000000;;		m.podManager.AddPod(mirrorPod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Should not update to mirror pod, because UID has changed.")
0000000000000000000000000000000000000000;;		m.syncBatch()
0000000000000000000000000000000000000000;;		verifyActions(t, m, []core.Action{getAction()})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTerminatePod(t *testing.T) {
0000000000000000000000000000000000000000;;		syncer := newTestManager(&fake.Clientset{})
0000000000000000000000000000000000000000;;		testPod := getTestPod()
0000000000000000000000000000000000000000;;		t.Logf("update the pod's status to Failed.  TerminatePod should preserve this status update.")
0000000000000000000000000000000000000000;;		firstStatus := getRandomPodStatus()
0000000000000000000000000000000000000000;;		firstStatus.Phase = v1.PodFailed
0000000000000000000000000000000000000000;;		syncer.SetPodStatus(testPod, firstStatus)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("set the testPod to a pod with Phase running, to simulate a stale pod")
0000000000000000000000000000000000000000;;		testPod.Status = getRandomPodStatus()
0000000000000000000000000000000000000000;;		testPod.Status.Phase = v1.PodRunning
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		syncer.TerminatePod(testPod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("we expect the container statuses to have changed to terminated")
0000000000000000000000000000000000000000;;		newStatus := expectPodStatus(t, syncer, testPod)
0000000000000000000000000000000000000000;;		for i := range newStatus.ContainerStatuses {
0000000000000000000000000000000000000000;;			assert.False(t, newStatus.ContainerStatuses[i].State.Terminated == nil, "expected containers to be terminated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range newStatus.InitContainerStatuses {
0000000000000000000000000000000000000000;;			assert.False(t, newStatus.InitContainerStatuses[i].State.Terminated == nil, "expected init containers to be terminated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("we expect the previous status update to be preserved.")
0000000000000000000000000000000000000000;;		assert.Equal(t, newStatus.Phase, firstStatus.Phase)
0000000000000000000000000000000000000000;;		assert.Equal(t, newStatus.Message, firstStatus.Message)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetContainerReadiness(t *testing.T) {
0000000000000000000000000000000000000000;;		cID1 := kubecontainer.ContainerID{Type: "test", ID: "1"}
0000000000000000000000000000000000000000;;		cID2 := kubecontainer.ContainerID{Type: "test", ID: "2"}
0000000000000000000000000000000000000000;;		containerStatuses := []v1.ContainerStatus{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name:        "c1",
0000000000000000000000000000000000000000;;				ContainerID: cID1.String(),
0000000000000000000000000000000000000000;;				Ready:       false,
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				Name:        "c2",
0000000000000000000000000000000000000000;;				ContainerID: cID2.String(),
0000000000000000000000000000000000000000;;				Ready:       false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		status := v1.PodStatus{
0000000000000000000000000000000000000000;;			ContainerStatuses: containerStatuses,
0000000000000000000000000000000000000000;;			Conditions: []v1.PodCondition{{
0000000000000000000000000000000000000000;;				Type:   v1.PodReady,
0000000000000000000000000000000000000000;;				Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := getTestPod()
0000000000000000000000000000000000000000;;		pod.Spec.Containers = []v1.Container{{Name: "c1"}, {Name: "c2"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify expected readiness of containers & pod.
0000000000000000000000000000000000000000;;		verifyReadiness := func(step string, status *v1.PodStatus, c1Ready, c2Ready, podReady bool) {
0000000000000000000000000000000000000000;;			for _, c := range status.ContainerStatuses {
0000000000000000000000000000000000000000;;				switch c.ContainerID {
0000000000000000000000000000000000000000;;				case cID1.String():
0000000000000000000000000000000000000000;;					if c.Ready != c1Ready {
0000000000000000000000000000000000000000;;						t.Errorf("[%s] Expected readiness of c1 to be %v but was %v", step, c1Ready, c.Ready)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case cID2.String():
0000000000000000000000000000000000000000;;					if c.Ready != c2Ready {
0000000000000000000000000000000000000000;;						t.Errorf("[%s] Expected readiness of c2 to be %v but was %v", step, c2Ready, c.Ready)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("[%s] Unexpected container: %+v", step, c)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if status.Conditions[0].Type != v1.PodReady {
0000000000000000000000000000000000000000;;				t.Fatalf("[%s] Unexpected condition: %+v", step, status.Conditions[0])
0000000000000000000000000000000000000000;;			} else if ready := (status.Conditions[0].Status == v1.ConditionTrue); ready != podReady {
0000000000000000000000000000000000000000;;				t.Errorf("[%s] Expected readiness of pod to be %v but was %v", step, podReady, ready)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := newTestManager(&fake.Clientset{})
0000000000000000000000000000000000000000;;		// Add test pod because the container spec has been changed.
0000000000000000000000000000000000000000;;		m.podManager.AddPod(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Log("Setting readiness before status should fail.")
0000000000000000000000000000000000000000;;		m.SetContainerReadiness(pod.UID, cID1, true)
0000000000000000000000000000000000000000;;		verifyUpdates(t, m, 0)
0000000000000000000000000000000000000000;;		if status, ok := m.GetPodStatus(pod.UID); ok {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected PodStatus: %+v", status)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Log("Setting initial status.")
0000000000000000000000000000000000000000;;		m.SetPodStatus(pod, status)
0000000000000000000000000000000000000000;;		verifyUpdates(t, m, 1)
0000000000000000000000000000000000000000;;		status = expectPodStatus(t, m, pod)
0000000000000000000000000000000000000000;;		verifyReadiness("initial", &status, false, false, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Log("Setting unchanged readiness should do nothing.")
0000000000000000000000000000000000000000;;		m.SetContainerReadiness(pod.UID, cID1, false)
0000000000000000000000000000000000000000;;		verifyUpdates(t, m, 0)
0000000000000000000000000000000000000000;;		status = expectPodStatus(t, m, pod)
0000000000000000000000000000000000000000;;		verifyReadiness("unchanged", &status, false, false, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Log("Setting container readiness should generate update but not pod readiness.")
0000000000000000000000000000000000000000;;		m.SetContainerReadiness(pod.UID, cID1, true)
0000000000000000000000000000000000000000;;		verifyUpdates(t, m, 1)
0000000000000000000000000000000000000000;;		status = expectPodStatus(t, m, pod)
0000000000000000000000000000000000000000;;		verifyReadiness("c1 ready", &status, true, false, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Log("Setting both containers to ready should update pod readiness.")
0000000000000000000000000000000000000000;;		m.SetContainerReadiness(pod.UID, cID2, true)
0000000000000000000000000000000000000000;;		verifyUpdates(t, m, 1)
0000000000000000000000000000000000000000;;		status = expectPodStatus(t, m, pod)
0000000000000000000000000000000000000000;;		verifyReadiness("all ready", &status, true, true, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Log("Setting non-existent container readiness should fail.")
0000000000000000000000000000000000000000;;		m.SetContainerReadiness(pod.UID, kubecontainer.ContainerID{Type: "test", ID: "foo"}, true)
0000000000000000000000000000000000000000;;		verifyUpdates(t, m, 0)
0000000000000000000000000000000000000000;;		status = expectPodStatus(t, m, pod)
0000000000000000000000000000000000000000;;		verifyReadiness("ignore non-existent", &status, true, true, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncBatchCleanupVersions(t *testing.T) {
0000000000000000000000000000000000000000;;		m := newTestManager(&fake.Clientset{})
0000000000000000000000000000000000000000;;		testPod := getTestPod()
0000000000000000000000000000000000000000;;		mirrorPod := getTestPod()
0000000000000000000000000000000000000000;;		mirrorPod.UID = "mirror-uid"
0000000000000000000000000000000000000000;;		mirrorPod.Name = "mirror_pod"
0000000000000000000000000000000000000000;;		mirrorPod.Annotations = map[string]string{
0000000000000000000000000000000000000000;;			kubetypes.ConfigSourceAnnotationKey: "api",
0000000000000000000000000000000000000000;;			kubetypes.ConfigMirrorAnnotationKey: "mirror",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Orphaned pods should be removed.")
0000000000000000000000000000000000000000;;		m.apiStatusVersions[testPod.UID] = 100
0000000000000000000000000000000000000000;;		m.apiStatusVersions[mirrorPod.UID] = 200
0000000000000000000000000000000000000000;;		m.syncBatch()
0000000000000000000000000000000000000000;;		if _, ok := m.apiStatusVersions[testPod.UID]; ok {
0000000000000000000000000000000000000000;;			t.Errorf("Should have cleared status for testPod")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := m.apiStatusVersions[mirrorPod.UID]; ok {
0000000000000000000000000000000000000000;;			t.Errorf("Should have cleared status for mirrorPod")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Non-orphaned pods should not be removed.")
0000000000000000000000000000000000000000;;		m.SetPodStatus(testPod, getRandomPodStatus())
0000000000000000000000000000000000000000;;		m.podManager.AddPod(mirrorPod)
0000000000000000000000000000000000000000;;		staticPod := mirrorPod
0000000000000000000000000000000000000000;;		staticPod.UID = "static-uid"
0000000000000000000000000000000000000000;;		staticPod.Annotations = map[string]string{kubetypes.ConfigSourceAnnotationKey: "file"}
0000000000000000000000000000000000000000;;		m.podManager.AddPod(staticPod)
0000000000000000000000000000000000000000;;		m.apiStatusVersions[testPod.UID] = 100
0000000000000000000000000000000000000000;;		m.apiStatusVersions[mirrorPod.UID] = 200
0000000000000000000000000000000000000000;;		m.testSyncBatch()
0000000000000000000000000000000000000000;;		if _, ok := m.apiStatusVersions[testPod.UID]; !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Should not have cleared status for testPod")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := m.apiStatusVersions[mirrorPod.UID]; !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Should not have cleared status for mirrorPod")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReconcilePodStatus(t *testing.T) {
0000000000000000000000000000000000000000;;		testPod := getTestPod()
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset(testPod)
0000000000000000000000000000000000000000;;		syncer := newTestManager(client)
0000000000000000000000000000000000000000;;		syncer.SetPodStatus(testPod, getRandomPodStatus())
0000000000000000000000000000000000000000;;		t.Logf("Call syncBatch directly to test reconcile")
0000000000000000000000000000000000000000;;		syncer.syncBatch() // The apiStatusVersions should be set now
0000000000000000000000000000000000000000;;		client.ClearActions()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podStatus, ok := syncer.GetPodStatus(testPod.UID)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("Should find pod status for pod: %#v", testPod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testPod.Status = podStatus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("If the pod status is the same, a reconciliation is not needed and syncBatch should do nothing")
0000000000000000000000000000000000000000;;		syncer.podManager.UpdatePod(testPod)
0000000000000000000000000000000000000000;;		if syncer.needsReconcile(testPod.UID, podStatus) {
0000000000000000000000000000000000000000;;			t.Errorf("Pod status is the same, a reconciliation is not needed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		syncer.syncBatch()
0000000000000000000000000000000000000000;;		verifyActions(t, syncer, []core.Action{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the pod status is the same, only the timestamp is in Rfc3339 format (lower precision without nanosecond),
0000000000000000000000000000000000000000;;		// a reconciliation is not needed, syncBatch should do nothing.
0000000000000000000000000000000000000000;;		// The StartTime should have been set in SetPodStatus().
0000000000000000000000000000000000000000;;		// TODO(random-liu): Remove this later when api becomes consistent for timestamp.
0000000000000000000000000000000000000000;;		t.Logf("Syncbatch should do nothing, as a reconciliation is not required")
0000000000000000000000000000000000000000;;		normalizedStartTime := testPod.Status.StartTime.Rfc3339Copy()
0000000000000000000000000000000000000000;;		testPod.Status.StartTime = &normalizedStartTime
0000000000000000000000000000000000000000;;		syncer.podManager.UpdatePod(testPod)
0000000000000000000000000000000000000000;;		if syncer.needsReconcile(testPod.UID, podStatus) {
0000000000000000000000000000000000000000;;			t.Errorf("Pod status only differs for timestamp format, a reconciliation is not needed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		syncer.syncBatch()
0000000000000000000000000000000000000000;;		verifyActions(t, syncer, []core.Action{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("If the pod status is different, a reconciliation is needed, syncBatch should trigger an update")
0000000000000000000000000000000000000000;;		testPod.Status = getRandomPodStatus()
0000000000000000000000000000000000000000;;		syncer.podManager.UpdatePod(testPod)
0000000000000000000000000000000000000000;;		if !syncer.needsReconcile(testPod.UID, podStatus) {
0000000000000000000000000000000000000000;;			t.Errorf("Pod status is different, a reconciliation is needed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		syncer.syncBatch()
0000000000000000000000000000000000000000;;		verifyActions(t, syncer, []core.Action{getAction(), updateAction()})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectPodStatus(t *testing.T, m *manager, pod *v1.Pod) v1.PodStatus {
0000000000000000000000000000000000000000;;		status, ok := m.GetPodStatus(pod.UID)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected PodStatus for %q not found", pod.UID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return status
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeletePods(t *testing.T) {
0000000000000000000000000000000000000000;;		pod := getTestPod()
0000000000000000000000000000000000000000;;		t.Logf("Set the deletion timestamp.")
0000000000000000000000000000000000000000;;		pod.DeletionTimestamp = new(metav1.Time)
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset(pod)
0000000000000000000000000000000000000000;;		m := newTestManager(client)
0000000000000000000000000000000000000000;;		m.podManager.AddPod(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := getRandomPodStatus()
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		status.StartTime = &now
0000000000000000000000000000000000000000;;		m.SetPodStatus(pod, status)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Expect to see a delete action.")
0000000000000000000000000000000000000000;;		verifyActions(t, m, []core.Action{getAction(), updateAction(), deleteAction()})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDoNotDeleteMirrorPods(t *testing.T) {
0000000000000000000000000000000000000000;;		staticPod := getTestPod()
0000000000000000000000000000000000000000;;		staticPod.Annotations = map[string]string{kubetypes.ConfigSourceAnnotationKey: "file"}
0000000000000000000000000000000000000000;;		mirrorPod := getTestPod()
0000000000000000000000000000000000000000;;		mirrorPod.UID = "mirror-12345678"
0000000000000000000000000000000000000000;;		mirrorPod.Annotations = map[string]string{
0000000000000000000000000000000000000000;;			kubetypes.ConfigSourceAnnotationKey: "api",
0000000000000000000000000000000000000000;;			kubetypes.ConfigMirrorAnnotationKey: "mirror",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Logf("Set the deletion timestamp.")
0000000000000000000000000000000000000000;;		mirrorPod.DeletionTimestamp = new(metav1.Time)
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset(mirrorPod)
0000000000000000000000000000000000000000;;		m := newTestManager(client)
0000000000000000000000000000000000000000;;		m.podManager.AddPod(staticPod)
0000000000000000000000000000000000000000;;		m.podManager.AddPod(mirrorPod)
0000000000000000000000000000000000000000;;		t.Logf("Verify setup.")
0000000000000000000000000000000000000000;;		assert.True(t, kubepod.IsStaticPod(staticPod), "SetUp error: staticPod")
0000000000000000000000000000000000000000;;		assert.True(t, kubepod.IsMirrorPod(mirrorPod), "SetUp error: mirrorPod")
0000000000000000000000000000000000000000;;		assert.Equal(t, m.podManager.TranslatePodUID(mirrorPod.UID), staticPod.UID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := getRandomPodStatus()
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		status.StartTime = &now
0000000000000000000000000000000000000000;;		m.SetPodStatus(staticPod, status)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Expect not to see a delete action.")
0000000000000000000000000000000000000000;;		verifyActions(t, m, []core.Action{getAction(), updateAction()})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getAction() core.GetAction {
0000000000000000000000000000000000000000;;		return core.GetActionImpl{ActionImpl: core.ActionImpl{Verb: "get", Resource: schema.GroupVersionResource{Resource: "pods"}}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updateAction() core.UpdateAction {
0000000000000000000000000000000000000000;;		return core.UpdateActionImpl{ActionImpl: core.ActionImpl{Verb: "update", Resource: schema.GroupVersionResource{Resource: "pods"}, Subresource: "status"}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deleteAction() core.DeleteAction {
0000000000000000000000000000000000000000;;		return core.DeleteActionImpl{ActionImpl: core.ActionImpl{Verb: "delete", Resource: schema.GroupVersionResource{Resource: "pods"}}}
0000000000000000000000000000000000000000;;	}
