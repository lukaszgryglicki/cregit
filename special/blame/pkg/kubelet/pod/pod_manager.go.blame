0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
d5235d9b54932acca15526ef5fe86f33975fdb66;pkg/kubelet/pod_manager.go[pkg/kubelet/pod_manager.go][pkg/kubelet/pod/pod_manager.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/configmap"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/secret"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Manager stores and manages access to pods, maintaining the mappings
0000000000000000000000000000000000000000;;	// between static pods and mirror pods.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The kubelet discovers pod updates from 3 sources: file, http, and
0000000000000000000000000000000000000000;;	// apiserver. Pods from non-apiserver sources are called static pods, and API
0000000000000000000000000000000000000000;;	// server is not aware of the existence of static pods. In order to monitor
0000000000000000000000000000000000000000;;	// the status of such pods, the kubelet creates a mirror pod for each static
0000000000000000000000000000000000000000;;	// pod via the API server.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A mirror pod has the same pod full name (name and namespace) as its static
0000000000000000000000000000000000000000;;	// counterpart (albeit different metadata such as UID, etc). By leveraging the
0000000000000000000000000000000000000000;;	// fact that the kubelet reports the pod status using the pod full name, the
0000000000000000000000000000000000000000;;	// status of the mirror pod always reflects the actual status of the static
0000000000000000000000000000000000000000;;	// pod. When a static pod gets deleted, the associated orphaned mirror pod
0000000000000000000000000000000000000000;;	// will also be removed.
0000000000000000000000000000000000000000;;	type Manager interface {
0000000000000000000000000000000000000000;;		// GetPods returns the regular pods bound to the kubelet and their spec.
0000000000000000000000000000000000000000;;		GetPods() []*v1.Pod
0000000000000000000000000000000000000000;;		// GetPodByName returns the (non-mirror) pod that matches full name, as well as
0000000000000000000000000000000000000000;;		// whether the pod was found.
0000000000000000000000000000000000000000;;		GetPodByFullName(podFullName string) (*v1.Pod, bool)
0000000000000000000000000000000000000000;;		// GetPodByName provides the (non-mirror) pod that matches namespace and
0000000000000000000000000000000000000000;;		// name, as well as whether the pod was found.
0000000000000000000000000000000000000000;;		GetPodByName(namespace, name string) (*v1.Pod, bool)
0000000000000000000000000000000000000000;;		// GetPodByUID provides the (non-mirror) pod that matches pod UID, as well as
0000000000000000000000000000000000000000;;		// whether the pod is found.
0000000000000000000000000000000000000000;;		GetPodByUID(types.UID) (*v1.Pod, bool)
0000000000000000000000000000000000000000;;		// GetPodByMirrorPod returns the static pod for the given mirror pod and
0000000000000000000000000000000000000000;;		// whether it was known to the pod manger.
0000000000000000000000000000000000000000;;		GetPodByMirrorPod(*v1.Pod) (*v1.Pod, bool)
0000000000000000000000000000000000000000;;		// GetMirrorPodByPod returns the mirror pod for the given static pod and
0000000000000000000000000000000000000000;;		// whether it was known to the pod manager.
0000000000000000000000000000000000000000;;		GetMirrorPodByPod(*v1.Pod) (*v1.Pod, bool)
0000000000000000000000000000000000000000;;		// GetPodsAndMirrorPods returns the both regular and mirror pods.
0000000000000000000000000000000000000000;;		GetPodsAndMirrorPods() ([]*v1.Pod, []*v1.Pod)
0000000000000000000000000000000000000000;;		// SetPods replaces the internal pods with the new pods.
0000000000000000000000000000000000000000;;		// It is currently only used for testing.
0000000000000000000000000000000000000000;;		SetPods(pods []*v1.Pod)
0000000000000000000000000000000000000000;;		// AddPod adds the given pod to the manager.
0000000000000000000000000000000000000000;;		AddPod(pod *v1.Pod)
0000000000000000000000000000000000000000;;		// UpdatePod updates the given pod in the manager.
0000000000000000000000000000000000000000;;		UpdatePod(pod *v1.Pod)
0000000000000000000000000000000000000000;;		// DeletePod deletes the given pod from the manager.  For mirror pods,
0000000000000000000000000000000000000000;;		// this means deleting the mappings related to mirror pods.  For non-
0000000000000000000000000000000000000000;;		// mirror pods, this means deleting from indexes for all non-mirror pods.
0000000000000000000000000000000000000000;;		DeletePod(pod *v1.Pod)
0000000000000000000000000000000000000000;;		// DeleteOrphanedMirrorPods deletes all mirror pods which do not have
0000000000000000000000000000000000000000;;		// associated static pods. This method sends deletion requests to the API
0000000000000000000000000000000000000000;;		// server, but does NOT modify the internal pod storage in basicManager.
0000000000000000000000000000000000000000;;		DeleteOrphanedMirrorPods()
0000000000000000000000000000000000000000;;		// TranslatePodUID returns the actual UID of a pod. If the UID belongs to
0000000000000000000000000000000000000000;;		// a mirror pod, returns the UID of its static pod. Otherwise, returns the
0000000000000000000000000000000000000000;;		// original UID.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// All public-facing functions should perform this translation for UIDs
0000000000000000000000000000000000000000;;		// because user may provide a mirror pod UID, which is not recognized by
0000000000000000000000000000000000000000;;		// internal Kubelet functions.
0000000000000000000000000000000000000000;;		TranslatePodUID(uid types.UID) types.UID
0000000000000000000000000000000000000000;;		// GetUIDTranslations returns the mappings of static pod UIDs to mirror pod
0000000000000000000000000000000000000000;;		// UIDs and mirror pod UIDs to static pod UIDs.
0000000000000000000000000000000000000000;;		GetUIDTranslations() (podToMirror, mirrorToPod map[types.UID]types.UID)
0000000000000000000000000000000000000000;;		// IsMirrorPodOf returns true if mirrorPod is a correct representation of
0000000000000000000000000000000000000000;;		// pod; false otherwise.
0000000000000000000000000000000000000000;;		IsMirrorPodOf(mirrorPod, pod *v1.Pod) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		MirrorClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// basicManager is a functional Manger.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// All fields in basicManager are read-only and are updated calling SetPods,
0000000000000000000000000000000000000000;;	// AddPod, UpdatePod, or DeletePod.
0000000000000000000000000000000000000000;;	type basicManager struct {
0000000000000000000000000000000000000000;;		// Protects all internal maps.
0000000000000000000000000000000000000000;;		lock sync.RWMutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Regular pods indexed by UID.
0000000000000000000000000000000000000000;;		podByUID map[types.UID]*v1.Pod
0000000000000000000000000000000000000000;;		// Mirror pods indexed by UID.
0000000000000000000000000000000000000000;;		mirrorPodByUID map[types.UID]*v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pods indexed by full name for easy access.
0000000000000000000000000000000000000000;;		podByFullName       map[string]*v1.Pod
0000000000000000000000000000000000000000;;		mirrorPodByFullName map[string]*v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Mirror pod UID to pod UID map.
0000000000000000000000000000000000000000;;		translationByUID map[types.UID]types.UID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// basicManager is keeping secretManager and configMapManager up-to-date.
0000000000000000000000000000000000000000;;		secretManager    secret.Manager
0000000000000000000000000000000000000000;;		configMapManager configmap.Manager
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A mirror pod client to create/delete mirror pods.
0000000000000000000000000000000000000000;;		MirrorClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBasicPodManager returns a functional Manager.
0000000000000000000000000000000000000000;;	func NewBasicPodManager(client MirrorClient, secretManager secret.Manager, configMapManager configmap.Manager) Manager {
0000000000000000000000000000000000000000;;		pm := &basicManager{}
0000000000000000000000000000000000000000;;		pm.secretManager = secretManager
0000000000000000000000000000000000000000;;		pm.configMapManager = configMapManager
0000000000000000000000000000000000000000;;		pm.MirrorClient = client
0000000000000000000000000000000000000000;;		pm.SetPods(nil)
0000000000000000000000000000000000000000;;		return pm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set the internal pods based on the new pods.
0000000000000000000000000000000000000000;;	func (pm *basicManager) SetPods(newPods []*v1.Pod) {
0000000000000000000000000000000000000000;;		pm.lock.Lock()
0000000000000000000000000000000000000000;;		defer pm.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pm.podByUID = make(map[types.UID]*v1.Pod)
0000000000000000000000000000000000000000;;		pm.podByFullName = make(map[string]*v1.Pod)
0000000000000000000000000000000000000000;;		pm.mirrorPodByUID = make(map[types.UID]*v1.Pod)
0000000000000000000000000000000000000000;;		pm.mirrorPodByFullName = make(map[string]*v1.Pod)
0000000000000000000000000000000000000000;;		pm.translationByUID = make(map[types.UID]types.UID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pm.updatePodsInternal(newPods...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *basicManager) AddPod(pod *v1.Pod) {
0000000000000000000000000000000000000000;;		pm.UpdatePod(pod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *basicManager) UpdatePod(pod *v1.Pod) {
0000000000000000000000000000000000000000;;		pm.lock.Lock()
0000000000000000000000000000000000000000;;		defer pm.lock.Unlock()
0000000000000000000000000000000000000000;;		pm.updatePodsInternal(pod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updatePodsInternal replaces the given pods in the current state of the
0000000000000000000000000000000000000000;;	// manager, updating the various indices.  The caller is assumed to hold the
0000000000000000000000000000000000000000;;	// lock.
0000000000000000000000000000000000000000;;	func (pm *basicManager) updatePodsInternal(pods ...*v1.Pod) {
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			if pm.secretManager != nil {
0000000000000000000000000000000000000000;;				// TODO: Consider detecting only status update and in such case do
0000000000000000000000000000000000000000;;				// not register pod, as it doesn't really matter.
0000000000000000000000000000000000000000;;				pm.secretManager.RegisterPod(pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pm.configMapManager != nil {
0000000000000000000000000000000000000000;;				// TODO: Consider detecting only status update and in such case do
0000000000000000000000000000000000000000;;				// not register pod, as it doesn't really matter.
0000000000000000000000000000000000000000;;				pm.configMapManager.RegisterPod(pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podFullName := kubecontainer.GetPodFullName(pod)
0000000000000000000000000000000000000000;;			if IsMirrorPod(pod) {
0000000000000000000000000000000000000000;;				pm.mirrorPodByUID[pod.UID] = pod
0000000000000000000000000000000000000000;;				pm.mirrorPodByFullName[podFullName] = pod
0000000000000000000000000000000000000000;;				if p, ok := pm.podByFullName[podFullName]; ok {
0000000000000000000000000000000000000000;;					pm.translationByUID[pod.UID] = p.UID
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				pm.podByUID[pod.UID] = pod
0000000000000000000000000000000000000000;;				pm.podByFullName[podFullName] = pod
0000000000000000000000000000000000000000;;				if mirror, ok := pm.mirrorPodByFullName[podFullName]; ok {
0000000000000000000000000000000000000000;;					pm.translationByUID[mirror.UID] = pod.UID
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *basicManager) DeletePod(pod *v1.Pod) {
0000000000000000000000000000000000000000;;		pm.lock.Lock()
0000000000000000000000000000000000000000;;		defer pm.lock.Unlock()
0000000000000000000000000000000000000000;;		if pm.secretManager != nil {
0000000000000000000000000000000000000000;;			pm.secretManager.UnregisterPod(pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pm.configMapManager != nil {
0000000000000000000000000000000000000000;;			pm.configMapManager.UnregisterPod(pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podFullName := kubecontainer.GetPodFullName(pod)
0000000000000000000000000000000000000000;;		if IsMirrorPod(pod) {
0000000000000000000000000000000000000000;;			delete(pm.mirrorPodByUID, pod.UID)
0000000000000000000000000000000000000000;;			delete(pm.mirrorPodByFullName, podFullName)
0000000000000000000000000000000000000000;;			delete(pm.translationByUID, pod.UID)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			delete(pm.podByUID, pod.UID)
0000000000000000000000000000000000000000;;			delete(pm.podByFullName, podFullName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *basicManager) GetPods() []*v1.Pod {
0000000000000000000000000000000000000000;;		pm.lock.RLock()
0000000000000000000000000000000000000000;;		defer pm.lock.RUnlock()
0000000000000000000000000000000000000000;;		return podsMapToPods(pm.podByUID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *basicManager) GetPodsAndMirrorPods() ([]*v1.Pod, []*v1.Pod) {
0000000000000000000000000000000000000000;;		pm.lock.RLock()
0000000000000000000000000000000000000000;;		defer pm.lock.RUnlock()
0000000000000000000000000000000000000000;;		pods := podsMapToPods(pm.podByUID)
0000000000000000000000000000000000000000;;		mirrorPods := podsMapToPods(pm.mirrorPodByUID)
0000000000000000000000000000000000000000;;		return pods, mirrorPods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *basicManager) GetPodByUID(uid types.UID) (*v1.Pod, bool) {
0000000000000000000000000000000000000000;;		pm.lock.RLock()
0000000000000000000000000000000000000000;;		defer pm.lock.RUnlock()
0000000000000000000000000000000000000000;;		pod, ok := pm.podByUID[uid]
0000000000000000000000000000000000000000;;		return pod, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *basicManager) GetPodByName(namespace, name string) (*v1.Pod, bool) {
0000000000000000000000000000000000000000;;		podFullName := kubecontainer.BuildPodFullName(name, namespace)
0000000000000000000000000000000000000000;;		return pm.GetPodByFullName(podFullName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *basicManager) GetPodByFullName(podFullName string) (*v1.Pod, bool) {
0000000000000000000000000000000000000000;;		pm.lock.RLock()
0000000000000000000000000000000000000000;;		defer pm.lock.RUnlock()
0000000000000000000000000000000000000000;;		pod, ok := pm.podByFullName[podFullName]
0000000000000000000000000000000000000000;;		return pod, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *basicManager) TranslatePodUID(uid types.UID) types.UID {
0000000000000000000000000000000000000000;;		if uid == "" {
0000000000000000000000000000000000000000;;			return uid
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pm.lock.RLock()
0000000000000000000000000000000000000000;;		defer pm.lock.RUnlock()
0000000000000000000000000000000000000000;;		if translated, ok := pm.translationByUID[uid]; ok {
0000000000000000000000000000000000000000;;			return translated
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uid
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *basicManager) GetUIDTranslations() (podToMirror, mirrorToPod map[types.UID]types.UID) {
0000000000000000000000000000000000000000;;		pm.lock.RLock()
0000000000000000000000000000000000000000;;		defer pm.lock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podToMirror = make(map[types.UID]types.UID, len(pm.translationByUID))
0000000000000000000000000000000000000000;;		mirrorToPod = make(map[types.UID]types.UID, len(pm.translationByUID))
0000000000000000000000000000000000000000;;		// Insert empty translation mapping for all static pods.
0000000000000000000000000000000000000000;;		for uid, pod := range pm.podByUID {
0000000000000000000000000000000000000000;;			if !IsStaticPod(pod) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podToMirror[uid] = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Fill in translations. Notice that if there is no mirror pod for a
0000000000000000000000000000000000000000;;		// static pod, its uid will be translated into empty string "". This
0000000000000000000000000000000000000000;;		// is WAI, from the caller side we can know that the static pod doesn't
0000000000000000000000000000000000000000;;		// have a corresponding mirror pod instead of using static pod uid directly.
0000000000000000000000000000000000000000;;		for k, v := range pm.translationByUID {
0000000000000000000000000000000000000000;;			mirrorToPod[k] = v
0000000000000000000000000000000000000000;;			podToMirror[v] = k
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return podToMirror, mirrorToPod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *basicManager) getOrphanedMirrorPodNames() []string {
0000000000000000000000000000000000000000;;		pm.lock.RLock()
0000000000000000000000000000000000000000;;		defer pm.lock.RUnlock()
0000000000000000000000000000000000000000;;		var podFullNames []string
0000000000000000000000000000000000000000;;		for podFullName := range pm.mirrorPodByFullName {
0000000000000000000000000000000000000000;;			if _, ok := pm.podByFullName[podFullName]; !ok {
0000000000000000000000000000000000000000;;				podFullNames = append(podFullNames, podFullName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return podFullNames
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *basicManager) DeleteOrphanedMirrorPods() {
0000000000000000000000000000000000000000;;		podFullNames := pm.getOrphanedMirrorPodNames()
0000000000000000000000000000000000000000;;		for _, podFullName := range podFullNames {
0000000000000000000000000000000000000000;;			pm.MirrorClient.DeleteMirrorPod(podFullName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *basicManager) IsMirrorPodOf(mirrorPod, pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		// Check name and namespace first.
0000000000000000000000000000000000000000;;		if pod.Name != mirrorPod.Name || pod.Namespace != mirrorPod.Namespace {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hash, ok := getHashFromMirrorPod(mirrorPod)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hash == getPodHash(pod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func podsMapToPods(UIDMap map[types.UID]*v1.Pod) []*v1.Pod {
0000000000000000000000000000000000000000;;		pods := make([]*v1.Pod, 0, len(UIDMap))
0000000000000000000000000000000000000000;;		for _, pod := range UIDMap {
0000000000000000000000000000000000000000;;			pods = append(pods, pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *basicManager) GetMirrorPodByPod(pod *v1.Pod) (*v1.Pod, bool) {
0000000000000000000000000000000000000000;;		pm.lock.RLock()
0000000000000000000000000000000000000000;;		defer pm.lock.RUnlock()
0000000000000000000000000000000000000000;;		mirrorPod, ok := pm.mirrorPodByFullName[kubecontainer.GetPodFullName(pod)]
0000000000000000000000000000000000000000;;		return mirrorPod, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *basicManager) GetPodByMirrorPod(mirrorPod *v1.Pod) (*v1.Pod, bool) {
0000000000000000000000000000000000000000;;		pm.lock.RLock()
0000000000000000000000000000000000000000;;		defer pm.lock.RUnlock()
0000000000000000000000000000000000000000;;		pod, ok := pm.podByFullName[kubecontainer.GetPodFullName(mirrorPod)]
0000000000000000000000000000000000000000;;		return pod, ok
0000000000000000000000000000000000000000;;	}
