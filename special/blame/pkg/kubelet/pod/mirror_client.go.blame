0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
1e8b1aa3caddbd8b5de2af0dfd069940656dcfd6;pkg/kubelet/mirror_client.go[pkg/kubelet/mirror_client.go][pkg/kubelet/pod/mirror_client.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		kubetypes "k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MirrorClient knows how to create/delete a mirror pod in the API server.
0000000000000000000000000000000000000000;;	type MirrorClient interface {
0000000000000000000000000000000000000000;;		// CreateMirrorPod creates a mirror pod in the API server for the given
0000000000000000000000000000000000000000;;		// pod or returns an error.  The mirror pod will have the same annotations
0000000000000000000000000000000000000000;;		// as the given pod as well as an extra annotation containing the hash of
0000000000000000000000000000000000000000;;		// the static pod.
0000000000000000000000000000000000000000;;		CreateMirrorPod(pod *v1.Pod) error
0000000000000000000000000000000000000000;;		// DeleteMirrorPod deletes the mirror pod with the given full name from
0000000000000000000000000000000000000000;;		// the API server or returns an error.
0000000000000000000000000000000000000000;;		DeleteMirrorPod(podFullName string) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// basicMirrorClient is a functional MirrorClient.  Mirror pods are stored in
0000000000000000000000000000000000000000;;	// the kubelet directly because they need to be in sync with the internal
0000000000000000000000000000000000000000;;	// pods.
0000000000000000000000000000000000000000;;	type basicMirrorClient struct {
0000000000000000000000000000000000000000;;		apiserverClient clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBasicMirrorClient returns a new MirrorClient.
0000000000000000000000000000000000000000;;	func NewBasicMirrorClient(apiserverClient clientset.Interface) MirrorClient {
0000000000000000000000000000000000000000;;		return &basicMirrorClient{apiserverClient: apiserverClient}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (mc *basicMirrorClient) CreateMirrorPod(pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		if mc.apiserverClient == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Make a copy of the pod.
0000000000000000000000000000000000000000;;		copyPod := *pod
0000000000000000000000000000000000000000;;		copyPod.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range pod.Annotations {
0000000000000000000000000000000000000000;;			copyPod.Annotations[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hash := getPodHash(pod)
0000000000000000000000000000000000000000;;		copyPod.Annotations[kubetypes.ConfigMirrorAnnotationKey] = hash
0000000000000000000000000000000000000000;;		apiPod, err := mc.apiserverClient.Core().Pods(copyPod.Namespace).Create(&copyPod)
0000000000000000000000000000000000000000;;		if err != nil && errors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;			// Check if the existing pod is the same as the pod we want to create.
0000000000000000000000000000000000000000;;			if h, ok := apiPod.Annotations[kubetypes.ConfigMirrorAnnotationKey]; ok && h == hash {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (mc *basicMirrorClient) DeleteMirrorPod(podFullName string) error {
0000000000000000000000000000000000000000;;		if mc.apiserverClient == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name, namespace, err := kubecontainer.ParsePodFullName(podFullName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to parse a pod full name %q", podFullName)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Deleting a mirror pod %q", podFullName)
0000000000000000000000000000000000000000;;		// TODO(random-liu): Delete the mirror pod with uid precondition in mirror pod manager
0000000000000000000000000000000000000000;;		if err := mc.apiserverClient.Core().Pods(namespace).Delete(name, metav1.NewDeleteOptions(0)); err != nil && !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed deleting a mirror pod %q: %v", podFullName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IsStaticPod(pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		source, err := kubetypes.GetPodSource(pod)
0000000000000000000000000000000000000000;;		return err == nil && source != kubetypes.ApiserverSource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IsMirrorPod(pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		_, ok := pod.Annotations[kubetypes.ConfigMirrorAnnotationKey]
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getHashFromMirrorPod(pod *v1.Pod) (string, bool) {
0000000000000000000000000000000000000000;;		hash, ok := pod.Annotations[kubetypes.ConfigMirrorAnnotationKey]
0000000000000000000000000000000000000000;;		return hash, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPodHash(pod *v1.Pod) string {
0000000000000000000000000000000000000000;;		// The annotation exists for all static pods.
0000000000000000000000000000000000000000;;		return pod.Annotations[kubetypes.ConfigHashAnnotationKey]
0000000000000000000000000000000000000000;;	}
