0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1be90f193c1ba5f6706e9fb38d8c8140545c31fc;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/require"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNodeIPParam(t *testing.T) {
0000000000000000000000000000000000000000;;		testKubelet := newTestKubelet(t, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;		defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;		kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			nodeIP   string
0000000000000000000000000000000000000000;;			success  bool
0000000000000000000000000000000000000000;;			testName string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				nodeIP:   "",
0000000000000000000000000000000000000000;;				success:  true,
0000000000000000000000000000000000000000;;				testName: "IP not set",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				nodeIP:   "127.0.0.1",
0000000000000000000000000000000000000000;;				success:  false,
0000000000000000000000000000000000000000;;				testName: "loopback address",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				nodeIP:   "FE80::0202:B3FF:FE1E:8329",
0000000000000000000000000000000000000000;;				success:  false,
0000000000000000000000000000000000000000;;				testName: "IPv6 address",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				nodeIP:   "1.2.3.4",
0000000000000000000000000000000000000000;;				success:  false,
0000000000000000000000000000000000000000;;				testName: "IPv4 address that doesn't belong to host",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			kubelet.nodeIP = net.ParseIP(test.nodeIP)
0000000000000000000000000000000000000000;;			err := kubelet.validateNodeIP()
0000000000000000000000000000000000000000;;			if test.success {
0000000000000000000000000000000000000000;;				assert.NoError(t, err, "test %s", test.testName)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				assert.Error(t, err, fmt.Sprintf("test %s", test.testName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestParseResolvConf(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			data        string
0000000000000000000000000000000000000000;;			nameservers []string
0000000000000000000000000000000000000000;;			searches    []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"", []string{}, []string{}},
0000000000000000000000000000000000000000;;			{" ", []string{}, []string{}},
0000000000000000000000000000000000000000;;			{"\n", []string{}, []string{}},
0000000000000000000000000000000000000000;;			{"\t\n\t", []string{}, []string{}},
0000000000000000000000000000000000000000;;			{"#comment\n", []string{}, []string{}},
0000000000000000000000000000000000000000;;			{" #comment\n", []string{}, []string{}},
0000000000000000000000000000000000000000;;			{"#comment\n#comment", []string{}, []string{}},
0000000000000000000000000000000000000000;;			{"#comment\nnameserver", []string{}, []string{}},
0000000000000000000000000000000000000000;;			{"#comment\nnameserver\nsearch", []string{}, []string{}},
0000000000000000000000000000000000000000;;			{"nameserver 1.2.3.4", []string{"1.2.3.4"}, []string{}},
0000000000000000000000000000000000000000;;			{" nameserver 1.2.3.4", []string{"1.2.3.4"}, []string{}},
0000000000000000000000000000000000000000;;			{"\tnameserver 1.2.3.4", []string{"1.2.3.4"}, []string{}},
0000000000000000000000000000000000000000;;			{"nameserver\t1.2.3.4", []string{"1.2.3.4"}, []string{}},
0000000000000000000000000000000000000000;;			{"nameserver \t 1.2.3.4", []string{"1.2.3.4"}, []string{}},
0000000000000000000000000000000000000000;;			{"nameserver 1.2.3.4\nnameserver 5.6.7.8", []string{"1.2.3.4", "5.6.7.8"}, []string{}},
0000000000000000000000000000000000000000;;			{"nameserver 1.2.3.4 #comment", []string{"1.2.3.4"}, []string{}},
0000000000000000000000000000000000000000;;			{"search foo", []string{}, []string{"foo"}},
0000000000000000000000000000000000000000;;			{"search foo bar", []string{}, []string{"foo", "bar"}},
0000000000000000000000000000000000000000;;			{"search foo bar bat\n", []string{}, []string{"foo", "bar", "bat"}},
0000000000000000000000000000000000000000;;			{"search foo\nsearch bar", []string{}, []string{"bar"}},
0000000000000000000000000000000000000000;;			{"nameserver 1.2.3.4\nsearch foo bar", []string{"1.2.3.4"}, []string{"foo", "bar"}},
0000000000000000000000000000000000000000;;			{"nameserver 1.2.3.4\nsearch foo\nnameserver 5.6.7.8\nsearch bar", []string{"1.2.3.4", "5.6.7.8"}, []string{"bar"}},
0000000000000000000000000000000000000000;;			{"#comment\nnameserver 1.2.3.4\n#comment\nsearch foo\ncomment", []string{"1.2.3.4"}, []string{"foo"}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testKubelet := newTestKubelet(t, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;		defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;		kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			ns, srch, err := kubelet.parseResolvConf(strings.NewReader(tc.data))
0000000000000000000000000000000000000000;;			require.NoError(t, err)
0000000000000000000000000000000000000000;;			assert.EqualValues(t, tc.nameservers, ns, "test case [%d]: name servers", i)
0000000000000000000000000000000000000000;;			assert.EqualValues(t, tc.searches, srch, "test case [%d] searches", i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestComposeDNSSearch(t *testing.T) {
0000000000000000000000000000000000000000;;		testKubelet := newTestKubelet(t, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;		defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;		kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		recorder := record.NewFakeRecorder(20)
0000000000000000000000000000000000000000;;		kubelet.recorder = recorder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := podWithUidNameNs("", "test_pod", "testNS")
0000000000000000000000000000000000000000;;		kubelet.clusterDomain = "TEST"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			dnsNames     []string
0000000000000000000000000000000000000000;;			hostNames    []string
0000000000000000000000000000000000000000;;			resultSearch []string
0000000000000000000000000000000000000000;;			events       []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				[]string{"testNS.svc.TEST", "svc.TEST", "TEST"},
0000000000000000000000000000000000000000;;				[]string{},
0000000000000000000000000000000000000000;;				[]string{"testNS.svc.TEST", "svc.TEST", "TEST"},
0000000000000000000000000000000000000000;;				[]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				[]string{"testNS.svc.TEST", "svc.TEST", "TEST"},
0000000000000000000000000000000000000000;;				[]string{"AAA", "svc.TEST", "BBB", "TEST"},
0000000000000000000000000000000000000000;;				[]string{"testNS.svc.TEST", "svc.TEST", "TEST", "AAA", "BBB"},
0000000000000000000000000000000000000000;;				[]string{
0000000000000000000000000000000000000000;;					"Found and omitted duplicated dns domain in host search line: 'svc.TEST' during merging with cluster dns domains",
0000000000000000000000000000000000000000;;					"Found and omitted duplicated dns domain in host search line: 'TEST' during merging with cluster dns domains",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				[]string{"testNS.svc.TEST", "svc.TEST", "TEST"},
0000000000000000000000000000000000000000;;				[]string{"AAA", strings.Repeat("B", 256), "BBB"},
0000000000000000000000000000000000000000;;				[]string{"testNS.svc.TEST", "svc.TEST", "TEST", "AAA"},
0000000000000000000000000000000000000000;;				[]string{"Search Line limits were exceeded, some dns names have been omitted, the applied search line is: testNS.svc.TEST svc.TEST TEST AAA"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				[]string{"testNS.svc.TEST", "svc.TEST", "TEST"},
0000000000000000000000000000000000000000;;				[]string{"AAA", "TEST", "BBB", "TEST", "CCC", "DDD"},
0000000000000000000000000000000000000000;;				[]string{"testNS.svc.TEST", "svc.TEST", "TEST", "AAA", "BBB", "CCC"},
0000000000000000000000000000000000000000;;				[]string{
0000000000000000000000000000000000000000;;					"Found and omitted duplicated dns domain in host search line: 'TEST' during merging with cluster dns domains",
0000000000000000000000000000000000000000;;					"Found and omitted duplicated dns domain in host search line: 'TEST' during merging with cluster dns domains",
0000000000000000000000000000000000000000;;					"Search Line limits were exceeded, some dns names have been omitted, the applied search line is: testNS.svc.TEST svc.TEST TEST AAA BBB CCC",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fetchEvent := func(recorder *record.FakeRecorder) string {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case event := <-recorder.Events:
0000000000000000000000000000000000000000;;				return event
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return "No more events!"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			dnsSearch := kubelet.formDNSSearch(tc.hostNames, pod)
0000000000000000000000000000000000000000;;			assert.EqualValues(t, tc.resultSearch, dnsSearch, "test [%d]", i)
0000000000000000000000000000000000000000;;			for _, expectedEvent := range tc.events {
0000000000000000000000000000000000000000;;				expected := fmt.Sprintf("%s %s %s", v1.EventTypeWarning, "DNSSearchForming", expectedEvent)
0000000000000000000000000000000000000000;;				event := fetchEvent(recorder)
0000000000000000000000000000000000000000;;				assert.Equal(t, expected, event, "test [%d]", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetIPTablesMark(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			bit    int
0000000000000000000000000000000000000000;;			expect string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				14,
0000000000000000000000000000000000000000;;				"0x00004000/0x00004000",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				15,
0000000000000000000000000000000000000000;;				"0x00008000/0x00008000",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tc := range tests {
0000000000000000000000000000000000000000;;			res := getIPTablesMark(tc.bit)
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.expect, res, "input %d", tc.bit)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
