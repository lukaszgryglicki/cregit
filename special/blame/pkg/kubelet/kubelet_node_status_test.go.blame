0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
aab5f6785b93caaf7c0cb91f56f21ffed6107f3d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		goruntime "runtime"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/require"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cadvisorapi "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		cadvisorapiv2 "github.com/google/cadvisor/info/v2"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/rand"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/cm"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/sliceutils"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/version"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		maxImageTagsForTest = 20
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateTestingImageList generate randomly generated image list and corresponding expectedImageList.
0000000000000000000000000000000000000000;;	func generateTestingImageList(count int) ([]kubecontainer.Image, []v1.ContainerImage) {
0000000000000000000000000000000000000000;;		// imageList is randomly generated image list
0000000000000000000000000000000000000000;;		var imageList []kubecontainer.Image
0000000000000000000000000000000000000000;;		for ; count > 0; count-- {
0000000000000000000000000000000000000000;;			imageItem := kubecontainer.Image{
0000000000000000000000000000000000000000;;				ID:       string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				RepoTags: generateImageTags(),
0000000000000000000000000000000000000000;;				Size:     rand.Int63nRange(minImgSize, maxImgSize+1),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			imageList = append(imageList, imageItem)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// expectedImageList is generated by imageList according to size and maxImagesInNodeStatus
0000000000000000000000000000000000000000;;		// 1. sort the imageList by size
0000000000000000000000000000000000000000;;		sort.Sort(sliceutils.ByImageSize(imageList))
0000000000000000000000000000000000000000;;		// 2. convert sorted imageList to v1.ContainerImage list
0000000000000000000000000000000000000000;;		var expectedImageList []v1.ContainerImage
0000000000000000000000000000000000000000;;		for _, kubeImage := range imageList {
0000000000000000000000000000000000000000;;			apiImage := v1.ContainerImage{
0000000000000000000000000000000000000000;;				Names:     kubeImage.RepoTags[0:maxNamesPerImageInNodeStatus],
0000000000000000000000000000000000000000;;				SizeBytes: kubeImage.Size,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expectedImageList = append(expectedImageList, apiImage)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// 3. only returns the top maxImagesInNodeStatus images in expectedImageList
0000000000000000000000000000000000000000;;		return imageList, expectedImageList[0:maxImagesInNodeStatus]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateImageTags() []string {
0000000000000000000000000000000000000000;;		var tagList []string
0000000000000000000000000000000000000000;;		// Generate > maxNamesPerImageInNodeStatus tags so that the test can verify
0000000000000000000000000000000000000000;;		// that kubelet report up to maxNamesPerImageInNodeStatus tags.
0000000000000000000000000000000000000000;;		count := rand.IntnRange(maxNamesPerImageInNodeStatus+1, maxImageTagsForTest+1)
0000000000000000000000000000000000000000;;		for ; count > 0; count-- {
0000000000000000000000000000000000000000;;			tagList = append(tagList, "gcr.io/google_containers:v"+strconv.Itoa(count))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tagList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func applyNodeStatusPatch(originalNode *v1.Node, patch []byte) (*v1.Node, error) {
0000000000000000000000000000000000000000;;		original, err := json.Marshal(originalNode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to marshal original node %#v: %v", originalNode, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		updated, err := strategicpatch.StrategicMergePatch(original, patch, v1.Node{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to apply strategic merge patch %q on node %#v: %v",
0000000000000000000000000000000000000000;;				patch, originalNode, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		updatedNode := &v1.Node{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(updated, updatedNode); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to unmarshal updated node %q: %v", updated, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return updatedNode, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type localCM struct {
0000000000000000000000000000000000000000;;		cm.ContainerManager
0000000000000000000000000000000000000000;;		allocatable v1.ResourceList
0000000000000000000000000000000000000000;;		capacity    v1.ResourceList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lcm *localCM) GetNodeAllocatableReservation() v1.ResourceList {
0000000000000000000000000000000000000000;;		return lcm.allocatable
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lcm *localCM) GetCapacity() v1.ResourceList {
0000000000000000000000000000000000000000;;		return lcm.capacity
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateNewNodeStatus(t *testing.T) {
0000000000000000000000000000000000000000;;		// generate one more than maxImagesInNodeStatus in inputImageList
0000000000000000000000000000000000000000;;		inputImageList, expectedImageList := generateTestingImageList(maxImagesInNodeStatus + 1)
0000000000000000000000000000000000000000;;		testKubelet := newTestKubeletWithImageList(
0000000000000000000000000000000000000000;;			t, inputImageList, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;		defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;		kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;		kubelet.containerManager = &localCM{
0000000000000000000000000000000000000000;;			ContainerManager: cm.NewStubContainerManager(),
0000000000000000000000000000000000000000;;			allocatable: v1.ResourceList{
0000000000000000000000000000000000000000;;				v1.ResourceCPU:    *resource.NewMilliQuantity(200, resource.DecimalSI),
0000000000000000000000000000000000000000;;				v1.ResourceMemory: *resource.NewQuantity(100E6, resource.BinarySI),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;				v1.ResourceCPU:    *resource.NewMilliQuantity(2000, resource.DecimalSI),
0000000000000000000000000000000000000000;;				v1.ResourceMemory: *resource.NewQuantity(10E9, resource.BinarySI),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kubeClient := testKubelet.fakeKubeClient
0000000000000000000000000000000000000000;;		existingNode := v1.Node{ObjectMeta: metav1.ObjectMeta{Name: testKubeletHostname}}
0000000000000000000000000000000000000000;;		kubeClient.ReactionChain = fake.NewSimpleClientset(&v1.NodeList{Items: []v1.Node{existingNode}}).ReactionChain
0000000000000000000000000000000000000000;;		machineInfo := &cadvisorapi.MachineInfo{
0000000000000000000000000000000000000000;;			MachineID:      "123",
0000000000000000000000000000000000000000;;			SystemUUID:     "abc",
0000000000000000000000000000000000000000;;			BootID:         "1b3",
0000000000000000000000000000000000000000;;			NumCores:       2,
0000000000000000000000000000000000000000;;			MemoryCapacity: 10E9, // 10G
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mockCadvisor := testKubelet.fakeCadvisor
0000000000000000000000000000000000000000;;		mockCadvisor.On("Start").Return(nil)
0000000000000000000000000000000000000000;;		mockCadvisor.On("MachineInfo").Return(machineInfo, nil)
0000000000000000000000000000000000000000;;		versionInfo := &cadvisorapi.VersionInfo{
0000000000000000000000000000000000000000;;			KernelVersion:      "3.16.0-0.bpo.4-amd64",
0000000000000000000000000000000000000000;;			ContainerOsVersion: "Debian GNU/Linux 7 (wheezy)",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mockCadvisor.On("VersionInfo").Return(versionInfo, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make kubelet report that it has sufficient disk space.
0000000000000000000000000000000000000000;;		require.NoError(t, updateDiskSpacePolicy(kubelet, mockCadvisor, 500, 500, 200, 200, 100, 100))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedNode := &v1.Node{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: testKubeletHostname},
0000000000000000000000000000000000000000;;			Spec:       v1.NodeSpec{},
0000000000000000000000000000000000000000;;			Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;				Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:               v1.NodeOutOfDisk,
0000000000000000000000000000000000000000;;						Status:             v1.ConditionFalse,
0000000000000000000000000000000000000000;;						Reason:             "KubeletHasSufficientDisk",
0000000000000000000000000000000000000000;;						Message:            fmt.Sprintf("kubelet has sufficient disk space available"),
0000000000000000000000000000000000000000;;						LastHeartbeatTime:  metav1.Time{},
0000000000000000000000000000000000000000;;						LastTransitionTime: metav1.Time{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:               v1.NodeMemoryPressure,
0000000000000000000000000000000000000000;;						Status:             v1.ConditionFalse,
0000000000000000000000000000000000000000;;						Reason:             "KubeletHasSufficientMemory",
0000000000000000000000000000000000000000;;						Message:            fmt.Sprintf("kubelet has sufficient memory available"),
0000000000000000000000000000000000000000;;						LastHeartbeatTime:  metav1.Time{},
0000000000000000000000000000000000000000;;						LastTransitionTime: metav1.Time{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:               v1.NodeDiskPressure,
0000000000000000000000000000000000000000;;						Status:             v1.ConditionFalse,
0000000000000000000000000000000000000000;;						Reason:             "KubeletHasNoDiskPressure",
0000000000000000000000000000000000000000;;						Message:            fmt.Sprintf("kubelet has no disk pressure"),
0000000000000000000000000000000000000000;;						LastHeartbeatTime:  metav1.Time{},
0000000000000000000000000000000000000000;;						LastTransitionTime: metav1.Time{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;						Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;						Reason:             "KubeletReady",
0000000000000000000000000000000000000000;;						Message:            fmt.Sprintf("kubelet is posting ready status"),
0000000000000000000000000000000000000000;;						LastHeartbeatTime:  metav1.Time{},
0000000000000000000000000000000000000000;;						LastTransitionTime: metav1.Time{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				NodeInfo: v1.NodeSystemInfo{
0000000000000000000000000000000000000000;;					MachineID:               "123",
0000000000000000000000000000000000000000;;					SystemUUID:              "abc",
0000000000000000000000000000000000000000;;					BootID:                  "1b3",
0000000000000000000000000000000000000000;;					KernelVersion:           "3.16.0-0.bpo.4-amd64",
0000000000000000000000000000000000000000;;					OSImage:                 "Debian GNU/Linux 7 (wheezy)",
0000000000000000000000000000000000000000;;					OperatingSystem:         goruntime.GOOS,
0000000000000000000000000000000000000000;;					Architecture:            goruntime.GOARCH,
0000000000000000000000000000000000000000;;					ContainerRuntimeVersion: "test://1.5.0",
0000000000000000000000000000000000000000;;					KubeletVersion:          version.Get().String(),
0000000000000000000000000000000000000000;;					KubeProxyVersion:        version.Get().String(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU:    *resource.NewMilliQuantity(2000, resource.DecimalSI),
0000000000000000000000000000000000000000;;					v1.ResourceMemory: *resource.NewQuantity(10E9, resource.BinarySI),
0000000000000000000000000000000000000000;;					v1.ResourcePods:   *resource.NewQuantity(0, resource.DecimalSI),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Allocatable: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU:    *resource.NewMilliQuantity(1800, resource.DecimalSI),
0000000000000000000000000000000000000000;;					v1.ResourceMemory: *resource.NewQuantity(9900E6, resource.BinarySI),
0000000000000000000000000000000000000000;;					v1.ResourcePods:   *resource.NewQuantity(0, resource.DecimalSI),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Addresses: []v1.NodeAddress{
0000000000000000000000000000000000000000;;					{Type: v1.NodeInternalIP, Address: "127.0.0.1"},
0000000000000000000000000000000000000000;;					{Type: v1.NodeHostName, Address: testKubeletHostname},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Images: expectedImageList,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubelet.updateRuntimeUp()
0000000000000000000000000000000000000000;;		assert.NoError(t, kubelet.updateNodeStatus())
0000000000000000000000000000000000000000;;		actions := kubeClient.Actions()
0000000000000000000000000000000000000000;;		require.Len(t, actions, 2)
0000000000000000000000000000000000000000;;		require.True(t, actions[1].Matches("patch", "nodes"))
0000000000000000000000000000000000000000;;		require.Equal(t, actions[1].GetSubresource(), "status")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatedNode, err := applyNodeStatusPatch(&existingNode, actions[1].(core.PatchActionImpl).GetPatch())
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		for i, cond := range updatedNode.Status.Conditions {
0000000000000000000000000000000000000000;;			assert.False(t, cond.LastHeartbeatTime.IsZero(), "LastHeartbeatTime for %v condition is zero", cond.Type)
0000000000000000000000000000000000000000;;			assert.False(t, cond.LastTransitionTime.IsZero(), "LastTransitionTime for %v condition  is zero", cond.Type)
0000000000000000000000000000000000000000;;			updatedNode.Status.Conditions[i].LastHeartbeatTime = metav1.Time{}
0000000000000000000000000000000000000000;;			updatedNode.Status.Conditions[i].LastTransitionTime = metav1.Time{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Version skew workaround. See: https://github.com/kubernetes/kubernetes/issues/16961
0000000000000000000000000000000000000000;;		assert.Equal(t, v1.NodeReady, updatedNode.Status.Conditions[len(updatedNode.Status.Conditions)-1].Type, "NotReady should be last")
0000000000000000000000000000000000000000;;		assert.Len(t, updatedNode.Status.Images, maxImagesInNodeStatus)
0000000000000000000000000000000000000000;;		assert.True(t, apiequality.Semantic.DeepEqual(expectedNode, updatedNode), "%s", diff.ObjectDiff(expectedNode, updatedNode))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateNewNodeOutOfDiskStatusWithTransitionFrequency(t *testing.T) {
0000000000000000000000000000000000000000;;		testKubelet := newTestKubelet(t, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;		defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;		kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;		kubelet.containerManager = &localCM{
0000000000000000000000000000000000000000;;			ContainerManager: cm.NewStubContainerManager(),
0000000000000000000000000000000000000000;;			allocatable: v1.ResourceList{
0000000000000000000000000000000000000000;;				v1.ResourceCPU:    *resource.NewMilliQuantity(200, resource.DecimalSI),
0000000000000000000000000000000000000000;;				v1.ResourceMemory: *resource.NewQuantity(100E6, resource.BinarySI),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;				v1.ResourceCPU:    *resource.NewMilliQuantity(2000, resource.DecimalSI),
0000000000000000000000000000000000000000;;				v1.ResourceMemory: *resource.NewQuantity(20E9, resource.BinarySI),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := testKubelet.fakeKubeClient
0000000000000000000000000000000000000000;;		existingNode := v1.Node{ObjectMeta: metav1.ObjectMeta{Name: testKubeletHostname}}
0000000000000000000000000000000000000000;;		kubeClient.ReactionChain = fake.NewSimpleClientset(&v1.NodeList{Items: []v1.Node{existingNode}}).ReactionChain
0000000000000000000000000000000000000000;;		machineInfo := &cadvisorapi.MachineInfo{
0000000000000000000000000000000000000000;;			MachineID:      "123",
0000000000000000000000000000000000000000;;			SystemUUID:     "abc",
0000000000000000000000000000000000000000;;			BootID:         "1b3",
0000000000000000000000000000000000000000;;			NumCores:       2,
0000000000000000000000000000000000000000;;			MemoryCapacity: 1024,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mockCadvisor := testKubelet.fakeCadvisor
0000000000000000000000000000000000000000;;		mockCadvisor.On("Start").Return(nil)
0000000000000000000000000000000000000000;;		mockCadvisor.On("MachineInfo").Return(machineInfo, nil)
0000000000000000000000000000000000000000;;		versionInfo := &cadvisorapi.VersionInfo{
0000000000000000000000000000000000000000;;			KernelVersion:      "3.16.0-0.bpo.4-amd64",
0000000000000000000000000000000000000000;;			ContainerOsVersion: "Debian GNU/Linux 7 (wheezy)",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mockCadvisor.On("VersionInfo").Return(versionInfo, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make Kubelet report that it has sufficient disk space.
0000000000000000000000000000000000000000;;		err := updateDiskSpacePolicy(kubelet, mockCadvisor, 500, 500, 200, 200, 100, 100)
0000000000000000000000000000000000000000;;		require.NoError(t, err, "update the disk space manager")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubelet.outOfDiskTransitionFrequency = 10 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedNodeOutOfDiskCondition := v1.NodeCondition{
0000000000000000000000000000000000000000;;			Type:               v1.NodeOutOfDisk,
0000000000000000000000000000000000000000;;			Status:             v1.ConditionFalse,
0000000000000000000000000000000000000000;;			Reason:             "KubeletHasSufficientDisk",
0000000000000000000000000000000000000000;;			Message:            fmt.Sprintf("kubelet has sufficient disk space available"),
0000000000000000000000000000000000000000;;			LastHeartbeatTime:  metav1.Time{},
0000000000000000000000000000000000000000;;			LastTransitionTime: metav1.Time{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubelet.updateRuntimeUp()
0000000000000000000000000000000000000000;;		assert.NoError(t, kubelet.updateNodeStatus())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actions := kubeClient.Actions()
0000000000000000000000000000000000000000;;		require.Len(t, actions, 2)
0000000000000000000000000000000000000000;;		require.True(t, actions[1].Matches("patch", "nodes"))
0000000000000000000000000000000000000000;;		require.Equal(t, "status", actions[1].GetSubresource())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatedNode, err := applyNodeStatusPatch(&existingNode, actions[1].(core.PatchActionImpl).GetPatch())
0000000000000000000000000000000000000000;;		assert.NoError(t, err, "apply the node status patch")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var oodCondition v1.NodeCondition
0000000000000000000000000000000000000000;;		for i, cond := range updatedNode.Status.Conditions {
0000000000000000000000000000000000000000;;			assert.False(t, cond.LastHeartbeatTime.IsZero(), "LastHeartbeatTime for %v condition is zero", cond.Type)
0000000000000000000000000000000000000000;;			assert.False(t, cond.LastTransitionTime.IsZero(), "LastTransitionTime for %v condition  is zero", cond.Type)
0000000000000000000000000000000000000000;;			updatedNode.Status.Conditions[i].LastHeartbeatTime = metav1.Time{}
0000000000000000000000000000000000000000;;			updatedNode.Status.Conditions[i].LastTransitionTime = metav1.Time{}
0000000000000000000000000000000000000000;;			if cond.Type == v1.NodeOutOfDisk {
0000000000000000000000000000000000000000;;				oodCondition = updatedNode.Status.Conditions[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		assert.EqualValues(t, expectedNodeOutOfDiskCondition, oodCondition)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateExistingNodeStatus(t *testing.T) {
0000000000000000000000000000000000000000;;		testKubelet := newTestKubelet(t, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;		defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;		kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;		kubelet.containerManager = &localCM{
0000000000000000000000000000000000000000;;			ContainerManager: cm.NewStubContainerManager(),
0000000000000000000000000000000000000000;;			allocatable: v1.ResourceList{
0000000000000000000000000000000000000000;;				v1.ResourceCPU:    *resource.NewMilliQuantity(200, resource.DecimalSI),
0000000000000000000000000000000000000000;;				v1.ResourceMemory: *resource.NewQuantity(100E6, resource.BinarySI),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;				v1.ResourceCPU:    *resource.NewMilliQuantity(2000, resource.DecimalSI),
0000000000000000000000000000000000000000;;				v1.ResourceMemory: *resource.NewQuantity(20E9, resource.BinarySI),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := testKubelet.fakeKubeClient
0000000000000000000000000000000000000000;;		existingNode := v1.Node{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: testKubeletHostname},
0000000000000000000000000000000000000000;;			Spec:       v1.NodeSpec{},
0000000000000000000000000000000000000000;;			Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;				Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:               v1.NodeOutOfDisk,
0000000000000000000000000000000000000000;;						Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;						Reason:             "KubeletOutOfDisk",
0000000000000000000000000000000000000000;;						Message:            "out of disk space",
0000000000000000000000000000000000000000;;						LastHeartbeatTime:  metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						LastTransitionTime: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:               v1.NodeMemoryPressure,
0000000000000000000000000000000000000000;;						Status:             v1.ConditionFalse,
0000000000000000000000000000000000000000;;						Reason:             "KubeletHasSufficientMemory",
0000000000000000000000000000000000000000;;						Message:            fmt.Sprintf("kubelet has sufficient memory available"),
0000000000000000000000000000000000000000;;						LastHeartbeatTime:  metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						LastTransitionTime: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:               v1.NodeDiskPressure,
0000000000000000000000000000000000000000;;						Status:             v1.ConditionFalse,
0000000000000000000000000000000000000000;;						Reason:             "KubeletHasSufficientDisk",
0000000000000000000000000000000000000000;;						Message:            fmt.Sprintf("kubelet has sufficient disk space available"),
0000000000000000000000000000000000000000;;						LastHeartbeatTime:  metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						LastTransitionTime: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;						Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;						Reason:             "KubeletReady",
0000000000000000000000000000000000000000;;						Message:            fmt.Sprintf("kubelet is posting ready status"),
0000000000000000000000000000000000000000;;						LastHeartbeatTime:  metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						LastTransitionTime: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU:    *resource.NewMilliQuantity(3000, resource.DecimalSI),
0000000000000000000000000000000000000000;;					v1.ResourceMemory: *resource.NewQuantity(20E9, resource.BinarySI),
0000000000000000000000000000000000000000;;					v1.ResourcePods:   *resource.NewQuantity(0, resource.DecimalSI),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Allocatable: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU:    *resource.NewMilliQuantity(2800, resource.DecimalSI),
0000000000000000000000000000000000000000;;					v1.ResourceMemory: *resource.NewQuantity(19900E6, resource.BinarySI),
0000000000000000000000000000000000000000;;					v1.ResourcePods:   *resource.NewQuantity(0, resource.DecimalSI),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kubeClient.ReactionChain = fake.NewSimpleClientset(&v1.NodeList{Items: []v1.Node{existingNode}}).ReactionChain
0000000000000000000000000000000000000000;;		mockCadvisor := testKubelet.fakeCadvisor
0000000000000000000000000000000000000000;;		mockCadvisor.On("Start").Return(nil)
0000000000000000000000000000000000000000;;		machineInfo := &cadvisorapi.MachineInfo{
0000000000000000000000000000000000000000;;			MachineID:      "123",
0000000000000000000000000000000000000000;;			SystemUUID:     "abc",
0000000000000000000000000000000000000000;;			BootID:         "1b3",
0000000000000000000000000000000000000000;;			NumCores:       2,
0000000000000000000000000000000000000000;;			MemoryCapacity: 20E9,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mockCadvisor.On("MachineInfo").Return(machineInfo, nil)
0000000000000000000000000000000000000000;;		versionInfo := &cadvisorapi.VersionInfo{
0000000000000000000000000000000000000000;;			KernelVersion:      "3.16.0-0.bpo.4-amd64",
0000000000000000000000000000000000000000;;			ContainerOsVersion: "Debian GNU/Linux 7 (wheezy)",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mockCadvisor.On("VersionInfo").Return(versionInfo, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make kubelet report that it is out of disk space.
0000000000000000000000000000000000000000;;		err := updateDiskSpacePolicy(kubelet, mockCadvisor, 500, 500, 50, 50, 100, 100)
0000000000000000000000000000000000000000;;		require.NoError(t, err, "update the disk space manager")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedNode := &v1.Node{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: testKubeletHostname},
0000000000000000000000000000000000000000;;			Spec:       v1.NodeSpec{},
0000000000000000000000000000000000000000;;			Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;				Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:               v1.NodeOutOfDisk,
0000000000000000000000000000000000000000;;						Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;						Reason:             "KubeletOutOfDisk",
0000000000000000000000000000000000000000;;						Message:            "out of disk space",
0000000000000000000000000000000000000000;;						LastHeartbeatTime:  metav1.Time{}, // placeholder
0000000000000000000000000000000000000000;;						LastTransitionTime: metav1.Time{}, // placeholder
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:               v1.NodeMemoryPressure,
0000000000000000000000000000000000000000;;						Status:             v1.ConditionFalse,
0000000000000000000000000000000000000000;;						Reason:             "KubeletHasSufficientMemory",
0000000000000000000000000000000000000000;;						Message:            fmt.Sprintf("kubelet has sufficient memory available"),
0000000000000000000000000000000000000000;;						LastHeartbeatTime:  metav1.Time{},
0000000000000000000000000000000000000000;;						LastTransitionTime: metav1.Time{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:               v1.NodeDiskPressure,
0000000000000000000000000000000000000000;;						Status:             v1.ConditionFalse,
0000000000000000000000000000000000000000;;						Reason:             "KubeletHasSufficientDisk",
0000000000000000000000000000000000000000;;						Message:            fmt.Sprintf("kubelet has sufficient disk space available"),
0000000000000000000000000000000000000000;;						LastHeartbeatTime:  metav1.Time{},
0000000000000000000000000000000000000000;;						LastTransitionTime: metav1.Time{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;						Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;						Reason:             "KubeletReady",
0000000000000000000000000000000000000000;;						Message:            fmt.Sprintf("kubelet is posting ready status"),
0000000000000000000000000000000000000000;;						LastHeartbeatTime:  metav1.Time{}, // placeholder
0000000000000000000000000000000000000000;;						LastTransitionTime: metav1.Time{}, // placeholder
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				NodeInfo: v1.NodeSystemInfo{
0000000000000000000000000000000000000000;;					MachineID:               "123",
0000000000000000000000000000000000000000;;					SystemUUID:              "abc",
0000000000000000000000000000000000000000;;					BootID:                  "1b3",
0000000000000000000000000000000000000000;;					KernelVersion:           "3.16.0-0.bpo.4-amd64",
0000000000000000000000000000000000000000;;					OSImage:                 "Debian GNU/Linux 7 (wheezy)",
0000000000000000000000000000000000000000;;					OperatingSystem:         goruntime.GOOS,
0000000000000000000000000000000000000000;;					Architecture:            goruntime.GOARCH,
0000000000000000000000000000000000000000;;					ContainerRuntimeVersion: "test://1.5.0",
0000000000000000000000000000000000000000;;					KubeletVersion:          version.Get().String(),
0000000000000000000000000000000000000000;;					KubeProxyVersion:        version.Get().String(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU:    *resource.NewMilliQuantity(2000, resource.DecimalSI),
0000000000000000000000000000000000000000;;					v1.ResourceMemory: *resource.NewQuantity(20E9, resource.BinarySI),
0000000000000000000000000000000000000000;;					v1.ResourcePods:   *resource.NewQuantity(0, resource.DecimalSI),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Allocatable: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU:    *resource.NewMilliQuantity(1800, resource.DecimalSI),
0000000000000000000000000000000000000000;;					v1.ResourceMemory: *resource.NewQuantity(19900E6, resource.BinarySI),
0000000000000000000000000000000000000000;;					v1.ResourcePods:   *resource.NewQuantity(0, resource.DecimalSI),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Addresses: []v1.NodeAddress{
0000000000000000000000000000000000000000;;					{Type: v1.NodeInternalIP, Address: "127.0.0.1"},
0000000000000000000000000000000000000000;;					{Type: v1.NodeHostName, Address: testKubeletHostname},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				// images will be sorted from max to min in node status.
0000000000000000000000000000000000000000;;				Images: []v1.ContainerImage{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Names:     []string{"gcr.io/google_containers:v3", "gcr.io/google_containers:v4"},
0000000000000000000000000000000000000000;;						SizeBytes: 456,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Names:     []string{"gcr.io/google_containers:v1", "gcr.io/google_containers:v2"},
0000000000000000000000000000000000000000;;						SizeBytes: 123,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubelet.updateRuntimeUp()
0000000000000000000000000000000000000000;;		assert.NoError(t, kubelet.updateNodeStatus())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actions := kubeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Len(t, actions, 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.IsType(t, core.PatchActionImpl{}, actions[1])
0000000000000000000000000000000000000000;;		patchAction := actions[1].(core.PatchActionImpl)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatedNode, err := applyNodeStatusPatch(&existingNode, patchAction.GetPatch())
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, cond := range updatedNode.Status.Conditions {
0000000000000000000000000000000000000000;;			old := metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC).Time
0000000000000000000000000000000000000000;;			// Expect LastHearbeat to be updated to Now, while LastTransitionTime to be the same.
0000000000000000000000000000000000000000;;			assert.NotEqual(t, old, cond.LastHeartbeatTime.Rfc3339Copy().UTC(), "LastHeartbeatTime for condition %v", cond.Type)
0000000000000000000000000000000000000000;;			assert.EqualValues(t, old, cond.LastTransitionTime.Rfc3339Copy().UTC(), "LastTransitionTime for condition %v", cond.Type)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			updatedNode.Status.Conditions[i].LastHeartbeatTime = metav1.Time{}
0000000000000000000000000000000000000000;;			updatedNode.Status.Conditions[i].LastTransitionTime = metav1.Time{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Version skew workaround. See: https://github.com/kubernetes/kubernetes/issues/16961
0000000000000000000000000000000000000000;;		assert.Equal(t, v1.NodeReady, updatedNode.Status.Conditions[len(updatedNode.Status.Conditions)-1].Type,
0000000000000000000000000000000000000000;;			"NodeReady should be the last condition")
0000000000000000000000000000000000000000;;		assert.True(t, apiequality.Semantic.DeepEqual(expectedNode, updatedNode), "%s", diff.ObjectDiff(expectedNode, updatedNode))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateExistingNodeOutOfDiskStatusWithTransitionFrequency(t *testing.T) {
0000000000000000000000000000000000000000;;		testKubelet := newTestKubelet(t, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;		defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;		kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;		kubelet.containerManager = &localCM{
0000000000000000000000000000000000000000;;			ContainerManager: cm.NewStubContainerManager(),
0000000000000000000000000000000000000000;;			allocatable: v1.ResourceList{
0000000000000000000000000000000000000000;;				v1.ResourceCPU:    *resource.NewMilliQuantity(200, resource.DecimalSI),
0000000000000000000000000000000000000000;;				v1.ResourceMemory: *resource.NewQuantity(100E6, resource.BinarySI),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;				v1.ResourceCPU:    *resource.NewMilliQuantity(2000, resource.DecimalSI),
0000000000000000000000000000000000000000;;				v1.ResourceMemory: *resource.NewQuantity(20E9, resource.BinarySI),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clock := testKubelet.fakeClock
0000000000000000000000000000000000000000;;		// Do not set nano second, because apiserver function doesn't support nano second. (Only support
0000000000000000000000000000000000000000;;		// RFC3339).
0000000000000000000000000000000000000000;;		clock.SetTime(time.Unix(123456, 0))
0000000000000000000000000000000000000000;;		kubeClient := testKubelet.fakeKubeClient
0000000000000000000000000000000000000000;;		existingNode := v1.Node{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: testKubeletHostname},
0000000000000000000000000000000000000000;;			Spec:       v1.NodeSpec{},
0000000000000000000000000000000000000000;;			Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;				Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;						Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;						Reason:             "KubeletReady",
0000000000000000000000000000000000000000;;						Message:            fmt.Sprintf("kubelet is posting ready status"),
0000000000000000000000000000000000000000;;						LastHeartbeatTime:  metav1.NewTime(clock.Now()),
0000000000000000000000000000000000000000;;						LastTransitionTime: metav1.NewTime(clock.Now()),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:               v1.NodeOutOfDisk,
0000000000000000000000000000000000000000;;						Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;						Reason:             "KubeletOutOfDisk",
0000000000000000000000000000000000000000;;						Message:            "out of disk space",
0000000000000000000000000000000000000000;;						LastHeartbeatTime:  metav1.NewTime(clock.Now()),
0000000000000000000000000000000000000000;;						LastTransitionTime: metav1.NewTime(clock.Now()),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kubeClient.ReactionChain = fake.NewSimpleClientset(&v1.NodeList{Items: []v1.Node{existingNode}}).ReactionChain
0000000000000000000000000000000000000000;;		mockCadvisor := testKubelet.fakeCadvisor
0000000000000000000000000000000000000000;;		machineInfo := &cadvisorapi.MachineInfo{
0000000000000000000000000000000000000000;;			MachineID:      "123",
0000000000000000000000000000000000000000;;			SystemUUID:     "abc",
0000000000000000000000000000000000000000;;			BootID:         "1b3",
0000000000000000000000000000000000000000;;			NumCores:       2,
0000000000000000000000000000000000000000;;			MemoryCapacity: 1024,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fsInfo := cadvisorapiv2.FsInfo{
0000000000000000000000000000000000000000;;			Device: "123",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mockCadvisor.On("Start").Return(nil)
0000000000000000000000000000000000000000;;		mockCadvisor.On("MachineInfo").Return(machineInfo, nil)
0000000000000000000000000000000000000000;;		mockCadvisor.On("ImagesFsInfo").Return(fsInfo, nil)
0000000000000000000000000000000000000000;;		mockCadvisor.On("RootFsInfo").Return(fsInfo, nil)
0000000000000000000000000000000000000000;;		versionInfo := &cadvisorapi.VersionInfo{
0000000000000000000000000000000000000000;;			KernelVersion:      "3.16.0-0.bpo.4-amd64",
0000000000000000000000000000000000000000;;			ContainerOsVersion: "Debian GNU/Linux 7 (wheezy)",
0000000000000000000000000000000000000000;;			DockerVersion:      "1.5.0",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mockCadvisor.On("VersionInfo").Return(versionInfo, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubelet.outOfDiskTransitionFrequency = 5 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ood := v1.NodeCondition{
0000000000000000000000000000000000000000;;			Type:               v1.NodeOutOfDisk,
0000000000000000000000000000000000000000;;			Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;			Reason:             "KubeletOutOfDisk",
0000000000000000000000000000000000000000;;			Message:            "out of disk space",
0000000000000000000000000000000000000000;;			LastHeartbeatTime:  metav1.NewTime(clock.Now()), // placeholder
0000000000000000000000000000000000000000;;			LastTransitionTime: metav1.NewTime(clock.Now()), // placeholder
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		noOod := v1.NodeCondition{
0000000000000000000000000000000000000000;;			Type:               v1.NodeOutOfDisk,
0000000000000000000000000000000000000000;;			Status:             v1.ConditionFalse,
0000000000000000000000000000000000000000;;			Reason:             "KubeletHasSufficientDisk",
0000000000000000000000000000000000000000;;			Message:            fmt.Sprintf("kubelet has sufficient disk space available"),
0000000000000000000000000000000000000000;;			LastHeartbeatTime:  metav1.NewTime(clock.Now()), // placeholder
0000000000000000000000000000000000000000;;			LastTransitionTime: metav1.NewTime(clock.Now()), // placeholder
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			rootFsAvail   uint64
0000000000000000000000000000000000000000;;			dockerFsAvail uint64
0000000000000000000000000000000000000000;;			expected      v1.NodeCondition
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// NodeOutOfDisk==false
0000000000000000000000000000000000000000;;				rootFsAvail:   200,
0000000000000000000000000000000000000000;;				dockerFsAvail: 200,
0000000000000000000000000000000000000000;;				expected:      ood,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// NodeOutOfDisk==true
0000000000000000000000000000000000000000;;				rootFsAvail:   50,
0000000000000000000000000000000000000000;;				dockerFsAvail: 200,
0000000000000000000000000000000000000000;;				expected:      ood,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// NodeOutOfDisk==false
0000000000000000000000000000000000000000;;				rootFsAvail:   200,
0000000000000000000000000000000000000000;;				dockerFsAvail: 200,
0000000000000000000000000000000000000000;;				expected:      ood,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// NodeOutOfDisk==true
0000000000000000000000000000000000000000;;				rootFsAvail:   200,
0000000000000000000000000000000000000000;;				dockerFsAvail: 50,
0000000000000000000000000000000000000000;;				expected:      ood,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// NodeOutOfDisk==false
0000000000000000000000000000000000000000;;				rootFsAvail:   200,
0000000000000000000000000000000000000000;;				dockerFsAvail: 200,
0000000000000000000000000000000000000000;;				expected:      noOod,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubelet.updateRuntimeUp()
0000000000000000000000000000000000000000;;		for tcIdx, tc := range testCases {
0000000000000000000000000000000000000000;;			// Step by a second
0000000000000000000000000000000000000000;;			clock.Step(1 * time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Setup expected times.
0000000000000000000000000000000000000000;;			tc.expected.LastHeartbeatTime = metav1.NewTime(clock.Now())
0000000000000000000000000000000000000000;;			// In the last case, there should be a status transition for NodeOutOfDisk
0000000000000000000000000000000000000000;;			if tcIdx == len(testCases)-1 {
0000000000000000000000000000000000000000;;				tc.expected.LastTransitionTime = metav1.NewTime(clock.Now())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Make kubelet report that it has sufficient disk space
0000000000000000000000000000000000000000;;			err := updateDiskSpacePolicy(kubelet, mockCadvisor, 500, 500, tc.rootFsAvail, tc.dockerFsAvail, 100, 100)
0000000000000000000000000000000000000000;;			require.NoError(t, err, "can't update disk space manager")
0000000000000000000000000000000000000000;;			assert.NoError(t, kubelet.updateNodeStatus())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			actions := kubeClient.Actions()
0000000000000000000000000000000000000000;;			assert.Len(t, actions, 2, "test [%d]", tcIdx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			assert.IsType(t, core.PatchActionImpl{}, actions[1])
0000000000000000000000000000000000000000;;			patchAction := actions[1].(core.PatchActionImpl)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			updatedNode, err := applyNodeStatusPatch(&existingNode, patchAction.GetPatch())
0000000000000000000000000000000000000000;;			require.NoError(t, err, "can't apply node status patch")
0000000000000000000000000000000000000000;;			kubeClient.ClearActions()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var oodCondition v1.NodeCondition
0000000000000000000000000000000000000000;;			for i, cond := range updatedNode.Status.Conditions {
0000000000000000000000000000000000000000;;				if cond.Type == v1.NodeOutOfDisk {
0000000000000000000000000000000000000000;;					oodCondition = updatedNode.Status.Conditions[i]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			assert.EqualValues(t, tc.expected, oodCondition)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateNodeStatusWithRuntimeStateError(t *testing.T) {
0000000000000000000000000000000000000000;;		testKubelet := newTestKubelet(t, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;		defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;		kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;		kubelet.containerManager = &localCM{
0000000000000000000000000000000000000000;;			ContainerManager: cm.NewStubContainerManager(),
0000000000000000000000000000000000000000;;			allocatable: v1.ResourceList{
0000000000000000000000000000000000000000;;				v1.ResourceCPU:    *resource.NewMilliQuantity(200, resource.DecimalSI),
0000000000000000000000000000000000000000;;				v1.ResourceMemory: *resource.NewQuantity(100E6, resource.BinarySI),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;				v1.ResourceCPU:    *resource.NewMilliQuantity(2000, resource.DecimalSI),
0000000000000000000000000000000000000000;;				v1.ResourceMemory: *resource.NewQuantity(10E9, resource.BinarySI),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clock := testKubelet.fakeClock
0000000000000000000000000000000000000000;;		kubeClient := testKubelet.fakeKubeClient
0000000000000000000000000000000000000000;;		existingNode := v1.Node{ObjectMeta: metav1.ObjectMeta{Name: testKubeletHostname}}
0000000000000000000000000000000000000000;;		kubeClient.ReactionChain = fake.NewSimpleClientset(&v1.NodeList{Items: []v1.Node{existingNode}}).ReactionChain
0000000000000000000000000000000000000000;;		mockCadvisor := testKubelet.fakeCadvisor
0000000000000000000000000000000000000000;;		mockCadvisor.On("Start").Return(nil)
0000000000000000000000000000000000000000;;		machineInfo := &cadvisorapi.MachineInfo{
0000000000000000000000000000000000000000;;			MachineID:      "123",
0000000000000000000000000000000000000000;;			SystemUUID:     "abc",
0000000000000000000000000000000000000000;;			BootID:         "1b3",
0000000000000000000000000000000000000000;;			NumCores:       2,
0000000000000000000000000000000000000000;;			MemoryCapacity: 10E9,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mockCadvisor.On("MachineInfo").Return(machineInfo, nil)
0000000000000000000000000000000000000000;;		versionInfo := &cadvisorapi.VersionInfo{
0000000000000000000000000000000000000000;;			KernelVersion:      "3.16.0-0.bpo.4-amd64",
0000000000000000000000000000000000000000;;			ContainerOsVersion: "Debian GNU/Linux 7 (wheezy)",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mockCadvisor.On("VersionInfo").Return(versionInfo, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make kubelet report that it has sufficient disk space.
0000000000000000000000000000000000000000;;		require.NoError(t, updateDiskSpacePolicy(kubelet, mockCadvisor, 500, 500, 200, 200, 100, 100))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedNode := &v1.Node{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: testKubeletHostname},
0000000000000000000000000000000000000000;;			Spec:       v1.NodeSpec{},
0000000000000000000000000000000000000000;;			Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;				Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:               v1.NodeOutOfDisk,
0000000000000000000000000000000000000000;;						Status:             v1.ConditionFalse,
0000000000000000000000000000000000000000;;						Reason:             "KubeletHasSufficientDisk",
0000000000000000000000000000000000000000;;						Message:            "kubelet has sufficient disk space available",
0000000000000000000000000000000000000000;;						LastHeartbeatTime:  metav1.Time{},
0000000000000000000000000000000000000000;;						LastTransitionTime: metav1.Time{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:               v1.NodeMemoryPressure,
0000000000000000000000000000000000000000;;						Status:             v1.ConditionFalse,
0000000000000000000000000000000000000000;;						Reason:             "KubeletHasSufficientMemory",
0000000000000000000000000000000000000000;;						Message:            fmt.Sprintf("kubelet has sufficient memory available"),
0000000000000000000000000000000000000000;;						LastHeartbeatTime:  metav1.Time{},
0000000000000000000000000000000000000000;;						LastTransitionTime: metav1.Time{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:               v1.NodeDiskPressure,
0000000000000000000000000000000000000000;;						Status:             v1.ConditionFalse,
0000000000000000000000000000000000000000;;						Reason:             "KubeletHasNoDiskPressure",
0000000000000000000000000000000000000000;;						Message:            fmt.Sprintf("kubelet has no disk pressure"),
0000000000000000000000000000000000000000;;						LastHeartbeatTime:  metav1.Time{},
0000000000000000000000000000000000000000;;						LastTransitionTime: metav1.Time{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{}, //placeholder
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				NodeInfo: v1.NodeSystemInfo{
0000000000000000000000000000000000000000;;					MachineID:               "123",
0000000000000000000000000000000000000000;;					SystemUUID:              "abc",
0000000000000000000000000000000000000000;;					BootID:                  "1b3",
0000000000000000000000000000000000000000;;					KernelVersion:           "3.16.0-0.bpo.4-amd64",
0000000000000000000000000000000000000000;;					OSImage:                 "Debian GNU/Linux 7 (wheezy)",
0000000000000000000000000000000000000000;;					OperatingSystem:         goruntime.GOOS,
0000000000000000000000000000000000000000;;					Architecture:            goruntime.GOARCH,
0000000000000000000000000000000000000000;;					ContainerRuntimeVersion: "test://1.5.0",
0000000000000000000000000000000000000000;;					KubeletVersion:          version.Get().String(),
0000000000000000000000000000000000000000;;					KubeProxyVersion:        version.Get().String(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU:    *resource.NewMilliQuantity(2000, resource.DecimalSI),
0000000000000000000000000000000000000000;;					v1.ResourceMemory: *resource.NewQuantity(10E9, resource.BinarySI),
0000000000000000000000000000000000000000;;					v1.ResourcePods:   *resource.NewQuantity(0, resource.DecimalSI),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Allocatable: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU:    *resource.NewMilliQuantity(1800, resource.DecimalSI),
0000000000000000000000000000000000000000;;					v1.ResourceMemory: *resource.NewQuantity(9900E6, resource.BinarySI),
0000000000000000000000000000000000000000;;					v1.ResourcePods:   *resource.NewQuantity(0, resource.DecimalSI),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Addresses: []v1.NodeAddress{
0000000000000000000000000000000000000000;;					{Type: v1.NodeInternalIP, Address: "127.0.0.1"},
0000000000000000000000000000000000000000;;					{Type: v1.NodeHostName, Address: testKubeletHostname},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Images: []v1.ContainerImage{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Names:     []string{"gcr.io/google_containers:v3", "gcr.io/google_containers:v4"},
0000000000000000000000000000000000000000;;						SizeBytes: 456,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Names:     []string{"gcr.io/google_containers:v1", "gcr.io/google_containers:v2"},
0000000000000000000000000000000000000000;;						SizeBytes: 123,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		checkNodeStatus := func(status v1.ConditionStatus, reason string) {
0000000000000000000000000000000000000000;;			kubeClient.ClearActions()
0000000000000000000000000000000000000000;;			assert.NoError(t, kubelet.updateNodeStatus())
0000000000000000000000000000000000000000;;			actions := kubeClient.Actions()
0000000000000000000000000000000000000000;;			require.Len(t, actions, 2)
0000000000000000000000000000000000000000;;			require.True(t, actions[1].Matches("patch", "nodes"))
0000000000000000000000000000000000000000;;			require.Equal(t, actions[1].GetSubresource(), "status")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			updatedNode, err := applyNodeStatusPatch(&existingNode, actions[1].(core.PatchActionImpl).GetPatch())
0000000000000000000000000000000000000000;;			require.NoError(t, err, "can't apply node status patch")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i, cond := range updatedNode.Status.Conditions {
0000000000000000000000000000000000000000;;				assert.False(t, cond.LastHeartbeatTime.IsZero(), "LastHeartbeatTime for %v condition is zero", cond.Type)
0000000000000000000000000000000000000000;;				assert.False(t, cond.LastTransitionTime.IsZero(), "LastTransitionTime for %v condition  is zero", cond.Type)
0000000000000000000000000000000000000000;;				updatedNode.Status.Conditions[i].LastHeartbeatTime = metav1.Time{}
0000000000000000000000000000000000000000;;				updatedNode.Status.Conditions[i].LastTransitionTime = metav1.Time{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Version skew workaround. See: https://github.com/kubernetes/kubernetes/issues/16961
0000000000000000000000000000000000000000;;			lastIndex := len(updatedNode.Status.Conditions) - 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			assert.Equal(t, v1.NodeReady, updatedNode.Status.Conditions[lastIndex].Type, "NodeReady should be the last condition")
0000000000000000000000000000000000000000;;			assert.NotEmpty(t, updatedNode.Status.Conditions[lastIndex].Message)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			updatedNode.Status.Conditions[lastIndex].Message = ""
0000000000000000000000000000000000000000;;			expectedNode.Status.Conditions[lastIndex] = v1.NodeCondition{
0000000000000000000000000000000000000000;;				Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;				Status:             status,
0000000000000000000000000000000000000000;;				Reason:             reason,
0000000000000000000000000000000000000000;;				LastHeartbeatTime:  metav1.Time{},
0000000000000000000000000000000000000000;;				LastTransitionTime: metav1.Time{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			assert.True(t, apiequality.Semantic.DeepEqual(expectedNode, updatedNode), "%s", diff.ObjectDiff(expectedNode, updatedNode))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(random-liu): Refactor the unit test to be table driven test.
0000000000000000000000000000000000000000;;		// Should report kubelet not ready if the runtime check is out of date
0000000000000000000000000000000000000000;;		clock.SetTime(time.Now().Add(-maxWaitForContainerRuntime))
0000000000000000000000000000000000000000;;		kubelet.updateRuntimeUp()
0000000000000000000000000000000000000000;;		checkNodeStatus(v1.ConditionFalse, "KubeletNotReady")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Should report kubelet ready if the runtime check is updated
0000000000000000000000000000000000000000;;		clock.SetTime(time.Now())
0000000000000000000000000000000000000000;;		kubelet.updateRuntimeUp()
0000000000000000000000000000000000000000;;		checkNodeStatus(v1.ConditionTrue, "KubeletReady")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Should report kubelet not ready if the runtime check is out of date
0000000000000000000000000000000000000000;;		clock.SetTime(time.Now().Add(-maxWaitForContainerRuntime))
0000000000000000000000000000000000000000;;		kubelet.updateRuntimeUp()
0000000000000000000000000000000000000000;;		checkNodeStatus(v1.ConditionFalse, "KubeletNotReady")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Should report kubelet not ready if the runtime check failed
0000000000000000000000000000000000000000;;		fakeRuntime := testKubelet.fakeRuntime
0000000000000000000000000000000000000000;;		// Inject error into fake runtime status check, node should be NotReady
0000000000000000000000000000000000000000;;		fakeRuntime.StatusErr = fmt.Errorf("injected runtime status error")
0000000000000000000000000000000000000000;;		clock.SetTime(time.Now())
0000000000000000000000000000000000000000;;		kubelet.updateRuntimeUp()
0000000000000000000000000000000000000000;;		checkNodeStatus(v1.ConditionFalse, "KubeletNotReady")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeRuntime.StatusErr = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Should report node not ready if runtime status is nil.
0000000000000000000000000000000000000000;;		fakeRuntime.RuntimeStatus = nil
0000000000000000000000000000000000000000;;		kubelet.updateRuntimeUp()
0000000000000000000000000000000000000000;;		checkNodeStatus(v1.ConditionFalse, "KubeletNotReady")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Should report node not ready if runtime status is empty.
0000000000000000000000000000000000000000;;		fakeRuntime.RuntimeStatus = &kubecontainer.RuntimeStatus{}
0000000000000000000000000000000000000000;;		kubelet.updateRuntimeUp()
0000000000000000000000000000000000000000;;		checkNodeStatus(v1.ConditionFalse, "KubeletNotReady")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Should report node not ready if RuntimeReady is false.
0000000000000000000000000000000000000000;;		fakeRuntime.RuntimeStatus = &kubecontainer.RuntimeStatus{
0000000000000000000000000000000000000000;;			Conditions: []kubecontainer.RuntimeCondition{
0000000000000000000000000000000000000000;;				{Type: kubecontainer.RuntimeReady, Status: false},
0000000000000000000000000000000000000000;;				{Type: kubecontainer.NetworkReady, Status: true},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kubelet.updateRuntimeUp()
0000000000000000000000000000000000000000;;		checkNodeStatus(v1.ConditionFalse, "KubeletNotReady")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Should report node ready if RuntimeReady is true.
0000000000000000000000000000000000000000;;		fakeRuntime.RuntimeStatus = &kubecontainer.RuntimeStatus{
0000000000000000000000000000000000000000;;			Conditions: []kubecontainer.RuntimeCondition{
0000000000000000000000000000000000000000;;				{Type: kubecontainer.RuntimeReady, Status: true},
0000000000000000000000000000000000000000;;				{Type: kubecontainer.NetworkReady, Status: true},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kubelet.updateRuntimeUp()
0000000000000000000000000000000000000000;;		checkNodeStatus(v1.ConditionTrue, "KubeletReady")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Should report node not ready if NetworkReady is false.
0000000000000000000000000000000000000000;;		fakeRuntime.RuntimeStatus = &kubecontainer.RuntimeStatus{
0000000000000000000000000000000000000000;;			Conditions: []kubecontainer.RuntimeCondition{
0000000000000000000000000000000000000000;;				{Type: kubecontainer.RuntimeReady, Status: true},
0000000000000000000000000000000000000000;;				{Type: kubecontainer.NetworkReady, Status: false},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kubelet.updateRuntimeUp()
0000000000000000000000000000000000000000;;		checkNodeStatus(v1.ConditionFalse, "KubeletNotReady")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateNodeStatusError(t *testing.T) {
0000000000000000000000000000000000000000;;		testKubelet := newTestKubelet(t, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;		defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;		kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;		// No matching node for the kubelet
0000000000000000000000000000000000000000;;		testKubelet.fakeKubeClient.ReactionChain = fake.NewSimpleClientset(&v1.NodeList{Items: []v1.Node{}}).ReactionChain
0000000000000000000000000000000000000000;;		assert.Error(t, kubelet.updateNodeStatus())
0000000000000000000000000000000000000000;;		assert.Len(t, testKubelet.fakeKubeClient.Actions(), nodeStatusUpdateRetry)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRegisterWithApiServer(t *testing.T) {
0000000000000000000000000000000000000000;;		testKubelet := newTestKubelet(t, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;		defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;		kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;		kubeClient := testKubelet.fakeKubeClient
0000000000000000000000000000000000000000;;		kubeClient.AddReactor("create", "nodes", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			// Return an error on create.
0000000000000000000000000000000000000000;;			return true, &v1.Node{}, &apierrors.StatusError{
0000000000000000000000000000000000000000;;				ErrStatus: metav1.Status{Reason: metav1.StatusReasonAlreadyExists},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		kubeClient.AddReactor("get", "nodes", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			// Return an existing (matching) node on get.
0000000000000000000000000000000000000000;;			return true, &v1.Node{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: testKubeletHostname},
0000000000000000000000000000000000000000;;				Spec:       v1.NodeSpec{ExternalID: testKubeletHostname},
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		kubeClient.AddReactor("*", "*", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			return true, nil, fmt.Errorf("no reaction implemented for %s", action)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		machineInfo := &cadvisorapi.MachineInfo{
0000000000000000000000000000000000000000;;			MachineID:      "123",
0000000000000000000000000000000000000000;;			SystemUUID:     "abc",
0000000000000000000000000000000000000000;;			BootID:         "1b3",
0000000000000000000000000000000000000000;;			NumCores:       2,
0000000000000000000000000000000000000000;;			MemoryCapacity: 1024,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mockCadvisor := testKubelet.fakeCadvisor
0000000000000000000000000000000000000000;;		mockCadvisor.On("MachineInfo").Return(machineInfo, nil)
0000000000000000000000000000000000000000;;		versionInfo := &cadvisorapi.VersionInfo{
0000000000000000000000000000000000000000;;			KernelVersion:      "3.16.0-0.bpo.4-amd64",
0000000000000000000000000000000000000000;;			ContainerOsVersion: "Debian GNU/Linux 7 (wheezy)",
0000000000000000000000000000000000000000;;			DockerVersion:      "1.5.0",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mockCadvisor.On("VersionInfo").Return(versionInfo, nil)
0000000000000000000000000000000000000000;;		mockCadvisor.On("ImagesFsInfo").Return(cadvisorapiv2.FsInfo{
0000000000000000000000000000000000000000;;			Usage:     400 * mb,
0000000000000000000000000000000000000000;;			Capacity:  1000 * mb,
0000000000000000000000000000000000000000;;			Available: 600 * mb,
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		mockCadvisor.On("RootFsInfo").Return(cadvisorapiv2.FsInfo{
0000000000000000000000000000000000000000;;			Usage:    9 * mb,
0000000000000000000000000000000000000000;;			Capacity: 10 * mb,
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		done := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			kubelet.registerWithApiServer()
0000000000000000000000000000000000000000;;			done <- struct{}{}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			assert.Fail(t, "timed out waiting for registration")
0000000000000000000000000000000000000000;;		case <-done:
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTryRegisterWithApiServer(t *testing.T) {
0000000000000000000000000000000000000000;;		alreadyExists := &apierrors.StatusError{
0000000000000000000000000000000000000000;;			ErrStatus: metav1.Status{Reason: metav1.StatusReasonAlreadyExists},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conflict := &apierrors.StatusError{
0000000000000000000000000000000000000000;;			ErrStatus: metav1.Status{Reason: metav1.StatusReasonConflict},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newNode := func(cmad bool, externalID string) *v1.Node {
0000000000000000000000000000000000000000;;			node := &v1.Node{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{},
0000000000000000000000000000000000000000;;				Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;					ExternalID: externalID,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if cmad {
0000000000000000000000000000000000000000;;				node.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;				node.Annotations[volumehelper.ControllerManagedAttachAnnotation] = "true"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return node
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			name            string
0000000000000000000000000000000000000000;;			newNode         *v1.Node
0000000000000000000000000000000000000000;;			existingNode    *v1.Node
0000000000000000000000000000000000000000;;			createError     error
0000000000000000000000000000000000000000;;			getError        error
0000000000000000000000000000000000000000;;			patchError      error
0000000000000000000000000000000000000000;;			deleteError     error
0000000000000000000000000000000000000000;;			expectedResult  bool
0000000000000000000000000000000000000000;;			expectedActions int
0000000000000000000000000000000000000000;;			testSavedNode   bool
0000000000000000000000000000000000000000;;			savedNodeIndex  int
0000000000000000000000000000000000000000;;			savedNodeCMAD   bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:            "success case - new node",
0000000000000000000000000000000000000000;;				newNode:         &v1.Node{},
0000000000000000000000000000000000000000;;				expectedResult:  true,
0000000000000000000000000000000000000000;;				expectedActions: 1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:            "success case - existing node - no change in CMAD",
0000000000000000000000000000000000000000;;				newNode:         newNode(true, "a"),
0000000000000000000000000000000000000000;;				createError:     alreadyExists,
0000000000000000000000000000000000000000;;				existingNode:    newNode(true, "a"),
0000000000000000000000000000000000000000;;				expectedResult:  true,
0000000000000000000000000000000000000000;;				expectedActions: 2,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:            "success case - existing node - CMAD disabled",
0000000000000000000000000000000000000000;;				newNode:         newNode(false, "a"),
0000000000000000000000000000000000000000;;				createError:     alreadyExists,
0000000000000000000000000000000000000000;;				existingNode:    newNode(true, "a"),
0000000000000000000000000000000000000000;;				expectedResult:  true,
0000000000000000000000000000000000000000;;				expectedActions: 3,
0000000000000000000000000000000000000000;;				testSavedNode:   true,
0000000000000000000000000000000000000000;;				savedNodeIndex:  2,
0000000000000000000000000000000000000000;;				savedNodeCMAD:   false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:            "success case - existing node - CMAD enabled",
0000000000000000000000000000000000000000;;				newNode:         newNode(true, "a"),
0000000000000000000000000000000000000000;;				createError:     alreadyExists,
0000000000000000000000000000000000000000;;				existingNode:    newNode(false, "a"),
0000000000000000000000000000000000000000;;				expectedResult:  true,
0000000000000000000000000000000000000000;;				expectedActions: 3,
0000000000000000000000000000000000000000;;				testSavedNode:   true,
0000000000000000000000000000000000000000;;				savedNodeIndex:  2,
0000000000000000000000000000000000000000;;				savedNodeCMAD:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:            "success case - external ID changed",
0000000000000000000000000000000000000000;;				newNode:         newNode(false, "b"),
0000000000000000000000000000000000000000;;				createError:     alreadyExists,
0000000000000000000000000000000000000000;;				existingNode:    newNode(false, "a"),
0000000000000000000000000000000000000000;;				expectedResult:  false,
0000000000000000000000000000000000000000;;				expectedActions: 3,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:            "create failed",
0000000000000000000000000000000000000000;;				newNode:         newNode(false, "b"),
0000000000000000000000000000000000000000;;				createError:     conflict,
0000000000000000000000000000000000000000;;				expectedResult:  false,
0000000000000000000000000000000000000000;;				expectedActions: 1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:            "get existing node failed",
0000000000000000000000000000000000000000;;				newNode:         newNode(false, "a"),
0000000000000000000000000000000000000000;;				createError:     alreadyExists,
0000000000000000000000000000000000000000;;				getError:        conflict,
0000000000000000000000000000000000000000;;				expectedResult:  false,
0000000000000000000000000000000000000000;;				expectedActions: 2,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:            "update existing node failed",
0000000000000000000000000000000000000000;;				newNode:         newNode(false, "a"),
0000000000000000000000000000000000000000;;				createError:     alreadyExists,
0000000000000000000000000000000000000000;;				existingNode:    newNode(true, "a"),
0000000000000000000000000000000000000000;;				patchError:      conflict,
0000000000000000000000000000000000000000;;				expectedResult:  false,
0000000000000000000000000000000000000000;;				expectedActions: 3,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:            "delete existing node failed",
0000000000000000000000000000000000000000;;				newNode:         newNode(false, "b"),
0000000000000000000000000000000000000000;;				createError:     alreadyExists,
0000000000000000000000000000000000000000;;				existingNode:    newNode(false, "a"),
0000000000000000000000000000000000000000;;				deleteError:     conflict,
0000000000000000000000000000000000000000;;				expectedResult:  false,
0000000000000000000000000000000000000000;;				expectedActions: 3,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		notImplemented := func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			return true, nil, fmt.Errorf("no reaction implemented for %s", action)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range cases {
0000000000000000000000000000000000000000;;			testKubelet := newTestKubelet(t, false /* controllerAttachDetachEnabled is a don't-care for this test */)
0000000000000000000000000000000000000000;;			defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;			kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;			kubeClient := testKubelet.fakeKubeClient
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			kubeClient.AddReactor("create", "nodes", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;				return true, nil, tc.createError
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			kubeClient.AddReactor("get", "nodes", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;				// Return an existing (matching) node on get.
0000000000000000000000000000000000000000;;				return true, tc.existingNode, tc.getError
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			kubeClient.AddReactor("patch", "nodes", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;				if action.GetSubresource() == "status" {
0000000000000000000000000000000000000000;;					return true, nil, tc.patchError
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return notImplemented(action)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			kubeClient.AddReactor("delete", "nodes", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;				return true, nil, tc.deleteError
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			kubeClient.AddReactor("*", "*", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;				return notImplemented(action)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			result := kubelet.tryRegisterWithApiServer(tc.newNode)
0000000000000000000000000000000000000000;;			require.Equal(t, tc.expectedResult, result, "test [%s]", tc.name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			actions := kubeClient.Actions()
0000000000000000000000000000000000000000;;			assert.Len(t, actions, tc.expectedActions, "test [%s]", tc.name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.testSavedNode {
0000000000000000000000000000000000000000;;				var savedNode *v1.Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				t.Logf("actions: %v: %+v", len(actions), actions)
0000000000000000000000000000000000000000;;				action := actions[tc.savedNodeIndex]
0000000000000000000000000000000000000000;;				if action.GetVerb() == "create" {
0000000000000000000000000000000000000000;;					createAction := action.(core.CreateAction)
0000000000000000000000000000000000000000;;					obj := createAction.GetObject()
0000000000000000000000000000000000000000;;					require.IsType(t, &v1.Node{}, obj)
0000000000000000000000000000000000000000;;					savedNode = obj.(*v1.Node)
0000000000000000000000000000000000000000;;				} else if action.GetVerb() == "patch" {
0000000000000000000000000000000000000000;;					patchAction := action.(core.PatchActionImpl)
0000000000000000000000000000000000000000;;					var err error
0000000000000000000000000000000000000000;;					savedNode, err = applyNodeStatusPatch(tc.existingNode, patchAction.GetPatch())
0000000000000000000000000000000000000000;;					require.NoError(t, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				actualCMAD, _ := strconv.ParseBool(savedNode.Annotations[volumehelper.ControllerManagedAttachAnnotation])
0000000000000000000000000000000000000000;;				assert.Equal(t, tc.savedNodeCMAD, actualCMAD, "test [%s]", tc.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateNewNodeStatusTooLargeReservation(t *testing.T) {
0000000000000000000000000000000000000000;;		// generate one more than maxImagesInNodeStatus in inputImageList
0000000000000000000000000000000000000000;;		inputImageList, _ := generateTestingImageList(maxImagesInNodeStatus + 1)
0000000000000000000000000000000000000000;;		testKubelet := newTestKubeletWithImageList(
0000000000000000000000000000000000000000;;			t, inputImageList, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;		defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;		kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;		kubelet.containerManager = &localCM{
0000000000000000000000000000000000000000;;			ContainerManager: cm.NewStubContainerManager(),
0000000000000000000000000000000000000000;;			allocatable: v1.ResourceList{
0000000000000000000000000000000000000000;;				v1.ResourceCPU: *resource.NewMilliQuantity(40000, resource.DecimalSI),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;				v1.ResourceCPU:    *resource.NewMilliQuantity(2000, resource.DecimalSI),
0000000000000000000000000000000000000000;;				v1.ResourceMemory: *resource.NewQuantity(10E9, resource.BinarySI),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kubeClient := testKubelet.fakeKubeClient
0000000000000000000000000000000000000000;;		existingNode := v1.Node{ObjectMeta: metav1.ObjectMeta{Name: testKubeletHostname}}
0000000000000000000000000000000000000000;;		kubeClient.ReactionChain = fake.NewSimpleClientset(&v1.NodeList{Items: []v1.Node{existingNode}}).ReactionChain
0000000000000000000000000000000000000000;;		machineInfo := &cadvisorapi.MachineInfo{
0000000000000000000000000000000000000000;;			MachineID:      "123",
0000000000000000000000000000000000000000;;			SystemUUID:     "abc",
0000000000000000000000000000000000000000;;			BootID:         "1b3",
0000000000000000000000000000000000000000;;			NumCores:       2,
0000000000000000000000000000000000000000;;			MemoryCapacity: 10E9, // 10G
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mockCadvisor := testKubelet.fakeCadvisor
0000000000000000000000000000000000000000;;		mockCadvisor.On("Start").Return(nil)
0000000000000000000000000000000000000000;;		mockCadvisor.On("MachineInfo").Return(machineInfo, nil)
0000000000000000000000000000000000000000;;		versionInfo := &cadvisorapi.VersionInfo{
0000000000000000000000000000000000000000;;			KernelVersion:      "3.16.0-0.bpo.4-amd64",
0000000000000000000000000000000000000000;;			ContainerOsVersion: "Debian GNU/Linux 7 (wheezy)",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mockCadvisor.On("VersionInfo").Return(versionInfo, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make kubelet report that it has sufficient disk space.
0000000000000000000000000000000000000000;;		require.NoError(t, updateDiskSpacePolicy(kubelet, mockCadvisor, 500, 500, 200, 200, 100, 100))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedNode := &v1.Node{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: testKubeletHostname},
0000000000000000000000000000000000000000;;			Spec:       v1.NodeSpec{},
0000000000000000000000000000000000000000;;			Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU:    *resource.NewMilliQuantity(2000, resource.DecimalSI),
0000000000000000000000000000000000000000;;					v1.ResourceMemory: *resource.NewQuantity(10E9, resource.BinarySI),
0000000000000000000000000000000000000000;;					v1.ResourcePods:   *resource.NewQuantity(0, resource.DecimalSI),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Allocatable: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU:    *resource.NewMilliQuantity(0, resource.DecimalSI),
0000000000000000000000000000000000000000;;					v1.ResourceMemory: *resource.NewQuantity(10E9, resource.BinarySI),
0000000000000000000000000000000000000000;;					v1.ResourcePods:   *resource.NewQuantity(0, resource.DecimalSI),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubelet.updateRuntimeUp()
0000000000000000000000000000000000000000;;		assert.NoError(t, kubelet.updateNodeStatus())
0000000000000000000000000000000000000000;;		actions := kubeClient.Actions()
0000000000000000000000000000000000000000;;		require.Len(t, actions, 2)
0000000000000000000000000000000000000000;;		require.True(t, actions[1].Matches("patch", "nodes"))
0000000000000000000000000000000000000000;;		require.Equal(t, actions[1].GetSubresource(), "status")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatedNode, err := applyNodeStatusPatch(&existingNode, actions[1].(core.PatchActionImpl).GetPatch())
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.True(t, apiequality.Semantic.DeepEqual(expectedNode.Status.Allocatable, updatedNode.Status.Allocatable), "%s", diff.ObjectDiff(expectedNode.Status.Allocatable, updatedNode.Status.Allocatable))
0000000000000000000000000000000000000000;;	}
