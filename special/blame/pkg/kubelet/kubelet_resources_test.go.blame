0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
84a9663d9dae6014522dd8e6cb1c309d6b6a560e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cadvisorapi "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		cadvisorapiv2 "github.com/google/cadvisor/info/v2"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodResourceLimitsDefaulting(t *testing.T) {
0000000000000000000000000000000000000000;;		cpuCores := resource.MustParse("10")
0000000000000000000000000000000000000000;;		memoryCapacity := resource.MustParse("10Gi")
0000000000000000000000000000000000000000;;		tk := newTestKubelet(t, true)
0000000000000000000000000000000000000000;;		defer tk.Cleanup()
0000000000000000000000000000000000000000;;		tk.fakeCadvisor.On("VersionInfo").Return(&cadvisorapi.VersionInfo{}, nil)
0000000000000000000000000000000000000000;;		tk.fakeCadvisor.On("MachineInfo").Return(&cadvisorapi.MachineInfo{
0000000000000000000000000000000000000000;;			NumCores:       int(cpuCores.Value()),
0000000000000000000000000000000000000000;;			MemoryCapacity: uint64(memoryCapacity.Value()),
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		tk.fakeCadvisor.On("ImagesFsInfo").Return(cadvisorapiv2.FsInfo{}, nil)
0000000000000000000000000000000000000000;;		tk.fakeCadvisor.On("RootFsInfo").Return(cadvisorapiv2.FsInfo{}, nil)
0000000000000000000000000000000000000000;;		tk.kubelet.nodeInfo = &testNodeInfo{
0000000000000000000000000000000000000000;;			nodes: []*v1.Node{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: string(tk.kubelet.nodeName),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;						Allocatable: v1.ResourceList{
0000000000000000000000000000000000000000;;							v1.ResourceCPU:    resource.MustParse("6"),
0000000000000000000000000000000000000000;;							v1.ResourceMemory: resource.MustParse("4Gi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			pod      *v1.Pod
0000000000000000000000000000000000000000;;			expected *v1.Pod
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      getPod("0", "0"),
0000000000000000000000000000000000000000;;				expected: getPod("6", "4Gi"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      getPod("1", "0"),
0000000000000000000000000000000000000000;;				expected: getPod("1", "4Gi"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      getPod("", ""),
0000000000000000000000000000000000000000;;				expected: getPod("6", "4Gi"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      getPod("0", "1Mi"),
0000000000000000000000000000000000000000;;				expected: getPod("6", "1Mi"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		as := assert.New(t)
0000000000000000000000000000000000000000;;		for idx, tc := range cases {
0000000000000000000000000000000000000000;;			actual, _, err := tk.kubelet.defaultPodLimitsForDownwardApi(tc.pod, nil)
0000000000000000000000000000000000000000;;			as.Nil(err, "failed to default pod limits: %v", err)
0000000000000000000000000000000000000000;;			if !apiequality.Semantic.DeepEqual(tc.expected, actual) {
0000000000000000000000000000000000000000;;				as.Fail("test case [%d] failed.  Expected: %+v, Got: %+v", idx, tc.expected, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPod(cpuLimit, memoryLimit string) *v1.Pod {
0000000000000000000000000000000000000000;;		resources := v1.ResourceRequirements{}
0000000000000000000000000000000000000000;;		if cpuLimit != "" || memoryLimit != "" {
0000000000000000000000000000000000000000;;			resources.Limits = make(v1.ResourceList)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cpuLimit != "" {
0000000000000000000000000000000000000000;;			resources.Limits[v1.ResourceCPU] = resource.MustParse(cpuLimit)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if memoryLimit != "" {
0000000000000000000000000000000000000000;;			resources.Limits[v1.ResourceMemory] = resource.MustParse(memoryLimit)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Resources: resources,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
