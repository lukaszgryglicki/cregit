0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1be90f193c1ba5f6706e9fb38d8c8140545c31fc;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/network"
0000000000000000000000000000000000000000;;		utiliptables "k8s.io/kubernetes/pkg/util/iptables"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// the mark-for-masquerade chain
0000000000000000000000000000000000000000;;		// TODO: clean up this logic in kube-proxy
0000000000000000000000000000000000000000;;		KubeMarkMasqChain utiliptables.Chain = "KUBE-MARK-MASQ"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the mark-for-drop chain
0000000000000000000000000000000000000000;;		KubeMarkDropChain utiliptables.Chain = "KUBE-MARK-DROP"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// kubernetes postrouting rules
0000000000000000000000000000000000000000;;		KubePostroutingChain utiliptables.Chain = "KUBE-POSTROUTING"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// kubernetes firewall rules
0000000000000000000000000000000000000000;;		KubeFirewallChain utiliptables.Chain = "KUBE-FIREWALL"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// effectiveHairpinMode determines the effective hairpin mode given the
0000000000000000000000000000000000000000;;	// configured mode, container runtime, and whether cbr0 should be configured.
0000000000000000000000000000000000000000;;	func effectiveHairpinMode(hairpinMode componentconfig.HairpinMode, containerRuntime string, networkPlugin string) (componentconfig.HairpinMode, error) {
0000000000000000000000000000000000000000;;		// The hairpin mode setting doesn't matter if:
0000000000000000000000000000000000000000;;		// - We're not using a bridge network. This is hard to check because we might
0000000000000000000000000000000000000000;;		//   be using a plugin.
0000000000000000000000000000000000000000;;		// - It's set to hairpin-veth for a container runtime that doesn't know how
0000000000000000000000000000000000000000;;		//   to set the hairpin flag on the veth's of containers. Currently the
0000000000000000000000000000000000000000;;		//   docker runtime is the only one that understands this.
0000000000000000000000000000000000000000;;		// - It's set to "none".
0000000000000000000000000000000000000000;;		if hairpinMode == componentconfig.PromiscuousBridge || hairpinMode == componentconfig.HairpinVeth {
0000000000000000000000000000000000000000;;			// Only on docker.
0000000000000000000000000000000000000000;;			if containerRuntime != "docker" {
0000000000000000000000000000000000000000;;				glog.Warningf("Hairpin mode set to %q but container runtime is %q, ignoring", hairpinMode, containerRuntime)
0000000000000000000000000000000000000000;;				return componentconfig.HairpinNone, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hairpinMode == componentconfig.PromiscuousBridge && networkPlugin != "kubenet" {
0000000000000000000000000000000000000000;;				// This is not a valid combination, since promiscuous-bridge only works on kubenet. Users might be using the
0000000000000000000000000000000000000000;;				// default values (from before the hairpin-mode flag existed) and we
0000000000000000000000000000000000000000;;				// should keep the old behavior.
0000000000000000000000000000000000000000;;				glog.Warningf("Hairpin mode set to %q but kubenet is not enabled, falling back to %q", hairpinMode, componentconfig.HairpinVeth)
0000000000000000000000000000000000000000;;				return componentconfig.HairpinVeth, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if hairpinMode != componentconfig.HairpinNone {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unknown value: %q", hairpinMode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hairpinMode, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// providerRequiresNetworkingConfiguration returns whether the cloud provider
0000000000000000000000000000000000000000;;	// requires special networking configuration.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) providerRequiresNetworkingConfiguration() bool {
0000000000000000000000000000000000000000;;		// TODO: We should have a mechanism to say whether native cloud provider
0000000000000000000000000000000000000000;;		// is used or whether we are using overlay networking. We should return
0000000000000000000000000000000000000000;;		// true for cloud providers if they implement Routes() interface and
0000000000000000000000000000000000000000;;		// we are not using overlay networking.
0000000000000000000000000000000000000000;;		if kl.cloud == nil || kl.cloud.ProviderName() != "gce" {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, supported := kl.cloud.Routes()
0000000000000000000000000000000000000000;;		return supported
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func omitDuplicates(kl *Kubelet, pod *v1.Pod, combinedSearch []string) []string {
0000000000000000000000000000000000000000;;		uniqueDomains := map[string]bool{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, dnsDomain := range combinedSearch {
0000000000000000000000000000000000000000;;			if _, exists := uniqueDomains[dnsDomain]; !exists {
0000000000000000000000000000000000000000;;				combinedSearch[len(uniqueDomains)] = dnsDomain
0000000000000000000000000000000000000000;;				uniqueDomains[dnsDomain] = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				log := fmt.Sprintf("Found and omitted duplicated dns domain in host search line: '%s' during merging with cluster dns domains", dnsDomain)
0000000000000000000000000000000000000000;;				kl.recorder.Event(pod, v1.EventTypeWarning, "DNSSearchForming", log)
0000000000000000000000000000000000000000;;				glog.Error(log)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return combinedSearch[:len(uniqueDomains)]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func formDNSSearchFitsLimits(kl *Kubelet, pod *v1.Pod, composedSearch []string) []string {
0000000000000000000000000000000000000000;;		// resolver file Search line current limitations
0000000000000000000000000000000000000000;;		resolvSearchLineDNSDomainsLimit := 6
0000000000000000000000000000000000000000;;		resolvSearchLineLenLimit := 255
0000000000000000000000000000000000000000;;		limitsExceeded := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(composedSearch) > resolvSearchLineDNSDomainsLimit {
0000000000000000000000000000000000000000;;			composedSearch = composedSearch[:resolvSearchLineDNSDomainsLimit]
0000000000000000000000000000000000000000;;			limitsExceeded = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resolvSearchhLineStrLen := len(strings.Join(composedSearch, " ")); resolvSearchhLineStrLen > resolvSearchLineLenLimit {
0000000000000000000000000000000000000000;;			cutDomainsNum := 0
0000000000000000000000000000000000000000;;			cutDoaminsLen := 0
0000000000000000000000000000000000000000;;			for i := len(composedSearch) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;				cutDoaminsLen += len(composedSearch[i]) + 1
0000000000000000000000000000000000000000;;				cutDomainsNum++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if (resolvSearchhLineStrLen - cutDoaminsLen) <= resolvSearchLineLenLimit {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			composedSearch = composedSearch[:(len(composedSearch) - cutDomainsNum)]
0000000000000000000000000000000000000000;;			limitsExceeded = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if limitsExceeded {
0000000000000000000000000000000000000000;;			log := fmt.Sprintf("Search Line limits were exceeded, some dns names have been omitted, the applied search line is: %s", strings.Join(composedSearch, " "))
0000000000000000000000000000000000000000;;			kl.recorder.Event(pod, v1.EventTypeWarning, "DNSSearchForming", log)
0000000000000000000000000000000000000000;;			glog.Error(log)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return composedSearch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (kl *Kubelet) formDNSSearchForDNSDefault(hostSearch []string, pod *v1.Pod) []string {
0000000000000000000000000000000000000000;;		return formDNSSearchFitsLimits(kl, pod, hostSearch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (kl *Kubelet) formDNSSearch(hostSearch []string, pod *v1.Pod) []string {
0000000000000000000000000000000000000000;;		if kl.clusterDomain == "" {
0000000000000000000000000000000000000000;;			formDNSSearchFitsLimits(kl, pod, hostSearch)
0000000000000000000000000000000000000000;;			return hostSearch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nsSvcDomain := fmt.Sprintf("%s.svc.%s", pod.Namespace, kl.clusterDomain)
0000000000000000000000000000000000000000;;		svcDomain := fmt.Sprintf("svc.%s", kl.clusterDomain)
0000000000000000000000000000000000000000;;		dnsSearch := []string{nsSvcDomain, svcDomain, kl.clusterDomain}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		combinedSearch := append(dnsSearch, hostSearch...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		combinedSearch = omitDuplicates(kl, pod, combinedSearch)
0000000000000000000000000000000000000000;;		return formDNSSearchFitsLimits(kl, pod, combinedSearch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (kl *Kubelet) checkLimitsForResolvConf() {
0000000000000000000000000000000000000000;;		// resolver file Search line current limitations
0000000000000000000000000000000000000000;;		resolvSearchLineDNSDomainsLimit := 6
0000000000000000000000000000000000000000;;		resolvSearchLineLenLimit := 255
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := os.Open(kl.resolverConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			kl.recorder.Event(kl.nodeRef, v1.EventTypeWarning, "checkLimitsForResolvConf", err.Error())
0000000000000000000000000000000000000000;;			glog.Error("checkLimitsForResolvConf: " + err.Error())
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, hostSearch, err := kl.parseResolvConf(f)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			kl.recorder.Event(kl.nodeRef, v1.EventTypeWarning, "checkLimitsForResolvConf", err.Error())
0000000000000000000000000000000000000000;;			glog.Error("checkLimitsForResolvConf: " + err.Error())
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		domainCntLimit := resolvSearchLineDNSDomainsLimit
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if kl.clusterDomain != "" {
0000000000000000000000000000000000000000;;			domainCntLimit -= 3
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(hostSearch) > domainCntLimit {
0000000000000000000000000000000000000000;;			log := fmt.Sprintf("Resolv.conf file '%s' contains search line consisting of more than %d domains!", kl.resolverConfig, domainCntLimit)
0000000000000000000000000000000000000000;;			kl.recorder.Event(kl.nodeRef, v1.EventTypeWarning, "checkLimitsForResolvConf", log)
0000000000000000000000000000000000000000;;			glog.Error("checkLimitsForResolvConf: " + log)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(strings.Join(hostSearch, " ")) > resolvSearchLineLenLimit {
0000000000000000000000000000000000000000;;			log := fmt.Sprintf("Resolv.conf file '%s' contains search line which length is more than allowed %d chars!", kl.resolverConfig, resolvSearchLineLenLimit)
0000000000000000000000000000000000000000;;			kl.recorder.Event(kl.nodeRef, v1.EventTypeWarning, "checkLimitsForResolvConf", log)
0000000000000000000000000000000000000000;;			glog.Error("checkLimitsForResolvConf: " + log)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseResolveConf reads a resolv.conf file from the given reader, and parses
0000000000000000000000000000000000000000;;	// it into nameservers and searches, possibly returning an error.
0000000000000000000000000000000000000000;;	// TODO: move to utility package
0000000000000000000000000000000000000000;;	func (kl *Kubelet) parseResolvConf(reader io.Reader) (nameservers []string, searches []string, err error) {
0000000000000000000000000000000000000000;;		file, err := ioutil.ReadAll(reader)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Lines of the form "nameserver 1.2.3.4" accumulate.
0000000000000000000000000000000000000000;;		nameservers = []string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Lines of the form "search example.com" overrule - last one wins.
0000000000000000000000000000000000000000;;		searches = []string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lines := strings.Split(string(file), "\n")
0000000000000000000000000000000000000000;;		for l := range lines {
0000000000000000000000000000000000000000;;			trimmed := strings.TrimSpace(lines[l])
0000000000000000000000000000000000000000;;			if strings.HasPrefix(trimmed, "#") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fields := strings.Fields(trimmed)
0000000000000000000000000000000000000000;;			if len(fields) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fields[0] == "nameserver" && len(fields) >= 2 {
0000000000000000000000000000000000000000;;				nameservers = append(nameservers, fields[1])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fields[0] == "search" {
0000000000000000000000000000000000000000;;				searches = fields[1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// There used to be code here to scrub DNS for each cloud, but doesn't
0000000000000000000000000000000000000000;;		// make sense anymore since cloudproviders are being factored out.
0000000000000000000000000000000000000000;;		// contact @thockin or @wlan0 for more information
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nameservers, searches, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncNetworkStatus updates the network state
0000000000000000000000000000000000000000;;	func (kl *Kubelet) syncNetworkStatus() {
0000000000000000000000000000000000000000;;		// For cri integration, network state will be updated in updateRuntimeUp,
0000000000000000000000000000000000000000;;		// we'll get runtime network status through cri directly.
0000000000000000000000000000000000000000;;		// TODO: Remove this once we completely switch to cri integration.
0000000000000000000000000000000000000000;;		if kl.networkPlugin != nil {
0000000000000000000000000000000000000000;;			kl.runtimeState.setNetworkState(kl.networkPlugin.Status())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updatePodCIDR updates the pod CIDR in the runtime state if it is different
0000000000000000000000000000000000000000;;	// from the current CIDR.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) updatePodCIDR(cidr string) {
0000000000000000000000000000000000000000;;		podCIDR := kl.runtimeState.podCIDR()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if podCIDR == cidr {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// kubelet -> network plugin
0000000000000000000000000000000000000000;;		// cri runtime shims are responsible for their own network plugins
0000000000000000000000000000000000000000;;		if kl.networkPlugin != nil {
0000000000000000000000000000000000000000;;			details := make(map[string]interface{})
0000000000000000000000000000000000000000;;			details[network.NET_PLUGIN_EVENT_POD_CIDR_CHANGE_DETAIL_CIDR] = cidr
0000000000000000000000000000000000000000;;			kl.networkPlugin.Event(network.NET_PLUGIN_EVENT_POD_CIDR_CHANGE, details)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// kubelet -> generic runtime -> runtime shim -> network plugin
0000000000000000000000000000000000000000;;		// docker/rkt non-cri implementations have a passthrough UpdatePodCIDR
0000000000000000000000000000000000000000;;		if err := kl.GetRuntime().UpdatePodCIDR(cidr); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to update pod CIDR: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Setting Pod CIDR: %v -> %v", podCIDR, cidr)
0000000000000000000000000000000000000000;;		kl.runtimeState.setPodCIDR(cidr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncNetworkUtil ensures the network utility are present on host.
0000000000000000000000000000000000000000;;	// Network util includes:
0000000000000000000000000000000000000000;;	// 1. 	In nat table, KUBE-MARK-DROP rule to mark connections for dropping
0000000000000000000000000000000000000000;;	// 	Marked connection will be drop on INPUT/OUTPUT Chain in filter table
0000000000000000000000000000000000000000;;	// 2. 	In nat table, KUBE-MARK-MASQ rule to mark connections for SNAT
0000000000000000000000000000000000000000;;	// 	Marked connection will get SNAT on POSTROUTING Chain in nat table
0000000000000000000000000000000000000000;;	func (kl *Kubelet) syncNetworkUtil() {
0000000000000000000000000000000000000000;;		if kl.iptablesMasqueradeBit < 0 || kl.iptablesMasqueradeBit > 31 {
0000000000000000000000000000000000000000;;			glog.Errorf("invalid iptables-masquerade-bit %v not in [0, 31]", kl.iptablesMasqueradeBit)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if kl.iptablesDropBit < 0 || kl.iptablesDropBit > 31 {
0000000000000000000000000000000000000000;;			glog.Errorf("invalid iptables-drop-bit %v not in [0, 31]", kl.iptablesDropBit)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if kl.iptablesDropBit == kl.iptablesMasqueradeBit {
0000000000000000000000000000000000000000;;			glog.Errorf("iptables-masquerade-bit %v and iptables-drop-bit %v must be different", kl.iptablesMasqueradeBit, kl.iptablesDropBit)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup KUBE-MARK-DROP rules
0000000000000000000000000000000000000000;;		dropMark := getIPTablesMark(kl.iptablesDropBit)
0000000000000000000000000000000000000000;;		if _, err := kl.iptClient.EnsureChain(utiliptables.TableNAT, KubeMarkDropChain); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to ensure that %s chain %s exists: %v", utiliptables.TableNAT, KubeMarkDropChain, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := kl.iptClient.EnsureRule(utiliptables.Append, utiliptables.TableNAT, KubeMarkDropChain, "-j", "MARK", "--set-xmark", dropMark); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to ensure marking rule for %v: %v", KubeMarkDropChain, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := kl.iptClient.EnsureChain(utiliptables.TableFilter, KubeFirewallChain); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to ensure that %s chain %s exists: %v", utiliptables.TableFilter, KubeFirewallChain, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := kl.iptClient.EnsureRule(utiliptables.Append, utiliptables.TableFilter, KubeFirewallChain,
0000000000000000000000000000000000000000;;			"-m", "comment", "--comment", "kubernetes firewall for dropping marked packets",
0000000000000000000000000000000000000000;;			"-m", "mark", "--mark", dropMark,
0000000000000000000000000000000000000000;;			"-j", "DROP"); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to ensure rule to drop packet marked by %v in %v chain %v: %v", KubeMarkDropChain, utiliptables.TableFilter, KubeFirewallChain, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := kl.iptClient.EnsureRule(utiliptables.Prepend, utiliptables.TableFilter, utiliptables.ChainOutput, "-j", string(KubeFirewallChain)); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to ensure that %s chain %s jumps to %s: %v", utiliptables.TableFilter, utiliptables.ChainOutput, KubeFirewallChain, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := kl.iptClient.EnsureRule(utiliptables.Prepend, utiliptables.TableFilter, utiliptables.ChainInput, "-j", string(KubeFirewallChain)); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to ensure that %s chain %s jumps to %s: %v", utiliptables.TableFilter, utiliptables.ChainInput, KubeFirewallChain, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup KUBE-MARK-MASQ rules
0000000000000000000000000000000000000000;;		masqueradeMark := getIPTablesMark(kl.iptablesMasqueradeBit)
0000000000000000000000000000000000000000;;		if _, err := kl.iptClient.EnsureChain(utiliptables.TableNAT, KubeMarkMasqChain); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to ensure that %s chain %s exists: %v", utiliptables.TableNAT, KubeMarkMasqChain, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := kl.iptClient.EnsureChain(utiliptables.TableNAT, KubePostroutingChain); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to ensure that %s chain %s exists: %v", utiliptables.TableNAT, KubePostroutingChain, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := kl.iptClient.EnsureRule(utiliptables.Append, utiliptables.TableNAT, KubeMarkMasqChain, "-j", "MARK", "--set-xmark", masqueradeMark); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to ensure marking rule for %v: %v", KubeMarkMasqChain, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := kl.iptClient.EnsureRule(utiliptables.Prepend, utiliptables.TableNAT, utiliptables.ChainPostrouting,
0000000000000000000000000000000000000000;;			"-m", "comment", "--comment", "kubernetes postrouting rules", "-j", string(KubePostroutingChain)); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to ensure that %s chain %s jumps to %s: %v", utiliptables.TableNAT, utiliptables.ChainPostrouting, KubePostroutingChain, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := kl.iptClient.EnsureRule(utiliptables.Append, utiliptables.TableNAT, KubePostroutingChain,
0000000000000000000000000000000000000000;;			"-m", "comment", "--comment", "kubernetes service traffic requiring SNAT",
0000000000000000000000000000000000000000;;			"-m", "mark", "--mark", masqueradeMark, "-j", "MASQUERADE"); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to ensure SNAT rule for packets marked by %v in %v chain %v: %v", KubeMarkMasqChain, utiliptables.TableNAT, KubePostroutingChain, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getIPTablesMark returns the fwmark given the bit
0000000000000000000000000000000000000000;;	func getIPTablesMark(bit int) string {
0000000000000000000000000000000000000000;;		value := 1 << uint(bit)
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%#08x/%#08x", value, value)
0000000000000000000000000000000000000000;;	}
