0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
b4ddc9b441fe4301598714142e5208a3624d5449;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package container
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestCache() *cache {
0000000000000000000000000000000000000000;;		c := NewCache()
0000000000000000000000000000000000000000;;		return c.(*cache)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCacheNotInitialized(t *testing.T) {
0000000000000000000000000000000000000000;;		cache := newTestCache()
0000000000000000000000000000000000000000;;		// If the global timestamp is not set, always return nil.
0000000000000000000000000000000000000000;;		d := cache.getIfNewerThan(types.UID("1234"), time.Time{})
0000000000000000000000000000000000000000;;		assert.True(t, d == nil, "should return nil since cache is not initialized")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTestPodIDAndStatus(numContainers int) (types.UID, *PodStatus) {
0000000000000000000000000000000000000000;;		id := types.UID(strconv.FormatInt(time.Now().UnixNano(), 10))
0000000000000000000000000000000000000000;;		name := fmt.Sprintf("cache-foo-%s", string(id))
0000000000000000000000000000000000000000;;		namespace := "ns"
0000000000000000000000000000000000000000;;		var status *PodStatus
0000000000000000000000000000000000000000;;		if numContainers > 0 {
0000000000000000000000000000000000000000;;			status = &PodStatus{ID: id, Name: name, Namespace: namespace}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			status = &PodStatus{ID: id}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < numContainers; i++ {
0000000000000000000000000000000000000000;;			status.ContainerStatuses = append(status.ContainerStatuses, &ContainerStatus{Name: string(i)})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return id, status
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetIfNewerThanWhenPodExists(t *testing.T) {
0000000000000000000000000000000000000000;;		cache := newTestCache()
0000000000000000000000000000000000000000;;		timestamp := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			cacheTime time.Time
0000000000000000000000000000000000000000;;			modified  time.Time
0000000000000000000000000000000000000000;;			expected  bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Both the global cache timestamp and the modified time are newer
0000000000000000000000000000000000000000;;				// than the timestamp.
0000000000000000000000000000000000000000;;				cacheTime: timestamp.Add(time.Second),
0000000000000000000000000000000000000000;;				modified:  timestamp,
0000000000000000000000000000000000000000;;				expected:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Global cache timestamp is newer, but the pod entry modified
0000000000000000000000000000000000000000;;				// time is older than the given timestamp. This means that the
0000000000000000000000000000000000000000;;				// entry is up-to-date even though it hasn't changed for a while.
0000000000000000000000000000000000000000;;				cacheTime: timestamp.Add(time.Second),
0000000000000000000000000000000000000000;;				modified:  timestamp.Add(-time.Second * 10),
0000000000000000000000000000000000000000;;				expected:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Global cache timestamp is older, but the pod entry modified
0000000000000000000000000000000000000000;;				// time is newer than the given timestamp. This means that the
0000000000000000000000000000000000000000;;				// entry is up-to-date but the rest of the cache are still being
0000000000000000000000000000000000000000;;				// updated.
0000000000000000000000000000000000000000;;				cacheTime: timestamp.Add(-time.Second),
0000000000000000000000000000000000000000;;				modified:  timestamp.Add(time.Second * 3),
0000000000000000000000000000000000000000;;				expected:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Both the global cache timestamp and the modified time are older
0000000000000000000000000000000000000000;;				// than the given timestamp.
0000000000000000000000000000000000000000;;				cacheTime: timestamp.Add(-time.Second),
0000000000000000000000000000000000000000;;				modified:  timestamp.Add(-time.Second),
0000000000000000000000000000000000000000;;				expected:  false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, c := range cases {
0000000000000000000000000000000000000000;;			podID, status := getTestPodIDAndStatus(2)
0000000000000000000000000000000000000000;;			cache.UpdateTime(c.cacheTime)
0000000000000000000000000000000000000000;;			cache.Set(podID, status, nil, c.modified)
0000000000000000000000000000000000000000;;			d := cache.getIfNewerThan(podID, timestamp)
0000000000000000000000000000000000000000;;			assert.Equal(t, c.expected, d != nil, "test[%d]", i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetPodNewerThanWhenPodDoesNotExist(t *testing.T) {
0000000000000000000000000000000000000000;;		cache := newTestCache()
0000000000000000000000000000000000000000;;		cacheTime := time.Now()
0000000000000000000000000000000000000000;;		cache.UpdateTime(cacheTime)
0000000000000000000000000000000000000000;;		podID := types.UID("1234")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			timestamp time.Time
0000000000000000000000000000000000000000;;			expected  bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				timestamp: cacheTime.Add(-time.Second),
0000000000000000000000000000000000000000;;				expected:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				timestamp: cacheTime.Add(time.Second),
0000000000000000000000000000000000000000;;				expected:  false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, c := range cases {
0000000000000000000000000000000000000000;;			d := cache.getIfNewerThan(podID, c.timestamp)
0000000000000000000000000000000000000000;;			assert.Equal(t, c.expected, d != nil, "test[%d]", i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCacheSetAndGet(t *testing.T) {
0000000000000000000000000000000000000000;;		cache := NewCache()
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			numContainers int
0000000000000000000000000000000000000000;;			error         error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{numContainers: 3, error: nil},
0000000000000000000000000000000000000000;;			{numContainers: 2, error: fmt.Errorf("unable to get status")},
0000000000000000000000000000000000000000;;			{numContainers: 0, error: nil},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, c := range cases {
0000000000000000000000000000000000000000;;			podID, status := getTestPodIDAndStatus(c.numContainers)
0000000000000000000000000000000000000000;;			cache.Set(podID, status, c.error, time.Time{})
0000000000000000000000000000000000000000;;			// Read back the status and error stored in cache and make sure they
0000000000000000000000000000000000000000;;			// match the original ones.
0000000000000000000000000000000000000000;;			actualStatus, actualErr := cache.Get(podID)
0000000000000000000000000000000000000000;;			assert.Equal(t, status, actualStatus, "test[%d]", i)
0000000000000000000000000000000000000000;;			assert.Equal(t, c.error, actualErr, "test[%d]", i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCacheGetPodDoesNotExist(t *testing.T) {
0000000000000000000000000000000000000000;;		cache := NewCache()
0000000000000000000000000000000000000000;;		podID, status := getTestPodIDAndStatus(0)
0000000000000000000000000000000000000000;;		// If the pod does not exist in cache, cache should return an status
0000000000000000000000000000000000000000;;		// object with id filled.
0000000000000000000000000000000000000000;;		actualStatus, actualErr := cache.Get(podID)
0000000000000000000000000000000000000000;;		assert.Equal(t, status, actualStatus)
0000000000000000000000000000000000000000;;		assert.Equal(t, nil, actualErr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDelete(t *testing.T) {
0000000000000000000000000000000000000000;;		cache := &cache{pods: map[types.UID]*data{}}
0000000000000000000000000000000000000000;;		// Write a new pod status into the cache.
0000000000000000000000000000000000000000;;		podID, status := getTestPodIDAndStatus(3)
0000000000000000000000000000000000000000;;		cache.Set(podID, status, nil, time.Time{})
0000000000000000000000000000000000000000;;		actualStatus, actualErr := cache.Get(podID)
0000000000000000000000000000000000000000;;		assert.Equal(t, status, actualStatus)
0000000000000000000000000000000000000000;;		assert.Equal(t, nil, actualErr)
0000000000000000000000000000000000000000;;		// Delete the pod from cache, and verify that we get an empty status.
0000000000000000000000000000000000000000;;		cache.Delete(podID)
0000000000000000000000000000000000000000;;		expectedStatus := &PodStatus{ID: podID}
0000000000000000000000000000000000000000;;		actualStatus, actualErr = cache.Get(podID)
0000000000000000000000000000000000000000;;		assert.Equal(t, expectedStatus, actualStatus)
0000000000000000000000000000000000000000;;		assert.Equal(t, nil, actualErr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyNotification(t *testing.T, ch chan *data, expectNotification bool) {
0000000000000000000000000000000000000000;;		if expectNotification {
0000000000000000000000000000000000000000;;			assert.True(t, len(ch) > 0, "Did not receive notification")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			assert.True(t, len(ch) < 1, "Should not have triggered the notification")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Drain the channel.
0000000000000000000000000000000000000000;;		for i := 0; i < len(ch); i++ {
0000000000000000000000000000000000000000;;			<-ch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRegisterNotification(t *testing.T) {
0000000000000000000000000000000000000000;;		cache := newTestCache()
0000000000000000000000000000000000000000;;		cacheTime := time.Now()
0000000000000000000000000000000000000000;;		cache.UpdateTime(cacheTime)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podID, status := getTestPodIDAndStatus(1)
0000000000000000000000000000000000000000;;		ch := cache.subscribe(podID, cacheTime.Add(time.Second))
0000000000000000000000000000000000000000;;		verifyNotification(t, ch, false)
0000000000000000000000000000000000000000;;		cache.Set(podID, status, nil, cacheTime.Add(time.Second))
0000000000000000000000000000000000000000;;		// The Set operation should've triggered the notification.
0000000000000000000000000000000000000000;;		verifyNotification(t, ch, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podID, _ = getTestPodIDAndStatus(1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ch = cache.subscribe(podID, cacheTime.Add(time.Second))
0000000000000000000000000000000000000000;;		verifyNotification(t, ch, false)
0000000000000000000000000000000000000000;;		cache.UpdateTime(cacheTime.Add(time.Second * 2))
0000000000000000000000000000000000000000;;		// The advance of cache timestamp should've triggered the notification.
0000000000000000000000000000000000000000;;		verifyNotification(t, ch, true)
0000000000000000000000000000000000000000;;	}
