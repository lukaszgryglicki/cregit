0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f97269008144cfbaf583377097fcafcbb736f8ed;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package container
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// TODO(yifan): Maybe set the them as parameters for NewCache().
0000000000000000000000000000000000000000;;		defaultCachePeriod = time.Second * 2
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RuntimeCache interface {
0000000000000000000000000000000000000000;;		GetPods() ([]*Pod, error)
0000000000000000000000000000000000000000;;		ForceUpdateIfOlder(time.Time) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type podsGetter interface {
0000000000000000000000000000000000000000;;		GetPods(bool) ([]*Pod, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRuntimeCache creates a container runtime cache.
0000000000000000000000000000000000000000;;	func NewRuntimeCache(getter podsGetter) (RuntimeCache, error) {
0000000000000000000000000000000000000000;;		return &runtimeCache{
0000000000000000000000000000000000000000;;			getter: getter,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// runtimeCache caches a list of pods. It records a timestamp (cacheTime) right
0000000000000000000000000000000000000000;;	// before updating the pods, so the timestamp is at most as new as the pods
0000000000000000000000000000000000000000;;	// (and can be slightly older). The timestamp always moves forward. Callers are
0000000000000000000000000000000000000000;;	// expected not to modify the pods returned from GetPods.
0000000000000000000000000000000000000000;;	type runtimeCache struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		// The underlying container runtime used to update the cache.
0000000000000000000000000000000000000000;;		getter podsGetter
0000000000000000000000000000000000000000;;		// Last time when cache was updated.
0000000000000000000000000000000000000000;;		cacheTime time.Time
0000000000000000000000000000000000000000;;		// The content of the cache.
0000000000000000000000000000000000000000;;		pods []*Pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPods returns the cached pods if they are not outdated; otherwise, it
0000000000000000000000000000000000000000;;	// retrieves the latest pods and return them.
0000000000000000000000000000000000000000;;	func (r *runtimeCache) GetPods() ([]*Pod, error) {
0000000000000000000000000000000000000000;;		r.Lock()
0000000000000000000000000000000000000000;;		defer r.Unlock()
0000000000000000000000000000000000000000;;		if time.Since(r.cacheTime) > defaultCachePeriod {
0000000000000000000000000000000000000000;;			if err := r.updateCache(); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.pods, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *runtimeCache) ForceUpdateIfOlder(minExpectedCacheTime time.Time) error {
0000000000000000000000000000000000000000;;		r.Lock()
0000000000000000000000000000000000000000;;		defer r.Unlock()
0000000000000000000000000000000000000000;;		if r.cacheTime.Before(minExpectedCacheTime) {
0000000000000000000000000000000000000000;;			return r.updateCache()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *runtimeCache) updateCache() error {
0000000000000000000000000000000000000000;;		pods, timestamp, err := r.getPodsWithTimestamp()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.pods, r.cacheTime = pods, timestamp
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodsWithTimestamp records a timestamp and retrieves pods from the getter.
0000000000000000000000000000000000000000;;	func (r *runtimeCache) getPodsWithTimestamp() ([]*Pod, time.Time, error) {
0000000000000000000000000000000000000000;;		// Always record the timestamp before getting the pods to avoid stale pods.
0000000000000000000000000000000000000000;;		timestamp := time.Now()
0000000000000000000000000000000000000000;;		pods, err := r.getter.GetPods(false)
0000000000000000000000000000000000000000;;		return pods, timestamp, err
0000000000000000000000000000000000000000;;	}
