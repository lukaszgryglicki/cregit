0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
139e19016a44bc8507f89ff3dd9db3243cb85aa1;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package container
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/remotecommand"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/flowcontrol"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Version interface {
0000000000000000000000000000000000000000;;		// Compare compares two versions of the runtime. On success it returns -1
0000000000000000000000000000000000000000;;		// if the version is less than the other, 1 if it is greater than the other,
0000000000000000000000000000000000000000;;		// or 0 if they are equal.
0000000000000000000000000000000000000000;;		Compare(other string) (int, error)
0000000000000000000000000000000000000000;;		// String returns a string that represents the version.
0000000000000000000000000000000000000000;;		String() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ImageSpec is an internal representation of an image.  Currently, it wraps the
0000000000000000000000000000000000000000;;	// value of a Container's Image field, but in the future it will include more detailed
0000000000000000000000000000000000000000;;	// information about the different image types.
0000000000000000000000000000000000000000;;	type ImageSpec struct {
0000000000000000000000000000000000000000;;		Image string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ImageStats contains statistics about all the images currently available.
0000000000000000000000000000000000000000;;	type ImageStats struct {
0000000000000000000000000000000000000000;;		// Total amount of storage consumed by existing images.
0000000000000000000000000000000000000000;;		TotalStorageBytes uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Runtime interface defines the interfaces that should be implemented
0000000000000000000000000000000000000000;;	// by a container runtime.
0000000000000000000000000000000000000000;;	// Thread safety is required from implementations of this interface.
0000000000000000000000000000000000000000;;	type Runtime interface {
0000000000000000000000000000000000000000;;		// Type returns the type of the container runtime.
0000000000000000000000000000000000000000;;		Type() string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Version returns the version information of the container runtime.
0000000000000000000000000000000000000000;;		Version() (Version, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// APIVersion returns the cached API version information of the container
0000000000000000000000000000000000000000;;		// runtime. Implementation is expected to update this cache periodically.
0000000000000000000000000000000000000000;;		// This may be different from the runtime engine's version.
0000000000000000000000000000000000000000;;		// TODO(random-liu): We should fold this into Version()
0000000000000000000000000000000000000000;;		APIVersion() (Version, error)
0000000000000000000000000000000000000000;;		// Status returns the status of the runtime. An error is returned if the Status
0000000000000000000000000000000000000000;;		// function itself fails, nil otherwise.
0000000000000000000000000000000000000000;;		Status() (*RuntimeStatus, error)
0000000000000000000000000000000000000000;;		// GetPods returns a list of containers grouped by pods. The boolean parameter
0000000000000000000000000000000000000000;;		// specifies whether the runtime returns all containers including those already
0000000000000000000000000000000000000000;;		// exited and dead containers (used for garbage collection).
0000000000000000000000000000000000000000;;		GetPods(all bool) ([]*Pod, error)
0000000000000000000000000000000000000000;;		// GarbageCollect removes dead containers using the specified container gc policy
0000000000000000000000000000000000000000;;		// If allSourcesReady is not true, it means that kubelet doesn't have the
0000000000000000000000000000000000000000;;		// complete list of pods from all avialble sources (e.g., apiserver, http,
0000000000000000000000000000000000000000;;		// file). In this case, garbage collector should refrain itself from aggressive
0000000000000000000000000000000000000000;;		// behavior such as removing all containers of unrecognized pods (yet).
0000000000000000000000000000000000000000;;		// If evictNonDeletedPods is set to true, containers and sandboxes belonging to pods
0000000000000000000000000000000000000000;;		// that are terminated, but not deleted will be evicted.  Otherwise, only deleted pods will be GC'd.
0000000000000000000000000000000000000000;;		// TODO: Revisit this method and make it cleaner.
0000000000000000000000000000000000000000;;		GarbageCollect(gcPolicy ContainerGCPolicy, allSourcesReady bool, evictNonDeletedPods bool) error
0000000000000000000000000000000000000000;;		// Syncs the running pod into the desired pod.
0000000000000000000000000000000000000000;;		SyncPod(pod *v1.Pod, apiPodStatus v1.PodStatus, podStatus *PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff) PodSyncResult
0000000000000000000000000000000000000000;;		// KillPod kills all the containers of a pod. Pod may be nil, running pod must not be.
0000000000000000000000000000000000000000;;		// TODO(random-liu): Return PodSyncResult in KillPod.
0000000000000000000000000000000000000000;;		// gracePeriodOverride if specified allows the caller to override the pod default grace period.
0000000000000000000000000000000000000000;;		// only hard kill paths are allowed to specify a gracePeriodOverride in the kubelet in order to not corrupt user data.
0000000000000000000000000000000000000000;;		// it is useful when doing SIGKILL for hard eviction scenarios, or max grace period during soft eviction scenarios.
0000000000000000000000000000000000000000;;		KillPod(pod *v1.Pod, runningPod Pod, gracePeriodOverride *int64) error
0000000000000000000000000000000000000000;;		// GetPodStatus retrieves the status of the pod, including the
0000000000000000000000000000000000000000;;		// information of all containers in the pod that are visble in Runtime.
0000000000000000000000000000000000000000;;		GetPodStatus(uid types.UID, name, namespace string) (*PodStatus, error)
0000000000000000000000000000000000000000;;		// Returns the filesystem path of the pod's network namespace; if the
0000000000000000000000000000000000000000;;		// runtime does not handle namespace creation itself, or cannot return
0000000000000000000000000000000000000000;;		// the network namespace path, it should return an error.
0000000000000000000000000000000000000000;;		// TODO: Change ContainerID to a Pod ID since the namespace is shared
0000000000000000000000000000000000000000;;		// by all containers in the pod.
0000000000000000000000000000000000000000;;		GetNetNS(containerID ContainerID) (string, error)
0000000000000000000000000000000000000000;;		// Returns the container ID that represents the Pod, as passed to network
0000000000000000000000000000000000000000;;		// plugins. For example, if the runtime uses an infra container, returns
0000000000000000000000000000000000000000;;		// the infra container's ContainerID.
0000000000000000000000000000000000000000;;		// TODO: Change ContainerID to a Pod ID, see GetNetNS()
0000000000000000000000000000000000000000;;		GetPodContainerID(*Pod) (ContainerID, error)
0000000000000000000000000000000000000000;;		// TODO(vmarmol): Unify pod and containerID args.
0000000000000000000000000000000000000000;;		// GetContainerLogs returns logs of a specific container. By
0000000000000000000000000000000000000000;;		// default, it returns a snapshot of the container log. Set 'follow' to true to
0000000000000000000000000000000000000000;;		// stream the log. Set 'follow' to false and specify the number of lines (e.g.
0000000000000000000000000000000000000000;;		// "100" or "all") to tail the log.
0000000000000000000000000000000000000000;;		GetContainerLogs(pod *v1.Pod, containerID ContainerID, logOptions *v1.PodLogOptions, stdout, stderr io.Writer) (err error)
0000000000000000000000000000000000000000;;		// Delete a container. If the container is still running, an error is returned.
0000000000000000000000000000000000000000;;		DeleteContainer(containerID ContainerID) error
0000000000000000000000000000000000000000;;		// ImageService provides methods to image-related methods.
0000000000000000000000000000000000000000;;		ImageService
0000000000000000000000000000000000000000;;		// UpdatePodCIDR sends a new podCIDR to the runtime.
0000000000000000000000000000000000000000;;		// This method just proxies a new runtimeConfig with the updated
0000000000000000000000000000000000000000;;		// CIDR value down to the runtime shim.
0000000000000000000000000000000000000000;;		UpdatePodCIDR(podCIDR string) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DirectStreamingRuntime is the interface implemented by runtimes for which the streaming calls
0000000000000000000000000000000000000000;;	// (exec/attach/port-forward) should be served directly by the Kubelet.
0000000000000000000000000000000000000000;;	type DirectStreamingRuntime interface {
0000000000000000000000000000000000000000;;		// Runs the command in the container of the specified pod using nsenter.
0000000000000000000000000000000000000000;;		// Attaches the processes stdin, stdout, and stderr. Optionally uses a
0000000000000000000000000000000000000000;;		// tty.
0000000000000000000000000000000000000000;;		ExecInContainer(containerID ContainerID, cmd []string, stdin io.Reader, stdout, stderr io.WriteCloser, tty bool, resize <-chan remotecommand.TerminalSize, timeout time.Duration) error
0000000000000000000000000000000000000000;;		// Forward the specified port from the specified pod to the stream.
0000000000000000000000000000000000000000;;		PortForward(pod *Pod, port int32, stream io.ReadWriteCloser) error
0000000000000000000000000000000000000000;;		// ContainerAttach encapsulates the attaching to containers for testability
0000000000000000000000000000000000000000;;		ContainerAttacher
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IndirectStreamingRuntime is the interface implemented by runtimes that handle the serving of the
0000000000000000000000000000000000000000;;	// streaming calls (exec/attach/port-forward) themselves. In this case, Kubelet should redirect to
0000000000000000000000000000000000000000;;	// the runtime server.
0000000000000000000000000000000000000000;;	type IndirectStreamingRuntime interface {
0000000000000000000000000000000000000000;;		GetExec(id ContainerID, cmd []string, stdin, stdout, stderr, tty bool) (*url.URL, error)
0000000000000000000000000000000000000000;;		GetAttach(id ContainerID, stdin, stdout, stderr, tty bool) (*url.URL, error)
0000000000000000000000000000000000000000;;		GetPortForward(podName, podNamespace string, podUID types.UID, ports []int32) (*url.URL, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ImageService interface {
0000000000000000000000000000000000000000;;		// PullImage pulls an image from the network to local storage using the supplied
0000000000000000000000000000000000000000;;		// secrets if necessary. It returns a reference (digest or ID) to the pulled image.
0000000000000000000000000000000000000000;;		PullImage(image ImageSpec, pullSecrets []v1.Secret) (string, error)
0000000000000000000000000000000000000000;;		// GetImageRef gets the reference (digest or ID) of the image which has already been in
0000000000000000000000000000000000000000;;		// the local storage. It returns ("", nil) if the image isn't in the local storage.
0000000000000000000000000000000000000000;;		GetImageRef(image ImageSpec) (string, error)
0000000000000000000000000000000000000000;;		// Gets all images currently on the machine.
0000000000000000000000000000000000000000;;		ListImages() ([]Image, error)
0000000000000000000000000000000000000000;;		// Removes the specified image.
0000000000000000000000000000000000000000;;		RemoveImage(image ImageSpec) error
0000000000000000000000000000000000000000;;		// Returns Image statistics.
0000000000000000000000000000000000000000;;		ImageStats() (*ImageStats, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ContainerAttacher interface {
0000000000000000000000000000000000000000;;		AttachContainer(id ContainerID, stdin io.Reader, stdout, stderr io.WriteCloser, tty bool, resize <-chan remotecommand.TerminalSize) (err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ContainerCommandRunner interface {
0000000000000000000000000000000000000000;;		// RunInContainer synchronously executes the command in the container, and returns the output.
0000000000000000000000000000000000000000;;		// If the command completes with a non-0 exit code, a pkg/util/exec.ExitError will be returned.
0000000000000000000000000000000000000000;;		RunInContainer(id ContainerID, cmd []string, timeout time.Duration) ([]byte, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pod is a group of containers.
0000000000000000000000000000000000000000;;	type Pod struct {
0000000000000000000000000000000000000000;;		// The ID of the pod, which can be used to retrieve a particular pod
0000000000000000000000000000000000000000;;		// from the pod list returned by GetPods().
0000000000000000000000000000000000000000;;		ID types.UID
0000000000000000000000000000000000000000;;		// The name and namespace of the pod, which is readable by human.
0000000000000000000000000000000000000000;;		Name      string
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;		// List of containers that belongs to this pod. It may contain only
0000000000000000000000000000000000000000;;		// running containers, or mixed with dead ones (when GetPods(true)).
0000000000000000000000000000000000000000;;		Containers []*Container
0000000000000000000000000000000000000000;;		// List of sandboxes associated with this pod. The sandboxes are converted
0000000000000000000000000000000000000000;;		// to Container temporariliy to avoid substantial changes to other
0000000000000000000000000000000000000000;;		// components. This is only populated by kuberuntime.
0000000000000000000000000000000000000000;;		// TODO: use the runtimeApi.PodSandbox type directly.
0000000000000000000000000000000000000000;;		Sandboxes []*Container
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodPair contains both runtime#Pod and api#Pod
0000000000000000000000000000000000000000;;	type PodPair struct {
0000000000000000000000000000000000000000;;		// APIPod is the v1.Pod
0000000000000000000000000000000000000000;;		APIPod *v1.Pod
0000000000000000000000000000000000000000;;		// RunningPod is the pod defined in pkg/kubelet/container/runtime#Pod
0000000000000000000000000000000000000000;;		RunningPod *Pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerID is a type that identifies a container.
0000000000000000000000000000000000000000;;	type ContainerID struct {
0000000000000000000000000000000000000000;;		// The type of the container runtime. e.g. 'docker', 'rkt'.
0000000000000000000000000000000000000000;;		Type string
0000000000000000000000000000000000000000;;		// The identification of the container, this is comsumable by
0000000000000000000000000000000000000000;;		// the underlying container runtime. (Note that the container
0000000000000000000000000000000000000000;;		// runtime interface still takes the whole struct as input).
0000000000000000000000000000000000000000;;		ID string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BuildContainerID(typ, ID string) ContainerID {
0000000000000000000000000000000000000000;;		return ContainerID{Type: typ, ID: ID}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convenience method for creating a ContainerID from an ID string.
0000000000000000000000000000000000000000;;	func ParseContainerID(containerID string) ContainerID {
0000000000000000000000000000000000000000;;		var id ContainerID
0000000000000000000000000000000000000000;;		if err := id.ParseString(containerID); err != nil {
0000000000000000000000000000000000000000;;			glog.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return id
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ContainerID) ParseString(data string) error {
0000000000000000000000000000000000000000;;		// Trim the quotes and split the type and ID.
0000000000000000000000000000000000000000;;		parts := strings.Split(strings.Trim(data, "\""), "://")
0000000000000000000000000000000000000000;;		if len(parts) != 2 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid container ID: %q", data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Type, c.ID = parts[0], parts[1]
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ContainerID) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s://%s", c.Type, c.ID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ContainerID) IsEmpty() bool {
0000000000000000000000000000000000000000;;		return *c == ContainerID{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ContainerID) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		return []byte(fmt.Sprintf("%q", c.String())), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ContainerID) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		return c.ParseString(string(data))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DockerID is an ID of docker container. It is a type to make it clear when we're working with docker container Ids
0000000000000000000000000000000000000000;;	type DockerID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (id DockerID) ContainerID() ContainerID {
0000000000000000000000000000000000000000;;		return ContainerID{
0000000000000000000000000000000000000000;;			Type: "docker",
0000000000000000000000000000000000000000;;			ID:   string(id),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ContainerState string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ContainerStateCreated ContainerState = "created"
0000000000000000000000000000000000000000;;		ContainerStateRunning ContainerState = "running"
0000000000000000000000000000000000000000;;		ContainerStateExited  ContainerState = "exited"
0000000000000000000000000000000000000000;;		// This unknown encompasses all the states that we currently don't care.
0000000000000000000000000000000000000000;;		ContainerStateUnknown ContainerState = "unknown"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Container provides the runtime information for a container, such as ID, hash,
0000000000000000000000000000000000000000;;	// state of the container.
0000000000000000000000000000000000000000;;	type Container struct {
0000000000000000000000000000000000000000;;		// The ID of the container, used by the container runtime to identify
0000000000000000000000000000000000000000;;		// a container.
0000000000000000000000000000000000000000;;		ID ContainerID
0000000000000000000000000000000000000000;;		// The name of the container, which should be the same as specified by
0000000000000000000000000000000000000000;;		// v1.Container.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// The image name of the container, this also includes the tag of the image,
0000000000000000000000000000000000000000;;		// the expected form is "NAME:TAG".
0000000000000000000000000000000000000000;;		Image string
0000000000000000000000000000000000000000;;		// The id of the image used by the container.
0000000000000000000000000000000000000000;;		ImageID string
0000000000000000000000000000000000000000;;		// Hash of the container, used for comparison. Optional for containers
0000000000000000000000000000000000000000;;		// not managed by kubelet.
0000000000000000000000000000000000000000;;		Hash uint64
0000000000000000000000000000000000000000;;		// State is the state of the container.
0000000000000000000000000000000000000000;;		State ContainerState
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodStatus represents the status of the pod and its containers.
0000000000000000000000000000000000000000;;	// v1.PodStatus can be derived from examining PodStatus and v1.Pod.
0000000000000000000000000000000000000000;;	type PodStatus struct {
0000000000000000000000000000000000000000;;		// ID of the pod.
0000000000000000000000000000000000000000;;		ID types.UID
0000000000000000000000000000000000000000;;		// Name of the pod.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// Namspace of the pod.
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;		// IP of the pod.
0000000000000000000000000000000000000000;;		IP string
0000000000000000000000000000000000000000;;		// Status of containers in the pod.
0000000000000000000000000000000000000000;;		ContainerStatuses []*ContainerStatus
0000000000000000000000000000000000000000;;		// Status of the pod sandbox.
0000000000000000000000000000000000000000;;		// Only for kuberuntime now, other runtime may keep it nil.
0000000000000000000000000000000000000000;;		SandboxStatuses []*runtimeapi.PodSandboxStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerStatus represents the status of a container.
0000000000000000000000000000000000000000;;	type ContainerStatus struct {
0000000000000000000000000000000000000000;;		// ID of the container.
0000000000000000000000000000000000000000;;		ID ContainerID
0000000000000000000000000000000000000000;;		// Name of the container.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// Status of the container.
0000000000000000000000000000000000000000;;		State ContainerState
0000000000000000000000000000000000000000;;		// Creation time of the container.
0000000000000000000000000000000000000000;;		CreatedAt time.Time
0000000000000000000000000000000000000000;;		// Start time of the container.
0000000000000000000000000000000000000000;;		StartedAt time.Time
0000000000000000000000000000000000000000;;		// Finish time of the container.
0000000000000000000000000000000000000000;;		FinishedAt time.Time
0000000000000000000000000000000000000000;;		// Exit code of the container.
0000000000000000000000000000000000000000;;		ExitCode int
0000000000000000000000000000000000000000;;		// Name of the image, this also includes the tag of the image,
0000000000000000000000000000000000000000;;		// the expected form is "NAME:TAG".
0000000000000000000000000000000000000000;;		Image string
0000000000000000000000000000000000000000;;		// ID of the image.
0000000000000000000000000000000000000000;;		ImageID string
0000000000000000000000000000000000000000;;		// Hash of the container, used for comparison.
0000000000000000000000000000000000000000;;		Hash uint64
0000000000000000000000000000000000000000;;		// Number of times that the container has been restarted.
0000000000000000000000000000000000000000;;		RestartCount int
0000000000000000000000000000000000000000;;		// A string explains why container is in such a status.
0000000000000000000000000000000000000000;;		Reason string
0000000000000000000000000000000000000000;;		// Message written by the container before exiting (stored in
0000000000000000000000000000000000000000;;		// TerminationMessagePath).
0000000000000000000000000000000000000000;;		Message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindContainerStatusByName returns container status in the pod status with the given name.
0000000000000000000000000000000000000000;;	// When there are multiple containers' statuses with the same name, the first match will be returned.
0000000000000000000000000000000000000000;;	func (podStatus *PodStatus) FindContainerStatusByName(containerName string) *ContainerStatus {
0000000000000000000000000000000000000000;;		for _, containerStatus := range podStatus.ContainerStatuses {
0000000000000000000000000000000000000000;;			if containerStatus.Name == containerName {
0000000000000000000000000000000000000000;;				return containerStatus
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get container status of all the running containers in a pod
0000000000000000000000000000000000000000;;	func (podStatus *PodStatus) GetRunningContainerStatuses() []*ContainerStatus {
0000000000000000000000000000000000000000;;		runningContainerStatuses := []*ContainerStatus{}
0000000000000000000000000000000000000000;;		for _, containerStatus := range podStatus.ContainerStatuses {
0000000000000000000000000000000000000000;;			if containerStatus.State == ContainerStateRunning {
0000000000000000000000000000000000000000;;				runningContainerStatuses = append(runningContainerStatuses, containerStatus)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return runningContainerStatuses
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Basic information about a container image.
0000000000000000000000000000000000000000;;	type Image struct {
0000000000000000000000000000000000000000;;		// ID of the image.
0000000000000000000000000000000000000000;;		ID string
0000000000000000000000000000000000000000;;		// Other names by which this image is known.
0000000000000000000000000000000000000000;;		RepoTags []string
0000000000000000000000000000000000000000;;		// Digests by which this image is known.
0000000000000000000000000000000000000000;;		RepoDigests []string
0000000000000000000000000000000000000000;;		// The size of the image in bytes.
0000000000000000000000000000000000000000;;		Size int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EnvVar struct {
0000000000000000000000000000000000000000;;		Name  string
0000000000000000000000000000000000000000;;		Value string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Mount struct {
0000000000000000000000000000000000000000;;		// Name of the volume mount.
0000000000000000000000000000000000000000;;		// TODO(yifan): Remove this field, as this is not representing the unique name of the mount,
0000000000000000000000000000000000000000;;		// but the volume name only.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// Path of the mount within the container.
0000000000000000000000000000000000000000;;		ContainerPath string
0000000000000000000000000000000000000000;;		// Path of the mount on the host.
0000000000000000000000000000000000000000;;		HostPath string
0000000000000000000000000000000000000000;;		// Whether the mount is read-only.
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;		// Whether the mount needs SELinux relabeling
0000000000000000000000000000000000000000;;		SELinuxRelabel bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PortMapping struct {
0000000000000000000000000000000000000000;;		// Name of the port mapping
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// Protocol of the port mapping.
0000000000000000000000000000000000000000;;		Protocol v1.Protocol
0000000000000000000000000000000000000000;;		// The port number within the container.
0000000000000000000000000000000000000000;;		ContainerPort int
0000000000000000000000000000000000000000;;		// The port number on the host.
0000000000000000000000000000000000000000;;		HostPort int
0000000000000000000000000000000000000000;;		// The host IP.
0000000000000000000000000000000000000000;;		HostIP string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DeviceInfo struct {
0000000000000000000000000000000000000000;;		// Path on host for mapping
0000000000000000000000000000000000000000;;		PathOnHost string
0000000000000000000000000000000000000000;;		// Path in Container to map
0000000000000000000000000000000000000000;;		PathInContainer string
0000000000000000000000000000000000000000;;		// Cgroup permissions
0000000000000000000000000000000000000000;;		Permissions string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunContainerOptions specify the options which are necessary for running containers
0000000000000000000000000000000000000000;;	type RunContainerOptions struct {
0000000000000000000000000000000000000000;;		// The environment variables list.
0000000000000000000000000000000000000000;;		Envs []EnvVar
0000000000000000000000000000000000000000;;		// The mounts for the containers.
0000000000000000000000000000000000000000;;		Mounts []Mount
0000000000000000000000000000000000000000;;		// The host devices mapped into the containers.
0000000000000000000000000000000000000000;;		Devices []DeviceInfo
0000000000000000000000000000000000000000;;		// The port mappings for the containers.
0000000000000000000000000000000000000000;;		PortMappings []PortMapping
0000000000000000000000000000000000000000;;		// If the container has specified the TerminationMessagePath, then
0000000000000000000000000000000000000000;;		// this directory will be used to create and mount the log file to
0000000000000000000000000000000000000000;;		// container.TerminationMessagePath
0000000000000000000000000000000000000000;;		PodContainerDir string
0000000000000000000000000000000000000000;;		// The list of DNS servers for the container to use.
0000000000000000000000000000000000000000;;		DNS []string
0000000000000000000000000000000000000000;;		// The list of DNS search domains.
0000000000000000000000000000000000000000;;		DNSSearch []string
0000000000000000000000000000000000000000;;		// The parent cgroup to pass to Docker
0000000000000000000000000000000000000000;;		CgroupParent string
0000000000000000000000000000000000000000;;		// The type of container rootfs
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;		// hostname for pod containers
0000000000000000000000000000000000000000;;		Hostname string
0000000000000000000000000000000000000000;;		// EnableHostUserNamespace sets userns=host when users request host namespaces (pid, ipc, net),
0000000000000000000000000000000000000000;;		// are using non-namespaced capabilities (mknod, sys_time, sys_module), the pod contains a privileged container,
0000000000000000000000000000000000000000;;		// or using host path volumes.
0000000000000000000000000000000000000000;;		// This should only be enabled when the container runtime is performing user remapping AND if the
0000000000000000000000000000000000000000;;		// experimental behavior is desired.
0000000000000000000000000000000000000000;;		EnableHostUserNamespace bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeInfo contains information about the volume.
0000000000000000000000000000000000000000;;	type VolumeInfo struct {
0000000000000000000000000000000000000000;;		// Mounter is the volume's mounter
0000000000000000000000000000000000000000;;		Mounter volume.Mounter
0000000000000000000000000000000000000000;;		// SELinuxLabeled indicates whether this volume has had the
0000000000000000000000000000000000000000;;		// pod's SELinux label applied to it or not
0000000000000000000000000000000000000000;;		SELinuxLabeled bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type VolumeMap map[string]VolumeInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RuntimeConditionType is the types of required runtime conditions.
0000000000000000000000000000000000000000;;	type RuntimeConditionType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// RuntimeReady means the runtime is up and ready to accept basic containers.
0000000000000000000000000000000000000000;;		RuntimeReady RuntimeConditionType = "RuntimeReady"
0000000000000000000000000000000000000000;;		// NetworkReady means the runtime network is up and ready to accept containers which require network.
0000000000000000000000000000000000000000;;		NetworkReady RuntimeConditionType = "NetworkReady"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RuntimeStatus contains the status of the runtime.
0000000000000000000000000000000000000000;;	type RuntimeStatus struct {
0000000000000000000000000000000000000000;;		// Conditions is an array of current observed runtime conditions.
0000000000000000000000000000000000000000;;		Conditions []RuntimeCondition
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetRuntimeCondition gets a specified runtime condition from the runtime status.
0000000000000000000000000000000000000000;;	func (r *RuntimeStatus) GetRuntimeCondition(t RuntimeConditionType) *RuntimeCondition {
0000000000000000000000000000000000000000;;		for i := range r.Conditions {
0000000000000000000000000000000000000000;;			c := &r.Conditions[i]
0000000000000000000000000000000000000000;;			if c.Type == t {
0000000000000000000000000000000000000000;;				return c
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String formats the runtime status into human readable string.
0000000000000000000000000000000000000000;;	func (s *RuntimeStatus) String() string {
0000000000000000000000000000000000000000;;		var ss []string
0000000000000000000000000000000000000000;;		for _, c := range s.Conditions {
0000000000000000000000000000000000000000;;			ss = append(ss, c.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("Runtime Conditions: %s", strings.Join(ss, ", "))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RuntimeCondition contains condition information for the runtime.
0000000000000000000000000000000000000000;;	type RuntimeCondition struct {
0000000000000000000000000000000000000000;;		// Type of runtime condition.
0000000000000000000000000000000000000000;;		Type RuntimeConditionType
0000000000000000000000000000000000000000;;		// Status of the condition, one of true/false.
0000000000000000000000000000000000000000;;		Status bool
0000000000000000000000000000000000000000;;		// Reason is brief reason for the condition's last transition.
0000000000000000000000000000000000000000;;		Reason string
0000000000000000000000000000000000000000;;		// Message is human readable message indicating details about last transition.
0000000000000000000000000000000000000000;;		Message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String formats the runtime condition into human readable string.
0000000000000000000000000000000000000000;;	func (c *RuntimeCondition) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s=%t reason:%s message:%s", c.Type, c.Status, c.Reason, c.Message)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Pods []*Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindPodByID finds and returns a pod in the pod list by UID. It will return an empty pod
0000000000000000000000000000000000000000;;	// if not found.
0000000000000000000000000000000000000000;;	func (p Pods) FindPodByID(podUID types.UID) Pod {
0000000000000000000000000000000000000000;;		for i := range p {
0000000000000000000000000000000000000000;;			if p[i].ID == podUID {
0000000000000000000000000000000000000000;;				return *p[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Pod{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindPodByFullName finds and returns a pod in the pod list by the full name.
0000000000000000000000000000000000000000;;	// It will return an empty pod if not found.
0000000000000000000000000000000000000000;;	func (p Pods) FindPodByFullName(podFullName string) Pod {
0000000000000000000000000000000000000000;;		for i := range p {
0000000000000000000000000000000000000000;;			if BuildPodFullName(p[i].Name, p[i].Namespace) == podFullName {
0000000000000000000000000000000000000000;;				return *p[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Pod{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindPod combines FindPodByID and FindPodByFullName, it finds and returns a pod in the
0000000000000000000000000000000000000000;;	// pod list either by the full name or the pod ID. It will return an empty pod
0000000000000000000000000000000000000000;;	// if not found.
0000000000000000000000000000000000000000;;	func (p Pods) FindPod(podFullName string, podUID types.UID) Pod {
0000000000000000000000000000000000000000;;		if len(podFullName) > 0 {
0000000000000000000000000000000000000000;;			return p.FindPodByFullName(podFullName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.FindPodByID(podUID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindContainerByName returns a container in the pod with the given name.
0000000000000000000000000000000000000000;;	// When there are multiple containers with the same name, the first match will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (p *Pod) FindContainerByName(containerName string) *Container {
0000000000000000000000000000000000000000;;		for _, c := range p.Containers {
0000000000000000000000000000000000000000;;			if c.Name == containerName {
0000000000000000000000000000000000000000;;				return c
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Pod) FindContainerByID(id ContainerID) *Container {
0000000000000000000000000000000000000000;;		for _, c := range p.Containers {
0000000000000000000000000000000000000000;;			if c.ID == id {
0000000000000000000000000000000000000000;;				return c
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Pod) FindSandboxByID(id ContainerID) *Container {
0000000000000000000000000000000000000000;;		for _, c := range p.Sandboxes {
0000000000000000000000000000000000000000;;			if c.ID == id {
0000000000000000000000000000000000000000;;				return c
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToAPIPod converts Pod to v1.Pod. Note that if a field in v1.Pod has no
0000000000000000000000000000000000000000;;	// corresponding field in Pod, the field would not be populated.
0000000000000000000000000000000000000000;;	func (p *Pod) ToAPIPod() *v1.Pod {
0000000000000000000000000000000000000000;;		var pod v1.Pod
0000000000000000000000000000000000000000;;		pod.UID = p.ID
0000000000000000000000000000000000000000;;		pod.Name = p.Name
0000000000000000000000000000000000000000;;		pod.Namespace = p.Namespace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, c := range p.Containers {
0000000000000000000000000000000000000000;;			var container v1.Container
0000000000000000000000000000000000000000;;			container.Name = c.Name
0000000000000000000000000000000000000000;;			container.Image = c.Image
0000000000000000000000000000000000000000;;			pod.Spec.Containers = append(pod.Spec.Containers, container)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEmpty returns true if the pod is empty.
0000000000000000000000000000000000000000;;	func (p *Pod) IsEmpty() bool {
0000000000000000000000000000000000000000;;		return reflect.DeepEqual(p, &Pod{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPodFullName returns a name that uniquely identifies a pod.
0000000000000000000000000000000000000000;;	func GetPodFullName(pod *v1.Pod) string {
0000000000000000000000000000000000000000;;		// Use underscore as the delimiter because it is not allowed in pod name
0000000000000000000000000000000000000000;;		// (DNS subdomain format), while allowed in the container name format.
0000000000000000000000000000000000000000;;		return pod.Name + "_" + pod.Namespace
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Build the pod full name from pod name and namespace.
0000000000000000000000000000000000000000;;	func BuildPodFullName(name, namespace string) string {
0000000000000000000000000000000000000000;;		return name + "_" + namespace
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the pod full name.
0000000000000000000000000000000000000000;;	func ParsePodFullName(podFullName string) (string, string, error) {
0000000000000000000000000000000000000000;;		parts := strings.Split(podFullName, "_")
0000000000000000000000000000000000000000;;		if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("failed to parse the pod full name %q", podFullName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parts[0], parts[1], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Option is a functional option type for Runtime, useful for
0000000000000000000000000000000000000000;;	// completely optional settings.
0000000000000000000000000000000000000000;;	type Option func(Runtime)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sort the container statuses by creation time.
0000000000000000000000000000000000000000;;	type SortContainerStatusesByCreationTime []*ContainerStatus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s SortContainerStatusesByCreationTime) Len() int      { return len(s) }
0000000000000000000000000000000000000000;;	func (s SortContainerStatusesByCreationTime) Swap(i, j int) { s[i], s[j] = s[j], s[i] }
0000000000000000000000000000000000000000;;	func (s SortContainerStatusesByCreationTime) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return s[i].CreatedAt.Before(s[j].CreatedAt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// MaxPodTerminationMessageLogLength is the maximum bytes any one pod may have written
0000000000000000000000000000000000000000;;		// as termination message output across all containers. Containers will be evenly truncated
0000000000000000000000000000000000000000;;		// until output is below this limit.
0000000000000000000000000000000000000000;;		MaxPodTerminationMessageLogLength = 1024 * 12
0000000000000000000000000000000000000000;;		// MaxContainerTerminationMessageLength is the upper bound any one container may write to
0000000000000000000000000000000000000000;;		// its termination message path. Contents above this length will be truncated.
0000000000000000000000000000000000000000;;		MaxContainerTerminationMessageLength = 1024 * 4
0000000000000000000000000000000000000000;;		// MaxContainerTerminationMessageLogLength is the maximum bytes any one container will
0000000000000000000000000000000000000000;;		// have written to its termination message when the message is read from the logs.
0000000000000000000000000000000000000000;;		MaxContainerTerminationMessageLogLength = 1024 * 2
0000000000000000000000000000000000000000;;		// MaxContainerTerminationMessageLogLines is the maximum number of previous lines of
0000000000000000000000000000000000000000;;		// log output that the termination message can contain.
0000000000000000000000000000000000000000;;		MaxContainerTerminationMessageLogLines = 80
0000000000000000000000000000000000000000;;	)
