0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
5a3769738749c461b6fcb592b65969ecc716a8c4;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package container
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"hash/adler32"
0000000000000000000000000000000000000000;;		"hash/fnv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/events"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/format"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/ioutils"
0000000000000000000000000000000000000000;;		hashutil "k8s.io/kubernetes/pkg/util/hash"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/third_party/forked/golang/expansion"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandlerRunner runs a lifecycle handler for a container.
0000000000000000000000000000000000000000;;	type HandlerRunner interface {
0000000000000000000000000000000000000000;;		Run(containerID ContainerID, pod *v1.Pod, container *v1.Container, handler *v1.Handler) (string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RuntimeHelper wraps kubelet to make container runtime
0000000000000000000000000000000000000000;;	// able to get necessary informations like the RunContainerOptions, DNS settings, Host IP.
0000000000000000000000000000000000000000;;	type RuntimeHelper interface {
0000000000000000000000000000000000000000;;		GenerateRunContainerOptions(pod *v1.Pod, container *v1.Container, podIP string) (contOpts *RunContainerOptions, useClusterFirstPolicy bool, err error)
0000000000000000000000000000000000000000;;		GetClusterDNS(pod *v1.Pod) (dnsServers []string, dnsSearches []string, useClusterFirstPolicy bool, err error)
0000000000000000000000000000000000000000;;		// GetPodCgroupParent returns the the CgroupName identifer, and its literal cgroupfs form on the host
0000000000000000000000000000000000000000;;		// of a pod.
0000000000000000000000000000000000000000;;		GetPodCgroupParent(pod *v1.Pod) string
0000000000000000000000000000000000000000;;		GetPodDir(podUID types.UID) string
0000000000000000000000000000000000000000;;		GeneratePodHostNameAndDomain(pod *v1.Pod) (hostname string, hostDomain string, err error)
0000000000000000000000000000000000000000;;		// GetExtraSupplementalGroupsForPod returns a list of the extra
0000000000000000000000000000000000000000;;		// supplemental groups for the Pod. These extra supplemental groups come
0000000000000000000000000000000000000000;;		// from annotations on persistent volumes that the pod depends on.
0000000000000000000000000000000000000000;;		GetExtraSupplementalGroupsForPod(pod *v1.Pod) []int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ShouldContainerBeRestarted checks whether a container needs to be restarted.
0000000000000000000000000000000000000000;;	// TODO(yifan): Think about how to refactor this.
0000000000000000000000000000000000000000;;	func ShouldContainerBeRestarted(container *v1.Container, pod *v1.Pod, podStatus *PodStatus) bool {
0000000000000000000000000000000000000000;;		// Get latest container status.
0000000000000000000000000000000000000000;;		status := podStatus.FindContainerStatusByName(container.Name)
0000000000000000000000000000000000000000;;		// If the container was never started before, we should start it.
0000000000000000000000000000000000000000;;		// NOTE(random-liu): If all historical containers were GC'd, we'll also return true here.
0000000000000000000000000000000000000000;;		if status == nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Check whether container is running
0000000000000000000000000000000000000000;;		if status.State == ContainerStateRunning {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Always restart container in the unknown, or in the created state.
0000000000000000000000000000000000000000;;		if status.State == ContainerStateUnknown || status.State == ContainerStateCreated {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Check RestartPolicy for dead container
0000000000000000000000000000000000000000;;		if pod.Spec.RestartPolicy == v1.RestartPolicyNever {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Already ran container %q of pod %q, do nothing", container.Name, format.Pod(pod))
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pod.Spec.RestartPolicy == v1.RestartPolicyOnFailure {
0000000000000000000000000000000000000000;;			// Check the exit code.
0000000000000000000000000000000000000000;;			if status.ExitCode == 0 {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Already successfully ran container %q of pod %q, do nothing", container.Name, format.Pod(pod))
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HashContainer returns the hash of the container. It is used to compare
0000000000000000000000000000000000000000;;	// the running container with its desired spec.
0000000000000000000000000000000000000000;;	func HashContainer(container *v1.Container) uint64 {
0000000000000000000000000000000000000000;;		hash := fnv.New32a()
0000000000000000000000000000000000000000;;		hashutil.DeepHashObject(hash, *container)
0000000000000000000000000000000000000000;;		return uint64(hash.Sum32())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HashContainerLegacy returns the hash of the container. It is used to compare
0000000000000000000000000000000000000000;;	// the running container with its desired spec.
0000000000000000000000000000000000000000;;	// This is used by rktnetes and dockershim (for handling <=1.5 containers).
0000000000000000000000000000000000000000;;	// TODO: Remove this function when kubernetes version is >=1.8 AND rktnetes
0000000000000000000000000000000000000000;;	// update its hash function.
0000000000000000000000000000000000000000;;	func HashContainerLegacy(container *v1.Container) uint64 {
0000000000000000000000000000000000000000;;		hash := adler32.New()
0000000000000000000000000000000000000000;;		hashutil.DeepHashObject(hash, *container)
0000000000000000000000000000000000000000;;		return uint64(hash.Sum32())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnvVarsToMap constructs a map of environment name to value from a slice
0000000000000000000000000000000000000000;;	// of env vars.
0000000000000000000000000000000000000000;;	func EnvVarsToMap(envs []EnvVar) map[string]string {
0000000000000000000000000000000000000000;;		result := map[string]string{}
0000000000000000000000000000000000000000;;		for _, env := range envs {
0000000000000000000000000000000000000000;;			result[env.Name] = env.Value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// V1EnvVarsToMap constructs a map of environment name to value from a slice
0000000000000000000000000000000000000000;;	// of env vars.
0000000000000000000000000000000000000000;;	func V1EnvVarsToMap(envs []v1.EnvVar) map[string]string {
0000000000000000000000000000000000000000;;		result := map[string]string{}
0000000000000000000000000000000000000000;;		for _, env := range envs {
0000000000000000000000000000000000000000;;			result[env.Name] = env.Value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExpandContainerCommandOnlyStatic substitutes only static environment variable values from the
0000000000000000000000000000000000000000;;	// container environment definitions. This does *not* include valueFrom substitutions.
0000000000000000000000000000000000000000;;	// TODO: callers should use ExpandContainerCommandAndArgs with a fully resolved list of environment.
0000000000000000000000000000000000000000;;	func ExpandContainerCommandOnlyStatic(containerCommand []string, envs []v1.EnvVar) (command []string) {
0000000000000000000000000000000000000000;;		mapping := expansion.MappingFuncFor(V1EnvVarsToMap(envs))
0000000000000000000000000000000000000000;;		if len(containerCommand) != 0 {
0000000000000000000000000000000000000000;;			for _, cmd := range containerCommand {
0000000000000000000000000000000000000000;;				command = append(command, expansion.Expand(cmd, mapping))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return command
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ExpandContainerCommandAndArgs(container *v1.Container, envs []EnvVar) (command []string, args []string) {
0000000000000000000000000000000000000000;;		mapping := expansion.MappingFuncFor(EnvVarsToMap(envs))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(container.Command) != 0 {
0000000000000000000000000000000000000000;;			for _, cmd := range container.Command {
0000000000000000000000000000000000000000;;				command = append(command, expansion.Expand(cmd, mapping))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(container.Args) != 0 {
0000000000000000000000000000000000000000;;			for _, arg := range container.Args {
0000000000000000000000000000000000000000;;				args = append(args, expansion.Expand(arg, mapping))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return command, args
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create an event recorder to record object's event except implicitly required container's, like infra container.
0000000000000000000000000000000000000000;;	func FilterEventRecorder(recorder record.EventRecorder) record.EventRecorder {
0000000000000000000000000000000000000000;;		return &innerEventRecorder{
0000000000000000000000000000000000000000;;			recorder: recorder,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type innerEventRecorder struct {
0000000000000000000000000000000000000000;;		recorder record.EventRecorder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (irecorder *innerEventRecorder) shouldRecordEvent(object runtime.Object) (*clientv1.ObjectReference, bool) {
0000000000000000000000000000000000000000;;		if object == nil {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ref, ok := object.(*clientv1.ObjectReference); ok {
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(ref.FieldPath, ImplicitContainerPrefix) {
0000000000000000000000000000000000000000;;				return ref, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// just in case we miss a spot, be sure that we still log something
0000000000000000000000000000000000000000;;		if ref, ok := object.(*v1.ObjectReference); ok {
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(ref.FieldPath, ImplicitContainerPrefix) {
0000000000000000000000000000000000000000;;				return events.ToObjectReference(ref), true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (irecorder *innerEventRecorder) Event(object runtime.Object, eventtype, reason, message string) {
0000000000000000000000000000000000000000;;		if ref, ok := irecorder.shouldRecordEvent(object); ok {
0000000000000000000000000000000000000000;;			irecorder.recorder.Event(ref, eventtype, reason, message)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (irecorder *innerEventRecorder) Eventf(object runtime.Object, eventtype, reason, messageFmt string, args ...interface{}) {
0000000000000000000000000000000000000000;;		if ref, ok := irecorder.shouldRecordEvent(object); ok {
0000000000000000000000000000000000000000;;			irecorder.recorder.Eventf(ref, eventtype, reason, messageFmt, args...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (irecorder *innerEventRecorder) PastEventf(object runtime.Object, timestamp metav1.Time, eventtype, reason, messageFmt string, args ...interface{}) {
0000000000000000000000000000000000000000;;		if ref, ok := irecorder.shouldRecordEvent(object); ok {
0000000000000000000000000000000000000000;;			irecorder.recorder.PastEventf(ref, timestamp, eventtype, reason, messageFmt, args...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pod must not be nil.
0000000000000000000000000000000000000000;;	func IsHostNetworkPod(pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		return pod.Spec.HostNetwork
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(random-liu): Convert PodStatus to running Pod, should be deprecated soon
0000000000000000000000000000000000000000;;	func ConvertPodStatusToRunningPod(runtimeName string, podStatus *PodStatus) Pod {
0000000000000000000000000000000000000000;;		runningPod := Pod{
0000000000000000000000000000000000000000;;			ID:        podStatus.ID,
0000000000000000000000000000000000000000;;			Name:      podStatus.Name,
0000000000000000000000000000000000000000;;			Namespace: podStatus.Namespace,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, containerStatus := range podStatus.ContainerStatuses {
0000000000000000000000000000000000000000;;			if containerStatus.State != ContainerStateRunning {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			container := &Container{
0000000000000000000000000000000000000000;;				ID:      containerStatus.ID,
0000000000000000000000000000000000000000;;				Name:    containerStatus.Name,
0000000000000000000000000000000000000000;;				Image:   containerStatus.Image,
0000000000000000000000000000000000000000;;				ImageID: containerStatus.ImageID,
0000000000000000000000000000000000000000;;				Hash:    containerStatus.Hash,
0000000000000000000000000000000000000000;;				State:   containerStatus.State,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			runningPod.Containers = append(runningPod.Containers, container)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Populate sandboxes in kubecontainer.Pod
0000000000000000000000000000000000000000;;		for _, sandbox := range podStatus.SandboxStatuses {
0000000000000000000000000000000000000000;;			runningPod.Sandboxes = append(runningPod.Sandboxes, &Container{
0000000000000000000000000000000000000000;;				ID:    ContainerID{Type: runtimeName, ID: sandbox.Id},
0000000000000000000000000000000000000000;;				State: SandboxToContainerState(sandbox.State),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return runningPod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SandboxToContainerState converts runtimeapi.PodSandboxState to
0000000000000000000000000000000000000000;;	// kubecontainer.ContainerState.
0000000000000000000000000000000000000000;;	// This is only needed because we need to return sandboxes as if they were
0000000000000000000000000000000000000000;;	// kubecontainer.Containers to avoid substantial changes to PLEG.
0000000000000000000000000000000000000000;;	// TODO: Remove this once it becomes obsolete.
0000000000000000000000000000000000000000;;	func SandboxToContainerState(state runtimeapi.PodSandboxState) ContainerState {
0000000000000000000000000000000000000000;;		switch state {
0000000000000000000000000000000000000000;;		case runtimeapi.PodSandboxState_SANDBOX_READY:
0000000000000000000000000000000000000000;;			return ContainerStateRunning
0000000000000000000000000000000000000000;;		case runtimeapi.PodSandboxState_SANDBOX_NOTREADY:
0000000000000000000000000000000000000000;;			return ContainerStateExited
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ContainerStateUnknown
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FormatPod returns a string representing a pod in a human readable format,
0000000000000000000000000000000000000000;;	// with pod UID as part of the string.
0000000000000000000000000000000000000000;;	func FormatPod(pod *Pod) string {
0000000000000000000000000000000000000000;;		// Use underscore as the delimiter because it is not allowed in pod name
0000000000000000000000000000000000000000;;		// (DNS subdomain format), while allowed in the container name format.
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s_%s(%s)", pod.Name, pod.Namespace, pod.ID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type containerCommandRunnerWrapper struct {
0000000000000000000000000000000000000000;;		DirectStreamingRuntime
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ ContainerCommandRunner = &containerCommandRunnerWrapper{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DirectStreamingRunner(runtime DirectStreamingRuntime) ContainerCommandRunner {
0000000000000000000000000000000000000000;;		return &containerCommandRunnerWrapper{runtime}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *containerCommandRunnerWrapper) RunInContainer(id ContainerID, cmd []string, timeout time.Duration) ([]byte, error) {
0000000000000000000000000000000000000000;;		var buffer bytes.Buffer
0000000000000000000000000000000000000000;;		output := ioutils.WriteCloserWrapper(&buffer)
0000000000000000000000000000000000000000;;		err := r.ExecInContainer(id, cmd, nil, output, output, false, nil, timeout)
0000000000000000000000000000000000000000;;		// Even if err is non-nil, there still may be output (e.g. the exec wrote to stdout or stderr but
0000000000000000000000000000000000000000;;		// the command returned a nonzero exit code). Therefore, always return the output along with the
0000000000000000000000000000000000000000;;		// error.
0000000000000000000000000000000000000000;;		return buffer.Bytes(), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetContainerSpec gets the container spec by containerName.
0000000000000000000000000000000000000000;;	func GetContainerSpec(pod *v1.Pod, containerName string) *v1.Container {
0000000000000000000000000000000000000000;;		for i, c := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			if containerName == c.Name {
0000000000000000000000000000000000000000;;				return &pod.Spec.Containers[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, c := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;			if containerName == c.Name {
0000000000000000000000000000000000000000;;				return &pod.Spec.InitContainers[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasPrivilegedContainer returns true if any of the containers in the pod are privileged.
0000000000000000000000000000000000000000;;	func HasPrivilegedContainer(pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		for _, c := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			if c.SecurityContext != nil &&
0000000000000000000000000000000000000000;;				c.SecurityContext.Privileged != nil &&
0000000000000000000000000000000000000000;;				*c.SecurityContext.Privileged {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MakeCapabilities creates string slices from Capability slices
0000000000000000000000000000000000000000;;	func MakeCapabilities(capAdd []v1.Capability, capDrop []v1.Capability) ([]string, []string) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			addCaps  []string
0000000000000000000000000000000000000000;;			dropCaps []string
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		for _, cap := range capAdd {
0000000000000000000000000000000000000000;;			addCaps = append(addCaps, string(cap))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, cap := range capDrop {
0000000000000000000000000000000000000000;;			dropCaps = append(dropCaps, string(cap))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return addCaps, dropCaps
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MakePortMappings creates internal port mapping from api port mapping.
0000000000000000000000000000000000000000;;	func MakePortMappings(container *v1.Container) (ports []PortMapping) {
0000000000000000000000000000000000000000;;		names := make(map[string]struct{})
0000000000000000000000000000000000000000;;		for _, p := range container.Ports {
0000000000000000000000000000000000000000;;			pm := PortMapping{
0000000000000000000000000000000000000000;;				HostPort:      int(p.HostPort),
0000000000000000000000000000000000000000;;				ContainerPort: int(p.ContainerPort),
0000000000000000000000000000000000000000;;				Protocol:      p.Protocol,
0000000000000000000000000000000000000000;;				HostIP:        p.HostIP,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We need to create some default port name if it's not specified, since
0000000000000000000000000000000000000000;;			// this is necessary for rkt.
0000000000000000000000000000000000000000;;			// http://issue.k8s.io/7710
0000000000000000000000000000000000000000;;			if p.Name == "" {
0000000000000000000000000000000000000000;;				pm.Name = fmt.Sprintf("%s-%s:%d", container.Name, p.Protocol, p.ContainerPort)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				pm.Name = fmt.Sprintf("%s-%s", container.Name, p.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Protect against exposing the same protocol-port more than once in a container.
0000000000000000000000000000000000000000;;			if _, ok := names[pm.Name]; ok {
0000000000000000000000000000000000000000;;				glog.Warningf("Port name conflicted, %q is defined more than once", pm.Name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ports = append(ports, pm)
0000000000000000000000000000000000000000;;			names[pm.Name] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
