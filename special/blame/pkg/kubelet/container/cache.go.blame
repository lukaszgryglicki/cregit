0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
b4ddc9b441fe4301598714142e5208a3624d5449;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package container
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cache stores the PodStatus for the pods. It represents *all* the visible
0000000000000000000000000000000000000000;;	// pods/containers in the container runtime. All cache entries are at least as
0000000000000000000000000000000000000000;;	// new or newer than the global timestamp (set by UpdateTime()), while
0000000000000000000000000000000000000000;;	// individual entries may be slightly newer than the global timestamp. If a pod
0000000000000000000000000000000000000000;;	// has no states known by the runtime, Cache returns an empty PodStatus object
0000000000000000000000000000000000000000;;	// with ID populated.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Cache provides two methods to retrive the PodStatus: the non-blocking Get()
0000000000000000000000000000000000000000;;	// and the blocking GetNewerThan() method. The component responsible for
0000000000000000000000000000000000000000;;	// populating the cache is expected to call Delete() to explicitly free the
0000000000000000000000000000000000000000;;	// cache entries.
0000000000000000000000000000000000000000;;	type Cache interface {
0000000000000000000000000000000000000000;;		Get(types.UID) (*PodStatus, error)
0000000000000000000000000000000000000000;;		Set(types.UID, *PodStatus, error, time.Time)
0000000000000000000000000000000000000000;;		// GetNewerThan is a blocking call that only returns the status
0000000000000000000000000000000000000000;;		// when it is newer than the given time.
0000000000000000000000000000000000000000;;		GetNewerThan(types.UID, time.Time) (*PodStatus, error)
0000000000000000000000000000000000000000;;		Delete(types.UID)
0000000000000000000000000000000000000000;;		UpdateTime(time.Time)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type data struct {
0000000000000000000000000000000000000000;;		// Status of the pod.
0000000000000000000000000000000000000000;;		status *PodStatus
0000000000000000000000000000000000000000;;		// Error got when trying to inspect the pod.
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;		// Time when the data was last modified.
0000000000000000000000000000000000000000;;		modified time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type subRecord struct {
0000000000000000000000000000000000000000;;		time time.Time
0000000000000000000000000000000000000000;;		ch   chan *data
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cache implements Cache.
0000000000000000000000000000000000000000;;	type cache struct {
0000000000000000000000000000000000000000;;		// Lock which guards all internal data structures.
0000000000000000000000000000000000000000;;		lock sync.RWMutex
0000000000000000000000000000000000000000;;		// Map that stores the pod statuses.
0000000000000000000000000000000000000000;;		pods map[types.UID]*data
0000000000000000000000000000000000000000;;		// A global timestamp represents how fresh the cached data is. All
0000000000000000000000000000000000000000;;		// cache content is at the least newer than this timestamp. Note that the
0000000000000000000000000000000000000000;;		// timestamp is nil after initialization, and will only become non-nil when
0000000000000000000000000000000000000000;;		// it is ready to serve the cached statuses.
0000000000000000000000000000000000000000;;		timestamp *time.Time
0000000000000000000000000000000000000000;;		// Map that stores the subscriber records.
0000000000000000000000000000000000000000;;		subscribers map[types.UID][]*subRecord
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCache creates a pod cache.
0000000000000000000000000000000000000000;;	func NewCache() Cache {
0000000000000000000000000000000000000000;;		return &cache{pods: map[types.UID]*data{}, subscribers: map[types.UID][]*subRecord{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get returns the PodStatus for the pod; callers are expected not to
0000000000000000000000000000000000000000;;	// modify the objects returned.
0000000000000000000000000000000000000000;;	func (c *cache) Get(id types.UID) (*PodStatus, error) {
0000000000000000000000000000000000000000;;		c.lock.RLock()
0000000000000000000000000000000000000000;;		defer c.lock.RUnlock()
0000000000000000000000000000000000000000;;		d := c.get(id)
0000000000000000000000000000000000000000;;		return d.status, d.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cache) GetNewerThan(id types.UID, minTime time.Time) (*PodStatus, error) {
0000000000000000000000000000000000000000;;		ch := c.subscribe(id, minTime)
0000000000000000000000000000000000000000;;		d := <-ch
0000000000000000000000000000000000000000;;		return d.status, d.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set sets the PodStatus for the pod.
0000000000000000000000000000000000000000;;	func (c *cache) Set(id types.UID, status *PodStatus, err error, timestamp time.Time) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		defer c.notify(id, timestamp)
0000000000000000000000000000000000000000;;		c.pods[id] = &data{status: status, err: err, modified: timestamp}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete removes the entry of the pod.
0000000000000000000000000000000000000000;;	func (c *cache) Delete(id types.UID) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		delete(c.pods, id)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//  UpdateTime modifies the global timestamp of the cache and notify
0000000000000000000000000000000000000000;;	//  subscribers if needed.
0000000000000000000000000000000000000000;;	func (c *cache) UpdateTime(timestamp time.Time) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		c.timestamp = &timestamp
0000000000000000000000000000000000000000;;		// Notify all the subscribers if the condition is met.
0000000000000000000000000000000000000000;;		for id := range c.subscribers {
0000000000000000000000000000000000000000;;			c.notify(id, *c.timestamp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeDefaultData(id types.UID) *data {
0000000000000000000000000000000000000000;;		return &data{status: &PodStatus{ID: id}, err: nil}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cache) get(id types.UID) *data {
0000000000000000000000000000000000000000;;		d, ok := c.pods[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// Cache should store *all* pod/container information known by the
0000000000000000000000000000000000000000;;			// container runtime. A cache miss indicates that there are no states
0000000000000000000000000000000000000000;;			// regarding the pod last time we queried the container runtime.
0000000000000000000000000000000000000000;;			// What this *really* means is that there are no visible pod/containers
0000000000000000000000000000000000000000;;			// associated with this pod. Simply return an default (mostly empty)
0000000000000000000000000000000000000000;;			// PodStatus to reflect this.
0000000000000000000000000000000000000000;;			return makeDefaultData(id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getIfNewerThan returns the data it is newer than the given time.
0000000000000000000000000000000000000000;;	// Otherwise, it returns nil. The caller should acquire the lock.
0000000000000000000000000000000000000000;;	func (c *cache) getIfNewerThan(id types.UID, minTime time.Time) *data {
0000000000000000000000000000000000000000;;		d, ok := c.pods[id]
0000000000000000000000000000000000000000;;		globalTimestampIsNewer := (c.timestamp != nil && c.timestamp.After(minTime))
0000000000000000000000000000000000000000;;		if !ok && globalTimestampIsNewer {
0000000000000000000000000000000000000000;;			// Status is not cached, but the global timestamp is newer than
0000000000000000000000000000000000000000;;			// minTime, return the default status.
0000000000000000000000000000000000000000;;			return makeDefaultData(id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok && (d.modified.After(minTime) || globalTimestampIsNewer) {
0000000000000000000000000000000000000000;;			// Status is cached, return status if either of the following is true.
0000000000000000000000000000000000000000;;			//   * status was modified after minTime
0000000000000000000000000000000000000000;;			//   * the global timestamp of the cache is newer than minTime.
0000000000000000000000000000000000000000;;			return d
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// The pod status is not ready.
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// notify sends notifications for pod with the given id, if the requirements
0000000000000000000000000000000000000000;;	// are met. Note that the caller should acquire the lock.
0000000000000000000000000000000000000000;;	func (c *cache) notify(id types.UID, timestamp time.Time) {
0000000000000000000000000000000000000000;;		list, ok := c.subscribers[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// No one to notify.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newList := []*subRecord{}
0000000000000000000000000000000000000000;;		for i, r := range list {
0000000000000000000000000000000000000000;;			if timestamp.Before(r.time) {
0000000000000000000000000000000000000000;;				// Doesn't meet the time requirement; keep the record.
0000000000000000000000000000000000000000;;				newList = append(newList, list[i])
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.ch <- c.get(id)
0000000000000000000000000000000000000000;;			close(r.ch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(newList) == 0 {
0000000000000000000000000000000000000000;;			delete(c.subscribers, id)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			c.subscribers[id] = newList
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cache) subscribe(id types.UID, timestamp time.Time) chan *data {
0000000000000000000000000000000000000000;;		ch := make(chan *data, 1)
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		d := c.getIfNewerThan(id, timestamp)
0000000000000000000000000000000000000000;;		if d != nil {
0000000000000000000000000000000000000000;;			// If the cache entry is ready, send the data and return immediately.
0000000000000000000000000000000000000000;;			ch <- d
0000000000000000000000000000000000000000;;			return ch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Add the subscription record.
0000000000000000000000000000000000000000;;		c.subscribers[id] = append(c.subscribers[id], &subRecord{time: timestamp, ch: ch})
0000000000000000000000000000000000000000;;		return ch
0000000000000000000000000000000000000000;;	}
