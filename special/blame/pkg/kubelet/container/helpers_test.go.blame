0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
fdf60bbec98f33090a133a350e4ce9ec7294fb68;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package container
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEnvVarsToMap(t *testing.T) {
0000000000000000000000000000000000000000;;		vars := []EnvVar{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name:  "foo",
0000000000000000000000000000000000000000;;				Value: "bar",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name:  "zoo",
0000000000000000000000000000000000000000;;				Value: "baz",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		varMap := EnvVarsToMap(vars)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := len(vars), len(varMap); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected map length; expected: %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if a := varMap["foo"]; a != "bar" {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected value of key 'foo': %v", a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if a := varMap["zoo"]; a != "baz" {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected value of key 'zoo': %v", a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestExpandCommandAndArgs(t *testing.T) {
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			name            string
0000000000000000000000000000000000000000;;			container       *v1.Container
0000000000000000000000000000000000000000;;			envs            []EnvVar
0000000000000000000000000000000000000000;;			expectedCommand []string
0000000000000000000000000000000000000000;;			expectedArgs    []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:      "none",
0000000000000000000000000000000000000000;;				container: &v1.Container{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "command expanded",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					Command: []string{"foo", "$(VAR_TEST)", "$(VAR_TEST2)"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				envs: []EnvVar{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "VAR_TEST",
0000000000000000000000000000000000000000;;						Value: "zoo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "VAR_TEST2",
0000000000000000000000000000000000000000;;						Value: "boo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedCommand: []string{"foo", "zoo", "boo"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "args expanded",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					Args: []string{"zap", "$(VAR_TEST)", "$(VAR_TEST2)"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				envs: []EnvVar{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "VAR_TEST",
0000000000000000000000000000000000000000;;						Value: "hap",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "VAR_TEST2",
0000000000000000000000000000000000000000;;						Value: "trap",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedArgs: []string{"zap", "hap", "trap"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "both expanded",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					Command: []string{"$(VAR_TEST2)--$(VAR_TEST)", "foo", "$(VAR_TEST3)"},
0000000000000000000000000000000000000000;;					Args:    []string{"foo", "$(VAR_TEST)", "$(VAR_TEST2)"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				envs: []EnvVar{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "VAR_TEST",
0000000000000000000000000000000000000000;;						Value: "zoo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "VAR_TEST2",
0000000000000000000000000000000000000000;;						Value: "boo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "VAR_TEST3",
0000000000000000000000000000000000000000;;						Value: "roo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedCommand: []string{"boo--zoo", "foo", "roo"},
0000000000000000000000000000000000000000;;				expectedArgs:    []string{"foo", "zoo", "boo"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range cases {
0000000000000000000000000000000000000000;;			actualCommand, actualArgs := ExpandContainerCommandAndArgs(tc.container, tc.envs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if e, a := tc.expectedCommand, actualCommand; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected command; expected %v, got %v", tc.name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if e, a := tc.expectedArgs, actualArgs; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected args; expected %v, got %v", tc.name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestShouldContainerBeRestarted(t *testing.T) {
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       "12345678",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: "new",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{Name: "no-history"},
0000000000000000000000000000000000000000;;					{Name: "alive"},
0000000000000000000000000000000000000000;;					{Name: "succeed"},
0000000000000000000000000000000000000000;;					{Name: "failed"},
0000000000000000000000000000000000000000;;					{Name: "unknown"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podStatus := &PodStatus{
0000000000000000000000000000000000000000;;			ID:        pod.UID,
0000000000000000000000000000000000000000;;			Name:      pod.Name,
0000000000000000000000000000000000000000;;			Namespace: pod.Namespace,
0000000000000000000000000000000000000000;;			ContainerStatuses: []*ContainerStatus{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:  "alive",
0000000000000000000000000000000000000000;;					State: ContainerStateRunning,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:     "succeed",
0000000000000000000000000000000000000000;;					State:    ContainerStateExited,
0000000000000000000000000000000000000000;;					ExitCode: 0,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:     "failed",
0000000000000000000000000000000000000000;;					State:    ContainerStateExited,
0000000000000000000000000000000000000000;;					ExitCode: 1,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:     "alive",
0000000000000000000000000000000000000000;;					State:    ContainerStateExited,
0000000000000000000000000000000000000000;;					ExitCode: 2,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:  "unknown",
0000000000000000000000000000000000000000;;					State: ContainerStateUnknown,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:     "failed",
0000000000000000000000000000000000000000;;					State:    ContainerStateExited,
0000000000000000000000000000000000000000;;					ExitCode: 3,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		policies := []v1.RestartPolicy{
0000000000000000000000000000000000000000;;			v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			v1.RestartPolicyOnFailure,
0000000000000000000000000000000000000000;;			v1.RestartPolicyAlways,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expected := map[string][]bool{
0000000000000000000000000000000000000000;;			"no-history": {true, true, true},
0000000000000000000000000000000000000000;;			"alive":      {false, false, false},
0000000000000000000000000000000000000000;;			"succeed":    {false, false, true},
0000000000000000000000000000000000000000;;			"failed":     {false, true, true},
0000000000000000000000000000000000000000;;			"unknown":    {true, true, true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			for i, policy := range policies {
0000000000000000000000000000000000000000;;				pod.Spec.RestartPolicy = policy
0000000000000000000000000000000000000000;;				e := expected[c.Name][i]
0000000000000000000000000000000000000000;;				r := ShouldContainerBeRestarted(&c, pod, podStatus)
0000000000000000000000000000000000000000;;				if r != e {
0000000000000000000000000000000000000000;;					t.Errorf("Restart for container %q with restart policy %q expected %t, got %t",
0000000000000000000000000000000000000000;;						c.Name, policy, e, r)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHasPrivilegedContainer(t *testing.T) {
0000000000000000000000000000000000000000;;		newBoolPtr := func(b bool) *bool {
0000000000000000000000000000000000000000;;			return &b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			securityContext *v1.SecurityContext
0000000000000000000000000000000000000000;;			expected        bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"nil security context": {
0000000000000000000000000000000000000000;;				securityContext: nil,
0000000000000000000000000000000000000000;;				expected:        false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"nil privileged": {
0000000000000000000000000000000000000000;;				securityContext: &v1.SecurityContext{},
0000000000000000000000000000000000000000;;				expected:        false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"false privileged": {
0000000000000000000000000000000000000000;;				securityContext: &v1.SecurityContext{Privileged: newBoolPtr(false)},
0000000000000000000000000000000000000000;;				expected:        false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"true privileged": {
0000000000000000000000000000000000000000;;				securityContext: &v1.SecurityContext{Privileged: newBoolPtr(true)},
0000000000000000000000000000000000000000;;				expected:        true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{SecurityContext: v.securityContext},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			actual := HasPrivilegedContainer(pod)
0000000000000000000000000000000000000000;;			if actual != v.expected {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected %t but got %t", k, v.expected, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMakePortMappings(t *testing.T) {
0000000000000000000000000000000000000000;;		port := func(name string, protocol v1.Protocol, containerPort, hostPort int32, ip string) v1.ContainerPort {
0000000000000000000000000000000000000000;;			return v1.ContainerPort{
0000000000000000000000000000000000000000;;				Name:          name,
0000000000000000000000000000000000000000;;				Protocol:      protocol,
0000000000000000000000000000000000000000;;				ContainerPort: containerPort,
0000000000000000000000000000000000000000;;				HostPort:      hostPort,
0000000000000000000000000000000000000000;;				HostIP:        ip,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		portMapping := func(name string, protocol v1.Protocol, containerPort, hostPort int, ip string) PortMapping {
0000000000000000000000000000000000000000;;			return PortMapping{
0000000000000000000000000000000000000000;;				Name:          name,
0000000000000000000000000000000000000000;;				Protocol:      protocol,
0000000000000000000000000000000000000000;;				ContainerPort: containerPort,
0000000000000000000000000000000000000000;;				HostPort:      hostPort,
0000000000000000000000000000000000000000;;				HostIP:        ip,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			container            *v1.Container
0000000000000000000000000000000000000000;;			expectedPortMappings []PortMapping
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Container{
0000000000000000000000000000000000000000;;					Name: "fooContainer",
0000000000000000000000000000000000000000;;					Ports: []v1.ContainerPort{
0000000000000000000000000000000000000000;;						port("", v1.ProtocolTCP, 80, 8080, "127.0.0.1"),
0000000000000000000000000000000000000000;;						port("", v1.ProtocolTCP, 443, 4343, "192.168.0.1"),
0000000000000000000000000000000000000000;;						port("foo", v1.ProtocolUDP, 555, 5555, ""),
0000000000000000000000000000000000000000;;						// Duplicated, should be ignored.
0000000000000000000000000000000000000000;;						port("foo", v1.ProtocolUDP, 888, 8888, ""),
0000000000000000000000000000000000000000;;						// Duplicated, should be ignored.
0000000000000000000000000000000000000000;;						port("", v1.ProtocolTCP, 80, 8888, ""),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				[]PortMapping{
0000000000000000000000000000000000000000;;					portMapping("fooContainer-TCP:80", v1.ProtocolTCP, 80, 8080, "127.0.0.1"),
0000000000000000000000000000000000000000;;					portMapping("fooContainer-TCP:443", v1.ProtocolTCP, 443, 4343, "192.168.0.1"),
0000000000000000000000000000000000000000;;					portMapping("fooContainer-foo", v1.ProtocolUDP, 555, 5555, ""),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			actual := MakePortMappings(tt.container)
0000000000000000000000000000000000000000;;			assert.Equal(t, tt.expectedPortMappings, actual, "[%d]", i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
