0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
cb7e0146fb2ea1e5e51762e0031530117051407d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package preemption
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		utilfeature "k8s.io/apiserver/pkg/util/feature"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		v1qos "k8s.io/kubernetes/pkg/api/v1/helper/qos"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/v1/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/features"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/events"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/eviction"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/lifecycle"
0000000000000000000000000000000000000000;;		kubetypes "k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/format"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm/predicates"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const message = "Preempted in order to admit critical pod"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CriticalPodAdmissionFailureHandler is an AdmissionFailureHandler that handles admission failure for Critical Pods.
0000000000000000000000000000000000000000;;	// If the ONLY admission failures are due to insufficient resources, then CriticalPodAdmissionHandler evicts pods
0000000000000000000000000000000000000000;;	// so that the critical pod can be admitted.  For evictions, the CriticalPodAdmissionHandler evicts a set of pods that
0000000000000000000000000000000000000000;;	// frees up the required resource requests.  The set of pods is designed to minimize impact, and is prioritized according to the ordering:
0000000000000000000000000000000000000000;;	// minimal impact for guaranteed pods > minimal impact for burstable pods > minimal impact for besteffort pods.
0000000000000000000000000000000000000000;;	// minimal impact is defined as follows: fewest pods evicted > fewest total requests of pods.
0000000000000000000000000000000000000000;;	// finding the fewest total requests of pods is considered besteffort.
0000000000000000000000000000000000000000;;	type CriticalPodAdmissionHandler struct {
0000000000000000000000000000000000000000;;		getPodsFunc eviction.ActivePodsFunc
0000000000000000000000000000000000000000;;		killPodFunc eviction.KillPodFunc
0000000000000000000000000000000000000000;;		recorder    record.EventRecorder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ lifecycle.AdmissionFailureHandler = &CriticalPodAdmissionHandler{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCriticalPodAdmissionHandler(getPodsFunc eviction.ActivePodsFunc, killPodFunc eviction.KillPodFunc, recorder record.EventRecorder) *CriticalPodAdmissionHandler {
0000000000000000000000000000000000000000;;		return &CriticalPodAdmissionHandler{
0000000000000000000000000000000000000000;;			getPodsFunc: getPodsFunc,
0000000000000000000000000000000000000000;;			killPodFunc: killPodFunc,
0000000000000000000000000000000000000000;;			recorder:    recorder,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandleAdmissionFailure gracefully handles admission rejection, and, in some cases,
0000000000000000000000000000000000000000;;	// to allow admission of the pod despite its previous failure.
0000000000000000000000000000000000000000;;	func (c *CriticalPodAdmissionHandler) HandleAdmissionFailure(pod *v1.Pod, failureReasons []algorithm.PredicateFailureReason) (bool, []algorithm.PredicateFailureReason, error) {
0000000000000000000000000000000000000000;;		if !kubetypes.IsCriticalPod(pod) || !utilfeature.DefaultFeatureGate.Enabled(features.ExperimentalCriticalPodAnnotation) {
0000000000000000000000000000000000000000;;			return false, failureReasons, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// InsufficientResourceError is not a reason to reject a critical pod.
0000000000000000000000000000000000000000;;		// Instead of rejecting, we free up resources to admit it, if no other reasons for rejection exist.
0000000000000000000000000000000000000000;;		nonResourceReasons := []algorithm.PredicateFailureReason{}
0000000000000000000000000000000000000000;;		resourceReasons := []*admissionRequirement{}
0000000000000000000000000000000000000000;;		for _, reason := range failureReasons {
0000000000000000000000000000000000000000;;			if r, ok := reason.(*predicates.InsufficientResourceError); ok {
0000000000000000000000000000000000000000;;				resourceReasons = append(resourceReasons, &admissionRequirement{
0000000000000000000000000000000000000000;;					resourceName: r.ResourceName,
0000000000000000000000000000000000000000;;					quantity:     r.GetInsufficientAmount(),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				nonResourceReasons = append(nonResourceReasons, reason)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(nonResourceReasons) > 0 {
0000000000000000000000000000000000000000;;			// Return only reasons that are not resource related, since critical pods cannot fail admission for resource reasons.
0000000000000000000000000000000000000000;;			return false, nonResourceReasons, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := c.evictPodsToFreeRequests(admissionRequirementList(resourceReasons))
0000000000000000000000000000000000000000;;		// if no error is returned, preemption succeeded and the pod is safe to admit.
0000000000000000000000000000000000000000;;		return err == nil, nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// freeRequests takes a list of insufficient resources, and attempts to free them by evicting pods
0000000000000000000000000000000000000000;;	// based on requests.  For example, if the only insufficient resource is 200Mb of memory, this function could
0000000000000000000000000000000000000000;;	// evict a pod with request=250Mb.
0000000000000000000000000000000000000000;;	func (c *CriticalPodAdmissionHandler) evictPodsToFreeRequests(insufficientResources admissionRequirementList) error {
0000000000000000000000000000000000000000;;		podsToPreempt, err := getPodsToPreempt(c.getPodsFunc(), insufficientResources)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("preemption: error finding a set of pods to preempt: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("preemption: attempting to evict pods %v, in order to free up resources: %s", podsToPreempt, insufficientResources.toString())
0000000000000000000000000000000000000000;;		for _, pod := range podsToPreempt {
0000000000000000000000000000000000000000;;			status := v1.PodStatus{
0000000000000000000000000000000000000000;;				Phase:   v1.PodFailed,
0000000000000000000000000000000000000000;;				Message: message,
0000000000000000000000000000000000000000;;				Reason:  events.PreemptContainer,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// record that we are evicting the pod
0000000000000000000000000000000000000000;;			c.recorder.Eventf(pod, v1.EventTypeWarning, events.PreemptContainer, message)
0000000000000000000000000000000000000000;;			// this is a blocking call and should only return when the pod and its containers are killed.
0000000000000000000000000000000000000000;;			err := c.killPodFunc(pod, status, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("preemption: pod %s failed to evict %v", format.Pod(pod), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Infof("preemption: pod %s evicted successfully", format.Pod(pod))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodsToPreempt returns a list of pods that could be preempted to free requests >= requirements
0000000000000000000000000000000000000000;;	func getPodsToPreempt(pods []*v1.Pod, requirements admissionRequirementList) ([]*v1.Pod, error) {
0000000000000000000000000000000000000000;;		bestEffortPods, burstablePods, guaranteedPods := sortPodsByQOS(pods)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// make sure that pods exist to reclaim the requirements
0000000000000000000000000000000000000000;;		unableToMeetRequirements := requirements.subtract(append(append(bestEffortPods, burstablePods...), guaranteedPods...)...)
0000000000000000000000000000000000000000;;		if len(unableToMeetRequirements) > 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no set of running pods found to reclaim resources: %v", unableToMeetRequirements.toString())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// find the guaranteed pods we would need to evict if we already evicted ALL burstable and besteffort pods.
0000000000000000000000000000000000000000;;		guarateedToEvict, err := getPodsToPreemptByDistance(guaranteedPods, requirements.subtract(append(bestEffortPods, burstablePods...)...))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Find the burstable pods we would need to evict if we already evicted ALL besteffort pods, and the required guaranteed pods.
0000000000000000000000000000000000000000;;		burstableToEvict, err := getPodsToPreemptByDistance(burstablePods, requirements.subtract(append(bestEffortPods, guarateedToEvict...)...))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Find the besteffort pods we would need to evict if we already evicted the required guaranteed and burstable pods.
0000000000000000000000000000000000000000;;		bestEffortToEvict, err := getPodsToPreemptByDistance(bestEffortPods, requirements.subtract(append(burstableToEvict, guarateedToEvict...)...))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return append(append(bestEffortToEvict, burstableToEvict...), guarateedToEvict...), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// finds the pods that have pod requests >= admission requirements.
0000000000000000000000000000000000000000;;	// Chooses pods that minimize "distance" to the requirements.
0000000000000000000000000000000000000000;;	// If more than one pod exists that fulfills the remaining requirements,
0000000000000000000000000000000000000000;;	// it chooses the pod that has the "smaller resource request"
0000000000000000000000000000000000000000;;	// This method, by repeatedly choosing the pod that fulfills as much of the requirements as possible,
0000000000000000000000000000000000000000;;	// attempts to minimize the number of pods returned.
0000000000000000000000000000000000000000;;	func getPodsToPreemptByDistance(pods []*v1.Pod, requirements admissionRequirementList) ([]*v1.Pod, error) {
0000000000000000000000000000000000000000;;		podsToEvict := []*v1.Pod{}
0000000000000000000000000000000000000000;;		// evict pods by shortest distance from remaining requirements, updating requirements every round.
0000000000000000000000000000000000000000;;		for len(requirements) > 0 {
0000000000000000000000000000000000000000;;			if len(pods) == 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("no set of running pods found to reclaim resources: %v", requirements.toString())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// all distances must be less than len(requirements), because the max distance for a single requirement is 1
0000000000000000000000000000000000000000;;			bestDistance := float64(len(requirements) + 1)
0000000000000000000000000000000000000000;;			bestPodIndex := 0
0000000000000000000000000000000000000000;;			// Find the pod with the smallest distance from requirements
0000000000000000000000000000000000000000;;			// Or, in the case of two equidistant pods, find the pod with "smaller" resource requests.
0000000000000000000000000000000000000000;;			for i, pod := range pods {
0000000000000000000000000000000000000000;;				dist := requirements.distance(pod)
0000000000000000000000000000000000000000;;				if dist < bestDistance || (bestDistance == dist && smallerResourceRequest(pod, pods[bestPodIndex])) {
0000000000000000000000000000000000000000;;					bestDistance = dist
0000000000000000000000000000000000000000;;					bestPodIndex = i
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// subtract the pod from requirements, and transfer the pod from input-pods to pods-to-evicted
0000000000000000000000000000000000000000;;			requirements = requirements.subtract(pods[bestPodIndex])
0000000000000000000000000000000000000000;;			podsToEvict = append(podsToEvict, pods[bestPodIndex])
0000000000000000000000000000000000000000;;			pods[bestPodIndex] = pods[len(pods)-1]
0000000000000000000000000000000000000000;;			pods = pods[:len(pods)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return podsToEvict, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type admissionRequirement struct {
0000000000000000000000000000000000000000;;		resourceName v1.ResourceName
0000000000000000000000000000000000000000;;		quantity     int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type admissionRequirementList []*admissionRequirement
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// distance of the pods requests from the admissionRequirements.
0000000000000000000000000000000000000000;;	// distance is measured by the fraction of the requirement satisfied by the pod,
0000000000000000000000000000000000000000;;	// so that each requirement is weighted equally, regardless of absolute magnitude.
0000000000000000000000000000000000000000;;	func (a admissionRequirementList) distance(pod *v1.Pod) float64 {
0000000000000000000000000000000000000000;;		dist := float64(0)
0000000000000000000000000000000000000000;;		for _, req := range a {
0000000000000000000000000000000000000000;;			remainingRequest := float64(req.quantity - resource.GetResourceRequest(pod, req.resourceName))
0000000000000000000000000000000000000000;;			if remainingRequest < 0 {
0000000000000000000000000000000000000000;;				remainingRequest = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dist += math.Pow(remainingRequest/float64(req.quantity), 2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dist
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns a new admissionRequirementList containing remaining requirements if the provided pod
0000000000000000000000000000000000000000;;	// were to be preempted
0000000000000000000000000000000000000000;;	func (a admissionRequirementList) subtract(pods ...*v1.Pod) admissionRequirementList {
0000000000000000000000000000000000000000;;		newList := []*admissionRequirement{}
0000000000000000000000000000000000000000;;		for _, req := range a {
0000000000000000000000000000000000000000;;			newQuantity := req.quantity
0000000000000000000000000000000000000000;;			for _, pod := range pods {
0000000000000000000000000000000000000000;;				newQuantity -= resource.GetResourceRequest(pod, req.resourceName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if newQuantity > 0 {
0000000000000000000000000000000000000000;;				newList = append(newList, &admissionRequirement{
0000000000000000000000000000000000000000;;					resourceName: req.resourceName,
0000000000000000000000000000000000000000;;					quantity:     newQuantity,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a admissionRequirementList) toString() string {
0000000000000000000000000000000000000000;;		s := "["
0000000000000000000000000000000000000000;;		for _, req := range a {
0000000000000000000000000000000000000000;;			s += fmt.Sprintf("(res: %v, q: %d), ", req.resourceName, req.quantity)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s + "]"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns lists containing non-critical besteffort, burstable, and guaranteed pods
0000000000000000000000000000000000000000;;	func sortPodsByQOS(pods []*v1.Pod) (bestEffort, burstable, guaranteed []*v1.Pod) {
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			if !kubetypes.IsCriticalPod(pod) {
0000000000000000000000000000000000000000;;				switch v1qos.GetPodQOS(pod) {
0000000000000000000000000000000000000000;;				case v1.PodQOSBestEffort:
0000000000000000000000000000000000000000;;					bestEffort = append(bestEffort, pod)
0000000000000000000000000000000000000000;;				case v1.PodQOSBurstable:
0000000000000000000000000000000000000000;;					burstable = append(burstable, pod)
0000000000000000000000000000000000000000;;				case v1.PodQOSGuaranteed:
0000000000000000000000000000000000000000;;					guaranteed = append(guaranteed, pod)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns true if pod1 has a smaller request than pod2
0000000000000000000000000000000000000000;;	func smallerResourceRequest(pod1 *v1.Pod, pod2 *v1.Pod) bool {
0000000000000000000000000000000000000000;;		priorityList := []v1.ResourceName{
0000000000000000000000000000000000000000;;			v1.ResourceNvidiaGPU,
0000000000000000000000000000000000000000;;			v1.ResourceMemory,
0000000000000000000000000000000000000000;;			v1.ResourceCPU,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, res := range priorityList {
0000000000000000000000000000000000000000;;			req1 := resource.GetResourceRequest(pod1, res)
0000000000000000000000000000000000000000;;			req2 := resource.GetResourceRequest(pod2, res)
0000000000000000000000000000000000000000;;			if req1 < req2 {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			} else if req1 > req2 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
