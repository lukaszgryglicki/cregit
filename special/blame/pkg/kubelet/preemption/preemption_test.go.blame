0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
cb7e0146fb2ea1e5e51762e0031530117051407d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package preemption
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		kubeapi "k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		kubetypes "k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		critical              = "critical"
0000000000000000000000000000000000000000;;		bestEffort            = "bestEffort"
0000000000000000000000000000000000000000;;		burstable             = "burstable"
0000000000000000000000000000000000000000;;		highRequestBurstable  = "high-request-burstable"
0000000000000000000000000000000000000000;;		guaranteed            = "guaranteed"
0000000000000000000000000000000000000000;;		highRequestGuaranteed = "high-request-guaranteed"
0000000000000000000000000000000000000000;;		tinyBurstable         = "tiny"
0000000000000000000000000000000000000000;;		maxPods               = 110
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakePodKiller struct {
0000000000000000000000000000000000000000;;		killedPods []*v1.Pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFakePodKiller() *fakePodKiller {
0000000000000000000000000000000000000000;;		return &fakePodKiller{killedPods: []*v1.Pod{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakePodKiller) clear() {
0000000000000000000000000000000000000000;;		f.killedPods = []*v1.Pod{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakePodKiller) getKilledPods() []*v1.Pod {
0000000000000000000000000000000000000000;;		return f.killedPods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakePodKiller) killPodNow(pod *v1.Pod, status v1.PodStatus, gracePeriodOverride *int64) error {
0000000000000000000000000000000000000000;;		f.killedPods = append(f.killedPods, pod)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakePodProvider struct {
0000000000000000000000000000000000000000;;		pods []*v1.Pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFakePodProvider() *fakePodProvider {
0000000000000000000000000000000000000000;;		return &fakePodProvider{pods: []*v1.Pod{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakePodProvider) setPods(pods []*v1.Pod) {
0000000000000000000000000000000000000000;;		f.pods = pods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakePodProvider) getPods() []*v1.Pod {
0000000000000000000000000000000000000000;;		return f.pods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTestCriticalPodAdmissionHandler(podProvider *fakePodProvider, podKiller *fakePodKiller) *CriticalPodAdmissionHandler {
0000000000000000000000000000000000000000;;		return &CriticalPodAdmissionHandler{
0000000000000000000000000000000000000000;;			getPodsFunc: podProvider.getPods,
0000000000000000000000000000000000000000;;			killPodFunc: podKiller.killPodNow,
0000000000000000000000000000000000000000;;			recorder:    &record.FakeRecorder{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEvictPodsToFreeRequests(t *testing.T) {
0000000000000000000000000000000000000000;;		type testRun struct {
0000000000000000000000000000000000000000;;			testName              string
0000000000000000000000000000000000000000;;			inputPods             []*v1.Pod
0000000000000000000000000000000000000000;;			insufficientResources admissionRequirementList
0000000000000000000000000000000000000000;;			expectErr             bool
0000000000000000000000000000000000000000;;			expectedOutput        []*v1.Pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podProvider := newFakePodProvider()
0000000000000000000000000000000000000000;;		podKiller := newFakePodKiller()
0000000000000000000000000000000000000000;;		criticalPodAdmissionHandler := getTestCriticalPodAdmissionHandler(podProvider, podKiller)
0000000000000000000000000000000000000000;;		allPods := getTestPods()
0000000000000000000000000000000000000000;;		runs := []testRun{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:              "critical pods cannot be preempted",
0000000000000000000000000000000000000000;;				inputPods:             []*v1.Pod{allPods[critical]},
0000000000000000000000000000000000000000;;				insufficientResources: getAdmissionRequirementList(0, 0, 1),
0000000000000000000000000000000000000000;;				expectErr:             true,
0000000000000000000000000000000000000000;;				expectedOutput:        nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:              "best effort pods are not preempted when attempting to free resources",
0000000000000000000000000000000000000000;;				inputPods:             []*v1.Pod{allPods[bestEffort]},
0000000000000000000000000000000000000000;;				insufficientResources: getAdmissionRequirementList(0, 1, 0),
0000000000000000000000000000000000000000;;				expectErr:             true,
0000000000000000000000000000000000000000;;				expectedOutput:        nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName: "multiple pods evicted",
0000000000000000000000000000000000000000;;				inputPods: []*v1.Pod{
0000000000000000000000000000000000000000;;					allPods[critical], allPods[bestEffort], allPods[burstable], allPods[highRequestBurstable],
0000000000000000000000000000000000000000;;					allPods[guaranteed], allPods[highRequestGuaranteed]},
0000000000000000000000000000000000000000;;				insufficientResources: getAdmissionRequirementList(0, 550, 0),
0000000000000000000000000000000000000000;;				expectErr:             false,
0000000000000000000000000000000000000000;;				expectedOutput:        []*v1.Pod{allPods[highRequestBurstable], allPods[highRequestGuaranteed]},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, r := range runs {
0000000000000000000000000000000000000000;;			podProvider.setPods(r.inputPods)
0000000000000000000000000000000000000000;;			outErr := criticalPodAdmissionHandler.evictPodsToFreeRequests(r.insufficientResources)
0000000000000000000000000000000000000000;;			outputPods := podKiller.getKilledPods()
0000000000000000000000000000000000000000;;			if !r.expectErr && outErr != nil {
0000000000000000000000000000000000000000;;				t.Errorf("evictPodsToFreeRequests returned an unexpected error during the %s test.  Err: %v", r.testName, outErr)
0000000000000000000000000000000000000000;;			} else if r.expectErr && outErr == nil {
0000000000000000000000000000000000000000;;				t.Errorf("evictPodsToFreeRequests expected an error but returned a successful output=%v during the %s test.", outputPods, r.testName)
0000000000000000000000000000000000000000;;			} else if !podListEqual(r.expectedOutput, outputPods) {
0000000000000000000000000000000000000000;;				t.Errorf("evictPodsToFreeRequests expected %v but got %v during the %s test.", r.expectedOutput, outputPods, r.testName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podKiller.clear()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkGetPodsToPreempt(t *testing.B) {
0000000000000000000000000000000000000000;;		allPods := getTestPods()
0000000000000000000000000000000000000000;;		inputPods := []*v1.Pod{}
0000000000000000000000000000000000000000;;		for i := 0; i < maxPods; i++ {
0000000000000000000000000000000000000000;;			inputPods = append(inputPods, allPods[tinyBurstable])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for n := 0; n < t.N; n++ {
0000000000000000000000000000000000000000;;			getPodsToPreempt(inputPods, admissionRequirementList([]*admissionRequirement{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					resourceName: v1.ResourceCPU,
0000000000000000000000000000000000000000;;					quantity:     parseCPUToInt64("110m"),
0000000000000000000000000000000000000000;;				}}))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetPodsToPreempt(t *testing.T) {
0000000000000000000000000000000000000000;;		type testRun struct {
0000000000000000000000000000000000000000;;			testName              string
0000000000000000000000000000000000000000;;			inputPods             []*v1.Pod
0000000000000000000000000000000000000000;;			insufficientResources admissionRequirementList
0000000000000000000000000000000000000000;;			expectErr             bool
0000000000000000000000000000000000000000;;			expectedOutput        []*v1.Pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allPods := getTestPods()
0000000000000000000000000000000000000000;;		runs := []testRun{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:              "no requirements",
0000000000000000000000000000000000000000;;				inputPods:             []*v1.Pod{},
0000000000000000000000000000000000000000;;				insufficientResources: getAdmissionRequirementList(0, 0, 0),
0000000000000000000000000000000000000000;;				expectErr:             false,
0000000000000000000000000000000000000000;;				expectedOutput:        []*v1.Pod{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:              "no pods",
0000000000000000000000000000000000000000;;				inputPods:             []*v1.Pod{},
0000000000000000000000000000000000000000;;				insufficientResources: getAdmissionRequirementList(0, 0, 1),
0000000000000000000000000000000000000000;;				expectErr:             true,
0000000000000000000000000000000000000000;;				expectedOutput:        nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:              "equal pods and resources requirements",
0000000000000000000000000000000000000000;;				inputPods:             []*v1.Pod{allPods[burstable]},
0000000000000000000000000000000000000000;;				insufficientResources: getAdmissionRequirementList(100, 100, 1),
0000000000000000000000000000000000000000;;				expectErr:             false,
0000000000000000000000000000000000000000;;				expectedOutput:        []*v1.Pod{allPods[burstable]},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:              "higer requirements than pod requests",
0000000000000000000000000000000000000000;;				inputPods:             []*v1.Pod{allPods[burstable]},
0000000000000000000000000000000000000000;;				insufficientResources: getAdmissionRequirementList(200, 200, 2),
0000000000000000000000000000000000000000;;				expectErr:             true,
0000000000000000000000000000000000000000;;				expectedOutput:        nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:              "choose between bestEffort and burstable",
0000000000000000000000000000000000000000;;				inputPods:             []*v1.Pod{allPods[burstable], allPods[bestEffort]},
0000000000000000000000000000000000000000;;				insufficientResources: getAdmissionRequirementList(0, 0, 1),
0000000000000000000000000000000000000000;;				expectErr:             false,
0000000000000000000000000000000000000000;;				expectedOutput:        []*v1.Pod{allPods[bestEffort]},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:              "choose between burstable and guaranteed",
0000000000000000000000000000000000000000;;				inputPods:             []*v1.Pod{allPods[burstable], allPods[guaranteed]},
0000000000000000000000000000000000000000;;				insufficientResources: getAdmissionRequirementList(0, 0, 1),
0000000000000000000000000000000000000000;;				expectErr:             false,
0000000000000000000000000000000000000000;;				expectedOutput:        []*v1.Pod{allPods[burstable]},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:              "choose lower request burstable if it meets requirements",
0000000000000000000000000000000000000000;;				inputPods:             []*v1.Pod{allPods[bestEffort], allPods[highRequestBurstable], allPods[burstable]},
0000000000000000000000000000000000000000;;				insufficientResources: getAdmissionRequirementList(100, 100, 0),
0000000000000000000000000000000000000000;;				expectErr:             false,
0000000000000000000000000000000000000000;;				expectedOutput:        []*v1.Pod{allPods[burstable]},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:              "choose higher request burstable if lower does not meet requirements",
0000000000000000000000000000000000000000;;				inputPods:             []*v1.Pod{allPods[bestEffort], allPods[burstable], allPods[highRequestBurstable]},
0000000000000000000000000000000000000000;;				insufficientResources: getAdmissionRequirementList(150, 150, 0),
0000000000000000000000000000000000000000;;				expectErr:             false,
0000000000000000000000000000000000000000;;				expectedOutput:        []*v1.Pod{allPods[highRequestBurstable]},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:              "multiple pods required",
0000000000000000000000000000000000000000;;				inputPods:             []*v1.Pod{allPods[bestEffort], allPods[burstable], allPods[highRequestBurstable], allPods[guaranteed], allPods[highRequestGuaranteed]},
0000000000000000000000000000000000000000;;				insufficientResources: getAdmissionRequirementList(350, 350, 0),
0000000000000000000000000000000000000000;;				expectErr:             false,
0000000000000000000000000000000000000000;;				expectedOutput:        []*v1.Pod{allPods[burstable], allPods[highRequestBurstable]},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:              "evict guaranteed when we have to, and dont evict the extra burstable",
0000000000000000000000000000000000000000;;				inputPods:             []*v1.Pod{allPods[bestEffort], allPods[burstable], allPods[highRequestBurstable], allPods[guaranteed], allPods[highRequestGuaranteed]},
0000000000000000000000000000000000000000;;				insufficientResources: getAdmissionRequirementList(0, 550, 0),
0000000000000000000000000000000000000000;;				expectErr:             false,
0000000000000000000000000000000000000000;;				expectedOutput:        []*v1.Pod{allPods[highRequestBurstable], allPods[highRequestGuaranteed]},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, r := range runs {
0000000000000000000000000000000000000000;;			outputPods, outErr := getPodsToPreempt(r.inputPods, r.insufficientResources)
0000000000000000000000000000000000000000;;			if !r.expectErr && outErr != nil {
0000000000000000000000000000000000000000;;				t.Errorf("getPodsToPreempt returned an unexpected error during the %s test.  Err: %v", r.testName, outErr)
0000000000000000000000000000000000000000;;			} else if r.expectErr && outErr == nil {
0000000000000000000000000000000000000000;;				t.Errorf("getPodsToPreempt expected an error but returned a successful output=%v during the %s test.", outputPods, r.testName)
0000000000000000000000000000000000000000;;			} else if !podListEqual(r.expectedOutput, outputPods) {
0000000000000000000000000000000000000000;;				t.Errorf("getPodsToPreempt expected %v but got %v during the %s test.", r.expectedOutput, outputPods, r.testName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmissionRequirementsDistance(t *testing.T) {
0000000000000000000000000000000000000000;;		type testRun struct {
0000000000000000000000000000000000000000;;			testName       string
0000000000000000000000000000000000000000;;			requirements   admissionRequirementList
0000000000000000000000000000000000000000;;			inputPod       *v1.Pod
0000000000000000000000000000000000000000;;			expectedOutput float64
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allPods := getTestPods()
0000000000000000000000000000000000000000;;		runs := []testRun{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:       "no requirements",
0000000000000000000000000000000000000000;;				requirements:   getAdmissionRequirementList(0, 0, 0),
0000000000000000000000000000000000000000;;				inputPod:       allPods[burstable],
0000000000000000000000000000000000000000;;				expectedOutput: 0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:       "no requests, some requirements",
0000000000000000000000000000000000000000;;				requirements:   getAdmissionRequirementList(100, 100, 1),
0000000000000000000000000000000000000000;;				inputPod:       allPods[bestEffort],
0000000000000000000000000000000000000000;;				expectedOutput: 2,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:       "equal requests and requirements",
0000000000000000000000000000000000000000;;				requirements:   getAdmissionRequirementList(100, 100, 1),
0000000000000000000000000000000000000000;;				inputPod:       allPods[burstable],
0000000000000000000000000000000000000000;;				expectedOutput: 0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:       "higher requests than requirements",
0000000000000000000000000000000000000000;;				requirements:   getAdmissionRequirementList(50, 50, 0),
0000000000000000000000000000000000000000;;				inputPod:       allPods[burstable],
0000000000000000000000000000000000000000;;				expectedOutput: 0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, run := range runs {
0000000000000000000000000000000000000000;;			output := run.requirements.distance(run.inputPod)
0000000000000000000000000000000000000000;;			if output != run.expectedOutput {
0000000000000000000000000000000000000000;;				t.Errorf("expected: %f, got: %f for %s test", run.expectedOutput, output, run.testName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmissionRequirementsSubtract(t *testing.T) {
0000000000000000000000000000000000000000;;		type testRun struct {
0000000000000000000000000000000000000000;;			testName       string
0000000000000000000000000000000000000000;;			initial        admissionRequirementList
0000000000000000000000000000000000000000;;			inputPod       *v1.Pod
0000000000000000000000000000000000000000;;			expectedOutput admissionRequirementList
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allPods := getTestPods()
0000000000000000000000000000000000000000;;		runs := []testRun{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:       "subtract a pod from no requirements",
0000000000000000000000000000000000000000;;				initial:        getAdmissionRequirementList(0, 0, 0),
0000000000000000000000000000000000000000;;				inputPod:       allPods[burstable],
0000000000000000000000000000000000000000;;				expectedOutput: getAdmissionRequirementList(0, 0, 0),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:       "subtract no requests from some requirements",
0000000000000000000000000000000000000000;;				initial:        getAdmissionRequirementList(100, 100, 1),
0000000000000000000000000000000000000000;;				inputPod:       allPods[bestEffort],
0000000000000000000000000000000000000000;;				expectedOutput: getAdmissionRequirementList(100, 100, 0),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:       "equal requests and requirements",
0000000000000000000000000000000000000000;;				initial:        getAdmissionRequirementList(100, 100, 1),
0000000000000000000000000000000000000000;;				inputPod:       allPods[burstable],
0000000000000000000000000000000000000000;;				expectedOutput: getAdmissionRequirementList(0, 0, 0),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:       "subtract higher requests than requirements",
0000000000000000000000000000000000000000;;				initial:        getAdmissionRequirementList(50, 50, 0),
0000000000000000000000000000000000000000;;				inputPod:       allPods[burstable],
0000000000000000000000000000000000000000;;				expectedOutput: getAdmissionRequirementList(0, 0, 0),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:       "subtract lower requests than requirements",
0000000000000000000000000000000000000000;;				initial:        getAdmissionRequirementList(200, 200, 1),
0000000000000000000000000000000000000000;;				inputPod:       allPods[burstable],
0000000000000000000000000000000000000000;;				expectedOutput: getAdmissionRequirementList(100, 100, 0),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, run := range runs {
0000000000000000000000000000000000000000;;			output := run.initial.subtract(run.inputPod)
0000000000000000000000000000000000000000;;			if !admissionRequirementListEqual(output, run.expectedOutput) {
0000000000000000000000000000000000000000;;				t.Errorf("expected: %s, got: %s for %s test", run.expectedOutput.toString(), output.toString(), run.testName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTestPods() map[string]*v1.Pod {
0000000000000000000000000000000000000000;;		allPods := map[string]*v1.Pod{
0000000000000000000000000000000000000000;;			tinyBurstable: getPodWithResources(tinyBurstable, v1.ResourceRequirements{
0000000000000000000000000000000000000000;;				Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;					"cpu":    resource.MustParse("1m"),
0000000000000000000000000000000000000000;;					"memory": resource.MustParse("1Mi"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			bestEffort: getPodWithResources(bestEffort, v1.ResourceRequirements{}),
0000000000000000000000000000000000000000;;			critical: getPodWithResources(critical, v1.ResourceRequirements{
0000000000000000000000000000000000000000;;				Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;					"cpu":    resource.MustParse("100m"),
0000000000000000000000000000000000000000;;					"memory": resource.MustParse("100Mi"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			burstable: getPodWithResources(burstable, v1.ResourceRequirements{
0000000000000000000000000000000000000000;;				Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;					"cpu":    resource.MustParse("100m"),
0000000000000000000000000000000000000000;;					"memory": resource.MustParse("100Mi"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			guaranteed: getPodWithResources(guaranteed, v1.ResourceRequirements{
0000000000000000000000000000000000000000;;				Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;					"cpu":    resource.MustParse("100m"),
0000000000000000000000000000000000000000;;					"memory": resource.MustParse("100Mi"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Limits: v1.ResourceList{
0000000000000000000000000000000000000000;;					"cpu":    resource.MustParse("100m"),
0000000000000000000000000000000000000000;;					"memory": resource.MustParse("100Mi"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			highRequestBurstable: getPodWithResources(highRequestBurstable, v1.ResourceRequirements{
0000000000000000000000000000000000000000;;				Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;					"cpu":    resource.MustParse("300m"),
0000000000000000000000000000000000000000;;					"memory": resource.MustParse("300Mi"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			highRequestGuaranteed: getPodWithResources(highRequestGuaranteed, v1.ResourceRequirements{
0000000000000000000000000000000000000000;;				Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;					"cpu":    resource.MustParse("300m"),
0000000000000000000000000000000000000000;;					"memory": resource.MustParse("300Mi"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Limits: v1.ResourceList{
0000000000000000000000000000000000000000;;					"cpu":    resource.MustParse("300m"),
0000000000000000000000000000000000000000;;					"memory": resource.MustParse("300Mi"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allPods[critical].Namespace = kubeapi.NamespaceSystem
0000000000000000000000000000000000000000;;		allPods[critical].Annotations[kubetypes.CriticalPodAnnotationKey] = ""
0000000000000000000000000000000000000000;;		return allPods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPodWithResources(name string, requests v1.ResourceRequirements) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				GenerateName: name,
0000000000000000000000000000000000000000;;				Annotations:  map[string]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:      fmt.Sprintf("%s-container", name),
0000000000000000000000000000000000000000;;						Resources: requests,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseCPUToInt64(res string) int64 {
0000000000000000000000000000000000000000;;		r := resource.MustParse(res)
0000000000000000000000000000000000000000;;		return (&r).MilliValue()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseNonCpuResourceToInt64(res string) int64 {
0000000000000000000000000000000000000000;;		r := resource.MustParse(res)
0000000000000000000000000000000000000000;;		return (&r).Value()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getAdmissionRequirementList(cpu, memory, pods int) admissionRequirementList {
0000000000000000000000000000000000000000;;		reqs := []*admissionRequirement{}
0000000000000000000000000000000000000000;;		if cpu > 0 {
0000000000000000000000000000000000000000;;			reqs = append(reqs, &admissionRequirement{
0000000000000000000000000000000000000000;;				resourceName: v1.ResourceCPU,
0000000000000000000000000000000000000000;;				quantity:     parseCPUToInt64(fmt.Sprintf("%dm", cpu)),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if memory > 0 {
0000000000000000000000000000000000000000;;			reqs = append(reqs, &admissionRequirement{
0000000000000000000000000000000000000000;;				resourceName: v1.ResourceMemory,
0000000000000000000000000000000000000000;;				quantity:     parseNonCpuResourceToInt64(fmt.Sprintf("%dMi", memory)),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pods > 0 {
0000000000000000000000000000000000000000;;			reqs = append(reqs, &admissionRequirement{
0000000000000000000000000000000000000000;;				resourceName: v1.ResourcePods,
0000000000000000000000000000000000000000;;				quantity:     int64(pods),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return admissionRequirementList(reqs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// this checks if the lists contents contain all of the same elements.
0000000000000000000000000000000000000000;;	// this is not correct if there are duplicate pods in the list.
0000000000000000000000000000000000000000;;	// for example: podListEqual([a, a, b], [a, b, b]) will return true
0000000000000000000000000000000000000000;;	func admissionRequirementListEqual(list1 admissionRequirementList, list2 admissionRequirementList) bool {
0000000000000000000000000000000000000000;;		if len(list1) != len(list2) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, a := range list1 {
0000000000000000000000000000000000000000;;			contains := false
0000000000000000000000000000000000000000;;			for _, b := range list2 {
0000000000000000000000000000000000000000;;				if a.resourceName == b.resourceName && a.quantity == b.quantity {
0000000000000000000000000000000000000000;;					contains = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !contains {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// podListEqual checks if the lists contents contain all of the same elements.
0000000000000000000000000000000000000000;;	func podListEqual(list1 []*v1.Pod, list2 []*v1.Pod) bool {
0000000000000000000000000000000000000000;;		if len(list1) != len(list2) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := map[*v1.Pod]int{}
0000000000000000000000000000000000000000;;		for _, val := range list1 {
0000000000000000000000000000000000000000;;			m[val] = m[val] + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, val := range list2 {
0000000000000000000000000000000000000000;;			m[val] = m[val] - 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range m {
0000000000000000000000000000000000000000;;			if v != 0 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
