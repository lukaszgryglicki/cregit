0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
b1f20585de7783b76bea2e50de61b43be0a9abb1;pkg/kubelet/prober/manager_test.go[pkg/kubelet/prober/manager_test.go][pkg/kubelet/prober/prober_manager_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package prober
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/prober/results"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/probe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		runtime.ReallyCrash = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var defaultProbe *v1.Probe = &v1.Probe{
0000000000000000000000000000000000000000;;		Handler: v1.Handler{
0000000000000000000000000000000000000000;;			Exec: &v1.ExecAction{},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		TimeoutSeconds:   1,
0000000000000000000000000000000000000000;;		PeriodSeconds:    1,
0000000000000000000000000000000000000000;;		SuccessThreshold: 1,
0000000000000000000000000000000000000000;;		FailureThreshold: 3,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAddRemovePods(t *testing.T) {
0000000000000000000000000000000000000000;;		noProbePod := v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID: "no_probe_pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{{
0000000000000000000000000000000000000000;;					Name: "no_probe1",
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					Name: "no_probe2",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		probePod := v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID: "probe_pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{{
0000000000000000000000000000000000000000;;					Name: "no_probe1",
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					Name:           "readiness",
0000000000000000000000000000000000000000;;					ReadinessProbe: defaultProbe,
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					Name: "no_probe2",
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					Name:          "liveness",
0000000000000000000000000000000000000000;;					LivenessProbe: defaultProbe,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := newTestManager()
0000000000000000000000000000000000000000;;		defer cleanup(t, m)
0000000000000000000000000000000000000000;;		if err := expectProbes(m, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Adding a pod with no probes should be a no-op.
0000000000000000000000000000000000000000;;		m.AddPod(&noProbePod)
0000000000000000000000000000000000000000;;		if err := expectProbes(m, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Adding a pod with probes.
0000000000000000000000000000000000000000;;		m.AddPod(&probePod)
0000000000000000000000000000000000000000;;		probePaths := []probeKey{
0000000000000000000000000000000000000000;;			{"probe_pod", "readiness", readiness},
0000000000000000000000000000000000000000;;			{"probe_pod", "liveness", liveness},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := expectProbes(m, probePaths); err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Removing un-probed pod.
0000000000000000000000000000000000000000;;		m.RemovePod(&noProbePod)
0000000000000000000000000000000000000000;;		if err := expectProbes(m, probePaths); err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Removing probed pod.
0000000000000000000000000000000000000000;;		m.RemovePod(&probePod)
0000000000000000000000000000000000000000;;		if err := waitForWorkerExit(m, probePaths); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := expectProbes(m, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Removing already removed pods should be a no-op.
0000000000000000000000000000000000000000;;		m.RemovePod(&probePod)
0000000000000000000000000000000000000000;;		if err := expectProbes(m, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCleanupPods(t *testing.T) {
0000000000000000000000000000000000000000;;		m := newTestManager()
0000000000000000000000000000000000000000;;		defer cleanup(t, m)
0000000000000000000000000000000000000000;;		podToCleanup := v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID: "pod_cleanup",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{{
0000000000000000000000000000000000000000;;					Name:           "prober1",
0000000000000000000000000000000000000000;;					ReadinessProbe: defaultProbe,
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					Name:          "prober2",
0000000000000000000000000000000000000000;;					LivenessProbe: defaultProbe,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podToKeep := v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID: "pod_keep",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{{
0000000000000000000000000000000000000000;;					Name:           "prober1",
0000000000000000000000000000000000000000;;					ReadinessProbe: defaultProbe,
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					Name:          "prober2",
0000000000000000000000000000000000000000;;					LivenessProbe: defaultProbe,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.AddPod(&podToCleanup)
0000000000000000000000000000000000000000;;		m.AddPod(&podToKeep)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.CleanupPods([]*v1.Pod{&podToKeep})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		removedProbes := []probeKey{
0000000000000000000000000000000000000000;;			{"pod_cleanup", "prober1", readiness},
0000000000000000000000000000000000000000;;			{"pod_cleanup", "prober2", liveness},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedProbes := []probeKey{
0000000000000000000000000000000000000000;;			{"pod_keep", "prober1", readiness},
0000000000000000000000000000000000000000;;			{"pod_keep", "prober2", liveness},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := waitForWorkerExit(m, removedProbes); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := expectProbes(m, expectedProbes); err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCleanupRepeated(t *testing.T) {
0000000000000000000000000000000000000000;;		m := newTestManager()
0000000000000000000000000000000000000000;;		defer cleanup(t, m)
0000000000000000000000000000000000000000;;		podTemplate := v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{{
0000000000000000000000000000000000000000;;					Name:           "prober1",
0000000000000000000000000000000000000000;;					ReadinessProbe: defaultProbe,
0000000000000000000000000000000000000000;;					LivenessProbe:  defaultProbe,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const numTestPods = 100
0000000000000000000000000000000000000000;;		for i := 0; i < numTestPods; i++ {
0000000000000000000000000000000000000000;;			pod := podTemplate
0000000000000000000000000000000000000000;;			pod.UID = types.UID(strconv.Itoa(i))
0000000000000000000000000000000000000000;;			m.AddPod(&pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;			m.CleanupPods([]*v1.Pod{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdatePodStatus(t *testing.T) {
0000000000000000000000000000000000000000;;		unprobed := v1.ContainerStatus{
0000000000000000000000000000000000000000;;			Name:        "unprobed_container",
0000000000000000000000000000000000000000;;			ContainerID: "test://unprobed_container_id",
0000000000000000000000000000000000000000;;			State: v1.ContainerState{
0000000000000000000000000000000000000000;;				Running: &v1.ContainerStateRunning{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		probedReady := v1.ContainerStatus{
0000000000000000000000000000000000000000;;			Name:        "probed_container_ready",
0000000000000000000000000000000000000000;;			ContainerID: "test://probed_container_ready_id",
0000000000000000000000000000000000000000;;			State: v1.ContainerState{
0000000000000000000000000000000000000000;;				Running: &v1.ContainerStateRunning{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		probedPending := v1.ContainerStatus{
0000000000000000000000000000000000000000;;			Name:        "probed_container_pending",
0000000000000000000000000000000000000000;;			ContainerID: "test://probed_container_pending_id",
0000000000000000000000000000000000000000;;			State: v1.ContainerState{
0000000000000000000000000000000000000000;;				Running: &v1.ContainerStateRunning{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		probedUnready := v1.ContainerStatus{
0000000000000000000000000000000000000000;;			Name:        "probed_container_unready",
0000000000000000000000000000000000000000;;			ContainerID: "test://probed_container_unready_id",
0000000000000000000000000000000000000000;;			State: v1.ContainerState{
0000000000000000000000000000000000000000;;				Running: &v1.ContainerStateRunning{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		terminated := v1.ContainerStatus{
0000000000000000000000000000000000000000;;			Name:        "terminated_container",
0000000000000000000000000000000000000000;;			ContainerID: "test://terminated_container_id",
0000000000000000000000000000000000000000;;			State: v1.ContainerState{
0000000000000000000000000000000000000000;;				Terminated: &v1.ContainerStateTerminated{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podStatus := v1.PodStatus{
0000000000000000000000000000000000000000;;			Phase: v1.PodRunning,
0000000000000000000000000000000000000000;;			ContainerStatuses: []v1.ContainerStatus{
0000000000000000000000000000000000000000;;				unprobed, probedReady, probedPending, probedUnready, terminated,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := newTestManager()
0000000000000000000000000000000000000000;;		// no cleanup: using fake workers.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup probe "workers" and cached results.
0000000000000000000000000000000000000000;;		m.workers = map[probeKey]*worker{
0000000000000000000000000000000000000000;;			{testPodUID, unprobed.Name, liveness}:       {},
0000000000000000000000000000000000000000;;			{testPodUID, probedReady.Name, readiness}:   {},
0000000000000000000000000000000000000000;;			{testPodUID, probedPending.Name, readiness}: {},
0000000000000000000000000000000000000000;;			{testPodUID, probedUnready.Name, readiness}: {},
0000000000000000000000000000000000000000;;			{testPodUID, terminated.Name, readiness}:    {},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.readinessManager.Set(kubecontainer.ParseContainerID(probedReady.ContainerID), results.Success, &v1.Pod{})
0000000000000000000000000000000000000000;;		m.readinessManager.Set(kubecontainer.ParseContainerID(probedUnready.ContainerID), results.Failure, &v1.Pod{})
0000000000000000000000000000000000000000;;		m.readinessManager.Set(kubecontainer.ParseContainerID(terminated.ContainerID), results.Success, &v1.Pod{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.UpdatePodStatus(testPodUID, &podStatus)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedReadiness := map[probeKey]bool{
0000000000000000000000000000000000000000;;			{testPodUID, unprobed.Name, readiness}:      true,
0000000000000000000000000000000000000000;;			{testPodUID, probedReady.Name, readiness}:   true,
0000000000000000000000000000000000000000;;			{testPodUID, probedPending.Name, readiness}: false,
0000000000000000000000000000000000000000;;			{testPodUID, probedUnready.Name, readiness}: false,
0000000000000000000000000000000000000000;;			{testPodUID, terminated.Name, readiness}:    false,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range podStatus.ContainerStatuses {
0000000000000000000000000000000000000000;;			expected, ok := expectedReadiness[probeKey{testPodUID, c.Name, readiness}]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				t.Fatalf("Missing expectation for test case: %v", c.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if expected != c.Ready {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected readiness for container %v: Expected %v but got %v",
0000000000000000000000000000000000000000;;					c.Name, expected, c.Ready)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateReadiness(t *testing.T) {
0000000000000000000000000000000000000000;;		testPod := getTestPod()
0000000000000000000000000000000000000000;;		setTestProbe(testPod, readiness, v1.Probe{})
0000000000000000000000000000000000000000;;		m := newTestManager()
0000000000000000000000000000000000000000;;		defer cleanup(t, m)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start syncing readiness without leaking goroutine.
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		go wait.Until(m.updateReadiness, 0, stopCh)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;			// Send an update to exit updateReadiness()
0000000000000000000000000000000000000000;;			m.readinessManager.Set(kubecontainer.ContainerID{}, results.Success, &v1.Pod{})
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exec := syncExecProber{}
0000000000000000000000000000000000000000;;		exec.set(probe.Success, nil)
0000000000000000000000000000000000000000;;		m.prober.exec = &exec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.statusManager.SetPodStatus(testPod, getTestRunningStatus())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.AddPod(testPod)
0000000000000000000000000000000000000000;;		probePaths := []probeKey{{testPodUID, testContainerName, readiness}}
0000000000000000000000000000000000000000;;		if err := expectProbes(m, probePaths); err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for ready status.
0000000000000000000000000000000000000000;;		if err := waitForReadyStatus(m, true); err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Prober fails.
0000000000000000000000000000000000000000;;		exec.set(probe.Failure, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for failed status.
0000000000000000000000000000000000000000;;		if err := waitForReadyStatus(m, false); err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectProbes(m *manager, expectedProbes []probeKey) error {
0000000000000000000000000000000000000000;;		m.workerLock.RLock()
0000000000000000000000000000000000000000;;		defer m.workerLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var unexpected []probeKey
0000000000000000000000000000000000000000;;		missing := make([]probeKey, len(expectedProbes))
0000000000000000000000000000000000000000;;		copy(missing, expectedProbes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	outer:
0000000000000000000000000000000000000000;;		for probePath := range m.workers {
0000000000000000000000000000000000000000;;			for i, expectedPath := range missing {
0000000000000000000000000000000000000000;;				if probePath == expectedPath {
0000000000000000000000000000000000000000;;					missing = append(missing[:i], missing[i+1:]...)
0000000000000000000000000000000000000000;;					continue outer
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			unexpected = append(unexpected, probePath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(missing) == 0 && len(unexpected) == 0 {
0000000000000000000000000000000000000000;;			return nil // Yay!
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Errorf("Unexpected probes: %v; Missing probes: %v;", unexpected, missing)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const interval = 1 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait for the given workers to exit & clean up.
0000000000000000000000000000000000000000;;	func waitForWorkerExit(m *manager, workerPaths []probeKey) error {
0000000000000000000000000000000000000000;;		for _, w := range workerPaths {
0000000000000000000000000000000000000000;;			condition := func() (bool, error) {
0000000000000000000000000000000000000000;;				_, exists := m.getWorker(w.podUID, w.containerName, w.probeType)
0000000000000000000000000000000000000000;;				return !exists, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if exited, _ := condition(); exited {
0000000000000000000000000000000000000000;;				continue // Already exited, no need to poll.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Infof("Polling %v", w)
0000000000000000000000000000000000000000;;			if err := wait.Poll(interval, wait.ForeverTestTimeout, condition); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait for the given workers to exit & clean up.
0000000000000000000000000000000000000000;;	func waitForReadyStatus(m *manager, ready bool) error {
0000000000000000000000000000000000000000;;		condition := func() (bool, error) {
0000000000000000000000000000000000000000;;			status, ok := m.statusManager.GetPodStatus(testPodUID)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("status not found: %q", testPodUID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(status.ContainerStatuses) != 1 {
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("expected single container, found %d", len(status.ContainerStatuses))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if status.ContainerStatuses[0].ContainerID != testContainerID.String() {
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("expected container %q, found %q",
0000000000000000000000000000000000000000;;					testContainerID, status.ContainerStatuses[0].ContainerID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return status.ContainerStatuses[0].Ready == ready, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("Polling for ready state %v", ready)
0000000000000000000000000000000000000000;;		if err := wait.Poll(interval, wait.ForeverTestTimeout, condition); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cleanup running probes to avoid leaking goroutines.
0000000000000000000000000000000000000000;;	func cleanup(t *testing.T, m *manager) {
0000000000000000000000000000000000000000;;		m.CleanupPods(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		condition := func() (bool, error) {
0000000000000000000000000000000000000000;;			workerCount := m.workerCount()
0000000000000000000000000000000000000000;;			if workerCount > 0 {
0000000000000000000000000000000000000000;;				glog.Infof("Waiting for %d workers to exit...", workerCount)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return workerCount == 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if exited, _ := condition(); exited {
0000000000000000000000000000000000000000;;			return // Already exited, no need to poll.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := wait.Poll(interval, wait.ForeverTestTimeout, condition); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error during cleanup: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
