0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
bd4f45eec9543af8193380c253c2ed3028706634;pkg/kubelet/probe.go[pkg/kubelet/probe.go][pkg/kubelet/prober/prober.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package prober
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/events"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/prober/results"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/format"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/probe"
0000000000000000000000000000000000000000;;		execprobe "k8s.io/kubernetes/pkg/probe/exec"
0000000000000000000000000000000000000000;;		httprobe "k8s.io/kubernetes/pkg/probe/http"
0000000000000000000000000000000000000000;;		tcprobe "k8s.io/kubernetes/pkg/probe/tcp"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const maxProbeRetries = 3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Prober helps to check the liveness/readiness of a container.
0000000000000000000000000000000000000000;;	type prober struct {
0000000000000000000000000000000000000000;;		exec   execprobe.ExecProber
0000000000000000000000000000000000000000;;		http   httprobe.HTTPProber
0000000000000000000000000000000000000000;;		tcp    tcprobe.TCPProber
0000000000000000000000000000000000000000;;		runner kubecontainer.ContainerCommandRunner
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		refManager *kubecontainer.RefManager
0000000000000000000000000000000000000000;;		recorder   record.EventRecorder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewProber creates a Prober, it takes a command runner and
0000000000000000000000000000000000000000;;	// several container info managers.
0000000000000000000000000000000000000000;;	func newProber(
0000000000000000000000000000000000000000;;		runner kubecontainer.ContainerCommandRunner,
0000000000000000000000000000000000000000;;		refManager *kubecontainer.RefManager,
0000000000000000000000000000000000000000;;		recorder record.EventRecorder) *prober {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &prober{
0000000000000000000000000000000000000000;;			exec:       execprobe.New(),
0000000000000000000000000000000000000000;;			http:       httprobe.New(),
0000000000000000000000000000000000000000;;			tcp:        tcprobe.New(),
0000000000000000000000000000000000000000;;			runner:     runner,
0000000000000000000000000000000000000000;;			refManager: refManager,
0000000000000000000000000000000000000000;;			recorder:   recorder,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// probe probes the container.
0000000000000000000000000000000000000000;;	func (pb *prober) probe(probeType probeType, pod *v1.Pod, status v1.PodStatus, container v1.Container, containerID kubecontainer.ContainerID) (results.Result, error) {
0000000000000000000000000000000000000000;;		var probeSpec *v1.Probe
0000000000000000000000000000000000000000;;		switch probeType {
0000000000000000000000000000000000000000;;		case readiness:
0000000000000000000000000000000000000000;;			probeSpec = container.ReadinessProbe
0000000000000000000000000000000000000000;;		case liveness:
0000000000000000000000000000000000000000;;			probeSpec = container.LivenessProbe
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return results.Failure, fmt.Errorf("Unknown probe type: %q", probeType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctrName := fmt.Sprintf("%s:%s", format.Pod(pod), container.Name)
0000000000000000000000000000000000000000;;		if probeSpec == nil {
0000000000000000000000000000000000000000;;			glog.Warningf("%s probe for %s is nil", probeType, ctrName)
0000000000000000000000000000000000000000;;			return results.Success, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result, output, err := pb.runProbeWithRetries(probeSpec, pod, status, container, containerID, maxProbeRetries)
0000000000000000000000000000000000000000;;		if err != nil || result != probe.Success {
0000000000000000000000000000000000000000;;			// Probe failed in one way or another.
0000000000000000000000000000000000000000;;			ref, hasRef := pb.refManager.GetRef(containerID)
0000000000000000000000000000000000000000;;			if !hasRef {
0000000000000000000000000000000000000000;;				glog.Warningf("No ref for container %q (%s)", containerID.String(), ctrName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(1).Infof("%s probe for %q errored: %v", probeType, ctrName, err)
0000000000000000000000000000000000000000;;				if hasRef {
0000000000000000000000000000000000000000;;					pb.recorder.Eventf(ref, v1.EventTypeWarning, events.ContainerUnhealthy, "%s probe errored: %v", probeType, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else { // result != probe.Success
0000000000000000000000000000000000000000;;				glog.V(1).Infof("%s probe for %q failed (%v): %s", probeType, ctrName, result, output)
0000000000000000000000000000000000000000;;				if hasRef {
0000000000000000000000000000000000000000;;					pb.recorder.Eventf(ref, v1.EventTypeWarning, events.ContainerUnhealthy, "%s probe failed: %s", probeType, output)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return results.Failure, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(3).Infof("%s probe for %q succeeded", probeType, ctrName)
0000000000000000000000000000000000000000;;		return results.Success, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// runProbeWithRetries tries to probe the container in a finite loop, it returns the last result
0000000000000000000000000000000000000000;;	// if it never succeeds.
0000000000000000000000000000000000000000;;	func (pb *prober) runProbeWithRetries(p *v1.Probe, pod *v1.Pod, status v1.PodStatus, container v1.Container, containerID kubecontainer.ContainerID, retries int) (probe.Result, string, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var result probe.Result
0000000000000000000000000000000000000000;;		var output string
0000000000000000000000000000000000000000;;		for i := 0; i < retries; i++ {
0000000000000000000000000000000000000000;;			result, output, err = pb.runProbe(p, pod, status, container, containerID)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return result, output, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, output, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildHeaderMap takes a list of HTTPHeader <name, value> string
0000000000000000000000000000000000000000;;	// pairs and returns a populated string->[]string http.Header map.
0000000000000000000000000000000000000000;;	func buildHeader(headerList []v1.HTTPHeader) http.Header {
0000000000000000000000000000000000000000;;		headers := make(http.Header)
0000000000000000000000000000000000000000;;		for _, header := range headerList {
0000000000000000000000000000000000000000;;			headers[header.Name] = append(headers[header.Name], header.Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return headers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pb *prober) runProbe(p *v1.Probe, pod *v1.Pod, status v1.PodStatus, container v1.Container, containerID kubecontainer.ContainerID) (probe.Result, string, error) {
0000000000000000000000000000000000000000;;		timeout := time.Duration(p.TimeoutSeconds) * time.Second
0000000000000000000000000000000000000000;;		if p.Exec != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Exec-Probe Pod: %v, Container: %v, Command: %v", pod, container, p.Exec.Command)
0000000000000000000000000000000000000000;;			command := kubecontainer.ExpandContainerCommandOnlyStatic(p.Exec.Command, container.Env)
0000000000000000000000000000000000000000;;			return pb.exec.Probe(pb.newExecInContainer(container, containerID, command, timeout))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.HTTPGet != nil {
0000000000000000000000000000000000000000;;			scheme := strings.ToLower(string(p.HTTPGet.Scheme))
0000000000000000000000000000000000000000;;			host := p.HTTPGet.Host
0000000000000000000000000000000000000000;;			if host == "" {
0000000000000000000000000000000000000000;;				host = status.PodIP
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			port, err := extractPort(p.HTTPGet.Port, container)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return probe.Unknown, "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			path := p.HTTPGet.Path
0000000000000000000000000000000000000000;;			glog.V(4).Infof("HTTP-Probe Host: %v://%v, Port: %v, Path: %v", scheme, host, port, path)
0000000000000000000000000000000000000000;;			url := formatURL(scheme, host, port, path)
0000000000000000000000000000000000000000;;			headers := buildHeader(p.HTTPGet.HTTPHeaders)
0000000000000000000000000000000000000000;;			glog.V(4).Infof("HTTP-Probe Headers: %v", headers)
0000000000000000000000000000000000000000;;			return pb.http.Probe(url, headers, timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.TCPSocket != nil {
0000000000000000000000000000000000000000;;			port, err := extractPort(p.TCPSocket.Port, container)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return probe.Unknown, "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			host := p.TCPSocket.Host
0000000000000000000000000000000000000000;;			if host == "" {
0000000000000000000000000000000000000000;;				host = status.PodIP
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("TCP-Probe Host: %v, Port: %v, Timeout: %v", host, port, timeout)
0000000000000000000000000000000000000000;;			return pb.tcp.Probe(host, port, timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Warningf("Failed to find probe builder for container: %v", container)
0000000000000000000000000000000000000000;;		return probe.Unknown, "", fmt.Errorf("Missing probe handler for %s:%s", format.Pod(pod), container.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractPort(param intstr.IntOrString, container v1.Container) (int, error) {
0000000000000000000000000000000000000000;;		port := -1
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		switch param.Type {
0000000000000000000000000000000000000000;;		case intstr.Int:
0000000000000000000000000000000000000000;;			port = param.IntValue()
0000000000000000000000000000000000000000;;		case intstr.String:
0000000000000000000000000000000000000000;;			if port, err = findPortByName(container, param.StrVal); err != nil {
0000000000000000000000000000000000000000;;				// Last ditch effort - maybe it was an int stored as string?
0000000000000000000000000000000000000000;;				if port, err = strconv.Atoi(param.StrVal); err != nil {
0000000000000000000000000000000000000000;;					return port, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return port, fmt.Errorf("IntOrString had no kind: %+v", param)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if port > 0 && port < 65536 {
0000000000000000000000000000000000000000;;			return port, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return port, fmt.Errorf("invalid port number: %v", port)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findPortByName is a helper function to look up a port in a container by name.
0000000000000000000000000000000000000000;;	func findPortByName(container v1.Container, portName string) (int, error) {
0000000000000000000000000000000000000000;;		for _, port := range container.Ports {
0000000000000000000000000000000000000000;;			if port.Name == portName {
0000000000000000000000000000000000000000;;				return int(port.ContainerPort), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, fmt.Errorf("port %s not found", portName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// formatURL formats a URL from args.  For testability.
0000000000000000000000000000000000000000;;	func formatURL(scheme string, host string, port int, path string) *url.URL {
0000000000000000000000000000000000000000;;		u, err := url.Parse(path)
0000000000000000000000000000000000000000;;		// Something is busted with the path, but it's too late to reject it. Pass it along as is.
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			u = &url.URL{
0000000000000000000000000000000000000000;;				Path: path,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u.Scheme = scheme
0000000000000000000000000000000000000000;;		u.Host = net.JoinHostPort(host, strconv.Itoa(port))
0000000000000000000000000000000000000000;;		return u
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type execInContainer struct {
0000000000000000000000000000000000000000;;		// run executes a command in a container. Combined stdout and stderr output is always returned. An
0000000000000000000000000000000000000000;;		// error is returned if one occurred.
0000000000000000000000000000000000000000;;		run func() ([]byte, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pb *prober) newExecInContainer(container v1.Container, containerID kubecontainer.ContainerID, cmd []string, timeout time.Duration) exec.Cmd {
0000000000000000000000000000000000000000;;		return execInContainer{func() ([]byte, error) {
0000000000000000000000000000000000000000;;			return pb.runner.RunInContainer(containerID, cmd, timeout)
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (eic execInContainer) Run() error {
0000000000000000000000000000000000000000;;		return fmt.Errorf("unimplemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (eic execInContainer) CombinedOutput() ([]byte, error) {
0000000000000000000000000000000000000000;;		return eic.run()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (eic execInContainer) Output() ([]byte, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("unimplemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (eic execInContainer) SetDir(dir string) {
0000000000000000000000000000000000000000;;		//unimplemented
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (eic execInContainer) SetStdin(in io.Reader) {
0000000000000000000000000000000000000000;;		//unimplemented
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (eic execInContainer) SetStdout(out io.Writer) {
0000000000000000000000000000000000000000;;		//unimplemented
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (eic execInContainer) SetStderr(out io.Writer) {
0000000000000000000000000000000000000000;;		//unimplemented
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (eic execInContainer) Stop() {
0000000000000000000000000000000000000000;;		//unimplemented
0000000000000000000000000000000000000000;;	}
