0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
b1f20585de7783b76bea2e50de61b43be0a9abb1;pkg/kubelet/prober/manager.go[pkg/kubelet/prober/manager.go][pkg/kubelet/prober/prober_manager.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package prober
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/prober/results"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/status"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/format"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Manager manages pod probing. It creates a probe "worker" for every container that specifies a
0000000000000000000000000000000000000000;;	// probe (AddPod). The worker periodically probes its assigned container and caches the results. The
0000000000000000000000000000000000000000;;	// manager use the cached probe results to set the appropriate Ready state in the PodStatus when
0000000000000000000000000000000000000000;;	// requested (UpdatePodStatus). Updating probe parameters is not currently supported.
0000000000000000000000000000000000000000;;	// TODO: Move liveness probing out of the runtime, to here.
0000000000000000000000000000000000000000;;	type Manager interface {
0000000000000000000000000000000000000000;;		// AddPod creates new probe workers for every container probe. This should be called for every
0000000000000000000000000000000000000000;;		// pod created.
0000000000000000000000000000000000000000;;		AddPod(pod *v1.Pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RemovePod handles cleaning up the removed pod state, including terminating probe workers and
0000000000000000000000000000000000000000;;		// deleting cached results.
0000000000000000000000000000000000000000;;		RemovePod(pod *v1.Pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CleanupPods handles cleaning up pods which should no longer be running.
0000000000000000000000000000000000000000;;		// It takes a list of "active pods" which should not be cleaned up.
0000000000000000000000000000000000000000;;		CleanupPods(activePods []*v1.Pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UpdatePodStatus modifies the given PodStatus with the appropriate Ready state for each
0000000000000000000000000000000000000000;;		// container based on container running status, cached probe results and worker states.
0000000000000000000000000000000000000000;;		UpdatePodStatus(types.UID, *v1.PodStatus)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start starts the Manager sync loops.
0000000000000000000000000000000000000000;;		Start()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type manager struct {
0000000000000000000000000000000000000000;;		// Map of active workers for probes
0000000000000000000000000000000000000000;;		workers map[probeKey]*worker
0000000000000000000000000000000000000000;;		// Lock for accessing & mutating workers
0000000000000000000000000000000000000000;;		workerLock sync.RWMutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The statusManager cache provides pod IP and container IDs for probing.
0000000000000000000000000000000000000000;;		statusManager status.Manager
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// readinessManager manages the results of readiness probes
0000000000000000000000000000000000000000;;		readinessManager results.Manager
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// livenessManager manages the results of liveness probes
0000000000000000000000000000000000000000;;		livenessManager results.Manager
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// prober executes the probe actions.
0000000000000000000000000000000000000000;;		prober *prober
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewManager(
0000000000000000000000000000000000000000;;		statusManager status.Manager,
0000000000000000000000000000000000000000;;		livenessManager results.Manager,
0000000000000000000000000000000000000000;;		runner kubecontainer.ContainerCommandRunner,
0000000000000000000000000000000000000000;;		refManager *kubecontainer.RefManager,
0000000000000000000000000000000000000000;;		recorder record.EventRecorder) Manager {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prober := newProber(runner, refManager, recorder)
0000000000000000000000000000000000000000;;		readinessManager := results.NewManager()
0000000000000000000000000000000000000000;;		return &manager{
0000000000000000000000000000000000000000;;			statusManager:    statusManager,
0000000000000000000000000000000000000000;;			prober:           prober,
0000000000000000000000000000000000000000;;			readinessManager: readinessManager,
0000000000000000000000000000000000000000;;			livenessManager:  livenessManager,
0000000000000000000000000000000000000000;;			workers:          make(map[probeKey]*worker),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Start syncing probe status. This should only be called once.
0000000000000000000000000000000000000000;;	func (m *manager) Start() {
0000000000000000000000000000000000000000;;		// Start syncing readiness.
0000000000000000000000000000000000000000;;		go wait.Forever(m.updateReadiness, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Key uniquely identifying container probes
0000000000000000000000000000000000000000;;	type probeKey struct {
0000000000000000000000000000000000000000;;		podUID        types.UID
0000000000000000000000000000000000000000;;		containerName string
0000000000000000000000000000000000000000;;		probeType     probeType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type of probe (readiness or liveness)
0000000000000000000000000000000000000000;;	type probeType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		liveness probeType = iota
0000000000000000000000000000000000000000;;		readiness
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// For debugging.
0000000000000000000000000000000000000000;;	func (t probeType) String() string {
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case readiness:
0000000000000000000000000000000000000000;;			return "Readiness"
0000000000000000000000000000000000000000;;		case liveness:
0000000000000000000000000000000000000000;;			return "Liveness"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "UNKNOWN"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) AddPod(pod *v1.Pod) {
0000000000000000000000000000000000000000;;		m.workerLock.Lock()
0000000000000000000000000000000000000000;;		defer m.workerLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := probeKey{podUID: pod.UID}
0000000000000000000000000000000000000000;;		for _, c := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			key.containerName = c.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if c.ReadinessProbe != nil {
0000000000000000000000000000000000000000;;				key.probeType = readiness
0000000000000000000000000000000000000000;;				if _, ok := m.workers[key]; ok {
0000000000000000000000000000000000000000;;					glog.Errorf("Readiness probe already exists! %v - %v",
0000000000000000000000000000000000000000;;						format.Pod(pod), c.Name)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w := newWorker(m, readiness, pod, c)
0000000000000000000000000000000000000000;;				m.workers[key] = w
0000000000000000000000000000000000000000;;				go w.run()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if c.LivenessProbe != nil {
0000000000000000000000000000000000000000;;				key.probeType = liveness
0000000000000000000000000000000000000000;;				if _, ok := m.workers[key]; ok {
0000000000000000000000000000000000000000;;					glog.Errorf("Liveness probe already exists! %v - %v",
0000000000000000000000000000000000000000;;						format.Pod(pod), c.Name)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w := newWorker(m, liveness, pod, c)
0000000000000000000000000000000000000000;;				m.workers[key] = w
0000000000000000000000000000000000000000;;				go w.run()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) RemovePod(pod *v1.Pod) {
0000000000000000000000000000000000000000;;		m.workerLock.RLock()
0000000000000000000000000000000000000000;;		defer m.workerLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := probeKey{podUID: pod.UID}
0000000000000000000000000000000000000000;;		for _, c := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			key.containerName = c.Name
0000000000000000000000000000000000000000;;			for _, probeType := range [...]probeType{readiness, liveness} {
0000000000000000000000000000000000000000;;				key.probeType = probeType
0000000000000000000000000000000000000000;;				if worker, ok := m.workers[key]; ok {
0000000000000000000000000000000000000000;;					worker.stop()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) CleanupPods(activePods []*v1.Pod) {
0000000000000000000000000000000000000000;;		desiredPods := make(map[types.UID]sets.Empty)
0000000000000000000000000000000000000000;;		for _, pod := range activePods {
0000000000000000000000000000000000000000;;			desiredPods[pod.UID] = sets.Empty{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.workerLock.RLock()
0000000000000000000000000000000000000000;;		defer m.workerLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, worker := range m.workers {
0000000000000000000000000000000000000000;;			if _, ok := desiredPods[key.podUID]; !ok {
0000000000000000000000000000000000000000;;				worker.stop()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) UpdatePodStatus(podUID types.UID, podStatus *v1.PodStatus) {
0000000000000000000000000000000000000000;;		for i, c := range podStatus.ContainerStatuses {
0000000000000000000000000000000000000000;;			var ready bool
0000000000000000000000000000000000000000;;			if c.State.Running == nil {
0000000000000000000000000000000000000000;;				ready = false
0000000000000000000000000000000000000000;;			} else if result, ok := m.readinessManager.Get(kubecontainer.ParseContainerID(c.ContainerID)); ok {
0000000000000000000000000000000000000000;;				ready = result == results.Success
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// The check whether there is a probe which hasn't run yet.
0000000000000000000000000000000000000000;;				_, exists := m.getWorker(podUID, c.Name, readiness)
0000000000000000000000000000000000000000;;				ready = !exists
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podStatus.ContainerStatuses[i].Ready = ready
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// init containers are ready if they have exited with success or if a readiness probe has
0000000000000000000000000000000000000000;;		// succeeded.
0000000000000000000000000000000000000000;;		for i, c := range podStatus.InitContainerStatuses {
0000000000000000000000000000000000000000;;			var ready bool
0000000000000000000000000000000000000000;;			if c.State.Terminated != nil && c.State.Terminated.ExitCode == 0 {
0000000000000000000000000000000000000000;;				ready = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podStatus.InitContainerStatuses[i].Ready = ready
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) getWorker(podUID types.UID, containerName string, probeType probeType) (*worker, bool) {
0000000000000000000000000000000000000000;;		m.workerLock.RLock()
0000000000000000000000000000000000000000;;		defer m.workerLock.RUnlock()
0000000000000000000000000000000000000000;;		worker, ok := m.workers[probeKey{podUID, containerName, probeType}]
0000000000000000000000000000000000000000;;		return worker, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Called by the worker after exiting.
0000000000000000000000000000000000000000;;	func (m *manager) removeWorker(podUID types.UID, containerName string, probeType probeType) {
0000000000000000000000000000000000000000;;		m.workerLock.Lock()
0000000000000000000000000000000000000000;;		defer m.workerLock.Unlock()
0000000000000000000000000000000000000000;;		delete(m.workers, probeKey{podUID, containerName, probeType})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// workerCount returns the total number of probe workers. For testing.
0000000000000000000000000000000000000000;;	func (m *manager) workerCount() int {
0000000000000000000000000000000000000000;;		m.workerLock.RLock()
0000000000000000000000000000000000000000;;		defer m.workerLock.RUnlock()
0000000000000000000000000000000000000000;;		return len(m.workers)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) updateReadiness() {
0000000000000000000000000000000000000000;;		update := <-m.readinessManager.Updates()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ready := update.Result == results.Success
0000000000000000000000000000000000000000;;		m.statusManager.SetContainerReadiness(update.PodUID, update.ContainerID, ready)
0000000000000000000000000000000000000000;;	}
