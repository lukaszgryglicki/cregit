0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
b1f20585de7783b76bea2e50de61b43be0a9abb1;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package prober
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/prober/results"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/format"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// worker handles the periodic probing of its assigned container. Each worker has a go-routine
0000000000000000000000000000000000000000;;	// associated with it which runs the probe loop until the container permanently terminates, or the
0000000000000000000000000000000000000000;;	// stop channel is closed. The worker uses the probe Manager's statusManager to get up-to-date
0000000000000000000000000000000000000000;;	// container IDs.
0000000000000000000000000000000000000000;;	type worker struct {
0000000000000000000000000000000000000000;;		// Channel for stopping the probe.
0000000000000000000000000000000000000000;;		stopCh chan struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The pod containing this probe (read-only)
0000000000000000000000000000000000000000;;		pod *v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The container to probe (read-only)
0000000000000000000000000000000000000000;;		container v1.Container
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Describes the probe configuration (read-only)
0000000000000000000000000000000000000000;;		spec *v1.Probe
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The type of the worker.
0000000000000000000000000000000000000000;;		probeType probeType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The probe value during the initial delay.
0000000000000000000000000000000000000000;;		initialValue results.Result
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Where to store this workers results.
0000000000000000000000000000000000000000;;		resultsManager results.Manager
0000000000000000000000000000000000000000;;		probeManager   *manager
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The last known container ID for this worker.
0000000000000000000000000000000000000000;;		containerID kubecontainer.ContainerID
0000000000000000000000000000000000000000;;		// The last probe result for this worker.
0000000000000000000000000000000000000000;;		lastResult results.Result
0000000000000000000000000000000000000000;;		// How many times in a row the probe has returned the same result.
0000000000000000000000000000000000000000;;		resultRun int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If set, skip probing.
0000000000000000000000000000000000000000;;		onHold bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates and starts a new probe worker.
0000000000000000000000000000000000000000;;	func newWorker(
0000000000000000000000000000000000000000;;		m *manager,
0000000000000000000000000000000000000000;;		probeType probeType,
0000000000000000000000000000000000000000;;		pod *v1.Pod,
0000000000000000000000000000000000000000;;		container v1.Container) *worker {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := &worker{
0000000000000000000000000000000000000000;;			stopCh:       make(chan struct{}, 1), // Buffer so stop() can be non-blocking.
0000000000000000000000000000000000000000;;			pod:          pod,
0000000000000000000000000000000000000000;;			container:    container,
0000000000000000000000000000000000000000;;			probeType:    probeType,
0000000000000000000000000000000000000000;;			probeManager: m,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch probeType {
0000000000000000000000000000000000000000;;		case readiness:
0000000000000000000000000000000000000000;;			w.spec = container.ReadinessProbe
0000000000000000000000000000000000000000;;			w.resultsManager = m.readinessManager
0000000000000000000000000000000000000000;;			w.initialValue = results.Failure
0000000000000000000000000000000000000000;;		case liveness:
0000000000000000000000000000000000000000;;			w.spec = container.LivenessProbe
0000000000000000000000000000000000000000;;			w.resultsManager = m.livenessManager
0000000000000000000000000000000000000000;;			w.initialValue = results.Success
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return w
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// run periodically probes the container.
0000000000000000000000000000000000000000;;	func (w *worker) run() {
0000000000000000000000000000000000000000;;		probeTickerPeriod := time.Duration(w.spec.PeriodSeconds) * time.Second
0000000000000000000000000000000000000000;;		probeTicker := time.NewTicker(probeTickerPeriod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			// Clean up.
0000000000000000000000000000000000000000;;			probeTicker.Stop()
0000000000000000000000000000000000000000;;			if !w.containerID.IsEmpty() {
0000000000000000000000000000000000000000;;				w.resultsManager.Remove(w.containerID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w.probeManager.removeWorker(w.pod.UID, w.container.Name, w.probeType)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If kubelet restarted the probes could be started in rapid succession.
0000000000000000000000000000000000000000;;		// Let the worker wait for a random portion of tickerPeriod before probing.
0000000000000000000000000000000000000000;;		time.Sleep(time.Duration(rand.Float64() * float64(probeTickerPeriod)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	probeLoop:
0000000000000000000000000000000000000000;;		for w.doProbe() {
0000000000000000000000000000000000000000;;			// Wait for next probe tick.
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-w.stopCh:
0000000000000000000000000000000000000000;;				break probeLoop
0000000000000000000000000000000000000000;;			case <-probeTicker.C:
0000000000000000000000000000000000000000;;				// continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stop stops the probe worker. The worker handles cleanup and removes itself from its manager.
0000000000000000000000000000000000000000;;	// It is safe to call stop multiple times.
0000000000000000000000000000000000000000;;	func (w *worker) stop() {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case w.stopCh <- struct{}{}:
0000000000000000000000000000000000000000;;		default: // Non-blocking.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// doProbe probes the container once and records the result.
0000000000000000000000000000000000000000;;	// Returns whether the worker should continue.
0000000000000000000000000000000000000000;;	func (w *worker) doProbe() (keepGoing bool) {
0000000000000000000000000000000000000000;;		defer func() { recover() }() // Actually eat panics (HandleCrash takes care of logging)
0000000000000000000000000000000000000000;;		defer runtime.HandleCrash(func(_ interface{}) { keepGoing = true })
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status, ok := w.probeManager.statusManager.GetPodStatus(w.pod.UID)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// Either the pod has not been created yet, or it was already deleted.
0000000000000000000000000000000000000000;;			glog.V(3).Infof("No status for pod: %v", format.Pod(w.pod))
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Worker should terminate if pod is terminated.
0000000000000000000000000000000000000000;;		if status.Phase == v1.PodFailed || status.Phase == v1.PodSucceeded {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Pod %v %v, exiting probe worker",
0000000000000000000000000000000000000000;;				format.Pod(w.pod), status.Phase)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, ok := podutil.GetContainerStatus(status.ContainerStatuses, w.container.Name)
0000000000000000000000000000000000000000;;		if !ok || len(c.ContainerID) == 0 {
0000000000000000000000000000000000000000;;			// Either the container has not been created yet, or it was deleted.
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Probe target container not found: %v - %v",
0000000000000000000000000000000000000000;;				format.Pod(w.pod), w.container.Name)
0000000000000000000000000000000000000000;;			return true // Wait for more information.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if w.containerID.String() != c.ContainerID {
0000000000000000000000000000000000000000;;			if !w.containerID.IsEmpty() {
0000000000000000000000000000000000000000;;				w.resultsManager.Remove(w.containerID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.containerID = kubecontainer.ParseContainerID(c.ContainerID)
0000000000000000000000000000000000000000;;			w.resultsManager.Set(w.containerID, w.initialValue, w.pod)
0000000000000000000000000000000000000000;;			// We've got a new container; resume probing.
0000000000000000000000000000000000000000;;			w.onHold = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if w.onHold {
0000000000000000000000000000000000000000;;			// Worker is on hold until there is a new container.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.State.Running == nil {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Non-running container probed: %v - %v",
0000000000000000000000000000000000000000;;				format.Pod(w.pod), w.container.Name)
0000000000000000000000000000000000000000;;			if !w.containerID.IsEmpty() {
0000000000000000000000000000000000000000;;				w.resultsManager.Set(w.containerID, results.Failure, w.pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Abort if the container will not be restarted.
0000000000000000000000000000000000000000;;			return c.State.Terminated == nil ||
0000000000000000000000000000000000000000;;				w.pod.Spec.RestartPolicy != v1.RestartPolicyNever
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if int32(time.Since(c.State.Running.StartedAt.Time).Seconds()) < w.spec.InitialDelaySeconds {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: in order for exec probes to correctly handle downward API env, we must be able to reconstruct
0000000000000000000000000000000000000000;;		// the full container environment here, OR we must make a call to the CRI in order to get those environment
0000000000000000000000000000000000000000;;		// values from the running container.
0000000000000000000000000000000000000000;;		result, err := w.probeManager.prober.probe(w.probeType, w.pod, status, w.container, w.containerID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Prober error, throw away the result.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if w.lastResult == result {
0000000000000000000000000000000000000000;;			w.resultRun++
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			w.lastResult = result
0000000000000000000000000000000000000000;;			w.resultRun = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if (result == results.Failure && w.resultRun < int(w.spec.FailureThreshold)) ||
0000000000000000000000000000000000000000;;			(result == results.Success && w.resultRun < int(w.spec.SuccessThreshold)) {
0000000000000000000000000000000000000000;;			// Success or failure is below threshold - leave the probe state unchanged.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.resultsManager.Set(w.containerID, result, w.pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if w.probeType == liveness && result == results.Failure {
0000000000000000000000000000000000000000;;			// The container fails a liveness check, it will need to be restarted.
0000000000000000000000000000000000000000;;			// Stop probing until we see a new container ID. This is to reduce the
0000000000000000000000000000000000000000;;			// chance of hitting #21751, where running `docker exec` when a
0000000000000000000000000000000000000000;;			// container is being stopped may lead to corrupted container state.
0000000000000000000000000000000000000000;;			w.onHold = true
0000000000000000000000000000000000000000;;			w.resultRun = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
