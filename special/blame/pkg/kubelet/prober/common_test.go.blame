0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
468ea8357025b43ac2a40d738ff0c920118d3bab;pkg/kubelet/prober/testing.go[pkg/kubelet/prober/testing.go][pkg/kubelet/prober/common_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package prober
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		kubepod "k8s.io/kubernetes/pkg/kubelet/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/prober/results"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/status"
0000000000000000000000000000000000000000;;		statustest "k8s.io/kubernetes/pkg/kubelet/status/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/probe"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		testContainerName = "cOnTaInEr_NaMe"
0000000000000000000000000000000000000000;;		testPodUID        = "pOd_UiD"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var testContainerID = kubecontainer.ContainerID{Type: "test", ID: "cOnTaInEr_Id"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTestRunningStatus() v1.PodStatus {
0000000000000000000000000000000000000000;;		containerStatus := v1.ContainerStatus{
0000000000000000000000000000000000000000;;			Name:        testContainerName,
0000000000000000000000000000000000000000;;			ContainerID: testContainerID.String(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		containerStatus.State.Running = &v1.ContainerStateRunning{StartedAt: metav1.Now()}
0000000000000000000000000000000000000000;;		podStatus := v1.PodStatus{
0000000000000000000000000000000000000000;;			Phase:             v1.PodRunning,
0000000000000000000000000000000000000000;;			ContainerStatuses: []v1.ContainerStatus{containerStatus},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return podStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTestPod() *v1.Pod {
0000000000000000000000000000000000000000;;		container := v1.Container{
0000000000000000000000000000000000000000;;			Name: testContainerName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers:    []v1.Container{container},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod.Name = "testPod"
0000000000000000000000000000000000000000;;		pod.UID = testPodUID
0000000000000000000000000000000000000000;;		return &pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setTestProbe(pod *v1.Pod, probeType probeType, probeSpec v1.Probe) {
0000000000000000000000000000000000000000;;		// All tests rely on the fake exec prober.
0000000000000000000000000000000000000000;;		probeSpec.Handler = v1.Handler{
0000000000000000000000000000000000000000;;			Exec: &v1.ExecAction{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Apply test defaults, overwridden for test speed.
0000000000000000000000000000000000000000;;		defaults := map[string]int64{
0000000000000000000000000000000000000000;;			"TimeoutSeconds":   1,
0000000000000000000000000000000000000000;;			"PeriodSeconds":    1,
0000000000000000000000000000000000000000;;			"SuccessThreshold": 1,
0000000000000000000000000000000000000000;;			"FailureThreshold": 1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for field, value := range defaults {
0000000000000000000000000000000000000000;;			f := reflect.ValueOf(&probeSpec).Elem().FieldByName(field)
0000000000000000000000000000000000000000;;			if f.Int() == 0 {
0000000000000000000000000000000000000000;;				f.SetInt(value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch probeType {
0000000000000000000000000000000000000000;;		case readiness:
0000000000000000000000000000000000000000;;			pod.Spec.Containers[0].ReadinessProbe = &probeSpec
0000000000000000000000000000000000000000;;		case liveness:
0000000000000000000000000000000000000000;;			pod.Spec.Containers[0].LivenessProbe = &probeSpec
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestManager() *manager {
0000000000000000000000000000000000000000;;		refManager := kubecontainer.NewRefManager()
0000000000000000000000000000000000000000;;		refManager.SetRef(testContainerID, &v1.ObjectReference{}) // Suppress prober warnings.
0000000000000000000000000000000000000000;;		podManager := kubepod.NewBasicPodManager(nil, nil, nil)
0000000000000000000000000000000000000000;;		// Add test pod to pod manager, so that status manager can get the pod from pod manager if needed.
0000000000000000000000000000000000000000;;		podManager.AddPod(getTestPod())
0000000000000000000000000000000000000000;;		m := NewManager(
0000000000000000000000000000000000000000;;			status.NewManager(&fake.Clientset{}, podManager, &statustest.FakePodDeletionSafetyProvider{}),
0000000000000000000000000000000000000000;;			results.NewManager(),
0000000000000000000000000000000000000000;;			nil, // runner
0000000000000000000000000000000000000000;;			refManager,
0000000000000000000000000000000000000000;;			&record.FakeRecorder{},
0000000000000000000000000000000000000000;;		).(*manager)
0000000000000000000000000000000000000000;;		// Don't actually execute probes.
0000000000000000000000000000000000000000;;		m.prober.exec = fakeExecProber{probe.Success, nil}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestWorker(m *manager, probeType probeType, probeSpec v1.Probe) *worker {
0000000000000000000000000000000000000000;;		pod := getTestPod()
0000000000000000000000000000000000000000;;		setTestProbe(pod, probeType, probeSpec)
0000000000000000000000000000000000000000;;		return newWorker(m, probeType, pod, pod.Spec.Containers[0])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeExecProber struct {
0000000000000000000000000000000000000000;;		result probe.Result
0000000000000000000000000000000000000000;;		err    error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p fakeExecProber) Probe(c exec.Cmd) (probe.Result, string, error) {
0000000000000000000000000000000000000000;;		return p.result, "", p.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type syncExecProber struct {
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;		fakeExecProber
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *syncExecProber) set(result probe.Result, err error) {
0000000000000000000000000000000000000000;;		p.Lock()
0000000000000000000000000000000000000000;;		defer p.Unlock()
0000000000000000000000000000000000000000;;		p.result = result
0000000000000000000000000000000000000000;;		p.err = err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *syncExecProber) Probe(cmd exec.Cmd) (probe.Result, string, error) {
0000000000000000000000000000000000000000;;		p.RLock()
0000000000000000000000000000000000000000;;		defer p.RUnlock()
0000000000000000000000000000000000000000;;		return p.fakeExecProber.Probe(cmd)
0000000000000000000000000000000000000000;;	}
