0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
d3d763fafa640fdf383ac0f27030219d7508312c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package prober
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		containertest "k8s.io/kubernetes/pkg/kubelet/container/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/prober/results"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/probe"
0000000000000000000000000000000000000000;;		execprobe "k8s.io/kubernetes/pkg/probe/exec"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFormatURL(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			scheme string
0000000000000000000000000000000000000000;;			host   string
0000000000000000000000000000000000000000;;			port   int
0000000000000000000000000000000000000000;;			path   string
0000000000000000000000000000000000000000;;			result string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"http", "localhost", 93, "", "http://localhost:93"},
0000000000000000000000000000000000000000;;			{"https", "localhost", 93, "/path", "https://localhost:93/path"},
0000000000000000000000000000000000000000;;			{"http", "localhost", 93, "?foo", "http://localhost:93?foo"},
0000000000000000000000000000000000000000;;			{"https", "localhost", 93, "/path?bar", "https://localhost:93/path?bar"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range testCases {
0000000000000000000000000000000000000000;;			url := formatURL(test.scheme, test.host, test.port, test.path)
0000000000000000000000000000000000000000;;			if url.String() != test.result {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %s, got %s", test.result, url.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFindPortByName(t *testing.T) {
0000000000000000000000000000000000000000;;		container := v1.Container{
0000000000000000000000000000000000000000;;			Ports: []v1.ContainerPort{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:          "foo",
0000000000000000000000000000000000000000;;					ContainerPort: 8080,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:          "bar",
0000000000000000000000000000000000000000;;					ContainerPort: 9000,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		want := 8080
0000000000000000000000000000000000000000;;		got, err := findPortByName(container, "foo")
0000000000000000000000000000000000000000;;		if got != want || err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, got %v, err: %v", want, got, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetURLParts(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			probe *v1.HTTPGetAction
0000000000000000000000000000000000000000;;			ok    bool
0000000000000000000000000000000000000000;;			host  string
0000000000000000000000000000000000000000;;			port  int
0000000000000000000000000000000000000000;;			path  string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{&v1.HTTPGetAction{Host: "", Port: intstr.FromInt(-1), Path: ""}, false, "", -1, ""},
0000000000000000000000000000000000000000;;			{&v1.HTTPGetAction{Host: "", Port: intstr.FromString(""), Path: ""}, false, "", -1, ""},
0000000000000000000000000000000000000000;;			{&v1.HTTPGetAction{Host: "", Port: intstr.FromString("-1"), Path: ""}, false, "", -1, ""},
0000000000000000000000000000000000000000;;			{&v1.HTTPGetAction{Host: "", Port: intstr.FromString("not-found"), Path: ""}, false, "", -1, ""},
0000000000000000000000000000000000000000;;			{&v1.HTTPGetAction{Host: "", Port: intstr.FromString("found"), Path: ""}, true, "127.0.0.1", 93, ""},
0000000000000000000000000000000000000000;;			{&v1.HTTPGetAction{Host: "", Port: intstr.FromInt(76), Path: ""}, true, "127.0.0.1", 76, ""},
0000000000000000000000000000000000000000;;			{&v1.HTTPGetAction{Host: "", Port: intstr.FromString("118"), Path: ""}, true, "127.0.0.1", 118, ""},
0000000000000000000000000000000000000000;;			{&v1.HTTPGetAction{Host: "hostname", Port: intstr.FromInt(76), Path: "path"}, true, "hostname", 76, "path"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range testCases {
0000000000000000000000000000000000000000;;			state := v1.PodStatus{PodIP: "127.0.0.1"}
0000000000000000000000000000000000000000;;			container := v1.Container{
0000000000000000000000000000000000000000;;				Ports: []v1.ContainerPort{{Name: "found", ContainerPort: 93}},
0000000000000000000000000000000000000000;;				LivenessProbe: &v1.Probe{
0000000000000000000000000000000000000000;;					Handler: v1.Handler{
0000000000000000000000000000000000000000;;						HTTPGet: test.probe,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			scheme := test.probe.Scheme
0000000000000000000000000000000000000000;;			if scheme == "" {
0000000000000000000000000000000000000000;;				scheme = v1.URISchemeHTTP
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			host := test.probe.Host
0000000000000000000000000000000000000000;;			if host == "" {
0000000000000000000000000000000000000000;;				host = state.PodIP
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			port, err := extractPort(test.probe.Port, container)
0000000000000000000000000000000000000000;;			if test.ok && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			path := test.probe.Path
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !test.ok && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("Expected error for %+v, got %s%s:%d/%s", test, scheme, host, port, path)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.ok {
0000000000000000000000000000000000000000;;				if host != test.host || port != test.port || path != test.path {
0000000000000000000000000000000000000000;;					t.Errorf("Expected %s:%d/%s, got %s:%d/%s",
0000000000000000000000000000000000000000;;						test.host, test.port, test.path, host, port, path)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetTCPAddrParts(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			probe *v1.TCPSocketAction
0000000000000000000000000000000000000000;;			ok    bool
0000000000000000000000000000000000000000;;			host  string
0000000000000000000000000000000000000000;;			port  int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{&v1.TCPSocketAction{Port: intstr.FromInt(-1)}, false, "", -1},
0000000000000000000000000000000000000000;;			{&v1.TCPSocketAction{Port: intstr.FromString("")}, false, "", -1},
0000000000000000000000000000000000000000;;			{&v1.TCPSocketAction{Port: intstr.FromString("-1")}, false, "", -1},
0000000000000000000000000000000000000000;;			{&v1.TCPSocketAction{Port: intstr.FromString("not-found")}, false, "", -1},
0000000000000000000000000000000000000000;;			{&v1.TCPSocketAction{Port: intstr.FromString("found")}, true, "1.2.3.4", 93},
0000000000000000000000000000000000000000;;			{&v1.TCPSocketAction{Port: intstr.FromInt(76)}, true, "1.2.3.4", 76},
0000000000000000000000000000000000000000;;			{&v1.TCPSocketAction{Port: intstr.FromString("118")}, true, "1.2.3.4", 118},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range testCases {
0000000000000000000000000000000000000000;;			host := "1.2.3.4"
0000000000000000000000000000000000000000;;			container := v1.Container{
0000000000000000000000000000000000000000;;				Ports: []v1.ContainerPort{{Name: "found", ContainerPort: 93}},
0000000000000000000000000000000000000000;;				LivenessProbe: &v1.Probe{
0000000000000000000000000000000000000000;;					Handler: v1.Handler{
0000000000000000000000000000000000000000;;						TCPSocket: test.probe,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			port, err := extractPort(test.probe.Port, container)
0000000000000000000000000000000000000000;;			if !test.ok && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("Expected error for %+v, got %s:%d", test, host, port)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.ok && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.ok {
0000000000000000000000000000000000000000;;				if host != test.host || port != test.port {
0000000000000000000000000000000000000000;;					t.Errorf("Expected %s:%d, got %s:%d", test.host, test.port, host, port)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHTTPHeaders(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			input  []v1.HTTPHeader
0000000000000000000000000000000000000000;;			output http.Header
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{[]v1.HTTPHeader{}, http.Header{}},
0000000000000000000000000000000000000000;;			{[]v1.HTTPHeader{
0000000000000000000000000000000000000000;;				{Name: "X-Muffins-Or-Cupcakes", Value: "Muffins"},
0000000000000000000000000000000000000000;;			}, http.Header{"X-Muffins-Or-Cupcakes": {"Muffins"}}},
0000000000000000000000000000000000000000;;			{[]v1.HTTPHeader{
0000000000000000000000000000000000000000;;				{Name: "X-Muffins-Or-Cupcakes", Value: "Muffins"},
0000000000000000000000000000000000000000;;				{Name: "X-Muffins-Or-Plumcakes", Value: "Muffins!"},
0000000000000000000000000000000000000000;;			}, http.Header{"X-Muffins-Or-Cupcakes": {"Muffins"},
0000000000000000000000000000000000000000;;				"X-Muffins-Or-Plumcakes": {"Muffins!"}}},
0000000000000000000000000000000000000000;;			{[]v1.HTTPHeader{
0000000000000000000000000000000000000000;;				{Name: "X-Muffins-Or-Cupcakes", Value: "Muffins"},
0000000000000000000000000000000000000000;;				{Name: "X-Muffins-Or-Cupcakes", Value: "Cupcakes, too"},
0000000000000000000000000000000000000000;;			}, http.Header{"X-Muffins-Or-Cupcakes": {"Muffins", "Cupcakes, too"}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range testCases {
0000000000000000000000000000000000000000;;			headers := buildHeader(test.input)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.output, headers) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %#v, got %#v", test.output, headers)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestProbe(t *testing.T) {
0000000000000000000000000000000000000000;;		containerID := kubecontainer.ContainerID{Type: "test", ID: "foobar"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		execProbe := &v1.Probe{
0000000000000000000000000000000000000000;;			Handler: v1.Handler{
0000000000000000000000000000000000000000;;				Exec: &v1.ExecAction{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			probe          *v1.Probe
0000000000000000000000000000000000000000;;			env            []v1.EnvVar
0000000000000000000000000000000000000000;;			execError      bool
0000000000000000000000000000000000000000;;			expectError    bool
0000000000000000000000000000000000000000;;			execResult     probe.Result
0000000000000000000000000000000000000000;;			expectedResult results.Result
0000000000000000000000000000000000000000;;			expectCommand  []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{ // No probe
0000000000000000000000000000000000000000;;				probe:          nil,
0000000000000000000000000000000000000000;;				expectedResult: results.Success,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // No handler
0000000000000000000000000000000000000000;;				probe:          &v1.Probe{},
0000000000000000000000000000000000000000;;				expectError:    true,
0000000000000000000000000000000000000000;;				expectedResult: results.Failure,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // Probe fails
0000000000000000000000000000000000000000;;				probe:          execProbe,
0000000000000000000000000000000000000000;;				execResult:     probe.Failure,
0000000000000000000000000000000000000000;;				expectedResult: results.Failure,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // Probe succeeds
0000000000000000000000000000000000000000;;				probe:          execProbe,
0000000000000000000000000000000000000000;;				execResult:     probe.Success,
0000000000000000000000000000000000000000;;				expectedResult: results.Success,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // Probe result is unknown
0000000000000000000000000000000000000000;;				probe:          execProbe,
0000000000000000000000000000000000000000;;				execResult:     probe.Unknown,
0000000000000000000000000000000000000000;;				expectedResult: results.Failure,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // Probe has an error
0000000000000000000000000000000000000000;;				probe:          execProbe,
0000000000000000000000000000000000000000;;				execError:      true,
0000000000000000000000000000000000000000;;				expectError:    true,
0000000000000000000000000000000000000000;;				execResult:     probe.Unknown,
0000000000000000000000000000000000000000;;				expectedResult: results.Failure,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // Probe arguments are passed through
0000000000000000000000000000000000000000;;				probe: &v1.Probe{
0000000000000000000000000000000000000000;;					Handler: v1.Handler{
0000000000000000000000000000000000000000;;						Exec: &v1.ExecAction{
0000000000000000000000000000000000000000;;							Command: []string{"/bin/bash", "-c", "some script"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectCommand:  []string{"/bin/bash", "-c", "some script"},
0000000000000000000000000000000000000000;;				execResult:     probe.Success,
0000000000000000000000000000000000000000;;				expectedResult: results.Success,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // Probe arguments are passed through
0000000000000000000000000000000000000000;;				probe: &v1.Probe{
0000000000000000000000000000000000000000;;					Handler: v1.Handler{
0000000000000000000000000000000000000000;;						Exec: &v1.ExecAction{
0000000000000000000000000000000000000000;;							Command: []string{"/bin/bash", "-c", "some $(A) $(B)"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				env: []v1.EnvVar{
0000000000000000000000000000000000000000;;					{Name: "A", Value: "script"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectCommand:  []string{"/bin/bash", "-c", "some script $(B)"},
0000000000000000000000000000000000000000;;				execResult:     probe.Success,
0000000000000000000000000000000000000000;;				expectedResult: results.Success,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			for _, probeType := range [...]probeType{liveness, readiness} {
0000000000000000000000000000000000000000;;				prober := &prober{
0000000000000000000000000000000000000000;;					refManager: kubecontainer.NewRefManager(),
0000000000000000000000000000000000000000;;					recorder:   &record.FakeRecorder{},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				testID := fmt.Sprintf("%d-%s", i, probeType)
0000000000000000000000000000000000000000;;				testContainer := v1.Container{Env: test.env}
0000000000000000000000000000000000000000;;				switch probeType {
0000000000000000000000000000000000000000;;				case liveness:
0000000000000000000000000000000000000000;;					testContainer.LivenessProbe = test.probe
0000000000000000000000000000000000000000;;				case readiness:
0000000000000000000000000000000000000000;;					testContainer.ReadinessProbe = test.probe
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if test.execError {
0000000000000000000000000000000000000000;;					prober.exec = fakeExecProber{test.execResult, errors.New("exec error")}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					prober.exec = fakeExecProber{test.execResult, nil}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				result, err := prober.probe(probeType, &v1.Pod{}, v1.PodStatus{}, testContainer, containerID)
0000000000000000000000000000000000000000;;				if test.expectError && err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("[%s] Expected probe error but no error was returned.", testID)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !test.expectError && err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("[%s] Didn't expect probe error but got: %v", testID, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if test.expectedResult != result {
0000000000000000000000000000000000000000;;					t.Errorf("[%s] Expected result to be %v but was %v", testID, test.expectedResult, result)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(test.expectCommand) > 0 {
0000000000000000000000000000000000000000;;					prober.exec = execprobe.New()
0000000000000000000000000000000000000000;;					prober.runner = &containertest.FakeContainerCommandRunner{}
0000000000000000000000000000000000000000;;					_, err := prober.probe(probeType, &v1.Pod{}, v1.PodStatus{}, testContainer, containerID)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("[%s] Didn't expect probe error but got: %v", testID, err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !reflect.DeepEqual(test.expectCommand, prober.runner.(*containertest.FakeContainerCommandRunner).Cmd) {
0000000000000000000000000000000000000000;;						t.Errorf("[%s] unexpected probe arguments: %v", testID, prober.runner.(*containertest.FakeContainerCommandRunner).Cmd)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewExecInContainer(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;			err  error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "no error",
0000000000000000000000000000000000000000;;				err:  nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "error - make sure we get output",
0000000000000000000000000000000000000000;;				err:  errors.New("bad"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			runner := &containertest.FakeContainerCommandRunner{
0000000000000000000000000000000000000000;;				Stdout: "foo",
0000000000000000000000000000000000000000;;				Err:    test.err,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			prober := &prober{
0000000000000000000000000000000000000000;;				runner: runner,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			container := v1.Container{}
0000000000000000000000000000000000000000;;			containerID := kubecontainer.ContainerID{Type: "docker", ID: "containerID"}
0000000000000000000000000000000000000000;;			cmd := []string{"/foo", "bar"}
0000000000000000000000000000000000000000;;			exec := prober.newExecInContainer(container, containerID, cmd, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			actualOutput, err := exec.CombinedOutput()
0000000000000000000000000000000000000000;;			if e, a := containerID, runner.ContainerID; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%s: container id: expected %v, got %v", test.name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := cmd, runner.Cmd; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: cmd: expected %v, got %v", test.name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// this isn't 100% foolproof as a bug in a real ContainerCommandRunner where it fails to copy to stdout/stderr wouldn't be caught by this test
0000000000000000000000000000000000000000;;			if e, a := "foo", string(actualOutput); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%s: output: expected %q, got %q", test.name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := fmt.Sprintf("%v", test.err), fmt.Sprintf("%v", err); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%s: error: expected %s, got %s", test.name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
