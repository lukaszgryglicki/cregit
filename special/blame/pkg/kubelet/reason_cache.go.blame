0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
3dd58c9e58b169d0492ee654875163ad2d4dc7cd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/groupcache/lru"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReasonCache stores the failure reason of the latest container start
0000000000000000000000000000000000000000;;	// in a string, keyed by <pod_UID>_<container_name>. The goal is to
0000000000000000000000000000000000000000;;	// propagate this reason to the container status. This endeavor is
0000000000000000000000000000000000000000;;	// "best-effort" for two reasons:
0000000000000000000000000000000000000000;;	//   1. The cache is not persisted.
0000000000000000000000000000000000000000;;	//   2. We use an LRU cache to avoid extra garbage collection work. This
0000000000000000000000000000000000000000;;	//      means that some entries may be recycled before a pod has been
0000000000000000000000000000000000000000;;	//      deleted.
0000000000000000000000000000000000000000;;	// TODO(random-liu): Use more reliable cache which could collect garbage of failed pod.
0000000000000000000000000000000000000000;;	// TODO(random-liu): Move reason cache to somewhere better.
0000000000000000000000000000000000000000;;	type ReasonCache struct {
0000000000000000000000000000000000000000;;		lock  sync.Mutex
0000000000000000000000000000000000000000;;		cache *lru.Cache
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reasonInfo is the cached item in ReasonCache
0000000000000000000000000000000000000000;;	type reasonInfo struct {
0000000000000000000000000000000000000000;;		reason  error
0000000000000000000000000000000000000000;;		message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maxReasonCacheEntries is the cache entry number in lru cache. 1000 is a proper number
0000000000000000000000000000000000000000;;	// for our 100 pods per node target. If we support more pods per node in the future, we
0000000000000000000000000000000000000000;;	// may want to increase the number.
0000000000000000000000000000000000000000;;	const maxReasonCacheEntries = 1000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewReasonCache() *ReasonCache {
0000000000000000000000000000000000000000;;		return &ReasonCache{cache: lru.New(maxReasonCacheEntries)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ReasonCache) composeKey(uid types.UID, name string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s_%s", uid, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// add adds error reason into the cache
0000000000000000000000000000000000000000;;	func (c *ReasonCache) add(uid types.UID, name string, reason error, message string) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		c.cache.Add(c.composeKey(uid, name), reasonInfo{reason, message})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update updates the reason cache with the SyncPodResult. Only SyncResult with
0000000000000000000000000000000000000000;;	// StartContainer action will change the cache.
0000000000000000000000000000000000000000;;	func (c *ReasonCache) Update(uid types.UID, result kubecontainer.PodSyncResult) {
0000000000000000000000000000000000000000;;		for _, r := range result.SyncResults {
0000000000000000000000000000000000000000;;			if r.Action != kubecontainer.StartContainer {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			name := r.Target.(string)
0000000000000000000000000000000000000000;;			if r.Error != nil {
0000000000000000000000000000000000000000;;				c.add(uid, name, r.Error, r.Message)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				c.Remove(uid, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove removes error reason from the cache
0000000000000000000000000000000000000000;;	func (c *ReasonCache) Remove(uid types.UID, name string) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		c.cache.Remove(c.composeKey(uid, name))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get gets error reason from the cache. The return values are error reason, error message and
0000000000000000000000000000000000000000;;	// whether an error reason is found in the cache. If no error reason is found, empty string will
0000000000000000000000000000000000000000;;	// be returned for error reason and error message.
0000000000000000000000000000000000000000;;	func (c *ReasonCache) Get(uid types.UID, name string) (error, string, bool) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		value, ok := c.cache.Get(c.composeKey(uid, name))
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, "", ok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		info := value.(reasonInfo)
0000000000000000000000000000000000000000;;		return info.reason, info.message, ok
0000000000000000000000000000000000000000;;	}
