0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
6898b78c278b43b7e1790a5b5c1fe060fdc30bd5;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		kubetypes "k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/format"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		runOnceManifestDelay     = 1 * time.Second
0000000000000000000000000000000000000000;;		runOnceMaxRetries        = 10
0000000000000000000000000000000000000000;;		runOnceRetryDelay        = 1 * time.Second
0000000000000000000000000000000000000000;;		runOnceRetryDelayBackoff = 2
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RunPodResult struct {
0000000000000000000000000000000000000000;;		Pod *v1.Pod
0000000000000000000000000000000000000000;;		Err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunOnce polls from one configuration update and run the associated pods.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) RunOnce(updates <-chan kubetypes.PodUpdate) ([]RunPodResult, error) {
0000000000000000000000000000000000000000;;		// Setup filesystem directories.
0000000000000000000000000000000000000000;;		if err := kl.setupDataDirs(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the container logs directory does not exist, create it.
0000000000000000000000000000000000000000;;		if _, err := os.Stat(ContainerLogsDir); err != nil {
0000000000000000000000000000000000000000;;			if err := kl.os.MkdirAll(ContainerLogsDir, 0755); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to create directory %q: %v", ContainerLogsDir, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case u := <-updates:
0000000000000000000000000000000000000000;;			glog.Infof("processing manifest with %d pods", len(u.Pods))
0000000000000000000000000000000000000000;;			result, err := kl.runOnce(u.Pods, runOnceRetryDelay)
0000000000000000000000000000000000000000;;			glog.Infof("finished processing %d pods", len(u.Pods))
0000000000000000000000000000000000000000;;			return result, err
0000000000000000000000000000000000000000;;		case <-time.After(runOnceManifestDelay):
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no pod manifest update after %v", runOnceManifestDelay)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// runOnce runs a given set of pods and returns their status.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) runOnce(pods []*v1.Pod, retryDelay time.Duration) (results []RunPodResult, err error) {
0000000000000000000000000000000000000000;;		ch := make(chan RunPodResult)
0000000000000000000000000000000000000000;;		admitted := []*v1.Pod{}
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			// Check if we can admit the pod.
0000000000000000000000000000000000000000;;			if ok, reason, message := kl.canAdmitPod(admitted, pod); !ok {
0000000000000000000000000000000000000000;;				kl.rejectPod(pod, reason, message)
0000000000000000000000000000000000000000;;				results = append(results, RunPodResult{pod, nil})
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			admitted = append(admitted, pod)
0000000000000000000000000000000000000000;;			go func(pod *v1.Pod) {
0000000000000000000000000000000000000000;;				err := kl.runPod(pod, retryDelay)
0000000000000000000000000000000000000000;;				ch <- RunPodResult{pod, err}
0000000000000000000000000000000000000000;;			}(pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Waiting for %d pods", len(admitted))
0000000000000000000000000000000000000000;;		failedPods := []string{}
0000000000000000000000000000000000000000;;		for i := 0; i < len(admitted); i++ {
0000000000000000000000000000000000000000;;			res := <-ch
0000000000000000000000000000000000000000;;			results = append(results, res)
0000000000000000000000000000000000000000;;			if res.Err != nil {
0000000000000000000000000000000000000000;;				// TODO(proppy): report which containers failed the pod.
0000000000000000000000000000000000000000;;				glog.Infof("failed to start pod %q: %v", format.Pod(res.Pod), res.Err)
0000000000000000000000000000000000000000;;				failedPods = append(failedPods, format.Pod(res.Pod))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Infof("started pod %q", format.Pod(res.Pod))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(failedPods) > 0 {
0000000000000000000000000000000000000000;;			return results, fmt.Errorf("error running pods: %v", failedPods)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("%d pods started", len(pods))
0000000000000000000000000000000000000000;;		return results, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// runPod runs a single pod and wait until all containers are running.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) runPod(pod *v1.Pod, retryDelay time.Duration) error {
0000000000000000000000000000000000000000;;		delay := retryDelay
0000000000000000000000000000000000000000;;		retry := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			status, err := kl.containerRuntime.GetPodStatus(pod.UID, pod.Name, pod.Namespace)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Unable to get status for pod %q: %v", format.Pod(pod), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if kl.isPodRunning(pod, status) {
0000000000000000000000000000000000000000;;				glog.Infof("pod %q containers running", format.Pod(pod))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Infof("pod %q containers not running: syncing", format.Pod(pod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.Infof("Creating a mirror pod for static pod %q", format.Pod(pod))
0000000000000000000000000000000000000000;;			if err := kl.podManager.CreateMirrorPod(pod); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed creating a mirror pod %q: %v", format.Pod(pod), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mirrorPod, _ := kl.podManager.GetMirrorPodByPod(pod)
0000000000000000000000000000000000000000;;			if err = kl.syncPod(syncPodOptions{
0000000000000000000000000000000000000000;;				pod:        pod,
0000000000000000000000000000000000000000;;				mirrorPod:  mirrorPod,
0000000000000000000000000000000000000000;;				podStatus:  status,
0000000000000000000000000000000000000000;;				updateType: kubetypes.SyncPodUpdate,
0000000000000000000000000000000000000000;;			}); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("error syncing pod %q: %v", format.Pod(pod), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if retry >= runOnceMaxRetries {
0000000000000000000000000000000000000000;;				return fmt.Errorf("timeout error: pod %q containers not running after %d retries", format.Pod(pod), runOnceMaxRetries)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO(proppy): health checking would be better than waiting + checking the state at the next iteration.
0000000000000000000000000000000000000000;;			glog.Infof("pod %q containers synced, waiting for %v", format.Pod(pod), delay)
0000000000000000000000000000000000000000;;			time.Sleep(delay)
0000000000000000000000000000000000000000;;			retry++
0000000000000000000000000000000000000000;;			delay *= runOnceRetryDelayBackoff
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isPodRunning returns true if all containers of a manifest are running.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) isPodRunning(pod *v1.Pod, status *kubecontainer.PodStatus) bool {
0000000000000000000000000000000000000000;;		for _, c := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			cs := status.FindContainerStatusByName(c.Name)
0000000000000000000000000000000000000000;;			if cs == nil || cs.State != kubecontainer.ContainerStateRunning {
0000000000000000000000000000000000000000;;				glog.Infof("Container %q for pod %q not running", c.Name, format.Pod(pod))
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
