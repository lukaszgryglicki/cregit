0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
9fbdd758c00a160e902805405146a779d3acf5d8;pkg/kubelet/kubelet_server.go[pkg/kubelet/kubelet_server.go][pkg/kubelet/server/server.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package server
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/pprof"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		goruntime "runtime"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restful "github.com/emicklei/go-restful"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		cadvisorapi "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		cadvisorapiv2 "github.com/google/cadvisor/info/v2"
0000000000000000000000000000000000000000;;		"github.com/prometheus/client_golang/prometheus"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrs "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		remotecommandconsts "k8s.io/apimachinery/pkg/util/remotecommand"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/authenticator"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/healthz"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/httplog"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/flushwriter"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/remotecommand"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/v1/validation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/cm"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/server/portforward"
0000000000000000000000000000000000000000;;		remotecommandserver "k8s.io/kubernetes/pkg/kubelet/server/remotecommand"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/server/stats"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/server/streaming"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/configz"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/limitwriter"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		metricsPath = "/metrics"
0000000000000000000000000000000000000000;;		specPath    = "/spec/"
0000000000000000000000000000000000000000;;		statsPath   = "/stats/"
0000000000000000000000000000000000000000;;		logsPath    = "/logs/"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Server is a http.Handler which exposes kubelet functionality over HTTP.
0000000000000000000000000000000000000000;;	type Server struct {
0000000000000000000000000000000000000000;;		auth             AuthInterface
0000000000000000000000000000000000000000;;		host             HostInterface
0000000000000000000000000000000000000000;;		restfulCont      containerInterface
0000000000000000000000000000000000000000;;		resourceAnalyzer stats.ResourceAnalyzer
0000000000000000000000000000000000000000;;		runtime          kubecontainer.Runtime
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TLSOptions struct {
0000000000000000000000000000000000000000;;		Config   *tls.Config
0000000000000000000000000000000000000000;;		CertFile string
0000000000000000000000000000000000000000;;		KeyFile  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// containerInterface defines the restful.Container functions used on the root container
0000000000000000000000000000000000000000;;	type containerInterface interface {
0000000000000000000000000000000000000000;;		Add(service *restful.WebService) *restful.Container
0000000000000000000000000000000000000000;;		Handle(path string, handler http.Handler)
0000000000000000000000000000000000000000;;		Filter(filter restful.FilterFunction)
0000000000000000000000000000000000000000;;		ServeHTTP(w http.ResponseWriter, r *http.Request)
0000000000000000000000000000000000000000;;		RegisteredWebServices() []*restful.WebService
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RegisteredHandlePaths returns the paths of handlers registered directly with the container (non-web-services)
0000000000000000000000000000000000000000;;		// Used to test filters are being applied on non-web-service handlers
0000000000000000000000000000000000000000;;		RegisteredHandlePaths() []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// filteringContainer delegates all Handle(...) calls to Container.HandleWithFilter(...),
0000000000000000000000000000000000000000;;	// so we can ensure restful.FilterFunctions are used for all handlers
0000000000000000000000000000000000000000;;	type filteringContainer struct {
0000000000000000000000000000000000000000;;		*restful.Container
0000000000000000000000000000000000000000;;		registeredHandlePaths []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *filteringContainer) Handle(path string, handler http.Handler) {
0000000000000000000000000000000000000000;;		a.HandleWithFilter(path, handler)
0000000000000000000000000000000000000000;;		a.registeredHandlePaths = append(a.registeredHandlePaths, path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (a *filteringContainer) RegisteredHandlePaths() []string {
0000000000000000000000000000000000000000;;		return a.registeredHandlePaths
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListenAndServeKubeletServer initializes a server to respond to HTTP network requests on the Kubelet.
0000000000000000000000000000000000000000;;	func ListenAndServeKubeletServer(
0000000000000000000000000000000000000000;;		host HostInterface,
0000000000000000000000000000000000000000;;		resourceAnalyzer stats.ResourceAnalyzer,
0000000000000000000000000000000000000000;;		address net.IP,
0000000000000000000000000000000000000000;;		port uint,
0000000000000000000000000000000000000000;;		tlsOptions *TLSOptions,
0000000000000000000000000000000000000000;;		auth AuthInterface,
0000000000000000000000000000000000000000;;		enableDebuggingHandlers,
0000000000000000000000000000000000000000;;		enableContentionProfiling bool,
0000000000000000000000000000000000000000;;		runtime kubecontainer.Runtime,
0000000000000000000000000000000000000000;;		criHandler http.Handler) {
0000000000000000000000000000000000000000;;		glog.Infof("Starting to listen on %s:%d", address, port)
0000000000000000000000000000000000000000;;		handler := NewServer(host, resourceAnalyzer, auth, enableDebuggingHandlers, enableContentionProfiling, runtime, criHandler)
0000000000000000000000000000000000000000;;		s := &http.Server{
0000000000000000000000000000000000000000;;			Addr:           net.JoinHostPort(address.String(), strconv.FormatUint(uint64(port), 10)),
0000000000000000000000000000000000000000;;			Handler:        &handler,
0000000000000000000000000000000000000000;;			MaxHeaderBytes: 1 << 20,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tlsOptions != nil {
0000000000000000000000000000000000000000;;			s.TLSConfig = tlsOptions.Config
0000000000000000000000000000000000000000;;			// Passing empty strings as the cert and key files means no
0000000000000000000000000000000000000000;;			// cert/keys are specified and GetCertificate in the TLSConfig
0000000000000000000000000000000000000000;;			// should be called instead.
0000000000000000000000000000000000000000;;			glog.Fatal(s.ListenAndServeTLS(tlsOptions.CertFile, tlsOptions.KeyFile))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Fatal(s.ListenAndServe())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListenAndServeKubeletReadOnlyServer initializes a server to respond to HTTP network requests on the Kubelet.
0000000000000000000000000000000000000000;;	func ListenAndServeKubeletReadOnlyServer(host HostInterface, resourceAnalyzer stats.ResourceAnalyzer, address net.IP, port uint, runtime kubecontainer.Runtime) {
0000000000000000000000000000000000000000;;		glog.V(1).Infof("Starting to listen read-only on %s:%d", address, port)
0000000000000000000000000000000000000000;;		s := NewServer(host, resourceAnalyzer, nil, false, false, runtime, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server := &http.Server{
0000000000000000000000000000000000000000;;			Addr:           net.JoinHostPort(address.String(), strconv.FormatUint(uint64(port), 10)),
0000000000000000000000000000000000000000;;			Handler:        &s,
0000000000000000000000000000000000000000;;			MaxHeaderBytes: 1 << 20,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Fatal(server.ListenAndServe())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AuthInterface contains all methods required by the auth filters
0000000000000000000000000000000000000000;;	type AuthInterface interface {
0000000000000000000000000000000000000000;;		authenticator.Request
0000000000000000000000000000000000000000;;		authorizer.RequestAttributesGetter
0000000000000000000000000000000000000000;;		authorizer.Authorizer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HostInterface contains all the kubelet methods required by the server.
0000000000000000000000000000000000000000;;	// For testability.
0000000000000000000000000000000000000000;;	type HostInterface interface {
0000000000000000000000000000000000000000;;		GetContainerInfo(podFullName string, uid types.UID, containerName string, req *cadvisorapi.ContainerInfoRequest) (*cadvisorapi.ContainerInfo, error)
0000000000000000000000000000000000000000;;		GetContainerInfoV2(name string, options cadvisorapiv2.RequestOptions) (map[string]cadvisorapiv2.ContainerInfo, error)
0000000000000000000000000000000000000000;;		GetRawContainerInfo(containerName string, req *cadvisorapi.ContainerInfoRequest, subcontainers bool) (map[string]*cadvisorapi.ContainerInfo, error)
0000000000000000000000000000000000000000;;		GetCachedMachineInfo() (*cadvisorapi.MachineInfo, error)
0000000000000000000000000000000000000000;;		GetPods() []*v1.Pod
0000000000000000000000000000000000000000;;		GetRunningPods() ([]*v1.Pod, error)
0000000000000000000000000000000000000000;;		GetPodByName(namespace, name string) (*v1.Pod, bool)
0000000000000000000000000000000000000000;;		RunInContainer(name string, uid types.UID, container string, cmd []string) ([]byte, error)
0000000000000000000000000000000000000000;;		ExecInContainer(name string, uid types.UID, container string, cmd []string, in io.Reader, out, err io.WriteCloser, tty bool, resize <-chan remotecommand.TerminalSize, timeout time.Duration) error
0000000000000000000000000000000000000000;;		AttachContainer(name string, uid types.UID, container string, in io.Reader, out, err io.WriteCloser, tty bool, resize <-chan remotecommand.TerminalSize) error
0000000000000000000000000000000000000000;;		GetKubeletContainerLogs(podFullName, containerName string, logOptions *v1.PodLogOptions, stdout, stderr io.Writer) error
0000000000000000000000000000000000000000;;		ServeLogs(w http.ResponseWriter, req *http.Request)
0000000000000000000000000000000000000000;;		PortForward(name string, uid types.UID, port int32, stream io.ReadWriteCloser) error
0000000000000000000000000000000000000000;;		StreamingConnectionIdleTimeout() time.Duration
0000000000000000000000000000000000000000;;		ResyncInterval() time.Duration
0000000000000000000000000000000000000000;;		GetHostname() string
0000000000000000000000000000000000000000;;		GetNode() (*v1.Node, error)
0000000000000000000000000000000000000000;;		GetNodeConfig() cm.NodeConfig
0000000000000000000000000000000000000000;;		LatestLoopEntryTime() time.Time
0000000000000000000000000000000000000000;;		ImagesFsInfo() (cadvisorapiv2.FsInfo, error)
0000000000000000000000000000000000000000;;		RootFsInfo() (cadvisorapiv2.FsInfo, error)
0000000000000000000000000000000000000000;;		ListVolumesForPod(podUID types.UID) (map[string]volume.Volume, bool)
0000000000000000000000000000000000000000;;		GetExec(podFullName string, podUID types.UID, containerName string, cmd []string, streamOpts remotecommandserver.Options) (*url.URL, error)
0000000000000000000000000000000000000000;;		GetAttach(podFullName string, podUID types.UID, containerName string, streamOpts remotecommandserver.Options) (*url.URL, error)
0000000000000000000000000000000000000000;;		GetPortForward(podName, podNamespace string, podUID types.UID, portForwardOpts portforward.V4Options) (*url.URL, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServer initializes and configures a kubelet.Server object to handle HTTP requests.
0000000000000000000000000000000000000000;;	func NewServer(
0000000000000000000000000000000000000000;;		host HostInterface,
0000000000000000000000000000000000000000;;		resourceAnalyzer stats.ResourceAnalyzer,
0000000000000000000000000000000000000000;;		auth AuthInterface,
0000000000000000000000000000000000000000;;		enableDebuggingHandlers,
0000000000000000000000000000000000000000;;		enableContentionProfiling bool,
0000000000000000000000000000000000000000;;		runtime kubecontainer.Runtime,
0000000000000000000000000000000000000000;;		criHandler http.Handler) Server {
0000000000000000000000000000000000000000;;		server := Server{
0000000000000000000000000000000000000000;;			host:             host,
0000000000000000000000000000000000000000;;			resourceAnalyzer: resourceAnalyzer,
0000000000000000000000000000000000000000;;			auth:             auth,
0000000000000000000000000000000000000000;;			restfulCont:      &filteringContainer{Container: restful.NewContainer()},
0000000000000000000000000000000000000000;;			runtime:          runtime,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if auth != nil {
0000000000000000000000000000000000000000;;			server.InstallAuthFilter()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		server.InstallDefaultHandlers()
0000000000000000000000000000000000000000;;		if enableDebuggingHandlers {
0000000000000000000000000000000000000000;;			server.InstallDebuggingHandlers(criHandler)
0000000000000000000000000000000000000000;;			if enableContentionProfiling {
0000000000000000000000000000000000000000;;				goruntime.SetBlockProfileRate(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return server
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstallAuthFilter installs authentication filters with the restful Container.
0000000000000000000000000000000000000000;;	func (s *Server) InstallAuthFilter() {
0000000000000000000000000000000000000000;;		s.restfulCont.Filter(func(req *restful.Request, resp *restful.Response, chain *restful.FilterChain) {
0000000000000000000000000000000000000000;;			// Authenticate
0000000000000000000000000000000000000000;;			u, ok, err := s.auth.AuthenticateRequest(req.Request)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Unable to authenticate the request due to an error: %v", err)
0000000000000000000000000000000000000000;;				resp.WriteErrorString(http.StatusUnauthorized, "Unauthorized")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				resp.WriteErrorString(http.StatusUnauthorized, "Unauthorized")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get authorization attributes
0000000000000000000000000000000000000000;;			attrs := s.auth.GetRequestAttributes(u, req.Request)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Authorize
0000000000000000000000000000000000000000;;			authorized, _, err := s.auth.Authorize(attrs)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				msg := fmt.Sprintf("Authorization error (user=%s, verb=%s, resource=%s, subresource=%s)", u.GetName(), attrs.GetVerb(), attrs.GetResource(), attrs.GetSubresource())
0000000000000000000000000000000000000000;;				glog.Errorf(msg, err)
0000000000000000000000000000000000000000;;				resp.WriteErrorString(http.StatusInternalServerError, msg)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !authorized {
0000000000000000000000000000000000000000;;				msg := fmt.Sprintf("Forbidden (user=%s, verb=%s, resource=%s, subresource=%s)", u.GetName(), attrs.GetVerb(), attrs.GetResource(), attrs.GetSubresource())
0000000000000000000000000000000000000000;;				glog.V(2).Info(msg)
0000000000000000000000000000000000000000;;				resp.WriteErrorString(http.StatusForbidden, msg)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Continue
0000000000000000000000000000000000000000;;			chain.ProcessFilter(req, resp)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstallDefaultHandlers registers the default set of supported HTTP request
0000000000000000000000000000000000000000;;	// patterns with the restful Container.
0000000000000000000000000000000000000000;;	func (s *Server) InstallDefaultHandlers() {
0000000000000000000000000000000000000000;;		healthz.InstallHandler(s.restfulCont,
0000000000000000000000000000000000000000;;			healthz.PingHealthz,
0000000000000000000000000000000000000000;;			healthz.NamedCheck("syncloop", s.syncLoopHealthCheck),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		ws := new(restful.WebService)
0000000000000000000000000000000000000000;;		ws.
0000000000000000000000000000000000000000;;			Path("/pods").
0000000000000000000000000000000000000000;;			Produces(restful.MIME_JSON)
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("").
0000000000000000000000000000000000000000;;			To(s.getPods).
0000000000000000000000000000000000000000;;			Operation("getPods"))
0000000000000000000000000000000000000000;;		s.restfulCont.Add(ws)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.restfulCont.Add(stats.CreateHandlers(statsPath, s.host, s.resourceAnalyzer))
0000000000000000000000000000000000000000;;		s.restfulCont.Handle(metricsPath, prometheus.Handler())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ws = new(restful.WebService)
0000000000000000000000000000000000000000;;		ws.
0000000000000000000000000000000000000000;;			Path(specPath).
0000000000000000000000000000000000000000;;			Produces(restful.MIME_JSON)
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("").
0000000000000000000000000000000000000000;;			To(s.getSpec).
0000000000000000000000000000000000000000;;			Operation("getSpec").
0000000000000000000000000000000000000000;;			Writes(cadvisorapi.MachineInfo{}))
0000000000000000000000000000000000000000;;		s.restfulCont.Add(ws)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const pprofBasePath = "/debug/pprof/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstallDebuggingHandlers registers the HTTP request patterns that serve logs or run commands/containers
0000000000000000000000000000000000000000;;	func (s *Server) InstallDebuggingHandlers(criHandler http.Handler) {
0000000000000000000000000000000000000000;;		glog.Infof("Adding debug handlers to kubelet server.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ws := new(restful.WebService)
0000000000000000000000000000000000000000;;		ws.
0000000000000000000000000000000000000000;;			Path("/run")
0000000000000000000000000000000000000000;;		ws.Route(ws.POST("/{podNamespace}/{podID}/{containerName}").
0000000000000000000000000000000000000000;;			To(s.getRun).
0000000000000000000000000000000000000000;;			Operation("getRun"))
0000000000000000000000000000000000000000;;		ws.Route(ws.POST("/{podNamespace}/{podID}/{uid}/{containerName}").
0000000000000000000000000000000000000000;;			To(s.getRun).
0000000000000000000000000000000000000000;;			Operation("getRun"))
0000000000000000000000000000000000000000;;		s.restfulCont.Add(ws)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ws = new(restful.WebService)
0000000000000000000000000000000000000000;;		ws.
0000000000000000000000000000000000000000;;			Path("/exec")
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("/{podNamespace}/{podID}/{containerName}").
0000000000000000000000000000000000000000;;			To(s.getExec).
0000000000000000000000000000000000000000;;			Operation("getExec"))
0000000000000000000000000000000000000000;;		ws.Route(ws.POST("/{podNamespace}/{podID}/{containerName}").
0000000000000000000000000000000000000000;;			To(s.getExec).
0000000000000000000000000000000000000000;;			Operation("getExec"))
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("/{podNamespace}/{podID}/{uid}/{containerName}").
0000000000000000000000000000000000000000;;			To(s.getExec).
0000000000000000000000000000000000000000;;			Operation("getExec"))
0000000000000000000000000000000000000000;;		ws.Route(ws.POST("/{podNamespace}/{podID}/{uid}/{containerName}").
0000000000000000000000000000000000000000;;			To(s.getExec).
0000000000000000000000000000000000000000;;			Operation("getExec"))
0000000000000000000000000000000000000000;;		s.restfulCont.Add(ws)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ws = new(restful.WebService)
0000000000000000000000000000000000000000;;		ws.
0000000000000000000000000000000000000000;;			Path("/attach")
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("/{podNamespace}/{podID}/{containerName}").
0000000000000000000000000000000000000000;;			To(s.getAttach).
0000000000000000000000000000000000000000;;			Operation("getAttach"))
0000000000000000000000000000000000000000;;		ws.Route(ws.POST("/{podNamespace}/{podID}/{containerName}").
0000000000000000000000000000000000000000;;			To(s.getAttach).
0000000000000000000000000000000000000000;;			Operation("getAttach"))
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("/{podNamespace}/{podID}/{uid}/{containerName}").
0000000000000000000000000000000000000000;;			To(s.getAttach).
0000000000000000000000000000000000000000;;			Operation("getAttach"))
0000000000000000000000000000000000000000;;		ws.Route(ws.POST("/{podNamespace}/{podID}/{uid}/{containerName}").
0000000000000000000000000000000000000000;;			To(s.getAttach).
0000000000000000000000000000000000000000;;			Operation("getAttach"))
0000000000000000000000000000000000000000;;		s.restfulCont.Add(ws)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ws = new(restful.WebService)
0000000000000000000000000000000000000000;;		ws.
0000000000000000000000000000000000000000;;			Path("/portForward")
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("/{podNamespace}/{podID}").
0000000000000000000000000000000000000000;;			To(s.getPortForward).
0000000000000000000000000000000000000000;;			Operation("getPortForward"))
0000000000000000000000000000000000000000;;		ws.Route(ws.POST("/{podNamespace}/{podID}").
0000000000000000000000000000000000000000;;			To(s.getPortForward).
0000000000000000000000000000000000000000;;			Operation("getPortForward"))
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("/{podNamespace}/{podID}/{uid}").
0000000000000000000000000000000000000000;;			To(s.getPortForward).
0000000000000000000000000000000000000000;;			Operation("getPortForward"))
0000000000000000000000000000000000000000;;		ws.Route(ws.POST("/{podNamespace}/{podID}/{uid}").
0000000000000000000000000000000000000000;;			To(s.getPortForward).
0000000000000000000000000000000000000000;;			Operation("getPortForward"))
0000000000000000000000000000000000000000;;		s.restfulCont.Add(ws)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ws = new(restful.WebService)
0000000000000000000000000000000000000000;;		ws.
0000000000000000000000000000000000000000;;			Path(logsPath)
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("").
0000000000000000000000000000000000000000;;			To(s.getLogs).
0000000000000000000000000000000000000000;;			Operation("getLogs"))
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("/{logpath:*}").
0000000000000000000000000000000000000000;;			To(s.getLogs).
0000000000000000000000000000000000000000;;			Operation("getLogs").
0000000000000000000000000000000000000000;;			Param(ws.PathParameter("logpath", "path to the log").DataType("string")))
0000000000000000000000000000000000000000;;		s.restfulCont.Add(ws)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ws = new(restful.WebService)
0000000000000000000000000000000000000000;;		ws.
0000000000000000000000000000000000000000;;			Path("/containerLogs")
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("/{podNamespace}/{podID}/{containerName}").
0000000000000000000000000000000000000000;;			To(s.getContainerLogs).
0000000000000000000000000000000000000000;;			Operation("getContainerLogs"))
0000000000000000000000000000000000000000;;		s.restfulCont.Add(ws)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configz.InstallHandler(s.restfulCont)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handlePprofEndpoint := func(req *restful.Request, resp *restful.Response) {
0000000000000000000000000000000000000000;;			name := strings.TrimPrefix(req.Request.URL.Path, pprofBasePath)
0000000000000000000000000000000000000000;;			switch name {
0000000000000000000000000000000000000000;;			case "profile":
0000000000000000000000000000000000000000;;				pprof.Profile(resp, req.Request)
0000000000000000000000000000000000000000;;			case "symbol":
0000000000000000000000000000000000000000;;				pprof.Symbol(resp, req.Request)
0000000000000000000000000000000000000000;;			case "cmdline":
0000000000000000000000000000000000000000;;				pprof.Cmdline(resp, req.Request)
0000000000000000000000000000000000000000;;			case "trace":
0000000000000000000000000000000000000000;;				pprof.Trace(resp, req.Request)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				pprof.Index(resp, req.Request)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup pprof handlers.
0000000000000000000000000000000000000000;;		ws = new(restful.WebService).Path(pprofBasePath)
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("/{subpath:*}").To(func(req *restful.Request, resp *restful.Response) {
0000000000000000000000000000000000000000;;			handlePprofEndpoint(req, resp)
0000000000000000000000000000000000000000;;		})).Doc("pprof endpoint")
0000000000000000000000000000000000000000;;		s.restfulCont.Add(ws)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The /runningpods endpoint is used for testing only.
0000000000000000000000000000000000000000;;		ws = new(restful.WebService)
0000000000000000000000000000000000000000;;		ws.
0000000000000000000000000000000000000000;;			Path("/runningpods/").
0000000000000000000000000000000000000000;;			Produces(restful.MIME_JSON)
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("").
0000000000000000000000000000000000000000;;			To(s.getRunningPods).
0000000000000000000000000000000000000000;;			Operation("getRunningPods"))
0000000000000000000000000000000000000000;;		s.restfulCont.Add(ws)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if criHandler != nil {
0000000000000000000000000000000000000000;;			s.restfulCont.Handle("/cri/", criHandler)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks if kubelet's sync loop  that updates containers is working.
0000000000000000000000000000000000000000;;	func (s *Server) syncLoopHealthCheck(req *http.Request) error {
0000000000000000000000000000000000000000;;		duration := s.host.ResyncInterval() * 2
0000000000000000000000000000000000000000;;		minDuration := time.Minute * 5
0000000000000000000000000000000000000000;;		if duration < minDuration {
0000000000000000000000000000000000000000;;			duration = minDuration
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		enterLoopTime := s.host.LatestLoopEntryTime()
0000000000000000000000000000000000000000;;		if !enterLoopTime.IsZero() && time.Now().After(enterLoopTime.Add(duration)) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("sync Loop took longer than expected")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getContainerLogs handles containerLogs request against the Kubelet
0000000000000000000000000000000000000000;;	func (s *Server) getContainerLogs(request *restful.Request, response *restful.Response) {
0000000000000000000000000000000000000000;;		podNamespace := request.PathParameter("podNamespace")
0000000000000000000000000000000000000000;;		podID := request.PathParameter("podID")
0000000000000000000000000000000000000000;;		containerName := request.PathParameter("containerName")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(podID) == 0 {
0000000000000000000000000000000000000000;;			// TODO: Why return JSON when the rest return plaintext errors?
0000000000000000000000000000000000000000;;			// TODO: Why return plaintext errors?
0000000000000000000000000000000000000000;;			response.WriteError(http.StatusBadRequest, fmt.Errorf(`{"message": "Missing podID."}`))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(containerName) == 0 {
0000000000000000000000000000000000000000;;			// TODO: Why return JSON when the rest return plaintext errors?
0000000000000000000000000000000000000000;;			response.WriteError(http.StatusBadRequest, fmt.Errorf(`{"message": "Missing container name."}`))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(podNamespace) == 0 {
0000000000000000000000000000000000000000;;			// TODO: Why return JSON when the rest return plaintext errors?
0000000000000000000000000000000000000000;;			response.WriteError(http.StatusBadRequest, fmt.Errorf(`{"message": "Missing podNamespace."}`))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		query := request.Request.URL.Query()
0000000000000000000000000000000000000000;;		// backwards compatibility for the "tail" query parameter
0000000000000000000000000000000000000000;;		if tail := request.QueryParameter("tail"); len(tail) > 0 {
0000000000000000000000000000000000000000;;			query["tailLines"] = []string{tail}
0000000000000000000000000000000000000000;;			// "all" is the same as omitting tail
0000000000000000000000000000000000000000;;			if tail == "all" {
0000000000000000000000000000000000000000;;				delete(query, "tailLines")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// container logs on the kubelet are locked to the v1 API version of PodLogOptions
0000000000000000000000000000000000000000;;		logOptions := &v1.PodLogOptions{}
0000000000000000000000000000000000000000;;		if err := api.ParameterCodec.DecodeParameters(query, v1.SchemeGroupVersion, logOptions); err != nil {
0000000000000000000000000000000000000000;;			response.WriteError(http.StatusBadRequest, fmt.Errorf(`{"message": "Unable to decode query."}`))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logOptions.TypeMeta = metav1.TypeMeta{}
0000000000000000000000000000000000000000;;		if errs := validation.ValidatePodLogOptions(logOptions); len(errs) > 0 {
0000000000000000000000000000000000000000;;			response.WriteError(apierrs.StatusUnprocessableEntity, fmt.Errorf(`{"message": "Invalid request."}`))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod, ok := s.host.GetPodByName(podNamespace, podID)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			response.WriteError(http.StatusNotFound, fmt.Errorf("pod %q does not exist\n", podID))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Check if containerName is valid.
0000000000000000000000000000000000000000;;		containerExists := false
0000000000000000000000000000000000000000;;		for _, container := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			if container.Name == containerName {
0000000000000000000000000000000000000000;;				containerExists = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !containerExists {
0000000000000000000000000000000000000000;;			for _, container := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;				if container.Name == containerName {
0000000000000000000000000000000000000000;;					containerExists = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !containerExists {
0000000000000000000000000000000000000000;;			response.WriteError(http.StatusNotFound, fmt.Errorf("container %q not found in pod %q\n", containerName, podID))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok := response.ResponseWriter.(http.Flusher); !ok {
0000000000000000000000000000000000000000;;			response.WriteError(http.StatusInternalServerError, fmt.Errorf("unable to convert %v into http.Flusher, cannot show logs\n", reflect.TypeOf(response)))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fw := flushwriter.Wrap(response.ResponseWriter)
0000000000000000000000000000000000000000;;		// Byte limit logic is already implemented in kuberuntime. However, we still need this for
0000000000000000000000000000000000000000;;		// old runtime integration.
0000000000000000000000000000000000000000;;		// TODO(random-liu): Remove this once we switch to CRI integration.
0000000000000000000000000000000000000000;;		if logOptions.LimitBytes != nil {
0000000000000000000000000000000000000000;;			fw = limitwriter.New(fw, *logOptions.LimitBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		response.Header().Set("Transfer-Encoding", "chunked")
0000000000000000000000000000000000000000;;		if err := s.host.GetKubeletContainerLogs(kubecontainer.GetPodFullName(pod), containerName, logOptions, fw, fw); err != nil {
0000000000000000000000000000000000000000;;			if err != limitwriter.ErrMaximumWrite {
0000000000000000000000000000000000000000;;				response.WriteError(http.StatusBadRequest, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encodePods creates an v1.PodList object from pods and returns the encoded
0000000000000000000000000000000000000000;;	// PodList.
0000000000000000000000000000000000000000;;	func encodePods(pods []*v1.Pod) (data []byte, err error) {
0000000000000000000000000000000000000000;;		podList := new(v1.PodList)
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			podList.Items = append(podList.Items, *pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: this needs to be parameterized to the kubelet, not hardcoded. Depends on Kubelet
0000000000000000000000000000000000000000;;		//   as API server refactor.
0000000000000000000000000000000000000000;;		// TODO: Locked to v1, needs to be made generic
0000000000000000000000000000000000000000;;		codec := api.Codecs.LegacyCodec(schema.GroupVersion{Group: v1.GroupName, Version: "v1"})
0000000000000000000000000000000000000000;;		return runtime.Encode(codec, podList)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPods returns a list of pods bound to the Kubelet and their spec.
0000000000000000000000000000000000000000;;	func (s *Server) getPods(request *restful.Request, response *restful.Response) {
0000000000000000000000000000000000000000;;		pods := s.host.GetPods()
0000000000000000000000000000000000000000;;		data, err := encodePods(pods)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			response.WriteError(http.StatusInternalServerError, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		writeJsonResponse(response, data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getRunningPods returns a list of pods running on Kubelet. The list is
0000000000000000000000000000000000000000;;	// provided by the container runtime, and is different from the list returned
0000000000000000000000000000000000000000;;	// by getPods, which is a set of desired pods to run.
0000000000000000000000000000000000000000;;	func (s *Server) getRunningPods(request *restful.Request, response *restful.Response) {
0000000000000000000000000000000000000000;;		pods, err := s.host.GetRunningPods()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			response.WriteError(http.StatusInternalServerError, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data, err := encodePods(pods)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			response.WriteError(http.StatusInternalServerError, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		writeJsonResponse(response, data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getLogs handles logs requests against the Kubelet.
0000000000000000000000000000000000000000;;	func (s *Server) getLogs(request *restful.Request, response *restful.Response) {
0000000000000000000000000000000000000000;;		s.host.ServeLogs(response, request.Request)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getSpec handles spec requests against the Kubelet.
0000000000000000000000000000000000000000;;	func (s *Server) getSpec(request *restful.Request, response *restful.Response) {
0000000000000000000000000000000000000000;;		info, err := s.host.GetCachedMachineInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			response.WriteError(http.StatusInternalServerError, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		response.WriteEntity(info)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type execRequestParams struct {
0000000000000000000000000000000000000000;;		podNamespace  string
0000000000000000000000000000000000000000;;		podName       string
0000000000000000000000000000000000000000;;		podUID        types.UID
0000000000000000000000000000000000000000;;		containerName string
0000000000000000000000000000000000000000;;		cmd           []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getExecRequestParams(req *restful.Request) execRequestParams {
0000000000000000000000000000000000000000;;		return execRequestParams{
0000000000000000000000000000000000000000;;			podNamespace:  req.PathParameter("podNamespace"),
0000000000000000000000000000000000000000;;			podName:       req.PathParameter("podID"),
0000000000000000000000000000000000000000;;			podUID:        types.UID(req.PathParameter("uid")),
0000000000000000000000000000000000000000;;			containerName: req.PathParameter("containerName"),
0000000000000000000000000000000000000000;;			cmd:           req.Request.URL.Query()[api.ExecCommandParamm],
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type portForwardRequestParams struct {
0000000000000000000000000000000000000000;;		podNamespace string
0000000000000000000000000000000000000000;;		podName      string
0000000000000000000000000000000000000000;;		podUID       types.UID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPortForwardRequestParams(req *restful.Request) portForwardRequestParams {
0000000000000000000000000000000000000000;;		return portForwardRequestParams{
0000000000000000000000000000000000000000;;			podNamespace: req.PathParameter("podNamespace"),
0000000000000000000000000000000000000000;;			podName:      req.PathParameter("podID"),
0000000000000000000000000000000000000000;;			podUID:       types.UID(req.PathParameter("uid")),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getAttach handles requests to attach to a container.
0000000000000000000000000000000000000000;;	func (s *Server) getAttach(request *restful.Request, response *restful.Response) {
0000000000000000000000000000000000000000;;		params := getExecRequestParams(request)
0000000000000000000000000000000000000000;;		streamOpts, err := remotecommandserver.NewOptions(request.Request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			response.WriteError(http.StatusBadRequest, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod, ok := s.host.GetPodByName(params.podNamespace, params.podName)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			response.WriteError(http.StatusNotFound, fmt.Errorf("pod does not exist"))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podFullName := kubecontainer.GetPodFullName(pod)
0000000000000000000000000000000000000000;;		redirect, err := s.host.GetAttach(podFullName, params.podUID, params.containerName, *streamOpts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			streaming.WriteError(err, response.ResponseWriter)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if redirect != nil {
0000000000000000000000000000000000000000;;			http.Redirect(response.ResponseWriter, request.Request, redirect.String(), http.StatusFound)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		remotecommandserver.ServeAttach(response.ResponseWriter,
0000000000000000000000000000000000000000;;			request.Request,
0000000000000000000000000000000000000000;;			s.host,
0000000000000000000000000000000000000000;;			podFullName,
0000000000000000000000000000000000000000;;			params.podUID,
0000000000000000000000000000000000000000;;			params.containerName,
0000000000000000000000000000000000000000;;			streamOpts,
0000000000000000000000000000000000000000;;			s.host.StreamingConnectionIdleTimeout(),
0000000000000000000000000000000000000000;;			remotecommandconsts.DefaultStreamCreationTimeout,
0000000000000000000000000000000000000000;;			remotecommandconsts.SupportedStreamingProtocols)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getExec handles requests to run a command inside a container.
0000000000000000000000000000000000000000;;	func (s *Server) getExec(request *restful.Request, response *restful.Response) {
0000000000000000000000000000000000000000;;		params := getExecRequestParams(request)
0000000000000000000000000000000000000000;;		streamOpts, err := remotecommandserver.NewOptions(request.Request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			response.WriteError(http.StatusBadRequest, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod, ok := s.host.GetPodByName(params.podNamespace, params.podName)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			response.WriteError(http.StatusNotFound, fmt.Errorf("pod does not exist"))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podFullName := kubecontainer.GetPodFullName(pod)
0000000000000000000000000000000000000000;;		redirect, err := s.host.GetExec(podFullName, params.podUID, params.containerName, params.cmd, *streamOpts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			streaming.WriteError(err, response.ResponseWriter)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if redirect != nil {
0000000000000000000000000000000000000000;;			http.Redirect(response.ResponseWriter, request.Request, redirect.String(), http.StatusFound)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		remotecommandserver.ServeExec(response.ResponseWriter,
0000000000000000000000000000000000000000;;			request.Request,
0000000000000000000000000000000000000000;;			s.host,
0000000000000000000000000000000000000000;;			podFullName,
0000000000000000000000000000000000000000;;			params.podUID,
0000000000000000000000000000000000000000;;			params.containerName,
0000000000000000000000000000000000000000;;			params.cmd,
0000000000000000000000000000000000000000;;			streamOpts,
0000000000000000000000000000000000000000;;			s.host.StreamingConnectionIdleTimeout(),
0000000000000000000000000000000000000000;;			remotecommandconsts.DefaultStreamCreationTimeout,
0000000000000000000000000000000000000000;;			remotecommandconsts.SupportedStreamingProtocols)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getRun handles requests to run a command inside a container.
0000000000000000000000000000000000000000;;	func (s *Server) getRun(request *restful.Request, response *restful.Response) {
0000000000000000000000000000000000000000;;		params := getExecRequestParams(request)
0000000000000000000000000000000000000000;;		pod, ok := s.host.GetPodByName(params.podNamespace, params.podName)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			response.WriteError(http.StatusNotFound, fmt.Errorf("pod does not exist"))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For legacy reasons, run uses different query param than exec.
0000000000000000000000000000000000000000;;		params.cmd = strings.Split(request.QueryParameter("cmd"), " ")
0000000000000000000000000000000000000000;;		data, err := s.host.RunInContainer(kubecontainer.GetPodFullName(pod), params.podUID, params.containerName, params.cmd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			response.WriteError(http.StatusInternalServerError, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		writeJsonResponse(response, data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Derived from go-restful writeJSON.
0000000000000000000000000000000000000000;;	func writeJsonResponse(response *restful.Response, data []byte) {
0000000000000000000000000000000000000000;;		if data == nil {
0000000000000000000000000000000000000000;;			response.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;			// do not write a nil representation
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		response.Header().Set(restful.HEADER_ContentType, restful.MIME_JSON)
0000000000000000000000000000000000000000;;		response.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;		if _, err := response.Write(data); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error writing response: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPortForward handles a new restful port forward request. It determines the
0000000000000000000000000000000000000000;;	// pod name and uid and then calls ServePortForward.
0000000000000000000000000000000000000000;;	func (s *Server) getPortForward(request *restful.Request, response *restful.Response) {
0000000000000000000000000000000000000000;;		params := getPortForwardRequestParams(request)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		portForwardOptions, err := portforward.NewV4Options(request.Request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			response.WriteError(http.StatusBadRequest, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod, ok := s.host.GetPodByName(params.podNamespace, params.podName)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			response.WriteError(http.StatusNotFound, fmt.Errorf("pod does not exist"))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(params.podUID) > 0 && pod.UID != params.podUID {
0000000000000000000000000000000000000000;;			response.WriteError(http.StatusNotFound, fmt.Errorf("pod not found"))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		redirect, err := s.host.GetPortForward(pod.Name, pod.Namespace, pod.UID, *portForwardOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			streaming.WriteError(err, response.ResponseWriter)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if redirect != nil {
0000000000000000000000000000000000000000;;			http.Redirect(response.ResponseWriter, request.Request, redirect.String(), http.StatusFound)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		portforward.ServePortForward(response.ResponseWriter,
0000000000000000000000000000000000000000;;			request.Request,
0000000000000000000000000000000000000000;;			s.host,
0000000000000000000000000000000000000000;;			kubecontainer.GetPodFullName(pod),
0000000000000000000000000000000000000000;;			params.podUID,
0000000000000000000000000000000000000000;;			portForwardOptions,
0000000000000000000000000000000000000000;;			s.host.StreamingConnectionIdleTimeout(),
0000000000000000000000000000000000000000;;			remotecommandconsts.DefaultStreamCreationTimeout,
0000000000000000000000000000000000000000;;			portforward.SupportedProtocols)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServeHTTP responds to HTTP requests on the Kubelet.
0000000000000000000000000000000000000000;;	func (s *Server) ServeHTTP(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		defer httplog.NewLogged(req, &w).StacktraceWhen(
0000000000000000000000000000000000000000;;			httplog.StatusIsNot(
0000000000000000000000000000000000000000;;				http.StatusOK,
0000000000000000000000000000000000000000;;				http.StatusFound,
0000000000000000000000000000000000000000;;				http.StatusMovedPermanently,
0000000000000000000000000000000000000000;;				http.StatusTemporaryRedirect,
0000000000000000000000000000000000000000;;				http.StatusBadRequest,
0000000000000000000000000000000000000000;;				http.StatusNotFound,
0000000000000000000000000000000000000000;;				http.StatusSwitchingProtocols,
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;		).Log()
0000000000000000000000000000000000000000;;		s.restfulCont.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;	}
