0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
da95e236fce3b98225926b2d9226bbdb6ec36842;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package remotecommand
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/httplog"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/wsstream"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		stdinChannel = iota
0000000000000000000000000000000000000000;;		stdoutChannel
0000000000000000000000000000000000000000;;		stderrChannel
0000000000000000000000000000000000000000;;		errorChannel
0000000000000000000000000000000000000000;;		resizeChannel
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		preV4BinaryWebsocketProtocol = wsstream.ChannelWebSocketProtocol
0000000000000000000000000000000000000000;;		preV4Base64WebsocketProtocol = wsstream.Base64ChannelWebSocketProtocol
0000000000000000000000000000000000000000;;		v4BinaryWebsocketProtocol    = "v4." + wsstream.ChannelWebSocketProtocol
0000000000000000000000000000000000000000;;		v4Base64WebsocketProtocol    = "v4." + wsstream.Base64ChannelWebSocketProtocol
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createChannels returns the standard channel types for a shell connection (STDIN 0, STDOUT 1, STDERR 2)
0000000000000000000000000000000000000000;;	// along with the approximate duplex value. It also creates the error (3) and resize (4) channels.
0000000000000000000000000000000000000000;;	func createChannels(opts *Options) []wsstream.ChannelType {
0000000000000000000000000000000000000000;;		// open the requested channels, and always open the error channel
0000000000000000000000000000000000000000;;		channels := make([]wsstream.ChannelType, 5)
0000000000000000000000000000000000000000;;		channels[stdinChannel] = readChannel(opts.Stdin)
0000000000000000000000000000000000000000;;		channels[stdoutChannel] = writeChannel(opts.Stdout)
0000000000000000000000000000000000000000;;		channels[stderrChannel] = writeChannel(opts.Stderr)
0000000000000000000000000000000000000000;;		channels[errorChannel] = wsstream.WriteChannel
0000000000000000000000000000000000000000;;		channels[resizeChannel] = wsstream.ReadChannel
0000000000000000000000000000000000000000;;		return channels
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readChannel returns wsstream.ReadChannel if real is true, or wsstream.IgnoreChannel.
0000000000000000000000000000000000000000;;	func readChannel(real bool) wsstream.ChannelType {
0000000000000000000000000000000000000000;;		if real {
0000000000000000000000000000000000000000;;			return wsstream.ReadChannel
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return wsstream.IgnoreChannel
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeChannel returns wsstream.WriteChannel if real is true, or wsstream.IgnoreChannel.
0000000000000000000000000000000000000000;;	func writeChannel(real bool) wsstream.ChannelType {
0000000000000000000000000000000000000000;;		if real {
0000000000000000000000000000000000000000;;			return wsstream.WriteChannel
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return wsstream.IgnoreChannel
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createWebSocketStreams returns a context containing the websocket connection and
0000000000000000000000000000000000000000;;	// streams needed to perform an exec or an attach.
0000000000000000000000000000000000000000;;	func createWebSocketStreams(req *http.Request, w http.ResponseWriter, opts *Options, idleTimeout time.Duration) (*context, bool) {
0000000000000000000000000000000000000000;;		channels := createChannels(opts)
0000000000000000000000000000000000000000;;		conn := wsstream.NewConn(map[string]wsstream.ChannelProtocolConfig{
0000000000000000000000000000000000000000;;			"": {
0000000000000000000000000000000000000000;;				Binary:   true,
0000000000000000000000000000000000000000;;				Channels: channels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			preV4BinaryWebsocketProtocol: {
0000000000000000000000000000000000000000;;				Binary:   true,
0000000000000000000000000000000000000000;;				Channels: channels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			preV4Base64WebsocketProtocol: {
0000000000000000000000000000000000000000;;				Binary:   false,
0000000000000000000000000000000000000000;;				Channels: channels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			v4BinaryWebsocketProtocol: {
0000000000000000000000000000000000000000;;				Binary:   true,
0000000000000000000000000000000000000000;;				Channels: channels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			v4Base64WebsocketProtocol: {
0000000000000000000000000000000000000000;;				Binary:   false,
0000000000000000000000000000000000000000;;				Channels: channels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		conn.SetIdleTimeout(idleTimeout)
0000000000000000000000000000000000000000;;		negotiatedProtocol, streams, err := conn.Open(httplog.Unlogged(w), req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Unable to upgrade websocket connection: %v", err))
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Send an empty message to the lowest writable channel to notify the client the connection is established
0000000000000000000000000000000000000000;;		// TODO: make generic to SPDY and WebSockets and do it outside of this method?
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case opts.Stdout:
0000000000000000000000000000000000000000;;			streams[stdoutChannel].Write([]byte{})
0000000000000000000000000000000000000000;;		case opts.Stderr:
0000000000000000000000000000000000000000;;			streams[stderrChannel].Write([]byte{})
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			streams[errorChannel].Write([]byte{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx := &context{
0000000000000000000000000000000000000000;;			conn:         conn,
0000000000000000000000000000000000000000;;			stdinStream:  streams[stdinChannel],
0000000000000000000000000000000000000000;;			stdoutStream: streams[stdoutChannel],
0000000000000000000000000000000000000000;;			stderrStream: streams[stderrChannel],
0000000000000000000000000000000000000000;;			tty:          opts.TTY,
0000000000000000000000000000000000000000;;			resizeStream: streams[resizeChannel],
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch negotiatedProtocol {
0000000000000000000000000000000000000000;;		case v4BinaryWebsocketProtocol, v4Base64WebsocketProtocol:
0000000000000000000000000000000000000000;;			ctx.writeStatus = v4WriteStatusFunc(streams[errorChannel])
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			ctx.writeStatus = v1WriteStatusFunc(streams[errorChannel])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ctx, true
0000000000000000000000000000000000000000;;	}
