0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
da95e236fce3b98225926b2d9226bbdb6ec36842;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package remotecommand
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream/spdy"
0000000000000000000000000000000000000000;;		remotecommandconsts "k8s.io/apimachinery/pkg/util/remotecommand"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/wsstream"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/remotecommand"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Options contains details about which streams are required for
0000000000000000000000000000000000000000;;	// remote command execution.
0000000000000000000000000000000000000000;;	type Options struct {
0000000000000000000000000000000000000000;;		Stdin  bool
0000000000000000000000000000000000000000;;		Stdout bool
0000000000000000000000000000000000000000;;		Stderr bool
0000000000000000000000000000000000000000;;		TTY    bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewOptions creates a new Options from the Request.
0000000000000000000000000000000000000000;;	func NewOptions(req *http.Request) (*Options, error) {
0000000000000000000000000000000000000000;;		tty := req.FormValue(api.ExecTTYParam) == "1"
0000000000000000000000000000000000000000;;		stdin := req.FormValue(api.ExecStdinParam) == "1"
0000000000000000000000000000000000000000;;		stdout := req.FormValue(api.ExecStdoutParam) == "1"
0000000000000000000000000000000000000000;;		stderr := req.FormValue(api.ExecStderrParam) == "1"
0000000000000000000000000000000000000000;;		if tty && stderr {
0000000000000000000000000000000000000000;;			// TODO: make this an error before we reach this method
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Access to exec with tty and stderr is not supported, bypassing stderr")
0000000000000000000000000000000000000000;;			stderr = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !stdin && !stdout && !stderr {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("you must specify at least 1 of stdin, stdout, stderr")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Options{
0000000000000000000000000000000000000000;;			Stdin:  stdin,
0000000000000000000000000000000000000000;;			Stdout: stdout,
0000000000000000000000000000000000000000;;			Stderr: stderr,
0000000000000000000000000000000000000000;;			TTY:    tty,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// context contains the connection and streams used when
0000000000000000000000000000000000000000;;	// forwarding an attach or execute session into a container.
0000000000000000000000000000000000000000;;	type context struct {
0000000000000000000000000000000000000000;;		conn         io.Closer
0000000000000000000000000000000000000000;;		stdinStream  io.ReadCloser
0000000000000000000000000000000000000000;;		stdoutStream io.WriteCloser
0000000000000000000000000000000000000000;;		stderrStream io.WriteCloser
0000000000000000000000000000000000000000;;		writeStatus  func(status *apierrors.StatusError) error
0000000000000000000000000000000000000000;;		resizeStream io.ReadCloser
0000000000000000000000000000000000000000;;		resizeChan   chan remotecommand.TerminalSize
0000000000000000000000000000000000000000;;		tty          bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// streamAndReply holds both a Stream and a channel that is closed when the stream's reply frame is
0000000000000000000000000000000000000000;;	// enqueued. Consumers can wait for replySent to be closed prior to proceeding, to ensure that the
0000000000000000000000000000000000000000;;	// replyFrame is enqueued before the connection's goaway frame is sent (e.g. if a stream was
0000000000000000000000000000000000000000;;	// received and right after, the connection gets closed).
0000000000000000000000000000000000000000;;	type streamAndReply struct {
0000000000000000000000000000000000000000;;		httpstream.Stream
0000000000000000000000000000000000000000;;		replySent <-chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitStreamReply waits until either replySent or stop is closed. If replySent is closed, it sends
0000000000000000000000000000000000000000;;	// an empty struct to the notify channel.
0000000000000000000000000000000000000000;;	func waitStreamReply(replySent <-chan struct{}, notify chan<- struct{}, stop <-chan struct{}) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-replySent:
0000000000000000000000000000000000000000;;			notify <- struct{}{}
0000000000000000000000000000000000000000;;		case <-stop:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createStreams(req *http.Request, w http.ResponseWriter, opts *Options, supportedStreamProtocols []string, idleTimeout, streamCreationTimeout time.Duration) (*context, bool) {
0000000000000000000000000000000000000000;;		var ctx *context
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		if wsstream.IsWebSocketRequest(req) {
0000000000000000000000000000000000000000;;			ctx, ok = createWebSocketStreams(req, w, opts, idleTimeout)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ctx, ok = createHttpStreamStreams(req, w, opts, supportedStreamProtocols, idleTimeout, streamCreationTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ctx.resizeStream != nil {
0000000000000000000000000000000000000000;;			ctx.resizeChan = make(chan remotecommand.TerminalSize)
0000000000000000000000000000000000000000;;			go handleResizeEvents(ctx.resizeStream, ctx.resizeChan)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ctx, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createHttpStreamStreams(req *http.Request, w http.ResponseWriter, opts *Options, supportedStreamProtocols []string, idleTimeout, streamCreationTimeout time.Duration) (*context, bool) {
0000000000000000000000000000000000000000;;		protocol, err := httpstream.Handshake(req, w, supportedStreamProtocols)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			w.WriteHeader(http.StatusBadRequest)
0000000000000000000000000000000000000000;;			fmt.Fprint(w, err.Error())
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		streamCh := make(chan streamAndReply)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		upgrader := spdy.NewResponseUpgrader()
0000000000000000000000000000000000000000;;		conn := upgrader.UpgradeResponse(w, req, func(stream httpstream.Stream, replySent <-chan struct{}) error {
0000000000000000000000000000000000000000;;			streamCh <- streamAndReply{Stream: stream, replySent: replySent}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		// from this point on, we can no longer call methods on response
0000000000000000000000000000000000000000;;		if conn == nil {
0000000000000000000000000000000000000000;;			// The upgrader is responsible for notifying the client of any errors that
0000000000000000000000000000000000000000;;			// occurred during upgrading. All we can do is return here at this point
0000000000000000000000000000000000000000;;			// if we weren't successful in upgrading.
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn.SetIdleTimeout(idleTimeout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var handler protocolHandler
0000000000000000000000000000000000000000;;		switch protocol {
0000000000000000000000000000000000000000;;		case remotecommandconsts.StreamProtocolV4Name:
0000000000000000000000000000000000000000;;			handler = &v4ProtocolHandler{}
0000000000000000000000000000000000000000;;		case remotecommandconsts.StreamProtocolV3Name:
0000000000000000000000000000000000000000;;			handler = &v3ProtocolHandler{}
0000000000000000000000000000000000000000;;		case remotecommandconsts.StreamProtocolV2Name:
0000000000000000000000000000000000000000;;			handler = &v2ProtocolHandler{}
0000000000000000000000000000000000000000;;		case "":
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Client did not request protocol negotiaion. Falling back to %q", remotecommandconsts.StreamProtocolV1Name)
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case remotecommandconsts.StreamProtocolV1Name:
0000000000000000000000000000000000000000;;			handler = &v1ProtocolHandler{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// count the streams client asked for, starting with 1
0000000000000000000000000000000000000000;;		expectedStreams := 1
0000000000000000000000000000000000000000;;		if opts.Stdin {
0000000000000000000000000000000000000000;;			expectedStreams++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.Stdout {
0000000000000000000000000000000000000000;;			expectedStreams++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.Stderr {
0000000000000000000000000000000000000000;;			expectedStreams++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.TTY && handler.supportsTerminalResizing() {
0000000000000000000000000000000000000000;;			expectedStreams++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expired := time.NewTimer(streamCreationTimeout)
0000000000000000000000000000000000000000;;		defer expired.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx, err := handler.waitForStreams(streamCh, expectedStreams, expired.C)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(err)
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx.conn = conn
0000000000000000000000000000000000000000;;		ctx.tty = opts.TTY
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ctx, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type protocolHandler interface {
0000000000000000000000000000000000000000;;		// waitForStreams waits for the expected streams or a timeout, returning a
0000000000000000000000000000000000000000;;		// remoteCommandContext if all the streams were received, or an error if not.
0000000000000000000000000000000000000000;;		waitForStreams(streams <-chan streamAndReply, expectedStreams int, expired <-chan time.Time) (*context, error)
0000000000000000000000000000000000000000;;		// supportsTerminalResizing returns true if the protocol handler supports terminal resizing
0000000000000000000000000000000000000000;;		supportsTerminalResizing() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// v4ProtocolHandler implements the V4 protocol version for streaming command execution. It only differs
0000000000000000000000000000000000000000;;	// in from v3 in the error stream format using an json-marshaled metav1.Status which carries
0000000000000000000000000000000000000000;;	// the process' exit code.
0000000000000000000000000000000000000000;;	type v4ProtocolHandler struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*v4ProtocolHandler) waitForStreams(streams <-chan streamAndReply, expectedStreams int, expired <-chan time.Time) (*context, error) {
0000000000000000000000000000000000000000;;		ctx := &context{}
0000000000000000000000000000000000000000;;		receivedStreams := 0
0000000000000000000000000000000000000000;;		replyChan := make(chan struct{})
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stop)
0000000000000000000000000000000000000000;;	WaitForStreams:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case stream := <-streams:
0000000000000000000000000000000000000000;;				streamType := stream.Headers().Get(api.StreamType)
0000000000000000000000000000000000000000;;				switch streamType {
0000000000000000000000000000000000000000;;				case api.StreamTypeError:
0000000000000000000000000000000000000000;;					ctx.writeStatus = v4WriteStatusFunc(stream) // write json errors
0000000000000000000000000000000000000000;;					go waitStreamReply(stream.replySent, replyChan, stop)
0000000000000000000000000000000000000000;;				case api.StreamTypeStdin:
0000000000000000000000000000000000000000;;					ctx.stdinStream = stream
0000000000000000000000000000000000000000;;					go waitStreamReply(stream.replySent, replyChan, stop)
0000000000000000000000000000000000000000;;				case api.StreamTypeStdout:
0000000000000000000000000000000000000000;;					ctx.stdoutStream = stream
0000000000000000000000000000000000000000;;					go waitStreamReply(stream.replySent, replyChan, stop)
0000000000000000000000000000000000000000;;				case api.StreamTypeStderr:
0000000000000000000000000000000000000000;;					ctx.stderrStream = stream
0000000000000000000000000000000000000000;;					go waitStreamReply(stream.replySent, replyChan, stop)
0000000000000000000000000000000000000000;;				case api.StreamTypeResize:
0000000000000000000000000000000000000000;;					ctx.resizeStream = stream
0000000000000000000000000000000000000000;;					go waitStreamReply(stream.replySent, replyChan, stop)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					runtime.HandleError(fmt.Errorf("Unexpected stream type: %q", streamType))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-replyChan:
0000000000000000000000000000000000000000;;				receivedStreams++
0000000000000000000000000000000000000000;;				if receivedStreams == expectedStreams {
0000000000000000000000000000000000000000;;					break WaitForStreams
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-expired:
0000000000000000000000000000000000000000;;				// TODO find a way to return the error to the user. Maybe use a separate
0000000000000000000000000000000000000000;;				// stream to report errors?
0000000000000000000000000000000000000000;;				return nil, errors.New("timed out waiting for client to create streams")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ctx, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// supportsTerminalResizing returns true because v4ProtocolHandler supports it
0000000000000000000000000000000000000000;;	func (*v4ProtocolHandler) supportsTerminalResizing() bool { return true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// v3ProtocolHandler implements the V3 protocol version for streaming command execution.
0000000000000000000000000000000000000000;;	type v3ProtocolHandler struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*v3ProtocolHandler) waitForStreams(streams <-chan streamAndReply, expectedStreams int, expired <-chan time.Time) (*context, error) {
0000000000000000000000000000000000000000;;		ctx := &context{}
0000000000000000000000000000000000000000;;		receivedStreams := 0
0000000000000000000000000000000000000000;;		replyChan := make(chan struct{})
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stop)
0000000000000000000000000000000000000000;;	WaitForStreams:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case stream := <-streams:
0000000000000000000000000000000000000000;;				streamType := stream.Headers().Get(api.StreamType)
0000000000000000000000000000000000000000;;				switch streamType {
0000000000000000000000000000000000000000;;				case api.StreamTypeError:
0000000000000000000000000000000000000000;;					ctx.writeStatus = v1WriteStatusFunc(stream)
0000000000000000000000000000000000000000;;					go waitStreamReply(stream.replySent, replyChan, stop)
0000000000000000000000000000000000000000;;				case api.StreamTypeStdin:
0000000000000000000000000000000000000000;;					ctx.stdinStream = stream
0000000000000000000000000000000000000000;;					go waitStreamReply(stream.replySent, replyChan, stop)
0000000000000000000000000000000000000000;;				case api.StreamTypeStdout:
0000000000000000000000000000000000000000;;					ctx.stdoutStream = stream
0000000000000000000000000000000000000000;;					go waitStreamReply(stream.replySent, replyChan, stop)
0000000000000000000000000000000000000000;;				case api.StreamTypeStderr:
0000000000000000000000000000000000000000;;					ctx.stderrStream = stream
0000000000000000000000000000000000000000;;					go waitStreamReply(stream.replySent, replyChan, stop)
0000000000000000000000000000000000000000;;				case api.StreamTypeResize:
0000000000000000000000000000000000000000;;					ctx.resizeStream = stream
0000000000000000000000000000000000000000;;					go waitStreamReply(stream.replySent, replyChan, stop)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					runtime.HandleError(fmt.Errorf("Unexpected stream type: %q", streamType))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-replyChan:
0000000000000000000000000000000000000000;;				receivedStreams++
0000000000000000000000000000000000000000;;				if receivedStreams == expectedStreams {
0000000000000000000000000000000000000000;;					break WaitForStreams
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-expired:
0000000000000000000000000000000000000000;;				// TODO find a way to return the error to the user. Maybe use a separate
0000000000000000000000000000000000000000;;				// stream to report errors?
0000000000000000000000000000000000000000;;				return nil, errors.New("timed out waiting for client to create streams")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ctx, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// supportsTerminalResizing returns true because v3ProtocolHandler supports it
0000000000000000000000000000000000000000;;	func (*v3ProtocolHandler) supportsTerminalResizing() bool { return true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// v2ProtocolHandler implements the V2 protocol version for streaming command execution.
0000000000000000000000000000000000000000;;	type v2ProtocolHandler struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*v2ProtocolHandler) waitForStreams(streams <-chan streamAndReply, expectedStreams int, expired <-chan time.Time) (*context, error) {
0000000000000000000000000000000000000000;;		ctx := &context{}
0000000000000000000000000000000000000000;;		receivedStreams := 0
0000000000000000000000000000000000000000;;		replyChan := make(chan struct{})
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stop)
0000000000000000000000000000000000000000;;	WaitForStreams:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case stream := <-streams:
0000000000000000000000000000000000000000;;				streamType := stream.Headers().Get(api.StreamType)
0000000000000000000000000000000000000000;;				switch streamType {
0000000000000000000000000000000000000000;;				case api.StreamTypeError:
0000000000000000000000000000000000000000;;					ctx.writeStatus = v1WriteStatusFunc(stream)
0000000000000000000000000000000000000000;;					go waitStreamReply(stream.replySent, replyChan, stop)
0000000000000000000000000000000000000000;;				case api.StreamTypeStdin:
0000000000000000000000000000000000000000;;					ctx.stdinStream = stream
0000000000000000000000000000000000000000;;					go waitStreamReply(stream.replySent, replyChan, stop)
0000000000000000000000000000000000000000;;				case api.StreamTypeStdout:
0000000000000000000000000000000000000000;;					ctx.stdoutStream = stream
0000000000000000000000000000000000000000;;					go waitStreamReply(stream.replySent, replyChan, stop)
0000000000000000000000000000000000000000;;				case api.StreamTypeStderr:
0000000000000000000000000000000000000000;;					ctx.stderrStream = stream
0000000000000000000000000000000000000000;;					go waitStreamReply(stream.replySent, replyChan, stop)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					runtime.HandleError(fmt.Errorf("Unexpected stream type: %q", streamType))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-replyChan:
0000000000000000000000000000000000000000;;				receivedStreams++
0000000000000000000000000000000000000000;;				if receivedStreams == expectedStreams {
0000000000000000000000000000000000000000;;					break WaitForStreams
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-expired:
0000000000000000000000000000000000000000;;				// TODO find a way to return the error to the user. Maybe use a separate
0000000000000000000000000000000000000000;;				// stream to report errors?
0000000000000000000000000000000000000000;;				return nil, errors.New("timed out waiting for client to create streams")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ctx, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// supportsTerminalResizing returns false because v2ProtocolHandler doesn't support it.
0000000000000000000000000000000000000000;;	func (*v2ProtocolHandler) supportsTerminalResizing() bool { return false }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// v1ProtocolHandler implements the V1 protocol version for streaming command execution.
0000000000000000000000000000000000000000;;	type v1ProtocolHandler struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*v1ProtocolHandler) waitForStreams(streams <-chan streamAndReply, expectedStreams int, expired <-chan time.Time) (*context, error) {
0000000000000000000000000000000000000000;;		ctx := &context{}
0000000000000000000000000000000000000000;;		receivedStreams := 0
0000000000000000000000000000000000000000;;		replyChan := make(chan struct{})
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stop)
0000000000000000000000000000000000000000;;	WaitForStreams:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case stream := <-streams:
0000000000000000000000000000000000000000;;				streamType := stream.Headers().Get(api.StreamType)
0000000000000000000000000000000000000000;;				switch streamType {
0000000000000000000000000000000000000000;;				case api.StreamTypeError:
0000000000000000000000000000000000000000;;					ctx.writeStatus = v1WriteStatusFunc(stream)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// This defer statement shouldn't be here, but due to previous refactoring, it ended up in
0000000000000000000000000000000000000000;;					// here. This is what 1.0.x kubelets do, so we're retaining that behavior. This is fixed in
0000000000000000000000000000000000000000;;					// the v2ProtocolHandler.
0000000000000000000000000000000000000000;;					defer stream.Reset()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					go waitStreamReply(stream.replySent, replyChan, stop)
0000000000000000000000000000000000000000;;				case api.StreamTypeStdin:
0000000000000000000000000000000000000000;;					ctx.stdinStream = stream
0000000000000000000000000000000000000000;;					go waitStreamReply(stream.replySent, replyChan, stop)
0000000000000000000000000000000000000000;;				case api.StreamTypeStdout:
0000000000000000000000000000000000000000;;					ctx.stdoutStream = stream
0000000000000000000000000000000000000000;;					go waitStreamReply(stream.replySent, replyChan, stop)
0000000000000000000000000000000000000000;;				case api.StreamTypeStderr:
0000000000000000000000000000000000000000;;					ctx.stderrStream = stream
0000000000000000000000000000000000000000;;					go waitStreamReply(stream.replySent, replyChan, stop)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					runtime.HandleError(fmt.Errorf("Unexpected stream type: %q", streamType))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-replyChan:
0000000000000000000000000000000000000000;;				receivedStreams++
0000000000000000000000000000000000000000;;				if receivedStreams == expectedStreams {
0000000000000000000000000000000000000000;;					break WaitForStreams
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-expired:
0000000000000000000000000000000000000000;;				// TODO find a way to return the error to the user. Maybe use a separate
0000000000000000000000000000000000000000;;				// stream to report errors?
0000000000000000000000000000000000000000;;				return nil, errors.New("timed out waiting for client to create streams")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ctx.stdinStream != nil {
0000000000000000000000000000000000000000;;			ctx.stdinStream.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ctx, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// supportsTerminalResizing returns false because v1ProtocolHandler doesn't support it.
0000000000000000000000000000000000000000;;	func (*v1ProtocolHandler) supportsTerminalResizing() bool { return false }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func handleResizeEvents(stream io.Reader, channel chan<- remotecommand.TerminalSize) {
0000000000000000000000000000000000000000;;		defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decoder := json.NewDecoder(stream)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			size := remotecommand.TerminalSize{}
0000000000000000000000000000000000000000;;			if err := decoder.Decode(&size); err != nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			channel <- size
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func v1WriteStatusFunc(stream io.Writer) func(status *apierrors.StatusError) error {
0000000000000000000000000000000000000000;;		return func(status *apierrors.StatusError) error {
0000000000000000000000000000000000000000;;			if status.Status().Status == metav1.StatusSuccess {
0000000000000000000000000000000000000000;;				return nil // send error messages
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err := stream.Write([]byte(status.Error()))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// v4WriteStatusFunc returns a WriteStatusFunc that marshals a given api Status
0000000000000000000000000000000000000000;;	// as json in the error channel.
0000000000000000000000000000000000000000;;	func v4WriteStatusFunc(stream io.Writer) func(status *apierrors.StatusError) error {
0000000000000000000000000000000000000000;;		return func(status *apierrors.StatusError) error {
0000000000000000000000000000000000000000;;			bs, err := json.Marshal(status.Status())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err = stream.Write(bs)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
