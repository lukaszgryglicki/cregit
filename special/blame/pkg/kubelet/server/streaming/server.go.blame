0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
727b22c0d1dcb064ebecf8b387d4174db5472791;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package streaming
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"google.golang.org/grpc"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/codes"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restful "github.com/emicklei/go-restful"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		remotecommandconsts "k8s.io/apimachinery/pkg/util/remotecommand"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/remotecommand"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/server/portforward"
0000000000000000000000000000000000000000;;		remotecommandserver "k8s.io/kubernetes/pkg/kubelet/server/remotecommand"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The library interface to serve the stream requests.
0000000000000000000000000000000000000000;;	type Server interface {
0000000000000000000000000000000000000000;;		http.Handler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the serving URL for the requests.
0000000000000000000000000000000000000000;;		// Requests must not be nil. Responses may be nil iff an error is returned.
0000000000000000000000000000000000000000;;		GetExec(*runtimeapi.ExecRequest) (*runtimeapi.ExecResponse, error)
0000000000000000000000000000000000000000;;		GetAttach(req *runtimeapi.AttachRequest) (*runtimeapi.AttachResponse, error)
0000000000000000000000000000000000000000;;		GetPortForward(*runtimeapi.PortForwardRequest) (*runtimeapi.PortForwardResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start the server.
0000000000000000000000000000000000000000;;		// addr is the address to serve on (address:port) stayUp indicates whether the server should
0000000000000000000000000000000000000000;;		// listen until Stop() is called, or automatically stop after all expected connections are
0000000000000000000000000000000000000000;;		// closed. Calling Get{Exec,Attach,PortForward} increments the expected connection count.
0000000000000000000000000000000000000000;;		// Function does not return until the server is stopped.
0000000000000000000000000000000000000000;;		Start(stayUp bool) error
0000000000000000000000000000000000000000;;		// Stop the server, and terminate any open connections.
0000000000000000000000000000000000000000;;		Stop() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The interface to execute the commands and provide the streams.
0000000000000000000000000000000000000000;;	type Runtime interface {
0000000000000000000000000000000000000000;;		Exec(containerID string, cmd []string, in io.Reader, out, err io.WriteCloser, tty bool, resize <-chan remotecommand.TerminalSize) error
0000000000000000000000000000000000000000;;		Attach(containerID string, in io.Reader, out, err io.WriteCloser, tty bool, resize <-chan remotecommand.TerminalSize) error
0000000000000000000000000000000000000000;;		PortForward(podSandboxID string, port int32, stream io.ReadWriteCloser) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config defines the options used for running the stream server.
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		// The host:port address the server will listen on.
0000000000000000000000000000000000000000;;		Addr string
0000000000000000000000000000000000000000;;		// The optional base URL for constructing streaming URLs. If empty, the baseURL will be
0000000000000000000000000000000000000000;;		// constructed from the serve address.
0000000000000000000000000000000000000000;;		BaseURL *url.URL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// How long to leave idle connections open for.
0000000000000000000000000000000000000000;;		StreamIdleTimeout time.Duration
0000000000000000000000000000000000000000;;		// How long to wait for clients to create streams. Only used for SPDY streaming.
0000000000000000000000000000000000000000;;		StreamCreationTimeout time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The streaming protocols the server supports (understands and permits).  See
0000000000000000000000000000000000000000;;		// k8s.io/kubernetes/pkg/kubelet/server/remotecommand/constants.go for available protocols.
0000000000000000000000000000000000000000;;		// Only used for SPDY streaming.
0000000000000000000000000000000000000000;;		SupportedRemoteCommandProtocols []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The streaming protocols the server supports (understands and permits).  See
0000000000000000000000000000000000000000;;		// k8s.io/kubernetes/pkg/kubelet/server/portforward/constants.go for available protocols.
0000000000000000000000000000000000000000;;		// Only used for SPDY streaming.
0000000000000000000000000000000000000000;;		SupportedPortForwardProtocols []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The config for serving over TLS. If nil, TLS will not be used.
0000000000000000000000000000000000000000;;		TLSConfig *tls.Config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultConfig provides default values for server Config. The DefaultConfig is partial, so
0000000000000000000000000000000000000000;;	// some fields like Addr must still be provided.
0000000000000000000000000000000000000000;;	var DefaultConfig = Config{
0000000000000000000000000000000000000000;;		StreamIdleTimeout:               4 * time.Hour,
0000000000000000000000000000000000000000;;		StreamCreationTimeout:           remotecommandconsts.DefaultStreamCreationTimeout,
0000000000000000000000000000000000000000;;		SupportedRemoteCommandProtocols: remotecommandconsts.SupportedStreamingProtocols,
0000000000000000000000000000000000000000;;		SupportedPortForwardProtocols:   portforward.SupportedProtocols,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(tallclair): Add auth(n/z) interface & handling.
0000000000000000000000000000000000000000;;	func NewServer(config Config, runtime Runtime) (Server, error) {
0000000000000000000000000000000000000000;;		s := &server{
0000000000000000000000000000000000000000;;			config:  config,
0000000000000000000000000000000000000000;;			runtime: &criAdapter{runtime},
0000000000000000000000000000000000000000;;			cache:   newRequestCache(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.config.BaseURL == nil {
0000000000000000000000000000000000000000;;			s.config.BaseURL = &url.URL{
0000000000000000000000000000000000000000;;				Scheme: "http",
0000000000000000000000000000000000000000;;				Host:   s.config.Addr,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s.config.TLSConfig != nil {
0000000000000000000000000000000000000000;;				s.config.BaseURL.Scheme = "https"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ws := &restful.WebService{}
0000000000000000000000000000000000000000;;		endpoints := []struct {
0000000000000000000000000000000000000000;;			path    string
0000000000000000000000000000000000000000;;			handler restful.RouteFunction
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"/exec/{token}", s.serveExec},
0000000000000000000000000000000000000000;;			{"/attach/{token}", s.serveAttach},
0000000000000000000000000000000000000000;;			{"/portforward/{token}", s.servePortForward},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If serving relative to a base path, set that here.
0000000000000000000000000000000000000000;;		pathPrefix := path.Dir(s.config.BaseURL.Path)
0000000000000000000000000000000000000000;;		for _, e := range endpoints {
0000000000000000000000000000000000000000;;			for _, method := range []string{"GET", "POST"} {
0000000000000000000000000000000000000000;;				ws.Route(ws.
0000000000000000000000000000000000000000;;					Method(method).
0000000000000000000000000000000000000000;;					Path(path.Join(pathPrefix, e.path)).
0000000000000000000000000000000000000000;;					To(e.handler))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := restful.NewContainer()
0000000000000000000000000000000000000000;;		handler.Add(ws)
0000000000000000000000000000000000000000;;		s.handler = handler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type server struct {
0000000000000000000000000000000000000000;;		config  Config
0000000000000000000000000000000000000000;;		runtime *criAdapter
0000000000000000000000000000000000000000;;		handler http.Handler
0000000000000000000000000000000000000000;;		cache   *requestCache
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *server) GetExec(req *runtimeapi.ExecRequest) (*runtimeapi.ExecResponse, error) {
0000000000000000000000000000000000000000;;		if req.ContainerId == "" {
0000000000000000000000000000000000000000;;			return nil, grpc.Errorf(codes.InvalidArgument, "missing required container_id")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		token, err := s.cache.Insert(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &runtimeapi.ExecResponse{
0000000000000000000000000000000000000000;;			Url: s.buildURL("exec", token),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *server) GetAttach(req *runtimeapi.AttachRequest) (*runtimeapi.AttachResponse, error) {
0000000000000000000000000000000000000000;;		if req.ContainerId == "" {
0000000000000000000000000000000000000000;;			return nil, grpc.Errorf(codes.InvalidArgument, "missing required container_id")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		token, err := s.cache.Insert(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &runtimeapi.AttachResponse{
0000000000000000000000000000000000000000;;			Url: s.buildURL("attach", token),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *server) GetPortForward(req *runtimeapi.PortForwardRequest) (*runtimeapi.PortForwardResponse, error) {
0000000000000000000000000000000000000000;;		if req.PodSandboxId == "" {
0000000000000000000000000000000000000000;;			return nil, grpc.Errorf(codes.InvalidArgument, "missing required pod_sandbox_id")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		token, err := s.cache.Insert(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &runtimeapi.PortForwardResponse{
0000000000000000000000000000000000000000;;			Url: s.buildURL("portforward", token),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *server) Start(stayUp bool) error {
0000000000000000000000000000000000000000;;		if !stayUp {
0000000000000000000000000000000000000000;;			// TODO(tallclair): Implement this.
0000000000000000000000000000000000000000;;			return errors.New("stayUp=false is not yet implemented")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server := &http.Server{
0000000000000000000000000000000000000000;;			Addr:      s.config.Addr,
0000000000000000000000000000000000000000;;			Handler:   s.handler,
0000000000000000000000000000000000000000;;			TLSConfig: s.config.TLSConfig,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.config.TLSConfig != nil {
0000000000000000000000000000000000000000;;			return server.ListenAndServeTLS("", "") // Use certs from TLSConfig.
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return server.ListenAndServe()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *server) Stop() error {
0000000000000000000000000000000000000000;;		// TODO(tallclair): Implement this.
0000000000000000000000000000000000000000;;		return errors.New("not yet implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		s.handler.ServeHTTP(w, r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *server) buildURL(method, token string) string {
0000000000000000000000000000000000000000;;		return s.config.BaseURL.ResolveReference(&url.URL{
0000000000000000000000000000000000000000;;			Path: path.Join(method, token),
0000000000000000000000000000000000000000;;		}).String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *server) serveExec(req *restful.Request, resp *restful.Response) {
0000000000000000000000000000000000000000;;		token := req.PathParameter("token")
0000000000000000000000000000000000000000;;		cachedRequest, ok := s.cache.Consume(token)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			http.NotFound(resp.ResponseWriter, req.Request)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		exec, ok := cachedRequest.(*runtimeapi.ExecRequest)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			http.NotFound(resp.ResponseWriter, req.Request)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		streamOpts := &remotecommandserver.Options{
0000000000000000000000000000000000000000;;			Stdin:  exec.Stdin,
0000000000000000000000000000000000000000;;			Stdout: true,
0000000000000000000000000000000000000000;;			Stderr: !exec.Tty,
0000000000000000000000000000000000000000;;			TTY:    exec.Tty,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		remotecommandserver.ServeExec(
0000000000000000000000000000000000000000;;			resp.ResponseWriter,
0000000000000000000000000000000000000000;;			req.Request,
0000000000000000000000000000000000000000;;			s.runtime,
0000000000000000000000000000000000000000;;			"", // unused: podName
0000000000000000000000000000000000000000;;			"", // unusued: podUID
0000000000000000000000000000000000000000;;			exec.ContainerId,
0000000000000000000000000000000000000000;;			exec.Cmd,
0000000000000000000000000000000000000000;;			streamOpts,
0000000000000000000000000000000000000000;;			s.config.StreamIdleTimeout,
0000000000000000000000000000000000000000;;			s.config.StreamCreationTimeout,
0000000000000000000000000000000000000000;;			s.config.SupportedRemoteCommandProtocols)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *server) serveAttach(req *restful.Request, resp *restful.Response) {
0000000000000000000000000000000000000000;;		token := req.PathParameter("token")
0000000000000000000000000000000000000000;;		cachedRequest, ok := s.cache.Consume(token)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			http.NotFound(resp.ResponseWriter, req.Request)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attach, ok := cachedRequest.(*runtimeapi.AttachRequest)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			http.NotFound(resp.ResponseWriter, req.Request)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		streamOpts := &remotecommandserver.Options{
0000000000000000000000000000000000000000;;			Stdin:  attach.Stdin,
0000000000000000000000000000000000000000;;			Stdout: true,
0000000000000000000000000000000000000000;;			Stderr: !attach.Tty,
0000000000000000000000000000000000000000;;			TTY:    attach.Tty,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		remotecommandserver.ServeAttach(
0000000000000000000000000000000000000000;;			resp.ResponseWriter,
0000000000000000000000000000000000000000;;			req.Request,
0000000000000000000000000000000000000000;;			s.runtime,
0000000000000000000000000000000000000000;;			"", // unused: podName
0000000000000000000000000000000000000000;;			"", // unusued: podUID
0000000000000000000000000000000000000000;;			attach.ContainerId,
0000000000000000000000000000000000000000;;			streamOpts,
0000000000000000000000000000000000000000;;			s.config.StreamIdleTimeout,
0000000000000000000000000000000000000000;;			s.config.StreamCreationTimeout,
0000000000000000000000000000000000000000;;			s.config.SupportedRemoteCommandProtocols)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *server) servePortForward(req *restful.Request, resp *restful.Response) {
0000000000000000000000000000000000000000;;		token := req.PathParameter("token")
0000000000000000000000000000000000000000;;		cachedRequest, ok := s.cache.Consume(token)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			http.NotFound(resp.ResponseWriter, req.Request)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pf, ok := cachedRequest.(*runtimeapi.PortForwardRequest)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			http.NotFound(resp.ResponseWriter, req.Request)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		portForwardOptions, err := portforward.BuildV4Options(pf.Port)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			resp.WriteError(http.StatusBadRequest, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		portforward.ServePortForward(
0000000000000000000000000000000000000000;;			resp.ResponseWriter,
0000000000000000000000000000000000000000;;			req.Request,
0000000000000000000000000000000000000000;;			s.runtime,
0000000000000000000000000000000000000000;;			pf.PodSandboxId,
0000000000000000000000000000000000000000;;			"", // unused: podUID
0000000000000000000000000000000000000000;;			portForwardOptions,
0000000000000000000000000000000000000000;;			s.config.StreamIdleTimeout,
0000000000000000000000000000000000000000;;			s.config.StreamCreationTimeout,
0000000000000000000000000000000000000000;;			s.config.SupportedPortForwardProtocols)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// criAdapter wraps the Runtime functions to conform to the remotecommand interfaces.
0000000000000000000000000000000000000000;;	// The adapter binds the container ID to the container name argument, and the pod sandbox ID to the pod name.
0000000000000000000000000000000000000000;;	type criAdapter struct {
0000000000000000000000000000000000000000;;		Runtime
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ remotecommandserver.Executor = &criAdapter{}
0000000000000000000000000000000000000000;;	var _ remotecommandserver.Attacher = &criAdapter{}
0000000000000000000000000000000000000000;;	var _ portforward.PortForwarder = &criAdapter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *criAdapter) ExecInContainer(podName string, podUID types.UID, container string, cmd []string, in io.Reader, out, err io.WriteCloser, tty bool, resize <-chan remotecommand.TerminalSize, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		return a.Exec(container, cmd, in, out, err, tty, resize)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *criAdapter) AttachContainer(podName string, podUID types.UID, container string, in io.Reader, out, err io.WriteCloser, tty bool, resize <-chan remotecommand.TerminalSize) error {
0000000000000000000000000000000000000000;;		return a.Attach(container, in, out, err, tty, resize)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *criAdapter) PortForward(podName string, podUID types.UID, port int32, stream io.ReadWriteCloser) error {
0000000000000000000000000000000000000000;;		return a.Runtime.PortForward(podName, port, stream)
0000000000000000000000000000000000000000;;	}
