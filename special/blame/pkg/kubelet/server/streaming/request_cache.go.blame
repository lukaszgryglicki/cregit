0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
e1e40ce087a3b8f3a621a2a95fe2b0f3c0995846;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package streaming
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"container/list"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Timeout after which tokens become invalid.
0000000000000000000000000000000000000000;;		CacheTTL = 1 * time.Minute
0000000000000000000000000000000000000000;;		// The maximum number of in-flight requests to allow.
0000000000000000000000000000000000000000;;		MaxInFlight = 1000
0000000000000000000000000000000000000000;;		// Length of the random base64 encoded token identifying the request.
0000000000000000000000000000000000000000;;		TokenLen = 8
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// requestCache caches streaming (exec/attach/port-forward) requests and generates a single-use
0000000000000000000000000000000000000000;;	// random token for their retrieval. The requestCache is used for building streaming URLs without
0000000000000000000000000000000000000000;;	// the need to encode every request parameter in the URL.
0000000000000000000000000000000000000000;;	type requestCache struct {
0000000000000000000000000000000000000000;;		// clock is used to obtain the current time
0000000000000000000000000000000000000000;;		clock clock.Clock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// tokens maps the generate token to the request for fast retrieval.
0000000000000000000000000000000000000000;;		tokens map[string]*list.Element
0000000000000000000000000000000000000000;;		// ll maintains an age-ordered request list for faster garbage collection of expired requests.
0000000000000000000000000000000000000000;;		ll *list.List
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lock sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type representing an *ExecRequest, *AttachRequest, or *PortForwardRequest.
0000000000000000000000000000000000000000;;	type request interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cacheEntry struct {
0000000000000000000000000000000000000000;;		token      string
0000000000000000000000000000000000000000;;		req        request
0000000000000000000000000000000000000000;;		expireTime time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRequestCache() *requestCache {
0000000000000000000000000000000000000000;;		return &requestCache{
0000000000000000000000000000000000000000;;			clock:  clock.RealClock{},
0000000000000000000000000000000000000000;;			ll:     list.New(),
0000000000000000000000000000000000000000;;			tokens: make(map[string]*list.Element),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Insert the given request into the cache and returns the token used for fetching it out.
0000000000000000000000000000000000000000;;	func (c *requestCache) Insert(req request) (token string, err error) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove expired entries.
0000000000000000000000000000000000000000;;		c.gc()
0000000000000000000000000000000000000000;;		// If the cache is full, reject the request.
0000000000000000000000000000000000000000;;		if c.ll.Len() == MaxInFlight {
0000000000000000000000000000000000000000;;			return "", ErrorTooManyInFlight()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		token, err = c.uniqueToken()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ele := c.ll.PushFront(&cacheEntry{token, req, c.clock.Now().Add(CacheTTL)})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.tokens[token] = ele
0000000000000000000000000000000000000000;;		return token, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Consume the token (remove it from the cache) and return the cached request, if found.
0000000000000000000000000000000000000000;;	func (c *requestCache) Consume(token string) (req request, found bool) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		ele, ok := c.tokens[token]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.ll.Remove(ele)
0000000000000000000000000000000000000000;;		delete(c.tokens, token)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		entry := ele.Value.(*cacheEntry)
0000000000000000000000000000000000000000;;		if c.clock.Now().After(entry.expireTime) {
0000000000000000000000000000000000000000;;			// Entry already expired.
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return entry.req, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// uniqueToken generates a random URL-safe token and ensures uniqueness.
0000000000000000000000000000000000000000;;	func (c *requestCache) uniqueToken() (string, error) {
0000000000000000000000000000000000000000;;		const maxTries = 10
0000000000000000000000000000000000000000;;		// Number of bytes to be TokenLen when base64 encoded.
0000000000000000000000000000000000000000;;		tokenSize := math.Ceil(float64(TokenLen) * 6 / 8)
0000000000000000000000000000000000000000;;		rawToken := make([]byte, int(tokenSize))
0000000000000000000000000000000000000000;;		for i := 0; i < maxTries; i++ {
0000000000000000000000000000000000000000;;			if _, err := rand.Read(rawToken); err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			encoded := base64.RawURLEncoding.EncodeToString(rawToken)
0000000000000000000000000000000000000000;;			token := encoded[:TokenLen]
0000000000000000000000000000000000000000;;			// If it's unique, return it. Otherwise retry.
0000000000000000000000000000000000000000;;			if _, exists := c.tokens[encoded]; !exists {
0000000000000000000000000000000000000000;;				return token, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("failed to generate unique token")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Must be write-locked prior to calling.
0000000000000000000000000000000000000000;;	func (c *requestCache) gc() {
0000000000000000000000000000000000000000;;		now := c.clock.Now()
0000000000000000000000000000000000000000;;		for c.ll.Len() > 0 {
0000000000000000000000000000000000000000;;			oldest := c.ll.Back()
0000000000000000000000000000000000000000;;			entry := oldest.Value.(*cacheEntry)
0000000000000000000000000000000000000000;;			if !now.After(entry.expireTime) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Oldest value is expired; remove it.
0000000000000000000000000000000000000000;;			c.ll.Remove(oldest)
0000000000000000000000000000000000000000;;			delete(c.tokens, entry.token)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
