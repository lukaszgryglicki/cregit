0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
727b22c0d1dcb064ebecf8b387d4174db5472791;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package streaming
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/require"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/remotecommand"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/transport/spdy"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		kubeletportforward "k8s.io/kubernetes/pkg/kubelet/server/portforward"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		testAddr         = "localhost:12345"
0000000000000000000000000000000000000000;;		testContainerID  = "container789"
0000000000000000000000000000000000000000;;		testPodSandboxID = "pod0987"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetExec(t *testing.T) {
0000000000000000000000000000000000000000;;		type testcase struct {
0000000000000000000000000000000000000000;;			cmd   []string
0000000000000000000000000000000000000000;;			tty   bool
0000000000000000000000000000000000000000;;			stdin bool
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testcases := []testcase{
0000000000000000000000000000000000000000;;			{[]string{"echo", "foo"}, false, false},
0000000000000000000000000000000000000000;;			{[]string{"date"}, true, false},
0000000000000000000000000000000000000000;;			{[]string{"date"}, false, true},
0000000000000000000000000000000000000000;;			{[]string{"date"}, true, true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		serv, err := NewServer(Config{
0000000000000000000000000000000000000000;;			Addr: testAddr,
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tlsServer, err := NewServer(Config{
0000000000000000000000000000000000000000;;			Addr:      testAddr,
0000000000000000000000000000000000000000;;			TLSConfig: &tls.Config{},
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const pathPrefix = "cri/shim"
0000000000000000000000000000000000000000;;		prefixServer, err := NewServer(Config{
0000000000000000000000000000000000000000;;			Addr: testAddr,
0000000000000000000000000000000000000000;;			BaseURL: &url.URL{
0000000000000000000000000000000000000000;;				Scheme: "http",
0000000000000000000000000000000000000000;;				Host:   testAddr,
0000000000000000000000000000000000000000;;				Path:   "/" + pathPrefix + "/",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assertRequestToken := func(test testcase, cache *requestCache, token string) {
0000000000000000000000000000000000000000;;			req, ok := cache.Consume(token)
0000000000000000000000000000000000000000;;			require.True(t, ok, "token %s not found! testcase=%+v", token, test)
0000000000000000000000000000000000000000;;			assert.Equal(t, testContainerID, req.(*runtimeapi.ExecRequest).ContainerId, "testcase=%+v", test)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.cmd, req.(*runtimeapi.ExecRequest).Cmd, "testcase=%+v", test)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.tty, req.(*runtimeapi.ExecRequest).Tty, "testcase=%+v", test)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.stdin, req.(*runtimeapi.ExecRequest).Stdin, "testcase=%+v", test)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		containerID := testContainerID
0000000000000000000000000000000000000000;;		for _, test := range testcases {
0000000000000000000000000000000000000000;;			request := &runtimeapi.ExecRequest{
0000000000000000000000000000000000000000;;				ContainerId: containerID,
0000000000000000000000000000000000000000;;				Cmd:         test.cmd,
0000000000000000000000000000000000000000;;				Tty:         test.tty,
0000000000000000000000000000000000000000;;				Stdin:       test.stdin,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			{ // Non-TLS
0000000000000000000000000000000000000000;;				resp, err := serv.GetExec(request)
0000000000000000000000000000000000000000;;				assert.NoError(t, err, "testcase=%+v", test)
0000000000000000000000000000000000000000;;				expectedURL := "http://" + testAddr + "/exec/"
0000000000000000000000000000000000000000;;				assert.Contains(t, resp.Url, expectedURL, "testcase=%+v", test)
0000000000000000000000000000000000000000;;				token := strings.TrimPrefix(resp.Url, expectedURL)
0000000000000000000000000000000000000000;;				assertRequestToken(test, serv.(*server).cache, token)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{ // TLS
0000000000000000000000000000000000000000;;				resp, err := tlsServer.GetExec(request)
0000000000000000000000000000000000000000;;				assert.NoError(t, err, "testcase=%+v", test)
0000000000000000000000000000000000000000;;				expectedURL := "https://" + testAddr + "/exec/"
0000000000000000000000000000000000000000;;				assert.Contains(t, resp.Url, expectedURL, "testcase=%+v", test)
0000000000000000000000000000000000000000;;				token := strings.TrimPrefix(resp.Url, expectedURL)
0000000000000000000000000000000000000000;;				assertRequestToken(test, tlsServer.(*server).cache, token)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{ // Path prefix
0000000000000000000000000000000000000000;;				resp, err := prefixServer.GetExec(request)
0000000000000000000000000000000000000000;;				assert.NoError(t, err, "testcase=%+v", test)
0000000000000000000000000000000000000000;;				expectedURL := "http://" + testAddr + "/" + pathPrefix + "/exec/"
0000000000000000000000000000000000000000;;				assert.Contains(t, resp.Url, expectedURL, "testcase=%+v", test)
0000000000000000000000000000000000000000;;				token := strings.TrimPrefix(resp.Url, expectedURL)
0000000000000000000000000000000000000000;;				assertRequestToken(test, prefixServer.(*server).cache, token)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetAttach(t *testing.T) {
0000000000000000000000000000000000000000;;		type testcase struct {
0000000000000000000000000000000000000000;;			tty   bool
0000000000000000000000000000000000000000;;			stdin bool
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testcases := []testcase{
0000000000000000000000000000000000000000;;			{false, false},
0000000000000000000000000000000000000000;;			{true, false},
0000000000000000000000000000000000000000;;			{false, true},
0000000000000000000000000000000000000000;;			{true, true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		serv, err := NewServer(Config{
0000000000000000000000000000000000000000;;			Addr: testAddr,
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tlsServer, err := NewServer(Config{
0000000000000000000000000000000000000000;;			Addr:      testAddr,
0000000000000000000000000000000000000000;;			TLSConfig: &tls.Config{},
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assertRequestToken := func(test testcase, cache *requestCache, token string) {
0000000000000000000000000000000000000000;;			req, ok := cache.Consume(token)
0000000000000000000000000000000000000000;;			require.True(t, ok, "token %s not found! testcase=%+v", token, test)
0000000000000000000000000000000000000000;;			assert.Equal(t, testContainerID, req.(*runtimeapi.AttachRequest).ContainerId, "testcase=%+v", test)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.tty, req.(*runtimeapi.AttachRequest).Tty, "testcase=%+v", test)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.stdin, req.(*runtimeapi.AttachRequest).Stdin, "testcase=%+v", test)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		containerID := testContainerID
0000000000000000000000000000000000000000;;		for _, test := range testcases {
0000000000000000000000000000000000000000;;			request := &runtimeapi.AttachRequest{
0000000000000000000000000000000000000000;;				ContainerId: containerID,
0000000000000000000000000000000000000000;;				Stdin:       test.stdin,
0000000000000000000000000000000000000000;;				Tty:         test.tty,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			{ // Non-TLS
0000000000000000000000000000000000000000;;				resp, err := serv.GetAttach(request)
0000000000000000000000000000000000000000;;				assert.NoError(t, err, "testcase=%+v", test)
0000000000000000000000000000000000000000;;				expectedURL := "http://" + testAddr + "/attach/"
0000000000000000000000000000000000000000;;				assert.Contains(t, resp.Url, expectedURL, "testcase=%+v", test)
0000000000000000000000000000000000000000;;				token := strings.TrimPrefix(resp.Url, expectedURL)
0000000000000000000000000000000000000000;;				assertRequestToken(test, serv.(*server).cache, token)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{ // TLS
0000000000000000000000000000000000000000;;				resp, err := tlsServer.GetAttach(request)
0000000000000000000000000000000000000000;;				assert.NoError(t, err, "testcase=%+v", test)
0000000000000000000000000000000000000000;;				expectedURL := "https://" + testAddr + "/attach/"
0000000000000000000000000000000000000000;;				assert.Contains(t, resp.Url, expectedURL, "testcase=%+v", test)
0000000000000000000000000000000000000000;;				token := strings.TrimPrefix(resp.Url, expectedURL)
0000000000000000000000000000000000000000;;				assertRequestToken(test, tlsServer.(*server).cache, token)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetPortForward(t *testing.T) {
0000000000000000000000000000000000000000;;		podSandboxID := testPodSandboxID
0000000000000000000000000000000000000000;;		request := &runtimeapi.PortForwardRequest{
0000000000000000000000000000000000000000;;			PodSandboxId: podSandboxID,
0000000000000000000000000000000000000000;;			Port:         []int32{1, 2, 3, 4},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		{ // Non-TLS
0000000000000000000000000000000000000000;;			serv, err := NewServer(Config{
0000000000000000000000000000000000000000;;				Addr: testAddr,
0000000000000000000000000000000000000000;;			}, nil)
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;			resp, err := serv.GetPortForward(request)
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;			expectedURL := "http://" + testAddr + "/portforward/"
0000000000000000000000000000000000000000;;			assert.True(t, strings.HasPrefix(resp.Url, expectedURL))
0000000000000000000000000000000000000000;;			token := strings.TrimPrefix(resp.Url, expectedURL)
0000000000000000000000000000000000000000;;			req, ok := serv.(*server).cache.Consume(token)
0000000000000000000000000000000000000000;;			require.True(t, ok, "token %s not found!", token)
0000000000000000000000000000000000000000;;			assert.Equal(t, testPodSandboxID, req.(*runtimeapi.PortForwardRequest).PodSandboxId)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		{ // TLS
0000000000000000000000000000000000000000;;			tlsServer, err := NewServer(Config{
0000000000000000000000000000000000000000;;				Addr:      testAddr,
0000000000000000000000000000000000000000;;				TLSConfig: &tls.Config{},
0000000000000000000000000000000000000000;;			}, nil)
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;			resp, err := tlsServer.GetPortForward(request)
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;			expectedURL := "https://" + testAddr + "/portforward/"
0000000000000000000000000000000000000000;;			assert.True(t, strings.HasPrefix(resp.Url, expectedURL))
0000000000000000000000000000000000000000;;			token := strings.TrimPrefix(resp.Url, expectedURL)
0000000000000000000000000000000000000000;;			req, ok := tlsServer.(*server).cache.Consume(token)
0000000000000000000000000000000000000000;;			require.True(t, ok, "token %s not found!", token)
0000000000000000000000000000000000000000;;			assert.Equal(t, testPodSandboxID, req.(*runtimeapi.PortForwardRequest).PodSandboxId)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServeExec(t *testing.T) {
0000000000000000000000000000000000000000;;		runRemoteCommandTest(t, "exec")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServeAttach(t *testing.T) {
0000000000000000000000000000000000000000;;		runRemoteCommandTest(t, "attach")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServePortForward(t *testing.T) {
0000000000000000000000000000000000000000;;		s, testServer := startTestServer(t)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := s.GetPortForward(&runtimeapi.PortForwardRequest{
0000000000000000000000000000000000000000;;			PodSandboxId: testPodSandboxID,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		reqURL, err := url.Parse(resp.Url)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		transport, upgrader, err := spdy.RoundTripperFor(&restclient.Config{})
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		dialer := spdy.NewDialer(upgrader, &http.Client{Transport: transport}, "POST", reqURL)
0000000000000000000000000000000000000000;;		streamConn, _, err := dialer.Dial(kubeletportforward.ProtocolV1Name)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		defer streamConn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the streams.
0000000000000000000000000000000000000000;;		headers := http.Header{}
0000000000000000000000000000000000000000;;		// Error stream is required, but unused in this test.
0000000000000000000000000000000000000000;;		headers.Set(api.StreamType, api.StreamTypeError)
0000000000000000000000000000000000000000;;		headers.Set(api.PortHeader, strconv.Itoa(testPort))
0000000000000000000000000000000000000000;;		_, err = streamConn.CreateStream(headers)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		// Setup the data stream.
0000000000000000000000000000000000000000;;		headers.Set(api.StreamType, api.StreamTypeData)
0000000000000000000000000000000000000000;;		headers.Set(api.PortHeader, strconv.Itoa(testPort))
0000000000000000000000000000000000000000;;		stream, err := streamConn.CreateStream(headers)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		doClientStreams(t, "portforward", stream, stream, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run the remote command test.
0000000000000000000000000000000000000000;;	// commandType is either "exec" or "attach".
0000000000000000000000000000000000000000;;	func runRemoteCommandTest(t *testing.T, commandType string) {
0000000000000000000000000000000000000000;;		s, testServer := startTestServer(t)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var reqURL *url.URL
0000000000000000000000000000000000000000;;		stdin := true
0000000000000000000000000000000000000000;;		containerID := testContainerID
0000000000000000000000000000000000000000;;		switch commandType {
0000000000000000000000000000000000000000;;		case "exec":
0000000000000000000000000000000000000000;;			resp, err := s.GetExec(&runtimeapi.ExecRequest{
0000000000000000000000000000000000000000;;				ContainerId: containerID,
0000000000000000000000000000000000000000;;				Cmd:         []string{"echo"},
0000000000000000000000000000000000000000;;				Stdin:       stdin,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			require.NoError(t, err)
0000000000000000000000000000000000000000;;			reqURL, err = url.Parse(resp.Url)
0000000000000000000000000000000000000000;;			require.NoError(t, err)
0000000000000000000000000000000000000000;;		case "attach":
0000000000000000000000000000000000000000;;			resp, err := s.GetAttach(&runtimeapi.AttachRequest{
0000000000000000000000000000000000000000;;				ContainerId: containerID,
0000000000000000000000000000000000000000;;				Stdin:       stdin,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			require.NoError(t, err)
0000000000000000000000000000000000000000;;			reqURL, err = url.Parse(resp.Url)
0000000000000000000000000000000000000000;;			require.NoError(t, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stdinR, stdinW := io.Pipe()
0000000000000000000000000000000000000000;;		stdoutR, stdoutW := io.Pipe()
0000000000000000000000000000000000000000;;		stderrR, stderrW := io.Pipe()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer wg.Done()
0000000000000000000000000000000000000000;;			exec, err := remotecommand.NewSPDYExecutor(&restclient.Config{}, "POST", reqURL)
0000000000000000000000000000000000000000;;			require.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			opts := remotecommand.StreamOptions{
0000000000000000000000000000000000000000;;				Stdin:  stdinR,
0000000000000000000000000000000000000000;;				Stdout: stdoutW,
0000000000000000000000000000000000000000;;				Stderr: stderrW,
0000000000000000000000000000000000000000;;				Tty:    false,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			require.NoError(t, exec.Stream(opts))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer wg.Done()
0000000000000000000000000000000000000000;;			doClientStreams(t, commandType, stdinW, stdoutR, stderrR)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Repeat request with the same URL should be a 404.
0000000000000000000000000000000000000000;;		resp, err := http.Get(reqURL.String())
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, http.StatusNotFound, resp.StatusCode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startTestServer(t *testing.T) (Server, *httptest.Server) {
0000000000000000000000000000000000000000;;		var s Server
0000000000000000000000000000000000000000;;		testServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			s.ServeHTTP(w, r)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		cleanup := true
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if cleanup {
0000000000000000000000000000000000000000;;				testServer.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testURL, err := url.Parse(testServer.URL)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rt := newFakeRuntime(t)
0000000000000000000000000000000000000000;;		config := DefaultConfig
0000000000000000000000000000000000000000;;		config.BaseURL = testURL
0000000000000000000000000000000000000000;;		s, err = NewServer(config, rt)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cleanup = false // Caller must close the test server.
0000000000000000000000000000000000000000;;		return s, testServer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		testInput  = "abcdefg"
0000000000000000000000000000000000000000;;		testOutput = "fooBARbaz"
0000000000000000000000000000000000000000;;		testErr    = "ERROR!!!"
0000000000000000000000000000000000000000;;		testPort   = 12345
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFakeRuntime(t *testing.T) *fakeRuntime {
0000000000000000000000000000000000000000;;		return &fakeRuntime{
0000000000000000000000000000000000000000;;			t: t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeRuntime struct {
0000000000000000000000000000000000000000;;		t *testing.T
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeRuntime) Exec(containerID string, cmd []string, stdin io.Reader, stdout, stderr io.WriteCloser, tty bool, resize <-chan remotecommand.TerminalSize) error {
0000000000000000000000000000000000000000;;		assert.Equal(f.t, testContainerID, containerID)
0000000000000000000000000000000000000000;;		doServerStreams(f.t, "exec", stdin, stdout, stderr)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeRuntime) Attach(containerID string, stdin io.Reader, stdout, stderr io.WriteCloser, tty bool, resize <-chan remotecommand.TerminalSize) error {
0000000000000000000000000000000000000000;;		assert.Equal(f.t, testContainerID, containerID)
0000000000000000000000000000000000000000;;		doServerStreams(f.t, "attach", stdin, stdout, stderr)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeRuntime) PortForward(podSandboxID string, port int32, stream io.ReadWriteCloser) error {
0000000000000000000000000000000000000000;;		assert.Equal(f.t, testPodSandboxID, podSandboxID)
0000000000000000000000000000000000000000;;		assert.EqualValues(f.t, testPort, port)
0000000000000000000000000000000000000000;;		doServerStreams(f.t, "portforward", stream, stream, nil)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Send & receive expected input/output. Must be the inverse of doClientStreams.
0000000000000000000000000000000000000000;;	// Function will block until the expected i/o is finished.
0000000000000000000000000000000000000000;;	func doServerStreams(t *testing.T, prefix string, stdin io.Reader, stdout, stderr io.Writer) {
0000000000000000000000000000000000000000;;		if stderr != nil {
0000000000000000000000000000000000000000;;			writeExpected(t, "server stderr", stderr, prefix+testErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		readExpected(t, "server stdin", stdin, prefix+testInput)
0000000000000000000000000000000000000000;;		writeExpected(t, "server stdout", stdout, prefix+testOutput)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Send & receive expected input/output. Must be the inverse of doServerStreams.
0000000000000000000000000000000000000000;;	// Function will block until the expected i/o is finished.
0000000000000000000000000000000000000000;;	func doClientStreams(t *testing.T, prefix string, stdin io.Writer, stdout, stderr io.Reader) {
0000000000000000000000000000000000000000;;		if stderr != nil {
0000000000000000000000000000000000000000;;			readExpected(t, "client stderr", stderr, prefix+testErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		writeExpected(t, "client stdin", stdin, prefix+testInput)
0000000000000000000000000000000000000000;;		readExpected(t, "client stdout", stdout, prefix+testOutput)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read and verify the expected string from the stream.
0000000000000000000000000000000000000000;;	func readExpected(t *testing.T, streamName string, r io.Reader, expected string) {
0000000000000000000000000000000000000000;;		result := make([]byte, len(expected))
0000000000000000000000000000000000000000;;		_, err := io.ReadAtLeast(r, result, len(expected))
0000000000000000000000000000000000000000;;		assert.NoError(t, err, "stream %s", streamName)
0000000000000000000000000000000000000000;;		assert.Equal(t, expected, string(result), "stream %s", streamName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write and verify success of the data over the stream.
0000000000000000000000000000000000000000;;	func writeExpected(t *testing.T, streamName string, w io.Writer, data string) {
0000000000000000000000000000000000000000;;		n, err := io.WriteString(w, data)
0000000000000000000000000000000000000000;;		assert.NoError(t, err, "stream %s", streamName)
0000000000000000000000000000000000000000;;		assert.Equal(t, len(data), n, "stream %s", streamName)
0000000000000000000000000000000000000000;;	}
