0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
bbb7c2f62746d45c0f223ad8947525483e99cbac;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package server
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/websocket"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		dataChannel = iota
0000000000000000000000000000000000000000;;		errorChannel
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServeWSPortForward(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			port          string
0000000000000000000000000000000000000000;;			uid           bool
0000000000000000000000000000000000000000;;			clientData    string
0000000000000000000000000000000000000000;;			containerData string
0000000000000000000000000000000000000000;;			shouldError   bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{port: "", shouldError: true},
0000000000000000000000000000000000000000;;			{port: "abc", shouldError: true},
0000000000000000000000000000000000000000;;			{port: "-1", shouldError: true},
0000000000000000000000000000000000000000;;			{port: "65536", shouldError: true},
0000000000000000000000000000000000000000;;			{port: "0", shouldError: true},
0000000000000000000000000000000000000000;;			{port: "1", shouldError: false},
0000000000000000000000000000000000000000;;			{port: "8000", shouldError: false},
0000000000000000000000000000000000000000;;			{port: "8000", clientData: "client data", containerData: "container data", shouldError: false},
0000000000000000000000000000000000000000;;			{port: "65535", shouldError: false},
0000000000000000000000000000000000000000;;			{port: "65535", uid: true, shouldError: false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podNamespace := "other"
0000000000000000000000000000000000000000;;		podName := "foo"
0000000000000000000000000000000000000000;;		expectedPodName := getPodName(podName, podNamespace)
0000000000000000000000000000000000000000;;		expectedUid := "9b01b80f-8fb4-11e4-95ab-4200af06647"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			fw := newServerTest()
0000000000000000000000000000000000000000;;			defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fw.fakeKubelet.streamingConnectionIdleTimeoutFunc = func() time.Duration {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			portForwardFuncDone := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fw.fakeKubelet.portForwardFunc = func(name string, uid types.UID, port int32, stream io.ReadWriteCloser) error {
0000000000000000000000000000000000000000;;				defer close(portForwardFuncDone)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if e, a := expectedPodName, name; e != a {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: pod name: expected '%v', got '%v'", i, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if e, a := expectedUid, uid; test.uid && e != string(a) {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: uid: expected '%v', got '%v'", i, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				p, err := strconv.ParseInt(test.port, 10, 32)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: error parsing port string '%s': %v", i, test.port, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := int32(p), port; e != a {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: port: expected '%v', got '%v'", i, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if test.clientData != "" {
0000000000000000000000000000000000000000;;					fromClient := make([]byte, 32)
0000000000000000000000000000000000000000;;					n, err := stream.Read(fromClient)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%d: error reading client data: %v", i, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if e, a := test.clientData, string(fromClient[0:n]); e != a {
0000000000000000000000000000000000000000;;						t.Fatalf("%d: client data: expected to receive '%v', got '%v'", i, e, a)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if test.containerData != "" {
0000000000000000000000000000000000000000;;					_, err := stream.Write([]byte(test.containerData))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%d: error writing container data: %v", i, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var url string
0000000000000000000000000000000000000000;;			if test.uid {
0000000000000000000000000000000000000000;;				url = fmt.Sprintf("ws://%s/portForward/%s/%s/%s?port=%s", fw.testHTTPServer.Listener.Addr().String(), podNamespace, podName, expectedUid, test.port)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				url = fmt.Sprintf("ws://%s/portForward/%s/%s?port=%s", fw.testHTTPServer.Listener.Addr().String(), podNamespace, podName, test.port)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ws, err := websocket.Dial(url, "", "http://127.0.0.1/")
0000000000000000000000000000000000000000;;			if test.shouldError {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: websocket dial expected err", i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: websocket dial unexpected err: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			defer ws.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			p, err := strconv.ParseUint(test.port, 10, 16)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: error parsing port string '%s': %v", i, test.port, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p16 := uint16(p)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			channel, data, err := wsRead(ws)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: read failed: expected no error: got %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if channel != dataChannel {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: wrong channel: got %q: expected %q", i, channel, dataChannel)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(data) != binary.Size(p16) {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: wrong data size: got %q: expected %d", i, data, binary.Size(p16))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := p16, binary.LittleEndian.Uint16(data); e != a {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: wrong data: got %q: expected %s", i, data, test.port)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			channel, data, err = wsRead(ws)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: read succeeded: expected no error: got %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if channel != errorChannel {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: wrong channel: got %q: expected %q", i, channel, errorChannel)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(data) != binary.Size(p16) {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: wrong data size: got %q: expected %d", i, data, binary.Size(p16))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := p16, binary.LittleEndian.Uint16(data); e != a {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: wrong data: got %q: expected %s", i, data, test.port)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.clientData != "" {
0000000000000000000000000000000000000000;;				println("writing the client data")
0000000000000000000000000000000000000000;;				err := wsWrite(ws, dataChannel, []byte(test.clientData))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: unexpected error writing client data: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.containerData != "" {
0000000000000000000000000000000000000000;;				_, data, err = wsRead(ws)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: unexpected error reading container data: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := test.containerData, string(data); e != a {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: expected to receive '%v' from container, got '%v'", i, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			<-portForwardFuncDone
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServeWSMultiplePortForward(t *testing.T) {
0000000000000000000000000000000000000000;;		portsText := []string{"7000,8000", "9000"}
0000000000000000000000000000000000000000;;		ports := []uint16{7000, 8000, 9000}
0000000000000000000000000000000000000000;;		podNamespace := "other"
0000000000000000000000000000000000000000;;		podName := "foo"
0000000000000000000000000000000000000000;;		expectedPodName := getPodName(podName, podNamespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fw.fakeKubelet.streamingConnectionIdleTimeoutFunc = func() time.Duration {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		portForwardWG := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		portForwardWG.Add(len(ports))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		portsMutex := sync.Mutex{}
0000000000000000000000000000000000000000;;		portsForwarded := map[int32]struct{}{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fw.fakeKubelet.portForwardFunc = func(name string, uid types.UID, port int32, stream io.ReadWriteCloser) error {
0000000000000000000000000000000000000000;;			defer portForwardWG.Done()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if e, a := expectedPodName, name; e != a {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: pod name: expected '%v', got '%v'", port, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			portsMutex.Lock()
0000000000000000000000000000000000000000;;			portsForwarded[port] = struct{}{}
0000000000000000000000000000000000000000;;			portsMutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fromClient := make([]byte, 32)
0000000000000000000000000000000000000000;;			n, err := stream.Read(fromClient)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: error reading client data: %v", port, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := fmt.Sprintf("client data on port %d", port), string(fromClient[0:n]); e != a {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: client data: expected to receive '%v', got '%v'", port, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err = stream.Write([]byte(fmt.Sprintf("container data on port %d", port)))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: error writing container data: %v", port, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		url := fmt.Sprintf("ws://%s/portForward/%s/%s?", fw.testHTTPServer.Listener.Addr().String(), podNamespace, podName)
0000000000000000000000000000000000000000;;		for _, port := range portsText {
0000000000000000000000000000000000000000;;			url = url + fmt.Sprintf("port=%s&", port)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ws, err := websocket.Dial(url, "", "http://127.0.0.1/")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("websocket dial unexpected err: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer ws.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, port := range ports {
0000000000000000000000000000000000000000;;			channel, data, err := wsRead(ws)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: read failed: expected no error: got %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if int(channel) != i*2+dataChannel {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: wrong channel: got %q: expected %q", i, channel, i*2+dataChannel)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(data) != binary.Size(port) {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: wrong data size: got %q: expected %d", i, data, binary.Size(port))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := port, binary.LittleEndian.Uint16(data); e != a {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: wrong data: got %q: expected %d", i, data, port)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			channel, data, err = wsRead(ws)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: read succeeded: expected no error: got %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if int(channel) != i*2+errorChannel {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: wrong channel: got %q: expected %q", i, channel, i*2+errorChannel)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(data) != binary.Size(port) {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: wrong data size: got %q: expected %d", i, data, binary.Size(port))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := port, binary.LittleEndian.Uint16(data); e != a {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: wrong data: got %q: expected %d", i, data, port)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, port := range ports {
0000000000000000000000000000000000000000;;			println("writing the client data", port)
0000000000000000000000000000000000000000;;			err := wsWrite(ws, byte(i*2+dataChannel), []byte(fmt.Sprintf("client data on port %d", port)))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: unexpected error writing client data: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			channel, data, err := wsRead(ws)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: unexpected error reading container data: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if int(channel) != i*2+dataChannel {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: wrong channel: got %q: expected %q", port, channel, i*2+dataChannel)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := fmt.Sprintf("container data on port %d", port), string(data); e != a {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: expected to receive '%v' from container, got '%v'", i, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		portForwardWG.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		portsMutex.Lock()
0000000000000000000000000000000000000000;;		defer portsMutex.Unlock()
0000000000000000000000000000000000000000;;		if len(ports) != len(portsForwarded) {
0000000000000000000000000000000000000000;;			t.Fatalf("expected to forward %d ports; got %v", len(ports), portsForwarded)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func wsWrite(conn *websocket.Conn, channel byte, data []byte) error {
0000000000000000000000000000000000000000;;		frame := make([]byte, len(data)+1)
0000000000000000000000000000000000000000;;		frame[0] = channel
0000000000000000000000000000000000000000;;		copy(frame[1:], data)
0000000000000000000000000000000000000000;;		err := websocket.Message.Send(conn, frame)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func wsRead(conn *websocket.Conn) (byte, []byte, error) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var data []byte
0000000000000000000000000000000000000000;;			err := websocket.Message.Receive(conn, &data)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(data) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			channel := data[0]
0000000000000000000000000000000000000000;;			data = data[1:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return channel, data, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
