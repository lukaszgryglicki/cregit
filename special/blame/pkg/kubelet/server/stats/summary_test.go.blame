0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
8cc5c4e4dbf3ab2e1d66adabc90e9427533f4d11;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package stats
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/info/v2"
0000000000000000000000000000000000000000;;		fuzz "github.com/google/gofuzz"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		k8sv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		kubestats "k8s.io/kubernetes/pkg/kubelet/apis/stats/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/cm"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/leaky"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Offsets from seed value in generated container stats.
0000000000000000000000000000000000000000;;		offsetCPUUsageCores = iota
0000000000000000000000000000000000000000;;		offsetCPUUsageCoreSeconds
0000000000000000000000000000000000000000;;		offsetMemPageFaults
0000000000000000000000000000000000000000;;		offsetMemMajorPageFaults
0000000000000000000000000000000000000000;;		offsetMemUsageBytes
0000000000000000000000000000000000000000;;		offsetMemRSSBytes
0000000000000000000000000000000000000000;;		offsetMemWorkingSetBytes
0000000000000000000000000000000000000000;;		offsetNetRxBytes
0000000000000000000000000000000000000000;;		offsetNetRxErrors
0000000000000000000000000000000000000000;;		offsetNetTxBytes
0000000000000000000000000000000000000000;;		offsetNetTxErrors
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		timestamp    = time.Now()
0000000000000000000000000000000000000000;;		creationTime = timestamp.Add(-5 * time.Minute)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBuildSummary(t *testing.T) {
0000000000000000000000000000000000000000;;		node := k8sv1.Node{}
0000000000000000000000000000000000000000;;		node.Name = "FooNode"
0000000000000000000000000000000000000000;;		nodeConfig := cm.NodeConfig{
0000000000000000000000000000000000000000;;			RuntimeCgroupsName: "/docker-daemon",
0000000000000000000000000000000000000000;;			SystemCgroupsName:  "/system",
0000000000000000000000000000000000000000;;			KubeletCgroupsName: "/kubelet",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			namespace0 = "test0"
0000000000000000000000000000000000000000;;			namespace2 = "test2"
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			seedRoot           = 0
0000000000000000000000000000000000000000;;			seedRuntime        = 100
0000000000000000000000000000000000000000;;			seedKubelet        = 200
0000000000000000000000000000000000000000;;			seedMisc           = 300
0000000000000000000000000000000000000000;;			seedPod0Infra      = 1000
0000000000000000000000000000000000000000;;			seedPod0Container0 = 2000
0000000000000000000000000000000000000000;;			seedPod0Container1 = 2001
0000000000000000000000000000000000000000;;			seedPod1Infra      = 3000
0000000000000000000000000000000000000000;;			seedPod1Container  = 4000
0000000000000000000000000000000000000000;;			seedPod2Infra      = 5000
0000000000000000000000000000000000000000;;			seedPod2Container  = 6000
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			pName0 = "pod0"
0000000000000000000000000000000000000000;;			pName1 = "pod1"
0000000000000000000000000000000000000000;;			pName2 = "pod0" // ensure pName2 conflicts with pName0, but is in a different namespace
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			cName00 = "c0"
0000000000000000000000000000000000000000;;			cName01 = "c1"
0000000000000000000000000000000000000000;;			cName10 = "c0" // ensure cName10 conflicts with cName02, but is in a different pod
0000000000000000000000000000000000000000;;			cName20 = "c1" // ensure cName20 conflicts with cName01, but is in a different pod + namespace
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			rootfsCapacity    = uint64(10000000)
0000000000000000000000000000000000000000;;			rootfsAvailable   = uint64(5000000)
0000000000000000000000000000000000000000;;			rootfsInodesFree  = uint64(1000)
0000000000000000000000000000000000000000;;			rootfsInodes      = uint64(2000)
0000000000000000000000000000000000000000;;			imagefsCapacity   = uint64(20000000)
0000000000000000000000000000000000000000;;			imagefsAvailable  = uint64(8000000)
0000000000000000000000000000000000000000;;			imagefsInodesFree = uint64(2000)
0000000000000000000000000000000000000000;;			imagefsInodes     = uint64(4000)
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prf0 := kubestats.PodReference{Name: pName0, Namespace: namespace0, UID: "UID" + pName0}
0000000000000000000000000000000000000000;;		prf1 := kubestats.PodReference{Name: pName1, Namespace: namespace0, UID: "UID" + pName1}
0000000000000000000000000000000000000000;;		prf2 := kubestats.PodReference{Name: pName2, Namespace: namespace2, UID: "UID" + pName2}
0000000000000000000000000000000000000000;;		infos := map[string]v2.ContainerInfo{
0000000000000000000000000000000000000000;;			"/":              summaryTestContainerInfo(seedRoot, "", "", ""),
0000000000000000000000000000000000000000;;			"/docker-daemon": summaryTestContainerInfo(seedRuntime, "", "", ""),
0000000000000000000000000000000000000000;;			"/kubelet":       summaryTestContainerInfo(seedKubelet, "", "", ""),
0000000000000000000000000000000000000000;;			"/system":        summaryTestContainerInfo(seedMisc, "", "", ""),
0000000000000000000000000000000000000000;;			// Pod0 - Namespace0
0000000000000000000000000000000000000000;;			"/pod0-i":  summaryTestContainerInfo(seedPod0Infra, pName0, namespace0, leaky.PodInfraContainerName),
0000000000000000000000000000000000000000;;			"/pod0-c0": summaryTestContainerInfo(seedPod0Container0, pName0, namespace0, cName00),
0000000000000000000000000000000000000000;;			"/pod0-c1": summaryTestContainerInfo(seedPod0Container1, pName0, namespace0, cName01),
0000000000000000000000000000000000000000;;			// Pod1 - Namespace0
0000000000000000000000000000000000000000;;			"/pod1-i":  summaryTestContainerInfo(seedPod1Infra, pName1, namespace0, leaky.PodInfraContainerName),
0000000000000000000000000000000000000000;;			"/pod1-c0": summaryTestContainerInfo(seedPod1Container, pName1, namespace0, cName10),
0000000000000000000000000000000000000000;;			// Pod2 - Namespace2
0000000000000000000000000000000000000000;;			"/pod2-i":  summaryTestContainerInfo(seedPod2Infra, pName2, namespace2, leaky.PodInfraContainerName),
0000000000000000000000000000000000000000;;			"/pod2-c0": summaryTestContainerInfo(seedPod2Container, pName2, namespace2, cName20),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		freeRootfsInodes := rootfsInodesFree
0000000000000000000000000000000000000000;;		totalRootfsInodes := rootfsInodes
0000000000000000000000000000000000000000;;		rootfs := v2.FsInfo{
0000000000000000000000000000000000000000;;			Capacity:   rootfsCapacity,
0000000000000000000000000000000000000000;;			Available:  rootfsAvailable,
0000000000000000000000000000000000000000;;			InodesFree: &freeRootfsInodes,
0000000000000000000000000000000000000000;;			Inodes:     &totalRootfsInodes,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		freeImagefsInodes := imagefsInodesFree
0000000000000000000000000000000000000000;;		totalImagefsInodes := imagefsInodes
0000000000000000000000000000000000000000;;		imagefs := v2.FsInfo{
0000000000000000000000000000000000000000;;			Capacity:   imagefsCapacity,
0000000000000000000000000000000000000000;;			Available:  imagefsAvailable,
0000000000000000000000000000000000000000;;			InodesFree: &freeImagefsInodes,
0000000000000000000000000000000000000000;;			Inodes:     &totalImagefsInodes,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// memory limit overrides for each container (used to test available bytes if a memory limit is known)
0000000000000000000000000000000000000000;;		memoryLimitOverrides := map[string]uint64{
0000000000000000000000000000000000000000;;			"/":        uint64(1 << 30),
0000000000000000000000000000000000000000;;			"/pod2-c0": uint64(1 << 15),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for name, memoryLimitOverride := range memoryLimitOverrides {
0000000000000000000000000000000000000000;;			info, found := infos[name]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				t.Errorf("No container defined with name %v", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			info.Spec.Memory.Limit = memoryLimitOverride
0000000000000000000000000000000000000000;;			infos[name] = info
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sb := &summaryBuilder{
0000000000000000000000000000000000000000;;			newFsResourceAnalyzer(&MockStatsProvider{}, time.Minute*5), &node, nodeConfig, rootfs, imagefs, container.ImageStats{}, infos}
0000000000000000000000000000000000000000;;		summary, err := sb.build()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		nodeStats := summary.Node
0000000000000000000000000000000000000000;;		assert.Equal(t, "FooNode", nodeStats.NodeName)
0000000000000000000000000000000000000000;;		assert.EqualValues(t, testTime(creationTime, seedRoot).Unix(), nodeStats.StartTime.Time.Unix())
0000000000000000000000000000000000000000;;		checkCPUStats(t, "Node", seedRoot, nodeStats.CPU)
0000000000000000000000000000000000000000;;		checkMemoryStats(t, "Node", seedRoot, infos["/"], nodeStats.Memory)
0000000000000000000000000000000000000000;;		checkNetworkStats(t, "Node", seedRoot, nodeStats.Network)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		systemSeeds := map[string]int{
0000000000000000000000000000000000000000;;			kubestats.SystemContainerRuntime: seedRuntime,
0000000000000000000000000000000000000000;;			kubestats.SystemContainerKubelet: seedKubelet,
0000000000000000000000000000000000000000;;			kubestats.SystemContainerMisc:    seedMisc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		systemContainerToNodeCgroup := map[string]string{
0000000000000000000000000000000000000000;;			kubestats.SystemContainerRuntime: nodeConfig.RuntimeCgroupsName,
0000000000000000000000000000000000000000;;			kubestats.SystemContainerKubelet: nodeConfig.KubeletCgroupsName,
0000000000000000000000000000000000000000;;			kubestats.SystemContainerMisc:    nodeConfig.SystemCgroupsName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, sys := range nodeStats.SystemContainers {
0000000000000000000000000000000000000000;;			name := sys.Name
0000000000000000000000000000000000000000;;			info := infos[systemContainerToNodeCgroup[name]]
0000000000000000000000000000000000000000;;			seed, found := systemSeeds[name]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				t.Errorf("Unknown SystemContainer: %q", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			assert.EqualValues(t, testTime(creationTime, seed).Unix(), sys.StartTime.Time.Unix(), name+".StartTime")
0000000000000000000000000000000000000000;;			checkCPUStats(t, name, seed, sys.CPU)
0000000000000000000000000000000000000000;;			checkMemoryStats(t, name, seed, info, sys.Memory)
0000000000000000000000000000000000000000;;			assert.Nil(t, sys.Logs, name+".Logs")
0000000000000000000000000000000000000000;;			assert.Nil(t, sys.Rootfs, name+".Rootfs")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.Equal(t, 3, len(summary.Pods))
0000000000000000000000000000000000000000;;		indexPods := make(map[kubestats.PodReference]kubestats.PodStats, len(summary.Pods))
0000000000000000000000000000000000000000;;		for _, pod := range summary.Pods {
0000000000000000000000000000000000000000;;			indexPods[pod.PodRef] = pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Validate Pod0 Results
0000000000000000000000000000000000000000;;		ps, found := indexPods[prf0]
0000000000000000000000000000000000000000;;		assert.True(t, found)
0000000000000000000000000000000000000000;;		assert.Len(t, ps.Containers, 2)
0000000000000000000000000000000000000000;;		indexCon := make(map[string]kubestats.ContainerStats, len(ps.Containers))
0000000000000000000000000000000000000000;;		for _, con := range ps.Containers {
0000000000000000000000000000000000000000;;			indexCon[con.Name] = con
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		con := indexCon[cName00]
0000000000000000000000000000000000000000;;		assert.EqualValues(t, testTime(creationTime, seedPod0Container0).Unix(), con.StartTime.Time.Unix())
0000000000000000000000000000000000000000;;		checkCPUStats(t, "Pod0Container0", seedPod0Container0, con.CPU)
0000000000000000000000000000000000000000;;		checkMemoryStats(t, "Pod0Conainer0", seedPod0Container0, infos["/pod0-c0"], con.Memory)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		con = indexCon[cName01]
0000000000000000000000000000000000000000;;		assert.EqualValues(t, testTime(creationTime, seedPod0Container1).Unix(), con.StartTime.Time.Unix())
0000000000000000000000000000000000000000;;		checkCPUStats(t, "Pod0Container1", seedPod0Container1, con.CPU)
0000000000000000000000000000000000000000;;		checkMemoryStats(t, "Pod0Container1", seedPod0Container1, infos["/pod0-c1"], con.Memory)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.EqualValues(t, testTime(creationTime, seedPod0Infra).Unix(), ps.StartTime.Time.Unix())
0000000000000000000000000000000000000000;;		checkNetworkStats(t, "Pod0", seedPod0Infra, ps.Network)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Validate Pod1 Results
0000000000000000000000000000000000000000;;		ps, found = indexPods[prf1]
0000000000000000000000000000000000000000;;		assert.True(t, found)
0000000000000000000000000000000000000000;;		assert.Len(t, ps.Containers, 1)
0000000000000000000000000000000000000000;;		con = ps.Containers[0]
0000000000000000000000000000000000000000;;		assert.Equal(t, cName10, con.Name)
0000000000000000000000000000000000000000;;		checkCPUStats(t, "Pod1Container0", seedPod1Container, con.CPU)
0000000000000000000000000000000000000000;;		checkMemoryStats(t, "Pod1Container0", seedPod1Container, infos["/pod1-c0"], con.Memory)
0000000000000000000000000000000000000000;;		checkNetworkStats(t, "Pod1", seedPod1Infra, ps.Network)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Validate Pod2 Results
0000000000000000000000000000000000000000;;		ps, found = indexPods[prf2]
0000000000000000000000000000000000000000;;		assert.True(t, found)
0000000000000000000000000000000000000000;;		assert.Len(t, ps.Containers, 1)
0000000000000000000000000000000000000000;;		con = ps.Containers[0]
0000000000000000000000000000000000000000;;		assert.Equal(t, cName20, con.Name)
0000000000000000000000000000000000000000;;		checkCPUStats(t, "Pod2Container0", seedPod2Container, con.CPU)
0000000000000000000000000000000000000000;;		checkMemoryStats(t, "Pod2Container0", seedPod2Container, infos["/pod2-c0"], con.Memory)
0000000000000000000000000000000000000000;;		checkNetworkStats(t, "Pod2", seedPod2Infra, ps.Network)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateCustomMetricSpec() []v1.MetricSpec {
0000000000000000000000000000000000000000;;		f := fuzz.New().NilChance(0).Funcs(
0000000000000000000000000000000000000000;;			func(e *v1.MetricSpec, c fuzz.Continue) {
0000000000000000000000000000000000000000;;				c.Fuzz(&e.Name)
0000000000000000000000000000000000000000;;				switch c.Intn(3) {
0000000000000000000000000000000000000000;;				case 0:
0000000000000000000000000000000000000000;;					e.Type = v1.MetricGauge
0000000000000000000000000000000000000000;;				case 1:
0000000000000000000000000000000000000000;;					e.Type = v1.MetricCumulative
0000000000000000000000000000000000000000;;				case 2:
0000000000000000000000000000000000000000;;					e.Type = v1.MetricDelta
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch c.Intn(2) {
0000000000000000000000000000000000000000;;				case 0:
0000000000000000000000000000000000000000;;					e.Format = v1.IntType
0000000000000000000000000000000000000000;;				case 1:
0000000000000000000000000000000000000000;;					e.Format = v1.FloatType
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				c.Fuzz(&e.Units)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		var ret []v1.MetricSpec
0000000000000000000000000000000000000000;;		f.Fuzz(&ret)
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateCustomMetrics(spec []v1.MetricSpec) map[string][]v1.MetricVal {
0000000000000000000000000000000000000000;;		ret := map[string][]v1.MetricVal{}
0000000000000000000000000000000000000000;;		for _, metricSpec := range spec {
0000000000000000000000000000000000000000;;			f := fuzz.New().NilChance(0).Funcs(
0000000000000000000000000000000000000000;;				func(e *v1.MetricVal, c fuzz.Continue) {
0000000000000000000000000000000000000000;;					switch metricSpec.Format {
0000000000000000000000000000000000000000;;					case v1.IntType:
0000000000000000000000000000000000000000;;						c.Fuzz(&e.IntValue)
0000000000000000000000000000000000000000;;					case v1.FloatType:
0000000000000000000000000000000000000000;;						c.Fuzz(&e.FloatValue)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var metrics []v1.MetricVal
0000000000000000000000000000000000000000;;			f.Fuzz(&metrics)
0000000000000000000000000000000000000000;;			ret[metricSpec.Name] = metrics
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func summaryTestContainerInfo(seed int, podName string, podNamespace string, containerName string) v2.ContainerInfo {
0000000000000000000000000000000000000000;;		labels := map[string]string{}
0000000000000000000000000000000000000000;;		if podName != "" {
0000000000000000000000000000000000000000;;			labels = map[string]string{
0000000000000000000000000000000000000000;;				"io.kubernetes.pod.name":       podName,
0000000000000000000000000000000000000000;;				"io.kubernetes.pod.uid":        "UID" + podName,
0000000000000000000000000000000000000000;;				"io.kubernetes.pod.namespace":  podNamespace,
0000000000000000000000000000000000000000;;				"io.kubernetes.container.name": containerName,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// by default, kernel will set memory.limit_in_bytes to 1 << 63 if not bounded
0000000000000000000000000000000000000000;;		unlimitedMemory := uint64(1 << 63)
0000000000000000000000000000000000000000;;		spec := v2.ContainerSpec{
0000000000000000000000000000000000000000;;			CreationTime: testTime(creationTime, seed),
0000000000000000000000000000000000000000;;			HasCpu:       true,
0000000000000000000000000000000000000000;;			HasMemory:    true,
0000000000000000000000000000000000000000;;			HasNetwork:   true,
0000000000000000000000000000000000000000;;			Labels:       labels,
0000000000000000000000000000000000000000;;			Memory: v2.MemorySpec{
0000000000000000000000000000000000000000;;				Limit: unlimitedMemory,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			CustomMetrics: generateCustomMetricSpec(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stats := v2.ContainerStats{
0000000000000000000000000000000000000000;;			Timestamp: testTime(timestamp, seed),
0000000000000000000000000000000000000000;;			Cpu:       &v1.CpuStats{},
0000000000000000000000000000000000000000;;			CpuInst:   &v2.CpuInstStats{},
0000000000000000000000000000000000000000;;			Memory: &v1.MemoryStats{
0000000000000000000000000000000000000000;;				Usage:      uint64(seed + offsetMemUsageBytes),
0000000000000000000000000000000000000000;;				WorkingSet: uint64(seed + offsetMemWorkingSetBytes),
0000000000000000000000000000000000000000;;				RSS:        uint64(seed + offsetMemRSSBytes),
0000000000000000000000000000000000000000;;				ContainerData: v1.MemoryStatsMemoryData{
0000000000000000000000000000000000000000;;					Pgfault:    uint64(seed + offsetMemPageFaults),
0000000000000000000000000000000000000000;;					Pgmajfault: uint64(seed + offsetMemMajorPageFaults),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Network: &v2.NetworkStats{
0000000000000000000000000000000000000000;;				Interfaces: []v1.InterfaceStats{{
0000000000000000000000000000000000000000;;					Name:     "eth0",
0000000000000000000000000000000000000000;;					RxBytes:  uint64(seed + offsetNetRxBytes),
0000000000000000000000000000000000000000;;					RxErrors: uint64(seed + offsetNetRxErrors),
0000000000000000000000000000000000000000;;					TxBytes:  uint64(seed + offsetNetTxBytes),
0000000000000000000000000000000000000000;;					TxErrors: uint64(seed + offsetNetTxErrors),
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					Name:     "cbr0",
0000000000000000000000000000000000000000;;					RxBytes:  100,
0000000000000000000000000000000000000000;;					RxErrors: 100,
0000000000000000000000000000000000000000;;					TxBytes:  100,
0000000000000000000000000000000000000000;;					TxErrors: 100,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			CustomMetrics: generateCustomMetrics(spec.CustomMetrics),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stats.Cpu.Usage.Total = uint64(seed + offsetCPUUsageCoreSeconds)
0000000000000000000000000000000000000000;;		stats.CpuInst.Usage.Total = uint64(seed + offsetCPUUsageCores)
0000000000000000000000000000000000000000;;		return v2.ContainerInfo{
0000000000000000000000000000000000000000;;			Spec:  spec,
0000000000000000000000000000000000000000;;			Stats: []*v2.ContainerStats{&stats},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testTime(base time.Time, seed int) time.Time {
0000000000000000000000000000000000000000;;		return base.Add(time.Duration(seed) * time.Second)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkNetworkStats(t *testing.T, label string, seed int, stats *kubestats.NetworkStats) {
0000000000000000000000000000000000000000;;		assert.NotNil(t, stats)
0000000000000000000000000000000000000000;;		assert.EqualValues(t, testTime(timestamp, seed).Unix(), stats.Time.Time.Unix(), label+".Net.Time")
0000000000000000000000000000000000000000;;		assert.EqualValues(t, seed+offsetNetRxBytes, *stats.RxBytes, label+".Net.RxBytes")
0000000000000000000000000000000000000000;;		assert.EqualValues(t, seed+offsetNetRxErrors, *stats.RxErrors, label+".Net.RxErrors")
0000000000000000000000000000000000000000;;		assert.EqualValues(t, seed+offsetNetTxBytes, *stats.TxBytes, label+".Net.TxBytes")
0000000000000000000000000000000000000000;;		assert.EqualValues(t, seed+offsetNetTxErrors, *stats.TxErrors, label+".Net.TxErrors")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkCPUStats(t *testing.T, label string, seed int, stats *kubestats.CPUStats) {
0000000000000000000000000000000000000000;;		assert.EqualValues(t, testTime(timestamp, seed).Unix(), stats.Time.Time.Unix(), label+".CPU.Time")
0000000000000000000000000000000000000000;;		assert.EqualValues(t, seed+offsetCPUUsageCores, *stats.UsageNanoCores, label+".CPU.UsageCores")
0000000000000000000000000000000000000000;;		assert.EqualValues(t, seed+offsetCPUUsageCoreSeconds, *stats.UsageCoreNanoSeconds, label+".CPU.UsageCoreSeconds")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkMemoryStats(t *testing.T, label string, seed int, info v2.ContainerInfo, stats *kubestats.MemoryStats) {
0000000000000000000000000000000000000000;;		assert.EqualValues(t, testTime(timestamp, seed).Unix(), stats.Time.Time.Unix(), label+".Mem.Time")
0000000000000000000000000000000000000000;;		assert.EqualValues(t, seed+offsetMemUsageBytes, *stats.UsageBytes, label+".Mem.UsageBytes")
0000000000000000000000000000000000000000;;		assert.EqualValues(t, seed+offsetMemWorkingSetBytes, *stats.WorkingSetBytes, label+".Mem.WorkingSetBytes")
0000000000000000000000000000000000000000;;		assert.EqualValues(t, seed+offsetMemRSSBytes, *stats.RSSBytes, label+".Mem.RSSBytes")
0000000000000000000000000000000000000000;;		assert.EqualValues(t, seed+offsetMemPageFaults, *stats.PageFaults, label+".Mem.PageFaults")
0000000000000000000000000000000000000000;;		assert.EqualValues(t, seed+offsetMemMajorPageFaults, *stats.MajorPageFaults, label+".Mem.MajorPageFaults")
0000000000000000000000000000000000000000;;		if !info.Spec.HasMemory || isMemoryUnlimited(info.Spec.Memory.Limit) {
0000000000000000000000000000000000000000;;			assert.Nil(t, stats.AvailableBytes, label+".Mem.AvailableBytes")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			expected := info.Spec.Memory.Limit - *stats.WorkingSetBytes
0000000000000000000000000000000000000000;;			assert.EqualValues(t, expected, *stats.AvailableBytes, label+".Mem.AvailableBytes")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCustomMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		spec := []v1.MetricSpec{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name:   "qos",
0000000000000000000000000000000000000000;;				Type:   v1.MetricGauge,
0000000000000000000000000000000000000000;;				Format: v1.IntType,
0000000000000000000000000000000000000000;;				Units:  "per second",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name:   "cpuLoad",
0000000000000000000000000000000000000000;;				Type:   v1.MetricCumulative,
0000000000000000000000000000000000000000;;				Format: v1.FloatType,
0000000000000000000000000000000000000000;;				Units:  "count",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		timestamp1 := time.Now()
0000000000000000000000000000000000000000;;		timestamp2 := time.Now().Add(time.Minute)
0000000000000000000000000000000000000000;;		metrics := map[string][]v1.MetricVal{
0000000000000000000000000000000000000000;;			"qos": {
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Timestamp: timestamp1,
0000000000000000000000000000000000000000;;					IntValue:  10,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Timestamp: timestamp2,
0000000000000000000000000000000000000000;;					IntValue:  100,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"cpuLoad": {
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Timestamp:  timestamp1,
0000000000000000000000000000000000000000;;					FloatValue: 1.2,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Timestamp:  timestamp2,
0000000000000000000000000000000000000000;;					FloatValue: 2.1,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cInfo := v2.ContainerInfo{
0000000000000000000000000000000000000000;;			Spec: v2.ContainerSpec{
0000000000000000000000000000000000000000;;				CustomMetrics: spec,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Stats: []*v2.ContainerStats{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					CustomMetrics: metrics,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sb := &summaryBuilder{}
0000000000000000000000000000000000000000;;		assert.Contains(t, sb.containerInfoV2ToUserDefinedMetrics(&cInfo),
0000000000000000000000000000000000000000;;			kubestats.UserDefinedMetric{
0000000000000000000000000000000000000000;;				UserDefinedMetricDescriptor: kubestats.UserDefinedMetricDescriptor{
0000000000000000000000000000000000000000;;					Name:  "qos",
0000000000000000000000000000000000000000;;					Type:  kubestats.MetricGauge,
0000000000000000000000000000000000000000;;					Units: "per second",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Time:  metav1.NewTime(timestamp2),
0000000000000000000000000000000000000000;;				Value: 100,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			kubestats.UserDefinedMetric{
0000000000000000000000000000000000000000;;				UserDefinedMetricDescriptor: kubestats.UserDefinedMetricDescriptor{
0000000000000000000000000000000000000000;;					Name:  "cpuLoad",
0000000000000000000000000000000000000000;;					Type:  kubestats.MetricCumulative,
0000000000000000000000000000000000000000;;					Units: "count",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Time:  metav1.NewTime(timestamp2),
0000000000000000000000000000000000000000;;				Value: 2.1,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	}
