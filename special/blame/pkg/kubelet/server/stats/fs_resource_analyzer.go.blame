0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
11fe0d2921df0a90ecde224aad0db3ceed280ebb;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package stats
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Map to PodVolumeStats pointers since the addresses for map values are not constant and can cause pain
0000000000000000000000000000000000000000;;	// if we need ever to get a pointer to one of the values (e.g. you can't)
0000000000000000000000000000000000000000;;	type Cache map[types.UID]*volumeStatCalculator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fsResourceAnalyzerInterface is for embedding fs functions into ResourceAnalyzer
0000000000000000000000000000000000000000;;	type fsResourceAnalyzerInterface interface {
0000000000000000000000000000000000000000;;		GetPodVolumeStats(uid types.UID) (PodVolumeStats, bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// diskResourceAnalyzer provider stats about fs resource usage
0000000000000000000000000000000000000000;;	type fsResourceAnalyzer struct {
0000000000000000000000000000000000000000;;		statsProvider     StatsProvider
0000000000000000000000000000000000000000;;		calcPeriod        time.Duration
0000000000000000000000000000000000000000;;		cachedVolumeStats atomic.Value
0000000000000000000000000000000000000000;;		startOnce         sync.Once
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ fsResourceAnalyzerInterface = &fsResourceAnalyzer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newFsResourceAnalyzer returns a new fsResourceAnalyzer implementation
0000000000000000000000000000000000000000;;	func newFsResourceAnalyzer(statsProvider StatsProvider, calcVolumePeriod time.Duration) *fsResourceAnalyzer {
0000000000000000000000000000000000000000;;		r := &fsResourceAnalyzer{
0000000000000000000000000000000000000000;;			statsProvider: statsProvider,
0000000000000000000000000000000000000000;;			calcPeriod:    calcVolumePeriod,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.cachedVolumeStats.Store(make(Cache))
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Start eager background caching of volume stats.
0000000000000000000000000000000000000000;;	func (s *fsResourceAnalyzer) Start() {
0000000000000000000000000000000000000000;;		s.startOnce.Do(func() {
0000000000000000000000000000000000000000;;			if s.calcPeriod <= 0 {
0000000000000000000000000000000000000000;;				glog.Info("Volume stats collection disabled.")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Info("Starting FS ResourceAnalyzer")
0000000000000000000000000000000000000000;;			go wait.Forever(func() { s.updateCachedPodVolumeStats() }, s.calcPeriod)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateCachedPodVolumeStats calculates and caches the PodVolumeStats for every Pod known to the kubelet.
0000000000000000000000000000000000000000;;	func (s *fsResourceAnalyzer) updateCachedPodVolumeStats() {
0000000000000000000000000000000000000000;;		oldCache := s.cachedVolumeStats.Load().(Cache)
0000000000000000000000000000000000000000;;		newCache := make(Cache)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Copy existing entries to new map, creating/starting new entries for pods missing from the cache
0000000000000000000000000000000000000000;;		for _, pod := range s.statsProvider.GetPods() {
0000000000000000000000000000000000000000;;			if value, found := oldCache[pod.GetUID()]; !found {
0000000000000000000000000000000000000000;;				newCache[pod.GetUID()] = newVolumeStatCalculator(s.statsProvider, s.calcPeriod, pod).StartOnce()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				newCache[pod.GetUID()] = value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stop entries for pods that have been deleted
0000000000000000000000000000000000000000;;		for uid, entry := range oldCache {
0000000000000000000000000000000000000000;;			if _, found := newCache[uid]; !found {
0000000000000000000000000000000000000000;;				entry.StopOnce()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update the cache reference
0000000000000000000000000000000000000000;;		s.cachedVolumeStats.Store(newCache)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPodVolumeStats returns the PodVolumeStats for a given pod.  Results are looked up from a cache that
0000000000000000000000000000000000000000;;	// is eagerly populated in the background, and never calculated on the fly.
0000000000000000000000000000000000000000;;	func (s *fsResourceAnalyzer) GetPodVolumeStats(uid types.UID) (PodVolumeStats, bool) {
0000000000000000000000000000000000000000;;		cache := s.cachedVolumeStats.Load().(Cache)
0000000000000000000000000000000000000000;;		if statCalc, found := cache[uid]; !found {
0000000000000000000000000000000000000000;;			// TODO: Differentiate between stats being empty
0000000000000000000000000000000000000000;;			// See issue #20679
0000000000000000000000000000000000000000;;			return PodVolumeStats{}, false
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return statCalc.GetLatest()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
