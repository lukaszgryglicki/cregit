0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
8cc5c4e4dbf3ab2e1d66adabc90e9427533f4d11;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package stats
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		kubetypes "k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		stats "k8s.io/kubernetes/pkg/kubelet/apis/stats/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/cm"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/leaky"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/network"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cadvisorapiv1 "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		cadvisorapiv2 "github.com/google/cadvisor/info/v2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SummaryProvider interface {
0000000000000000000000000000000000000000;;		// Get provides a new Summary using the latest results from cadvisor
0000000000000000000000000000000000000000;;		Get() (*stats.Summary, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type summaryProviderImpl struct {
0000000000000000000000000000000000000000;;		provider           StatsProvider
0000000000000000000000000000000000000000;;		fsResourceAnalyzer fsResourceAnalyzerInterface
0000000000000000000000000000000000000000;;		runtime            container.Runtime
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ SummaryProvider = &summaryProviderImpl{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSummaryProvider returns a new SummaryProvider
0000000000000000000000000000000000000000;;	func NewSummaryProvider(statsProvider StatsProvider, fsResourceAnalyzer fsResourceAnalyzerInterface, cruntime container.Runtime) SummaryProvider {
0000000000000000000000000000000000000000;;		return &summaryProviderImpl{statsProvider, fsResourceAnalyzer, cruntime}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get implements the SummaryProvider interface
0000000000000000000000000000000000000000;;	// Query cadvisor for the latest resource metrics and build into a summary
0000000000000000000000000000000000000000;;	func (sp *summaryProviderImpl) Get() (*stats.Summary, error) {
0000000000000000000000000000000000000000;;		options := cadvisorapiv2.RequestOptions{
0000000000000000000000000000000000000000;;			IdType:    cadvisorapiv2.TypeName,
0000000000000000000000000000000000000000;;			Count:     2, // 2 samples are needed to compute "instantaneous" CPU
0000000000000000000000000000000000000000;;			Recursive: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		infos, err := sp.provider.GetContainerInfoV2("/", options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if _, ok := infos["/"]; ok {
0000000000000000000000000000000000000000;;				// If the failure is partial, log it and return a best-effort response.
0000000000000000000000000000000000000000;;				glog.Errorf("Partial failure issuing GetContainerInfoV2: %v", err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("failed GetContainerInfoV2: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(tallclair): Consider returning a best-effort response if any of the following errors
0000000000000000000000000000000000000000;;		// occur.
0000000000000000000000000000000000000000;;		node, err := sp.provider.GetNode()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed GetNode: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeConfig := sp.provider.GetNodeConfig()
0000000000000000000000000000000000000000;;		rootFsInfo, err := sp.provider.RootFsInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed RootFsInfo: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		imageFsInfo, err := sp.provider.ImagesFsInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed DockerImagesFsInfo: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		imageStats, err := sp.runtime.ImageStats()
0000000000000000000000000000000000000000;;		if err != nil || imageStats == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed ImageStats: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sb := &summaryBuilder{sp.fsResourceAnalyzer, node, nodeConfig, rootFsInfo, imageFsInfo, *imageStats, infos}
0000000000000000000000000000000000000000;;		return sb.build()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// summaryBuilder aggregates the datastructures provided by cadvisor into a Summary result
0000000000000000000000000000000000000000;;	type summaryBuilder struct {
0000000000000000000000000000000000000000;;		fsResourceAnalyzer fsResourceAnalyzerInterface
0000000000000000000000000000000000000000;;		node               *v1.Node
0000000000000000000000000000000000000000;;		nodeConfig         cm.NodeConfig
0000000000000000000000000000000000000000;;		rootFsInfo         cadvisorapiv2.FsInfo
0000000000000000000000000000000000000000;;		imageFsInfo        cadvisorapiv2.FsInfo
0000000000000000000000000000000000000000;;		imageStats         container.ImageStats
0000000000000000000000000000000000000000;;		infos              map[string]cadvisorapiv2.ContainerInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// build returns a Summary from aggregating the input data
0000000000000000000000000000000000000000;;	func (sb *summaryBuilder) build() (*stats.Summary, error) {
0000000000000000000000000000000000000000;;		rootInfo, found := sb.infos["/"]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Missing stats for root container")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var nodeFsInodesUsed *uint64
0000000000000000000000000000000000000000;;		if sb.rootFsInfo.Inodes != nil && sb.rootFsInfo.InodesFree != nil {
0000000000000000000000000000000000000000;;			nodeFsIU := *sb.rootFsInfo.Inodes - *sb.rootFsInfo.InodesFree
0000000000000000000000000000000000000000;;			nodeFsInodesUsed = &nodeFsIU
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var imageFsInodesUsed *uint64
0000000000000000000000000000000000000000;;		if sb.imageFsInfo.Inodes != nil && sb.imageFsInfo.InodesFree != nil {
0000000000000000000000000000000000000000;;			imageFsIU := *sb.imageFsInfo.Inodes - *sb.imageFsInfo.InodesFree
0000000000000000000000000000000000000000;;			imageFsInodesUsed = &imageFsIU
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rootStats := sb.containerInfoV2ToStats("", &rootInfo)
0000000000000000000000000000000000000000;;		cStats, _ := sb.latestContainerStats(&rootInfo)
0000000000000000000000000000000000000000;;		nodeStats := stats.NodeStats{
0000000000000000000000000000000000000000;;			NodeName: sb.node.Name,
0000000000000000000000000000000000000000;;			CPU:      rootStats.CPU,
0000000000000000000000000000000000000000;;			Memory:   rootStats.Memory,
0000000000000000000000000000000000000000;;			Network:  sb.containerInfoV2ToNetworkStats("node:"+sb.node.Name, &rootInfo),
0000000000000000000000000000000000000000;;			Fs: &stats.FsStats{
0000000000000000000000000000000000000000;;				Time:           metav1.NewTime(cStats.Timestamp),
0000000000000000000000000000000000000000;;				AvailableBytes: &sb.rootFsInfo.Available,
0000000000000000000000000000000000000000;;				CapacityBytes:  &sb.rootFsInfo.Capacity,
0000000000000000000000000000000000000000;;				UsedBytes:      &sb.rootFsInfo.Usage,
0000000000000000000000000000000000000000;;				InodesFree:     sb.rootFsInfo.InodesFree,
0000000000000000000000000000000000000000;;				Inodes:         sb.rootFsInfo.Inodes,
0000000000000000000000000000000000000000;;				InodesUsed:     nodeFsInodesUsed,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			StartTime: rootStats.StartTime,
0000000000000000000000000000000000000000;;			Runtime: &stats.RuntimeStats{
0000000000000000000000000000000000000000;;				ImageFs: &stats.FsStats{
0000000000000000000000000000000000000000;;					Time:           metav1.NewTime(cStats.Timestamp),
0000000000000000000000000000000000000000;;					AvailableBytes: &sb.imageFsInfo.Available,
0000000000000000000000000000000000000000;;					CapacityBytes:  &sb.imageFsInfo.Capacity,
0000000000000000000000000000000000000000;;					UsedBytes:      &sb.imageStats.TotalStorageBytes,
0000000000000000000000000000000000000000;;					InodesFree:     sb.imageFsInfo.InodesFree,
0000000000000000000000000000000000000000;;					Inodes:         sb.imageFsInfo.Inodes,
0000000000000000000000000000000000000000;;					InodesUsed:     imageFsInodesUsed,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		systemContainers := map[string]string{
0000000000000000000000000000000000000000;;			stats.SystemContainerKubelet: sb.nodeConfig.KubeletCgroupsName,
0000000000000000000000000000000000000000;;			stats.SystemContainerRuntime: sb.nodeConfig.RuntimeCgroupsName,
0000000000000000000000000000000000000000;;			stats.SystemContainerMisc:    sb.nodeConfig.SystemCgroupsName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for sys, name := range systemContainers {
0000000000000000000000000000000000000000;;			if info, ok := sb.infos[name]; ok {
0000000000000000000000000000000000000000;;				sysCont := sb.containerInfoV2ToStats(sys, &info)
0000000000000000000000000000000000000000;;				// System containers don't have a filesystem associated with them.
0000000000000000000000000000000000000000;;				sysCont.Rootfs = nil
0000000000000000000000000000000000000000;;				sysCont.Logs = nil
0000000000000000000000000000000000000000;;				nodeStats.SystemContainers = append(nodeStats.SystemContainers, sysCont)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		summary := stats.Summary{
0000000000000000000000000000000000000000;;			Node: nodeStats,
0000000000000000000000000000000000000000;;			Pods: sb.buildSummaryPods(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &summary, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// containerInfoV2FsStats populates the container fs stats
0000000000000000000000000000000000000000;;	func (sb *summaryBuilder) containerInfoV2FsStats(
0000000000000000000000000000000000000000;;		info *cadvisorapiv2.ContainerInfo,
0000000000000000000000000000000000000000;;		cs *stats.ContainerStats) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lcs, found := sb.latestContainerStats(info)
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The container logs live on the node rootfs device
0000000000000000000000000000000000000000;;		cs.Logs = &stats.FsStats{
0000000000000000000000000000000000000000;;			Time:           metav1.NewTime(lcs.Timestamp),
0000000000000000000000000000000000000000;;			AvailableBytes: &sb.rootFsInfo.Available,
0000000000000000000000000000000000000000;;			CapacityBytes:  &sb.rootFsInfo.Capacity,
0000000000000000000000000000000000000000;;			InodesFree:     sb.rootFsInfo.InodesFree,
0000000000000000000000000000000000000000;;			Inodes:         sb.rootFsInfo.Inodes,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sb.rootFsInfo.Inodes != nil && sb.rootFsInfo.InodesFree != nil {
0000000000000000000000000000000000000000;;			logsInodesUsed := *sb.rootFsInfo.Inodes - *sb.rootFsInfo.InodesFree
0000000000000000000000000000000000000000;;			cs.Logs.InodesUsed = &logsInodesUsed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The container rootFs lives on the imageFs devices (which may not be the node root fs)
0000000000000000000000000000000000000000;;		cs.Rootfs = &stats.FsStats{
0000000000000000000000000000000000000000;;			Time:           metav1.NewTime(lcs.Timestamp),
0000000000000000000000000000000000000000;;			AvailableBytes: &sb.imageFsInfo.Available,
0000000000000000000000000000000000000000;;			CapacityBytes:  &sb.imageFsInfo.Capacity,
0000000000000000000000000000000000000000;;			InodesFree:     sb.imageFsInfo.InodesFree,
0000000000000000000000000000000000000000;;			Inodes:         sb.imageFsInfo.Inodes,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cfs := lcs.Filesystem
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cfs != nil {
0000000000000000000000000000000000000000;;			if cfs.BaseUsageBytes != nil {
0000000000000000000000000000000000000000;;				rootfsUsage := *cfs.BaseUsageBytes
0000000000000000000000000000000000000000;;				cs.Rootfs.UsedBytes = &rootfsUsage
0000000000000000000000000000000000000000;;				if cfs.TotalUsageBytes != nil {
0000000000000000000000000000000000000000;;					logsUsage := *cfs.TotalUsageBytes - *cfs.BaseUsageBytes
0000000000000000000000000000000000000000;;					cs.Logs.UsedBytes = &logsUsage
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cfs.InodeUsage != nil {
0000000000000000000000000000000000000000;;				rootInodes := *cfs.InodeUsage
0000000000000000000000000000000000000000;;				cs.Rootfs.InodesUsed = &rootInodes
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// latestContainerStats returns the latest container stats from cadvisor, or nil if none exist
0000000000000000000000000000000000000000;;	func (sb *summaryBuilder) latestContainerStats(info *cadvisorapiv2.ContainerInfo) (*cadvisorapiv2.ContainerStats, bool) {
0000000000000000000000000000000000000000;;		stats := info.Stats
0000000000000000000000000000000000000000;;		if len(stats) < 1 {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		latest := stats[len(stats)-1]
0000000000000000000000000000000000000000;;		if latest == nil {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return latest, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildSummaryPods aggregates and returns the container stats in cinfos by the Pod managing the container.
0000000000000000000000000000000000000000;;	// Containers not managed by a Pod are omitted.
0000000000000000000000000000000000000000;;	func (sb *summaryBuilder) buildSummaryPods() []stats.PodStats {
0000000000000000000000000000000000000000;;		// Map each container to a pod and update the PodStats with container data
0000000000000000000000000000000000000000;;		podToStats := map[stats.PodReference]*stats.PodStats{}
0000000000000000000000000000000000000000;;		for key, cinfo := range sb.infos {
0000000000000000000000000000000000000000;;			// on systemd using devicemapper each mount into the container has an associated cgroup.
0000000000000000000000000000000000000000;;			// we ignore them to ensure we do not get duplicate entries in our summary.
0000000000000000000000000000000000000000;;			// for details on .mount units: http://man7.org/linux/man-pages/man5/systemd.mount.5.html
0000000000000000000000000000000000000000;;			if strings.HasSuffix(key, ".mount") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Build the Pod key if this container is managed by a Pod
0000000000000000000000000000000000000000;;			if !sb.isPodManagedContainer(&cinfo) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ref := sb.buildPodRef(&cinfo)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Lookup the PodStats for the pod using the PodRef.  If none exists, initialize a new entry.
0000000000000000000000000000000000000000;;			podStats, found := podToStats[ref]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				podStats = &stats.PodStats{PodRef: ref}
0000000000000000000000000000000000000000;;				podToStats[ref] = podStats
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Update the PodStats entry with the stats from the container by adding it to stats.Containers
0000000000000000000000000000000000000000;;			containerName := types.GetContainerName(cinfo.Spec.Labels)
0000000000000000000000000000000000000000;;			if containerName == leaky.PodInfraContainerName {
0000000000000000000000000000000000000000;;				// Special case for infrastructure container which is hidden from the user and has network stats
0000000000000000000000000000000000000000;;				podStats.Network = sb.containerInfoV2ToNetworkStats("pod:"+ref.Namespace+"_"+ref.Name, &cinfo)
0000000000000000000000000000000000000000;;				podStats.StartTime = metav1.NewTime(cinfo.Spec.CreationTime)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				podStats.Containers = append(podStats.Containers, sb.containerInfoV2ToStats(containerName, &cinfo))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add each PodStats to the result
0000000000000000000000000000000000000000;;		result := make([]stats.PodStats, 0, len(podToStats))
0000000000000000000000000000000000000000;;		for _, podStats := range podToStats {
0000000000000000000000000000000000000000;;			// Lookup the volume stats for each pod
0000000000000000000000000000000000000000;;			podUID := kubetypes.UID(podStats.PodRef.UID)
0000000000000000000000000000000000000000;;			if vstats, found := sb.fsResourceAnalyzer.GetPodVolumeStats(podUID); found {
0000000000000000000000000000000000000000;;				podStats.VolumeStats = vstats.Volumes
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = append(result, *podStats)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildPodRef returns a PodReference that identifies the Pod managing cinfo
0000000000000000000000000000000000000000;;	func (sb *summaryBuilder) buildPodRef(cinfo *cadvisorapiv2.ContainerInfo) stats.PodReference {
0000000000000000000000000000000000000000;;		podName := types.GetPodName(cinfo.Spec.Labels)
0000000000000000000000000000000000000000;;		podNamespace := types.GetPodNamespace(cinfo.Spec.Labels)
0000000000000000000000000000000000000000;;		podUID := types.GetPodUID(cinfo.Spec.Labels)
0000000000000000000000000000000000000000;;		return stats.PodReference{Name: podName, Namespace: podNamespace, UID: podUID}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isPodManagedContainer returns true if the cinfo container is managed by a Pod
0000000000000000000000000000000000000000;;	func (sb *summaryBuilder) isPodManagedContainer(cinfo *cadvisorapiv2.ContainerInfo) bool {
0000000000000000000000000000000000000000;;		podName := types.GetPodName(cinfo.Spec.Labels)
0000000000000000000000000000000000000000;;		podNamespace := types.GetPodNamespace(cinfo.Spec.Labels)
0000000000000000000000000000000000000000;;		managed := podName != "" && podNamespace != ""
0000000000000000000000000000000000000000;;		if !managed && podName != podNamespace {
0000000000000000000000000000000000000000;;			glog.Warningf(
0000000000000000000000000000000000000000;;				"Expect container to have either both podName (%s) and podNamespace (%s) labels, or neither.",
0000000000000000000000000000000000000000;;				podName, podNamespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return managed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sb *summaryBuilder) containerInfoV2ToStats(
0000000000000000000000000000000000000000;;		name string,
0000000000000000000000000000000000000000;;		info *cadvisorapiv2.ContainerInfo) stats.ContainerStats {
0000000000000000000000000000000000000000;;		cStats := stats.ContainerStats{
0000000000000000000000000000000000000000;;			StartTime: metav1.NewTime(info.Spec.CreationTime),
0000000000000000000000000000000000000000;;			Name:      name,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cstat, found := sb.latestContainerStats(info)
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return cStats
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if info.Spec.HasCpu {
0000000000000000000000000000000000000000;;			cpuStats := stats.CPUStats{
0000000000000000000000000000000000000000;;				Time: metav1.NewTime(cstat.Timestamp),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cstat.CpuInst != nil {
0000000000000000000000000000000000000000;;				cpuStats.UsageNanoCores = &cstat.CpuInst.Usage.Total
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cstat.Cpu != nil {
0000000000000000000000000000000000000000;;				cpuStats.UsageCoreNanoSeconds = &cstat.Cpu.Usage.Total
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cStats.CPU = &cpuStats
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if info.Spec.HasMemory {
0000000000000000000000000000000000000000;;			pageFaults := cstat.Memory.ContainerData.Pgfault
0000000000000000000000000000000000000000;;			majorPageFaults := cstat.Memory.ContainerData.Pgmajfault
0000000000000000000000000000000000000000;;			cStats.Memory = &stats.MemoryStats{
0000000000000000000000000000000000000000;;				Time:            metav1.NewTime(cstat.Timestamp),
0000000000000000000000000000000000000000;;				UsageBytes:      &cstat.Memory.Usage,
0000000000000000000000000000000000000000;;				WorkingSetBytes: &cstat.Memory.WorkingSet,
0000000000000000000000000000000000000000;;				RSSBytes:        &cstat.Memory.RSS,
0000000000000000000000000000000000000000;;				PageFaults:      &pageFaults,
0000000000000000000000000000000000000000;;				MajorPageFaults: &majorPageFaults,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// availableBytes = memory  limit (if known) - workingset
0000000000000000000000000000000000000000;;			if !isMemoryUnlimited(info.Spec.Memory.Limit) {
0000000000000000000000000000000000000000;;				availableBytes := info.Spec.Memory.Limit - cstat.Memory.WorkingSet
0000000000000000000000000000000000000000;;				cStats.Memory.AvailableBytes = &availableBytes
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sb.containerInfoV2FsStats(info, &cStats)
0000000000000000000000000000000000000000;;		cStats.UserDefinedMetrics = sb.containerInfoV2ToUserDefinedMetrics(info)
0000000000000000000000000000000000000000;;		return cStats
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Size after which we consider memory to be "unlimited". This is not
0000000000000000000000000000000000000000;;	// MaxInt64 due to rounding by the kernel.
0000000000000000000000000000000000000000;;	// TODO: cadvisor should export this https://github.com/google/cadvisor/blob/master/metrics/prometheus.go#L596
0000000000000000000000000000000000000000;;	const maxMemorySize = uint64(1 << 62)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isMemoryUnlimited(v uint64) bool {
0000000000000000000000000000000000000000;;		return v > maxMemorySize
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sb *summaryBuilder) containerInfoV2ToNetworkStats(name string, info *cadvisorapiv2.ContainerInfo) *stats.NetworkStats {
0000000000000000000000000000000000000000;;		if !info.Spec.HasNetwork {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cstat, found := sb.latestContainerStats(info)
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, inter := range cstat.Network.Interfaces {
0000000000000000000000000000000000000000;;			if inter.Name == network.DefaultInterfaceName {
0000000000000000000000000000000000000000;;				return &stats.NetworkStats{
0000000000000000000000000000000000000000;;					Time:     metav1.NewTime(cstat.Timestamp),
0000000000000000000000000000000000000000;;					RxBytes:  &inter.RxBytes,
0000000000000000000000000000000000000000;;					RxErrors: &inter.RxErrors,
0000000000000000000000000000000000000000;;					TxBytes:  &inter.TxBytes,
0000000000000000000000000000000000000000;;					TxErrors: &inter.TxErrors,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Missing default interface %q for %s", network.DefaultInterfaceName, name)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sb *summaryBuilder) containerInfoV2ToUserDefinedMetrics(info *cadvisorapiv2.ContainerInfo) []stats.UserDefinedMetric {
0000000000000000000000000000000000000000;;		type specVal struct {
0000000000000000000000000000000000000000;;			ref     stats.UserDefinedMetricDescriptor
0000000000000000000000000000000000000000;;			valType cadvisorapiv1.DataType
0000000000000000000000000000000000000000;;			time    time.Time
0000000000000000000000000000000000000000;;			value   float64
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		udmMap := map[string]*specVal{}
0000000000000000000000000000000000000000;;		for _, spec := range info.Spec.CustomMetrics {
0000000000000000000000000000000000000000;;			udmMap[spec.Name] = &specVal{
0000000000000000000000000000000000000000;;				ref: stats.UserDefinedMetricDescriptor{
0000000000000000000000000000000000000000;;					Name:  spec.Name,
0000000000000000000000000000000000000000;;					Type:  stats.UserDefinedMetricType(spec.Type),
0000000000000000000000000000000000000000;;					Units: spec.Units,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				valType: spec.Format,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, stat := range info.Stats {
0000000000000000000000000000000000000000;;			for name, values := range stat.CustomMetrics {
0000000000000000000000000000000000000000;;				specVal, ok := udmMap[name]
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					glog.Warningf("spec for custom metric %q is missing from cAdvisor output. Spec: %+v, Metrics: %+v", name, info.Spec, stat.CustomMetrics)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, value := range values {
0000000000000000000000000000000000000000;;					// Pick the most recent value
0000000000000000000000000000000000000000;;					if value.Timestamp.Before(specVal.time) {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					specVal.time = value.Timestamp
0000000000000000000000000000000000000000;;					specVal.value = value.FloatValue
0000000000000000000000000000000000000000;;					if specVal.valType == cadvisorapiv1.IntType {
0000000000000000000000000000000000000000;;						specVal.value = float64(value.IntValue)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var udm []stats.UserDefinedMetric
0000000000000000000000000000000000000000;;		for _, specVal := range udmMap {
0000000000000000000000000000000000000000;;			udm = append(udm, stats.UserDefinedMetric{
0000000000000000000000000000000000000000;;				UserDefinedMetricDescriptor: specVal.ref,
0000000000000000000000000000000000000000;;				Time:  metav1.NewTime(specVal.time),
0000000000000000000000000000000000000000;;				Value: specVal.value,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return udm
0000000000000000000000000000000000000000;;	}
