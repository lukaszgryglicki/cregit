0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
bc7cfe061835e15896f6dff00883de6c8108993a;pkg/kubelet/server/stats/volume_stat_caculator.go[pkg/kubelet/server/stats/volume_stat_caculator.go][pkg/kubelet/server/stats/volume_stat_calculator.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package stats
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		stats "k8s.io/kubernetes/pkg/kubelet/apis/stats/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/format"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// volumeStatCalculator calculates volume metrics for a given pod periodically in the background and caches the result
0000000000000000000000000000000000000000;;	type volumeStatCalculator struct {
0000000000000000000000000000000000000000;;		statsProvider StatsProvider
0000000000000000000000000000000000000000;;		jitterPeriod  time.Duration
0000000000000000000000000000000000000000;;		pod           *v1.Pod
0000000000000000000000000000000000000000;;		stopChannel   chan struct{}
0000000000000000000000000000000000000000;;		startO        sync.Once
0000000000000000000000000000000000000000;;		stopO         sync.Once
0000000000000000000000000000000000000000;;		latest        atomic.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodVolumeStats encapsulates all VolumeStats for a pod
0000000000000000000000000000000000000000;;	type PodVolumeStats struct {
0000000000000000000000000000000000000000;;		Volumes []stats.VolumeStats
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newVolumeStatCalculator creates a new VolumeStatCalculator
0000000000000000000000000000000000000000;;	func newVolumeStatCalculator(statsProvider StatsProvider, jitterPeriod time.Duration, pod *v1.Pod) *volumeStatCalculator {
0000000000000000000000000000000000000000;;		return &volumeStatCalculator{
0000000000000000000000000000000000000000;;			statsProvider: statsProvider,
0000000000000000000000000000000000000000;;			jitterPeriod:  jitterPeriod,
0000000000000000000000000000000000000000;;			pod:           pod,
0000000000000000000000000000000000000000;;			stopChannel:   make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StartOnce starts pod volume calc that will occur periodically in the background until s.StopOnce is called
0000000000000000000000000000000000000000;;	func (s *volumeStatCalculator) StartOnce() *volumeStatCalculator {
0000000000000000000000000000000000000000;;		s.startO.Do(func() {
0000000000000000000000000000000000000000;;			go wait.JitterUntil(func() {
0000000000000000000000000000000000000000;;				s.calcAndStoreStats()
0000000000000000000000000000000000000000;;			}, s.jitterPeriod, 1.0, true, s.stopChannel)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StopOnce stops background pod volume calculation.  Will not stop a currently executing calculations until
0000000000000000000000000000000000000000;;	// they complete their current iteration.
0000000000000000000000000000000000000000;;	func (s *volumeStatCalculator) StopOnce() *volumeStatCalculator {
0000000000000000000000000000000000000000;;		s.stopO.Do(func() {
0000000000000000000000000000000000000000;;			close(s.stopChannel)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getLatest returns the most recent PodVolumeStats from the cache
0000000000000000000000000000000000000000;;	func (s *volumeStatCalculator) GetLatest() (PodVolumeStats, bool) {
0000000000000000000000000000000000000000;;		if result := s.latest.Load(); result == nil {
0000000000000000000000000000000000000000;;			return PodVolumeStats{}, false
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return result.(PodVolumeStats), true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// calcAndStoreStats calculates PodVolumeStats for a given pod and writes the result to the s.latest cache.
0000000000000000000000000000000000000000;;	func (s *volumeStatCalculator) calcAndStoreStats() {
0000000000000000000000000000000000000000;;		// Find all Volumes for the Pod
0000000000000000000000000000000000000000;;		volumes, found := s.statsProvider.ListVolumesForPod(s.pod.UID)
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Call GetMetrics on each Volume and copy the result to a new VolumeStats.FsStats
0000000000000000000000000000000000000000;;		stats := make([]stats.VolumeStats, 0, len(volumes))
0000000000000000000000000000000000000000;;		for name, v := range volumes {
0000000000000000000000000000000000000000;;			metric, err := v.GetMetrics()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// Expected for Volumes that don't support Metrics
0000000000000000000000000000000000000000;;				if !volume.IsNotSupported(err) {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Failed to calculate volume metrics for pod %s volume %s: %+v", format.Pod(s.pod), name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			stats = append(stats, s.parsePodVolumeStats(name, metric))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Store the new stats
0000000000000000000000000000000000000000;;		s.latest.Store(PodVolumeStats{Volumes: stats})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parsePodVolumeStats converts (internal) volume.Metrics to (external) stats.VolumeStats structures
0000000000000000000000000000000000000000;;	func (s *volumeStatCalculator) parsePodVolumeStats(podName string, metric *volume.Metrics) stats.VolumeStats {
0000000000000000000000000000000000000000;;		available := uint64(metric.Available.Value())
0000000000000000000000000000000000000000;;		capacity := uint64(metric.Capacity.Value())
0000000000000000000000000000000000000000;;		used := uint64(metric.Used.Value())
0000000000000000000000000000000000000000;;		inodes := uint64(metric.Inodes.Value())
0000000000000000000000000000000000000000;;		inodesFree := uint64(metric.InodesFree.Value())
0000000000000000000000000000000000000000;;		inodesUsed := uint64(metric.InodesUsed.Value())
0000000000000000000000000000000000000000;;		return stats.VolumeStats{
0000000000000000000000000000000000000000;;			Name: podName,
0000000000000000000000000000000000000000;;			FsStats: stats.FsStats{Time: metric.Time, AvailableBytes: &available, CapacityBytes: &capacity,
0000000000000000000000000000000000000000;;				UsedBytes: &used, Inodes: &inodes, InodesFree: &inodesFree, InodesUsed: &inodesUsed},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
