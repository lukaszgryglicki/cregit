0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
537edcb5faac48ba5c0785f0c3d693a848cf3a78;pkg/kubelet/kubelet_server_test.go[pkg/kubelet/kubelet_server_test.go][pkg/kubelet/server/server_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package server
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/http/httputil"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cadvisorapi "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		cadvisorapiv2 "github.com/google/cadvisor/info/v2"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/require"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrs "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream/spdy"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/remotecommand"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/cm"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		kubecontainertesting "k8s.io/kubernetes/pkg/kubelet/container/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/server/portforward"
0000000000000000000000000000000000000000;;		remotecommandserver "k8s.io/kubernetes/pkg/kubelet/server/remotecommand"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/server/stats"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		testUID = "9b01b80f-8fb4-11e4-95ab-4200af06647"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeKubelet struct {
0000000000000000000000000000000000000000;;		podByNameFunc                      func(namespace, name string) (*v1.Pod, bool)
0000000000000000000000000000000000000000;;		containerInfoFunc                  func(podFullName string, uid types.UID, containerName string, req *cadvisorapi.ContainerInfoRequest) (*cadvisorapi.ContainerInfo, error)
0000000000000000000000000000000000000000;;		rawInfoFunc                        func(query *cadvisorapi.ContainerInfoRequest) (map[string]*cadvisorapi.ContainerInfo, error)
0000000000000000000000000000000000000000;;		machineInfoFunc                    func() (*cadvisorapi.MachineInfo, error)
0000000000000000000000000000000000000000;;		podsFunc                           func() []*v1.Pod
0000000000000000000000000000000000000000;;		runningPodsFunc                    func() ([]*v1.Pod, error)
0000000000000000000000000000000000000000;;		logFunc                            func(w http.ResponseWriter, req *http.Request)
0000000000000000000000000000000000000000;;		runFunc                            func(podFullName string, uid types.UID, containerName string, cmd []string) ([]byte, error)
0000000000000000000000000000000000000000;;		execFunc                           func(pod string, uid types.UID, container string, cmd []string, in io.Reader, out, err io.WriteCloser, tty bool) error
0000000000000000000000000000000000000000;;		attachFunc                         func(pod string, uid types.UID, container string, in io.Reader, out, err io.WriteCloser, tty bool) error
0000000000000000000000000000000000000000;;		portForwardFunc                    func(name string, uid types.UID, port int32, stream io.ReadWriteCloser) error
0000000000000000000000000000000000000000;;		containerLogsFunc                  func(podFullName, containerName string, logOptions *v1.PodLogOptions, stdout, stderr io.Writer) error
0000000000000000000000000000000000000000;;		streamingConnectionIdleTimeoutFunc func() time.Duration
0000000000000000000000000000000000000000;;		hostnameFunc                       func() string
0000000000000000000000000000000000000000;;		resyncInterval                     time.Duration
0000000000000000000000000000000000000000;;		loopEntryTime                      time.Time
0000000000000000000000000000000000000000;;		plegHealth                         bool
0000000000000000000000000000000000000000;;		redirectURL                        *url.URL
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fk *fakeKubelet) ResyncInterval() time.Duration {
0000000000000000000000000000000000000000;;		return fk.resyncInterval
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fk *fakeKubelet) LatestLoopEntryTime() time.Time {
0000000000000000000000000000000000000000;;		return fk.loopEntryTime
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fk *fakeKubelet) GetPodByName(namespace, name string) (*v1.Pod, bool) {
0000000000000000000000000000000000000000;;		return fk.podByNameFunc(namespace, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fk *fakeKubelet) GetContainerInfo(podFullName string, uid types.UID, containerName string, req *cadvisorapi.ContainerInfoRequest) (*cadvisorapi.ContainerInfo, error) {
0000000000000000000000000000000000000000;;		return fk.containerInfoFunc(podFullName, uid, containerName, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fk *fakeKubelet) GetRawContainerInfo(containerName string, req *cadvisorapi.ContainerInfoRequest, subcontainers bool) (map[string]*cadvisorapi.ContainerInfo, error) {
0000000000000000000000000000000000000000;;		return fk.rawInfoFunc(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fk *fakeKubelet) GetCachedMachineInfo() (*cadvisorapi.MachineInfo, error) {
0000000000000000000000000000000000000000;;		return fk.machineInfoFunc()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fk *fakeKubelet) GetPods() []*v1.Pod {
0000000000000000000000000000000000000000;;		return fk.podsFunc()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fk *fakeKubelet) GetRunningPods() ([]*v1.Pod, error) {
0000000000000000000000000000000000000000;;		return fk.runningPodsFunc()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fk *fakeKubelet) ServeLogs(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		fk.logFunc(w, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fk *fakeKubelet) GetKubeletContainerLogs(podFullName, containerName string, logOptions *v1.PodLogOptions, stdout, stderr io.Writer) error {
0000000000000000000000000000000000000000;;		return fk.containerLogsFunc(podFullName, containerName, logOptions, stdout, stderr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fk *fakeKubelet) GetHostname() string {
0000000000000000000000000000000000000000;;		return fk.hostnameFunc()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fk *fakeKubelet) RunInContainer(podFullName string, uid types.UID, containerName string, cmd []string) ([]byte, error) {
0000000000000000000000000000000000000000;;		return fk.runFunc(podFullName, uid, containerName, cmd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fk *fakeKubelet) ExecInContainer(name string, uid types.UID, container string, cmd []string, in io.Reader, out, err io.WriteCloser, tty bool, resize <-chan remotecommand.TerminalSize, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		return fk.execFunc(name, uid, container, cmd, in, out, err, tty)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fk *fakeKubelet) AttachContainer(name string, uid types.UID, container string, in io.Reader, out, err io.WriteCloser, tty bool, resize <-chan remotecommand.TerminalSize) error {
0000000000000000000000000000000000000000;;		return fk.attachFunc(name, uid, container, in, out, err, tty)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fk *fakeKubelet) PortForward(name string, uid types.UID, port int32, stream io.ReadWriteCloser) error {
0000000000000000000000000000000000000000;;		return fk.portForwardFunc(name, uid, port, stream)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fk *fakeKubelet) GetExec(podFullName string, podUID types.UID, containerName string, cmd []string, streamOpts remotecommandserver.Options) (*url.URL, error) {
0000000000000000000000000000000000000000;;		return fk.redirectURL, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fk *fakeKubelet) GetAttach(podFullName string, podUID types.UID, containerName string, streamOpts remotecommandserver.Options) (*url.URL, error) {
0000000000000000000000000000000000000000;;		return fk.redirectURL, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fk *fakeKubelet) GetPortForward(podName, podNamespace string, podUID types.UID, portForwardOpts portforward.V4Options) (*url.URL, error) {
0000000000000000000000000000000000000000;;		return fk.redirectURL, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fk *fakeKubelet) StreamingConnectionIdleTimeout() time.Duration {
0000000000000000000000000000000000000000;;		return fk.streamingConnectionIdleTimeoutFunc()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unused functions
0000000000000000000000000000000000000000;;	func (_ *fakeKubelet) GetContainerInfoV2(_ string, _ cadvisorapiv2.RequestOptions) (map[string]cadvisorapiv2.ContainerInfo, error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ *fakeKubelet) ImagesFsInfo() (cadvisorapiv2.FsInfo, error) {
0000000000000000000000000000000000000000;;		return cadvisorapiv2.FsInfo{}, fmt.Errorf("Unsupported Operation ImagesFsInfo")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ *fakeKubelet) RootFsInfo() (cadvisorapiv2.FsInfo, error) {
0000000000000000000000000000000000000000;;		return cadvisorapiv2.FsInfo{}, fmt.Errorf("Unsupport Operation RootFsInfo")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ *fakeKubelet) GetNode() (*v1.Node, error)   { return nil, nil }
0000000000000000000000000000000000000000;;	func (_ *fakeKubelet) GetNodeConfig() cm.NodeConfig { return cm.NodeConfig{} }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fk *fakeKubelet) ListVolumesForPod(podUID types.UID) (map[string]volume.Volume, bool) {
0000000000000000000000000000000000000000;;		return map[string]volume.Volume{}, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeAuth struct {
0000000000000000000000000000000000000000;;		authenticateFunc func(*http.Request) (user.Info, bool, error)
0000000000000000000000000000000000000000;;		attributesFunc   func(user.Info, *http.Request) authorizer.Attributes
0000000000000000000000000000000000000000;;		authorizeFunc    func(authorizer.Attributes) (authorized bool, reason string, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeAuth) AuthenticateRequest(req *http.Request) (user.Info, bool, error) {
0000000000000000000000000000000000000000;;		return f.authenticateFunc(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (f *fakeAuth) GetRequestAttributes(u user.Info, req *http.Request) authorizer.Attributes {
0000000000000000000000000000000000000000;;		return f.attributesFunc(u, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (f *fakeAuth) Authorize(a authorizer.Attributes) (authorized bool, reason string, err error) {
0000000000000000000000000000000000000000;;		return f.authorizeFunc(a)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type serverTestFramework struct {
0000000000000000000000000000000000000000;;		serverUnderTest *Server
0000000000000000000000000000000000000000;;		fakeKubelet     *fakeKubelet
0000000000000000000000000000000000000000;;		fakeAuth        *fakeAuth
0000000000000000000000000000000000000000;;		testHTTPServer  *httptest.Server
0000000000000000000000000000000000000000;;		criHandler      *utiltesting.FakeHandler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newServerTest() *serverTestFramework {
0000000000000000000000000000000000000000;;		fw := &serverTestFramework{}
0000000000000000000000000000000000000000;;		fw.fakeKubelet = &fakeKubelet{
0000000000000000000000000000000000000000;;			hostnameFunc: func() string {
0000000000000000000000000000000000000000;;				return "127.0.0.1"
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			podByNameFunc: func(namespace, name string) (*v1.Pod, bool) {
0000000000000000000000000000000000000000;;				return &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Namespace: namespace,
0000000000000000000000000000000000000000;;						Name:      name,
0000000000000000000000000000000000000000;;						UID:       testUID,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}, true
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			plegHealth: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fw.fakeAuth = &fakeAuth{
0000000000000000000000000000000000000000;;			authenticateFunc: func(req *http.Request) (user.Info, bool, error) {
0000000000000000000000000000000000000000;;				return &user.DefaultInfo{Name: "test"}, true, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			attributesFunc: func(u user.Info, req *http.Request) authorizer.Attributes {
0000000000000000000000000000000000000000;;				return &authorizer.AttributesRecord{User: u}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			authorizeFunc: func(a authorizer.Attributes) (authorized bool, reason string, err error) {
0000000000000000000000000000000000000000;;				return true, "", nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fw.criHandler = &utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode: http.StatusOK,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		server := NewServer(
0000000000000000000000000000000000000000;;			fw.fakeKubelet,
0000000000000000000000000000000000000000;;			stats.NewResourceAnalyzer(fw.fakeKubelet, time.Minute, &kubecontainertesting.FakeRuntime{}),
0000000000000000000000000000000000000000;;			fw.fakeAuth,
0000000000000000000000000000000000000000;;			true,
0000000000000000000000000000000000000000;;			false,
0000000000000000000000000000000000000000;;			&kubecontainertesting.Mock{},
0000000000000000000000000000000000000000;;			fw.criHandler)
0000000000000000000000000000000000000000;;		fw.serverUnderTest = &server
0000000000000000000000000000000000000000;;		fw.testHTTPServer = httptest.NewServer(fw.serverUnderTest)
0000000000000000000000000000000000000000;;		return fw
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A helper function to return the correct pod name.
0000000000000000000000000000000000000000;;	func getPodName(name, namespace string) string {
0000000000000000000000000000000000000000;;		if namespace == "" {
0000000000000000000000000000000000000000;;			namespace = metav1.NamespaceDefault
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return name + "_" + namespace
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestContainerInfo(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;		expectedInfo := &cadvisorapi.ContainerInfo{}
0000000000000000000000000000000000000000;;		podID := "somepod"
0000000000000000000000000000000000000000;;		expectedPodID := getPodName(podID, "")
0000000000000000000000000000000000000000;;		expectedContainerName := "goodcontainer"
0000000000000000000000000000000000000000;;		fw.fakeKubelet.containerInfoFunc = func(podID string, uid types.UID, containerName string, req *cadvisorapi.ContainerInfoRequest) (*cadvisorapi.ContainerInfo, error) {
0000000000000000000000000000000000000000;;			if podID != expectedPodID || containerName != expectedContainerName {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("bad podID or containerName: podID=%v; containerName=%v", podID, containerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return expectedInfo, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(fw.testHTTPServer.URL + fmt.Sprintf("/stats/%v/%v", podID, expectedContainerName))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Got error GETing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		var receivedInfo cadvisorapi.ContainerInfo
0000000000000000000000000000000000000000;;		err = json.NewDecoder(resp.Body).Decode(&receivedInfo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("received invalid json data: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !receivedInfo.Eq(expectedInfo) {
0000000000000000000000000000000000000000;;			t.Errorf("received wrong data: %#v", receivedInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestContainerInfoWithUidNamespace(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;		expectedInfo := &cadvisorapi.ContainerInfo{}
0000000000000000000000000000000000000000;;		podID := "somepod"
0000000000000000000000000000000000000000;;		expectedNamespace := "custom"
0000000000000000000000000000000000000000;;		expectedPodID := getPodName(podID, expectedNamespace)
0000000000000000000000000000000000000000;;		expectedContainerName := "goodcontainer"
0000000000000000000000000000000000000000;;		fw.fakeKubelet.containerInfoFunc = func(podID string, uid types.UID, containerName string, req *cadvisorapi.ContainerInfoRequest) (*cadvisorapi.ContainerInfo, error) {
0000000000000000000000000000000000000000;;			if podID != expectedPodID || string(uid) != testUID || containerName != expectedContainerName {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("bad podID or uid or containerName: podID=%v; uid=%v; containerName=%v", podID, uid, containerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return expectedInfo, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(fw.testHTTPServer.URL + fmt.Sprintf("/stats/%v/%v/%v/%v", expectedNamespace, podID, testUID, expectedContainerName))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Got error GETing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		var receivedInfo cadvisorapi.ContainerInfo
0000000000000000000000000000000000000000;;		err = json.NewDecoder(resp.Body).Decode(&receivedInfo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("received invalid json data: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !receivedInfo.Eq(expectedInfo) {
0000000000000000000000000000000000000000;;			t.Errorf("received wrong data: %#v", receivedInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestContainerNotFound(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;		podID := "somepod"
0000000000000000000000000000000000000000;;		expectedNamespace := "custom"
0000000000000000000000000000000000000000;;		expectedContainerName := "slowstartcontainer"
0000000000000000000000000000000000000000;;		fw.fakeKubelet.containerInfoFunc = func(podID string, uid types.UID, containerName string, req *cadvisorapi.ContainerInfoRequest) (*cadvisorapi.ContainerInfo, error) {
0000000000000000000000000000000000000000;;			return nil, kubecontainer.ErrContainerNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := http.Get(fw.testHTTPServer.URL + fmt.Sprintf("/stats/%v/%v/%v/%v", expectedNamespace, podID, testUID, expectedContainerName))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Got error GETing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusNotFound {
0000000000000000000000000000000000000000;;			t.Fatalf("Received status %d expecting %d", resp.StatusCode, http.StatusNotFound)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRootInfo(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;		expectedInfo := &cadvisorapi.ContainerInfo{
0000000000000000000000000000000000000000;;			ContainerReference: cadvisorapi.ContainerReference{
0000000000000000000000000000000000000000;;				Name: "/",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fw.fakeKubelet.rawInfoFunc = func(req *cadvisorapi.ContainerInfoRequest) (map[string]*cadvisorapi.ContainerInfo, error) {
0000000000000000000000000000000000000000;;			return map[string]*cadvisorapi.ContainerInfo{
0000000000000000000000000000000000000000;;				expectedInfo.Name: expectedInfo,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(fw.testHTTPServer.URL + "/stats")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Got error GETing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		var receivedInfo cadvisorapi.ContainerInfo
0000000000000000000000000000000000000000;;		err = json.NewDecoder(resp.Body).Decode(&receivedInfo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("received invalid json data: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !receivedInfo.Eq(expectedInfo) {
0000000000000000000000000000000000000000;;			t.Errorf("received wrong data: %#v, expected %#v", receivedInfo, expectedInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSubcontainerContainerInfo(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;		const kubeletContainer = "/kubelet"
0000000000000000000000000000000000000000;;		const kubeletSubContainer = "/kubelet/sub"
0000000000000000000000000000000000000000;;		expectedInfo := map[string]*cadvisorapi.ContainerInfo{
0000000000000000000000000000000000000000;;			kubeletContainer: {
0000000000000000000000000000000000000000;;				ContainerReference: cadvisorapi.ContainerReference{
0000000000000000000000000000000000000000;;					Name: kubeletContainer,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			kubeletSubContainer: {
0000000000000000000000000000000000000000;;				ContainerReference: cadvisorapi.ContainerReference{
0000000000000000000000000000000000000000;;					Name: kubeletSubContainer,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fw.fakeKubelet.rawInfoFunc = func(req *cadvisorapi.ContainerInfoRequest) (map[string]*cadvisorapi.ContainerInfo, error) {
0000000000000000000000000000000000000000;;			return expectedInfo, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request := fmt.Sprintf("{\"containerName\":%q, \"subcontainers\": true}", kubeletContainer)
0000000000000000000000000000000000000000;;		resp, err := http.Post(fw.testHTTPServer.URL+"/stats/container", "application/json", bytes.NewBuffer([]byte(request)))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Got error GETing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		var receivedInfo map[string]*cadvisorapi.ContainerInfo
0000000000000000000000000000000000000000;;		err = json.NewDecoder(resp.Body).Decode(&receivedInfo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Received invalid json data: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(receivedInfo) != len(expectedInfo) {
0000000000000000000000000000000000000000;;			t.Errorf("Received wrong data: %#v, expected %#v", receivedInfo, expectedInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, containerName := range []string{kubeletContainer, kubeletSubContainer} {
0000000000000000000000000000000000000000;;			if _, ok := receivedInfo[containerName]; !ok {
0000000000000000000000000000000000000000;;				t.Errorf("Expected container %q to be present in result: %#v", containerName, receivedInfo)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !receivedInfo[containerName].Eq(expectedInfo[containerName]) {
0000000000000000000000000000000000000000;;				t.Errorf("Invalid result for %q: Expected %#v, received %#v", containerName, expectedInfo[containerName], receivedInfo[containerName])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMachineInfo(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;		expectedInfo := &cadvisorapi.MachineInfo{
0000000000000000000000000000000000000000;;			NumCores:       4,
0000000000000000000000000000000000000000;;			MemoryCapacity: 1024,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fw.fakeKubelet.machineInfoFunc = func() (*cadvisorapi.MachineInfo, error) {
0000000000000000000000000000000000000000;;			return expectedInfo, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(fw.testHTTPServer.URL + "/spec")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Got error GETing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		var receivedInfo cadvisorapi.MachineInfo
0000000000000000000000000000000000000000;;		err = json.NewDecoder(resp.Body).Decode(&receivedInfo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("received invalid json data: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(&receivedInfo, expectedInfo) {
0000000000000000000000000000000000000000;;			t.Errorf("received wrong data: %#v", receivedInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServeLogs(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		content := string(`<pre><a href="kubelet.log">kubelet.log</a><a href="google.log">google.log</a></pre>`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fw.fakeKubelet.logFunc = func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;			w.Header().Add("Content-Type", "text/html")
0000000000000000000000000000000000000000;;			w.Write([]byte(content))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(fw.testHTTPServer.URL + "/logs/")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Got error GETing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err := httputil.DumpResponse(resp, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// copying the response body did not work
0000000000000000000000000000000000000000;;			t.Errorf("Cannot copy resp: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := string(body)
0000000000000000000000000000000000000000;;		if !strings.Contains(result, "kubelet.log") || !strings.Contains(result, "google.log") {
0000000000000000000000000000000000000000;;			t.Errorf("Received wrong data: %s", result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServeRunInContainer(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;		output := "foo bar"
0000000000000000000000000000000000000000;;		podNamespace := "other"
0000000000000000000000000000000000000000;;		podName := "foo"
0000000000000000000000000000000000000000;;		expectedPodName := getPodName(podName, podNamespace)
0000000000000000000000000000000000000000;;		expectedContainerName := "baz"
0000000000000000000000000000000000000000;;		expectedCommand := "ls -a"
0000000000000000000000000000000000000000;;		fw.fakeKubelet.runFunc = func(podFullName string, uid types.UID, containerName string, cmd []string) ([]byte, error) {
0000000000000000000000000000000000000000;;			if podFullName != expectedPodName {
0000000000000000000000000000000000000000;;				t.Errorf("expected %s, got %s", expectedPodName, podFullName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if containerName != expectedContainerName {
0000000000000000000000000000000000000000;;				t.Errorf("expected %s, got %s", expectedContainerName, containerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.Join(cmd, " ") != expectedCommand {
0000000000000000000000000000000000000000;;				t.Errorf("expected: %s, got %v", expectedCommand, cmd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return []byte(output), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Post(fw.testHTTPServer.URL+"/run/"+podNamespace+"/"+podName+"/"+expectedContainerName+"?cmd=ls%20-a", "", nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Got error POSTing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// copying the response body did not work
0000000000000000000000000000000000000000;;			t.Errorf("Cannot copy resp: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := string(body)
0000000000000000000000000000000000000000;;		if result != output {
0000000000000000000000000000000000000000;;			t.Errorf("expected %s, got %s", output, result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServeRunInContainerWithUID(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;		output := "foo bar"
0000000000000000000000000000000000000000;;		podNamespace := "other"
0000000000000000000000000000000000000000;;		podName := "foo"
0000000000000000000000000000000000000000;;		expectedPodName := getPodName(podName, podNamespace)
0000000000000000000000000000000000000000;;		expectedContainerName := "baz"
0000000000000000000000000000000000000000;;		expectedCommand := "ls -a"
0000000000000000000000000000000000000000;;		fw.fakeKubelet.runFunc = func(podFullName string, uid types.UID, containerName string, cmd []string) ([]byte, error) {
0000000000000000000000000000000000000000;;			if podFullName != expectedPodName {
0000000000000000000000000000000000000000;;				t.Errorf("expected %s, got %s", expectedPodName, podFullName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if string(uid) != testUID {
0000000000000000000000000000000000000000;;				t.Errorf("expected %s, got %s", testUID, uid)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if containerName != expectedContainerName {
0000000000000000000000000000000000000000;;				t.Errorf("expected %s, got %s", expectedContainerName, containerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.Join(cmd, " ") != expectedCommand {
0000000000000000000000000000000000000000;;				t.Errorf("expected: %s, got %v", expectedCommand, cmd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return []byte(output), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Post(fw.testHTTPServer.URL+"/run/"+podNamespace+"/"+podName+"/"+testUID+"/"+expectedContainerName+"?cmd=ls%20-a", "", nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Got error POSTing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// copying the response body did not work
0000000000000000000000000000000000000000;;			t.Errorf("Cannot copy resp: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := string(body)
0000000000000000000000000000000000000000;;		if result != output {
0000000000000000000000000000000000000000;;			t.Errorf("expected %s, got %s", output, result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHealthCheck(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;		fw.fakeKubelet.hostnameFunc = func() string {
0000000000000000000000000000000000000000;;			return "127.0.0.1"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test with correct hostname, Docker version
0000000000000000000000000000000000000000;;		assertHealthIsOk(t, fw.testHTTPServer.URL+"/healthz")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test with incorrect hostname
0000000000000000000000000000000000000000;;		fw.fakeKubelet.hostnameFunc = func() string {
0000000000000000000000000000000000000000;;			return "fake"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		assertHealthIsOk(t, fw.testHTTPServer.URL+"/healthz")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func assertHealthFails(t *testing.T, httpURL string, expectedErrorCode int) {
0000000000000000000000000000000000000000;;		resp, err := http.Get(httpURL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Got error GETing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		if resp.StatusCode != expectedErrorCode {
0000000000000000000000000000000000000000;;			t.Errorf("expected status code %d, got %d", expectedErrorCode, resp.StatusCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type authTestCase struct {
0000000000000000000000000000000000000000;;		Method string
0000000000000000000000000000000000000000;;		Path   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAuthFilters(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testcases := []authTestCase{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This is a sanity check that the Handle->HandleWithFilter() delegation is working
0000000000000000000000000000000000000000;;		// Ideally, these would move to registered web services and this list would get shorter
0000000000000000000000000000000000000000;;		expectedPaths := []string{"/healthz", "/metrics"}
0000000000000000000000000000000000000000;;		paths := sets.NewString(fw.serverUnderTest.restfulCont.RegisteredHandlePaths()...)
0000000000000000000000000000000000000000;;		for _, expectedPath := range expectedPaths {
0000000000000000000000000000000000000000;;			if !paths.Has(expectedPath) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected registered handle path %s was missing", expectedPath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test all the non-web-service handlers
0000000000000000000000000000000000000000;;		for _, path := range fw.serverUnderTest.restfulCont.RegisteredHandlePaths() {
0000000000000000000000000000000000000000;;			testcases = append(testcases, authTestCase{"GET", path})
0000000000000000000000000000000000000000;;			testcases = append(testcases, authTestCase{"POST", path})
0000000000000000000000000000000000000000;;			// Test subpaths for directory handlers
0000000000000000000000000000000000000000;;			if strings.HasSuffix(path, "/") {
0000000000000000000000000000000000000000;;				testcases = append(testcases, authTestCase{"GET", path + "foo"})
0000000000000000000000000000000000000000;;				testcases = append(testcases, authTestCase{"POST", path + "foo"})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test all the generated web-service paths
0000000000000000000000000000000000000000;;		for _, ws := range fw.serverUnderTest.restfulCont.RegisteredWebServices() {
0000000000000000000000000000000000000000;;			for _, r := range ws.Routes() {
0000000000000000000000000000000000000000;;				testcases = append(testcases, authTestCase{r.Method, r.Path})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		methodToAPIVerb := map[string]string{"GET": "get", "POST": "create", "PUT": "update"}
0000000000000000000000000000000000000000;;		pathToSubresource := func(path string) string {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			// Cases for subpaths we expect specific subresources for
0000000000000000000000000000000000000000;;			case isSubpath(path, statsPath):
0000000000000000000000000000000000000000;;				return "stats"
0000000000000000000000000000000000000000;;			case isSubpath(path, specPath):
0000000000000000000000000000000000000000;;				return "spec"
0000000000000000000000000000000000000000;;			case isSubpath(path, logsPath):
0000000000000000000000000000000000000000;;				return "log"
0000000000000000000000000000000000000000;;			case isSubpath(path, metricsPath):
0000000000000000000000000000000000000000;;				return "metrics"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Cases for subpaths we expect to map to the "proxy" subresource
0000000000000000000000000000000000000000;;			case isSubpath(path, "/attach"),
0000000000000000000000000000000000000000;;				isSubpath(path, "/configz"),
0000000000000000000000000000000000000000;;				isSubpath(path, "/containerLogs"),
0000000000000000000000000000000000000000;;				isSubpath(path, "/debug"),
0000000000000000000000000000000000000000;;				isSubpath(path, "/exec"),
0000000000000000000000000000000000000000;;				isSubpath(path, "/healthz"),
0000000000000000000000000000000000000000;;				isSubpath(path, "/pods"),
0000000000000000000000000000000000000000;;				isSubpath(path, "/portForward"),
0000000000000000000000000000000000000000;;				isSubpath(path, "/run"),
0000000000000000000000000000000000000000;;				isSubpath(path, "/runningpods"),
0000000000000000000000000000000000000000;;				isSubpath(path, "/cri"):
0000000000000000000000000000000000000000;;				return "proxy"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(fmt.Errorf(`unexpected kubelet API path %s.
0000000000000000000000000000000000000000;;	The kubelet API has likely registered a handler for a new path.
0000000000000000000000000000000000000000;;	If the new path has a use case for partitioned authorization when requested from the kubelet API,
0000000000000000000000000000000000000000;;	add a specific subresource for it in auth.go#GetRequestAttributes() and in TestAuthFilters().
0000000000000000000000000000000000000000;;	Otherwise, add it to the expected list of paths that map to the "proxy" subresource in TestAuthFilters().`, path))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attributesGetter := NewNodeAuthorizerAttributesGetter(types.NodeName("test"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testcases {
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				expectedUser       = &user.DefaultInfo{Name: "test"}
0000000000000000000000000000000000000000;;				expectedAttributes = authorizer.AttributesRecord{
0000000000000000000000000000000000000000;;					User:            expectedUser,
0000000000000000000000000000000000000000;;					APIGroup:        "",
0000000000000000000000000000000000000000;;					APIVersion:      "v1",
0000000000000000000000000000000000000000;;					Verb:            methodToAPIVerb[tc.Method],
0000000000000000000000000000000000000000;;					Resource:        "nodes",
0000000000000000000000000000000000000000;;					Name:            "test",
0000000000000000000000000000000000000000;;					Subresource:     pathToSubresource(tc.Path),
0000000000000000000000000000000000000000;;					ResourceRequest: true,
0000000000000000000000000000000000000000;;					Path:            tc.Path,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				calledAuthenticate = false
0000000000000000000000000000000000000000;;				calledAuthorize    = false
0000000000000000000000000000000000000000;;				calledAttributes   = false
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fw.fakeAuth.authenticateFunc = func(req *http.Request) (user.Info, bool, error) {
0000000000000000000000000000000000000000;;				calledAuthenticate = true
0000000000000000000000000000000000000000;;				return expectedUser, true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fw.fakeAuth.attributesFunc = func(u user.Info, req *http.Request) authorizer.Attributes {
0000000000000000000000000000000000000000;;				calledAttributes = true
0000000000000000000000000000000000000000;;				if u != expectedUser {
0000000000000000000000000000000000000000;;					t.Fatalf("%s: expected user %v, got %v", tc.Path, expectedUser, u)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return attributesGetter.GetRequestAttributes(u, req)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fw.fakeAuth.authorizeFunc = func(a authorizer.Attributes) (authorized bool, reason string, err error) {
0000000000000000000000000000000000000000;;				calledAuthorize = true
0000000000000000000000000000000000000000;;				if a != expectedAttributes {
0000000000000000000000000000000000000000;;					t.Fatalf("%s: expected attributes\n\t%#v\ngot\n\t%#v", tc.Path, expectedAttributes, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, "", nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			req, err := http.NewRequest(tc.Method, fw.testHTTPServer.URL+tc.Path, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", tc.Path, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resp, err := http.DefaultClient.Do(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", tc.Path, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer resp.Body.Close()
0000000000000000000000000000000000000000;;			if resp.StatusCode != http.StatusForbidden {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected status code %d", tc.Path, resp.StatusCode)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !calledAuthenticate {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Authenticate was not called", tc.Path)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !calledAttributes {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Attributes were not called", tc.Path)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !calledAuthorize {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Authorize was not called", tc.Path)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAuthenticationError(t *testing.T) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			expectedUser       = &user.DefaultInfo{Name: "test"}
0000000000000000000000000000000000000000;;			expectedAttributes = &authorizer.AttributesRecord{User: expectedUser}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			calledAuthenticate = false
0000000000000000000000000000000000000000;;			calledAuthorize    = false
0000000000000000000000000000000000000000;;			calledAttributes   = false
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;		fw.fakeAuth.authenticateFunc = func(req *http.Request) (user.Info, bool, error) {
0000000000000000000000000000000000000000;;			calledAuthenticate = true
0000000000000000000000000000000000000000;;			return expectedUser, true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fw.fakeAuth.attributesFunc = func(u user.Info, req *http.Request) authorizer.Attributes {
0000000000000000000000000000000000000000;;			calledAttributes = true
0000000000000000000000000000000000000000;;			return expectedAttributes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fw.fakeAuth.authorizeFunc = func(a authorizer.Attributes) (authorized bool, reason string, err error) {
0000000000000000000000000000000000000000;;			calledAuthorize = true
0000000000000000000000000000000000000000;;			return false, "", errors.New("Failed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assertHealthFails(t, fw.testHTTPServer.URL+"/healthz", http.StatusInternalServerError)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !calledAuthenticate {
0000000000000000000000000000000000000000;;			t.Fatalf("Authenticate was not called")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !calledAttributes {
0000000000000000000000000000000000000000;;			t.Fatalf("Attributes was not called")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !calledAuthorize {
0000000000000000000000000000000000000000;;			t.Fatalf("Authorize was not called")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAuthenticationFailure(t *testing.T) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			expectedUser       = &user.DefaultInfo{Name: "test"}
0000000000000000000000000000000000000000;;			expectedAttributes = &authorizer.AttributesRecord{User: expectedUser}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			calledAuthenticate = false
0000000000000000000000000000000000000000;;			calledAuthorize    = false
0000000000000000000000000000000000000000;;			calledAttributes   = false
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;		fw.fakeAuth.authenticateFunc = func(req *http.Request) (user.Info, bool, error) {
0000000000000000000000000000000000000000;;			calledAuthenticate = true
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fw.fakeAuth.attributesFunc = func(u user.Info, req *http.Request) authorizer.Attributes {
0000000000000000000000000000000000000000;;			calledAttributes = true
0000000000000000000000000000000000000000;;			return expectedAttributes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fw.fakeAuth.authorizeFunc = func(a authorizer.Attributes) (authorized bool, reason string, err error) {
0000000000000000000000000000000000000000;;			calledAuthorize = true
0000000000000000000000000000000000000000;;			return false, "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assertHealthFails(t, fw.testHTTPServer.URL+"/healthz", http.StatusUnauthorized)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !calledAuthenticate {
0000000000000000000000000000000000000000;;			t.Fatalf("Authenticate was not called")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if calledAttributes {
0000000000000000000000000000000000000000;;			t.Fatalf("Attributes was called unexpectedly")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if calledAuthorize {
0000000000000000000000000000000000000000;;			t.Fatalf("Authorize was called unexpectedly")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAuthorizationSuccess(t *testing.T) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			expectedUser       = &user.DefaultInfo{Name: "test"}
0000000000000000000000000000000000000000;;			expectedAttributes = &authorizer.AttributesRecord{User: expectedUser}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			calledAuthenticate = false
0000000000000000000000000000000000000000;;			calledAuthorize    = false
0000000000000000000000000000000000000000;;			calledAttributes   = false
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;		fw.fakeAuth.authenticateFunc = func(req *http.Request) (user.Info, bool, error) {
0000000000000000000000000000000000000000;;			calledAuthenticate = true
0000000000000000000000000000000000000000;;			return expectedUser, true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fw.fakeAuth.attributesFunc = func(u user.Info, req *http.Request) authorizer.Attributes {
0000000000000000000000000000000000000000;;			calledAttributes = true
0000000000000000000000000000000000000000;;			return expectedAttributes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fw.fakeAuth.authorizeFunc = func(a authorizer.Attributes) (authorized bool, reason string, err error) {
0000000000000000000000000000000000000000;;			calledAuthorize = true
0000000000000000000000000000000000000000;;			return true, "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assertHealthIsOk(t, fw.testHTTPServer.URL+"/healthz")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !calledAuthenticate {
0000000000000000000000000000000000000000;;			t.Fatalf("Authenticate was not called")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !calledAttributes {
0000000000000000000000000000000000000000;;			t.Fatalf("Attributes were not called")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !calledAuthorize {
0000000000000000000000000000000000000000;;			t.Fatalf("Authorize was not called")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncLoopCheck(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;		fw.fakeKubelet.hostnameFunc = func() string {
0000000000000000000000000000000000000000;;			return "127.0.0.1"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fw.fakeKubelet.resyncInterval = time.Minute
0000000000000000000000000000000000000000;;		fw.fakeKubelet.loopEntryTime = time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test with correct hostname, Docker version
0000000000000000000000000000000000000000;;		assertHealthIsOk(t, fw.testHTTPServer.URL+"/healthz")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fw.fakeKubelet.loopEntryTime = time.Now().Add(time.Minute * -10)
0000000000000000000000000000000000000000;;		assertHealthFails(t, fw.testHTTPServer.URL+"/healthz", http.StatusInternalServerError)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns http response status code from the HTTP GET
0000000000000000000000000000000000000000;;	func assertHealthIsOk(t *testing.T, httpURL string) {
0000000000000000000000000000000000000000;;		resp, err := http.Get(httpURL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Got error GETing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Errorf("expected status code %d, got %d", http.StatusOK, resp.StatusCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		body, readErr := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if readErr != nil {
0000000000000000000000000000000000000000;;			// copying the response body did not work
0000000000000000000000000000000000000000;;			t.Fatalf("Cannot copy resp: %#v", readErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := string(body)
0000000000000000000000000000000000000000;;		if !strings.Contains(result, "ok") {
0000000000000000000000000000000000000000;;			t.Errorf("expected body contains ok, got %s", result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setPodByNameFunc(fw *serverTestFramework, namespace, pod, container string) {
0000000000000000000000000000000000000000;;		fw.fakeKubelet.podByNameFunc = func(namespace, name string) (*v1.Pod, bool) {
0000000000000000000000000000000000000000;;			return &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: namespace,
0000000000000000000000000000000000000000;;					Name:      pod,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: container,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setGetContainerLogsFunc(fw *serverTestFramework, t *testing.T, expectedPodName, expectedContainerName string, expectedLogOptions *v1.PodLogOptions, output string) {
0000000000000000000000000000000000000000;;		fw.fakeKubelet.containerLogsFunc = func(podFullName, containerName string, logOptions *v1.PodLogOptions, stdout, stderr io.Writer) error {
0000000000000000000000000000000000000000;;			if podFullName != expectedPodName {
0000000000000000000000000000000000000000;;				t.Errorf("expected %s, got %s", expectedPodName, podFullName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if containerName != expectedContainerName {
0000000000000000000000000000000000000000;;				t.Errorf("expected %s, got %s", expectedContainerName, containerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(expectedLogOptions, logOptions) {
0000000000000000000000000000000000000000;;				t.Errorf("expected %#v, got %#v", expectedLogOptions, logOptions)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			io.WriteString(stdout, output)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: I really want to be a table driven test
0000000000000000000000000000000000000000;;	func TestContainerLogs(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;		output := "foo bar"
0000000000000000000000000000000000000000;;		podNamespace := "other"
0000000000000000000000000000000000000000;;		podName := "foo"
0000000000000000000000000000000000000000;;		expectedPodName := getPodName(podName, podNamespace)
0000000000000000000000000000000000000000;;		expectedContainerName := "baz"
0000000000000000000000000000000000000000;;		setPodByNameFunc(fw, podNamespace, podName, expectedContainerName)
0000000000000000000000000000000000000000;;		setGetContainerLogsFunc(fw, t, expectedPodName, expectedContainerName, &v1.PodLogOptions{}, output)
0000000000000000000000000000000000000000;;		resp, err := http.Get(fw.testHTTPServer.URL + "/containerLogs/" + podNamespace + "/" + podName + "/" + expectedContainerName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got error GETing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error reading container logs: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := string(body)
0000000000000000000000000000000000000000;;		if result != output {
0000000000000000000000000000000000000000;;			t.Errorf("Expected: '%v', got: '%v'", output, result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestContainerLogsWithLimitBytes(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;		output := "foo bar"
0000000000000000000000000000000000000000;;		podNamespace := "other"
0000000000000000000000000000000000000000;;		podName := "foo"
0000000000000000000000000000000000000000;;		expectedPodName := getPodName(podName, podNamespace)
0000000000000000000000000000000000000000;;		expectedContainerName := "baz"
0000000000000000000000000000000000000000;;		bytes := int64(3)
0000000000000000000000000000000000000000;;		setPodByNameFunc(fw, podNamespace, podName, expectedContainerName)
0000000000000000000000000000000000000000;;		setGetContainerLogsFunc(fw, t, expectedPodName, expectedContainerName, &v1.PodLogOptions{LimitBytes: &bytes}, output)
0000000000000000000000000000000000000000;;		resp, err := http.Get(fw.testHTTPServer.URL + "/containerLogs/" + podNamespace + "/" + podName + "/" + expectedContainerName + "?limitBytes=3")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got error GETing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error reading container logs: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := string(body)
0000000000000000000000000000000000000000;;		if result != output[:bytes] {
0000000000000000000000000000000000000000;;			t.Errorf("Expected: '%v', got: '%v'", output[:bytes], result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestContainerLogsWithTail(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;		output := "foo bar"
0000000000000000000000000000000000000000;;		podNamespace := "other"
0000000000000000000000000000000000000000;;		podName := "foo"
0000000000000000000000000000000000000000;;		expectedPodName := getPodName(podName, podNamespace)
0000000000000000000000000000000000000000;;		expectedContainerName := "baz"
0000000000000000000000000000000000000000;;		expectedTail := int64(5)
0000000000000000000000000000000000000000;;		setPodByNameFunc(fw, podNamespace, podName, expectedContainerName)
0000000000000000000000000000000000000000;;		setGetContainerLogsFunc(fw, t, expectedPodName, expectedContainerName, &v1.PodLogOptions{TailLines: &expectedTail}, output)
0000000000000000000000000000000000000000;;		resp, err := http.Get(fw.testHTTPServer.URL + "/containerLogs/" + podNamespace + "/" + podName + "/" + expectedContainerName + "?tailLines=5")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got error GETing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error reading container logs: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := string(body)
0000000000000000000000000000000000000000;;		if result != output {
0000000000000000000000000000000000000000;;			t.Errorf("Expected: '%v', got: '%v'", output, result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestContainerLogsWithLegacyTail(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;		output := "foo bar"
0000000000000000000000000000000000000000;;		podNamespace := "other"
0000000000000000000000000000000000000000;;		podName := "foo"
0000000000000000000000000000000000000000;;		expectedPodName := getPodName(podName, podNamespace)
0000000000000000000000000000000000000000;;		expectedContainerName := "baz"
0000000000000000000000000000000000000000;;		expectedTail := int64(5)
0000000000000000000000000000000000000000;;		setPodByNameFunc(fw, podNamespace, podName, expectedContainerName)
0000000000000000000000000000000000000000;;		setGetContainerLogsFunc(fw, t, expectedPodName, expectedContainerName, &v1.PodLogOptions{TailLines: &expectedTail}, output)
0000000000000000000000000000000000000000;;		resp, err := http.Get(fw.testHTTPServer.URL + "/containerLogs/" + podNamespace + "/" + podName + "/" + expectedContainerName + "?tail=5")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got error GETing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error reading container logs: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := string(body)
0000000000000000000000000000000000000000;;		if result != output {
0000000000000000000000000000000000000000;;			t.Errorf("Expected: '%v', got: '%v'", output, result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestContainerLogsWithTailAll(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;		output := "foo bar"
0000000000000000000000000000000000000000;;		podNamespace := "other"
0000000000000000000000000000000000000000;;		podName := "foo"
0000000000000000000000000000000000000000;;		expectedPodName := getPodName(podName, podNamespace)
0000000000000000000000000000000000000000;;		expectedContainerName := "baz"
0000000000000000000000000000000000000000;;		setPodByNameFunc(fw, podNamespace, podName, expectedContainerName)
0000000000000000000000000000000000000000;;		setGetContainerLogsFunc(fw, t, expectedPodName, expectedContainerName, &v1.PodLogOptions{}, output)
0000000000000000000000000000000000000000;;		resp, err := http.Get(fw.testHTTPServer.URL + "/containerLogs/" + podNamespace + "/" + podName + "/" + expectedContainerName + "?tail=all")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got error GETing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error reading container logs: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := string(body)
0000000000000000000000000000000000000000;;		if result != output {
0000000000000000000000000000000000000000;;			t.Errorf("Expected: '%v', got: '%v'", output, result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestContainerLogsWithInvalidTail(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;		output := "foo bar"
0000000000000000000000000000000000000000;;		podNamespace := "other"
0000000000000000000000000000000000000000;;		podName := "foo"
0000000000000000000000000000000000000000;;		expectedPodName := getPodName(podName, podNamespace)
0000000000000000000000000000000000000000;;		expectedContainerName := "baz"
0000000000000000000000000000000000000000;;		setPodByNameFunc(fw, podNamespace, podName, expectedContainerName)
0000000000000000000000000000000000000000;;		setGetContainerLogsFunc(fw, t, expectedPodName, expectedContainerName, &v1.PodLogOptions{}, output)
0000000000000000000000000000000000000000;;		resp, err := http.Get(fw.testHTTPServer.URL + "/containerLogs/" + podNamespace + "/" + podName + "/" + expectedContainerName + "?tail=-1")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got error GETing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		if resp.StatusCode != apierrs.StatusUnprocessableEntity {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected non-error reading container logs: %#v", resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestContainerLogsWithFollow(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;		output := "foo bar"
0000000000000000000000000000000000000000;;		podNamespace := "other"
0000000000000000000000000000000000000000;;		podName := "foo"
0000000000000000000000000000000000000000;;		expectedPodName := getPodName(podName, podNamespace)
0000000000000000000000000000000000000000;;		expectedContainerName := "baz"
0000000000000000000000000000000000000000;;		setPodByNameFunc(fw, podNamespace, podName, expectedContainerName)
0000000000000000000000000000000000000000;;		setGetContainerLogsFunc(fw, t, expectedPodName, expectedContainerName, &v1.PodLogOptions{Follow: true}, output)
0000000000000000000000000000000000000000;;		resp, err := http.Get(fw.testHTTPServer.URL + "/containerLogs/" + podNamespace + "/" + podName + "/" + expectedContainerName + "?follow=1")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got error GETing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error reading container logs: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := string(body)
0000000000000000000000000000000000000000;;		if result != output {
0000000000000000000000000000000000000000;;			t.Errorf("Expected: '%v', got: '%v'", output, result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServeExecInContainerIdleTimeout(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fw.fakeKubelet.streamingConnectionIdleTimeoutFunc = func() time.Duration {
0000000000000000000000000000000000000000;;			return 100 * time.Millisecond
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podNamespace := "other"
0000000000000000000000000000000000000000;;		podName := "foo"
0000000000000000000000000000000000000000;;		expectedContainerName := "baz"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		url := fw.testHTTPServer.URL + "/exec/" + podNamespace + "/" + podName + "/" + expectedContainerName + "?c=ls&c=-a&" + api.ExecStdinParam + "=1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		upgradeRoundTripper := spdy.NewSpdyRoundTripper(nil, true)
0000000000000000000000000000000000000000;;		c := &http.Client{Transport: upgradeRoundTripper}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := c.Post(url, "", nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Got error POSTing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		upgradeRoundTripper.Dialer = &net.Dialer{
0000000000000000000000000000000000000000;;			Deadline: time.Now().Add(60 * time.Second),
0000000000000000000000000000000000000000;;			Timeout:  60 * time.Second,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn, err := upgradeRoundTripper.NewConnection(resp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error creating streaming connection: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if conn == nil {
0000000000000000000000000000000000000000;;			t.Fatal("Unexpected nil connection")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-conn.CloseChan()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testExecAttach(t *testing.T, verb string) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			stdin              bool
0000000000000000000000000000000000000000;;			stdout             bool
0000000000000000000000000000000000000000;;			stderr             bool
0000000000000000000000000000000000000000;;			tty                bool
0000000000000000000000000000000000000000;;			responseStatusCode int
0000000000000000000000000000000000000000;;			uid                bool
0000000000000000000000000000000000000000;;			responseLocation   string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{responseStatusCode: http.StatusBadRequest},
0000000000000000000000000000000000000000;;			{stdin: true, responseStatusCode: http.StatusSwitchingProtocols},
0000000000000000000000000000000000000000;;			{stdout: true, responseStatusCode: http.StatusSwitchingProtocols},
0000000000000000000000000000000000000000;;			{stderr: true, responseStatusCode: http.StatusSwitchingProtocols},
0000000000000000000000000000000000000000;;			{stdout: true, stderr: true, responseStatusCode: http.StatusSwitchingProtocols},
0000000000000000000000000000000000000000;;			{stdout: true, stderr: true, tty: true, responseStatusCode: http.StatusSwitchingProtocols},
0000000000000000000000000000000000000000;;			{stdin: true, stdout: true, stderr: true, responseStatusCode: http.StatusSwitchingProtocols},
0000000000000000000000000000000000000000;;			{stdout: true, responseStatusCode: http.StatusFound, responseLocation: "http://localhost:12345/" + verb},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			fw := newServerTest()
0000000000000000000000000000000000000000;;			defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fw.fakeKubelet.streamingConnectionIdleTimeoutFunc = func() time.Duration {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.responseLocation != "" {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				fw.fakeKubelet.redirectURL, err = url.Parse(test.responseLocation)
0000000000000000000000000000000000000000;;				require.NoError(t, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			podNamespace := "other"
0000000000000000000000000000000000000000;;			podName := "foo"
0000000000000000000000000000000000000000;;			expectedPodName := getPodName(podName, podNamespace)
0000000000000000000000000000000000000000;;			expectedContainerName := "baz"
0000000000000000000000000000000000000000;;			expectedCommand := "ls -a"
0000000000000000000000000000000000000000;;			expectedStdin := "stdin"
0000000000000000000000000000000000000000;;			expectedStdout := "stdout"
0000000000000000000000000000000000000000;;			expectedStderr := "stderr"
0000000000000000000000000000000000000000;;			done := make(chan struct{})
0000000000000000000000000000000000000000;;			clientStdoutReadDone := make(chan struct{})
0000000000000000000000000000000000000000;;			clientStderrReadDone := make(chan struct{})
0000000000000000000000000000000000000000;;			execInvoked := false
0000000000000000000000000000000000000000;;			attachInvoked := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			testStreamFunc := func(podFullName string, uid types.UID, containerName string, cmd []string, in io.Reader, out, stderr io.WriteCloser, tty bool, done chan struct{}) error {
0000000000000000000000000000000000000000;;				defer close(done)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if podFullName != expectedPodName {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: podFullName: expected %s, got %s", i, expectedPodName, podFullName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if test.uid && string(uid) != testUID {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: uid: expected %v, got %v", i, testUID, uid)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if containerName != expectedContainerName {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: containerName: expected %s, got %s", i, expectedContainerName, containerName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if test.stdin {
0000000000000000000000000000000000000000;;					if in == nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%d: stdin: expected non-nil", i)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					b := make([]byte, 10)
0000000000000000000000000000000000000000;;					n, err := in.Read(b)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%d: error reading from stdin: %v", i, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if e, a := expectedStdin, string(b[0:n]); e != a {
0000000000000000000000000000000000000000;;						t.Fatalf("%d: stdin: expected to read %v, got %v", i, e, a)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if in != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: stdin: expected nil: %#v", i, in)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if test.stdout {
0000000000000000000000000000000000000000;;					if out == nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%d: stdout: expected non-nil", i)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					_, err := out.Write([]byte(expectedStdout))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%d:, error writing to stdout: %v", i, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					out.Close()
0000000000000000000000000000000000000000;;					<-clientStdoutReadDone
0000000000000000000000000000000000000000;;				} else if out != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: stdout: expected nil: %#v", i, out)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if tty {
0000000000000000000000000000000000000000;;					if stderr != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%d: tty set but received non-nil stderr: %v", i, stderr)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if test.stderr {
0000000000000000000000000000000000000000;;					if stderr == nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%d: stderr: expected non-nil", i)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					_, err := stderr.Write([]byte(expectedStderr))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%d:, error writing to stderr: %v", i, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					stderr.Close()
0000000000000000000000000000000000000000;;					<-clientStderrReadDone
0000000000000000000000000000000000000000;;				} else if stderr != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: stderr: expected nil: %#v", i, stderr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fw.fakeKubelet.execFunc = func(podFullName string, uid types.UID, containerName string, cmd []string, in io.Reader, out, stderr io.WriteCloser, tty bool) error {
0000000000000000000000000000000000000000;;				execInvoked = true
0000000000000000000000000000000000000000;;				if strings.Join(cmd, " ") != expectedCommand {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: cmd: expected: %s, got %v", i, expectedCommand, cmd)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return testStreamFunc(podFullName, uid, containerName, cmd, in, out, stderr, tty, done)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fw.fakeKubelet.attachFunc = func(podFullName string, uid types.UID, containerName string, in io.Reader, out, stderr io.WriteCloser, tty bool) error {
0000000000000000000000000000000000000000;;				attachInvoked = true
0000000000000000000000000000000000000000;;				return testStreamFunc(podFullName, uid, containerName, nil, in, out, stderr, tty, done)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var url string
0000000000000000000000000000000000000000;;			if test.uid {
0000000000000000000000000000000000000000;;				url = fw.testHTTPServer.URL + "/" + verb + "/" + podNamespace + "/" + podName + "/" + testUID + "/" + expectedContainerName + "?ignore=1"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				url = fw.testHTTPServer.URL + "/" + verb + "/" + podNamespace + "/" + podName + "/" + expectedContainerName + "?ignore=1"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if verb == "exec" {
0000000000000000000000000000000000000000;;				url += "&command=ls&command=-a"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.stdin {
0000000000000000000000000000000000000000;;				url += "&" + api.ExecStdinParam + "=1"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.stdout {
0000000000000000000000000000000000000000;;				url += "&" + api.ExecStdoutParam + "=1"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.stderr && !test.tty {
0000000000000000000000000000000000000000;;				url += "&" + api.ExecStderrParam + "=1"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.tty {
0000000000000000000000000000000000000000;;				url += "&" + api.ExecTTYParam + "=1"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				resp                *http.Response
0000000000000000000000000000000000000000;;				err                 error
0000000000000000000000000000000000000000;;				upgradeRoundTripper httpstream.UpgradeRoundTripper
0000000000000000000000000000000000000000;;				c                   *http.Client
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.responseStatusCode != http.StatusSwitchingProtocols {
0000000000000000000000000000000000000000;;				c = &http.Client{}
0000000000000000000000000000000000000000;;				// Don't follow redirects, since we want to inspect the redirect response.
0000000000000000000000000000000000000000;;				c.CheckRedirect = func(*http.Request, []*http.Request) error {
0000000000000000000000000000000000000000;;					return http.ErrUseLastResponse
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				upgradeRoundTripper = spdy.NewRoundTripper(nil, true)
0000000000000000000000000000000000000000;;				c = &http.Client{Transport: upgradeRoundTripper}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resp, err = c.Post(url, "", nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: Got error POSTing: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err = ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: Error reading response body: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if e, a := test.responseStatusCode, resp.StatusCode; e != a {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: response status: expected %v, got %v", i, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if e, a := test.responseLocation, resp.Header.Get("Location"); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%d: response location: expected %v, got %v", i, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.responseStatusCode != http.StatusSwitchingProtocols {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			conn, err := upgradeRoundTripper.NewConnection(resp)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected error creating streaming connection: %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if conn == nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: unexpected nil conn", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer conn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			h := http.Header{}
0000000000000000000000000000000000000000;;			h.Set(api.StreamType, api.StreamTypeError)
0000000000000000000000000000000000000000;;			if _, err := conn.CreateStream(h); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: error creating error stream: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.stdin {
0000000000000000000000000000000000000000;;				h.Set(api.StreamType, api.StreamTypeStdin)
0000000000000000000000000000000000000000;;				stream, err := conn.CreateStream(h)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: error creating stdin stream: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				_, err = stream.Write([]byte(expectedStdin))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: error writing to stdin stream: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var stdoutStream httpstream.Stream
0000000000000000000000000000000000000000;;			if test.stdout {
0000000000000000000000000000000000000000;;				h.Set(api.StreamType, api.StreamTypeStdout)
0000000000000000000000000000000000000000;;				stdoutStream, err = conn.CreateStream(h)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: error creating stdout stream: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var stderrStream httpstream.Stream
0000000000000000000000000000000000000000;;			if test.stderr && !test.tty {
0000000000000000000000000000000000000000;;				h.Set(api.StreamType, api.StreamTypeStderr)
0000000000000000000000000000000000000000;;				stderrStream, err = conn.CreateStream(h)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: error creating stderr stream: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.stdout {
0000000000000000000000000000000000000000;;				output := make([]byte, 10)
0000000000000000000000000000000000000000;;				n, err := stdoutStream.Read(output)
0000000000000000000000000000000000000000;;				close(clientStdoutReadDone)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: error reading from stdout stream: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := expectedStdout, string(output[0:n]); e != a {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: stdout: expected '%v', got '%v'", i, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.stderr && !test.tty {
0000000000000000000000000000000000000000;;				output := make([]byte, 10)
0000000000000000000000000000000000000000;;				n, err := stderrStream.Read(output)
0000000000000000000000000000000000000000;;				close(clientStderrReadDone)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: error reading from stderr stream: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := expectedStderr, string(output[0:n]); e != a {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: stderr: expected '%v', got '%v'", i, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// wait for the server to finish before checking if the attach/exec funcs were invoked
0000000000000000000000000000000000000000;;			<-done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if verb == "exec" {
0000000000000000000000000000000000000000;;				if !execInvoked {
0000000000000000000000000000000000000000;;					t.Errorf("%d: exec was not invoked", i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if attachInvoked {
0000000000000000000000000000000000000000;;					t.Errorf("%d: attach should not have been invoked", i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if !attachInvoked {
0000000000000000000000000000000000000000;;					t.Errorf("%d: attach was not invoked", i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if execInvoked {
0000000000000000000000000000000000000000;;					t.Errorf("%d: exec should not have been invoked", i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServeExecInContainer(t *testing.T) {
0000000000000000000000000000000000000000;;		testExecAttach(t, "exec")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServeAttachContainer(t *testing.T) {
0000000000000000000000000000000000000000;;		testExecAttach(t, "attach")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServePortForwardIdleTimeout(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fw.fakeKubelet.streamingConnectionIdleTimeoutFunc = func() time.Duration {
0000000000000000000000000000000000000000;;			return 100 * time.Millisecond
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podNamespace := "other"
0000000000000000000000000000000000000000;;		podName := "foo"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		url := fw.testHTTPServer.URL + "/portForward/" + podNamespace + "/" + podName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		upgradeRoundTripper := spdy.NewRoundTripper(nil, true)
0000000000000000000000000000000000000000;;		c := &http.Client{Transport: upgradeRoundTripper}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := c.Post(url, "", nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Got error POSTing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn, err := upgradeRoundTripper.NewConnection(resp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error creating streaming connection: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if conn == nil {
0000000000000000000000000000000000000000;;			t.Fatal("Unexpected nil connection")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer conn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-conn.CloseChan()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServePortForward(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			port             string
0000000000000000000000000000000000000000;;			uid              bool
0000000000000000000000000000000000000000;;			clientData       string
0000000000000000000000000000000000000000;;			containerData    string
0000000000000000000000000000000000000000;;			shouldError      bool
0000000000000000000000000000000000000000;;			responseLocation string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{port: "", shouldError: true},
0000000000000000000000000000000000000000;;			{port: "abc", shouldError: true},
0000000000000000000000000000000000000000;;			{port: "-1", shouldError: true},
0000000000000000000000000000000000000000;;			{port: "65536", shouldError: true},
0000000000000000000000000000000000000000;;			{port: "0", shouldError: true},
0000000000000000000000000000000000000000;;			{port: "1", shouldError: false},
0000000000000000000000000000000000000000;;			{port: "8000", shouldError: false},
0000000000000000000000000000000000000000;;			{port: "8000", clientData: "client data", containerData: "container data", shouldError: false},
0000000000000000000000000000000000000000;;			{port: "65535", shouldError: false},
0000000000000000000000000000000000000000;;			{port: "65535", uid: true, shouldError: false},
0000000000000000000000000000000000000000;;			{port: "65535", responseLocation: "http://localhost:12345/portforward", shouldError: false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podNamespace := "other"
0000000000000000000000000000000000000000;;		podName := "foo"
0000000000000000000000000000000000000000;;		expectedPodName := getPodName(podName, podNamespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			fw := newServerTest()
0000000000000000000000000000000000000000;;			defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fw.fakeKubelet.streamingConnectionIdleTimeoutFunc = func() time.Duration {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.responseLocation != "" {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				fw.fakeKubelet.redirectURL, err = url.Parse(test.responseLocation)
0000000000000000000000000000000000000000;;				require.NoError(t, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			portForwardFuncDone := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fw.fakeKubelet.portForwardFunc = func(name string, uid types.UID, port int32, stream io.ReadWriteCloser) error {
0000000000000000000000000000000000000000;;				defer close(portForwardFuncDone)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if e, a := expectedPodName, name; e != a {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: pod name: expected '%v', got '%v'", i, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if e, a := testUID, uid; test.uid && e != string(a) {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: uid: expected '%v', got '%v'", i, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				p, err := strconv.ParseInt(test.port, 10, 32)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: error parsing port string '%s': %v", i, test.port, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := int32(p), port; e != a {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: port: expected '%v', got '%v'", i, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if test.clientData != "" {
0000000000000000000000000000000000000000;;					fromClient := make([]byte, 32)
0000000000000000000000000000000000000000;;					n, err := stream.Read(fromClient)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%d: error reading client data: %v", i, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if e, a := test.clientData, string(fromClient[0:n]); e != a {
0000000000000000000000000000000000000000;;						t.Fatalf("%d: client data: expected to receive '%v', got '%v'", i, e, a)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if test.containerData != "" {
0000000000000000000000000000000000000000;;					_, err := stream.Write([]byte(test.containerData))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%d: error writing container data: %v", i, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var url string
0000000000000000000000000000000000000000;;			if test.uid {
0000000000000000000000000000000000000000;;				url = fmt.Sprintf("%s/portForward/%s/%s/%s", fw.testHTTPServer.URL, podNamespace, podName, testUID)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				url = fmt.Sprintf("%s/portForward/%s/%s", fw.testHTTPServer.URL, podNamespace, podName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				upgradeRoundTripper httpstream.UpgradeRoundTripper
0000000000000000000000000000000000000000;;				c                   *http.Client
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(test.responseLocation) > 0 {
0000000000000000000000000000000000000000;;				c = &http.Client{}
0000000000000000000000000000000000000000;;				// Don't follow redirects, since we want to inspect the redirect response.
0000000000000000000000000000000000000000;;				c.CheckRedirect = func(*http.Request, []*http.Request) error {
0000000000000000000000000000000000000000;;					return http.ErrUseLastResponse
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				upgradeRoundTripper = spdy.NewRoundTripper(nil, true)
0000000000000000000000000000000000000000;;				c = &http.Client{Transport: upgradeRoundTripper}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resp, err := c.Post(url, "", nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: Got error POSTing: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.responseLocation != "" {
0000000000000000000000000000000000000000;;				assert.Equal(t, http.StatusFound, resp.StatusCode, "%d: status code", i)
0000000000000000000000000000000000000000;;				assert.Equal(t, test.responseLocation, resp.Header.Get("Location"), "%d: location", i)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				assert.Equal(t, http.StatusSwitchingProtocols, resp.StatusCode, "%d: status code", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			conn, err := upgradeRoundTripper.NewConnection(resp)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected error creating streaming connection: %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if conn == nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: Unexpected nil connection", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer conn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			headers := http.Header{}
0000000000000000000000000000000000000000;;			headers.Set("streamType", "error")
0000000000000000000000000000000000000000;;			headers.Set("port", test.port)
0000000000000000000000000000000000000000;;			errorStream, err := conn.CreateStream(headers)
0000000000000000000000000000000000000000;;			_ = errorStream
0000000000000000000000000000000000000000;;			haveErr := err != nil
0000000000000000000000000000000000000000;;			if e, a := test.shouldError, haveErr; e != a {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: create stream: expected err=%t, got %t: %v", i, e, a, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.shouldError {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			headers.Set("streamType", "data")
0000000000000000000000000000000000000000;;			headers.Set("port", test.port)
0000000000000000000000000000000000000000;;			dataStream, err := conn.CreateStream(headers)
0000000000000000000000000000000000000000;;			haveErr = err != nil
0000000000000000000000000000000000000000;;			if e, a := test.shouldError, haveErr; e != a {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: create stream: expected err=%t, got %t: %v", i, e, a, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.clientData != "" {
0000000000000000000000000000000000000000;;				_, err := dataStream.Write([]byte(test.clientData))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: unexpected error writing client data: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.containerData != "" {
0000000000000000000000000000000000000000;;				fromContainer := make([]byte, 32)
0000000000000000000000000000000000000000;;				n, err := dataStream.Read(fromContainer)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: unexpected error reading container data: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := test.containerData, string(fromContainer[0:n]); e != a {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: expected to receive '%v' from container, got '%v'", i, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			<-portForwardFuncDone
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCRIHandler(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := newServerTest()
0000000000000000000000000000000000000000;;		defer fw.testHTTPServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			path  = "/cri/exec/123456abcdef"
0000000000000000000000000000000000000000;;			query = "cmd=echo+foo"
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		resp, err := http.Get(fw.testHTTPServer.URL + path + "?" + query)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, http.StatusOK, resp.StatusCode)
0000000000000000000000000000000000000000;;		assert.Equal(t, "GET", fw.criHandler.RequestReceived.Method)
0000000000000000000000000000000000000000;;		assert.Equal(t, path, fw.criHandler.RequestReceived.URL.Path)
0000000000000000000000000000000000000000;;		assert.Equal(t, query, fw.criHandler.RequestReceived.URL.RawQuery)
0000000000000000000000000000000000000000;;	}
