0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
bbb7c2f62746d45c0f223ad8947525483e99cbac;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package portforward
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream/spdy"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func handleHttpStreams(req *http.Request, w http.ResponseWriter, portForwarder PortForwarder, podName string, uid types.UID, supportedPortForwardProtocols []string, idleTimeout, streamCreationTimeout time.Duration) error {
0000000000000000000000000000000000000000;;		_, err := httpstream.Handshake(req, w, supportedPortForwardProtocols)
0000000000000000000000000000000000000000;;		// negotiated protocol isn't currently used server side, but could be in the future
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Handshake writes the error to the client
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		streamChan := make(chan httpstream.Stream, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Upgrading port forward response")
0000000000000000000000000000000000000000;;		upgrader := spdy.NewResponseUpgrader()
0000000000000000000000000000000000000000;;		conn := upgrader.UpgradeResponse(w, req, httpStreamReceived(streamChan))
0000000000000000000000000000000000000000;;		if conn == nil {
0000000000000000000000000000000000000000;;			return errors.New("Unable to upgrade websocket connection")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer conn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("(conn=%p) setting port forwarding streaming connection idle timeout to %v", conn, idleTimeout)
0000000000000000000000000000000000000000;;		conn.SetIdleTimeout(idleTimeout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := &httpStreamHandler{
0000000000000000000000000000000000000000;;			conn:                  conn,
0000000000000000000000000000000000000000;;			streamChan:            streamChan,
0000000000000000000000000000000000000000;;			streamPairs:           make(map[string]*httpStreamPair),
0000000000000000000000000000000000000000;;			streamCreationTimeout: streamCreationTimeout,
0000000000000000000000000000000000000000;;			pod:       podName,
0000000000000000000000000000000000000000;;			uid:       uid,
0000000000000000000000000000000000000000;;			forwarder: portForwarder,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h.run()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// httpStreamReceived is the httpstream.NewStreamHandler for port
0000000000000000000000000000000000000000;;	// forward streams. It checks each stream's port and stream type headers,
0000000000000000000000000000000000000000;;	// rejecting any streams that with missing or invalid values. Each valid
0000000000000000000000000000000000000000;;	// stream is sent to the streams channel.
0000000000000000000000000000000000000000;;	func httpStreamReceived(streams chan httpstream.Stream) func(httpstream.Stream, <-chan struct{}) error {
0000000000000000000000000000000000000000;;		return func(stream httpstream.Stream, replySent <-chan struct{}) error {
0000000000000000000000000000000000000000;;			// make sure it has a valid port header
0000000000000000000000000000000000000000;;			portString := stream.Headers().Get(api.PortHeader)
0000000000000000000000000000000000000000;;			if len(portString) == 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("%q header is required", api.PortHeader)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			port, err := strconv.ParseUint(portString, 10, 16)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to parse %q as a port: %v", portString, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if port < 1 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("port %q must be > 0", portString)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// make sure it has a valid stream type header
0000000000000000000000000000000000000000;;			streamType := stream.Headers().Get(api.StreamType)
0000000000000000000000000000000000000000;;			if len(streamType) == 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("%q header is required", api.StreamType)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if streamType != api.StreamTypeError && streamType != api.StreamTypeData {
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid stream type %q", streamType)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			streams <- stream
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// httpStreamHandler is capable of processing multiple port forward
0000000000000000000000000000000000000000;;	// requests over a single httpstream.Connection.
0000000000000000000000000000000000000000;;	type httpStreamHandler struct {
0000000000000000000000000000000000000000;;		conn                  httpstream.Connection
0000000000000000000000000000000000000000;;		streamChan            chan httpstream.Stream
0000000000000000000000000000000000000000;;		streamPairsLock       sync.RWMutex
0000000000000000000000000000000000000000;;		streamPairs           map[string]*httpStreamPair
0000000000000000000000000000000000000000;;		streamCreationTimeout time.Duration
0000000000000000000000000000000000000000;;		pod                   string
0000000000000000000000000000000000000000;;		uid                   types.UID
0000000000000000000000000000000000000000;;		forwarder             PortForwarder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getStreamPair returns a httpStreamPair for requestID. This creates a
0000000000000000000000000000000000000000;;	// new pair if one does not yet exist for the requestID. The returned bool is
0000000000000000000000000000000000000000;;	// true if the pair was created.
0000000000000000000000000000000000000000;;	func (h *httpStreamHandler) getStreamPair(requestID string) (*httpStreamPair, bool) {
0000000000000000000000000000000000000000;;		h.streamPairsLock.Lock()
0000000000000000000000000000000000000000;;		defer h.streamPairsLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p, ok := h.streamPairs[requestID]; ok {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("(conn=%p, request=%s) found existing stream pair", h.conn, requestID)
0000000000000000000000000000000000000000;;			return p, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("(conn=%p, request=%s) creating new stream pair", h.conn, requestID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := newPortForwardPair(requestID)
0000000000000000000000000000000000000000;;		h.streamPairs[requestID] = p
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// monitorStreamPair waits for the pair to receive both its error and data
0000000000000000000000000000000000000000;;	// streams, or for the timeout to expire (whichever happens first), and then
0000000000000000000000000000000000000000;;	// removes the pair.
0000000000000000000000000000000000000000;;	func (h *httpStreamHandler) monitorStreamPair(p *httpStreamPair, timeout <-chan time.Time) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-timeout:
0000000000000000000000000000000000000000;;			err := fmt.Errorf("(conn=%v, request=%s) timed out waiting for streams", h.conn, p.requestID)
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			p.printError(err.Error())
0000000000000000000000000000000000000000;;		case <-p.complete:
0000000000000000000000000000000000000000;;			glog.V(5).Infof("(conn=%v, request=%s) successfully received error and data streams", h.conn, p.requestID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h.removeStreamPair(p.requestID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hasStreamPair returns a bool indicating if a stream pair for requestID
0000000000000000000000000000000000000000;;	// exists.
0000000000000000000000000000000000000000;;	func (h *httpStreamHandler) hasStreamPair(requestID string) bool {
0000000000000000000000000000000000000000;;		h.streamPairsLock.RLock()
0000000000000000000000000000000000000000;;		defer h.streamPairsLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, ok := h.streamPairs[requestID]
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeStreamPair removes the stream pair identified by requestID from streamPairs.
0000000000000000000000000000000000000000;;	func (h *httpStreamHandler) removeStreamPair(requestID string) {
0000000000000000000000000000000000000000;;		h.streamPairsLock.Lock()
0000000000000000000000000000000000000000;;		defer h.streamPairsLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete(h.streamPairs, requestID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// requestID returns the request id for stream.
0000000000000000000000000000000000000000;;	func (h *httpStreamHandler) requestID(stream httpstream.Stream) string {
0000000000000000000000000000000000000000;;		requestID := stream.Headers().Get(api.PortForwardRequestIDHeader)
0000000000000000000000000000000000000000;;		if len(requestID) == 0 {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("(conn=%p) stream received without %s header", h.conn, api.PortForwardRequestIDHeader)
0000000000000000000000000000000000000000;;			// If we get here, it's because the connection came from an older client
0000000000000000000000000000000000000000;;			// that isn't generating the request id header
0000000000000000000000000000000000000000;;			// (https://github.com/kubernetes/kubernetes/blob/843134885e7e0b360eb5441e85b1410a8b1a7a0c/pkg/client/unversioned/portforward/portforward.go#L258-L287)
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// This is a best-effort attempt at supporting older clients.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// When there aren't concurrent new forwarded connections, each connection
0000000000000000000000000000000000000000;;			// will have a pair of streams (data, error), and the stream IDs will be
0000000000000000000000000000000000000000;;			// consecutive odd numbers, e.g. 1 and 3 for the first connection. Convert
0000000000000000000000000000000000000000;;			// the stream ID into a pseudo-request id by taking the stream type and
0000000000000000000000000000000000000000;;			// using id = stream.Identifier() when the stream type is error,
0000000000000000000000000000000000000000;;			// and id = stream.Identifier() - 2 when it's data.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// NOTE: this only works when there are not concurrent new streams from
0000000000000000000000000000000000000000;;			// multiple forwarded connections; it's a best-effort attempt at supporting
0000000000000000000000000000000000000000;;			// old clients that don't generate request ids.  If there are concurrent
0000000000000000000000000000000000000000;;			// new connections, it's possible that 1 connection gets streams whose IDs
0000000000000000000000000000000000000000;;			// are not consecutive (e.g. 5 and 9 instead of 5 and 7).
0000000000000000000000000000000000000000;;			streamType := stream.Headers().Get(api.StreamType)
0000000000000000000000000000000000000000;;			switch streamType {
0000000000000000000000000000000000000000;;			case api.StreamTypeError:
0000000000000000000000000000000000000000;;				requestID = strconv.Itoa(int(stream.Identifier()))
0000000000000000000000000000000000000000;;			case api.StreamTypeData:
0000000000000000000000000000000000000000;;				requestID = strconv.Itoa(int(stream.Identifier()) - 2)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(5).Infof("(conn=%p) automatically assigning request ID=%q from stream type=%s, stream ID=%d", h.conn, requestID, streamType, stream.Identifier())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return requestID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// run is the main loop for the httpStreamHandler. It processes new
0000000000000000000000000000000000000000;;	// streams, invoking portForward for each complete stream pair. The loop exits
0000000000000000000000000000000000000000;;	// when the httpstream.Connection is closed.
0000000000000000000000000000000000000000;;	func (h *httpStreamHandler) run() {
0000000000000000000000000000000000000000;;		glog.V(5).Infof("(conn=%p) waiting for port forward streams", h.conn)
0000000000000000000000000000000000000000;;	Loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-h.conn.CloseChan():
0000000000000000000000000000000000000000;;				glog.V(5).Infof("(conn=%p) upgraded connection closed", h.conn)
0000000000000000000000000000000000000000;;				break Loop
0000000000000000000000000000000000000000;;			case stream := <-h.streamChan:
0000000000000000000000000000000000000000;;				requestID := h.requestID(stream)
0000000000000000000000000000000000000000;;				streamType := stream.Headers().Get(api.StreamType)
0000000000000000000000000000000000000000;;				glog.V(5).Infof("(conn=%p, request=%s) received new stream of type %s", h.conn, requestID, streamType)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				p, created := h.getStreamPair(requestID)
0000000000000000000000000000000000000000;;				if created {
0000000000000000000000000000000000000000;;					go h.monitorStreamPair(p, time.After(h.streamCreationTimeout))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if complete, err := p.add(stream); err != nil {
0000000000000000000000000000000000000000;;					msg := fmt.Sprintf("error processing stream for request %s: %v", requestID, err)
0000000000000000000000000000000000000000;;					utilruntime.HandleError(errors.New(msg))
0000000000000000000000000000000000000000;;					p.printError(msg)
0000000000000000000000000000000000000000;;				} else if complete {
0000000000000000000000000000000000000000;;					go h.portForward(p)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// portForward invokes the httpStreamHandler's forwarder.PortForward
0000000000000000000000000000000000000000;;	// function for the given stream pair.
0000000000000000000000000000000000000000;;	func (h *httpStreamHandler) portForward(p *httpStreamPair) {
0000000000000000000000000000000000000000;;		defer p.dataStream.Close()
0000000000000000000000000000000000000000;;		defer p.errorStream.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		portString := p.dataStream.Headers().Get(api.PortHeader)
0000000000000000000000000000000000000000;;		port, _ := strconv.ParseInt(portString, 10, 32)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("(conn=%p, request=%s) invoking forwarder.PortForward for port %s", h.conn, p.requestID, portString)
0000000000000000000000000000000000000000;;		err := h.forwarder.PortForward(h.pod, h.uid, int32(port), p.dataStream)
0000000000000000000000000000000000000000;;		glog.V(5).Infof("(conn=%p, request=%s) done invoking forwarder.PortForward for port %s", h.conn, p.requestID, portString)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			msg := fmt.Errorf("error forwarding port %d to pod %s, uid %v: %v", port, h.pod, h.uid, err)
0000000000000000000000000000000000000000;;			utilruntime.HandleError(msg)
0000000000000000000000000000000000000000;;			fmt.Fprint(p.errorStream, msg.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// httpStreamPair represents the error and data streams for a port
0000000000000000000000000000000000000000;;	// forwarding request.
0000000000000000000000000000000000000000;;	type httpStreamPair struct {
0000000000000000000000000000000000000000;;		lock        sync.RWMutex
0000000000000000000000000000000000000000;;		requestID   string
0000000000000000000000000000000000000000;;		dataStream  httpstream.Stream
0000000000000000000000000000000000000000;;		errorStream httpstream.Stream
0000000000000000000000000000000000000000;;		complete    chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newPortForwardPair creates a new httpStreamPair.
0000000000000000000000000000000000000000;;	func newPortForwardPair(requestID string) *httpStreamPair {
0000000000000000000000000000000000000000;;		return &httpStreamPair{
0000000000000000000000000000000000000000;;			requestID: requestID,
0000000000000000000000000000000000000000;;			complete:  make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// add adds the stream to the httpStreamPair. If the pair already
0000000000000000000000000000000000000000;;	// contains a stream for the new stream's type, an error is returned. add
0000000000000000000000000000000000000000;;	// returns true if both the data and error streams for this pair have been
0000000000000000000000000000000000000000;;	// received.
0000000000000000000000000000000000000000;;	func (p *httpStreamPair) add(stream httpstream.Stream) (bool, error) {
0000000000000000000000000000000000000000;;		p.lock.Lock()
0000000000000000000000000000000000000000;;		defer p.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch stream.Headers().Get(api.StreamType) {
0000000000000000000000000000000000000000;;		case api.StreamTypeError:
0000000000000000000000000000000000000000;;			if p.errorStream != nil {
0000000000000000000000000000000000000000;;				return false, errors.New("error stream already assigned")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.errorStream = stream
0000000000000000000000000000000000000000;;		case api.StreamTypeData:
0000000000000000000000000000000000000000;;			if p.dataStream != nil {
0000000000000000000000000000000000000000;;				return false, errors.New("data stream already assigned")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.dataStream = stream
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		complete := p.errorStream != nil && p.dataStream != nil
0000000000000000000000000000000000000000;;		if complete {
0000000000000000000000000000000000000000;;			close(p.complete)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return complete, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printError writes s to p.errorStream if p.errorStream has been set.
0000000000000000000000000000000000000000;;	func (p *httpStreamPair) printError(s string) {
0000000000000000000000000000000000000000;;		p.lock.RLock()
0000000000000000000000000000000000000000;;		defer p.lock.RUnlock()
0000000000000000000000000000000000000000;;		if p.errorStream != nil {
0000000000000000000000000000000000000000;;			fmt.Fprint(p.errorStream, s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
