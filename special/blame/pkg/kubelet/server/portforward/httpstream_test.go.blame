0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
56cd6d33c13e8aab957be791beea3a5c0b77a717;pkg/kubelet/server/portforward/portforward_test.go[pkg/kubelet/server/portforward/portforward_test.go][pkg/kubelet/server/portforward/httpstream_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package portforward
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHTTPStreamReceived(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			port          string
0000000000000000000000000000000000000000;;			streamType    string
0000000000000000000000000000000000000000;;			expectedError string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"missing port": {
0000000000000000000000000000000000000000;;				expectedError: `"port" header is required`,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"unable to parse port": {
0000000000000000000000000000000000000000;;				port:          "abc",
0000000000000000000000000000000000000000;;				expectedError: `unable to parse "abc" as a port: strconv.ParseUint: parsing "abc": invalid syntax`,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"negative port": {
0000000000000000000000000000000000000000;;				port:          "-1",
0000000000000000000000000000000000000000;;				expectedError: `unable to parse "-1" as a port: strconv.ParseUint: parsing "-1": invalid syntax`,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"missing stream type": {
0000000000000000000000000000000000000000;;				port:          "80",
0000000000000000000000000000000000000000;;				expectedError: `"streamType" header is required`,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"valid port with error stream": {
0000000000000000000000000000000000000000;;				port:       "80",
0000000000000000000000000000000000000000;;				streamType: "error",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"valid port with data stream": {
0000000000000000000000000000000000000000;;				port:       "80",
0000000000000000000000000000000000000000;;				streamType: "data",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid stream type": {
0000000000000000000000000000000000000000;;				port:          "80",
0000000000000000000000000000000000000000;;				streamType:    "foo",
0000000000000000000000000000000000000000;;				expectedError: `invalid stream type "foo"`,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for name, test := range tests {
0000000000000000000000000000000000000000;;			streams := make(chan httpstream.Stream, 1)
0000000000000000000000000000000000000000;;			f := httpStreamReceived(streams)
0000000000000000000000000000000000000000;;			stream := newFakeHttpStream()
0000000000000000000000000000000000000000;;			if len(test.port) > 0 {
0000000000000000000000000000000000000000;;				stream.headers.Set("port", test.port)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(test.streamType) > 0 {
0000000000000000000000000000000000000000;;				stream.headers.Set("streamType", test.streamType)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			replySent := make(chan struct{})
0000000000000000000000000000000000000000;;			err := f(stream, replySent)
0000000000000000000000000000000000000000;;			close(replySent)
0000000000000000000000000000000000000000;;			if len(test.expectedError) > 0 {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected err=%q, but it was nil", name, test.expectedError)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := test.expectedError, err.Error(); e != a {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected err=%q, got %q", name, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error %v", name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s := <-streams; s != stream {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected stream %#v, got %#v", name, stream, s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetStreamPair(t *testing.T) {
0000000000000000000000000000000000000000;;		timeout := make(chan time.Time)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := &httpStreamHandler{
0000000000000000000000000000000000000000;;			streamPairs: make(map[string]*httpStreamPair),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// test adding a new entry
0000000000000000000000000000000000000000;;		p, created := h.getStreamPair("1")
0000000000000000000000000000000000000000;;		if p == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected nil pair")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !created {
0000000000000000000000000000000000000000;;			t.Fatal("expected created=true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.dataStream != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected non-nil data stream")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.errorStream != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected non-nil error stream")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// start the monitor for this pair
0000000000000000000000000000000000000000;;		monitorDone := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			h.monitorStreamPair(p, timeout)
0000000000000000000000000000000000000000;;			close(monitorDone)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !h.hasStreamPair("1") {
0000000000000000000000000000000000000000;;			t.Fatal("This should still be true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// make sure we can retrieve an existing entry
0000000000000000000000000000000000000000;;		p2, created := h.getStreamPair("1")
0000000000000000000000000000000000000000;;		if created {
0000000000000000000000000000000000000000;;			t.Fatal("expected created=false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p != p2 {
0000000000000000000000000000000000000000;;			t.Fatalf("retrieving an existing pair: expected %#v, got %#v", p, p2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// removed via complete
0000000000000000000000000000000000000000;;		dataStream := newFakeHttpStream()
0000000000000000000000000000000000000000;;		dataStream.headers.Set(api.StreamType, api.StreamTypeData)
0000000000000000000000000000000000000000;;		complete, err := p.add(dataStream)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error adding data stream to pair: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if complete {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected complete")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errorStream := newFakeHttpStream()
0000000000000000000000000000000000000000;;		errorStream.headers.Set(api.StreamType, api.StreamTypeError)
0000000000000000000000000000000000000000;;		complete, err = p.add(errorStream)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error adding error stream to pair: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !complete {
0000000000000000000000000000000000000000;;			t.Fatal("unexpected incomplete")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// make sure monitorStreamPair completed
0000000000000000000000000000000000000000;;		<-monitorDone
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// make sure the pair was removed
0000000000000000000000000000000000000000;;		if h.hasStreamPair("1") {
0000000000000000000000000000000000000000;;			t.Fatal("expected removal of pair after both data and error streams received")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// removed via timeout
0000000000000000000000000000000000000000;;		p, created = h.getStreamPair("2")
0000000000000000000000000000000000000000;;		if !created {
0000000000000000000000000000000000000000;;			t.Fatal("expected created=true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p == nil {
0000000000000000000000000000000000000000;;			t.Fatal("expected p not to be nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		monitorDone = make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			h.monitorStreamPair(p, timeout)
0000000000000000000000000000000000000000;;			close(monitorDone)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		// cause the timeout
0000000000000000000000000000000000000000;;		close(timeout)
0000000000000000000000000000000000000000;;		// make sure monitorStreamPair completed
0000000000000000000000000000000000000000;;		<-monitorDone
0000000000000000000000000000000000000000;;		if h.hasStreamPair("2") {
0000000000000000000000000000000000000000;;			t.Fatal("expected stream pair to be removed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestID(t *testing.T) {
0000000000000000000000000000000000000000;;		h := &httpStreamHandler{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := newFakeHttpStream()
0000000000000000000000000000000000000000;;		s.headers.Set(api.StreamType, api.StreamTypeError)
0000000000000000000000000000000000000000;;		s.id = 1
0000000000000000000000000000000000000000;;		if e, a := "1", h.requestID(s); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %q, got %q", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.headers.Set(api.StreamType, api.StreamTypeData)
0000000000000000000000000000000000000000;;		s.id = 3
0000000000000000000000000000000000000000;;		if e, a := "1", h.requestID(s); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %q, got %q", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.id = 7
0000000000000000000000000000000000000000;;		s.headers.Set(api.PortForwardRequestIDHeader, "2")
0000000000000000000000000000000000000000;;		if e, a := "2", h.requestID(s); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %q, got %q", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeHttpStream struct {
0000000000000000000000000000000000000000;;		headers http.Header
0000000000000000000000000000000000000000;;		id      uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFakeHttpStream() *fakeHttpStream {
0000000000000000000000000000000000000000;;		return &fakeHttpStream{
0000000000000000000000000000000000000000;;			headers: make(http.Header),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ httpstream.Stream = &fakeHttpStream{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *fakeHttpStream) Read(data []byte) (int, error) {
0000000000000000000000000000000000000000;;		return 0, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *fakeHttpStream) Write(data []byte) (int, error) {
0000000000000000000000000000000000000000;;		return 0, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *fakeHttpStream) Close() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *fakeHttpStream) Reset() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *fakeHttpStream) Headers() http.Header {
0000000000000000000000000000000000000000;;		return s.headers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *fakeHttpStream) Identifier() uint32 {
0000000000000000000000000000000000000000;;		return s.id
0000000000000000000000000000000000000000;;	}
