0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
bbb7c2f62746d45c0f223ad8947525483e99cbac;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package portforward
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/httplog"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/wsstream"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		dataChannel = iota
0000000000000000000000000000000000000000;;		errorChannel
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v4BinaryWebsocketProtocol = "v4." + wsstream.ChannelWebSocketProtocol
0000000000000000000000000000000000000000;;		v4Base64WebsocketProtocol = "v4." + wsstream.Base64ChannelWebSocketProtocol
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// options contains details about which streams are required for
0000000000000000000000000000000000000000;;	// port forwarding.
0000000000000000000000000000000000000000;;	// All fields incldued in V4Options need to be expressed explicilty in the
0000000000000000000000000000000000000000;;	// CRI (pkg/kubelet/apis/cri/{version}/api.proto) PortForwardRequest.
0000000000000000000000000000000000000000;;	type V4Options struct {
0000000000000000000000000000000000000000;;		Ports []int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newOptions creates a new options from the Request.
0000000000000000000000000000000000000000;;	func NewV4Options(req *http.Request) (*V4Options, error) {
0000000000000000000000000000000000000000;;		if !wsstream.IsWebSocketRequest(req) {
0000000000000000000000000000000000000000;;			return &V4Options{}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		portStrings := req.URL.Query()[api.PortHeader]
0000000000000000000000000000000000000000;;		if len(portStrings) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("query parameter %q is required", api.PortHeader)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ports := make([]int32, 0, len(portStrings))
0000000000000000000000000000000000000000;;		for _, portString := range portStrings {
0000000000000000000000000000000000000000;;			if len(portString) == 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("query parameter %q cannot be empty", api.PortHeader)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, p := range strings.Split(portString, ",") {
0000000000000000000000000000000000000000;;				port, err := strconv.ParseUint(p, 10, 16)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("unable to parse %q as a port: %v", portString, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if port < 1 {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("port %q must be > 0", portString)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ports = append(ports, int32(port))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &V4Options{
0000000000000000000000000000000000000000;;			Ports: ports,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildV4Options returns a V4Options based on the given information.
0000000000000000000000000000000000000000;;	func BuildV4Options(ports []int32) (*V4Options, error) {
0000000000000000000000000000000000000000;;		return &V4Options{Ports: ports}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handleWebSocketStreams handles requests to forward ports to a pod via
0000000000000000000000000000000000000000;;	// a PortForwarder. A pair of streams are created per port (DATA n,
0000000000000000000000000000000000000000;;	// ERROR n+1). The associated port is written to each stream as a unsigned 16
0000000000000000000000000000000000000000;;	// bit integer in little endian format.
0000000000000000000000000000000000000000;;	func handleWebSocketStreams(req *http.Request, w http.ResponseWriter, portForwarder PortForwarder, podName string, uid types.UID, opts *V4Options, supportedPortForwardProtocols []string, idleTimeout, streamCreationTimeout time.Duration) error {
0000000000000000000000000000000000000000;;		channels := make([]wsstream.ChannelType, 0, len(opts.Ports)*2)
0000000000000000000000000000000000000000;;		for i := 0; i < len(opts.Ports); i++ {
0000000000000000000000000000000000000000;;			channels = append(channels, wsstream.ReadWriteChannel, wsstream.WriteChannel)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn := wsstream.NewConn(map[string]wsstream.ChannelProtocolConfig{
0000000000000000000000000000000000000000;;			"": {
0000000000000000000000000000000000000000;;				Binary:   true,
0000000000000000000000000000000000000000;;				Channels: channels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			v4BinaryWebsocketProtocol: {
0000000000000000000000000000000000000000;;				Binary:   true,
0000000000000000000000000000000000000000;;				Channels: channels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			v4Base64WebsocketProtocol: {
0000000000000000000000000000000000000000;;				Binary:   false,
0000000000000000000000000000000000000000;;				Channels: channels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		conn.SetIdleTimeout(idleTimeout)
0000000000000000000000000000000000000000;;		_, streams, err := conn.Open(httplog.Unlogged(w), req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("Unable to upgrade websocket connection: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer conn.Close()
0000000000000000000000000000000000000000;;		streamPairs := make([]*websocketStreamPair, len(opts.Ports))
0000000000000000000000000000000000000000;;		for i := range streamPairs {
0000000000000000000000000000000000000000;;			streamPair := websocketStreamPair{
0000000000000000000000000000000000000000;;				port:        opts.Ports[i],
0000000000000000000000000000000000000000;;				dataStream:  streams[i*2+dataChannel],
0000000000000000000000000000000000000000;;				errorStream: streams[i*2+errorChannel],
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			streamPairs[i] = &streamPair
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			portBytes := make([]byte, 2)
0000000000000000000000000000000000000000;;			// port is always positive so conversion is allowable
0000000000000000000000000000000000000000;;			binary.LittleEndian.PutUint16(portBytes, uint16(streamPair.port))
0000000000000000000000000000000000000000;;			streamPair.dataStream.Write(portBytes)
0000000000000000000000000000000000000000;;			streamPair.errorStream.Write(portBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h := &websocketStreamHandler{
0000000000000000000000000000000000000000;;			conn:        conn,
0000000000000000000000000000000000000000;;			streamPairs: streamPairs,
0000000000000000000000000000000000000000;;			pod:         podName,
0000000000000000000000000000000000000000;;			uid:         uid,
0000000000000000000000000000000000000000;;			forwarder:   portForwarder,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h.run()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// websocketStreamPair represents the error and data streams for a port
0000000000000000000000000000000000000000;;	// forwarding request.
0000000000000000000000000000000000000000;;	type websocketStreamPair struct {
0000000000000000000000000000000000000000;;		port        int32
0000000000000000000000000000000000000000;;		dataStream  io.ReadWriteCloser
0000000000000000000000000000000000000000;;		errorStream io.WriteCloser
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// websocketStreamHandler is capable of processing a single port forward
0000000000000000000000000000000000000000;;	// request over a websocket connection
0000000000000000000000000000000000000000;;	type websocketStreamHandler struct {
0000000000000000000000000000000000000000;;		conn        *wsstream.Conn
0000000000000000000000000000000000000000;;		streamPairs []*websocketStreamPair
0000000000000000000000000000000000000000;;		pod         string
0000000000000000000000000000000000000000;;		uid         types.UID
0000000000000000000000000000000000000000;;		forwarder   PortForwarder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// run invokes the websocketStreamHandler's forwarder.PortForward
0000000000000000000000000000000000000000;;	// function for the given stream pair.
0000000000000000000000000000000000000000;;	func (h *websocketStreamHandler) run() {
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(len(h.streamPairs))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, pair := range h.streamPairs {
0000000000000000000000000000000000000000;;			p := pair
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;				h.portForward(p)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *websocketStreamHandler) portForward(p *websocketStreamPair) {
0000000000000000000000000000000000000000;;		defer p.dataStream.Close()
0000000000000000000000000000000000000000;;		defer p.errorStream.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("(conn=%p) invoking forwarder.PortForward for port %d", h.conn, p.port)
0000000000000000000000000000000000000000;;		err := h.forwarder.PortForward(h.pod, h.uid, p.port, p.dataStream)
0000000000000000000000000000000000000000;;		glog.V(5).Infof("(conn=%p) done invoking forwarder.PortForward for port %d", h.conn, p.port)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			msg := fmt.Errorf("error forwarding port %d to pod %s, uid %v: %v", p.port, h.pod, h.uid, err)
0000000000000000000000000000000000000000;;			runtime.HandleError(msg)
0000000000000000000000000000000000000000;;			fmt.Fprint(p.errorStream, msg.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
