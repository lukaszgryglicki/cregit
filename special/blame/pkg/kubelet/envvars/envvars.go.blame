0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
c03c75daa5271286c496055e49df90f8cfdbcf2d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package envvars
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromServices builds environment variables that a container is started with,
0000000000000000000000000000000000000000;;	// which tell the container where to find the services it may need, which are
0000000000000000000000000000000000000000;;	// provided as an argument.
0000000000000000000000000000000000000000;;	func FromServices(services []*v1.Service) []v1.EnvVar {
0000000000000000000000000000000000000000;;		var result []v1.EnvVar
0000000000000000000000000000000000000000;;		for i := range services {
0000000000000000000000000000000000000000;;			service := services[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// ignore services where ClusterIP is "None" or empty
0000000000000000000000000000000000000000;;			// the services passed to this method should be pre-filtered
0000000000000000000000000000000000000000;;			// only services that have the cluster IP set should be included here
0000000000000000000000000000000000000000;;			if !v1helper.IsServiceIPSet(service) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Host
0000000000000000000000000000000000000000;;			name := makeEnvVariableName(service.Name) + "_SERVICE_HOST"
0000000000000000000000000000000000000000;;			result = append(result, v1.EnvVar{Name: name, Value: service.Spec.ClusterIP})
0000000000000000000000000000000000000000;;			// First port - give it the backwards-compatible name
0000000000000000000000000000000000000000;;			name = makeEnvVariableName(service.Name) + "_SERVICE_PORT"
0000000000000000000000000000000000000000;;			result = append(result, v1.EnvVar{Name: name, Value: strconv.Itoa(int(service.Spec.Ports[0].Port))})
0000000000000000000000000000000000000000;;			// All named ports (only the first may be unnamed, checked in validation)
0000000000000000000000000000000000000000;;			for i := range service.Spec.Ports {
0000000000000000000000000000000000000000;;				sp := &service.Spec.Ports[i]
0000000000000000000000000000000000000000;;				if sp.Name != "" {
0000000000000000000000000000000000000000;;					pn := name + "_" + makeEnvVariableName(sp.Name)
0000000000000000000000000000000000000000;;					result = append(result, v1.EnvVar{Name: pn, Value: strconv.Itoa(int(sp.Port))})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Docker-compatible vars.
0000000000000000000000000000000000000000;;			result = append(result, makeLinkVariables(service)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeEnvVariableName(str string) string {
0000000000000000000000000000000000000000;;		// TODO: If we simplify to "all names are DNS1123Subdomains" this
0000000000000000000000000000000000000000;;		// will need two tweaks:
0000000000000000000000000000000000000000;;		//   1) Handle leading digits
0000000000000000000000000000000000000000;;		//   2) Handle dots
0000000000000000000000000000000000000000;;		return strings.ToUpper(strings.Replace(str, "-", "_", -1))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeLinkVariables(service *v1.Service) []v1.EnvVar {
0000000000000000000000000000000000000000;;		prefix := makeEnvVariableName(service.Name)
0000000000000000000000000000000000000000;;		all := []v1.EnvVar{}
0000000000000000000000000000000000000000;;		for i := range service.Spec.Ports {
0000000000000000000000000000000000000000;;			sp := &service.Spec.Ports[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			protocol := string(v1.ProtocolTCP)
0000000000000000000000000000000000000000;;			if sp.Protocol != "" {
0000000000000000000000000000000000000000;;				protocol = string(sp.Protocol)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			hostPort := net.JoinHostPort(service.Spec.ClusterIP, strconv.Itoa(int(sp.Port)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i == 0 {
0000000000000000000000000000000000000000;;				// Docker special-cases the first port.
0000000000000000000000000000000000000000;;				all = append(all, v1.EnvVar{
0000000000000000000000000000000000000000;;					Name:  prefix + "_PORT",
0000000000000000000000000000000000000000;;					Value: fmt.Sprintf("%s://%s", strings.ToLower(protocol), hostPort),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			portPrefix := fmt.Sprintf("%s_PORT_%d_%s", prefix, sp.Port, strings.ToUpper(protocol))
0000000000000000000000000000000000000000;;			all = append(all, []v1.EnvVar{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:  portPrefix,
0000000000000000000000000000000000000000;;					Value: fmt.Sprintf("%s://%s", strings.ToLower(protocol), hostPort),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:  portPrefix + "_PROTO",
0000000000000000000000000000000000000000;;					Value: strings.ToLower(protocol),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:  portPrefix + "_PORT",
0000000000000000000000000000000000000000;;					Value: strconv.Itoa(int(sp.Port)),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:  portPrefix + "_ADDR",
0000000000000000000000000000000000000000;;					Value: service.Spec.ClusterIP,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return all
0000000000000000000000000000000000000000;;	}
