0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
eb579981409449681fd95336da24d22dd3eb6cf0;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cadvisorapi "github.com/google/cadvisor/info/v2"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/require"
0000000000000000000000000000000000000000;;		cadvisortest "k8s.io/kubernetes/pkg/kubelet/cadvisor/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testPolicy() DiskSpacePolicy {
0000000000000000000000000000000000000000;;		return DiskSpacePolicy{
0000000000000000000000000000000000000000;;			DockerFreeDiskMB: 250,
0000000000000000000000000000000000000000;;			RootFreeDiskMB:   250,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setUp(t *testing.T) (*assert.Assertions, DiskSpacePolicy, *cadvisortest.Mock) {
0000000000000000000000000000000000000000;;		assert := assert.New(t)
0000000000000000000000000000000000000000;;		policy := testPolicy()
0000000000000000000000000000000000000000;;		c := new(cadvisortest.Mock)
0000000000000000000000000000000000000000;;		return assert, policy, c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidPolicy(t *testing.T) {
0000000000000000000000000000000000000000;;		assert, policy, c := setUp(t)
0000000000000000000000000000000000000000;;		_, err := newDiskSpaceManager(c, policy)
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		policy = testPolicy()
0000000000000000000000000000000000000000;;		policy.DockerFreeDiskMB = -1
0000000000000000000000000000000000000000;;		_, err = newDiskSpaceManager(c, policy)
0000000000000000000000000000000000000000;;		assert.Error(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		policy = testPolicy()
0000000000000000000000000000000000000000;;		policy.RootFreeDiskMB = -1
0000000000000000000000000000000000000000;;		_, err = newDiskSpaceManager(c, policy)
0000000000000000000000000000000000000000;;		assert.Error(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSpaceAvailable(t *testing.T) {
0000000000000000000000000000000000000000;;		assert, policy, mockCadvisor := setUp(t)
0000000000000000000000000000000000000000;;		dm, err := newDiskSpaceManager(mockCadvisor, policy)
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mockCadvisor.On("ImagesFsInfo").Return(cadvisorapi.FsInfo{
0000000000000000000000000000000000000000;;			Usage:     400 * mb,
0000000000000000000000000000000000000000;;			Capacity:  1000 * mb,
0000000000000000000000000000000000000000;;			Available: 600 * mb,
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		mockCadvisor.On("RootFsInfo").Return(cadvisorapi.FsInfo{
0000000000000000000000000000000000000000;;			Usage:    9 * mb,
0000000000000000000000000000000000000000;;			Capacity: 10 * mb,
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ok, err := dm.IsRuntimeDiskSpaceAvailable()
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;		assert.True(ok)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ok, err = dm.IsRootDiskSpaceAvailable()
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;		assert.False(ok)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestIsRuntimeDiskSpaceAvailableWithSpace verifies IsRuntimeDiskSpaceAvailable results when
0000000000000000000000000000000000000000;;	// space is available.
0000000000000000000000000000000000000000;;	func TestIsRuntimeDiskSpaceAvailableWithSpace(t *testing.T) {
0000000000000000000000000000000000000000;;		assert, policy, mockCadvisor := setUp(t)
0000000000000000000000000000000000000000;;		dm, err := newDiskSpaceManager(mockCadvisor, policy)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 500MB available
0000000000000000000000000000000000000000;;		mockCadvisor.On("ImagesFsInfo").Return(cadvisorapi.FsInfo{
0000000000000000000000000000000000000000;;			Usage:     9500 * mb,
0000000000000000000000000000000000000000;;			Capacity:  10000 * mb,
0000000000000000000000000000000000000000;;			Available: 500 * mb,
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ok, err := dm.IsRuntimeDiskSpaceAvailable()
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;		assert.True(ok)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestIsRuntimeDiskSpaceAvailableWithoutSpace verifies IsRuntimeDiskSpaceAvailable results when
0000000000000000000000000000000000000000;;	// space is not available.
0000000000000000000000000000000000000000;;	func TestIsRuntimeDiskSpaceAvailableWithoutSpace(t *testing.T) {
0000000000000000000000000000000000000000;;		// 1MB available
0000000000000000000000000000000000000000;;		assert, policy, mockCadvisor := setUp(t)
0000000000000000000000000000000000000000;;		mockCadvisor.On("ImagesFsInfo").Return(cadvisorapi.FsInfo{
0000000000000000000000000000000000000000;;			Usage:     999 * mb,
0000000000000000000000000000000000000000;;			Capacity:  1000 * mb,
0000000000000000000000000000000000000000;;			Available: 1 * mb,
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dm, err := newDiskSpaceManager(mockCadvisor, policy)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ok, err := dm.IsRuntimeDiskSpaceAvailable()
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;		assert.False(ok)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestIsRootDiskSpaceAvailableWithSpace verifies IsRootDiskSpaceAvailable results when
0000000000000000000000000000000000000000;;	// space is available.
0000000000000000000000000000000000000000;;	func TestIsRootDiskSpaceAvailableWithSpace(t *testing.T) {
0000000000000000000000000000000000000000;;		assert, policy, mockCadvisor := setUp(t)
0000000000000000000000000000000000000000;;		policy.RootFreeDiskMB = 10
0000000000000000000000000000000000000000;;		dm, err := newDiskSpaceManager(mockCadvisor, policy)
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 999MB available
0000000000000000000000000000000000000000;;		mockCadvisor.On("RootFsInfo").Return(cadvisorapi.FsInfo{
0000000000000000000000000000000000000000;;			Usage:     1 * mb,
0000000000000000000000000000000000000000;;			Capacity:  1000 * mb,
0000000000000000000000000000000000000000;;			Available: 999 * mb,
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ok, err := dm.IsRootDiskSpaceAvailable()
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;		assert.True(ok)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestIsRootDiskSpaceAvailableWithoutSpace verifies IsRootDiskSpaceAvailable results when
0000000000000000000000000000000000000000;;	// space is not available.
0000000000000000000000000000000000000000;;	func TestIsRootDiskSpaceAvailableWithoutSpace(t *testing.T) {
0000000000000000000000000000000000000000;;		assert, policy, mockCadvisor := setUp(t)
0000000000000000000000000000000000000000;;		policy.RootFreeDiskMB = 10
0000000000000000000000000000000000000000;;		dm, err := newDiskSpaceManager(mockCadvisor, policy)
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 9MB available
0000000000000000000000000000000000000000;;		mockCadvisor.On("RootFsInfo").Return(cadvisorapi.FsInfo{
0000000000000000000000000000000000000000;;			Usage:     990 * mb,
0000000000000000000000000000000000000000;;			Capacity:  1000 * mb,
0000000000000000000000000000000000000000;;			Available: 9 * mb,
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ok, err := dm.IsRootDiskSpaceAvailable()
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;		assert.False(ok)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestCache verifies that caching works properly with DiskSpaceAvailable calls
0000000000000000000000000000000000000000;;	func TestCache(t *testing.T) {
0000000000000000000000000000000000000000;;		assert, policy, mockCadvisor := setUp(t)
0000000000000000000000000000000000000000;;		dm, err := newDiskSpaceManager(mockCadvisor, policy)
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mockCadvisor.On("ImagesFsInfo").Return(cadvisorapi.FsInfo{
0000000000000000000000000000000000000000;;			Usage:     400 * mb,
0000000000000000000000000000000000000000;;			Capacity:  1000 * mb,
0000000000000000000000000000000000000000;;			Available: 300 * mb,
0000000000000000000000000000000000000000;;		}, nil).Once()
0000000000000000000000000000000000000000;;		mockCadvisor.On("RootFsInfo").Return(cadvisorapi.FsInfo{
0000000000000000000000000000000000000000;;			Usage:     500 * mb,
0000000000000000000000000000000000000000;;			Capacity:  1000 * mb,
0000000000000000000000000000000000000000;;			Available: 500 * mb,
0000000000000000000000000000000000000000;;		}, nil).Once()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Initial calls which should be recorded in mockCadvisor
0000000000000000000000000000000000000000;;		ok, err := dm.IsRuntimeDiskSpaceAvailable()
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;		assert.True(ok)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ok, err = dm.IsRootDiskSpaceAvailable()
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;		assert.True(ok)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the current count of calls to mockCadvisor
0000000000000000000000000000000000000000;;		cadvisorCallCount := len(mockCadvisor.Calls)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Checking for space again shouldn't need to mock as cache would serve it.
0000000000000000000000000000000000000000;;		ok, err = dm.IsRuntimeDiskSpaceAvailable()
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;		assert.True(ok)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ok, err = dm.IsRootDiskSpaceAvailable()
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;		assert.True(ok)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure no more calls to the mockCadvisor occurred
0000000000000000000000000000000000000000;;		assert.Equal(cadvisorCallCount, len(mockCadvisor.Calls))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestFsInfoError verifies errors are returned  by DiskSpaceAvailable calls
0000000000000000000000000000000000000000;;	// when FsInfo calls return an error
0000000000000000000000000000000000000000;;	func TestFsInfoError(t *testing.T) {
0000000000000000000000000000000000000000;;		assert, policy, mockCadvisor := setUp(t)
0000000000000000000000000000000000000000;;		policy.RootFreeDiskMB = 10
0000000000000000000000000000000000000000;;		dm, err := newDiskSpaceManager(mockCadvisor, policy)
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mockCadvisor.On("ImagesFsInfo").Return(cadvisorapi.FsInfo{}, fmt.Errorf("can't find fs"))
0000000000000000000000000000000000000000;;		mockCadvisor.On("RootFsInfo").Return(cadvisorapi.FsInfo{}, fmt.Errorf("EBUSY"))
0000000000000000000000000000000000000000;;		ok, err := dm.IsRuntimeDiskSpaceAvailable()
0000000000000000000000000000000000000000;;		assert.Error(err)
0000000000000000000000000000000000000000;;		assert.True(ok)
0000000000000000000000000000000000000000;;		ok, err = dm.IsRootDiskSpaceAvailable()
0000000000000000000000000000000000000000;;		assert.Error(err)
0000000000000000000000000000000000000000;;		assert.True(ok)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test_getFSInfo verifies multiple possible cases for getFsInfo.
0000000000000000000000000000000000000000;;	func Test_getFsInfo(t *testing.T) {
0000000000000000000000000000000000000000;;		assert, policy, mockCadvisor := setUp(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sunny day case
0000000000000000000000000000000000000000;;		mockCadvisor.On("RootFsInfo").Return(cadvisorapi.FsInfo{
0000000000000000000000000000000000000000;;			Usage:     10 * mb,
0000000000000000000000000000000000000000;;			Capacity:  100 * mb,
0000000000000000000000000000000000000000;;			Available: 90 * mb,
0000000000000000000000000000000000000000;;		}, nil).Once()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dm := &realDiskSpaceManager{
0000000000000000000000000000000000000000;;			cadvisor:   mockCadvisor,
0000000000000000000000000000000000000000;;			policy:     policy,
0000000000000000000000000000000000000000;;			cachedInfo: map[string]fsInfo{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		available, err := dm.isSpaceAvailable("root", 10, dm.cadvisor.RootFsInfo)
0000000000000000000000000000000000000000;;		assert.True(available)
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Threshold case
0000000000000000000000000000000000000000;;		mockCadvisor = new(cadvisortest.Mock)
0000000000000000000000000000000000000000;;		mockCadvisor.On("RootFsInfo").Return(cadvisorapi.FsInfo{
0000000000000000000000000000000000000000;;			Usage:     9 * mb,
0000000000000000000000000000000000000000;;			Capacity:  100 * mb,
0000000000000000000000000000000000000000;;			Available: 9 * mb,
0000000000000000000000000000000000000000;;		}, nil).Once()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dm = &realDiskSpaceManager{
0000000000000000000000000000000000000000;;			cadvisor:   mockCadvisor,
0000000000000000000000000000000000000000;;			policy:     policy,
0000000000000000000000000000000000000000;;			cachedInfo: map[string]fsInfo{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		available, err = dm.isSpaceAvailable("root", 10, dm.cadvisor.RootFsInfo)
0000000000000000000000000000000000000000;;		assert.False(available)
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Frozen case
0000000000000000000000000000000000000000;;		mockCadvisor.On("RootFsInfo").Return(cadvisorapi.FsInfo{
0000000000000000000000000000000000000000;;			Usage:     9 * mb,
0000000000000000000000000000000000000000;;			Capacity:  10 * mb,
0000000000000000000000000000000000000000;;			Available: 500 * mb,
0000000000000000000000000000000000000000;;		}, nil).Once()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dm = &realDiskSpaceManager{
0000000000000000000000000000000000000000;;			cadvisor:   mockCadvisor,
0000000000000000000000000000000000000000;;			policy:     policy,
0000000000000000000000000000000000000000;;			cachedInfo: map[string]fsInfo{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		available, err = dm.isSpaceAvailable("root", 10, dm.cadvisor.RootFsInfo)
0000000000000000000000000000000000000000;;		assert.True(available)
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Capacity error case
0000000000000000000000000000000000000000;;		mockCadvisor = new(cadvisortest.Mock)
0000000000000000000000000000000000000000;;		mockCadvisor.On("RootFsInfo").Return(cadvisorapi.FsInfo{
0000000000000000000000000000000000000000;;			Usage:     9 * mb,
0000000000000000000000000000000000000000;;			Capacity:  0,
0000000000000000000000000000000000000000;;			Available: 500 * mb,
0000000000000000000000000000000000000000;;		}, nil).Once()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dm = &realDiskSpaceManager{
0000000000000000000000000000000000000000;;			cadvisor:   mockCadvisor,
0000000000000000000000000000000000000000;;			policy:     policy,
0000000000000000000000000000000000000000;;			cachedInfo: map[string]fsInfo{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		available, err = dm.isSpaceAvailable("root", 10, dm.cadvisor.RootFsInfo)
0000000000000000000000000000000000000000;;		assert.True(available)
0000000000000000000000000000000000000000;;		assert.Error(err)
0000000000000000000000000000000000000000;;		assert.Contains(fmt.Sprintf("%s", err), "could not determine capacity")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Available error case skipped as v2.FSInfo uses uint64 and this
0000000000000000000000000000000000000000;;		// can not be less than 0
0000000000000000000000000000000000000000;;	}
