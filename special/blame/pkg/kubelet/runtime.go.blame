0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
fc29c3c230cf942f0c18a900ade05c59ecfbafbf;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type runtimeState struct {
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;		lastBaseRuntimeSync      time.Time
0000000000000000000000000000000000000000;;		baseRuntimeSyncThreshold time.Duration
0000000000000000000000000000000000000000;;		networkError             error
0000000000000000000000000000000000000000;;		internalError            error
0000000000000000000000000000000000000000;;		cidr                     string
0000000000000000000000000000000000000000;;		initError                error
0000000000000000000000000000000000000000;;		healthChecks             []*healthCheck
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A health check function should be efficient and not rely on external
0000000000000000000000000000000000000000;;	// components (e.g., container runtime).
0000000000000000000000000000000000000000;;	type healthCheckFnType func() (bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type healthCheck struct {
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;		fn   healthCheckFnType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *runtimeState) addHealthCheck(name string, f healthCheckFnType) {
0000000000000000000000000000000000000000;;		s.Lock()
0000000000000000000000000000000000000000;;		defer s.Unlock()
0000000000000000000000000000000000000000;;		s.healthChecks = append(s.healthChecks, &healthCheck{name: name, fn: f})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *runtimeState) setRuntimeSync(t time.Time) {
0000000000000000000000000000000000000000;;		s.Lock()
0000000000000000000000000000000000000000;;		defer s.Unlock()
0000000000000000000000000000000000000000;;		s.lastBaseRuntimeSync = t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *runtimeState) setInternalError(err error) {
0000000000000000000000000000000000000000;;		s.Lock()
0000000000000000000000000000000000000000;;		defer s.Unlock()
0000000000000000000000000000000000000000;;		s.internalError = err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *runtimeState) setNetworkState(err error) {
0000000000000000000000000000000000000000;;		s.Lock()
0000000000000000000000000000000000000000;;		defer s.Unlock()
0000000000000000000000000000000000000000;;		s.networkError = err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *runtimeState) setPodCIDR(cidr string) {
0000000000000000000000000000000000000000;;		s.Lock()
0000000000000000000000000000000000000000;;		defer s.Unlock()
0000000000000000000000000000000000000000;;		s.cidr = cidr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *runtimeState) podCIDR() string {
0000000000000000000000000000000000000000;;		s.RLock()
0000000000000000000000000000000000000000;;		defer s.RUnlock()
0000000000000000000000000000000000000000;;		return s.cidr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *runtimeState) setInitError(err error) {
0000000000000000000000000000000000000000;;		s.Lock()
0000000000000000000000000000000000000000;;		defer s.Unlock()
0000000000000000000000000000000000000000;;		s.initError = err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *runtimeState) runtimeErrors() []string {
0000000000000000000000000000000000000000;;		s.RLock()
0000000000000000000000000000000000000000;;		defer s.RUnlock()
0000000000000000000000000000000000000000;;		var ret []string
0000000000000000000000000000000000000000;;		if s.initError != nil {
0000000000000000000000000000000000000000;;			ret = append(ret, s.initError.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !s.lastBaseRuntimeSync.Add(s.baseRuntimeSyncThreshold).After(time.Now()) {
0000000000000000000000000000000000000000;;			ret = append(ret, "container runtime is down")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.internalError != nil {
0000000000000000000000000000000000000000;;			ret = append(ret, s.internalError.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, hc := range s.healthChecks {
0000000000000000000000000000000000000000;;			if ok, err := hc.fn(); !ok {
0000000000000000000000000000000000000000;;				ret = append(ret, fmt.Sprintf("%s is not healthy: %v", hc.name, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *runtimeState) networkErrors() []string {
0000000000000000000000000000000000000000;;		s.RLock()
0000000000000000000000000000000000000000;;		defer s.RUnlock()
0000000000000000000000000000000000000000;;		var ret []string
0000000000000000000000000000000000000000;;		if s.networkError != nil {
0000000000000000000000000000000000000000;;			ret = append(ret, s.networkError.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRuntimeState(
0000000000000000000000000000000000000000;;		runtimeSyncThreshold time.Duration,
0000000000000000000000000000000000000000;;	) *runtimeState {
0000000000000000000000000000000000000000;;		return &runtimeState{
0000000000000000000000000000000000000000;;			lastBaseRuntimeSync:      time.Time{},
0000000000000000000000000000000000000000;;			baseRuntimeSyncThreshold: runtimeSyncThreshold,
0000000000000000000000000000000000000000;;			networkError:             fmt.Errorf("network state unknown"),
0000000000000000000000000000000000000000;;			internalError:            nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
