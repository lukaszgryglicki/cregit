0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
f3056e072b415333fc98a56dca4f7c3ce0500039;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package certificate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/elliptic"
0000000000000000000000000000000000000000;;		cryptorand "crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certificates "k8s.io/api/certificates/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;		certificatesclient "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/certificates/v1beta1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		syncPeriod = 1 * time.Hour
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Manager maintains and updates the certificates in use by this certificate
0000000000000000000000000000000000000000;;	// manager. In the background it communicates with the API server to get new
0000000000000000000000000000000000000000;;	// certificates for certificates about to expire.
0000000000000000000000000000000000000000;;	type Manager interface {
0000000000000000000000000000000000000000;;		// CertificateSigningRequestClient sets the client interface that is used for
0000000000000000000000000000000000000000;;		// signing new certificates generated as part of rotation.
0000000000000000000000000000000000000000;;		SetCertificateSigningRequestClient(certificatesclient.CertificateSigningRequestInterface) error
0000000000000000000000000000000000000000;;		// Start the API server status sync loop.
0000000000000000000000000000000000000000;;		Start()
0000000000000000000000000000000000000000;;		// Current returns the currently selected certificate from the
0000000000000000000000000000000000000000;;		// certificate manager, as well as the associated certificate and key data
0000000000000000000000000000000000000000;;		// in PEM format.
0000000000000000000000000000000000000000;;		Current() *tls.Certificate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config is the set of configuration parameters available for a new Manager.
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		// CertificateSigningRequestClient will be used for signing new certificate
0000000000000000000000000000000000000000;;		// requests generated when a key rotation occurs. It must be set either at
0000000000000000000000000000000000000000;;		// initialization or by using CertificateSigningRequestClient before
0000000000000000000000000000000000000000;;		// Manager.Start() is called.
0000000000000000000000000000000000000000;;		CertificateSigningRequestClient certificatesclient.CertificateSigningRequestInterface
0000000000000000000000000000000000000000;;		// Template is the CertificateRequest that will be used as a template for
0000000000000000000000000000000000000000;;		// generating certificate signing requests for all new keys generated as
0000000000000000000000000000000000000000;;		// part of rotation. It follows the same rules as the template parameter of
0000000000000000000000000000000000000000;;		// crypto.x509.CreateCertificateRequest in the Go standard libraries.
0000000000000000000000000000000000000000;;		Template *x509.CertificateRequest
0000000000000000000000000000000000000000;;		// Usages is the types of usages that certificates generated by the manager
0000000000000000000000000000000000000000;;		// can be used for.
0000000000000000000000000000000000000000;;		Usages []certificates.KeyUsage
0000000000000000000000000000000000000000;;		// CertificateStore is a persistent store where the current cert/key is
0000000000000000000000000000000000000000;;		// kept and future cert/key pairs will be persisted after they are
0000000000000000000000000000000000000000;;		// generated.
0000000000000000000000000000000000000000;;		CertificateStore Store
0000000000000000000000000000000000000000;;		// BootstrapCertificatePEM is the certificate data that will be returned
0000000000000000000000000000000000000000;;		// from the Manager if the CertificateStore doesn't have any cert/key pairs
0000000000000000000000000000000000000000;;		// currently available and has not yet had a chance to get a new cert/key
0000000000000000000000000000000000000000;;		// pair from the API. If the CertificateStore does have a cert/key pair,
0000000000000000000000000000000000000000;;		// this will be ignored. If there is no cert/key pair available in the
0000000000000000000000000000000000000000;;		// CertificateStore, as soon as Start is called, it will request a new
0000000000000000000000000000000000000000;;		// cert/key pair from the CertificateSigningRequestClient. This is intended
0000000000000000000000000000000000000000;;		// to allow the first boot of a component to be initialized using a
0000000000000000000000000000000000000000;;		// generic, multi-use cert/key pair which will be quickly replaced with a
0000000000000000000000000000000000000000;;		// unique cert/key pair.
0000000000000000000000000000000000000000;;		BootstrapCertificatePEM []byte
0000000000000000000000000000000000000000;;		// BootstrapKeyPEM is the key data that will be returned from the Manager
0000000000000000000000000000000000000000;;		// if the CertificateStore doesn't have any cert/key pairs currently
0000000000000000000000000000000000000000;;		// available. If the CertificateStore does have a cert/key pair, this will
0000000000000000000000000000000000000000;;		// be ignored. If the bootstrap cert/key pair are used, they will be
0000000000000000000000000000000000000000;;		// rotated at the first opportunity, possibly well in advance of expiring.
0000000000000000000000000000000000000000;;		// This is intended to allow the first boot of a component to be
0000000000000000000000000000000000000000;;		// initialized using a generic, multi-use cert/key pair which will be
0000000000000000000000000000000000000000;;		// quickly replaced with a unique cert/key pair.
0000000000000000000000000000000000000000;;		BootstrapKeyPEM []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Store is responsible for getting and updating the current certificate.
0000000000000000000000000000000000000000;;	// Depending on the concrete implementation, the backing store for this
0000000000000000000000000000000000000000;;	// behavior may vary.
0000000000000000000000000000000000000000;;	type Store interface {
0000000000000000000000000000000000000000;;		// Current returns the currently selected certificate, as well as the
0000000000000000000000000000000000000000;;		// associated certificate and key data in PEM format. If the Store doesn't
0000000000000000000000000000000000000000;;		// have a cert/key pair currently, it should return a NoCertKeyError so
0000000000000000000000000000000000000000;;		// that the Manager can recover by using bootstrap certificates to request
0000000000000000000000000000000000000000;;		// a new cert/key pair.
0000000000000000000000000000000000000000;;		Current() (*tls.Certificate, error)
0000000000000000000000000000000000000000;;		// Update accepts the PEM data for the cert/key pair and makes the new
0000000000000000000000000000000000000000;;		// cert/key pair the 'current' pair, that will be returned by future calls
0000000000000000000000000000000000000000;;		// to Current().
0000000000000000000000000000000000000000;;		Update(cert, key []byte) (*tls.Certificate, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NoCertKeyError indicates there is no cert/key currently available.
0000000000000000000000000000000000000000;;	type NoCertKeyError string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *NoCertKeyError) Error() string { return string(*e) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type manager struct {
0000000000000000000000000000000000000000;;		certSigningRequestClient certificatesclient.CertificateSigningRequestInterface
0000000000000000000000000000000000000000;;		template                 *x509.CertificateRequest
0000000000000000000000000000000000000000;;		usages                   []certificates.KeyUsage
0000000000000000000000000000000000000000;;		certStore                Store
0000000000000000000000000000000000000000;;		certAccessLock           sync.RWMutex
0000000000000000000000000000000000000000;;		cert                     *tls.Certificate
0000000000000000000000000000000000000000;;		rotationDeadline         time.Time
0000000000000000000000000000000000000000;;		forceRotation            bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewManager returns a new certificate manager. A certificate manager is
0000000000000000000000000000000000000000;;	// responsible for being the authoritative source of certificates in the
0000000000000000000000000000000000000000;;	// Kubelet and handling updates due to rotation.
0000000000000000000000000000000000000000;;	func NewManager(config *Config) (Manager, error) {
0000000000000000000000000000000000000000;;		cert, forceRotation, err := getCurrentCertificateOrBootstrap(
0000000000000000000000000000000000000000;;			config.CertificateStore,
0000000000000000000000000000000000000000;;			config.BootstrapCertificatePEM,
0000000000000000000000000000000000000000;;			config.BootstrapKeyPEM)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := manager{
0000000000000000000000000000000000000000;;			certSigningRequestClient: config.CertificateSigningRequestClient,
0000000000000000000000000000000000000000;;			template:                 config.Template,
0000000000000000000000000000000000000000;;			usages:                   config.Usages,
0000000000000000000000000000000000000000;;			certStore:                config.CertificateStore,
0000000000000000000000000000000000000000;;			cert:                     cert,
0000000000000000000000000000000000000000;;			forceRotation:            forceRotation,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &m, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Current returns the currently selected certificate from the certificate
0000000000000000000000000000000000000000;;	// manager. This can be nil if the manager was initialized without a
0000000000000000000000000000000000000000;;	// certificate and has not yet received one from the
0000000000000000000000000000000000000000;;	// CertificateSigningRequestClient.
0000000000000000000000000000000000000000;;	func (m *manager) Current() *tls.Certificate {
0000000000000000000000000000000000000000;;		m.certAccessLock.RLock()
0000000000000000000000000000000000000000;;		defer m.certAccessLock.RUnlock()
0000000000000000000000000000000000000000;;		return m.cert
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetCertificateSigningRequestClient sets the client interface that is used
0000000000000000000000000000000000000000;;	// for signing new certificates generated as part of rotation. It must be
0000000000000000000000000000000000000000;;	// called before Start() and can not be used to change the
0000000000000000000000000000000000000000;;	// CertificateSigningRequestClient that has already been set. This method is to
0000000000000000000000000000000000000000;;	// support the one specific scenario where the CertificateSigningRequestClient
0000000000000000000000000000000000000000;;	// uses the CertificateManager.
0000000000000000000000000000000000000000;;	func (m *manager) SetCertificateSigningRequestClient(certSigningRequestClient certificatesclient.CertificateSigningRequestInterface) error {
0000000000000000000000000000000000000000;;		if m.certSigningRequestClient == nil {
0000000000000000000000000000000000000000;;			m.certSigningRequestClient = certSigningRequestClient
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("CertificateSigningRequestClient is already set.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Start will start the background work of rotating the certificates.
0000000000000000000000000000000000000000;;	func (m *manager) Start() {
0000000000000000000000000000000000000000;;		// Certificate rotation depends on access to the API server certificate
0000000000000000000000000000000000000000;;		// signing API, so don't start the certificate manager if we don't have a
0000000000000000000000000000000000000000;;		// client. This will happen on the cluster master, where the kubelet is
0000000000000000000000000000000000000000;;		// responsible for bootstrapping the pods of the master components.
0000000000000000000000000000000000000000;;		if m.certSigningRequestClient == nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Certificate rotation is not enabled, no connection to the apiserver.")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Certificate rotation is enabled.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.setRotationDeadline()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Synchronously request a certificate before entering the background
0000000000000000000000000000000000000000;;		// loop to allow bootstrap scenarios, where the certificate manager
0000000000000000000000000000000000000000;;		// doesn't have a certificate at all yet.
0000000000000000000000000000000000000000;;		if m.shouldRotate() {
0000000000000000000000000000000000000000;;			_, err := m.rotateCerts()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Could not rotate certificates: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		backoff := wait.Backoff{
0000000000000000000000000000000000000000;;			Duration: 2 * time.Second,
0000000000000000000000000000000000000000;;			Factor:   2,
0000000000000000000000000000000000000000;;			Jitter:   0.1,
0000000000000000000000000000000000000000;;			Steps:    7,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go wait.Forever(func() {
0000000000000000000000000000000000000000;;			time.Sleep(m.rotationDeadline.Sub(time.Now()))
0000000000000000000000000000000000000000;;			if err := wait.ExponentialBackoff(backoff, m.rotateCerts); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Reached backoff limit, still unable to rotate certs: %v", err)
0000000000000000000000000000000000000000;;				wait.PollInfinite(128*time.Second, m.rotateCerts)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getCurrentCertificateOrBootstrap(
0000000000000000000000000000000000000000;;		store Store,
0000000000000000000000000000000000000000;;		bootstrapCertificatePEM []byte,
0000000000000000000000000000000000000000;;		bootstrapKeyPEM []byte) (cert *tls.Certificate, shouldRotate bool, errResult error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currentCert, err := store.Current()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return currentCert, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok := err.(*NoCertKeyError); !ok {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if bootstrapCertificatePEM == nil || bootstrapKeyPEM == nil {
0000000000000000000000000000000000000000;;			return nil, true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bootstrapCert, err := tls.X509KeyPair(bootstrapCertificatePEM, bootstrapKeyPEM)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(bootstrapCert.Certificate) < 1 {
0000000000000000000000000000000000000000;;			return nil, false, fmt.Errorf("no cert/key data found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certs, err := x509.ParseCertificates(bootstrapCert.Certificate[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, fmt.Errorf("unable to parse certificate data: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bootstrapCert.Leaf = certs[0]
0000000000000000000000000000000000000000;;		return &bootstrapCert, true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shouldRotate looks at how close the current certificate is to expiring and
0000000000000000000000000000000000000000;;	// decides if it is time to rotate or not.
0000000000000000000000000000000000000000;;	func (m *manager) shouldRotate() bool {
0000000000000000000000000000000000000000;;		m.certAccessLock.RLock()
0000000000000000000000000000000000000000;;		defer m.certAccessLock.RUnlock()
0000000000000000000000000000000000000000;;		if m.cert == nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.forceRotation {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return time.Now().After(m.rotationDeadline)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) rotateCerts() (bool, error) {
0000000000000000000000000000000000000000;;		csrPEM, keyPEM, err := m.generateCSR()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unable to generate a certificate signing request: %v", err)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Call the Certificate Signing Request API to get a certificate for the
0000000000000000000000000000000000000000;;		// new private key.
0000000000000000000000000000000000000000;;		crtPEM, err := requestCertificate(m.certSigningRequestClient, csrPEM, m.usages)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed while requesting a signed certificate from the master: %v", err)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cert, err := m.certStore.Update(crtPEM, keyPEM)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unable to store the new cert/key pair: %v", err)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.updateCached(cert)
0000000000000000000000000000000000000000;;		m.setRotationDeadline()
0000000000000000000000000000000000000000;;		m.forceRotation = false
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setRotationDeadline sets a cached value for the threshold at which the
0000000000000000000000000000000000000000;;	// current certificate should be rotated, 80%+/-10% of the expiration of the
0000000000000000000000000000000000000000;;	// certificate.
0000000000000000000000000000000000000000;;	func (m *manager) setRotationDeadline() {
0000000000000000000000000000000000000000;;		m.certAccessLock.RLock()
0000000000000000000000000000000000000000;;		defer m.certAccessLock.RUnlock()
0000000000000000000000000000000000000000;;		if m.cert == nil {
0000000000000000000000000000000000000000;;			m.rotationDeadline = time.Now()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		notAfter := m.cert.Leaf.NotAfter
0000000000000000000000000000000000000000;;		totalDuration := float64(notAfter.Sub(m.cert.Leaf.NotBefore))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use some jitter to set the rotation threshold so each node will rotate
0000000000000000000000000000000000000000;;		// at approximately 70-90% of the total lifetime of the certificate.  With
0000000000000000000000000000000000000000;;		// jitter, if a number of nodes are added to a cluster at approximately the
0000000000000000000000000000000000000000;;		// same time (such as cluster creation time), they won't all try to rotate
0000000000000000000000000000000000000000;;		// certificates at the same time for the rest of the life of the cluster.
0000000000000000000000000000000000000000;;		jitteryDuration := wait.Jitter(time.Duration(totalDuration), 0.2) - time.Duration(totalDuration*0.3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.rotationDeadline = m.cert.Leaf.NotBefore.Add(jitteryDuration)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) updateCached(cert *tls.Certificate) {
0000000000000000000000000000000000000000;;		m.certAccessLock.Lock()
0000000000000000000000000000000000000000;;		defer m.certAccessLock.Unlock()
0000000000000000000000000000000000000000;;		m.cert = cert
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) generateCSR() (csrPEM []byte, keyPEM []byte, err error) {
0000000000000000000000000000000000000000;;		// Generate a new private key.
0000000000000000000000000000000000000000;;		privateKey, err := ecdsa.GenerateKey(elliptic.P256(), cryptorand.Reader)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("unable to generate a new private key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		der, err := x509.MarshalECPrivateKey(privateKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("unable to marshal the new key to DER: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyPEM = pem.EncodeToMemory(&pem.Block{Type: cert.ECPrivateKeyBlockType, Bytes: der})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		csrPEM, err = cert.MakeCSRFromTemplate(privateKey, m.template)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("unable to create a csr from the private key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return csrPEM, keyPEM, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// requestCertificate will create a certificate signing request using the PEM
0000000000000000000000000000000000000000;;	// encoded CSR and send it to API server, then it will watch the object's
0000000000000000000000000000000000000000;;	// status, once approved by API server, it will return the API server's issued
0000000000000000000000000000000000000000;;	// certificate (pem-encoded). If there is any errors, or the watch timeouts, it
0000000000000000000000000000000000000000;;	// will return an error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NOTE This is a copy of a function with the same name in
0000000000000000000000000000000000000000;;	// k8s.io/kubernetes/pkg/kubelet/util/csr/csr.go, changing only the package that
0000000000000000000000000000000000000000;;	// CertificateSigningRequestInterface and KeyUsage are imported from.
0000000000000000000000000000000000000000;;	func requestCertificate(client certificatesclient.CertificateSigningRequestInterface, csrData []byte, usages []certificates.KeyUsage) (certData []byte, err error) {
0000000000000000000000000000000000000000;;		glog.Infof("Requesting new certificate.")
0000000000000000000000000000000000000000;;		req, err := client.Create(&certificates.CertificateSigningRequest{
0000000000000000000000000000000000000000;;			// Username, UID, Groups will be injected by API server.
0000000000000000000000000000000000000000;;			TypeMeta:   metav1.TypeMeta{Kind: "CertificateSigningRequest"},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{GenerateName: "csr-"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Spec: certificates.CertificateSigningRequestSpec{
0000000000000000000000000000000000000000;;				Request: csrData,
0000000000000000000000000000000000000000;;				Usages:  usages,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cannot create certificate signing request: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make a default timeout = 3600s.
0000000000000000000000000000000000000000;;		var defaultTimeoutSeconds int64 = 3600
0000000000000000000000000000000000000000;;		certWatch, err := client.Watch(metav1.ListOptions{
0000000000000000000000000000000000000000;;			Watch:          true,
0000000000000000000000000000000000000000;;			TimeoutSeconds: &defaultTimeoutSeconds,
0000000000000000000000000000000000000000;;			FieldSelector:  fields.OneTermEqualSelector("metadata.name", req.Name).String(),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cannot watch on the certificate signing request: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer certWatch.Stop()
0000000000000000000000000000000000000000;;		ch := certWatch.ResultChan()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			event, ok := <-ch
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if event.Type == watch.Modified || event.Type == watch.Added {
0000000000000000000000000000000000000000;;				if event.Object.(*certificates.CertificateSigningRequest).UID != req.UID {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				status := event.Object.(*certificates.CertificateSigningRequest).Status
0000000000000000000000000000000000000000;;				for _, c := range status.Conditions {
0000000000000000000000000000000000000000;;					if c.Type == certificates.CertificateDenied {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("certificate signing request is not approved, reason: %v, message: %v", c.Reason, c.Message)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if c.Type == certificates.CertificateApproved && status.Certificate != nil {
0000000000000000000000000000000000000000;;						return status.Certificate, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("watch channel closed")
0000000000000000000000000000000000000000;;	}
