0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
2ce761e6befd1e0fbfa1644ac01f2b8651bba373;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package certificate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"crypto/x509/pkix"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certificates "k8s.io/api/certificates/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		clientcertificates "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/certificates/v1beta1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewKubeletServerCertificateManager creates a certificate manager for the kubelet when retrieving a server certificate
0000000000000000000000000000000000000000;;	// or returns an error.
0000000000000000000000000000000000000000;;	func NewKubeletServerCertificateManager(kubeClient clientset.Interface, kubeCfg *componentconfig.KubeletConfiguration, nodeName types.NodeName, ips []net.IP, hostnames []string) (Manager, error) {
0000000000000000000000000000000000000000;;		var certSigningRequestClient clientcertificates.CertificateSigningRequestInterface
0000000000000000000000000000000000000000;;		if kubeClient != nil && kubeClient.Certificates() != nil {
0000000000000000000000000000000000000000;;			certSigningRequestClient = kubeClient.Certificates().CertificateSigningRequests()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		certificateStore, err := NewFileStore(
0000000000000000000000000000000000000000;;			"kubelet-server",
0000000000000000000000000000000000000000;;			kubeCfg.CertDirectory,
0000000000000000000000000000000000000000;;			kubeCfg.CertDirectory,
0000000000000000000000000000000000000000;;			kubeCfg.TLSCertFile,
0000000000000000000000000000000000000000;;			kubeCfg.TLSPrivateKeyFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to initialize server certificate store: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m, err := NewManager(&Config{
0000000000000000000000000000000000000000;;			CertificateSigningRequestClient: certSigningRequestClient,
0000000000000000000000000000000000000000;;			Template: &x509.CertificateRequest{
0000000000000000000000000000000000000000;;				Subject: pkix.Name{
0000000000000000000000000000000000000000;;					CommonName:   fmt.Sprintf("system:node:%s", nodeName),
0000000000000000000000000000000000000000;;					Organization: []string{"system:nodes"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				DNSNames:    hostnames,
0000000000000000000000000000000000000000;;				IPAddresses: ips,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Usages: []certificates.KeyUsage{
0000000000000000000000000000000000000000;;				// https://tools.ietf.org/html/rfc5280#section-4.2.1.3
0000000000000000000000000000000000000000;;				//
0000000000000000000000000000000000000000;;				// Digital signature allows the certificate to be used to verify
0000000000000000000000000000000000000000;;				// digital signatures used during TLS negotiation.
0000000000000000000000000000000000000000;;				certificates.UsageDigitalSignature,
0000000000000000000000000000000000000000;;				// KeyEncipherment allows the cert/key pair to be used to encrypt
0000000000000000000000000000000000000000;;				// keys, including the symetric keys negotiated during TLS setup
0000000000000000000000000000000000000000;;				// and used for data transfer.
0000000000000000000000000000000000000000;;				certificates.UsageKeyEncipherment,
0000000000000000000000000000000000000000;;				// ServerAuth allows the cert to be used by a TLS server to
0000000000000000000000000000000000000000;;				// authenticate itself to a TLS client.
0000000000000000000000000000000000000000;;				certificates.UsageServerAuth,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			CertificateStore: certificateStore,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to initialize server certificate manager: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewKubeletClientCertificateManager sets up a certificate manager without a
0000000000000000000000000000000000000000;;	// client that can be used to sign new certificates (or rotate). It answers with
0000000000000000000000000000000000000000;;	// whatever certificate it is initialized with. If a CSR client is set later, it
0000000000000000000000000000000000000000;;	// may begin rotating/renewing the client cert
0000000000000000000000000000000000000000;;	func NewKubeletClientCertificateManager(certDirectory string, nodeName types.NodeName, certData []byte, keyData []byte, certFile string, keyFile string) (Manager, error) {
0000000000000000000000000000000000000000;;		certificateStore, err := NewFileStore(
0000000000000000000000000000000000000000;;			"kubelet-client",
0000000000000000000000000000000000000000;;			certDirectory,
0000000000000000000000000000000000000000;;			certDirectory,
0000000000000000000000000000000000000000;;			certFile,
0000000000000000000000000000000000000000;;			keyFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to initialize client certificate store: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m, err := NewManager(&Config{
0000000000000000000000000000000000000000;;			Template: &x509.CertificateRequest{
0000000000000000000000000000000000000000;;				Subject: pkix.Name{
0000000000000000000000000000000000000000;;					CommonName:   fmt.Sprintf("system:node:%s", nodeName),
0000000000000000000000000000000000000000;;					Organization: []string{"system:nodes"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Usages: []certificates.KeyUsage{
0000000000000000000000000000000000000000;;				// https://tools.ietf.org/html/rfc5280#section-4.2.1.3
0000000000000000000000000000000000000000;;				//
0000000000000000000000000000000000000000;;				// DigitalSignature allows the certificate to be used to verify
0000000000000000000000000000000000000000;;				// digital signatures including signatures used during TLS
0000000000000000000000000000000000000000;;				// negotiation.
0000000000000000000000000000000000000000;;				certificates.UsageDigitalSignature,
0000000000000000000000000000000000000000;;				// KeyEncipherment allows the cert/key pair to be used to encrypt
0000000000000000000000000000000000000000;;				// keys, including the symetric keys negotiated during TLS setup
0000000000000000000000000000000000000000;;				// and used for data transfer..
0000000000000000000000000000000000000000;;				certificates.UsageKeyEncipherment,
0000000000000000000000000000000000000000;;				// ClientAuth allows the cert to be used by a TLS client to
0000000000000000000000000000000000000000;;				// authenticate itself to the TLS server.
0000000000000000000000000000000000000000;;				certificates.UsageClientAuth,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			CertificateStore:        certificateStore,
0000000000000000000000000000000000000000;;			BootstrapCertificatePEM: certData,
0000000000000000000000000000000000000000;;			BootstrapKeyPEM:         keyData,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to initialize client certificate manager: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m, nil
0000000000000000000000000000000000000000;;	}
