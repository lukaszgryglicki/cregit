0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
f3056e072b415333fc98a56dca4f7c3ce0500039;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package certificate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		keyExtension  = ".key"
0000000000000000000000000000000000000000;;		certExtension = ".crt"
0000000000000000000000000000000000000000;;		pemExtension  = ".pem"
0000000000000000000000000000000000000000;;		currentPair   = "current"
0000000000000000000000000000000000000000;;		updatedPair   = "updated"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fileStore struct {
0000000000000000000000000000000000000000;;		pairNamePrefix string
0000000000000000000000000000000000000000;;		certDirectory  string
0000000000000000000000000000000000000000;;		keyDirectory   string
0000000000000000000000000000000000000000;;		certFile       string
0000000000000000000000000000000000000000;;		keyFile        string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFileStore returns a concrete implementation of a Store that is based on
0000000000000000000000000000000000000000;;	// storing the cert/key pairs in a single file per pair on disk in the
0000000000000000000000000000000000000000;;	// designated directory. When starting up it will look for the currently
0000000000000000000000000000000000000000;;	// selected cert/key pair in:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 1. ${certDirectory}/${pairNamePrefix}-current.pem - both cert and key are in the same file.
0000000000000000000000000000000000000000;;	// 2. ${certFile}, ${keyFile}
0000000000000000000000000000000000000000;;	// 3. ${certDirectory}/${pairNamePrefix}.crt, ${keyDirectory}/${pairNamePrefix}.key
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The first one found will be used. If rotation is enabled, future cert/key
0000000000000000000000000000000000000000;;	// updates will be written to the ${certDirectory} directory and
0000000000000000000000000000000000000000;;	// ${certDirectory}/${pairNamePrefix}-current.pem will be created as a soft
0000000000000000000000000000000000000000;;	// link to the currently selected cert/key pair.
0000000000000000000000000000000000000000;;	func NewFileStore(
0000000000000000000000000000000000000000;;		pairNamePrefix string,
0000000000000000000000000000000000000000;;		certDirectory string,
0000000000000000000000000000000000000000;;		keyDirectory string,
0000000000000000000000000000000000000000;;		certFile string,
0000000000000000000000000000000000000000;;		keyFile string) (Store, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := fileStore{
0000000000000000000000000000000000000000;;			pairNamePrefix: pairNamePrefix,
0000000000000000000000000000000000000000;;			certDirectory:  certDirectory,
0000000000000000000000000000000000000000;;			keyDirectory:   keyDirectory,
0000000000000000000000000000000000000000;;			certFile:       certFile,
0000000000000000000000000000000000000000;;			keyFile:        keyFile,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := s.recover(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recover checks if there is a certificate rotation that was interrupted while
0000000000000000000000000000000000000000;;	// progress, and if so, attempts to recover to a good state.
0000000000000000000000000000000000000000;;	func (s *fileStore) recover() error {
0000000000000000000000000000000000000000;;		// If the 'current' file doesn't exist, continue on with the recovery process.
0000000000000000000000000000000000000000;;		currentPath := filepath.Join(s.certDirectory, s.filename(currentPair))
0000000000000000000000000000000000000000;;		if exists, err := util.FileExists(currentPath); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else if exists {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the 'updated' file exists, and it is a symbolic link, continue on
0000000000000000000000000000000000000000;;		// with the recovery process.
0000000000000000000000000000000000000000;;		updatedPath := filepath.Join(s.certDirectory, s.filename(updatedPair))
0000000000000000000000000000000000000000;;		if fi, err := os.Lstat(updatedPath); err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else if fi.Mode()&os.ModeSymlink != os.ModeSymlink {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected %q to be a symlink but it is a file.", updatedPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Move the 'updated' symlink to 'current'.
0000000000000000000000000000000000000000;;		if err := os.Rename(updatedPath, currentPath); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to rename %q to %q: %v", updatedPath, currentPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *fileStore) Current() (*tls.Certificate, error) {
0000000000000000000000000000000000000000;;		pairFile := filepath.Join(s.certDirectory, s.filename(currentPair))
0000000000000000000000000000000000000000;;		if pairFileExists, err := util.FileExists(pairFile); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		} else if pairFileExists {
0000000000000000000000000000000000000000;;			glog.Infof("Loading cert/key pair from %q.", pairFile)
0000000000000000000000000000000000000000;;			return loadFile(pairFile)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certFileExists, err := util.FileExists(s.certFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		keyFileExists, err := util.FileExists(s.keyFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if certFileExists && keyFileExists {
0000000000000000000000000000000000000000;;			glog.Infof("Loading cert/key pair from (%q, %q).", s.certFile, s.keyFile)
0000000000000000000000000000000000000000;;			return loadX509KeyPair(s.certFile, s.keyFile)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := filepath.Join(s.certDirectory, s.pairNamePrefix+certExtension)
0000000000000000000000000000000000000000;;		k := filepath.Join(s.keyDirectory, s.pairNamePrefix+keyExtension)
0000000000000000000000000000000000000000;;		certFileExists, err = util.FileExists(c)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		keyFileExists, err = util.FileExists(k)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if certFileExists && keyFileExists {
0000000000000000000000000000000000000000;;			glog.Infof("Loading cert/key pair from (%q, %q).", c, k)
0000000000000000000000000000000000000000;;			return loadX509KeyPair(c, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		noKeyErr := NoCertKeyError(
0000000000000000000000000000000000000000;;			fmt.Sprintf("no cert/key files read at %q, (%q, %q) or (%q, %q)",
0000000000000000000000000000000000000000;;				pairFile,
0000000000000000000000000000000000000000;;				s.certFile,
0000000000000000000000000000000000000000;;				s.keyFile,
0000000000000000000000000000000000000000;;				s.certDirectory,
0000000000000000000000000000000000000000;;				s.keyDirectory))
0000000000000000000000000000000000000000;;		return nil, &noKeyErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func loadFile(pairFile string) (*tls.Certificate, error) {
0000000000000000000000000000000000000000;;		certBlock, keyBlock, err := loadCertKeyBlocks(pairFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cert, err := tls.X509KeyPair(pem.EncodeToMemory(certBlock), pem.EncodeToMemory(keyBlock))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("could not convert data from %q into cert/key pair: %v", pairFile, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		certs, err := x509.ParseCertificates(cert.Certificate[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to parse certificate data: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cert.Leaf = certs[0]
0000000000000000000000000000000000000000;;		return &cert, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func loadCertKeyBlocks(pairFile string) (cert *pem.Block, key *pem.Block, err error) {
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile(pairFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("could not load cert/key pair from %q: %v", pairFile, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		certBlock, rest := pem.Decode(data)
0000000000000000000000000000000000000000;;		if certBlock == nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("could not decode the first block from %q from expected PEM format", pairFile)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		keyBlock, rest := pem.Decode(rest)
0000000000000000000000000000000000000000;;		if keyBlock == nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("could not decode the second block from %q from expected PEM format", pairFile)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return certBlock, keyBlock, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *fileStore) Update(certData, keyData []byte) (*tls.Certificate, error) {
0000000000000000000000000000000000000000;;		ts := time.Now().Format("2006-01-02-15-04-05")
0000000000000000000000000000000000000000;;		pemFilename := s.filename(ts)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(s.certDirectory, 0755); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("could not create directory %q to store certificates: %v", s.certDirectory, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		certPath := filepath.Join(s.certDirectory, pemFilename)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := os.OpenFile(certPath, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0600)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("could not open %q: %v", certPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;		certBlock, _ := pem.Decode(certData)
0000000000000000000000000000000000000000;;		if certBlock == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid certificate data")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pem.Encode(f, certBlock)
0000000000000000000000000000000000000000;;		keyBlock, _ := pem.Decode(keyData)
0000000000000000000000000000000000000000;;		if keyBlock == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid key data")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pem.Encode(f, keyBlock)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cert, err := loadFile(certPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := s.updateSymlink(certPath); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cert, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateSymLink updates the current symlink to point to the file that is
0000000000000000000000000000000000000000;;	// passed it. It will fail if there is a non-symlink file exists where the
0000000000000000000000000000000000000000;;	// symlink is expected to be.
0000000000000000000000000000000000000000;;	func (s *fileStore) updateSymlink(filename string) error {
0000000000000000000000000000000000000000;;		// If the 'current' file either doesn't exist, or is already a symlink,
0000000000000000000000000000000000000000;;		// proceed. Otherwise, this is an unrecoverable error.
0000000000000000000000000000000000000000;;		currentPath := filepath.Join(s.certDirectory, s.filename(currentPair))
0000000000000000000000000000000000000000;;		currentPathExists := false
0000000000000000000000000000000000000000;;		if fi, err := os.Lstat(currentPath); err != nil {
0000000000000000000000000000000000000000;;			if !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if fi.Mode()&os.ModeSymlink != os.ModeSymlink {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected %q to be a symlink but it is a file.", currentPath)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			currentPathExists = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the 'updated' file doesn't exist, proceed. If it exists but it is a
0000000000000000000000000000000000000000;;		// symlink, delete it.  Otherwise, this is an unrecoverable error.
0000000000000000000000000000000000000000;;		updatedPath := filepath.Join(s.certDirectory, s.filename(updatedPair))
0000000000000000000000000000000000000000;;		if fi, err := os.Lstat(updatedPath); err != nil {
0000000000000000000000000000000000000000;;			if !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if fi.Mode()&os.ModeSymlink != os.ModeSymlink {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected %q to be a symlink but it is a file.", updatedPath)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if err := os.Remove(updatedPath); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to remove %q: %v", updatedPath, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check that the new cert/key pair file exists to avoid rotating to an
0000000000000000000000000000000000000000;;		// invalid cert/key.
0000000000000000000000000000000000000000;;		if filenameExists, err := util.FileExists(filename); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else if !filenameExists {
0000000000000000000000000000000000000000;;			return fmt.Errorf("file %q does not exist so it can not be used as the currently selected cert/key", filename)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the 'updated' symlink pointing to the requested file name.
0000000000000000000000000000000000000000;;		if err := os.Symlink(filename, updatedPath); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to create a symlink from %q to %q: %v", updatedPath, filename, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Replace the 'current' symlink.
0000000000000000000000000000000000000000;;		if currentPathExists {
0000000000000000000000000000000000000000;;			if err := os.Remove(currentPath); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to remove %q: %v", currentPath, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := os.Rename(updatedPath, currentPath); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to rename %q to %q: %v", updatedPath, currentPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *fileStore) filename(qualifier string) string {
0000000000000000000000000000000000000000;;		return s.pairNamePrefix + "-" + qualifier + pemExtension
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// withoutExt returns the given filename after removing the extension. The
0000000000000000000000000000000000000000;;	// extension to remove will be the result of filepath.Ext().
0000000000000000000000000000000000000000;;	func withoutExt(filename string) string {
0000000000000000000000000000000000000000;;		return strings.TrimSuffix(filename, filepath.Ext(filename))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func loadX509KeyPair(certFile, keyFile string) (*tls.Certificate, error) {
0000000000000000000000000000000000000000;;		cert, err := tls.LoadX509KeyPair(certFile, keyFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		certs, err := x509.ParseCertificates(cert.Certificate[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to parse certificate data: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cert.Leaf = certs[0]
0000000000000000000000000000000000000000;;		return &cert, nil
0000000000000000000000000000000000000000;;	}
