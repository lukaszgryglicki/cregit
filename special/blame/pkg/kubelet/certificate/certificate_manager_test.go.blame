0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
f3056e072b415333fc98a56dca4f7c3ce0500039;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package certificate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"crypto/x509/pkix"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certificates "k8s.io/api/certificates/v1beta1"
0000000000000000000000000000000000000000;;		v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		watch "k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		certificatesclient "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/certificates/v1beta1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type certificateData struct {
0000000000000000000000000000000000000000;;		keyPEM         []byte
0000000000000000000000000000000000000000;;		certificatePEM []byte
0000000000000000000000000000000000000000;;		certificate    *tls.Certificate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var storeCertData = newCertificateData(`-----BEGIN CERTIFICATE-----
0000000000000000000000000000000000000000;;	MIICRzCCAfGgAwIBAgIJALMb7ecMIk3MMA0GCSqGSIb3DQEBCwUAMH4xCzAJBgNV
0000000000000000000000000000000000000000;;	BAYTAkdCMQ8wDQYDVQQIDAZMb25kb24xDzANBgNVBAcMBkxvbmRvbjEYMBYGA1UE
0000000000000000000000000000000000000000;;	CgwPR2xvYmFsIFNlY3VyaXR5MRYwFAYDVQQLDA1JVCBEZXBhcnRtZW50MRswGQYD
0000000000000000000000000000000000000000;;	VQQDDBJ0ZXN0LWNlcnRpZmljYXRlLTAwIBcNMTcwNDI2MjMyNjUyWhgPMjExNzA0
0000000000000000000000000000000000000000;;	MDIyMzI2NTJaMH4xCzAJBgNVBAYTAkdCMQ8wDQYDVQQIDAZMb25kb24xDzANBgNV
0000000000000000000000000000000000000000;;	BAcMBkxvbmRvbjEYMBYGA1UECgwPR2xvYmFsIFNlY3VyaXR5MRYwFAYDVQQLDA1J
0000000000000000000000000000000000000000;;	VCBEZXBhcnRtZW50MRswGQYDVQQDDBJ0ZXN0LWNlcnRpZmljYXRlLTAwXDANBgkq
0000000000000000000000000000000000000000;;	hkiG9w0BAQEFAANLADBIAkEAtBMa7NWpv3BVlKTCPGO/LEsguKqWHBtKzweMY2CV
0000000000000000000000000000000000000000;;	tAL1rQm913huhxF9w+ai76KQ3MHK5IVnLJjYYA5MzP2H5QIDAQABo1AwTjAdBgNV
0000000000000000000000000000000000000000;;	HQ4EFgQU22iy8aWkNSxv0nBxFxerfsvnZVMwHwYDVR0jBBgwFoAU22iy8aWkNSxv
0000000000000000000000000000000000000000;;	0nBxFxerfsvnZVMwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAANBAEOefGbV
0000000000000000000000000000000000000000;;	NcHxklaW06w6OBYJPwpIhCVozC1qdxGX1dg8VkEKzjOzjgqVD30m59OFmSlBmHsl
0000000000000000000000000000000000000000;;	nkVA6wyOSDYBf3o=
0000000000000000000000000000000000000000;;	-----END CERTIFICATE-----`, `-----BEGIN RSA PRIVATE KEY-----
0000000000000000000000000000000000000000;;	MIIBUwIBADANBgkqhkiG9w0BAQEFAASCAT0wggE5AgEAAkEAtBMa7NWpv3BVlKTC
0000000000000000000000000000000000000000;;	PGO/LEsguKqWHBtKzweMY2CVtAL1rQm913huhxF9w+ai76KQ3MHK5IVnLJjYYA5M
0000000000000000000000000000000000000000;;	zP2H5QIDAQABAkAS9BfXab3OKpK3bIgNNyp+DQJKrZnTJ4Q+OjsqkpXvNltPJosf
0000000000000000000000000000000000000000;;	G8GsiKu/vAt4HGqI3eU77NvRI+mL4MnHRmXBAiEA3qM4FAtKSRBbcJzPxxLEUSwg
0000000000000000000000000000000000000000;;	XSCcosCktbkXvpYrS30CIQDPDxgqlwDEJQ0uKuHkZI38/SPWWqfUmkecwlbpXABK
0000000000000000000000000000000000000000;;	iQIgZX08DA8VfvcA5/Xj1Zjdey9FVY6POLXen6RPiabE97UCICp6eUW7ht+2jjar
0000000000000000000000000000000000000000;;	e35EltCRCjoejRHTuN9TC0uCoVipAiAXaJIx/Q47vGwiw6Y8KXsNU6y54gTbOSxX
0000000000000000000000000000000000000000;;	54LzHNk/+Q==
0000000000000000000000000000000000000000;;	-----END RSA PRIVATE KEY-----`)
0000000000000000000000000000000000000000;;	var bootstrapCertData = newCertificateData(
0000000000000000000000000000000000000000;;		`-----BEGIN CERTIFICATE-----
0000000000000000000000000000000000000000;;	MIICRzCCAfGgAwIBAgIJANXr+UzRFq4TMA0GCSqGSIb3DQEBCwUAMH4xCzAJBgNV
0000000000000000000000000000000000000000;;	BAYTAkdCMQ8wDQYDVQQIDAZMb25kb24xDzANBgNVBAcMBkxvbmRvbjEYMBYGA1UE
0000000000000000000000000000000000000000;;	CgwPR2xvYmFsIFNlY3VyaXR5MRYwFAYDVQQLDA1JVCBEZXBhcnRtZW50MRswGQYD
0000000000000000000000000000000000000000;;	VQQDDBJ0ZXN0LWNlcnRpZmljYXRlLTEwIBcNMTcwNDI2MjMyNzMyWhgPMjExNzA0
0000000000000000000000000000000000000000;;	MDIyMzI3MzJaMH4xCzAJBgNVBAYTAkdCMQ8wDQYDVQQIDAZMb25kb24xDzANBgNV
0000000000000000000000000000000000000000;;	BAcMBkxvbmRvbjEYMBYGA1UECgwPR2xvYmFsIFNlY3VyaXR5MRYwFAYDVQQLDA1J
0000000000000000000000000000000000000000;;	VCBEZXBhcnRtZW50MRswGQYDVQQDDBJ0ZXN0LWNlcnRpZmljYXRlLTEwXDANBgkq
0000000000000000000000000000000000000000;;	hkiG9w0BAQEFAANLADBIAkEAqvbkN4RShH1rL37JFp4fZPnn0JUhVWWsrP8NOomJ
0000000000000000000000000000000000000000;;	pXdBDUMGWuEQIsZ1Gf9JrCQLu6ooRyHSKRFpAVbMQ3ABJwIDAQABo1AwTjAdBgNV
0000000000000000000000000000000000000000;;	HQ4EFgQUEGBc6YYheEZ/5MhwqSUYYPYRj2MwHwYDVR0jBBgwFoAUEGBc6YYheEZ/
0000000000000000000000000000000000000000;;	5MhwqSUYYPYRj2MwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAANBAIyNmznk
0000000000000000000000000000000000000000;;	5dgJY52FppEEcfQRdS5k4XFPc22SHPcz77AHf5oWZ1WG9VezOZZPp8NCiFDDlDL8
0000000000000000000000000000000000000000;;	yma33a5eMyTjLD8=
0000000000000000000000000000000000000000;;	-----END CERTIFICATE-----`, `-----BEGIN RSA PRIVATE KEY-----
0000000000000000000000000000000000000000;;	MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEAqvbkN4RShH1rL37J
0000000000000000000000000000000000000000;;	Fp4fZPnn0JUhVWWsrP8NOomJpXdBDUMGWuEQIsZ1Gf9JrCQLu6ooRyHSKRFpAVbM
0000000000000000000000000000000000000000;;	Q3ABJwIDAQABAkBC2OBpGLMPHN8BJijIUDFkURakBvuOoX+/8MYiYk7QxEmfLCk6
0000000000000000000000000000000000000000;;	L6r+GLNFMfXwXcBmXtMKfZKAIKutKf098JaBAiEA10azfqt3G/5owrNA00plSyT6
0000000000000000000000000000000000000000;;	ZmHPzY9Uq1p/QTR/uOcCIQDLTkfBkLHm0UKeobbO/fSm6ZflhyBRDINy4FvwmZMt
0000000000000000000000000000000000000000;;	wQIgYV/tmQJeIh91q3wBepFQOClFykG8CTMoDUol/YyNqUkCIHfp6Rr7fGL3JIMq
0000000000000000000000000000000000000000;;	QQgf9DCK8SPZqq8DYXjdan0kKBJBAiEAyDb+07o2gpggo8BYUKSaiRCiyXfaq87f
0000000000000000000000000000000000000000;;	eVqgpBq/QN4=
0000000000000000000000000000000000000000;;	-----END RSA PRIVATE KEY-----`)
0000000000000000000000000000000000000000;;	var apiServerCertData = newCertificateData(
0000000000000000000000000000000000000000;;		`-----BEGIN CERTIFICATE-----
0000000000000000000000000000000000000000;;	MIICRzCCAfGgAwIBAgIJAIydTIADd+yqMA0GCSqGSIb3DQEBCwUAMH4xCzAJBgNV
0000000000000000000000000000000000000000;;	BAYTAkdCMQ8wDQYDVQQIDAZMb25kb24xDzANBgNVBAcMBkxvbmRvbjEYMBYGA1UE
0000000000000000000000000000000000000000;;	CgwPR2xvYmFsIFNlY3VyaXR5MRYwFAYDVQQLDA1JVCBEZXBhcnRtZW50MRswGQYD
0000000000000000000000000000000000000000;;	VQQDDBJ0ZXN0LWNlcnRpZmljYXRlLTIwIBcNMTcwNDI2MjMyNDU4WhgPMjExNzA0
0000000000000000000000000000000000000000;;	MDIyMzI0NThaMH4xCzAJBgNVBAYTAkdCMQ8wDQYDVQQIDAZMb25kb24xDzANBgNV
0000000000000000000000000000000000000000;;	BAcMBkxvbmRvbjEYMBYGA1UECgwPR2xvYmFsIFNlY3VyaXR5MRYwFAYDVQQLDA1J
0000000000000000000000000000000000000000;;	VCBEZXBhcnRtZW50MRswGQYDVQQDDBJ0ZXN0LWNlcnRpZmljYXRlLTIwXDANBgkq
0000000000000000000000000000000000000000;;	hkiG9w0BAQEFAANLADBIAkEAuiRet28DV68Dk4A8eqCaqgXmymamUEjW/DxvIQqH
0000000000000000000000000000000000000000;;	3lbhtm8BwSnS9wUAajSLSWiq3fci2RbRgaSPjUrnbOHCLQIDAQABo1AwTjAdBgNV
0000000000000000000000000000000000000000;;	HQ4EFgQU0vhI4OPGEOqT+VAWwxdhVvcmgdIwHwYDVR0jBBgwFoAU0vhI4OPGEOqT
0000000000000000000000000000000000000000;;	+VAWwxdhVvcmgdIwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAANBALNeJGDe
0000000000000000000000000000000000000000;;	nV5cXbp9W1bC12Tc8nnNXn4ypLE2JTQAvyp51zoZ8hQoSnRVx/VCY55Yu+br8gQZ
0000000000000000000000000000000000000000;;	+tW+O/PoE7B3tuY=
0000000000000000000000000000000000000000;;	-----END CERTIFICATE-----`, `-----BEGIN RSA PRIVATE KEY-----
0000000000000000000000000000000000000000;;	MIIBVgIBADANBgkqhkiG9w0BAQEFAASCAUAwggE8AgEAAkEAuiRet28DV68Dk4A8
0000000000000000000000000000000000000000;;	eqCaqgXmymamUEjW/DxvIQqH3lbhtm8BwSnS9wUAajSLSWiq3fci2RbRgaSPjUrn
0000000000000000000000000000000000000000;;	bOHCLQIDAQABAkEArDR1g9IqD3aUImNikDgAngbzqpAokOGyMoxeavzpEaFOgCzi
0000000000000000000000000000000000000000;;	gi7HF7yHRmZkUt8CzdEvnHSqRjFuaaB0gGA+AQIhAOc8Z1h8ElLRSqaZGgI3jCTp
0000000000000000000000000000000000000000;;	Izx9HNY//U5NGrXD2+ttAiEAzhOqkqI4+nDab7FpiD7MXI6fO549mEXeVBPvPtsS
0000000000000000000000000000000000000000;;	OcECIQCIfkpOm+ZBBpO3JXaJynoqK4gGI6ALA/ik6LSUiIlfPQIhAISjd9hlfZME
0000000000000000000000000000000000000000;;	bDQT1r8Q3Gx+h9LRqQeHgPBQ3F5ylqqBAiBaJ0hkYvrIdWxNlcLqD3065bJpHQ4S
0000000000000000000000000000000000000000;;	WQkuZUQN1M/Xvg==
0000000000000000000000000000000000000000;;	-----END RSA PRIVATE KEY-----`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newCertificateData(certificatePEM string, keyPEM string) *certificateData {
0000000000000000000000000000000000000000;;		certificate, err := tls.X509KeyPair([]byte(certificatePEM), []byte(keyPEM))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("Unable to initialize certificate: %v", err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		certs, err := x509.ParseCertificates(certificate.Certificate[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("Unable to initialize certificate leaf: %v", err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		certificate.Leaf = certs[0]
0000000000000000000000000000000000000000;;		return &certificateData{
0000000000000000000000000000000000000000;;			keyPEM:         []byte(keyPEM),
0000000000000000000000000000000000000000;;			certificatePEM: []byte(certificatePEM),
0000000000000000000000000000000000000000;;			certificate:    &certificate,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewManagerNoRotation(t *testing.T) {
0000000000000000000000000000000000000000;;		store := &fakeStore{
0000000000000000000000000000000000000000;;			cert: storeCertData.certificate,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := NewManager(&Config{
0000000000000000000000000000000000000000;;			Template:         &x509.CertificateRequest{},
0000000000000000000000000000000000000000;;			Usages:           []certificates.KeyUsage{},
0000000000000000000000000000000000000000;;			CertificateStore: store,
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to initialize the certificate manager: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestShouldRotate(t *testing.T) {
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name         string
0000000000000000000000000000000000000000;;			notBefore    time.Time
0000000000000000000000000000000000000000;;			notAfter     time.Time
0000000000000000000000000000000000000000;;			shouldRotate bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"just issued, still good", now.Add(-1 * time.Hour), now.Add(99 * time.Hour), false},
0000000000000000000000000000000000000000;;			{"half way expired, still good", now.Add(-24 * time.Hour), now.Add(24 * time.Hour), false},
0000000000000000000000000000000000000000;;			{"mostly expired, still good", now.Add(-69 * time.Hour), now.Add(31 * time.Hour), false},
0000000000000000000000000000000000000000;;			{"just about expired, should rotate", now.Add(-91 * time.Hour), now.Add(9 * time.Hour), true},
0000000000000000000000000000000000000000;;			{"nearly expired, should rotate", now.Add(-99 * time.Hour), now.Add(1 * time.Hour), true},
0000000000000000000000000000000000000000;;			{"already expired, should rotate", now.Add(-10 * time.Hour), now.Add(-1 * time.Hour), true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			t.Run(test.name, func(t *testing.T) {
0000000000000000000000000000000000000000;;				m := manager{
0000000000000000000000000000000000000000;;					cert: &tls.Certificate{
0000000000000000000000000000000000000000;;						Leaf: &x509.Certificate{
0000000000000000000000000000000000000000;;							NotBefore: test.notBefore,
0000000000000000000000000000000000000000;;							NotAfter:  test.notAfter,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					template: &x509.CertificateRequest{},
0000000000000000000000000000000000000000;;					usages:   []certificates.KeyUsage{},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				m.setRotationDeadline()
0000000000000000000000000000000000000000;;				if m.shouldRotate() != test.shouldRotate {
0000000000000000000000000000000000000000;;					t.Errorf("Time %v, a certificate issued for (%v, %v) should rotate should be %t.",
0000000000000000000000000000000000000000;;						now,
0000000000000000000000000000000000000000;;						m.cert.Leaf.NotBefore,
0000000000000000000000000000000000000000;;						m.cert.Leaf.NotAfter,
0000000000000000000000000000000000000000;;						test.shouldRotate)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetRotationDeadline(t *testing.T) {
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			name         string
0000000000000000000000000000000000000000;;			notBefore    time.Time
0000000000000000000000000000000000000000;;			notAfter     time.Time
0000000000000000000000000000000000000000;;			shouldRotate bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"just issued, still good", now.Add(-1 * time.Hour), now.Add(99 * time.Hour), false},
0000000000000000000000000000000000000000;;			{"half way expired, still good", now.Add(-24 * time.Hour), now.Add(24 * time.Hour), false},
0000000000000000000000000000000000000000;;			{"mostly expired, still good", now.Add(-69 * time.Hour), now.Add(31 * time.Hour), false},
0000000000000000000000000000000000000000;;			{"just about expired, should rotate", now.Add(-91 * time.Hour), now.Add(9 * time.Hour), true},
0000000000000000000000000000000000000000;;			{"nearly expired, should rotate", now.Add(-99 * time.Hour), now.Add(1 * time.Hour), true},
0000000000000000000000000000000000000000;;			{"already expired, should rotate", now.Add(-10 * time.Hour), now.Add(-1 * time.Hour), true},
0000000000000000000000000000000000000000;;			{"long duration", now.Add(-6 * 30 * 24 * time.Hour), now.Add(6 * 30 * 24 * time.Hour), true},
0000000000000000000000000000000000000000;;			{"short duration", now.Add(-30 * time.Second), now.Add(30 * time.Second), true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			t.Run(tc.name, func(t *testing.T) {
0000000000000000000000000000000000000000;;				m := manager{
0000000000000000000000000000000000000000;;					cert: &tls.Certificate{
0000000000000000000000000000000000000000;;						Leaf: &x509.Certificate{
0000000000000000000000000000000000000000;;							NotBefore: tc.notBefore,
0000000000000000000000000000000000000000;;							NotAfter:  tc.notAfter,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					template: &x509.CertificateRequest{},
0000000000000000000000000000000000000000;;					usages:   []certificates.KeyUsage{},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				lowerBound := tc.notBefore.Add(time.Duration(float64(tc.notAfter.Sub(tc.notBefore)) * 0.7))
0000000000000000000000000000000000000000;;				upperBound := tc.notBefore.Add(time.Duration(float64(tc.notAfter.Sub(tc.notBefore)) * 0.9))
0000000000000000000000000000000000000000;;				for i := 0; i < 1000; i++ {
0000000000000000000000000000000000000000;;					// setRotationDeadline includes jitter, so this needs to run many times for validation.
0000000000000000000000000000000000000000;;					m.setRotationDeadline()
0000000000000000000000000000000000000000;;					if m.rotationDeadline.Before(lowerBound) || m.rotationDeadline.After(upperBound) {
0000000000000000000000000000000000000000;;						t.Errorf("For notBefore %v, notAfter %v, the rotationDeadline %v should be between %v and %v.",
0000000000000000000000000000000000000000;;							tc.notBefore,
0000000000000000000000000000000000000000;;							tc.notAfter,
0000000000000000000000000000000000000000;;							m.rotationDeadline,
0000000000000000000000000000000000000000;;							lowerBound,
0000000000000000000000000000000000000000;;							upperBound)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRotateCertCreateCSRError(t *testing.T) {
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		m := manager{
0000000000000000000000000000000000000000;;			cert: &tls.Certificate{
0000000000000000000000000000000000000000;;				Leaf: &x509.Certificate{
0000000000000000000000000000000000000000;;					NotBefore: now.Add(-2 * time.Hour),
0000000000000000000000000000000000000000;;					NotAfter:  now.Add(-1 * time.Hour),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			template: &x509.CertificateRequest{},
0000000000000000000000000000000000000000;;			usages:   []certificates.KeyUsage{},
0000000000000000000000000000000000000000;;			certSigningRequestClient: fakeClient{
0000000000000000000000000000000000000000;;				failureType: createError,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if success, err := m.rotateCerts(); success {
0000000000000000000000000000000000000000;;			t.Errorf("Got success from 'rotateCerts', wanted failure")
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got error %v from 'rotateCerts', wanted no error.", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRotateCertWaitingForResultError(t *testing.T) {
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		m := manager{
0000000000000000000000000000000000000000;;			cert: &tls.Certificate{
0000000000000000000000000000000000000000;;				Leaf: &x509.Certificate{
0000000000000000000000000000000000000000;;					NotBefore: now.Add(-2 * time.Hour),
0000000000000000000000000000000000000000;;					NotAfter:  now.Add(-1 * time.Hour),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			template: &x509.CertificateRequest{},
0000000000000000000000000000000000000000;;			usages:   []certificates.KeyUsage{},
0000000000000000000000000000000000000000;;			certSigningRequestClient: fakeClient{
0000000000000000000000000000000000000000;;				failureType: watchError,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if success, err := m.rotateCerts(); success {
0000000000000000000000000000000000000000;;			t.Errorf("Got success from 'rotateCerts', wanted failure.")
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got error %v from 'rotateCerts', wanted no error.", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewManagerBootstrap(t *testing.T) {
0000000000000000000000000000000000000000;;		store := &fakeStore{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var cm Manager
0000000000000000000000000000000000000000;;		cm, err := NewManager(&Config{
0000000000000000000000000000000000000000;;			Template:                &x509.CertificateRequest{},
0000000000000000000000000000000000000000;;			Usages:                  []certificates.KeyUsage{},
0000000000000000000000000000000000000000;;			CertificateStore:        store,
0000000000000000000000000000000000000000;;			BootstrapCertificatePEM: bootstrapCertData.certificatePEM,
0000000000000000000000000000000000000000;;			BootstrapKeyPEM:         bootstrapCertData.keyPEM,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to initialize the certificate manager: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cert := cm.Current()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cert == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Certificate was nil, expected something.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m, ok := cm.(*manager); !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Expected a '*manager' from 'NewManager'")
0000000000000000000000000000000000000000;;		} else if !m.shouldRotate() {
0000000000000000000000000000000000000000;;			t.Errorf("Expected rotation should happen during bootstrap, but it won't.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewManagerNoBootstrap(t *testing.T) {
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		cert, err := tls.X509KeyPair(storeCertData.certificatePEM, storeCertData.keyPEM)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unable to initialize a certificate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cert.Leaf = &x509.Certificate{
0000000000000000000000000000000000000000;;			NotBefore: now.Add(-24 * time.Hour),
0000000000000000000000000000000000000000;;			NotAfter:  now.Add(24 * time.Hour),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		store := &fakeStore{
0000000000000000000000000000000000000000;;			cert: &cert,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cm, err := NewManager(&Config{
0000000000000000000000000000000000000000;;			Template:                &x509.CertificateRequest{},
0000000000000000000000000000000000000000;;			Usages:                  []certificates.KeyUsage{},
0000000000000000000000000000000000000000;;			CertificateStore:        store,
0000000000000000000000000000000000000000;;			BootstrapCertificatePEM: bootstrapCertData.certificatePEM,
0000000000000000000000000000000000000000;;			BootstrapKeyPEM:         bootstrapCertData.keyPEM,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to initialize the certificate manager: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currentCert := cm.Current()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if currentCert == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Certificate was nil, expected something.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m, ok := cm.(*manager); !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Expected a '*manager' from 'NewManager'")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			m.setRotationDeadline()
0000000000000000000000000000000000000000;;			if m.shouldRotate() {
0000000000000000000000000000000000000000;;				t.Errorf("Expected rotation should happen during bootstrap, but it won't.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetCurrentCertificateOrBootstrap(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			description          string
0000000000000000000000000000000000000000;;			storeCert            *tls.Certificate
0000000000000000000000000000000000000000;;			bootstrapCertData    []byte
0000000000000000000000000000000000000000;;			bootstrapKeyData     []byte
0000000000000000000000000000000000000000;;			expectedCert         *tls.Certificate
0000000000000000000000000000000000000000;;			expectedShouldRotate bool
0000000000000000000000000000000000000000;;			expectedErrMsg       string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"return cert from store",
0000000000000000000000000000000000000000;;				storeCertData.certificate,
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				storeCertData.certificate,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				"",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"no cert in store and no bootstrap cert",
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;				"",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			t.Run(tc.description, func(t *testing.T) {
0000000000000000000000000000000000000000;;				store := &fakeStore{
0000000000000000000000000000000000000000;;					cert: tc.storeCert,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				certResult, shouldRotate, err := getCurrentCertificateOrBootstrap(
0000000000000000000000000000000000000000;;					store,
0000000000000000000000000000000000000000;;					tc.bootstrapCertData,
0000000000000000000000000000000000000000;;					tc.bootstrapKeyData)
0000000000000000000000000000000000000000;;				if certResult == nil || certResult.Certificate == nil || tc.expectedCert == nil {
0000000000000000000000000000000000000000;;					if certResult != nil && tc.expectedCert != nil {
0000000000000000000000000000000000000000;;						t.Errorf("Got certificate %v, wanted %v", certResult, tc.expectedCert)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if !certificatesEqual(certResult, tc.expectedCert) {
0000000000000000000000000000000000000000;;						t.Errorf("Got certificate %v, wanted %v", certResult, tc.expectedCert)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if shouldRotate != tc.expectedShouldRotate {
0000000000000000000000000000000000000000;;					t.Errorf("Got shouldRotate %t, wanted %t", shouldRotate, tc.expectedShouldRotate)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					if tc.expectedErrMsg != "" {
0000000000000000000000000000000000000000;;						t.Errorf("Got err %v, wanted %q", err, tc.expectedErrMsg)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if tc.expectedErrMsg == "" || !strings.Contains(err.Error(), tc.expectedErrMsg) {
0000000000000000000000000000000000000000;;						t.Errorf("Got err %v, wanted %q", err, tc.expectedErrMsg)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInitializeCertificateSigningRequestClient(t *testing.T) {
0000000000000000000000000000000000000000;;		var nilCertificate = &certificateData{}
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			description             string
0000000000000000000000000000000000000000;;			storeCert               *certificateData
0000000000000000000000000000000000000000;;			bootstrapCert           *certificateData
0000000000000000000000000000000000000000;;			apiCert                 *certificateData
0000000000000000000000000000000000000000;;			expectedCertBeforeStart *certificateData
0000000000000000000000000000000000000000;;			expectedCertAfterStart  *certificateData
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:             "No current certificate, no bootstrap certificate",
0000000000000000000000000000000000000000;;				storeCert:               nilCertificate,
0000000000000000000000000000000000000000;;				bootstrapCert:           nilCertificate,
0000000000000000000000000000000000000000;;				apiCert:                 apiServerCertData,
0000000000000000000000000000000000000000;;				expectedCertBeforeStart: nilCertificate,
0000000000000000000000000000000000000000;;				expectedCertAfterStart:  apiServerCertData,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:             "No current certificate, bootstrap certificate",
0000000000000000000000000000000000000000;;				storeCert:               nilCertificate,
0000000000000000000000000000000000000000;;				bootstrapCert:           bootstrapCertData,
0000000000000000000000000000000000000000;;				apiCert:                 apiServerCertData,
0000000000000000000000000000000000000000;;				expectedCertBeforeStart: bootstrapCertData,
0000000000000000000000000000000000000000;;				expectedCertAfterStart:  apiServerCertData,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:             "Current certificate, no bootstrap certificate",
0000000000000000000000000000000000000000;;				storeCert:               storeCertData,
0000000000000000000000000000000000000000;;				bootstrapCert:           nilCertificate,
0000000000000000000000000000000000000000;;				apiCert:                 apiServerCertData,
0000000000000000000000000000000000000000;;				expectedCertBeforeStart: storeCertData,
0000000000000000000000000000000000000000;;				expectedCertAfterStart:  storeCertData,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:             "Current certificate, bootstrap certificate",
0000000000000000000000000000000000000000;;				storeCert:               storeCertData,
0000000000000000000000000000000000000000;;				bootstrapCert:           bootstrapCertData,
0000000000000000000000000000000000000000;;				apiCert:                 apiServerCertData,
0000000000000000000000000000000000000000;;				expectedCertBeforeStart: storeCertData,
0000000000000000000000000000000000000000;;				expectedCertAfterStart:  storeCertData,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			t.Run(tc.description, func(t *testing.T) {
0000000000000000000000000000000000000000;;				certificateStore := &fakeStore{
0000000000000000000000000000000000000000;;					cert: tc.storeCert.certificate,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				certificateManager, err := NewManager(&Config{
0000000000000000000000000000000000000000;;					Template: &x509.CertificateRequest{
0000000000000000000000000000000000000000;;						Subject: pkix.Name{
0000000000000000000000000000000000000000;;							Organization: []string{"system:nodes"},
0000000000000000000000000000000000000000;;							CommonName:   "system:node:fake-node-name",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Usages: []certificates.KeyUsage{
0000000000000000000000000000000000000000;;						certificates.UsageDigitalSignature,
0000000000000000000000000000000000000000;;						certificates.UsageKeyEncipherment,
0000000000000000000000000000000000000000;;						certificates.UsageClientAuth,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					CertificateStore:        certificateStore,
0000000000000000000000000000000000000000;;					BootstrapCertificatePEM: tc.bootstrapCert.certificatePEM,
0000000000000000000000000000000000000000;;					BootstrapKeyPEM:         tc.bootstrapCert.keyPEM,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("Got %v, wanted no error.", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				certificate := certificateManager.Current()
0000000000000000000000000000000000000000;;				if !certificatesEqual(certificate, tc.expectedCertBeforeStart.certificate) {
0000000000000000000000000000000000000000;;					t.Errorf("Got %v, wanted %v", certificateString(certificate), certificateString(tc.expectedCertBeforeStart.certificate))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := certificateManager.SetCertificateSigningRequestClient(&fakeClient{
0000000000000000000000000000000000000000;;					certificatePEM: tc.apiCert.certificatePEM,
0000000000000000000000000000000000000000;;				}); err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("Got error %v, expected none.", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if m, ok := certificateManager.(*manager); !ok {
0000000000000000000000000000000000000000;;					t.Errorf("Expected a '*manager' from 'NewManager'")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					m.setRotationDeadline()
0000000000000000000000000000000000000000;;					if m.shouldRotate() {
0000000000000000000000000000000000000000;;						if success, err := m.rotateCerts(); !success {
0000000000000000000000000000000000000000;;							t.Errorf("Got failure from 'rotateCerts', wanted success.")
0000000000000000000000000000000000000000;;						} else if err != nil {
0000000000000000000000000000000000000000;;							t.Errorf("Got error %v, expected none.", err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				certificate = certificateManager.Current()
0000000000000000000000000000000000000000;;				if !certificatesEqual(certificate, tc.expectedCertAfterStart.certificate) {
0000000000000000000000000000000000000000;;					t.Errorf("Got %v, wanted %v", certificateString(certificate), certificateString(tc.expectedCertAfterStart.certificate))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInitializeOtherRESTClients(t *testing.T) {
0000000000000000000000000000000000000000;;		var nilCertificate = &certificateData{}
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			description             string
0000000000000000000000000000000000000000;;			storeCert               *certificateData
0000000000000000000000000000000000000000;;			bootstrapCert           *certificateData
0000000000000000000000000000000000000000;;			apiCert                 *certificateData
0000000000000000000000000000000000000000;;			expectedCertBeforeStart *certificateData
0000000000000000000000000000000000000000;;			expectedCertAfterStart  *certificateData
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:             "No current certificate, no bootstrap certificate",
0000000000000000000000000000000000000000;;				storeCert:               nilCertificate,
0000000000000000000000000000000000000000;;				bootstrapCert:           nilCertificate,
0000000000000000000000000000000000000000;;				apiCert:                 apiServerCertData,
0000000000000000000000000000000000000000;;				expectedCertBeforeStart: nilCertificate,
0000000000000000000000000000000000000000;;				expectedCertAfterStart:  apiServerCertData,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:             "No current certificate, bootstrap certificate",
0000000000000000000000000000000000000000;;				storeCert:               nilCertificate,
0000000000000000000000000000000000000000;;				bootstrapCert:           bootstrapCertData,
0000000000000000000000000000000000000000;;				apiCert:                 apiServerCertData,
0000000000000000000000000000000000000000;;				expectedCertBeforeStart: bootstrapCertData,
0000000000000000000000000000000000000000;;				expectedCertAfterStart:  apiServerCertData,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:             "Current certificate, no bootstrap certificate",
0000000000000000000000000000000000000000;;				storeCert:               storeCertData,
0000000000000000000000000000000000000000;;				bootstrapCert:           nilCertificate,
0000000000000000000000000000000000000000;;				apiCert:                 apiServerCertData,
0000000000000000000000000000000000000000;;				expectedCertBeforeStart: storeCertData,
0000000000000000000000000000000000000000;;				expectedCertAfterStart:  storeCertData,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:             "Current certificate, bootstrap certificate",
0000000000000000000000000000000000000000;;				storeCert:               storeCertData,
0000000000000000000000000000000000000000;;				bootstrapCert:           bootstrapCertData,
0000000000000000000000000000000000000000;;				apiCert:                 apiServerCertData,
0000000000000000000000000000000000000000;;				expectedCertBeforeStart: storeCertData,
0000000000000000000000000000000000000000;;				expectedCertAfterStart:  storeCertData,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			t.Run(tc.description, func(t *testing.T) {
0000000000000000000000000000000000000000;;				certificateStore := &fakeStore{
0000000000000000000000000000000000000000;;					cert: tc.storeCert.certificate,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				certificateManager, err := NewManager(&Config{
0000000000000000000000000000000000000000;;					Template: &x509.CertificateRequest{
0000000000000000000000000000000000000000;;						Subject: pkix.Name{
0000000000000000000000000000000000000000;;							Organization: []string{"system:nodes"},
0000000000000000000000000000000000000000;;							CommonName:   "system:node:fake-node-name",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Usages: []certificates.KeyUsage{
0000000000000000000000000000000000000000;;						certificates.UsageDigitalSignature,
0000000000000000000000000000000000000000;;						certificates.UsageKeyEncipherment,
0000000000000000000000000000000000000000;;						certificates.UsageClientAuth,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					CertificateStore:        certificateStore,
0000000000000000000000000000000000000000;;					BootstrapCertificatePEM: tc.bootstrapCert.certificatePEM,
0000000000000000000000000000000000000000;;					BootstrapKeyPEM:         tc.bootstrapCert.keyPEM,
0000000000000000000000000000000000000000;;					CertificateSigningRequestClient: &fakeClient{
0000000000000000000000000000000000000000;;						certificatePEM: tc.apiCert.certificatePEM,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("Got %v, wanted no error.", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				certificate := certificateManager.Current()
0000000000000000000000000000000000000000;;				if !certificatesEqual(certificate, tc.expectedCertBeforeStart.certificate) {
0000000000000000000000000000000000000000;;					t.Errorf("Got %v, wanted %v", certificateString(certificate), certificateString(tc.expectedCertBeforeStart.certificate))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if m, ok := certificateManager.(*manager); !ok {
0000000000000000000000000000000000000000;;					t.Errorf("Expected a '*manager' from 'NewManager'")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					m.setRotationDeadline()
0000000000000000000000000000000000000000;;					if m.shouldRotate() {
0000000000000000000000000000000000000000;;						if success, err := certificateManager.(*manager).rotateCerts(); !success {
0000000000000000000000000000000000000000;;							t.Errorf("Got failure from 'rotateCerts', expected success")
0000000000000000000000000000000000000000;;						} else if err != nil {
0000000000000000000000000000000000000000;;							t.Errorf("Got error %v, expected none.", err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				certificate = certificateManager.Current()
0000000000000000000000000000000000000000;;				if !certificatesEqual(certificate, tc.expectedCertAfterStart.certificate) {
0000000000000000000000000000000000000000;;					t.Errorf("Got %v, wanted %v", certificateString(certificate), certificateString(tc.expectedCertAfterStart.certificate))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeClientFailureType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		none fakeClientFailureType = iota
0000000000000000000000000000000000000000;;		createError
0000000000000000000000000000000000000000;;		watchError
0000000000000000000000000000000000000000;;		certificateSigningRequestDenied
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeClient struct {
0000000000000000000000000000000000000000;;		certificatesclient.CertificateSigningRequestInterface
0000000000000000000000000000000000000000;;		failureType    fakeClientFailureType
0000000000000000000000000000000000000000;;		certificatePEM []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c fakeClient) Create(*certificates.CertificateSigningRequest) (*certificates.CertificateSigningRequest, error) {
0000000000000000000000000000000000000000;;		if c.failureType == createError {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Create error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		csrReply := certificates.CertificateSigningRequest{}
0000000000000000000000000000000000000000;;		csrReply.UID = "fake-uid"
0000000000000000000000000000000000000000;;		return &csrReply, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c fakeClient) Watch(opts v1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		if c.failureType == watchError {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Watch error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &fakeWatch{
0000000000000000000000000000000000000000;;			failureType:    c.failureType,
0000000000000000000000000000000000000000;;			certificatePEM: c.certificatePEM,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeWatch struct {
0000000000000000000000000000000000000000;;		failureType    fakeClientFailureType
0000000000000000000000000000000000000000;;		certificatePEM []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *fakeWatch) Stop() {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *fakeWatch) ResultChan() <-chan watch.Event {
0000000000000000000000000000000000000000;;		var condition certificates.CertificateSigningRequestCondition
0000000000000000000000000000000000000000;;		if w.failureType == certificateSigningRequestDenied {
0000000000000000000000000000000000000000;;			condition = certificates.CertificateSigningRequestCondition{
0000000000000000000000000000000000000000;;				Type: certificates.CertificateDenied,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			condition = certificates.CertificateSigningRequestCondition{
0000000000000000000000000000000000000000;;				Type: certificates.CertificateApproved,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		csr := certificates.CertificateSigningRequest{
0000000000000000000000000000000000000000;;			Status: certificates.CertificateSigningRequestStatus{
0000000000000000000000000000000000000000;;				Conditions: []certificates.CertificateSigningRequestCondition{
0000000000000000000000000000000000000000;;					condition,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Certificate: []byte(w.certificatePEM),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		csr.UID = "fake-uid"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := make(chan watch.Event, 1)
0000000000000000000000000000000000000000;;		c <- watch.Event{
0000000000000000000000000000000000000000;;			Type:   watch.Added,
0000000000000000000000000000000000000000;;			Object: &csr,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeStore struct {
0000000000000000000000000000000000000000;;		cert *tls.Certificate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *fakeStore) Current() (*tls.Certificate, error) {
0000000000000000000000000000000000000000;;		if s.cert == nil {
0000000000000000000000000000000000000000;;			noKeyErr := NoCertKeyError("")
0000000000000000000000000000000000000000;;			return nil, &noKeyErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.cert, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Accepts the PEM data for the cert/key pair and makes the new cert/key
0000000000000000000000000000000000000000;;	// pair the 'current' pair, that will be returned by future calls to
0000000000000000000000000000000000000000;;	// Current().
0000000000000000000000000000000000000000;;	func (s *fakeStore) Update(certPEM, keyPEM []byte) (*tls.Certificate, error) {
0000000000000000000000000000000000000000;;		// In order to make the mocking work, whenever a cert/key pair is passed in
0000000000000000000000000000000000000000;;		// to be updated in the mock store, assume that the certificate manager
0000000000000000000000000000000000000000;;		// generated the key, and then asked the mock CertificateSigningRequest API
0000000000000000000000000000000000000000;;		// to sign it, then the faked API returned a canned response. The canned
0000000000000000000000000000000000000000;;		// signing response will not match the generated key. In order to make
0000000000000000000000000000000000000000;;		// things work out, search here for the correct matching key and use that
0000000000000000000000000000000000000000;;		// instead of the passed in key. That way this file of test code doesn't
0000000000000000000000000000000000000000;;		// have to implement an actual certificate signing process.
0000000000000000000000000000000000000000;;		for _, tc := range []*certificateData{storeCertData, bootstrapCertData, apiServerCertData} {
0000000000000000000000000000000000000000;;			if bytes.Equal(tc.certificatePEM, certPEM) {
0000000000000000000000000000000000000000;;				keyPEM = tc.keyPEM
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cert, err := tls.X509KeyPair(certPEM, keyPEM)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		s.cert = &cert
0000000000000000000000000000000000000000;;		s.cert.Leaf = &x509.Certificate{
0000000000000000000000000000000000000000;;			NotBefore: now.Add(-24 * time.Hour),
0000000000000000000000000000000000000000;;			NotAfter:  now.Add(24 * time.Hour),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.cert, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func certificatesEqual(c1 *tls.Certificate, c2 *tls.Certificate) bool {
0000000000000000000000000000000000000000;;		if c1 == nil || c2 == nil {
0000000000000000000000000000000000000000;;			return c1 == c2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(c1.Certificate) != len(c2.Certificate) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < len(c1.Certificate); i++ {
0000000000000000000000000000000000000000;;			if !bytes.Equal(c1.Certificate[i], c2.Certificate[i]) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func certificateString(c *tls.Certificate) string {
0000000000000000000000000000000000000000;;		if c == nil {
0000000000000000000000000000000000000000;;			return "certificate == nil"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.Leaf == nil {
0000000000000000000000000000000000000000;;			return "certificate.Leaf == nil"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.Leaf.Subject.CommonName
0000000000000000000000000000000000000000;;	}
