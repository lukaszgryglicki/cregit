0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f69b7b7816a945a25239b34ea1a2f1ed3a806f76;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kuberuntime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Taken from lmctfy https://github.com/google/lmctfy/blob/master/lmctfy/controllers/cpu_controller.cc
0000000000000000000000000000000000000000;;		minShares     = 2
0000000000000000000000000000000000000000;;		sharesPerCPU  = 1024
0000000000000000000000000000000000000000;;		milliCPUToCPU = 1000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 100000 is equivalent to 100ms
0000000000000000000000000000000000000000;;		quotaPeriod    = 100 * minQuotaPeriod
0000000000000000000000000000000000000000;;		minQuotaPeriod = 1000
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// The default dns opt strings
0000000000000000000000000000000000000000;;		defaultDNSOptions = []string{"ndots:5"}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type podsByID []*kubecontainer.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b podsByID) Len() int           { return len(b) }
0000000000000000000000000000000000000000;;	func (b podsByID) Swap(i, j int)      { b[i], b[j] = b[j], b[i] }
0000000000000000000000000000000000000000;;	func (b podsByID) Less(i, j int) bool { return b[i].ID < b[j].ID }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type containersByID []*kubecontainer.Container
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b containersByID) Len() int           { return len(b) }
0000000000000000000000000000000000000000;;	func (b containersByID) Swap(i, j int)      { b[i], b[j] = b[j], b[i] }
0000000000000000000000000000000000000000;;	func (b containersByID) Less(i, j int) bool { return b[i].ID.ID < b[j].ID.ID }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Newest first.
0000000000000000000000000000000000000000;;	type podSandboxByCreated []*runtimeapi.PodSandbox
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p podSandboxByCreated) Len() int           { return len(p) }
0000000000000000000000000000000000000000;;	func (p podSandboxByCreated) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
0000000000000000000000000000000000000000;;	func (p podSandboxByCreated) Less(i, j int) bool { return p[i].CreatedAt > p[j].CreatedAt }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type containerStatusByCreated []*kubecontainer.ContainerStatus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c containerStatusByCreated) Len() int           { return len(c) }
0000000000000000000000000000000000000000;;	func (c containerStatusByCreated) Swap(i, j int)      { c[i], c[j] = c[j], c[i] }
0000000000000000000000000000000000000000;;	func (c containerStatusByCreated) Less(i, j int) bool { return c[i].CreatedAt.After(c[j].CreatedAt) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// toKubeContainerState converts runtimeapi.ContainerState to kubecontainer.ContainerState.
0000000000000000000000000000000000000000;;	func toKubeContainerState(state runtimeapi.ContainerState) kubecontainer.ContainerState {
0000000000000000000000000000000000000000;;		switch state {
0000000000000000000000000000000000000000;;		case runtimeapi.ContainerState_CONTAINER_CREATED:
0000000000000000000000000000000000000000;;			return kubecontainer.ContainerStateCreated
0000000000000000000000000000000000000000;;		case runtimeapi.ContainerState_CONTAINER_RUNNING:
0000000000000000000000000000000000000000;;			return kubecontainer.ContainerStateRunning
0000000000000000000000000000000000000000;;		case runtimeapi.ContainerState_CONTAINER_EXITED:
0000000000000000000000000000000000000000;;			return kubecontainer.ContainerStateExited
0000000000000000000000000000000000000000;;		case runtimeapi.ContainerState_CONTAINER_UNKNOWN:
0000000000000000000000000000000000000000;;			return kubecontainer.ContainerStateUnknown
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return kubecontainer.ContainerStateUnknown
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// toRuntimeProtocol converts v1.Protocol to runtimeapi.Protocol.
0000000000000000000000000000000000000000;;	func toRuntimeProtocol(protocol v1.Protocol) runtimeapi.Protocol {
0000000000000000000000000000000000000000;;		switch protocol {
0000000000000000000000000000000000000000;;		case v1.ProtocolTCP:
0000000000000000000000000000000000000000;;			return runtimeapi.Protocol_TCP
0000000000000000000000000000000000000000;;		case v1.ProtocolUDP:
0000000000000000000000000000000000000000;;			return runtimeapi.Protocol_UDP
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Warningf("Unknown protocol %q: defaulting to TCP", protocol)
0000000000000000000000000000000000000000;;		return runtimeapi.Protocol_TCP
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// toKubeContainer converts runtimeapi.Container to kubecontainer.Container.
0000000000000000000000000000000000000000;;	func (m *kubeGenericRuntimeManager) toKubeContainer(c *runtimeapi.Container) (*kubecontainer.Container, error) {
0000000000000000000000000000000000000000;;		if c == nil || c.Id == "" || c.Image == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to convert a nil pointer to a runtime container")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		annotatedInfo := getContainerInfoFromAnnotations(c.Annotations)
0000000000000000000000000000000000000000;;		return &kubecontainer.Container{
0000000000000000000000000000000000000000;;			ID:      kubecontainer.ContainerID{Type: m.runtimeName, ID: c.Id},
0000000000000000000000000000000000000000;;			Name:    c.GetMetadata().GetName(),
0000000000000000000000000000000000000000;;			ImageID: c.ImageRef,
0000000000000000000000000000000000000000;;			Image:   c.Image.Image,
0000000000000000000000000000000000000000;;			Hash:    annotatedInfo.Hash,
0000000000000000000000000000000000000000;;			State:   toKubeContainerState(c.State),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sandboxToKubeContainer converts runtimeapi.PodSandbox to kubecontainer.Container.
0000000000000000000000000000000000000000;;	// This is only needed because we need to return sandboxes as if they were
0000000000000000000000000000000000000000;;	// kubecontainer.Containers to avoid substantial changes to PLEG.
0000000000000000000000000000000000000000;;	// TODO: Remove this once it becomes obsolete.
0000000000000000000000000000000000000000;;	func (m *kubeGenericRuntimeManager) sandboxToKubeContainer(s *runtimeapi.PodSandbox) (*kubecontainer.Container, error) {
0000000000000000000000000000000000000000;;		if s == nil || s.Id == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to convert a nil pointer to a runtime container")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &kubecontainer.Container{
0000000000000000000000000000000000000000;;			ID:    kubecontainer.ContainerID{Type: m.runtimeName, ID: s.Id},
0000000000000000000000000000000000000000;;			State: kubecontainer.SandboxToContainerState(s.State),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getImageUser gets uid or user name that will run the command(s) from image. The function
0000000000000000000000000000000000000000;;	// guarantees that only one of them is set.
0000000000000000000000000000000000000000;;	func (m *kubeGenericRuntimeManager) getImageUser(image string) (*int64, string, error) {
0000000000000000000000000000000000000000;;		imageStatus, err := m.imageService.ImageStatus(&runtimeapi.ImageSpec{Image: image})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if imageStatus != nil {
0000000000000000000000000000000000000000;;			if imageStatus.Uid != nil {
0000000000000000000000000000000000000000;;				return &imageStatus.GetUid().Value, "", nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if imageStatus.Username != "" {
0000000000000000000000000000000000000000;;				return nil, imageStatus.Username, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If non of them is set, treat it as root.
0000000000000000000000000000000000000000;;		return new(int64), "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isContainerFailed returns true if container has exited and exitcode is not zero.
0000000000000000000000000000000000000000;;	func isContainerFailed(status *kubecontainer.ContainerStatus) bool {
0000000000000000000000000000000000000000;;		if status.State == kubecontainer.ContainerStateExited && status.ExitCode != 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// milliCPUToShares converts milliCPU to CPU shares
0000000000000000000000000000000000000000;;	func milliCPUToShares(milliCPU int64) int64 {
0000000000000000000000000000000000000000;;		if milliCPU == 0 {
0000000000000000000000000000000000000000;;			// Return 2 here to really match kernel default for zero milliCPU.
0000000000000000000000000000000000000000;;			return minShares
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Conceptually (milliCPU / milliCPUToCPU) * sharesPerCPU, but factored to improve rounding.
0000000000000000000000000000000000000000;;		shares := (milliCPU * sharesPerCPU) / milliCPUToCPU
0000000000000000000000000000000000000000;;		if shares < minShares {
0000000000000000000000000000000000000000;;			return minShares
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return shares
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// milliCPUToQuota converts milliCPU to CFS quota and period values
0000000000000000000000000000000000000000;;	func milliCPUToQuota(milliCPU int64) (quota int64, period int64) {
0000000000000000000000000000000000000000;;		// CFS quota is measured in two values:
0000000000000000000000000000000000000000;;		//  - cfs_period_us=100ms (the amount of time to measure usage across)
0000000000000000000000000000000000000000;;		//  - cfs_quota=20ms (the amount of cpu time allowed to be used across a period)
0000000000000000000000000000000000000000;;		// so in the above example, you are limited to 20% of a single CPU
0000000000000000000000000000000000000000;;		// for multi-cpu environments, you just scale equivalent amounts
0000000000000000000000000000000000000000;;		if milliCPU == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we set the period to 100ms by default
0000000000000000000000000000000000000000;;		period = quotaPeriod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we then convert your milliCPU to a value normalized over a period
0000000000000000000000000000000000000000;;		quota = (milliCPU * quotaPeriod) / milliCPUToCPU
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// quota needs to be a minimum of 1ms.
0000000000000000000000000000000000000000;;		if quota < minQuotaPeriod {
0000000000000000000000000000000000000000;;			quota = minQuotaPeriod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getStableKey generates a key (string) to uniquely identify a
0000000000000000000000000000000000000000;;	// (pod, container) tuple. The key should include the content of the
0000000000000000000000000000000000000000;;	// container, so that any change to the container generates a new key.
0000000000000000000000000000000000000000;;	func getStableKey(pod *v1.Pod, container *v1.Container) string {
0000000000000000000000000000000000000000;;		hash := strconv.FormatUint(kubecontainer.HashContainer(container), 16)
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s_%s_%s_%s_%s", pod.Name, pod.Namespace, string(pod.UID), container.Name, hash)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildContainerLogsPath builds log path for container relative to pod logs directory.
0000000000000000000000000000000000000000;;	func buildContainerLogsPath(containerName string, restartCount int) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s_%d.log", containerName, restartCount)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildFullContainerLogsPath builds absolute log path for container.
0000000000000000000000000000000000000000;;	func buildFullContainerLogsPath(podUID types.UID, containerName string, restartCount int) string {
0000000000000000000000000000000000000000;;		return filepath.Join(buildPodLogsDirectory(podUID), buildContainerLogsPath(containerName, restartCount))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildPodLogsDirectory builds absolute log directory path for a pod sandbox.
0000000000000000000000000000000000000000;;	func buildPodLogsDirectory(podUID types.UID) string {
0000000000000000000000000000000000000000;;		return filepath.Join(podLogsRootDirectory, string(podUID))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// toKubeRuntimeStatus converts the runtimeapi.RuntimeStatus to kubecontainer.RuntimeStatus.
0000000000000000000000000000000000000000;;	func toKubeRuntimeStatus(status *runtimeapi.RuntimeStatus) *kubecontainer.RuntimeStatus {
0000000000000000000000000000000000000000;;		conditions := []kubecontainer.RuntimeCondition{}
0000000000000000000000000000000000000000;;		for _, c := range status.GetConditions() {
0000000000000000000000000000000000000000;;			conditions = append(conditions, kubecontainer.RuntimeCondition{
0000000000000000000000000000000000000000;;				Type:    kubecontainer.RuntimeConditionType(c.Type),
0000000000000000000000000000000000000000;;				Status:  c.Status,
0000000000000000000000000000000000000000;;				Reason:  c.Reason,
0000000000000000000000000000000000000000;;				Message: c.Message,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &kubecontainer.RuntimeStatus{Conditions: conditions}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getSysctlsFromAnnotations gets sysctls and unsafeSysctls from annotations.
0000000000000000000000000000000000000000;;	func getSysctlsFromAnnotations(annotations map[string]string) (map[string]string, error) {
0000000000000000000000000000000000000000;;		apiSysctls, apiUnsafeSysctls, err := v1helper.SysctlsFromPodAnnotations(annotations)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sysctls := make(map[string]string)
0000000000000000000000000000000000000000;;		for _, c := range apiSysctls {
0000000000000000000000000000000000000000;;			sysctls[c.Name] = c.Value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range apiUnsafeSysctls {
0000000000000000000000000000000000000000;;			sysctls[c.Name] = c.Value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sysctls, nil
0000000000000000000000000000000000000000;;	}
