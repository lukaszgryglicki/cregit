0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
5464e5a5d7a8fd40e9826bae7a1dc78c936c2109;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kuberuntime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cadvisorapi "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		kubetypes "k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/flowcontrol"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/credentialprovider"
0000000000000000000000000000000000000000;;		apitest "k8s.io/kubernetes/pkg/kubelet/apis/cri/testing"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		containertest "k8s.io/kubernetes/pkg/kubelet/container/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		fakeCreatedAt int64 = 1
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createTestRuntimeManager() (*apitest.FakeRuntimeService, *apitest.FakeImageService, *kubeGenericRuntimeManager, error) {
0000000000000000000000000000000000000000;;		return customTestRuntimeManager(&credentialprovider.BasicDockerKeyring{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func customTestRuntimeManager(keyring *credentialprovider.BasicDockerKeyring) (*apitest.FakeRuntimeService, *apitest.FakeImageService, *kubeGenericRuntimeManager, error) {
0000000000000000000000000000000000000000;;		fakeRuntimeService := apitest.NewFakeRuntimeService()
0000000000000000000000000000000000000000;;		fakeImageService := apitest.NewFakeImageService()
0000000000000000000000000000000000000000;;		// Only an empty machineInfo is needed here, because in unit test all containers are besteffort,
0000000000000000000000000000000000000000;;		// data in machineInfo is not used. If burstable containers are used in unit test in the future,
0000000000000000000000000000000000000000;;		// we may want to set memory capacity.
0000000000000000000000000000000000000000;;		machineInfo := &cadvisorapi.MachineInfo{}
0000000000000000000000000000000000000000;;		osInterface := &containertest.FakeOS{}
0000000000000000000000000000000000000000;;		manager, err := NewFakeKubeRuntimeManager(fakeRuntimeService, fakeImageService, machineInfo, osInterface, &containertest.FakeRuntimeHelper{}, keyring)
0000000000000000000000000000000000000000;;		return fakeRuntimeService, fakeImageService, manager, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sandboxTemplate is a sandbox template to create fake sandbox.
0000000000000000000000000000000000000000;;	type sandboxTemplate struct {
0000000000000000000000000000000000000000;;		pod       *v1.Pod
0000000000000000000000000000000000000000;;		attempt   uint32
0000000000000000000000000000000000000000;;		createdAt int64
0000000000000000000000000000000000000000;;		state     runtimeapi.PodSandboxState
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// containerTemplate is a container template to create fake container.
0000000000000000000000000000000000000000;;	type containerTemplate struct {
0000000000000000000000000000000000000000;;		pod            *v1.Pod
0000000000000000000000000000000000000000;;		container      *v1.Container
0000000000000000000000000000000000000000;;		sandboxAttempt uint32
0000000000000000000000000000000000000000;;		attempt        int
0000000000000000000000000000000000000000;;		createdAt      int64
0000000000000000000000000000000000000000;;		state          runtimeapi.ContainerState
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeAndSetFakePod is a helper function to create and set one fake sandbox for a pod and
0000000000000000000000000000000000000000;;	// one fake container for each of its container.
0000000000000000000000000000000000000000;;	func makeAndSetFakePod(t *testing.T, m *kubeGenericRuntimeManager, fakeRuntime *apitest.FakeRuntimeService,
0000000000000000000000000000000000000000;;		pod *v1.Pod) (*apitest.FakePodSandbox, []*apitest.FakeContainer) {
0000000000000000000000000000000000000000;;		sandbox := makeFakePodSandbox(t, m, sandboxTemplate{
0000000000000000000000000000000000000000;;			pod:       pod,
0000000000000000000000000000000000000000;;			createdAt: fakeCreatedAt,
0000000000000000000000000000000000000000;;			state:     runtimeapi.PodSandboxState_SANDBOX_READY,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var containers []*apitest.FakeContainer
0000000000000000000000000000000000000000;;		newTemplate := func(c *v1.Container) containerTemplate {
0000000000000000000000000000000000000000;;			return containerTemplate{
0000000000000000000000000000000000000000;;				pod:       pod,
0000000000000000000000000000000000000000;;				container: c,
0000000000000000000000000000000000000000;;				createdAt: fakeCreatedAt,
0000000000000000000000000000000000000000;;				state:     runtimeapi.ContainerState_CONTAINER_RUNNING,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			containers = append(containers, makeFakeContainer(t, m, newTemplate(&pod.Spec.Containers[i])))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;			containers = append(containers, makeFakeContainer(t, m, newTemplate(&pod.Spec.InitContainers[i])))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeRuntime.SetFakeSandboxes([]*apitest.FakePodSandbox{sandbox})
0000000000000000000000000000000000000000;;		fakeRuntime.SetFakeContainers(containers)
0000000000000000000000000000000000000000;;		return sandbox, containers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeFakePodSandbox creates a fake pod sandbox based on a sandbox template.
0000000000000000000000000000000000000000;;	func makeFakePodSandbox(t *testing.T, m *kubeGenericRuntimeManager, template sandboxTemplate) *apitest.FakePodSandbox {
0000000000000000000000000000000000000000;;		config, err := m.generatePodSandboxConfig(template.pod, template.attempt)
0000000000000000000000000000000000000000;;		assert.NoError(t, err, "generatePodSandboxConfig for sandbox template %+v", template)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podSandboxID := apitest.BuildSandboxName(config.Metadata)
0000000000000000000000000000000000000000;;		return &apitest.FakePodSandbox{
0000000000000000000000000000000000000000;;			PodSandboxStatus: runtimeapi.PodSandboxStatus{
0000000000000000000000000000000000000000;;				Id:        podSandboxID,
0000000000000000000000000000000000000000;;				Metadata:  config.Metadata,
0000000000000000000000000000000000000000;;				State:     template.state,
0000000000000000000000000000000000000000;;				CreatedAt: template.createdAt,
0000000000000000000000000000000000000000;;				Network: &runtimeapi.PodSandboxNetworkStatus{
0000000000000000000000000000000000000000;;					Ip: apitest.FakePodSandboxIP,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Labels: config.Labels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeFakePodSandboxes creates a group of fake pod sandboxes based on the sandbox templates.
0000000000000000000000000000000000000000;;	// The function guarantees the order of the fake pod sandboxes is the same with the templates.
0000000000000000000000000000000000000000;;	func makeFakePodSandboxes(t *testing.T, m *kubeGenericRuntimeManager, templates []sandboxTemplate) []*apitest.FakePodSandbox {
0000000000000000000000000000000000000000;;		var fakePodSandboxes []*apitest.FakePodSandbox
0000000000000000000000000000000000000000;;		for _, template := range templates {
0000000000000000000000000000000000000000;;			fakePodSandboxes = append(fakePodSandboxes, makeFakePodSandbox(t, m, template))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fakePodSandboxes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeFakeContainer creates a fake container based on a container template.
0000000000000000000000000000000000000000;;	func makeFakeContainer(t *testing.T, m *kubeGenericRuntimeManager, template containerTemplate) *apitest.FakeContainer {
0000000000000000000000000000000000000000;;		sandboxConfig, err := m.generatePodSandboxConfig(template.pod, template.sandboxAttempt)
0000000000000000000000000000000000000000;;		assert.NoError(t, err, "generatePodSandboxConfig for container template %+v", template)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containerConfig, err := m.generateContainerConfig(template.container, template.pod, template.attempt, "", template.container.Image)
0000000000000000000000000000000000000000;;		assert.NoError(t, err, "generateContainerConfig for container template %+v", template)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podSandboxID := apitest.BuildSandboxName(sandboxConfig.Metadata)
0000000000000000000000000000000000000000;;		containerID := apitest.BuildContainerName(containerConfig.Metadata, podSandboxID)
0000000000000000000000000000000000000000;;		imageRef := containerConfig.Image.Image
0000000000000000000000000000000000000000;;		return &apitest.FakeContainer{
0000000000000000000000000000000000000000;;			ContainerStatus: runtimeapi.ContainerStatus{
0000000000000000000000000000000000000000;;				Id:          containerID,
0000000000000000000000000000000000000000;;				Metadata:    containerConfig.Metadata,
0000000000000000000000000000000000000000;;				Image:       containerConfig.Image,
0000000000000000000000000000000000000000;;				ImageRef:    imageRef,
0000000000000000000000000000000000000000;;				CreatedAt:   template.createdAt,
0000000000000000000000000000000000000000;;				State:       template.state,
0000000000000000000000000000000000000000;;				Labels:      containerConfig.Labels,
0000000000000000000000000000000000000000;;				Annotations: containerConfig.Annotations,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			SandboxID: podSandboxID,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeFakeContainers creates a group of fake containers based on the container templates.
0000000000000000000000000000000000000000;;	// The function guarantees the order of the fake containers is the same with the templates.
0000000000000000000000000000000000000000;;	func makeFakeContainers(t *testing.T, m *kubeGenericRuntimeManager, templates []containerTemplate) []*apitest.FakeContainer {
0000000000000000000000000000000000000000;;		var fakeContainers []*apitest.FakeContainer
0000000000000000000000000000000000000000;;		for _, template := range templates {
0000000000000000000000000000000000000000;;			fakeContainers = append(fakeContainers, makeFakeContainer(t, m, template))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fakeContainers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeTestContainer creates a test api container.
0000000000000000000000000000000000000000;;	func makeTestContainer(name, image string) v1.Container {
0000000000000000000000000000000000000000;;		return v1.Container{
0000000000000000000000000000000000000000;;			Name:  name,
0000000000000000000000000000000000000000;;			Image: image,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeTestPod creates a test api pod.
0000000000000000000000000000000000000000;;	func makeTestPod(podName, podNamespace, podUID string, containers []v1.Container) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       types.UID(podUID),
0000000000000000000000000000000000000000;;				Name:      podName,
0000000000000000000000000000000000000000;;				Namespace: podNamespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: containers,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifyPods returns true if the two pod slices are equal.
0000000000000000000000000000000000000000;;	func verifyPods(a, b []*kubecontainer.Pod) bool {
0000000000000000000000000000000000000000;;		if len(a) != len(b) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sort the containers within a pod.
0000000000000000000000000000000000000000;;		for i := range a {
0000000000000000000000000000000000000000;;			sort.Sort(containersByID(a[i].Containers))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range b {
0000000000000000000000000000000000000000;;			sort.Sort(containersByID(b[i].Containers))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sort the pods by UID.
0000000000000000000000000000000000000000;;		sort.Sort(podsByID(a))
0000000000000000000000000000000000000000;;		sort.Sort(podsByID(b))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return reflect.DeepEqual(a, b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyFakeContainerList(fakeRuntime *apitest.FakeRuntimeService, expected []string) ([]string, bool) {
0000000000000000000000000000000000000000;;		actual := []string{}
0000000000000000000000000000000000000000;;		for _, c := range fakeRuntime.Containers {
0000000000000000000000000000000000000000;;			actual = append(actual, c.Id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(sort.StringSlice(actual))
0000000000000000000000000000000000000000;;		sort.Sort(sort.StringSlice(expected))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return actual, reflect.DeepEqual(expected, actual)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewKubeRuntimeManager(t *testing.T) {
0000000000000000000000000000000000000000;;		_, _, _, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestVersion(t *testing.T) {
0000000000000000000000000000000000000000;;		_, _, m, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		version, err := m.Version()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, kubeRuntimeAPIVersion, version.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestContainerRuntimeType(t *testing.T) {
0000000000000000000000000000000000000000;;		_, _, m, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runtimeType := m.Type()
0000000000000000000000000000000000000000;;		assert.Equal(t, apitest.FakeRuntimeName, runtimeType)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetPodStatus(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeRuntime, _, m, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containers := []v1.Container{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name:            "foo1",
0000000000000000000000000000000000000000;;				Image:           "busybox",
0000000000000000000000000000000000000000;;				ImagePullPolicy: v1.PullIfNotPresent,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name:            "foo2",
0000000000000000000000000000000000000000;;				Image:           "busybox",
0000000000000000000000000000000000000000;;				ImagePullPolicy: v1.PullIfNotPresent,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       "12345678",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: "new",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: containers,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set fake sandbox and faked containers to fakeRuntime.
0000000000000000000000000000000000000000;;		makeAndSetFakePod(t, m, fakeRuntime, pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podStatus, err := m.GetPodStatus(pod.UID, pod.Name, pod.Namespace)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, pod.UID, podStatus.ID)
0000000000000000000000000000000000000000;;		assert.Equal(t, pod.Name, podStatus.Name)
0000000000000000000000000000000000000000;;		assert.Equal(t, pod.Namespace, podStatus.Namespace)
0000000000000000000000000000000000000000;;		assert.Equal(t, apitest.FakePodSandboxIP, podStatus.IP)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetPods(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeRuntime, _, m, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       "12345678",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: "new",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "foo1",
0000000000000000000000000000000000000000;;						Image: "busybox",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "foo2",
0000000000000000000000000000000000000000;;						Image: "busybox",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set fake sandbox and fake containers to fakeRuntime.
0000000000000000000000000000000000000000;;		fakeSandbox, fakeContainers := makeAndSetFakePod(t, m, fakeRuntime, pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert the fakeContainers to kubecontainer.Container
0000000000000000000000000000000000000000;;		containers := make([]*kubecontainer.Container, len(fakeContainers))
0000000000000000000000000000000000000000;;		for i := range containers {
0000000000000000000000000000000000000000;;			fakeContainer := fakeContainers[i]
0000000000000000000000000000000000000000;;			c, err := m.toKubeContainer(&runtimeapi.Container{
0000000000000000000000000000000000000000;;				Id:          fakeContainer.Id,
0000000000000000000000000000000000000000;;				Metadata:    fakeContainer.Metadata,
0000000000000000000000000000000000000000;;				State:       fakeContainer.State,
0000000000000000000000000000000000000000;;				Image:       fakeContainer.Image,
0000000000000000000000000000000000000000;;				ImageRef:    fakeContainer.ImageRef,
0000000000000000000000000000000000000000;;				Labels:      fakeContainer.Labels,
0000000000000000000000000000000000000000;;				Annotations: fakeContainer.Annotations,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			containers[i] = c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Convert fakeSandbox to kubecontainer.Container
0000000000000000000000000000000000000000;;		sandbox, err := m.sandboxToKubeContainer(&runtimeapi.PodSandbox{
0000000000000000000000000000000000000000;;			Id:          fakeSandbox.Id,
0000000000000000000000000000000000000000;;			Metadata:    fakeSandbox.Metadata,
0000000000000000000000000000000000000000;;			State:       fakeSandbox.State,
0000000000000000000000000000000000000000;;			CreatedAt:   fakeSandbox.CreatedAt,
0000000000000000000000000000000000000000;;			Labels:      fakeSandbox.Labels,
0000000000000000000000000000000000000000;;			Annotations: fakeSandbox.Annotations,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected := []*kubecontainer.Pod{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ID:         kubetypes.UID("12345678"),
0000000000000000000000000000000000000000;;				Name:       "foo",
0000000000000000000000000000000000000000;;				Namespace:  "new",
0000000000000000000000000000000000000000;;				Containers: []*kubecontainer.Container{containers[0], containers[1]},
0000000000000000000000000000000000000000;;				Sandboxes:  []*kubecontainer.Container{sandbox},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actual, err := m.GetPods(false)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !verifyPods(expected, actual) {
0000000000000000000000000000000000000000;;			t.Errorf("expected %q, got %q", expected, actual)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetPodContainerID(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeRuntime, _, m, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       "12345678",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: "new",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "foo1",
0000000000000000000000000000000000000000;;						Image: "busybox",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "foo2",
0000000000000000000000000000000000000000;;						Image: "busybox",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Set fake sandbox and fake containers to fakeRuntime.
0000000000000000000000000000000000000000;;		fakeSandbox, _ := makeAndSetFakePod(t, m, fakeRuntime, pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert fakeSandbox to kubecontainer.Container
0000000000000000000000000000000000000000;;		sandbox, err := m.sandboxToKubeContainer(&runtimeapi.PodSandbox{
0000000000000000000000000000000000000000;;			Id:        fakeSandbox.Id,
0000000000000000000000000000000000000000;;			Metadata:  fakeSandbox.Metadata,
0000000000000000000000000000000000000000;;			State:     fakeSandbox.State,
0000000000000000000000000000000000000000;;			CreatedAt: fakeSandbox.CreatedAt,
0000000000000000000000000000000000000000;;			Labels:    fakeSandbox.Labels,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedPod := &kubecontainer.Pod{
0000000000000000000000000000000000000000;;			ID:         pod.UID,
0000000000000000000000000000000000000000;;			Name:       pod.Name,
0000000000000000000000000000000000000000;;			Namespace:  pod.Namespace,
0000000000000000000000000000000000000000;;			Containers: []*kubecontainer.Container{},
0000000000000000000000000000000000000000;;			Sandboxes:  []*kubecontainer.Container{sandbox},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		actual, err := m.GetPodContainerID(expectedPod)
0000000000000000000000000000000000000000;;		assert.Equal(t, fakeSandbox.Id, actual.ID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetNetNS(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeRuntime, _, m, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       "12345678",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: "new",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "foo1",
0000000000000000000000000000000000000000;;						Image: "busybox",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "foo2",
0000000000000000000000000000000000000000;;						Image: "busybox",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set fake sandbox and fake containers to fakeRuntime.
0000000000000000000000000000000000000000;;		sandbox, _ := makeAndSetFakePod(t, m, fakeRuntime, pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actual, err := m.GetNetNS(kubecontainer.ContainerID{ID: sandbox.Id})
0000000000000000000000000000000000000000;;		assert.Equal(t, "", actual)
0000000000000000000000000000000000000000;;		assert.Equal(t, "not supported", err.Error())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestKillPod(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeRuntime, _, m, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       "12345678",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: "new",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "foo1",
0000000000000000000000000000000000000000;;						Image: "busybox",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "foo2",
0000000000000000000000000000000000000000;;						Image: "busybox",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set fake sandbox and fake containers to fakeRuntime.
0000000000000000000000000000000000000000;;		fakeSandbox, fakeContainers := makeAndSetFakePod(t, m, fakeRuntime, pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert the fakeContainers to kubecontainer.Container
0000000000000000000000000000000000000000;;		containers := make([]*kubecontainer.Container, len(fakeContainers))
0000000000000000000000000000000000000000;;		for i := range containers {
0000000000000000000000000000000000000000;;			fakeContainer := fakeContainers[i]
0000000000000000000000000000000000000000;;			c, err := m.toKubeContainer(&runtimeapi.Container{
0000000000000000000000000000000000000000;;				Id:       fakeContainer.Id,
0000000000000000000000000000000000000000;;				Metadata: fakeContainer.Metadata,
0000000000000000000000000000000000000000;;				State:    fakeContainer.State,
0000000000000000000000000000000000000000;;				Image:    fakeContainer.Image,
0000000000000000000000000000000000000000;;				ImageRef: fakeContainer.ImageRef,
0000000000000000000000000000000000000000;;				Labels:   fakeContainer.Labels,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			containers[i] = c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runningPod := kubecontainer.Pod{
0000000000000000000000000000000000000000;;			ID:         pod.UID,
0000000000000000000000000000000000000000;;			Name:       pod.Name,
0000000000000000000000000000000000000000;;			Namespace:  pod.Namespace,
0000000000000000000000000000000000000000;;			Containers: []*kubecontainer.Container{containers[0], containers[1]},
0000000000000000000000000000000000000000;;			Sandboxes: []*kubecontainer.Container{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ID: kubecontainer.ContainerID{
0000000000000000000000000000000000000000;;						ID:   fakeSandbox.Id,
0000000000000000000000000000000000000000;;						Type: apitest.FakeRuntimeName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = m.KillPod(pod, runningPod, nil)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, 2, len(fakeRuntime.Containers))
0000000000000000000000000000000000000000;;		assert.Equal(t, 1, len(fakeRuntime.Sandboxes))
0000000000000000000000000000000000000000;;		for _, sandbox := range fakeRuntime.Sandboxes {
0000000000000000000000000000000000000000;;			assert.Equal(t, runtimeapi.PodSandboxState_SANDBOX_NOTREADY, sandbox.State)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range fakeRuntime.Containers {
0000000000000000000000000000000000000000;;			assert.Equal(t, runtimeapi.ContainerState_CONTAINER_EXITED, c.State)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncPod(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeRuntime, fakeImage, m, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containers := []v1.Container{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name:            "foo1",
0000000000000000000000000000000000000000;;				Image:           "busybox",
0000000000000000000000000000000000000000;;				ImagePullPolicy: v1.PullIfNotPresent,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name:            "foo2",
0000000000000000000000000000000000000000;;				Image:           "alpine",
0000000000000000000000000000000000000000;;				ImagePullPolicy: v1.PullIfNotPresent,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       "12345678",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: "new",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: containers,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backOff := flowcontrol.NewBackOff(time.Second, time.Minute)
0000000000000000000000000000000000000000;;		result := m.SyncPod(pod, v1.PodStatus{}, &kubecontainer.PodStatus{}, []v1.Secret{}, backOff)
0000000000000000000000000000000000000000;;		assert.NoError(t, result.Error())
0000000000000000000000000000000000000000;;		assert.Equal(t, 2, len(fakeRuntime.Containers))
0000000000000000000000000000000000000000;;		assert.Equal(t, 2, len(fakeImage.Images))
0000000000000000000000000000000000000000;;		assert.Equal(t, 1, len(fakeRuntime.Sandboxes))
0000000000000000000000000000000000000000;;		for _, sandbox := range fakeRuntime.Sandboxes {
0000000000000000000000000000000000000000;;			assert.Equal(t, runtimeapi.PodSandboxState_SANDBOX_READY, sandbox.State)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range fakeRuntime.Containers {
0000000000000000000000000000000000000000;;			assert.Equal(t, runtimeapi.ContainerState_CONTAINER_RUNNING, c.State)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPruneInitContainers(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeRuntime, _, m, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		init1 := makeTestContainer("init1", "busybox")
0000000000000000000000000000000000000000;;		init2 := makeTestContainer("init2", "busybox")
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       "12345678",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: "new",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				InitContainers: []v1.Container{init1, init2},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		templates := []containerTemplate{
0000000000000000000000000000000000000000;;			{pod: pod, container: &init1, attempt: 2, createdAt: 2, state: runtimeapi.ContainerState_CONTAINER_EXITED},
0000000000000000000000000000000000000000;;			{pod: pod, container: &init1, attempt: 1, createdAt: 1, state: runtimeapi.ContainerState_CONTAINER_EXITED},
0000000000000000000000000000000000000000;;			{pod: pod, container: &init2, attempt: 1, createdAt: 1, state: runtimeapi.ContainerState_CONTAINER_EXITED},
0000000000000000000000000000000000000000;;			{pod: pod, container: &init2, attempt: 0, createdAt: 0, state: runtimeapi.ContainerState_CONTAINER_EXITED},
0000000000000000000000000000000000000000;;			{pod: pod, container: &init1, attempt: 0, createdAt: 0, state: runtimeapi.ContainerState_CONTAINER_EXITED},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakes := makeFakeContainers(t, m, templates)
0000000000000000000000000000000000000000;;		fakeRuntime.SetFakeContainers(fakes)
0000000000000000000000000000000000000000;;		podStatus, err := m.GetPodStatus(pod.UID, pod.Name, pod.Namespace)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keep := map[kubecontainer.ContainerID]int{}
0000000000000000000000000000000000000000;;		m.pruneInitContainersBeforeStart(pod, podStatus, keep)
0000000000000000000000000000000000000000;;		expectedContainers := []string{fakes[0].Id, fakes[2].Id}
0000000000000000000000000000000000000000;;		if actual, ok := verifyFakeContainerList(fakeRuntime, expectedContainers); !ok {
0000000000000000000000000000000000000000;;			t.Errorf("expected %q, got %q", expectedContainers, actual)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncPodWithInitContainers(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeRuntime, _, m, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		initContainers := []v1.Container{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name:            "init1",
0000000000000000000000000000000000000000;;				Image:           "init",
0000000000000000000000000000000000000000;;				ImagePullPolicy: v1.PullIfNotPresent,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		containers := []v1.Container{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name:            "foo1",
0000000000000000000000000000000000000000;;				Image:           "busybox",
0000000000000000000000000000000000000000;;				ImagePullPolicy: v1.PullIfNotPresent,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name:            "foo2",
0000000000000000000000000000000000000000;;				Image:           "alpine",
0000000000000000000000000000000000000000;;				ImagePullPolicy: v1.PullIfNotPresent,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       "12345678",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: "new",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers:     containers,
0000000000000000000000000000000000000000;;				InitContainers: initContainers,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// buildContainerID is an internal helper function to build container id from api pod
0000000000000000000000000000000000000000;;		// and container with default attempt number 0.
0000000000000000000000000000000000000000;;		buildContainerID := func(pod *v1.Pod, container v1.Container) string {
0000000000000000000000000000000000000000;;			uid := string(pod.UID)
0000000000000000000000000000000000000000;;			sandboxID := apitest.BuildSandboxName(&runtimeapi.PodSandboxMetadata{
0000000000000000000000000000000000000000;;				Name:      pod.Name,
0000000000000000000000000000000000000000;;				Uid:       uid,
0000000000000000000000000000000000000000;;				Namespace: pod.Namespace,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			return apitest.BuildContainerName(&runtimeapi.ContainerMetadata{Name: container.Name}, sandboxID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backOff := flowcontrol.NewBackOff(time.Second, time.Minute)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 1. should only create the init container.
0000000000000000000000000000000000000000;;		podStatus, err := m.GetPodStatus(pod.UID, pod.Name, pod.Namespace)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		result := m.SyncPod(pod, v1.PodStatus{}, podStatus, []v1.Secret{}, backOff)
0000000000000000000000000000000000000000;;		assert.NoError(t, result.Error())
0000000000000000000000000000000000000000;;		assert.Equal(t, 1, len(fakeRuntime.Containers))
0000000000000000000000000000000000000000;;		initContainerID := buildContainerID(pod, initContainers[0])
0000000000000000000000000000000000000000;;		expectedContainers := []string{initContainerID}
0000000000000000000000000000000000000000;;		if actual, ok := verifyFakeContainerList(fakeRuntime, expectedContainers); !ok {
0000000000000000000000000000000000000000;;			t.Errorf("expected %q, got %q", expectedContainers, actual)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 2. should not create app container because init container is still running.
0000000000000000000000000000000000000000;;		podStatus, err = m.GetPodStatus(pod.UID, pod.Name, pod.Namespace)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		result = m.SyncPod(pod, v1.PodStatus{}, podStatus, []v1.Secret{}, backOff)
0000000000000000000000000000000000000000;;		assert.NoError(t, result.Error())
0000000000000000000000000000000000000000;;		assert.Equal(t, 1, len(fakeRuntime.Containers))
0000000000000000000000000000000000000000;;		expectedContainers = []string{initContainerID}
0000000000000000000000000000000000000000;;		if actual, ok := verifyFakeContainerList(fakeRuntime, expectedContainers); !ok {
0000000000000000000000000000000000000000;;			t.Errorf("expected %q, got %q", expectedContainers, actual)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 3. should create all app containers because init container finished.
0000000000000000000000000000000000000000;;		fakeRuntime.StopContainer(initContainerID, 0)
0000000000000000000000000000000000000000;;		podStatus, err = m.GetPodStatus(pod.UID, pod.Name, pod.Namespace)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		result = m.SyncPod(pod, v1.PodStatus{}, podStatus, []v1.Secret{}, backOff)
0000000000000000000000000000000000000000;;		assert.NoError(t, result.Error())
0000000000000000000000000000000000000000;;		assert.Equal(t, 3, len(fakeRuntime.Containers))
0000000000000000000000000000000000000000;;		expectedContainers = []string{initContainerID, buildContainerID(pod, containers[0]),
0000000000000000000000000000000000000000;;			buildContainerID(pod, containers[1])}
0000000000000000000000000000000000000000;;		if actual, ok := verifyFakeContainerList(fakeRuntime, expectedContainers); !ok {
0000000000000000000000000000000000000000;;			t.Errorf("expected %q, got %q", expectedContainers, actual)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
