0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
65591e92a75630d51ab923b044e00c72e059dfea;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kuberuntime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		containertest "k8s.io/kubernetes/pkg/kubelet/container/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestRemoveContainer tests removing the container and its corresponding container logs.
0000000000000000000000000000000000000000;;	func TestRemoveContainer(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeRuntime, _, m, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       "12345678",
0000000000000000000000000000000000000000;;				Name:      "bar",
0000000000000000000000000000000000000000;;				Namespace: "new",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:            "foo",
0000000000000000000000000000000000000000;;						Image:           "busybox",
0000000000000000000000000000000000000000;;						ImagePullPolicy: v1.PullIfNotPresent,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create fake sandbox and container
0000000000000000000000000000000000000000;;		_, fakeContainers := makeAndSetFakePod(t, m, fakeRuntime, pod)
0000000000000000000000000000000000000000;;		assert.Equal(t, len(fakeContainers), 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containerId := fakeContainers[0].Id
0000000000000000000000000000000000000000;;		fakeOS := m.osInterface.(*containertest.FakeOS)
0000000000000000000000000000000000000000;;		err = m.removeContainer(containerId)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		// Verify container log is removed
0000000000000000000000000000000000000000;;		expectedContainerLogPath := filepath.Join(podLogsRootDirectory, "12345678", "foo_0.log")
0000000000000000000000000000000000000000;;		expectedContainerLogSymlink := legacyLogSymlink(containerId, "foo", "bar", "new")
0000000000000000000000000000000000000000;;		assert.Equal(t, fakeOS.Removes, []string{expectedContainerLogPath, expectedContainerLogSymlink})
0000000000000000000000000000000000000000;;		// Verify container is removed
0000000000000000000000000000000000000000;;		assert.Contains(t, fakeRuntime.Called, "RemoveContainer")
0000000000000000000000000000000000000000;;		containers, err := fakeRuntime.ListContainers(&runtimeapi.ContainerFilter{Id: containerId})
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Empty(t, containers)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestKillContainer tests killing the container in a Pod.
0000000000000000000000000000000000000000;;	func TestKillContainer(t *testing.T) {
0000000000000000000000000000000000000000;;		_, _, m, _ := createTestRuntimeManager()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			caseName            string
0000000000000000000000000000000000000000;;			pod                 *v1.Pod
0000000000000000000000000000000000000000;;			containerID         kubecontainer.ContainerID
0000000000000000000000000000000000000000;;			containerName       string
0000000000000000000000000000000000000000;;			reason              string
0000000000000000000000000000000000000000;;			gracePeriodOverride int64
0000000000000000000000000000000000000000;;			succeed             bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				caseName: "Failed to find container in pods, expect to return error",
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{UID: "pod1_id", Name: "pod1", Namespace: "default"},
0000000000000000000000000000000000000000;;					Spec:       v1.PodSpec{Containers: []v1.Container{{Name: "empty_container"}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				containerID:         kubecontainer.ContainerID{Type: "docker", ID: "not_exist_container_id"},
0000000000000000000000000000000000000000;;				containerName:       "not_exist_container",
0000000000000000000000000000000000000000;;				reason:              "unknown reason",
0000000000000000000000000000000000000000;;				gracePeriodOverride: 0,
0000000000000000000000000000000000000000;;				succeed:             false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			err := m.killContainer(test.pod, test.containerID, test.containerName, test.reason, &test.gracePeriodOverride)
0000000000000000000000000000000000000000;;			if test.succeed != (err == nil) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v (%v)", test.caseName, test.succeed, (err == nil), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestToKubeContainerStatus tests the converting the CRI container status to
0000000000000000000000000000000000000000;;	// the internal type (i.e., toKubeContainerStatus()) for containers in
0000000000000000000000000000000000000000;;	// different states.
0000000000000000000000000000000000000000;;	func TestToKubeContainerStatus(t *testing.T) {
0000000000000000000000000000000000000000;;		cid := &kubecontainer.ContainerID{Type: "testRuntime", ID: "dummyid"}
0000000000000000000000000000000000000000;;		meta := &runtimeapi.ContainerMetadata{Name: "cname", Attempt: 3}
0000000000000000000000000000000000000000;;		imageSpec := &runtimeapi.ImageSpec{Image: "fimage"}
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			createdAt  int64 = 327
0000000000000000000000000000000000000000;;			startedAt  int64 = 999
0000000000000000000000000000000000000000;;			finishedAt int64 = 1278
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for desc, test := range map[string]struct {
0000000000000000000000000000000000000000;;			input    *runtimeapi.ContainerStatus
0000000000000000000000000000000000000000;;			expected *kubecontainer.ContainerStatus
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"created container": {
0000000000000000000000000000000000000000;;				input: &runtimeapi.ContainerStatus{
0000000000000000000000000000000000000000;;					Id:        cid.ID,
0000000000000000000000000000000000000000;;					Metadata:  meta,
0000000000000000000000000000000000000000;;					Image:     imageSpec,
0000000000000000000000000000000000000000;;					State:     runtimeapi.ContainerState_CONTAINER_CREATED,
0000000000000000000000000000000000000000;;					CreatedAt: createdAt,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: &kubecontainer.ContainerStatus{
0000000000000000000000000000000000000000;;					ID:        *cid,
0000000000000000000000000000000000000000;;					Image:     imageSpec.Image,
0000000000000000000000000000000000000000;;					State:     kubecontainer.ContainerStateCreated,
0000000000000000000000000000000000000000;;					CreatedAt: time.Unix(0, createdAt),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"running container": {
0000000000000000000000000000000000000000;;				input: &runtimeapi.ContainerStatus{
0000000000000000000000000000000000000000;;					Id:        cid.ID,
0000000000000000000000000000000000000000;;					Metadata:  meta,
0000000000000000000000000000000000000000;;					Image:     imageSpec,
0000000000000000000000000000000000000000;;					State:     runtimeapi.ContainerState_CONTAINER_RUNNING,
0000000000000000000000000000000000000000;;					CreatedAt: createdAt,
0000000000000000000000000000000000000000;;					StartedAt: startedAt,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: &kubecontainer.ContainerStatus{
0000000000000000000000000000000000000000;;					ID:        *cid,
0000000000000000000000000000000000000000;;					Image:     imageSpec.Image,
0000000000000000000000000000000000000000;;					State:     kubecontainer.ContainerStateRunning,
0000000000000000000000000000000000000000;;					CreatedAt: time.Unix(0, createdAt),
0000000000000000000000000000000000000000;;					StartedAt: time.Unix(0, startedAt),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"exited container": {
0000000000000000000000000000000000000000;;				input: &runtimeapi.ContainerStatus{
0000000000000000000000000000000000000000;;					Id:         cid.ID,
0000000000000000000000000000000000000000;;					Metadata:   meta,
0000000000000000000000000000000000000000;;					Image:      imageSpec,
0000000000000000000000000000000000000000;;					State:      runtimeapi.ContainerState_CONTAINER_EXITED,
0000000000000000000000000000000000000000;;					CreatedAt:  createdAt,
0000000000000000000000000000000000000000;;					StartedAt:  startedAt,
0000000000000000000000000000000000000000;;					FinishedAt: finishedAt,
0000000000000000000000000000000000000000;;					ExitCode:   int32(121),
0000000000000000000000000000000000000000;;					Reason:     "GotKilled",
0000000000000000000000000000000000000000;;					Message:    "The container was killed",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: &kubecontainer.ContainerStatus{
0000000000000000000000000000000000000000;;					ID:         *cid,
0000000000000000000000000000000000000000;;					Image:      imageSpec.Image,
0000000000000000000000000000000000000000;;					State:      kubecontainer.ContainerStateExited,
0000000000000000000000000000000000000000;;					CreatedAt:  time.Unix(0, createdAt),
0000000000000000000000000000000000000000;;					StartedAt:  time.Unix(0, startedAt),
0000000000000000000000000000000000000000;;					FinishedAt: time.Unix(0, finishedAt),
0000000000000000000000000000000000000000;;					ExitCode:   121,
0000000000000000000000000000000000000000;;					Reason:     "GotKilled",
0000000000000000000000000000000000000000;;					Message:    "The container was killed",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"unknown container": {
0000000000000000000000000000000000000000;;				input: &runtimeapi.ContainerStatus{
0000000000000000000000000000000000000000;;					Id:        cid.ID,
0000000000000000000000000000000000000000;;					Metadata:  meta,
0000000000000000000000000000000000000000;;					Image:     imageSpec,
0000000000000000000000000000000000000000;;					State:     runtimeapi.ContainerState_CONTAINER_UNKNOWN,
0000000000000000000000000000000000000000;;					CreatedAt: createdAt,
0000000000000000000000000000000000000000;;					StartedAt: startedAt,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: &kubecontainer.ContainerStatus{
0000000000000000000000000000000000000000;;					ID:        *cid,
0000000000000000000000000000000000000000;;					Image:     imageSpec.Image,
0000000000000000000000000000000000000000;;					State:     kubecontainer.ContainerStateUnknown,
0000000000000000000000000000000000000000;;					CreatedAt: time.Unix(0, createdAt),
0000000000000000000000000000000000000000;;					StartedAt: time.Unix(0, startedAt),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			actual := toKubeContainerStatus(test.input, cid.Type)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.expected, actual, desc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeExpetectedConfig(m *kubeGenericRuntimeManager, pod *v1.Pod, containerIndex int) *runtimeapi.ContainerConfig {
0000000000000000000000000000000000000000;;		container := &pod.Spec.Containers[containerIndex]
0000000000000000000000000000000000000000;;		podIP := ""
0000000000000000000000000000000000000000;;		restartCount := 0
0000000000000000000000000000000000000000;;		opts, _, _ := m.runtimeHelper.GenerateRunContainerOptions(pod, container, podIP)
0000000000000000000000000000000000000000;;		containerLogsPath := buildContainerLogsPath(container.Name, restartCount)
0000000000000000000000000000000000000000;;		restartCountUint32 := uint32(restartCount)
0000000000000000000000000000000000000000;;		envs := make([]*runtimeapi.KeyValue, len(opts.Envs))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedConfig := &runtimeapi.ContainerConfig{
0000000000000000000000000000000000000000;;			Metadata: &runtimeapi.ContainerMetadata{
0000000000000000000000000000000000000000;;				Name:    container.Name,
0000000000000000000000000000000000000000;;				Attempt: restartCountUint32,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Image:       &runtimeapi.ImageSpec{Image: container.Image},
0000000000000000000000000000000000000000;;			Command:     container.Command,
0000000000000000000000000000000000000000;;			Args:        []string(nil),
0000000000000000000000000000000000000000;;			WorkingDir:  container.WorkingDir,
0000000000000000000000000000000000000000;;			Labels:      newContainerLabels(container, pod),
0000000000000000000000000000000000000000;;			Annotations: newContainerAnnotations(container, pod, restartCount),
0000000000000000000000000000000000000000;;			Devices:     makeDevices(opts),
0000000000000000000000000000000000000000;;			Mounts:      m.makeMounts(opts, container),
0000000000000000000000000000000000000000;;			LogPath:     containerLogsPath,
0000000000000000000000000000000000000000;;			Stdin:       container.Stdin,
0000000000000000000000000000000000000000;;			StdinOnce:   container.StdinOnce,
0000000000000000000000000000000000000000;;			Tty:         container.TTY,
0000000000000000000000000000000000000000;;			Linux:       m.generateLinuxContainerConfig(container, pod, new(int64), ""),
0000000000000000000000000000000000000000;;			Envs:        envs,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return expectedConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGenerateContainerConfig(t *testing.T) {
0000000000000000000000000000000000000000;;		_, _, m, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       "12345678",
0000000000000000000000000000000000000000;;				Name:      "bar",
0000000000000000000000000000000000000000;;				Namespace: "new",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:            "foo",
0000000000000000000000000000000000000000;;						Image:           "busybox",
0000000000000000000000000000000000000000;;						ImagePullPolicy: v1.PullIfNotPresent,
0000000000000000000000000000000000000000;;						Command:         []string{"testCommand"},
0000000000000000000000000000000000000000;;						WorkingDir:      "testWorkingDir",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedConfig := makeExpetectedConfig(m, pod, 0)
0000000000000000000000000000000000000000;;		containerConfig, err := m.generateContainerConfig(&pod.Spec.Containers[0], pod, 0, "", pod.Spec.Containers[0].Image)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, expectedConfig, containerConfig, "generate container config for kubelet runtime v1.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runAsUser := int64(0)
0000000000000000000000000000000000000000;;		runAsNonRootTrue := true
0000000000000000000000000000000000000000;;		podWithContainerSecurityContext := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       "12345678",
0000000000000000000000000000000000000000;;				Name:      "bar",
0000000000000000000000000000000000000000;;				Namespace: "new",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:            "foo",
0000000000000000000000000000000000000000;;						Image:           "busybox",
0000000000000000000000000000000000000000;;						ImagePullPolicy: v1.PullIfNotPresent,
0000000000000000000000000000000000000000;;						Command:         []string{"testCommand"},
0000000000000000000000000000000000000000;;						WorkingDir:      "testWorkingDir",
0000000000000000000000000000000000000000;;						SecurityContext: &v1.SecurityContext{
0000000000000000000000000000000000000000;;							RunAsNonRoot: &runAsNonRootTrue,
0000000000000000000000000000000000000000;;							RunAsUser:    &runAsUser,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = m.generateContainerConfig(&podWithContainerSecurityContext.Spec.Containers[0], podWithContainerSecurityContext, 0, "", podWithContainerSecurityContext.Spec.Containers[0].Image)
0000000000000000000000000000000000000000;;		assert.Error(t, err)
0000000000000000000000000000000000000000;;	}
