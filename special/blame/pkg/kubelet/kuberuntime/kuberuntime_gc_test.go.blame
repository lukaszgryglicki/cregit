0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
7f4eb170a27824603528efadbc3644993b161225;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kuberuntime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/mock/gomock"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		containertest "k8s.io/kubernetes/pkg/kubelet/container/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSandboxGC(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeRuntime, _, m, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakePodGetter := m.containerGC.podGetter.(*fakePodGetter)
0000000000000000000000000000000000000000;;		makeGCSandbox := func(pod *v1.Pod, attempt uint32, state runtimeapi.PodSandboxState, withPodGetter bool, createdAt int64) sandboxTemplate {
0000000000000000000000000000000000000000;;			if withPodGetter {
0000000000000000000000000000000000000000;;				// initialize the pod getter
0000000000000000000000000000000000000000;;				fakePodGetter.pods[pod.UID] = pod
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return sandboxTemplate{
0000000000000000000000000000000000000000;;				pod:       pod,
0000000000000000000000000000000000000000;;				state:     state,
0000000000000000000000000000000000000000;;				attempt:   attempt,
0000000000000000000000000000000000000000;;				createdAt: createdAt,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods := []*v1.Pod{
0000000000000000000000000000000000000000;;			makeTestPod("foo1", "new", "1234", []v1.Container{
0000000000000000000000000000000000000000;;				makeTestContainer("bar1", "busybox"),
0000000000000000000000000000000000000000;;				makeTestContainer("bar2", "busybox"),
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			makeTestPod("foo2", "new", "5678", []v1.Container{
0000000000000000000000000000000000000000;;				makeTestContainer("bar3", "busybox"),
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			makeTestPod("deleted", "new", "9012", []v1.Container{
0000000000000000000000000000000000000000;;				makeTestContainer("bar4", "busybox"),
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for c, test := range []struct {
0000000000000000000000000000000000000000;;			description         string              // description of the test case
0000000000000000000000000000000000000000;;			sandboxes           []sandboxTemplate   // templates of sandboxes
0000000000000000000000000000000000000000;;			containers          []containerTemplate // templates of containers
0000000000000000000000000000000000000000;;			minAge              time.Duration       // sandboxMinGCAge
0000000000000000000000000000000000000000;;			remain              []int               // template indexes of remaining sandboxes
0000000000000000000000000000000000000000;;			evictNonDeletedPods bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "notready sandboxes without containers for deleted pods should be garbage collected.",
0000000000000000000000000000000000000000;;				sandboxes: []sandboxTemplate{
0000000000000000000000000000000000000000;;					makeGCSandbox(pods[2], 0, runtimeapi.PodSandboxState_SANDBOX_NOTREADY, false, 0),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				containers:          []containerTemplate{},
0000000000000000000000000000000000000000;;				remain:              []int{},
0000000000000000000000000000000000000000;;				evictNonDeletedPods: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "ready sandboxes without containers for deleted pods should not be garbage collected.",
0000000000000000000000000000000000000000;;				sandboxes: []sandboxTemplate{
0000000000000000000000000000000000000000;;					makeGCSandbox(pods[2], 0, runtimeapi.PodSandboxState_SANDBOX_READY, false, 0),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				containers:          []containerTemplate{},
0000000000000000000000000000000000000000;;				remain:              []int{0},
0000000000000000000000000000000000000000;;				evictNonDeletedPods: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "sandboxes for existing pods should not be garbage collected.",
0000000000000000000000000000000000000000;;				sandboxes: []sandboxTemplate{
0000000000000000000000000000000000000000;;					makeGCSandbox(pods[0], 0, runtimeapi.PodSandboxState_SANDBOX_READY, true, 0),
0000000000000000000000000000000000000000;;					makeGCSandbox(pods[1], 0, runtimeapi.PodSandboxState_SANDBOX_NOTREADY, true, 0),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				containers:          []containerTemplate{},
0000000000000000000000000000000000000000;;				remain:              []int{0, 1},
0000000000000000000000000000000000000000;;				evictNonDeletedPods: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "non-running sandboxes for existing pods should be garbage collected if evictNonDeletedPods is set.",
0000000000000000000000000000000000000000;;				sandboxes: []sandboxTemplate{
0000000000000000000000000000000000000000;;					makeGCSandbox(pods[0], 0, runtimeapi.PodSandboxState_SANDBOX_READY, true, 0),
0000000000000000000000000000000000000000;;					makeGCSandbox(pods[1], 0, runtimeapi.PodSandboxState_SANDBOX_NOTREADY, true, 0),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				containers:          []containerTemplate{},
0000000000000000000000000000000000000000;;				remain:              []int{0},
0000000000000000000000000000000000000000;;				evictNonDeletedPods: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "sandbox with containers should not be garbage collected.",
0000000000000000000000000000000000000000;;				sandboxes: []sandboxTemplate{
0000000000000000000000000000000000000000;;					makeGCSandbox(pods[0], 0, runtimeapi.PodSandboxState_SANDBOX_NOTREADY, false, 0),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				containers: []containerTemplate{
0000000000000000000000000000000000000000;;					{pod: pods[0], container: &pods[0].Spec.Containers[0], state: runtimeapi.ContainerState_CONTAINER_EXITED},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				remain:              []int{0},
0000000000000000000000000000000000000000;;				evictNonDeletedPods: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "multiple sandboxes should be handled properly.",
0000000000000000000000000000000000000000;;				sandboxes: []sandboxTemplate{
0000000000000000000000000000000000000000;;					// running sandbox.
0000000000000000000000000000000000000000;;					makeGCSandbox(pods[0], 1, runtimeapi.PodSandboxState_SANDBOX_READY, true, 1),
0000000000000000000000000000000000000000;;					// exited sandbox without containers.
0000000000000000000000000000000000000000;;					makeGCSandbox(pods[0], 0, runtimeapi.PodSandboxState_SANDBOX_NOTREADY, true, 0),
0000000000000000000000000000000000000000;;					// exited sandbox with containers.
0000000000000000000000000000000000000000;;					makeGCSandbox(pods[1], 1, runtimeapi.PodSandboxState_SANDBOX_NOTREADY, true, 1),
0000000000000000000000000000000000000000;;					// exited sandbox without containers.
0000000000000000000000000000000000000000;;					makeGCSandbox(pods[1], 0, runtimeapi.PodSandboxState_SANDBOX_NOTREADY, true, 0),
0000000000000000000000000000000000000000;;					// exited sandbox without containers for deleted pods.
0000000000000000000000000000000000000000;;					makeGCSandbox(pods[2], 0, runtimeapi.PodSandboxState_SANDBOX_NOTREADY, false, 0),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				containers: []containerTemplate{
0000000000000000000000000000000000000000;;					{pod: pods[1], container: &pods[1].Spec.Containers[0], sandboxAttempt: 1, state: runtimeapi.ContainerState_CONTAINER_EXITED},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				remain:              []int{0, 2},
0000000000000000000000000000000000000000;;				evictNonDeletedPods: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			t.Logf("TestCase #%d: %+v", c, test)
0000000000000000000000000000000000000000;;			fakeSandboxes := makeFakePodSandboxes(t, m, test.sandboxes)
0000000000000000000000000000000000000000;;			fakeContainers := makeFakeContainers(t, m, test.containers)
0000000000000000000000000000000000000000;;			fakeRuntime.SetFakeSandboxes(fakeSandboxes)
0000000000000000000000000000000000000000;;			fakeRuntime.SetFakeContainers(fakeContainers)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := m.containerGC.evictSandboxes(test.evictNonDeletedPods)
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;			realRemain, err := fakeRuntime.ListPodSandbox(nil)
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;			assert.Len(t, realRemain, len(test.remain))
0000000000000000000000000000000000000000;;			for _, remain := range test.remain {
0000000000000000000000000000000000000000;;				status, err := fakeRuntime.PodSandboxStatus(fakeSandboxes[remain].Id)
0000000000000000000000000000000000000000;;				assert.NoError(t, err)
0000000000000000000000000000000000000000;;				assert.Equal(t, &fakeSandboxes[remain].PodSandboxStatus, status)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestContainerGC(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeRuntime, _, m, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakePodGetter := m.containerGC.podGetter.(*fakePodGetter)
0000000000000000000000000000000000000000;;		makeGCContainer := func(podName, containerName string, attempt int, createdAt int64, state runtimeapi.ContainerState) containerTemplate {
0000000000000000000000000000000000000000;;			container := makeTestContainer(containerName, "test-image")
0000000000000000000000000000000000000000;;			pod := makeTestPod(podName, "test-ns", podName, []v1.Container{container})
0000000000000000000000000000000000000000;;			if podName != "deleted" {
0000000000000000000000000000000000000000;;				// initialize the pod getter, explicitly exclude deleted pod
0000000000000000000000000000000000000000;;				fakePodGetter.pods[pod.UID] = pod
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return containerTemplate{
0000000000000000000000000000000000000000;;				pod:       pod,
0000000000000000000000000000000000000000;;				container: &container,
0000000000000000000000000000000000000000;;				attempt:   attempt,
0000000000000000000000000000000000000000;;				createdAt: createdAt,
0000000000000000000000000000000000000000;;				state:     state,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defaultGCPolicy := kubecontainer.ContainerGCPolicy{MinAge: time.Hour, MaxPerPodContainer: 2, MaxContainers: 6}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for c, test := range []struct {
0000000000000000000000000000000000000000;;			description         string                           // description of the test case
0000000000000000000000000000000000000000;;			containers          []containerTemplate              // templates of containers
0000000000000000000000000000000000000000;;			policy              *kubecontainer.ContainerGCPolicy // container gc policy
0000000000000000000000000000000000000000;;			remain              []int                            // template indexes of remaining containers
0000000000000000000000000000000000000000;;			evictNonDeletedPods bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "all containers should be removed when max container limit is 0",
0000000000000000000000000000000000000000;;				containers: []containerTemplate{
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 0, 0, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				policy:              &kubecontainer.ContainerGCPolicy{MinAge: time.Minute, MaxPerPodContainer: 1, MaxContainers: 0},
0000000000000000000000000000000000000000;;				remain:              []int{},
0000000000000000000000000000000000000000;;				evictNonDeletedPods: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "max containers should be complied when no max per pod container limit is set",
0000000000000000000000000000000000000000;;				containers: []containerTemplate{
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 4, 4, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 3, 3, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 2, 2, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 0, 0, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				policy:              &kubecontainer.ContainerGCPolicy{MinAge: time.Minute, MaxPerPodContainer: -1, MaxContainers: 4},
0000000000000000000000000000000000000000;;				remain:              []int{0, 1, 2, 3},
0000000000000000000000000000000000000000;;				evictNonDeletedPods: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "no containers should be removed if both max container and per pod container limits are not set",
0000000000000000000000000000000000000000;;				containers: []containerTemplate{
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 2, 2, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 0, 0, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				policy:              &kubecontainer.ContainerGCPolicy{MinAge: time.Minute, MaxPerPodContainer: -1, MaxContainers: -1},
0000000000000000000000000000000000000000;;				remain:              []int{0, 1, 2},
0000000000000000000000000000000000000000;;				evictNonDeletedPods: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "recently started containers should not be removed",
0000000000000000000000000000000000000000;;				containers: []containerTemplate{
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 2, time.Now().UnixNano(), runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 1, time.Now().UnixNano(), runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 0, time.Now().UnixNano(), runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				remain:              []int{0, 1, 2},
0000000000000000000000000000000000000000;;				evictNonDeletedPods: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "oldest containers should be removed when per pod container limit exceeded",
0000000000000000000000000000000000000000;;				containers: []containerTemplate{
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 2, 2, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 0, 0, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				remain:              []int{0, 1},
0000000000000000000000000000000000000000;;				evictNonDeletedPods: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "running containers should not be removed",
0000000000000000000000000000000000000000;;				containers: []containerTemplate{
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 2, 2, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 0, 0, runtimeapi.ContainerState_CONTAINER_RUNNING),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				remain:              []int{0, 1, 2},
0000000000000000000000000000000000000000;;				evictNonDeletedPods: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "no containers should be removed when limits are not exceeded",
0000000000000000000000000000000000000000;;				containers: []containerTemplate{
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 0, 0, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				remain:              []int{0, 1},
0000000000000000000000000000000000000000;;				evictNonDeletedPods: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "max container count should apply per (UID, container) pair",
0000000000000000000000000000000000000000;;				containers: []containerTemplate{
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 2, 2, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 0, 0, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo1", "baz", 2, 2, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo1", "baz", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo1", "baz", 0, 0, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo2", "bar", 2, 2, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo2", "bar", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo2", "bar", 0, 0, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				remain:              []int{0, 1, 3, 4, 6, 7},
0000000000000000000000000000000000000000;;				evictNonDeletedPods: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "max limit should apply and try to keep from every pod",
0000000000000000000000000000000000000000;;				containers: []containerTemplate{
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 0, 0, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo1", "bar1", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo1", "bar1", 0, 0, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo2", "bar2", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo2", "bar2", 0, 0, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo3", "bar3", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo3", "bar3", 0, 0, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo4", "bar4", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo4", "bar4", 0, 0, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				remain:              []int{0, 2, 4, 6, 8},
0000000000000000000000000000000000000000;;				evictNonDeletedPods: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "oldest pods should be removed if limit exceeded",
0000000000000000000000000000000000000000;;				containers: []containerTemplate{
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 2, 2, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo1", "bar1", 2, 2, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo1", "bar1", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo2", "bar2", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo3", "bar3", 0, 0, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo4", "bar4", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo5", "bar5", 0, 0, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo6", "bar6", 2, 2, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo7", "bar7", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				remain:              []int{0, 2, 4, 6, 8, 9},
0000000000000000000000000000000000000000;;				evictNonDeletedPods: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "all non-running containers should be removed when evictNonDeletedPods is set",
0000000000000000000000000000000000000000;;				containers: []containerTemplate{
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 2, 2, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo1", "bar1", 2, 2, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo1", "bar1", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo2", "bar2", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo3", "bar3", 0, 0, runtimeapi.ContainerState_CONTAINER_RUNNING),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				remain:              []int{5},
0000000000000000000000000000000000000000;;				evictNonDeletedPods: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "containers for deleted pods should be removed",
0000000000000000000000000000000000000000;;				containers: []containerTemplate{
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("foo", "bar", 0, 0, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					// deleted pods still respect MinAge.
0000000000000000000000000000000000000000;;					makeGCContainer("deleted", "bar1", 2, time.Now().UnixNano(), runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("deleted", "bar1", 1, 1, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;					makeGCContainer("deleted", "bar1", 0, 0, runtimeapi.ContainerState_CONTAINER_EXITED),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				remain:              []int{0, 1, 2},
0000000000000000000000000000000000000000;;				evictNonDeletedPods: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			t.Logf("TestCase #%d: %+v", c, test)
0000000000000000000000000000000000000000;;			fakeContainers := makeFakeContainers(t, m, test.containers)
0000000000000000000000000000000000000000;;			fakeRuntime.SetFakeContainers(fakeContainers)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.policy == nil {
0000000000000000000000000000000000000000;;				test.policy = &defaultGCPolicy
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := m.containerGC.evictContainers(*test.policy, true, test.evictNonDeletedPods)
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;			realRemain, err := fakeRuntime.ListContainers(nil)
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;			assert.Len(t, realRemain, len(test.remain))
0000000000000000000000000000000000000000;;			for _, remain := range test.remain {
0000000000000000000000000000000000000000;;				status, err := fakeRuntime.ContainerStatus(fakeContainers[remain].Id)
0000000000000000000000000000000000000000;;				assert.NoError(t, err)
0000000000000000000000000000000000000000;;				assert.Equal(t, &fakeContainers[remain].ContainerStatus, status)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Notice that legacy container symlink is not tested since it may be deprecated soon.
0000000000000000000000000000000000000000;;	func TestPodLogDirectoryGC(t *testing.T) {
0000000000000000000000000000000000000000;;		_, _, m, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		fakeOS := m.osInterface.(*containertest.FakeOS)
0000000000000000000000000000000000000000;;		fakePodGetter := m.containerGC.podGetter.(*fakePodGetter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pod log directories without corresponding pods should be removed.
0000000000000000000000000000000000000000;;		fakePodGetter.pods["123"] = makeTestPod("foo1", "new", "123", nil)
0000000000000000000000000000000000000000;;		fakePodGetter.pods["456"] = makeTestPod("foo2", "new", "456", nil)
0000000000000000000000000000000000000000;;		files := []string{"123", "456", "789", "012"}
0000000000000000000000000000000000000000;;		removed := []string{filepath.Join(podLogsRootDirectory, "789"), filepath.Join(podLogsRootDirectory, "012")}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctrl := gomock.NewController(t)
0000000000000000000000000000000000000000;;		defer ctrl.Finish()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeOS.ReadDirFn = func(string) ([]os.FileInfo, error) {
0000000000000000000000000000000000000000;;			var fileInfos []os.FileInfo
0000000000000000000000000000000000000000;;			for _, file := range files {
0000000000000000000000000000000000000000;;				mockFI := containertest.NewMockFileInfo(ctrl)
0000000000000000000000000000000000000000;;				mockFI.EXPECT().Name().Return(file)
0000000000000000000000000000000000000000;;				fileInfos = append(fileInfos, mockFI)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fileInfos, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// allSourcesReady == true, pod log directories without corresponding pod should be removed.
0000000000000000000000000000000000000000;;		err = m.containerGC.evictPodLogsDirectories(true)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, removed, fakeOS.Removes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// allSourcesReady == false, pod log directories should not be removed.
0000000000000000000000000000000000000000;;		fakeOS.Removes = []string{}
0000000000000000000000000000000000000000;;		err = m.containerGC.evictPodLogsDirectories(false)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Empty(t, fakeOS.Removes)
0000000000000000000000000000000000000000;;	}
