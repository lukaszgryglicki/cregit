0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
5464e5a5d7a8fd40e9826bae7a1dc78c936c2109;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kuberuntime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/require"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/credentialprovider"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPullImage(t *testing.T) {
0000000000000000000000000000000000000000;;		_, _, fakeManager, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		imageRef, err := fakeManager.PullImage(kubecontainer.ImageSpec{Image: "busybox"}, nil)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, "busybox", imageRef)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		images, err := fakeManager.ListImages()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, 1, len(images))
0000000000000000000000000000000000000000;;		assert.Equal(t, images[0].RepoTags, []string{"busybox"})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestListImages(t *testing.T) {
0000000000000000000000000000000000000000;;		_, fakeImageService, fakeManager, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		images := []string{"1111", "2222", "3333"}
0000000000000000000000000000000000000000;;		expected := sets.NewString(images...)
0000000000000000000000000000000000000000;;		fakeImageService.SetFakeImages(images)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actualImages, err := fakeManager.ListImages()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		actual := sets.NewString()
0000000000000000000000000000000000000000;;		for _, i := range actualImages {
0000000000000000000000000000000000000000;;			actual.Insert(i.ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.Equal(t, expected.List(), actual.List())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetImageRef(t *testing.T) {
0000000000000000000000000000000000000000;;		_, fakeImageService, fakeManager, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		image := "busybox"
0000000000000000000000000000000000000000;;		fakeImageService.SetFakeImages([]string{image})
0000000000000000000000000000000000000000;;		imageRef, err := fakeManager.GetImageRef(kubecontainer.ImageSpec{Image: image})
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, image, imageRef)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRemoveImage(t *testing.T) {
0000000000000000000000000000000000000000;;		_, fakeImageService, fakeManager, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = fakeManager.PullImage(kubecontainer.ImageSpec{Image: "busybox"}, nil)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, 1, len(fakeImageService.Images))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = fakeManager.RemoveImage(kubecontainer.ImageSpec{Image: "busybox"})
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, 0, len(fakeImageService.Images))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestImageStats(t *testing.T) {
0000000000000000000000000000000000000000;;		_, fakeImageService, fakeManager, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const imageSize = 64
0000000000000000000000000000000000000000;;		fakeImageService.SetFakeImageSize(imageSize)
0000000000000000000000000000000000000000;;		images := []string{"1111", "2222", "3333"}
0000000000000000000000000000000000000000;;		fakeImageService.SetFakeImages(images)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actualStats, err := fakeManager.ImageStats()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		expectedStats := &kubecontainer.ImageStats{TotalStorageBytes: imageSize * uint64(len(images))}
0000000000000000000000000000000000000000;;		assert.Equal(t, expectedStats, actualStats)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPullWithSecrets(t *testing.T) {
0000000000000000000000000000000000000000;;		// auth value is equivalent to: "username":"passed-user","password":"passed-password"
0000000000000000000000000000000000000000;;		dockerCfg := map[string]map[string]string{"index.docker.io/v1/": {"email": "passed-email", "auth": "cGFzc2VkLXVzZXI6cGFzc2VkLXBhc3N3b3Jk"}}
0000000000000000000000000000000000000000;;		dockercfgContent, err := json.Marshal(dockerCfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockerConfigJson := map[string]map[string]map[string]string{"auths": dockerCfg}
0000000000000000000000000000000000000000;;		dockerConfigJsonContent, err := json.Marshal(dockerConfigJson)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			imageName           string
0000000000000000000000000000000000000000;;			passedSecrets       []v1.Secret
0000000000000000000000000000000000000000;;			builtInDockerConfig credentialprovider.DockerConfig
0000000000000000000000000000000000000000;;			expectedAuth        *runtimeapi.AuthConfig
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"no matching secrets": {
0000000000000000000000000000000000000000;;				"ubuntu",
0000000000000000000000000000000000000000;;				[]v1.Secret{},
0000000000000000000000000000000000000000;;				credentialprovider.DockerConfig(map[string]credentialprovider.DockerConfigEntry{}),
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"default keyring secrets": {
0000000000000000000000000000000000000000;;				"ubuntu",
0000000000000000000000000000000000000000;;				[]v1.Secret{},
0000000000000000000000000000000000000000;;				credentialprovider.DockerConfig(map[string]credentialprovider.DockerConfigEntry{
0000000000000000000000000000000000000000;;					"index.docker.io/v1/": {Username: "built-in", Password: "password", Provider: nil},
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;				&runtimeapi.AuthConfig{Username: "built-in", Password: "password"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"default keyring secrets unused": {
0000000000000000000000000000000000000000;;				"ubuntu",
0000000000000000000000000000000000000000;;				[]v1.Secret{},
0000000000000000000000000000000000000000;;				credentialprovider.DockerConfig(map[string]credentialprovider.DockerConfigEntry{
0000000000000000000000000000000000000000;;					"extraneous": {Username: "built-in", Password: "password", Provider: nil},
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"builtin keyring secrets, but use passed": {
0000000000000000000000000000000000000000;;				"ubuntu",
0000000000000000000000000000000000000000;;				[]v1.Secret{{Type: v1.SecretTypeDockercfg, Data: map[string][]byte{v1.DockerConfigKey: dockercfgContent}}},
0000000000000000000000000000000000000000;;				credentialprovider.DockerConfig(map[string]credentialprovider.DockerConfigEntry{
0000000000000000000000000000000000000000;;					"index.docker.io/v1/": {Username: "built-in", Password: "password", Provider: nil},
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;				&runtimeapi.AuthConfig{Username: "passed-user", Password: "passed-password"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"builtin keyring secrets, but use passed with new docker config": {
0000000000000000000000000000000000000000;;				"ubuntu",
0000000000000000000000000000000000000000;;				[]v1.Secret{{Type: v1.SecretTypeDockerConfigJson, Data: map[string][]byte{v1.DockerConfigJsonKey: dockerConfigJsonContent}}},
0000000000000000000000000000000000000000;;				credentialprovider.DockerConfig(map[string]credentialprovider.DockerConfigEntry{
0000000000000000000000000000000000000000;;					"index.docker.io/v1/": {Username: "built-in", Password: "password", Provider: nil},
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;				&runtimeapi.AuthConfig{Username: "passed-user", Password: "passed-password"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for description, test := range tests {
0000000000000000000000000000000000000000;;			builtInKeyRing := &credentialprovider.BasicDockerKeyring{}
0000000000000000000000000000000000000000;;			builtInKeyRing.Add(test.builtInDockerConfig)
0000000000000000000000000000000000000000;;			_, fakeImageService, fakeManager, err := customTestRuntimeManager(builtInKeyRing)
0000000000000000000000000000000000000000;;			require.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err = fakeManager.PullImage(kubecontainer.ImageSpec{Image: test.imageName}, test.passedSecrets)
0000000000000000000000000000000000000000;;			require.NoError(t, err)
0000000000000000000000000000000000000000;;			fakeImageService.AssertImagePulledWithAuth(t, &runtimeapi.ImageSpec{Image: test.imageName}, test.expectedAuth, description)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
