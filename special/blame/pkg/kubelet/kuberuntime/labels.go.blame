0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
87f241273b941272e7eed736cc0b13bfcb14be8d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kuberuntime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		kubetypes "k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/format"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// TODO: change those label names to follow kubernetes's format
0000000000000000000000000000000000000000;;		podDeletionGracePeriodLabel    = "io.kubernetes.pod.deletionGracePeriod"
0000000000000000000000000000000000000000;;		podTerminationGracePeriodLabel = "io.kubernetes.pod.terminationGracePeriod"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containerHashLabel                     = "io.kubernetes.container.hash"
0000000000000000000000000000000000000000;;		containerRestartCountLabel             = "io.kubernetes.container.restartCount"
0000000000000000000000000000000000000000;;		containerTerminationMessagePathLabel   = "io.kubernetes.container.terminationMessagePath"
0000000000000000000000000000000000000000;;		containerTerminationMessagePolicyLabel = "io.kubernetes.container.terminationMessagePolicy"
0000000000000000000000000000000000000000;;		containerPreStopHandlerLabel           = "io.kubernetes.container.preStopHandler"
0000000000000000000000000000000000000000;;		containerPortsLabel                    = "io.kubernetes.container.ports"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type labeledPodSandboxInfo struct {
0000000000000000000000000000000000000000;;		// Labels from v1.Pod
0000000000000000000000000000000000000000;;		Labels       map[string]string
0000000000000000000000000000000000000000;;		PodName      string
0000000000000000000000000000000000000000;;		PodNamespace string
0000000000000000000000000000000000000000;;		PodUID       kubetypes.UID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type annotatedPodSandboxInfo struct {
0000000000000000000000000000000000000000;;		// Annotations from v1.Pod
0000000000000000000000000000000000000000;;		Annotations map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type labeledContainerInfo struct {
0000000000000000000000000000000000000000;;		ContainerName string
0000000000000000000000000000000000000000;;		PodName       string
0000000000000000000000000000000000000000;;		PodNamespace  string
0000000000000000000000000000000000000000;;		PodUID        kubetypes.UID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type annotatedContainerInfo struct {
0000000000000000000000000000000000000000;;		Hash                      uint64
0000000000000000000000000000000000000000;;		RestartCount              int
0000000000000000000000000000000000000000;;		PodDeletionGracePeriod    *int64
0000000000000000000000000000000000000000;;		PodTerminationGracePeriod *int64
0000000000000000000000000000000000000000;;		TerminationMessagePath    string
0000000000000000000000000000000000000000;;		TerminationMessagePolicy  v1.TerminationMessagePolicy
0000000000000000000000000000000000000000;;		PreStopHandler            *v1.Handler
0000000000000000000000000000000000000000;;		ContainerPorts            []v1.ContainerPort
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newPodLabels creates pod labels from v1.Pod.
0000000000000000000000000000000000000000;;	func newPodLabels(pod *v1.Pod) map[string]string {
0000000000000000000000000000000000000000;;		labels := map[string]string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get labels from v1.Pod
0000000000000000000000000000000000000000;;		for k, v := range pod.Labels {
0000000000000000000000000000000000000000;;			labels[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labels[types.KubernetesPodNameLabel] = pod.Name
0000000000000000000000000000000000000000;;		labels[types.KubernetesPodNamespaceLabel] = pod.Namespace
0000000000000000000000000000000000000000;;		labels[types.KubernetesPodUIDLabel] = string(pod.UID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return labels
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newPodAnnotations creates pod annotations from v1.Pod.
0000000000000000000000000000000000000000;;	func newPodAnnotations(pod *v1.Pod) map[string]string {
0000000000000000000000000000000000000000;;		return pod.Annotations
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newContainerLabels creates container labels from v1.Container and v1.Pod.
0000000000000000000000000000000000000000;;	func newContainerLabels(container *v1.Container, pod *v1.Pod) map[string]string {
0000000000000000000000000000000000000000;;		labels := map[string]string{}
0000000000000000000000000000000000000000;;		labels[types.KubernetesPodNameLabel] = pod.Name
0000000000000000000000000000000000000000;;		labels[types.KubernetesPodNamespaceLabel] = pod.Namespace
0000000000000000000000000000000000000000;;		labels[types.KubernetesPodUIDLabel] = string(pod.UID)
0000000000000000000000000000000000000000;;		labels[types.KubernetesContainerNameLabel] = container.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return labels
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newContainerAnnotations creates container annotations from v1.Container and v1.Pod.
0000000000000000000000000000000000000000;;	func newContainerAnnotations(container *v1.Container, pod *v1.Pod, restartCount int) map[string]string {
0000000000000000000000000000000000000000;;		annotations := map[string]string{}
0000000000000000000000000000000000000000;;		annotations[containerHashLabel] = strconv.FormatUint(kubecontainer.HashContainer(container), 16)
0000000000000000000000000000000000000000;;		annotations[containerRestartCountLabel] = strconv.Itoa(restartCount)
0000000000000000000000000000000000000000;;		annotations[containerTerminationMessagePathLabel] = container.TerminationMessagePath
0000000000000000000000000000000000000000;;		annotations[containerTerminationMessagePolicyLabel] = string(container.TerminationMessagePolicy)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pod.DeletionGracePeriodSeconds != nil {
0000000000000000000000000000000000000000;;			annotations[podDeletionGracePeriodLabel] = strconv.FormatInt(*pod.DeletionGracePeriodSeconds, 10)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pod.Spec.TerminationGracePeriodSeconds != nil {
0000000000000000000000000000000000000000;;			annotations[podTerminationGracePeriodLabel] = strconv.FormatInt(*pod.Spec.TerminationGracePeriodSeconds, 10)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if container.Lifecycle != nil && container.Lifecycle.PreStop != nil {
0000000000000000000000000000000000000000;;			// Using json enconding so that the PreStop handler object is readable after writing as a label
0000000000000000000000000000000000000000;;			rawPreStop, err := json.Marshal(container.Lifecycle.PreStop)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Unable to marshal lifecycle PreStop handler for container %q of pod %q: %v", container.Name, format.Pod(pod), err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				annotations[containerPreStopHandlerLabel] = string(rawPreStop)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(container.Ports) > 0 {
0000000000000000000000000000000000000000;;			rawContainerPorts, err := json.Marshal(container.Ports)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Unable to marshal container ports for container %q for pod %q: %v", container.Name, format.Pod(pod), err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				annotations[containerPortsLabel] = string(rawContainerPorts)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return annotations
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodSandboxInfoFromLabels gets labeledPodSandboxInfo from labels.
0000000000000000000000000000000000000000;;	func getPodSandboxInfoFromLabels(labels map[string]string) *labeledPodSandboxInfo {
0000000000000000000000000000000000000000;;		podSandboxInfo := &labeledPodSandboxInfo{
0000000000000000000000000000000000000000;;			Labels:       make(map[string]string),
0000000000000000000000000000000000000000;;			PodName:      getStringValueFromLabel(labels, types.KubernetesPodNameLabel),
0000000000000000000000000000000000000000;;			PodNamespace: getStringValueFromLabel(labels, types.KubernetesPodNamespaceLabel),
0000000000000000000000000000000000000000;;			PodUID:       kubetypes.UID(getStringValueFromLabel(labels, types.KubernetesPodUIDLabel)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remain only labels from v1.Pod
0000000000000000000000000000000000000000;;		for k, v := range labels {
0000000000000000000000000000000000000000;;			if k != types.KubernetesPodNameLabel && k != types.KubernetesPodNamespaceLabel && k != types.KubernetesPodUIDLabel {
0000000000000000000000000000000000000000;;				podSandboxInfo.Labels[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return podSandboxInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodSandboxInfoFromAnnotations gets annotatedPodSandboxInfo from annotations.
0000000000000000000000000000000000000000;;	func getPodSandboxInfoFromAnnotations(annotations map[string]string) *annotatedPodSandboxInfo {
0000000000000000000000000000000000000000;;		return &annotatedPodSandboxInfo{
0000000000000000000000000000000000000000;;			Annotations: annotations,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getContainerInfoFromLabels gets labeledContainerInfo from labels.
0000000000000000000000000000000000000000;;	func getContainerInfoFromLabels(labels map[string]string) *labeledContainerInfo {
0000000000000000000000000000000000000000;;		return &labeledContainerInfo{
0000000000000000000000000000000000000000;;			PodName:       getStringValueFromLabel(labels, types.KubernetesPodNameLabel),
0000000000000000000000000000000000000000;;			PodNamespace:  getStringValueFromLabel(labels, types.KubernetesPodNamespaceLabel),
0000000000000000000000000000000000000000;;			PodUID:        kubetypes.UID(getStringValueFromLabel(labels, types.KubernetesPodUIDLabel)),
0000000000000000000000000000000000000000;;			ContainerName: getStringValueFromLabel(labels, types.KubernetesContainerNameLabel),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getContainerInfoFromAnnotations gets annotatedContainerInfo from annotations.
0000000000000000000000000000000000000000;;	func getContainerInfoFromAnnotations(annotations map[string]string) *annotatedContainerInfo {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		containerInfo := &annotatedContainerInfo{
0000000000000000000000000000000000000000;;			TerminationMessagePath:   getStringValueFromLabel(annotations, containerTerminationMessagePathLabel),
0000000000000000000000000000000000000000;;			TerminationMessagePolicy: v1.TerminationMessagePolicy(getStringValueFromLabel(annotations, containerTerminationMessagePolicyLabel)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if containerInfo.Hash, err = getUint64ValueFromLabel(annotations, containerHashLabel); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unable to get %q from annotations %q: %v", containerHashLabel, annotations, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if containerInfo.RestartCount, err = getIntValueFromLabel(annotations, containerRestartCountLabel); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unable to get %q from annotations %q: %v", containerRestartCountLabel, annotations, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if containerInfo.PodDeletionGracePeriod, err = getInt64PointerFromLabel(annotations, podDeletionGracePeriodLabel); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unable to get %q from annotations %q: %v", podDeletionGracePeriodLabel, annotations, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if containerInfo.PodTerminationGracePeriod, err = getInt64PointerFromLabel(annotations, podTerminationGracePeriodLabel); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unable to get %q from annotations %q: %v", podTerminationGracePeriodLabel, annotations, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		preStopHandler := &v1.Handler{}
0000000000000000000000000000000000000000;;		if found, err := getJSONObjectFromLabel(annotations, containerPreStopHandlerLabel, preStopHandler); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unable to get %q from annotations %q: %v", containerPreStopHandlerLabel, annotations, err)
0000000000000000000000000000000000000000;;		} else if found {
0000000000000000000000000000000000000000;;			containerInfo.PreStopHandler = preStopHandler
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containerPorts := []v1.ContainerPort{}
0000000000000000000000000000000000000000;;		if found, err := getJSONObjectFromLabel(annotations, containerPortsLabel, &containerPorts); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unable to get %q from annotations %q: %v", containerPortsLabel, annotations, err)
0000000000000000000000000000000000000000;;		} else if found {
0000000000000000000000000000000000000000;;			containerInfo.ContainerPorts = containerPorts
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return containerInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getStringValueFromLabel(labels map[string]string, label string) string {
0000000000000000000000000000000000000000;;		if value, found := labels[label]; found {
0000000000000000000000000000000000000000;;			return value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Do not report error, because there should be many old containers without label now.
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Container doesn't have label %s, it may be an old or invalid container", label)
0000000000000000000000000000000000000000;;		// Return empty string "" for these containers, the caller will get value by other ways.
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getIntValueFromLabel(labels map[string]string, label string) (int, error) {
0000000000000000000000000000000000000000;;		if strValue, found := labels[label]; found {
0000000000000000000000000000000000000000;;			intValue, err := strconv.Atoi(strValue)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// This really should not happen. Just set value to 0 to handle this abnormal case
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return intValue, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Do not report error, because there should be many old containers without label now.
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Container doesn't have label %s, it may be an old or invalid container", label)
0000000000000000000000000000000000000000;;		// Just set the value to 0
0000000000000000000000000000000000000000;;		return 0, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getUint64ValueFromLabel(labels map[string]string, label string) (uint64, error) {
0000000000000000000000000000000000000000;;		if strValue, found := labels[label]; found {
0000000000000000000000000000000000000000;;			intValue, err := strconv.ParseUint(strValue, 16, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// This really should not happen. Just set value to 0 to handle this abnormal case
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return intValue, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Do not report error, because there should be many old containers without label now.
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Container doesn't have label %s, it may be an old or invalid container", label)
0000000000000000000000000000000000000000;;		// Just set the value to 0
0000000000000000000000000000000000000000;;		return 0, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getInt64PointerFromLabel(labels map[string]string, label string) (*int64, error) {
0000000000000000000000000000000000000000;;		if strValue, found := labels[label]; found {
0000000000000000000000000000000000000000;;			int64Value, err := strconv.ParseInt(strValue, 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &int64Value, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If the label is not found, return pointer nil.
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getJSONObjectFromLabel returns a bool value indicating whether an object is found.
0000000000000000000000000000000000000000;;	func getJSONObjectFromLabel(labels map[string]string, label string, value interface{}) (bool, error) {
0000000000000000000000000000000000000000;;		if strValue, found := labels[label]; found {
0000000000000000000000000000000000000000;;			err := json.Unmarshal([]byte(strValue), value)
0000000000000000000000000000000000000000;;			return found, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If the label is not found, return not found.
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
