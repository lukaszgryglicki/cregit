0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
7f4eb170a27824603528efadbc3644993b161225;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kuberuntime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		internalapi "k8s.io/kubernetes/pkg/kubelet/apis/cri"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// containerGC is the manager of garbage collection.
0000000000000000000000000000000000000000;;	type containerGC struct {
0000000000000000000000000000000000000000;;		client    internalapi.RuntimeService
0000000000000000000000000000000000000000;;		manager   *kubeGenericRuntimeManager
0000000000000000000000000000000000000000;;		podGetter podGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewContainerGC creates a new containerGC.
0000000000000000000000000000000000000000;;	func NewContainerGC(client internalapi.RuntimeService, podGetter podGetter, manager *kubeGenericRuntimeManager) *containerGC {
0000000000000000000000000000000000000000;;		return &containerGC{
0000000000000000000000000000000000000000;;			client:    client,
0000000000000000000000000000000000000000;;			manager:   manager,
0000000000000000000000000000000000000000;;			podGetter: podGetter,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// containerGCInfo is the internal information kept for containers being considered for GC.
0000000000000000000000000000000000000000;;	type containerGCInfo struct {
0000000000000000000000000000000000000000;;		// The ID of the container.
0000000000000000000000000000000000000000;;		id string
0000000000000000000000000000000000000000;;		// The name of the container.
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;		// The sandbox ID which this container belongs to
0000000000000000000000000000000000000000;;		sandboxID string
0000000000000000000000000000000000000000;;		// Creation time for the container.
0000000000000000000000000000000000000000;;		createTime time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sandboxGCInfo is the internal information kept for sandboxes being considered for GC.
0000000000000000000000000000000000000000;;	type sandboxGCInfo struct {
0000000000000000000000000000000000000000;;		// The ID of the sandbox.
0000000000000000000000000000000000000000;;		id string
0000000000000000000000000000000000000000;;		// Creation time for the sandbox.
0000000000000000000000000000000000000000;;		createTime time.Time
0000000000000000000000000000000000000000;;		// If true, the sandbox is ready or still has containers.
0000000000000000000000000000000000000000;;		active bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// evictUnit is considered for eviction as units of (UID, container name) pair.
0000000000000000000000000000000000000000;;	type evictUnit struct {
0000000000000000000000000000000000000000;;		// UID of the pod.
0000000000000000000000000000000000000000;;		uid types.UID
0000000000000000000000000000000000000000;;		// Name of the container in the pod.
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type containersByEvictUnit map[evictUnit][]containerGCInfo
0000000000000000000000000000000000000000;;	type sandboxesByPodUID map[types.UID][]sandboxGCInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NumContainers returns the number of containers in this map.
0000000000000000000000000000000000000000;;	func (cu containersByEvictUnit) NumContainers() int {
0000000000000000000000000000000000000000;;		num := 0
0000000000000000000000000000000000000000;;		for key := range cu {
0000000000000000000000000000000000000000;;			num += len(cu[key])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return num
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NumEvictUnits returns the number of pod in this map.
0000000000000000000000000000000000000000;;	func (cu containersByEvictUnit) NumEvictUnits() int {
0000000000000000000000000000000000000000;;		return len(cu)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Newest first.
0000000000000000000000000000000000000000;;	type byCreated []containerGCInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a byCreated) Len() int           { return len(a) }
0000000000000000000000000000000000000000;;	func (a byCreated) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
0000000000000000000000000000000000000000;;	func (a byCreated) Less(i, j int) bool { return a[i].createTime.After(a[j].createTime) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Newest first.
0000000000000000000000000000000000000000;;	type sandboxByCreated []sandboxGCInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a sandboxByCreated) Len() int           { return len(a) }
0000000000000000000000000000000000000000;;	func (a sandboxByCreated) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
0000000000000000000000000000000000000000;;	func (a sandboxByCreated) Less(i, j int) bool { return a[i].createTime.After(a[j].createTime) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// enforceMaxContainersPerEvictUnit enforces MaxPerPodContainer for each evictUnit.
0000000000000000000000000000000000000000;;	func (cgc *containerGC) enforceMaxContainersPerEvictUnit(evictUnits containersByEvictUnit, MaxContainers int) {
0000000000000000000000000000000000000000;;		for key := range evictUnits {
0000000000000000000000000000000000000000;;			toRemove := len(evictUnits[key]) - MaxContainers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if toRemove > 0 {
0000000000000000000000000000000000000000;;				evictUnits[key] = cgc.removeOldestN(evictUnits[key], toRemove)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeOldestN removes the oldest toRemove containers and returns the resulting slice.
0000000000000000000000000000000000000000;;	func (cgc *containerGC) removeOldestN(containers []containerGCInfo, toRemove int) []containerGCInfo {
0000000000000000000000000000000000000000;;		// Remove from oldest to newest (last to first).
0000000000000000000000000000000000000000;;		numToKeep := len(containers) - toRemove
0000000000000000000000000000000000000000;;		for i := len(containers) - 1; i >= numToKeep; i-- {
0000000000000000000000000000000000000000;;			if err := cgc.manager.removeContainer(containers[i].id); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to remove container %q: %v", containers[i].id, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assume we removed the containers so that we're not too aggressive.
0000000000000000000000000000000000000000;;		return containers[:numToKeep]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeOldestNSandboxes removes the oldest inactive toRemove sandboxes and
0000000000000000000000000000000000000000;;	// returns the resulting slice.
0000000000000000000000000000000000000000;;	func (cgc *containerGC) removeOldestNSandboxes(sandboxes []sandboxGCInfo, toRemove int) {
0000000000000000000000000000000000000000;;		// Remove from oldest to newest (last to first).
0000000000000000000000000000000000000000;;		numToKeep := len(sandboxes) - toRemove
0000000000000000000000000000000000000000;;		for i := len(sandboxes) - 1; i >= numToKeep; i-- {
0000000000000000000000000000000000000000;;			if !sandboxes[i].active {
0000000000000000000000000000000000000000;;				cgc.removeSandbox(sandboxes[i].id)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeSandbox removes the sandbox by sandboxID.
0000000000000000000000000000000000000000;;	func (cgc *containerGC) removeSandbox(sandboxID string) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Removing sandbox %q", sandboxID)
0000000000000000000000000000000000000000;;		// In normal cases, kubelet should've already called StopPodSandbox before
0000000000000000000000000000000000000000;;		// GC kicks in. To guard against the rare cases where this is not true, try
0000000000000000000000000000000000000000;;		// stopping the sandbox before removing it.
0000000000000000000000000000000000000000;;		if err := cgc.client.StopPodSandbox(sandboxID); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to stop sandbox %q before removing: %v", sandboxID, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := cgc.client.RemovePodSandbox(sandboxID); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to remove sandbox %q: %v", sandboxID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isPodDeleted returns true if the pod is already deleted.
0000000000000000000000000000000000000000;;	func (cgc *containerGC) isPodDeleted(podUID types.UID) bool {
0000000000000000000000000000000000000000;;		_, found := cgc.podGetter.GetPodByUID(podUID)
0000000000000000000000000000000000000000;;		return !found
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// evictableContainers gets all containers that are evictable. Evictable containers are: not running
0000000000000000000000000000000000000000;;	// and created more than MinAge ago.
0000000000000000000000000000000000000000;;	func (cgc *containerGC) evictableContainers(minAge time.Duration) (containersByEvictUnit, error) {
0000000000000000000000000000000000000000;;		containers, err := cgc.manager.getKubeletContainers(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return containersByEvictUnit{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		evictUnits := make(containersByEvictUnit)
0000000000000000000000000000000000000000;;		newestGCTime := time.Now().Add(-minAge)
0000000000000000000000000000000000000000;;		for _, container := range containers {
0000000000000000000000000000000000000000;;			// Prune out running containers.
0000000000000000000000000000000000000000;;			if container.State == runtimeapi.ContainerState_CONTAINER_RUNNING {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			createdAt := time.Unix(0, container.CreatedAt)
0000000000000000000000000000000000000000;;			if newestGCTime.Before(createdAt) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			labeledInfo := getContainerInfoFromLabels(container.Labels)
0000000000000000000000000000000000000000;;			containerInfo := containerGCInfo{
0000000000000000000000000000000000000000;;				id:         container.Id,
0000000000000000000000000000000000000000;;				name:       container.Metadata.Name,
0000000000000000000000000000000000000000;;				createTime: createdAt,
0000000000000000000000000000000000000000;;				sandboxID:  container.PodSandboxId,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			key := evictUnit{
0000000000000000000000000000000000000000;;				uid:  labeledInfo.PodUID,
0000000000000000000000000000000000000000;;				name: containerInfo.name,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			evictUnits[key] = append(evictUnits[key], containerInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sort the containers by age.
0000000000000000000000000000000000000000;;		for uid := range evictUnits {
0000000000000000000000000000000000000000;;			sort.Sort(byCreated(evictUnits[uid]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return evictUnits, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// evict all containers that are evictable
0000000000000000000000000000000000000000;;	func (cgc *containerGC) evictContainers(gcPolicy kubecontainer.ContainerGCPolicy, allSourcesReady bool, evictNonDeletedPods bool) error {
0000000000000000000000000000000000000000;;		// Separate containers by evict units.
0000000000000000000000000000000000000000;;		evictUnits, err := cgc.evictableContainers(gcPolicy.MinAge)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove deleted pod containers if all sources are ready.
0000000000000000000000000000000000000000;;		if allSourcesReady {
0000000000000000000000000000000000000000;;			for key, unit := range evictUnits {
0000000000000000000000000000000000000000;;				if cgc.isPodDeleted(key.uid) || evictNonDeletedPods {
0000000000000000000000000000000000000000;;					cgc.removeOldestN(unit, len(unit)) // Remove all.
0000000000000000000000000000000000000000;;					delete(evictUnits, key)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Enforce max containers per evict unit.
0000000000000000000000000000000000000000;;		if gcPolicy.MaxPerPodContainer >= 0 {
0000000000000000000000000000000000000000;;			cgc.enforceMaxContainersPerEvictUnit(evictUnits, gcPolicy.MaxPerPodContainer)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Enforce max total number of containers.
0000000000000000000000000000000000000000;;		if gcPolicy.MaxContainers >= 0 && evictUnits.NumContainers() > gcPolicy.MaxContainers {
0000000000000000000000000000000000000000;;			// Leave an equal number of containers per evict unit (min: 1).
0000000000000000000000000000000000000000;;			numContainersPerEvictUnit := gcPolicy.MaxContainers / evictUnits.NumEvictUnits()
0000000000000000000000000000000000000000;;			if numContainersPerEvictUnit < 1 {
0000000000000000000000000000000000000000;;				numContainersPerEvictUnit = 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cgc.enforceMaxContainersPerEvictUnit(evictUnits, numContainersPerEvictUnit)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If we still need to evict, evict oldest first.
0000000000000000000000000000000000000000;;			numContainers := evictUnits.NumContainers()
0000000000000000000000000000000000000000;;			if numContainers > gcPolicy.MaxContainers {
0000000000000000000000000000000000000000;;				flattened := make([]containerGCInfo, 0, numContainers)
0000000000000000000000000000000000000000;;				for key := range evictUnits {
0000000000000000000000000000000000000000;;					flattened = append(flattened, evictUnits[key]...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sort.Sort(byCreated(flattened))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				cgc.removeOldestN(flattened, numContainers-gcPolicy.MaxContainers)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// evictSandboxes remove all evictable sandboxes. An evictable sandbox must
0000000000000000000000000000000000000000;;	// meet the following requirements:
0000000000000000000000000000000000000000;;	//   1. not in ready state
0000000000000000000000000000000000000000;;	//   2. contains no containers.
0000000000000000000000000000000000000000;;	//   3. belong to a non-existent (i.e., already removed) pod, or is not the
0000000000000000000000000000000000000000;;	//      most recently created sandbox for the pod.
0000000000000000000000000000000000000000;;	func (cgc *containerGC) evictSandboxes(evictNonDeletedPods bool) error {
0000000000000000000000000000000000000000;;		containers, err := cgc.manager.getKubeletContainers(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sandboxes, err := cgc.manager.getKubeletSandboxes(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sandboxesByPod := make(sandboxesByPodUID)
0000000000000000000000000000000000000000;;		for _, sandbox := range sandboxes {
0000000000000000000000000000000000000000;;			podUID := types.UID(sandbox.Metadata.Uid)
0000000000000000000000000000000000000000;;			sandboxInfo := sandboxGCInfo{
0000000000000000000000000000000000000000;;				id:         sandbox.Id,
0000000000000000000000000000000000000000;;				createTime: time.Unix(0, sandbox.CreatedAt),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Set ready sandboxes to be active.
0000000000000000000000000000000000000000;;			if sandbox.State == runtimeapi.PodSandboxState_SANDBOX_READY {
0000000000000000000000000000000000000000;;				sandboxInfo.active = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Set sandboxes that still have containers to be active.
0000000000000000000000000000000000000000;;			hasContainers := false
0000000000000000000000000000000000000000;;			sandboxID := sandbox.Id
0000000000000000000000000000000000000000;;			for _, container := range containers {
0000000000000000000000000000000000000000;;				if container.PodSandboxId == sandboxID {
0000000000000000000000000000000000000000;;					hasContainers = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hasContainers {
0000000000000000000000000000000000000000;;				sandboxInfo.active = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			sandboxesByPod[podUID] = append(sandboxesByPod[podUID], sandboxInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sort the sandboxes by age.
0000000000000000000000000000000000000000;;		for uid := range sandboxesByPod {
0000000000000000000000000000000000000000;;			sort.Sort(sandboxByCreated(sandboxesByPod[uid]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for podUID, sandboxes := range sandboxesByPod {
0000000000000000000000000000000000000000;;			if cgc.isPodDeleted(podUID) || evictNonDeletedPods {
0000000000000000000000000000000000000000;;				// Remove all evictable sandboxes if the pod has been removed.
0000000000000000000000000000000000000000;;				// Note that the latest dead sandbox is also removed if there is
0000000000000000000000000000000000000000;;				// already an active one.
0000000000000000000000000000000000000000;;				cgc.removeOldestNSandboxes(sandboxes, len(sandboxes))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Keep latest one if the pod still exists.
0000000000000000000000000000000000000000;;				cgc.removeOldestNSandboxes(sandboxes, len(sandboxes)-1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// evictPodLogsDirectories evicts all evictable pod logs directories. Pod logs directories
0000000000000000000000000000000000000000;;	// are evictable if there are no corresponding pods.
0000000000000000000000000000000000000000;;	func (cgc *containerGC) evictPodLogsDirectories(allSourcesReady bool) error {
0000000000000000000000000000000000000000;;		osInterface := cgc.manager.osInterface
0000000000000000000000000000000000000000;;		if allSourcesReady {
0000000000000000000000000000000000000000;;			// Only remove pod logs directories when all sources are ready.
0000000000000000000000000000000000000000;;			dirs, err := osInterface.ReadDir(podLogsRootDirectory)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to read podLogsRootDirectory %q: %v", podLogsRootDirectory, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, dir := range dirs {
0000000000000000000000000000000000000000;;				name := dir.Name()
0000000000000000000000000000000000000000;;				podUID := types.UID(name)
0000000000000000000000000000000000000000;;				if !cgc.isPodDeleted(podUID) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err := osInterface.RemoveAll(filepath.Join(podLogsRootDirectory, name))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to remove pod logs directory %q: %v", name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove dead container log symlinks.
0000000000000000000000000000000000000000;;		// TODO(random-liu): Remove this after cluster logging supports CRI container log path.
0000000000000000000000000000000000000000;;		logSymlinks, _ := osInterface.Glob(filepath.Join(legacyContainerLogsDir, fmt.Sprintf("*.%s", legacyLogSuffix)))
0000000000000000000000000000000000000000;;		for _, logSymlink := range logSymlinks {
0000000000000000000000000000000000000000;;			if _, err := osInterface.Stat(logSymlink); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				err := osInterface.Remove(logSymlink)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to remove container log dead symlink %q: %v", logSymlink, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GarbageCollect removes dead containers using the specified container gc policy.
0000000000000000000000000000000000000000;;	// Note that gc policy is not applied to sandboxes. Sandboxes are only removed when they are
0000000000000000000000000000000000000000;;	// not ready and containing no containers.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// GarbageCollect consists of the following steps:
0000000000000000000000000000000000000000;;	// * gets evictable containers which are not active and created more than gcPolicy.MinAge ago.
0000000000000000000000000000000000000000;;	// * removes oldest dead containers for each pod by enforcing gcPolicy.MaxPerPodContainer.
0000000000000000000000000000000000000000;;	// * removes oldest dead containers by enforcing gcPolicy.MaxContainers.
0000000000000000000000000000000000000000;;	// * gets evictable sandboxes which are not ready and contains no containers.
0000000000000000000000000000000000000000;;	// * removes evictable sandboxes.
0000000000000000000000000000000000000000;;	func (cgc *containerGC) GarbageCollect(gcPolicy kubecontainer.ContainerGCPolicy, allSourcesReady bool, evictNonDeletedPods bool) error {
0000000000000000000000000000000000000000;;		// Remove evictable containers
0000000000000000000000000000000000000000;;		if err := cgc.evictContainers(gcPolicy, allSourcesReady, evictNonDeletedPods); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove sandboxes with zero containers
0000000000000000000000000000000000000000;;		if err := cgc.evictSandboxes(evictNonDeletedPods); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove pod sandbox log directory
0000000000000000000000000000000000000000;;		return cgc.evictPodLogsDirectories(allSourcesReady)
0000000000000000000000000000000000000000;;	}
