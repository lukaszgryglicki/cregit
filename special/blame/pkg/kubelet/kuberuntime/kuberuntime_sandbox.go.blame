0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f69b7b7816a945a25239b34ea1a2f1ed3a806f76;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kuberuntime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		kubetypes "k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/format"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createPodSandbox creates a pod sandbox and returns (podSandBoxID, message, error).
0000000000000000000000000000000000000000;;	func (m *kubeGenericRuntimeManager) createPodSandbox(pod *v1.Pod, attempt uint32) (string, string, error) {
0000000000000000000000000000000000000000;;		podSandboxConfig, err := m.generatePodSandboxConfig(pod, attempt)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("GeneratePodSandboxConfig for pod %q failed: %v", format.Pod(pod), err)
0000000000000000000000000000000000000000;;			glog.Error(message)
0000000000000000000000000000000000000000;;			return "", message, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create pod logs directory
0000000000000000000000000000000000000000;;		err = m.osInterface.MkdirAll(podSandboxConfig.LogDirectory, 0755)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("Create pod log directory for pod %q failed: %v", format.Pod(pod), err)
0000000000000000000000000000000000000000;;			glog.Errorf(message)
0000000000000000000000000000000000000000;;			return "", message, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podSandBoxID, err := m.runtimeService.RunPodSandbox(podSandboxConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("CreatePodSandbox for pod %q failed: %v", format.Pod(pod), err)
0000000000000000000000000000000000000000;;			glog.Error(message)
0000000000000000000000000000000000000000;;			return "", message, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return podSandBoxID, "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generatePodSandboxConfig generates pod sandbox config from v1.Pod.
0000000000000000000000000000000000000000;;	func (m *kubeGenericRuntimeManager) generatePodSandboxConfig(pod *v1.Pod, attempt uint32) (*runtimeapi.PodSandboxConfig, error) {
0000000000000000000000000000000000000000;;		// TODO: deprecating podsandbox resource requirements in favor of the pod level cgroup
0000000000000000000000000000000000000000;;		// Refer https://github.com/kubernetes/kubernetes/issues/29871
0000000000000000000000000000000000000000;;		podUID := string(pod.UID)
0000000000000000000000000000000000000000;;		podSandboxConfig := &runtimeapi.PodSandboxConfig{
0000000000000000000000000000000000000000;;			Metadata: &runtimeapi.PodSandboxMetadata{
0000000000000000000000000000000000000000;;				Name:      pod.Name,
0000000000000000000000000000000000000000;;				Namespace: pod.Namespace,
0000000000000000000000000000000000000000;;				Uid:       podUID,
0000000000000000000000000000000000000000;;				Attempt:   attempt,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Labels:      newPodLabels(pod),
0000000000000000000000000000000000000000;;			Annotations: newPodAnnotations(pod),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dnsServers, dnsSearches, useClusterFirstPolicy, err := m.runtimeHelper.GetClusterDNS(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podSandboxConfig.DnsConfig = &runtimeapi.DNSConfig{
0000000000000000000000000000000000000000;;			Servers:  dnsServers,
0000000000000000000000000000000000000000;;			Searches: dnsSearches,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if useClusterFirstPolicy {
0000000000000000000000000000000000000000;;			podSandboxConfig.DnsConfig.Options = defaultDNSOptions
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !kubecontainer.IsHostNetworkPod(pod) {
0000000000000000000000000000000000000000;;			// TODO: Add domain support in new runtime interface
0000000000000000000000000000000000000000;;			hostname, _, err := m.runtimeHelper.GeneratePodHostNameAndDomain(pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podSandboxConfig.Hostname = hostname
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logDir := buildPodLogsDirectory(pod.UID)
0000000000000000000000000000000000000000;;		podSandboxConfig.LogDirectory = logDir
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		portMappings := []*runtimeapi.PortMapping{}
0000000000000000000000000000000000000000;;		for _, c := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			containerPortMappings := kubecontainer.MakePortMappings(&c)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for idx := range containerPortMappings {
0000000000000000000000000000000000000000;;				port := containerPortMappings[idx]
0000000000000000000000000000000000000000;;				hostPort := int32(port.HostPort)
0000000000000000000000000000000000000000;;				containerPort := int32(port.ContainerPort)
0000000000000000000000000000000000000000;;				protocol := toRuntimeProtocol(port.Protocol)
0000000000000000000000000000000000000000;;				portMappings = append(portMappings, &runtimeapi.PortMapping{
0000000000000000000000000000000000000000;;					HostIp:        port.HostIP,
0000000000000000000000000000000000000000;;					HostPort:      hostPort,
0000000000000000000000000000000000000000;;					ContainerPort: containerPort,
0000000000000000000000000000000000000000;;					Protocol:      protocol,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(portMappings) > 0 {
0000000000000000000000000000000000000000;;			podSandboxConfig.PortMappings = portMappings
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lc, err := m.generatePodSandboxLinuxConfig(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podSandboxConfig.Linux = lc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return podSandboxConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generatePodSandboxLinuxConfig generates LinuxPodSandboxConfig from v1.Pod.
0000000000000000000000000000000000000000;;	func (m *kubeGenericRuntimeManager) generatePodSandboxLinuxConfig(pod *v1.Pod) (*runtimeapi.LinuxPodSandboxConfig, error) {
0000000000000000000000000000000000000000;;		cgroupParent := m.runtimeHelper.GetPodCgroupParent(pod)
0000000000000000000000000000000000000000;;		lc := &runtimeapi.LinuxPodSandboxConfig{
0000000000000000000000000000000000000000;;			CgroupParent: cgroupParent,
0000000000000000000000000000000000000000;;			SecurityContext: &runtimeapi.LinuxSandboxSecurityContext{
0000000000000000000000000000000000000000;;				Privileged: kubecontainer.HasPrivilegedContainer(pod),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sysctls, err := getSysctlsFromAnnotations(pod.Annotations)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to get sysctls from annotations %v for pod %q: %v", pod.Annotations, format.Pod(pod), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lc.Sysctls = sysctls
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pod.Spec.SecurityContext != nil {
0000000000000000000000000000000000000000;;			sc := pod.Spec.SecurityContext
0000000000000000000000000000000000000000;;			if sc.RunAsUser != nil {
0000000000000000000000000000000000000000;;				lc.SecurityContext.RunAsUser = &runtimeapi.Int64Value{Value: int64(*sc.RunAsUser)}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lc.SecurityContext.NamespaceOptions = &runtimeapi.NamespaceOption{
0000000000000000000000000000000000000000;;				HostNetwork: pod.Spec.HostNetwork,
0000000000000000000000000000000000000000;;				HostIpc:     pod.Spec.HostIPC,
0000000000000000000000000000000000000000;;				HostPid:     pod.Spec.HostPID,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if sc.FSGroup != nil {
0000000000000000000000000000000000000000;;				lc.SecurityContext.SupplementalGroups = append(lc.SecurityContext.SupplementalGroups, int64(*sc.FSGroup))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if groups := m.runtimeHelper.GetExtraSupplementalGroupsForPod(pod); len(groups) > 0 {
0000000000000000000000000000000000000000;;				lc.SecurityContext.SupplementalGroups = append(lc.SecurityContext.SupplementalGroups, groups...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if sc.SupplementalGroups != nil {
0000000000000000000000000000000000000000;;				for _, sg := range sc.SupplementalGroups {
0000000000000000000000000000000000000000;;					lc.SecurityContext.SupplementalGroups = append(lc.SecurityContext.SupplementalGroups, int64(sg))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if sc.SELinuxOptions != nil {
0000000000000000000000000000000000000000;;				lc.SecurityContext.SelinuxOptions = &runtimeapi.SELinuxOption{
0000000000000000000000000000000000000000;;					User:  sc.SELinuxOptions.User,
0000000000000000000000000000000000000000;;					Role:  sc.SELinuxOptions.Role,
0000000000000000000000000000000000000000;;					Type:  sc.SELinuxOptions.Type,
0000000000000000000000000000000000000000;;					Level: sc.SELinuxOptions.Level,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return lc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getKubeletSandboxes lists all (or just the running) sandboxes managed by kubelet.
0000000000000000000000000000000000000000;;	func (m *kubeGenericRuntimeManager) getKubeletSandboxes(all bool) ([]*runtimeapi.PodSandbox, error) {
0000000000000000000000000000000000000000;;		var filter *runtimeapi.PodSandboxFilter
0000000000000000000000000000000000000000;;		if !all {
0000000000000000000000000000000000000000;;			readyState := runtimeapi.PodSandboxState_SANDBOX_READY
0000000000000000000000000000000000000000;;			filter = &runtimeapi.PodSandboxFilter{
0000000000000000000000000000000000000000;;				State: &runtimeapi.PodSandboxStateValue{
0000000000000000000000000000000000000000;;					State: readyState,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := m.runtimeService.ListPodSandbox(filter)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("ListPodSandbox failed: %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// determinePodSandboxIP determines the IP address of the given pod sandbox.
0000000000000000000000000000000000000000;;	func (m *kubeGenericRuntimeManager) determinePodSandboxIP(podNamespace, podName string, podSandbox *runtimeapi.PodSandboxStatus) string {
0000000000000000000000000000000000000000;;		if podSandbox.Network == nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Pod Sandbox status doesn't have network information, cannot report IP")
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ip := podSandbox.Network.Ip
0000000000000000000000000000000000000000;;		if len(ip) != 0 && net.ParseIP(ip) == nil {
0000000000000000000000000000000000000000;;			// ip could be an empty string if runtime is not responsible for the
0000000000000000000000000000000000000000;;			// IP (e.g., host networking).
0000000000000000000000000000000000000000;;			glog.Warningf("Pod Sandbox reported an unparseable IP %v", ip)
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ip
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodSandboxID gets the sandbox id by podUID and returns ([]sandboxID, error).
0000000000000000000000000000000000000000;;	// Param state could be nil in order to get all sandboxes belonging to same pod.
0000000000000000000000000000000000000000;;	func (m *kubeGenericRuntimeManager) getSandboxIDByPodUID(podUID kubetypes.UID, state *runtimeapi.PodSandboxState) ([]string, error) {
0000000000000000000000000000000000000000;;		filter := &runtimeapi.PodSandboxFilter{
0000000000000000000000000000000000000000;;			LabelSelector: map[string]string{types.KubernetesPodUIDLabel: string(podUID)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if state != nil {
0000000000000000000000000000000000000000;;			filter.State = &runtimeapi.PodSandboxStateValue{
0000000000000000000000000000000000000000;;				State: *state,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sandboxes, err := m.runtimeService.ListPodSandbox(filter)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("ListPodSandbox with pod UID %q failed: %v", podUID, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(sandboxes) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sort with newest first.
0000000000000000000000000000000000000000;;		sandboxIDs := make([]string, len(sandboxes))
0000000000000000000000000000000000000000;;		sort.Sort(podSandboxByCreated(sandboxes))
0000000000000000000000000000000000000000;;		for i, s := range sandboxes {
0000000000000000000000000000000000000000;;			sandboxIDs[i] = s.Id
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sandboxIDs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPortForward gets the endpoint the runtime will serve the port-forward request from.
0000000000000000000000000000000000000000;;	func (m *kubeGenericRuntimeManager) GetPortForward(podName, podNamespace string, podUID kubetypes.UID, ports []int32) (*url.URL, error) {
0000000000000000000000000000000000000000;;		sandboxIDs, err := m.getSandboxIDByPodUID(podUID, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to find sandboxID for pod %s: %v", format.PodDesc(podName, podNamespace, podUID), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(sandboxIDs) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to find sandboxID for pod %s", format.PodDesc(podName, podNamespace, podUID))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req := &runtimeapi.PortForwardRequest{
0000000000000000000000000000000000000000;;			PodSandboxId: sandboxIDs[0],
0000000000000000000000000000000000000000;;			Port:         ports,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := m.runtimeService.PortForward(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return url.Parse(resp.Url)
0000000000000000000000000000000000000000;;	}
