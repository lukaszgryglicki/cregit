0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
35ca32ed1a222f91fd13bb434abb76d7550f36c0;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kuberuntime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLogOptions(t *testing.T) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			line         = int64(8)
0000000000000000000000000000000000000000;;			bytes        = int64(64)
0000000000000000000000000000000000000000;;			timestamp    = metav1.Now()
0000000000000000000000000000000000000000;;			sinceseconds = int64(10)
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		for c, test := range []struct {
0000000000000000000000000000000000000000;;			apiOpts *v1.PodLogOptions
0000000000000000000000000000000000000000;;			expect  *logOptions
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{ // empty options
0000000000000000000000000000000000000000;;				apiOpts: &v1.PodLogOptions{},
0000000000000000000000000000000000000000;;				expect:  &logOptions{tail: -1, bytes: -1},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // test tail lines
0000000000000000000000000000000000000000;;				apiOpts: &v1.PodLogOptions{TailLines: &line},
0000000000000000000000000000000000000000;;				expect:  &logOptions{tail: line, bytes: -1},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // test limit bytes
0000000000000000000000000000000000000000;;				apiOpts: &v1.PodLogOptions{LimitBytes: &bytes},
0000000000000000000000000000000000000000;;				expect:  &logOptions{tail: -1, bytes: bytes},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // test since timestamp
0000000000000000000000000000000000000000;;				apiOpts: &v1.PodLogOptions{SinceTime: &timestamp},
0000000000000000000000000000000000000000;;				expect:  &logOptions{tail: -1, bytes: -1, since: timestamp.Time},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // test since seconds
0000000000000000000000000000000000000000;;				apiOpts: &v1.PodLogOptions{SinceSeconds: &sinceseconds},
0000000000000000000000000000000000000000;;				expect:  &logOptions{tail: -1, bytes: -1, since: timestamp.Add(-10 * time.Second)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			t.Logf("TestCase #%d: %+v", c, test)
0000000000000000000000000000000000000000;;			opts := newLogOptions(test.apiOpts, timestamp.Time)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.expect, opts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestParseLog(t *testing.T) {
0000000000000000000000000000000000000000;;		timestamp, err := time.Parse(timeFormat, "2016-10-20T18:39:20.57606443Z")
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		msg := &logMessage{}
0000000000000000000000000000000000000000;;		for c, test := range []struct {
0000000000000000000000000000000000000000;;			line string
0000000000000000000000000000000000000000;;			msg  *logMessage
0000000000000000000000000000000000000000;;			err  bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{ // Docker log format stdout
0000000000000000000000000000000000000000;;				line: `{"log":"docker stdout test log","stream":"stdout","time":"2016-10-20T18:39:20.57606443Z"}` + "\n",
0000000000000000000000000000000000000000;;				msg: &logMessage{
0000000000000000000000000000000000000000;;					timestamp: timestamp,
0000000000000000000000000000000000000000;;					stream:    stdoutType,
0000000000000000000000000000000000000000;;					log:       []byte("docker stdout test log"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // Docker log format stderr
0000000000000000000000000000000000000000;;				line: `{"log":"docker stderr test log","stream":"stderr","time":"2016-10-20T18:39:20.57606443Z"}` + "\n",
0000000000000000000000000000000000000000;;				msg: &logMessage{
0000000000000000000000000000000000000000;;					timestamp: timestamp,
0000000000000000000000000000000000000000;;					stream:    stderrType,
0000000000000000000000000000000000000000;;					log:       []byte("docker stderr test log"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // CRI log format stdout
0000000000000000000000000000000000000000;;				line: "2016-10-20T18:39:20.57606443Z stdout cri stdout test log\n",
0000000000000000000000000000000000000000;;				msg: &logMessage{
0000000000000000000000000000000000000000;;					timestamp: timestamp,
0000000000000000000000000000000000000000;;					stream:    stdoutType,
0000000000000000000000000000000000000000;;					log:       []byte("cri stdout test log\n"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // CRI log format stderr
0000000000000000000000000000000000000000;;				line: "2016-10-20T18:39:20.57606443Z stderr cri stderr test log\n",
0000000000000000000000000000000000000000;;				msg: &logMessage{
0000000000000000000000000000000000000000;;					timestamp: timestamp,
0000000000000000000000000000000000000000;;					stream:    stderrType,
0000000000000000000000000000000000000000;;					log:       []byte("cri stderr test log\n"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // Unsupported Log format
0000000000000000000000000000000000000000;;				line: "unsupported log format test log\n",
0000000000000000000000000000000000000000;;				msg:  &logMessage{},
0000000000000000000000000000000000000000;;				err:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			t.Logf("TestCase #%d: %+v", c, test)
0000000000000000000000000000000000000000;;			parse, err := getParseFunc([]byte(test.line))
0000000000000000000000000000000000000000;;			if test.err {
0000000000000000000000000000000000000000;;				assert.Error(t, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;			err = parse([]byte(test.line), msg)
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.msg, msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWriteLogs(t *testing.T) {
0000000000000000000000000000000000000000;;		timestamp := time.Unix(1234, 4321)
0000000000000000000000000000000000000000;;		log := "abcdefg\n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for c, test := range []struct {
0000000000000000000000000000000000000000;;			stream       streamType
0000000000000000000000000000000000000000;;			since        time.Time
0000000000000000000000000000000000000000;;			timestamp    bool
0000000000000000000000000000000000000000;;			expectStdout string
0000000000000000000000000000000000000000;;			expectStderr string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{ // stderr log
0000000000000000000000000000000000000000;;				stream:       stderrType,
0000000000000000000000000000000000000000;;				expectStderr: log,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // stdout log
0000000000000000000000000000000000000000;;				stream:       stdoutType,
0000000000000000000000000000000000000000;;				expectStdout: log,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // since is after timestamp
0000000000000000000000000000000000000000;;				stream: stdoutType,
0000000000000000000000000000000000000000;;				since:  timestamp.Add(1 * time.Second),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // timestamp enabled
0000000000000000000000000000000000000000;;				stream:       stderrType,
0000000000000000000000000000000000000000;;				timestamp:    true,
0000000000000000000000000000000000000000;;				expectStderr: timestamp.Format(timeFormat) + " " + log,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			t.Logf("TestCase #%d: %+v", c, test)
0000000000000000000000000000000000000000;;			msg := &logMessage{
0000000000000000000000000000000000000000;;				timestamp: timestamp,
0000000000000000000000000000000000000000;;				stream:    test.stream,
0000000000000000000000000000000000000000;;				log:       []byte(log),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			stdoutBuf := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;			stderrBuf := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;			w := newLogWriter(stdoutBuf, stderrBuf, &logOptions{since: test.since, timestamp: test.timestamp, bytes: -1})
0000000000000000000000000000000000000000;;			err := w.write(msg)
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.expectStdout, stdoutBuf.String())
0000000000000000000000000000000000000000;;			assert.Equal(t, test.expectStderr, stderrBuf.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWriteLogsWithBytesLimit(t *testing.T) {
0000000000000000000000000000000000000000;;		timestamp := time.Unix(1234, 4321)
0000000000000000000000000000000000000000;;		timestampStr := timestamp.Format(timeFormat)
0000000000000000000000000000000000000000;;		log := "abcdefg\n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for c, test := range []struct {
0000000000000000000000000000000000000000;;			stdoutLines  int
0000000000000000000000000000000000000000;;			stderrLines  int
0000000000000000000000000000000000000000;;			bytes        int
0000000000000000000000000000000000000000;;			timestamp    bool
0000000000000000000000000000000000000000;;			expectStdout string
0000000000000000000000000000000000000000;;			expectStderr string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{ // limit bytes less than one line
0000000000000000000000000000000000000000;;				stdoutLines:  3,
0000000000000000000000000000000000000000;;				bytes:        3,
0000000000000000000000000000000000000000;;				expectStdout: "abc",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // limit bytes across lines
0000000000000000000000000000000000000000;;				stdoutLines:  3,
0000000000000000000000000000000000000000;;				bytes:        len(log) + 3,
0000000000000000000000000000000000000000;;				expectStdout: "abcdefg\nabc",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // limit bytes more than all lines
0000000000000000000000000000000000000000;;				stdoutLines:  3,
0000000000000000000000000000000000000000;;				bytes:        3 * len(log),
0000000000000000000000000000000000000000;;				expectStdout: "abcdefg\nabcdefg\nabcdefg\n",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // limit bytes for stderr
0000000000000000000000000000000000000000;;				stderrLines:  3,
0000000000000000000000000000000000000000;;				bytes:        len(log) + 3,
0000000000000000000000000000000000000000;;				expectStderr: "abcdefg\nabc",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // limit bytes for both stdout and stderr, stdout first.
0000000000000000000000000000000000000000;;				stdoutLines:  1,
0000000000000000000000000000000000000000;;				stderrLines:  2,
0000000000000000000000000000000000000000;;				bytes:        len(log) + 3,
0000000000000000000000000000000000000000;;				expectStdout: "abcdefg\n",
0000000000000000000000000000000000000000;;				expectStderr: "abc",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // limit bytes with timestamp
0000000000000000000000000000000000000000;;				stdoutLines:  3,
0000000000000000000000000000000000000000;;				timestamp:    true,
0000000000000000000000000000000000000000;;				bytes:        len(timestampStr) + 1 + len(log) + 2,
0000000000000000000000000000000000000000;;				expectStdout: timestampStr + " " + log + timestampStr[:2],
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			t.Logf("TestCase #%d: %+v", c, test)
0000000000000000000000000000000000000000;;			msg := &logMessage{
0000000000000000000000000000000000000000;;				timestamp: timestamp,
0000000000000000000000000000000000000000;;				log:       []byte(log),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			stdoutBuf := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;			stderrBuf := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;			w := newLogWriter(stdoutBuf, stderrBuf, &logOptions{timestamp: test.timestamp, bytes: int64(test.bytes)})
0000000000000000000000000000000000000000;;			for i := 0; i < test.stdoutLines; i++ {
0000000000000000000000000000000000000000;;				msg.stream = stdoutType
0000000000000000000000000000000000000000;;				if err := w.write(msg); err != nil {
0000000000000000000000000000000000000000;;					assert.EqualError(t, err, errMaximumWrite.Error())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := 0; i < test.stderrLines; i++ {
0000000000000000000000000000000000000000;;				msg.stream = stderrType
0000000000000000000000000000000000000000;;				if err := w.write(msg); err != nil {
0000000000000000000000000000000000000000;;					assert.EqualError(t, err, errMaximumWrite.Error())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			assert.Equal(t, test.expectStdout, stdoutBuf.String())
0000000000000000000000000000000000000000;;			assert.Equal(t, test.expectStderr, stderrBuf.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
