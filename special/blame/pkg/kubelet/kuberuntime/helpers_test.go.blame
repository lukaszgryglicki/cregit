0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6980a9343bca7dd69f1b1a48c07924d0a2f5bae0;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kuberuntime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		runtimetesting "k8s.io/kubernetes/pkg/kubelet/apis/cri/testing"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStableKey(t *testing.T) {
0000000000000000000000000000000000000000;;		container := &v1.Container{
0000000000000000000000000000000000000000;;			Name:  "test_container",
0000000000000000000000000000000000000000;;			Image: "foo/image:v1",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "test_pod",
0000000000000000000000000000000000000000;;				Namespace: "test_pod_namespace",
0000000000000000000000000000000000000000;;				UID:       "test_pod_uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{*container},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldKey := getStableKey(pod, container)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Updating the container image should change the key.
0000000000000000000000000000000000000000;;		container.Image = "foo/image:v2"
0000000000000000000000000000000000000000;;		newKey := getStableKey(pod, container)
0000000000000000000000000000000000000000;;		assert.NotEqual(t, oldKey, newKey)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestGetSystclsFromAnnotations tests the logic of getting sysctls from annotations.
0000000000000000000000000000000000000000;;	func TestGetSystclsFromAnnotations(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			annotations     map[string]string
0000000000000000000000000000000000000000;;			expectedSysctls map[string]string
0000000000000000000000000000000000000000;;		}{{
0000000000000000000000000000000000000000;;			annotations: map[string]string{
0000000000000000000000000000000000000000;;				v1.SysctlsPodAnnotationKey:       "kernel.shmmni=32768,kernel.shmmax=1000000000",
0000000000000000000000000000000000000000;;				v1.UnsafeSysctlsPodAnnotationKey: "knet.ipv4.route.min_pmtu=1000",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedSysctls: map[string]string{
0000000000000000000000000000000000000000;;				"kernel.shmmni":            "32768",
0000000000000000000000000000000000000000;;				"kernel.shmmax":            "1000000000",
0000000000000000000000000000000000000000;;				"knet.ipv4.route.min_pmtu": "1000",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			annotations: map[string]string{
0000000000000000000000000000000000000000;;				v1.SysctlsPodAnnotationKey: "kernel.shmmni=32768,kernel.shmmax=1000000000",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedSysctls: map[string]string{
0000000000000000000000000000000000000000;;				"kernel.shmmni": "32768",
0000000000000000000000000000000000000000;;				"kernel.shmmax": "1000000000",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			annotations: map[string]string{
0000000000000000000000000000000000000000;;				v1.UnsafeSysctlsPodAnnotationKey: "knet.ipv4.route.min_pmtu=1000",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedSysctls: map[string]string{
0000000000000000000000000000000000000000;;				"knet.ipv4.route.min_pmtu": "1000",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			actualSysctls, err := getSysctlsFromAnnotations(test.annotations)
0000000000000000000000000000000000000000;;			assert.NoError(t, err, "TestCase[%d]", i)
0000000000000000000000000000000000000000;;			assert.Len(t, actualSysctls, len(test.expectedSysctls), "TestCase[%d]", i)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.expectedSysctls, actualSysctls, "TestCase[%d]", i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestToKubeContainer(t *testing.T) {
0000000000000000000000000000000000000000;;		c := &runtimeapi.Container{
0000000000000000000000000000000000000000;;			Id: "test-id",
0000000000000000000000000000000000000000;;			Metadata: &runtimeapi.ContainerMetadata{
0000000000000000000000000000000000000000;;				Name:    "test-name",
0000000000000000000000000000000000000000;;				Attempt: 1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Image:    &runtimeapi.ImageSpec{Image: "test-image"},
0000000000000000000000000000000000000000;;			ImageRef: "test-image-ref",
0000000000000000000000000000000000000000;;			State:    runtimeapi.ContainerState_CONTAINER_RUNNING,
0000000000000000000000000000000000000000;;			Annotations: map[string]string{
0000000000000000000000000000000000000000;;				containerHashLabel: "1234",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expect := &kubecontainer.Container{
0000000000000000000000000000000000000000;;			ID: kubecontainer.ContainerID{
0000000000000000000000000000000000000000;;				Type: runtimetesting.FakeRuntimeName,
0000000000000000000000000000000000000000;;				ID:   "test-id",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Name:    "test-name",
0000000000000000000000000000000000000000;;			ImageID: "test-image-ref",
0000000000000000000000000000000000000000;;			Image:   "test-image",
0000000000000000000000000000000000000000;;			Hash:    uint64(0x1234),
0000000000000000000000000000000000000000;;			State:   kubecontainer.ContainerStateRunning,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, _, m, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		got, err := m.toKubeContainer(c)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, expect, got)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetImageUser(t *testing.T) {
0000000000000000000000000000000000000000;;		_, i, m, err := createTestRuntimeManager()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type image struct {
0000000000000000000000000000000000000000;;			name     string
0000000000000000000000000000000000000000;;			uid      *runtimeapi.Int64Value
0000000000000000000000000000000000000000;;			username string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type imageUserValues struct {
0000000000000000000000000000000000000000;;			// getImageUser can return (*int64)(nil) so comparing with *uid will break
0000000000000000000000000000000000000000;;			// type cannot be *int64 as Golang does not allow to take the address of a numeric constant"
0000000000000000000000000000000000000000;;			uid      interface{}
0000000000000000000000000000000000000000;;			username string
0000000000000000000000000000000000000000;;			err      error
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			description             string
0000000000000000000000000000000000000000;;			originalImage           image
0000000000000000000000000000000000000000;;			expectedImageUserValues imageUserValues
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"image without username and uid should return (new(int64), \"\", nil)",
0000000000000000000000000000000000000000;;				image{
0000000000000000000000000000000000000000;;					name:     "test-image-ref1",
0000000000000000000000000000000000000000;;					uid:      (*runtimeapi.Int64Value)(nil),
0000000000000000000000000000000000000000;;					username: "",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				imageUserValues{
0000000000000000000000000000000000000000;;					uid:      int64(0),
0000000000000000000000000000000000000000;;					username: "",
0000000000000000000000000000000000000000;;					err:      nil,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"image with username and no uid should return ((*int64)nil, imageStatus.Username, nil)",
0000000000000000000000000000000000000000;;				image{
0000000000000000000000000000000000000000;;					name:     "test-image-ref2",
0000000000000000000000000000000000000000;;					uid:      (*runtimeapi.Int64Value)(nil),
0000000000000000000000000000000000000000;;					username: "testUser",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				imageUserValues{
0000000000000000000000000000000000000000;;					uid:      (*int64)(nil),
0000000000000000000000000000000000000000;;					username: "testUser",
0000000000000000000000000000000000000000;;					err:      nil,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"image with uid should return (*int64, \"\", nil)",
0000000000000000000000000000000000000000;;				image{
0000000000000000000000000000000000000000;;					name: "test-image-ref3",
0000000000000000000000000000000000000000;;					uid: &runtimeapi.Int64Value{
0000000000000000000000000000000000000000;;						Value: 2,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					username: "whatever",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				imageUserValues{
0000000000000000000000000000000000000000;;					uid:      int64(2),
0000000000000000000000000000000000000000;;					username: "",
0000000000000000000000000000000000000000;;					err:      nil,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i.SetFakeImages([]string{"test-image-ref1", "test-image-ref2", "test-image-ref3"})
0000000000000000000000000000000000000000;;		for j, test := range tests {
0000000000000000000000000000000000000000;;			i.Images[test.originalImage.name].Username = test.originalImage.username
0000000000000000000000000000000000000000;;			i.Images[test.originalImage.name].Uid = test.originalImage.uid
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			uid, username, error := m.getImageUser(test.originalImage.name)
0000000000000000000000000000000000000000;;			assert.NoError(t, error, "TestCase[%d]", j)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.expectedImageUserValues.uid == (*int64)(nil) {
0000000000000000000000000000000000000000;;				assert.Equal(t, test.expectedImageUserValues.uid, uid, "TestCase[%d]", j)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				assert.Equal(t, test.expectedImageUserValues.uid, *uid, "TestCase[%d]", j)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			assert.Equal(t, test.expectedImageUserValues.username, username, "TestCase[%d]", j)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
