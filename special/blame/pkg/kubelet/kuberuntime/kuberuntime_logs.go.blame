0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
71f8a97e65110ad8ea45f110ed575f3397e2329b;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kuberuntime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/docker/pkg/jsonlog"
0000000000000000000000000000000000000000;;		"github.com/fsnotify/fsnotify"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/tail"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Notice that the current kuberuntime logs implementation doesn't handle
0000000000000000000000000000000000000000;;	// log rotation.
0000000000000000000000000000000000000000;;	// * It will not retrieve logs in rotated log file.
0000000000000000000000000000000000000000;;	// * If log rotation happens when following the log:
0000000000000000000000000000000000000000;;	//   * If the rotation is using create mode, we'll still follow the old file.
0000000000000000000000000000000000000000;;	//   * If the rotation is using copytruncate, we'll be reading at the original position and get nothing.
0000000000000000000000000000000000000000;;	// TODO(random-liu): Support log rotation.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// streamType is the type of the stream.
0000000000000000000000000000000000000000;;	type streamType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		stderrType streamType = "stderr"
0000000000000000000000000000000000000000;;		stdoutType streamType = "stdout"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// timeFormat is the time format used in the log.
0000000000000000000000000000000000000000;;		timeFormat = time.RFC3339Nano
0000000000000000000000000000000000000000;;		// blockSize is the block size used in tail.
0000000000000000000000000000000000000000;;		blockSize = 1024
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// stateCheckPeriod is the period to check container state while following
0000000000000000000000000000000000000000;;		// the container log. Kubelet should not keep following the log when the
0000000000000000000000000000000000000000;;		// container is not running.
0000000000000000000000000000000000000000;;		stateCheckPeriod = 5 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// eol is the end-of-line sign in the log.
0000000000000000000000000000000000000000;;		eol = []byte{'\n'}
0000000000000000000000000000000000000000;;		// delimiter is the delimiter for timestamp and streamtype in log line.
0000000000000000000000000000000000000000;;		delimiter = []byte{' '}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// logMessage is the internal log type.
0000000000000000000000000000000000000000;;	type logMessage struct {
0000000000000000000000000000000000000000;;		timestamp time.Time
0000000000000000000000000000000000000000;;		stream    streamType
0000000000000000000000000000000000000000;;		log       []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reset resets the log to nil.
0000000000000000000000000000000000000000;;	func (l *logMessage) reset() {
0000000000000000000000000000000000000000;;		l.timestamp = time.Time{}
0000000000000000000000000000000000000000;;		l.stream = ""
0000000000000000000000000000000000000000;;		l.log = nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// logOptions is the internal type of all log options.
0000000000000000000000000000000000000000;;	type logOptions struct {
0000000000000000000000000000000000000000;;		tail      int64
0000000000000000000000000000000000000000;;		bytes     int64
0000000000000000000000000000000000000000;;		since     time.Time
0000000000000000000000000000000000000000;;		follow    bool
0000000000000000000000000000000000000000;;		timestamp bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newLogOptions convert the v1.PodLogOptions to internal logOptions.
0000000000000000000000000000000000000000;;	func newLogOptions(apiOpts *v1.PodLogOptions, now time.Time) *logOptions {
0000000000000000000000000000000000000000;;		opts := &logOptions{
0000000000000000000000000000000000000000;;			tail:      -1, // -1 by default which means read all logs.
0000000000000000000000000000000000000000;;			bytes:     -1, // -1 by default which means read all logs.
0000000000000000000000000000000000000000;;			follow:    apiOpts.Follow,
0000000000000000000000000000000000000000;;			timestamp: apiOpts.Timestamps,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if apiOpts.TailLines != nil {
0000000000000000000000000000000000000000;;			opts.tail = *apiOpts.TailLines
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if apiOpts.LimitBytes != nil {
0000000000000000000000000000000000000000;;			opts.bytes = *apiOpts.LimitBytes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if apiOpts.SinceSeconds != nil {
0000000000000000000000000000000000000000;;			opts.since = now.Add(-time.Duration(*apiOpts.SinceSeconds) * time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if apiOpts.SinceTime != nil && apiOpts.SinceTime.After(opts.since) {
0000000000000000000000000000000000000000;;			opts.since = apiOpts.SinceTime.Time
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return opts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadLogs read the container log and redirect into stdout and stderr.
0000000000000000000000000000000000000000;;	// Note that containerID is only needed when following the log, or else
0000000000000000000000000000000000000000;;	// just pass in empty string "".
0000000000000000000000000000000000000000;;	func (m *kubeGenericRuntimeManager) ReadLogs(path, containerID string, apiOpts *v1.PodLogOptions, stdout, stderr io.Writer) error {
0000000000000000000000000000000000000000;;		f, err := os.Open(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to open log file %q: %v", path, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert v1.PodLogOptions into internal log options.
0000000000000000000000000000000000000000;;		opts := newLogOptions(apiOpts, time.Now())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Search start point based on tail line.
0000000000000000000000000000000000000000;;		start, err := tail.FindTailLineStartIndex(f, opts.tail)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to tail %d lines of log file %q: %v", opts.tail, path, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := f.Seek(start, os.SEEK_SET); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to seek %d in log file %q: %v", start, path, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start parsing the logs.
0000000000000000000000000000000000000000;;		r := bufio.NewReader(f)
0000000000000000000000000000000000000000;;		// Do not create watcher here because it is not needed if `Follow` is false.
0000000000000000000000000000000000000000;;		var watcher *fsnotify.Watcher
0000000000000000000000000000000000000000;;		var parse parseFunc
0000000000000000000000000000000000000000;;		writer := newLogWriter(stdout, stderr, opts)
0000000000000000000000000000000000000000;;		msg := &logMessage{}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			l, err := r.ReadBytes(eol[0])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err != io.EOF { // This is an real error
0000000000000000000000000000000000000000;;					return fmt.Errorf("failed to read log file %q: %v", path, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !opts.follow {
0000000000000000000000000000000000000000;;					// Return directly when reading to the end if not follow.
0000000000000000000000000000000000000000;;					if len(l) > 0 {
0000000000000000000000000000000000000000;;						glog.Warningf("Incomplete line in log file %q: %q", path, l)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					glog.V(2).Infof("Finish parsing log file %q", path)
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Reset seek so that if this is an incomplete line,
0000000000000000000000000000000000000000;;				// it will be read again.
0000000000000000000000000000000000000000;;				if _, err := f.Seek(-int64(len(l)), os.SEEK_CUR); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("failed to reset seek in log file %q: %v", path, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if watcher == nil {
0000000000000000000000000000000000000000;;					// Intialize the watcher if it has not been initialized yet.
0000000000000000000000000000000000000000;;					if watcher, err = fsnotify.NewWatcher(); err != nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("failed to create fsnotify watcher: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					defer watcher.Close()
0000000000000000000000000000000000000000;;					if err := watcher.Add(f.Name()); err != nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("failed to watch file %q: %v", f.Name(), err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Wait until the next log change.
0000000000000000000000000000000000000000;;				if found, err := m.waitLogs(containerID, watcher); !found {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if parse == nil {
0000000000000000000000000000000000000000;;				// Intialize the log parsing function.
0000000000000000000000000000000000000000;;				parse, err = getParseFunc(l)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("failed to get parse function: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Parse the log line.
0000000000000000000000000000000000000000;;			msg.reset()
0000000000000000000000000000000000000000;;			if err := parse(l, msg); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed with err %v when parsing log for log file %q: %q", err, path, l)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Write the log line into the stream.
0000000000000000000000000000000000000000;;			if err := writer.write(msg); err != nil {
0000000000000000000000000000000000000000;;				if err == errMaximumWrite {
0000000000000000000000000000000000000000;;					glog.V(2).Infof("Finish parsing log file %q, hit bytes limit %d(bytes)", path, opts.bytes)
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.Errorf("Failed with err %v when writing log for log file %q: %+v", err, path, msg)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitLogs wait for the next log write. It returns a boolean and an error. The boolean
0000000000000000000000000000000000000000;;	// indicates whether a new log is found; the error is error happens during waiting new logs.
0000000000000000000000000000000000000000;;	func (m *kubeGenericRuntimeManager) waitLogs(id string, w *fsnotify.Watcher) (bool, error) {
0000000000000000000000000000000000000000;;		errRetry := 5
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case e := <-w.Events:
0000000000000000000000000000000000000000;;				switch e.Op {
0000000000000000000000000000000000000000;;				case fsnotify.Write:
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					glog.Errorf("Unexpected fsnotify event: %v, retrying...", e)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case err := <-w.Errors:
0000000000000000000000000000000000000000;;				glog.Errorf("Fsnotify watch error: %v, %d error retries remaining", err, errRetry)
0000000000000000000000000000000000000000;;				if errRetry == 0 {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				errRetry--
0000000000000000000000000000000000000000;;			case <-time.After(stateCheckPeriod):
0000000000000000000000000000000000000000;;				s, err := m.runtimeService.ContainerStatus(id)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Only keep following container log when it is running.
0000000000000000000000000000000000000000;;				if s.State != runtimeapi.ContainerState_CONTAINER_RUNNING {
0000000000000000000000000000000000000000;;					glog.Errorf("Container %q is not running (state=%q)", id, s.State)
0000000000000000000000000000000000000000;;					// Do not return error because it's normal that the container stops
0000000000000000000000000000000000000000;;					// during waiting.
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseFunc is a function parsing one log line to the internal log type.
0000000000000000000000000000000000000000;;	// Notice that the caller must make sure logMessage is not nil.
0000000000000000000000000000000000000000;;	type parseFunc func([]byte, *logMessage) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var parseFuncs []parseFunc = []parseFunc{
0000000000000000000000000000000000000000;;		parseCRILog,        // CRI log format parse function
0000000000000000000000000000000000000000;;		parseDockerJSONLog, // Docker JSON log format parse function
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseCRILog parses logs in CRI log format. CRI Log format example:
0000000000000000000000000000000000000000;;	//   2016-10-06T00:17:09.669794202Z stdout log content 1
0000000000000000000000000000000000000000;;	//   2016-10-06T00:17:09.669794203Z stderr log content 2
0000000000000000000000000000000000000000;;	func parseCRILog(log []byte, msg *logMessage) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		// Parse timestamp
0000000000000000000000000000000000000000;;		idx := bytes.Index(log, delimiter)
0000000000000000000000000000000000000000;;		if idx < 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("timestamp is not found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg.timestamp, err = time.Parse(timeFormat, string(log[:idx]))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected timestamp format %q: %v", timeFormat, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Parse stream type
0000000000000000000000000000000000000000;;		log = log[idx+1:]
0000000000000000000000000000000000000000;;		idx = bytes.Index(log, delimiter)
0000000000000000000000000000000000000000;;		if idx < 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("stream type is not found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg.stream = streamType(log[:idx])
0000000000000000000000000000000000000000;;		if msg.stream != stdoutType && msg.stream != stderrType {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected stream type %q", msg.stream)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get log content
0000000000000000000000000000000000000000;;		msg.log = log[idx+1:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dockerJSONLog is the JSON log buffer used in parseDockerJSONLog.
0000000000000000000000000000000000000000;;	var dockerJSONLog = &jsonlog.JSONLog{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseDockerJSONLog parses logs in Docker JSON log format. Docker JSON log format
0000000000000000000000000000000000000000;;	// example:
0000000000000000000000000000000000000000;;	//   {"log":"content 1","stream":"stdout","time":"2016-10-20T18:39:20.57606443Z"}
0000000000000000000000000000000000000000;;	//   {"log":"content 2","stream":"stderr","time":"2016-10-20T18:39:20.57606444Z"}
0000000000000000000000000000000000000000;;	func parseDockerJSONLog(log []byte, msg *logMessage) error {
0000000000000000000000000000000000000000;;		dockerJSONLog.Reset()
0000000000000000000000000000000000000000;;		l := dockerJSONLog
0000000000000000000000000000000000000000;;		// TODO: JSON decoding is fairly expensive, we should evaluate this.
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(log, l); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed with %v to unmarshal log %q", err, l)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg.timestamp = l.Created
0000000000000000000000000000000000000000;;		msg.stream = streamType(l.Stream)
0000000000000000000000000000000000000000;;		msg.log = []byte(l.Log)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getParseFunc returns proper parse function based on the sample log line passed in.
0000000000000000000000000000000000000000;;	func getParseFunc(log []byte) (parseFunc, error) {
0000000000000000000000000000000000000000;;		for _, p := range parseFuncs {
0000000000000000000000000000000000000000;;			if err := p(log, &logMessage{}); err == nil {
0000000000000000000000000000000000000000;;				return p, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("unsupported log format: %q", log)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// logWriter controls the writing into the stream based on the log options.
0000000000000000000000000000000000000000;;	type logWriter struct {
0000000000000000000000000000000000000000;;		stdout io.Writer
0000000000000000000000000000000000000000;;		stderr io.Writer
0000000000000000000000000000000000000000;;		opts   *logOptions
0000000000000000000000000000000000000000;;		remain int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errMaximumWrite is returned when all bytes have been written.
0000000000000000000000000000000000000000;;	var errMaximumWrite = errors.New("maximum write")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errShortWrite is returned when the message is not fully written.
0000000000000000000000000000000000000000;;	var errShortWrite = errors.New("short write")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newLogWriter(stdout io.Writer, stderr io.Writer, opts *logOptions) *logWriter {
0000000000000000000000000000000000000000;;		w := &logWriter{
0000000000000000000000000000000000000000;;			stdout: stdout,
0000000000000000000000000000000000000000;;			stderr: stderr,
0000000000000000000000000000000000000000;;			opts:   opts,
0000000000000000000000000000000000000000;;			remain: math.MaxInt64, // initialize it as infinity
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.bytes >= 0 {
0000000000000000000000000000000000000000;;			w.remain = opts.bytes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeLogs writes logs into stdout, stderr.
0000000000000000000000000000000000000000;;	func (w *logWriter) write(msg *logMessage) error {
0000000000000000000000000000000000000000;;		if msg.timestamp.Before(w.opts.since) {
0000000000000000000000000000000000000000;;			// Skip the line because it's older than since
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		line := msg.log
0000000000000000000000000000000000000000;;		if w.opts.timestamp {
0000000000000000000000000000000000000000;;			prefix := append([]byte(msg.timestamp.Format(timeFormat)), delimiter[0])
0000000000000000000000000000000000000000;;			line = append(prefix, line...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If the line is longer than the remaining bytes, cut it.
0000000000000000000000000000000000000000;;		if int64(len(line)) > w.remain {
0000000000000000000000000000000000000000;;			line = line[:w.remain]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Get the proper stream to write to.
0000000000000000000000000000000000000000;;		var stream io.Writer
0000000000000000000000000000000000000000;;		switch msg.stream {
0000000000000000000000000000000000000000;;		case stdoutType:
0000000000000000000000000000000000000000;;			stream = w.stdout
0000000000000000000000000000000000000000;;		case stderrType:
0000000000000000000000000000000000000000;;			stream = w.stderr
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected stream type %q", msg.stream)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err := stream.Write(line)
0000000000000000000000000000000000000000;;		w.remain -= int64(n)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If the line has not been fully written, return errShortWrite
0000000000000000000000000000000000000000;;		if n < len(line) {
0000000000000000000000000000000000000000;;			return errShortWrite
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If there are no more bytes left, return errMaximumWrite
0000000000000000000000000000000000000000;;		if w.remain <= 0 {
0000000000000000000000000000000000000000;;			return errMaximumWrite
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
