0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
5464e5a5d7a8fd40e9826bae7a1dc78c936c2109;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kuberuntime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/credentialprovider"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/parsers"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PullImage pulls an image from the network to local storage using the supplied
0000000000000000000000000000000000000000;;	// secrets if necessary.
0000000000000000000000000000000000000000;;	func (m *kubeGenericRuntimeManager) PullImage(image kubecontainer.ImageSpec, pullSecrets []v1.Secret) (string, error) {
0000000000000000000000000000000000000000;;		img := image.Image
0000000000000000000000000000000000000000;;		repoToPull, _, _, err := parsers.ParseImageName(img)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyring, err := credentialprovider.MakeDockerKeyring(pullSecrets, m.keyring)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		imgSpec := &runtimeapi.ImageSpec{Image: img}
0000000000000000000000000000000000000000;;		creds, withCredentials := keyring.Lookup(repoToPull)
0000000000000000000000000000000000000000;;		if !withCredentials {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Pulling image %q without credentials", img)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			imageRef, err := m.imageService.PullImage(imgSpec, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Pull image %q failed: %v", img, err)
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return imageRef, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var pullErrs []error
0000000000000000000000000000000000000000;;		for _, currentCreds := range creds {
0000000000000000000000000000000000000000;;			authConfig := credentialprovider.LazyProvide(currentCreds)
0000000000000000000000000000000000000000;;			auth := &runtimeapi.AuthConfig{
0000000000000000000000000000000000000000;;				Username:      authConfig.Username,
0000000000000000000000000000000000000000;;				Password:      authConfig.Password,
0000000000000000000000000000000000000000;;				Auth:          authConfig.Auth,
0000000000000000000000000000000000000000;;				ServerAddress: authConfig.ServerAddress,
0000000000000000000000000000000000000000;;				IdentityToken: authConfig.IdentityToken,
0000000000000000000000000000000000000000;;				RegistryToken: authConfig.RegistryToken,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			imageRef, err := m.imageService.PullImage(imgSpec, auth)
0000000000000000000000000000000000000000;;			// If there was no error, return success
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return imageRef, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pullErrs = append(pullErrs, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", utilerrors.NewAggregate(pullErrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetImageRef gets the reference (digest or ID) of the image which has already been in
0000000000000000000000000000000000000000;;	// the local storage. It returns ("", nil) if the image isn't in the local storage.
0000000000000000000000000000000000000000;;	func (m *kubeGenericRuntimeManager) GetImageRef(image kubecontainer.ImageSpec) (string, error) {
0000000000000000000000000000000000000000;;		status, err := m.imageService.ImageStatus(&runtimeapi.ImageSpec{Image: image.Image})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("ImageStatus for image %q failed: %v", image, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if status == nil {
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		imageRef := status.Id
0000000000000000000000000000000000000000;;		if len(status.RepoDigests) > 0 {
0000000000000000000000000000000000000000;;			imageRef = status.RepoDigests[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return imageRef, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListImages gets all images currently on the machine.
0000000000000000000000000000000000000000;;	func (m *kubeGenericRuntimeManager) ListImages() ([]kubecontainer.Image, error) {
0000000000000000000000000000000000000000;;		var images []kubecontainer.Image
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allImages, err := m.imageService.ListImages(nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("ListImages failed: %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, img := range allImages {
0000000000000000000000000000000000000000;;			images = append(images, kubecontainer.Image{
0000000000000000000000000000000000000000;;				ID:          img.Id,
0000000000000000000000000000000000000000;;				Size:        int64(img.Size_),
0000000000000000000000000000000000000000;;				RepoTags:    img.RepoTags,
0000000000000000000000000000000000000000;;				RepoDigests: img.RepoDigests,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return images, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveImage removes the specified image.
0000000000000000000000000000000000000000;;	func (m *kubeGenericRuntimeManager) RemoveImage(image kubecontainer.ImageSpec) error {
0000000000000000000000000000000000000000;;		err := m.imageService.RemoveImage(&runtimeapi.ImageSpec{Image: image.Image})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Remove image %q failed: %v", image.Image, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ImageStats returns the statistics of the image.
0000000000000000000000000000000000000000;;	// Notice that current logic doesn't really work for images which share layers (e.g. docker image),
0000000000000000000000000000000000000000;;	// this is a known issue, and we'll address this by getting imagefs stats directly from CRI.
0000000000000000000000000000000000000000;;	// TODO: Get imagefs stats directly from CRI.
0000000000000000000000000000000000000000;;	func (m *kubeGenericRuntimeManager) ImageStats() (*kubecontainer.ImageStats, error) {
0000000000000000000000000000000000000000;;		allImages, err := m.imageService.ListImages(nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("ListImages failed: %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stats := &kubecontainer.ImageStats{}
0000000000000000000000000000000000000000;;		for _, img := range allImages {
0000000000000000000000000000000000000000;;			stats.TotalStorageBytes += img.Size_
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stats, nil
0000000000000000000000000000000000000000;;	}
