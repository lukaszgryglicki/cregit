0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6f17536982a8fef52fe380a9b2950a07d4360ff3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/capabilities"
0000000000000000000000000000000000000000;;		kubetypes "k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/securitycontext"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check whether we have the capabilities to run the specified pod.
0000000000000000000000000000000000000000;;	func canRunPod(pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		if !capabilities.Get().AllowPrivileged {
0000000000000000000000000000000000000000;;			for _, container := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;				if securitycontext.HasPrivilegedRequest(&container) {
0000000000000000000000000000000000000000;;					return fmt.Errorf("pod with UID %q specified privileged container, but is disallowed", pod.UID)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, container := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;				if securitycontext.HasPrivilegedRequest(&container) {
0000000000000000000000000000000000000000;;					return fmt.Errorf("pod with UID %q specified privileged init container, but is disallowed", pod.UID)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pod.Spec.HostNetwork {
0000000000000000000000000000000000000000;;			allowed, err := allowHostNetwork(pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !allowed {
0000000000000000000000000000000000000000;;				return fmt.Errorf("pod with UID %q specified host networking, but is disallowed", pod.UID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pod.Spec.HostPID {
0000000000000000000000000000000000000000;;			allowed, err := allowHostPID(pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !allowed {
0000000000000000000000000000000000000000;;				return fmt.Errorf("pod with UID %q specified host PID, but is disallowed", pod.UID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pod.Spec.HostIPC {
0000000000000000000000000000000000000000;;			allowed, err := allowHostIPC(pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !allowed {
0000000000000000000000000000000000000000;;				return fmt.Errorf("pod with UID %q specified host ipc, but is disallowed", pod.UID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Determined whether the specified pod is allowed to use host networking
0000000000000000000000000000000000000000;;	func allowHostNetwork(pod *v1.Pod) (bool, error) {
0000000000000000000000000000000000000000;;		podSource, err := kubetypes.GetPodSource(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, source := range capabilities.Get().PrivilegedSources.HostNetworkSources {
0000000000000000000000000000000000000000;;			if source == podSource {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Determined whether the specified pod is allowed to use host networking
0000000000000000000000000000000000000000;;	func allowHostPID(pod *v1.Pod) (bool, error) {
0000000000000000000000000000000000000000;;		podSource, err := kubetypes.GetPodSource(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, source := range capabilities.Get().PrivilegedSources.HostPIDSources {
0000000000000000000000000000000000000000;;			if source == podSource {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Determined whether the specified pod is allowed to use host ipc
0000000000000000000000000000000000000000;;	func allowHostIPC(pod *v1.Pod) (bool, error) {
0000000000000000000000000000000000000000;;		podSource, err := kubetypes.GetPodSource(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, source := range capabilities.Get().PrivilegedSources.HostIPCSources {
0000000000000000000000000000000000000000;;			if source == podSource {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dirExists returns true if the path exists and represents a directory.
0000000000000000000000000000000000000000;;	func dirExists(path string) bool {
0000000000000000000000000000000000000000;;		s, err := os.Stat(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.IsDir()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// empty is a placeholder type used to implement a set
0000000000000000000000000000000000000000;;	type empty struct{}
