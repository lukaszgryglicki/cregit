0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
876f49e842afc754615b7329892fb39b41274a02;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubelet/app/options"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/cm"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util"
0000000000000000000000000000000000000000;;		nodeutil "k8s.io/kubernetes/pkg/util/node"
0000000000000000000000000000000000000000;;		volumeutil "k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getRootDir returns the full path to the directory under which kubelet can
0000000000000000000000000000000000000000;;	// store data.  These functions are useful to pass interfaces to other modules
0000000000000000000000000000000000000000;;	// that may need to know where to write data without getting a whole kubelet
0000000000000000000000000000000000000000;;	// instance.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) getRootDir() string {
0000000000000000000000000000000000000000;;		return kl.rootDirectory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodsDir returns the full path to the directory under which pod
0000000000000000000000000000000000000000;;	// directories are created.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) getPodsDir() string {
0000000000000000000000000000000000000000;;		return filepath.Join(kl.getRootDir(), options.DefaultKubeletPodsDirName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPluginsDir returns the full path to the directory under which plugin
0000000000000000000000000000000000000000;;	// directories are created.  Plugins can use these directories for data that
0000000000000000000000000000000000000000;;	// they need to persist.  Plugins should create subdirectories under this named
0000000000000000000000000000000000000000;;	// after their own names.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) getPluginsDir() string {
0000000000000000000000000000000000000000;;		return filepath.Join(kl.getRootDir(), options.DefaultKubeletPluginsDirName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPluginDir returns a data directory name for a given plugin name.
0000000000000000000000000000000000000000;;	// Plugins can use these directories to store data that they need to persist.
0000000000000000000000000000000000000000;;	// For per-pod plugin data, see getPodPluginDir.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) getPluginDir(pluginName string) string {
0000000000000000000000000000000000000000;;		return filepath.Join(kl.getPluginsDir(), pluginName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPodDir returns the full path to the per-pod data directory for the
0000000000000000000000000000000000000000;;	// specified pod. This directory may not exist if the pod does not exist.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) GetPodDir(podUID types.UID) string {
0000000000000000000000000000000000000000;;		return kl.getPodDir(podUID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodDir returns the full path to the per-pod directory for the pod with
0000000000000000000000000000000000000000;;	// the given UID.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) getPodDir(podUID types.UID) string {
0000000000000000000000000000000000000000;;		// Backwards compat.  The "old" stuff should be removed before 1.0
0000000000000000000000000000000000000000;;		// release.  The thinking here is this:
0000000000000000000000000000000000000000;;		//     !old && !new = use new
0000000000000000000000000000000000000000;;		//     !old && new  = use new
0000000000000000000000000000000000000000;;		//     old && !new  = use old
0000000000000000000000000000000000000000;;		//     old && new   = use new (but warn)
0000000000000000000000000000000000000000;;		oldPath := filepath.Join(kl.getRootDir(), string(podUID))
0000000000000000000000000000000000000000;;		oldExists := dirExists(oldPath)
0000000000000000000000000000000000000000;;		newPath := filepath.Join(kl.getPodsDir(), string(podUID))
0000000000000000000000000000000000000000;;		newExists := dirExists(newPath)
0000000000000000000000000000000000000000;;		if oldExists && !newExists {
0000000000000000000000000000000000000000;;			return oldPath
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if oldExists {
0000000000000000000000000000000000000000;;			glog.Warningf("Data dir for pod %q exists in both old and new form, using new", podUID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newPath
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodVolumesDir returns the full path to the per-pod data directory under
0000000000000000000000000000000000000000;;	// which volumes are created for the specified pod.  This directory may not
0000000000000000000000000000000000000000;;	// exist if the pod does not exist.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) getPodVolumesDir(podUID types.UID) string {
0000000000000000000000000000000000000000;;		return filepath.Join(kl.getPodDir(podUID), options.DefaultKubeletVolumesDirName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodVolumeDir returns the full path to the directory which represents the
0000000000000000000000000000000000000000;;	// named volume under the named plugin for specified pod.  This directory may not
0000000000000000000000000000000000000000;;	// exist if the pod does not exist.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) getPodVolumeDir(podUID types.UID, pluginName string, volumeName string) string {
0000000000000000000000000000000000000000;;		return filepath.Join(kl.getPodVolumesDir(podUID), pluginName, volumeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodPluginsDir returns the full path to the per-pod data directory under
0000000000000000000000000000000000000000;;	// which plugins may store data for the specified pod.  This directory may not
0000000000000000000000000000000000000000;;	// exist if the pod does not exist.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) getPodPluginsDir(podUID types.UID) string {
0000000000000000000000000000000000000000;;		return filepath.Join(kl.getPodDir(podUID), options.DefaultKubeletPluginsDirName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodPluginDir returns a data directory name for a given plugin name for a
0000000000000000000000000000000000000000;;	// given pod UID.  Plugins can use these directories to store data that they
0000000000000000000000000000000000000000;;	// need to persist.  For non-per-pod plugin data, see getPluginDir.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) getPodPluginDir(podUID types.UID, pluginName string) string {
0000000000000000000000000000000000000000;;		return filepath.Join(kl.getPodPluginsDir(podUID), pluginName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodContainerDir returns the full path to the per-pod data directory under
0000000000000000000000000000000000000000;;	// which container data is held for the specified pod.  This directory may not
0000000000000000000000000000000000000000;;	// exist if the pod or container does not exist.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) getPodContainerDir(podUID types.UID, ctrName string) string {
0000000000000000000000000000000000000000;;		// Backwards compat.  The "old" stuff should be removed before 1.0
0000000000000000000000000000000000000000;;		// release.  The thinking here is this:
0000000000000000000000000000000000000000;;		//     !old && !new = use new
0000000000000000000000000000000000000000;;		//     !old && new  = use new
0000000000000000000000000000000000000000;;		//     old && !new  = use old
0000000000000000000000000000000000000000;;		//     old && new   = use new (but warn)
0000000000000000000000000000000000000000;;		oldPath := filepath.Join(kl.getPodDir(podUID), ctrName)
0000000000000000000000000000000000000000;;		oldExists := dirExists(oldPath)
0000000000000000000000000000000000000000;;		newPath := filepath.Join(kl.getPodDir(podUID), options.DefaultKubeletContainersDirName, ctrName)
0000000000000000000000000000000000000000;;		newExists := dirExists(newPath)
0000000000000000000000000000000000000000;;		if oldExists && !newExists {
0000000000000000000000000000000000000000;;			return oldPath
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if oldExists {
0000000000000000000000000000000000000000;;			glog.Warningf("Data dir for pod %q, container %q exists in both old and new form, using new", podUID, ctrName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newPath
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPods returns all pods bound to the kubelet and their spec, and the mirror
0000000000000000000000000000000000000000;;	// pods.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) GetPods() []*v1.Pod {
0000000000000000000000000000000000000000;;		return kl.podManager.GetPods()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetRunningPods returns all pods running on kubelet from looking at the
0000000000000000000000000000000000000000;;	// container runtime cache. This function converts kubecontainer.Pod to
0000000000000000000000000000000000000000;;	// v1.Pod, so only the fields that exist in both kubecontainer.Pod and
0000000000000000000000000000000000000000;;	// v1.Pod are considered meaningful.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) GetRunningPods() ([]*v1.Pod, error) {
0000000000000000000000000000000000000000;;		pods, err := kl.runtimeCache.GetPods()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiPods := make([]*v1.Pod, 0, len(pods))
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			apiPods = append(apiPods, pod.ToAPIPod())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return apiPods, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPodByFullName gets the pod with the given 'full' name, which
0000000000000000000000000000000000000000;;	// incorporates the namespace as well as whether the pod was found.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) GetPodByFullName(podFullName string) (*v1.Pod, bool) {
0000000000000000000000000000000000000000;;		return kl.podManager.GetPodByFullName(podFullName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPodByName provides the first pod that matches namespace and name, as well
0000000000000000000000000000000000000000;;	// as whether the pod was found.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) GetPodByName(namespace, name string) (*v1.Pod, bool) {
0000000000000000000000000000000000000000;;		return kl.podManager.GetPodByName(namespace, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetHostname Returns the hostname as the kubelet sees it.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) GetHostname() string {
0000000000000000000000000000000000000000;;		return kl.hostname
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetRuntime returns the current Runtime implementation in use by the kubelet. This func
0000000000000000000000000000000000000000;;	// is exported to simplify integration with third party kubelet extensions (e.g. kubernetes-mesos).
0000000000000000000000000000000000000000;;	func (kl *Kubelet) GetRuntime() kubecontainer.Runtime {
0000000000000000000000000000000000000000;;		return kl.containerRuntime
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetNode returns the node info for the configured node name of this Kubelet.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) GetNode() (*v1.Node, error) {
0000000000000000000000000000000000000000;;		if kl.standaloneMode {
0000000000000000000000000000000000000000;;			return kl.initialNode()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return kl.nodeInfo.GetNodeInfo(string(kl.nodeName))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getNodeAnyWay() must return a *v1.Node which is required by RunGeneralPredicates().
0000000000000000000000000000000000000000;;	// The *v1.Node is obtained as follows:
0000000000000000000000000000000000000000;;	// Return kubelet's nodeInfo for this node, except on error or if in standalone mode,
0000000000000000000000000000000000000000;;	// in which case return a manufactured nodeInfo representing a node with no pods,
0000000000000000000000000000000000000000;;	// zero capacity, and the default labels.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) getNodeAnyWay() (*v1.Node, error) {
0000000000000000000000000000000000000000;;		if !kl.standaloneMode {
0000000000000000000000000000000000000000;;			if n, err := kl.nodeInfo.GetNodeInfo(string(kl.nodeName)); err == nil {
0000000000000000000000000000000000000000;;				return n, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return kl.initialNode()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetNodeConfig returns the container manager node config.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) GetNodeConfig() cm.NodeConfig {
0000000000000000000000000000000000000000;;		return kl.containerManager.GetNodeConfig()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns host IP or nil in case of error.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) GetHostIP() (net.IP, error) {
0000000000000000000000000000000000000000;;		node, err := kl.GetNode()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cannot get node: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodeutil.GetNodeHostIP(node)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getHostIPAnyway attempts to return the host IP from kubelet's nodeInfo, or
0000000000000000000000000000000000000000;;	// the initialNode.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) getHostIPAnyWay() (net.IP, error) {
0000000000000000000000000000000000000000;;		node, err := kl.getNodeAnyWay()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodeutil.GetNodeHostIP(node)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetExtraSupplementalGroupsForPod returns a list of the extra
0000000000000000000000000000000000000000;;	// supplemental groups for the Pod. These extra supplemental groups come
0000000000000000000000000000000000000000;;	// from annotations on persistent volumes that the pod depends on.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) GetExtraSupplementalGroupsForPod(pod *v1.Pod) []int64 {
0000000000000000000000000000000000000000;;		return kl.volumeManager.GetExtraSupplementalGroupsForPod(pod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodVolumePathListFromDisk returns a list of the volume paths by reading the
0000000000000000000000000000000000000000;;	// volume directories for the given pod from the disk.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) getPodVolumePathListFromDisk(podUID types.UID) ([]string, error) {
0000000000000000000000000000000000000000;;		volumes := []string{}
0000000000000000000000000000000000000000;;		podVolDir := kl.getPodVolumesDir(podUID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pathExists, pathErr := volumeutil.PathExists(podVolDir); pathErr != nil {
0000000000000000000000000000000000000000;;			return volumes, fmt.Errorf("Error checking if path %q exists: %v", podVolDir, pathErr)
0000000000000000000000000000000000000000;;		} else if !pathExists {
0000000000000000000000000000000000000000;;			glog.Warningf("Warning: path %q does not exist: %q", podVolDir)
0000000000000000000000000000000000000000;;			return volumes, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumePluginDirs, err := ioutil.ReadDir(podVolDir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Could not read directory %s: %v", podVolDir, err)
0000000000000000000000000000000000000000;;			return volumes, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, volumePluginDir := range volumePluginDirs {
0000000000000000000000000000000000000000;;			volumePluginName := volumePluginDir.Name()
0000000000000000000000000000000000000000;;			volumePluginPath := filepath.Join(podVolDir, volumePluginName)
0000000000000000000000000000000000000000;;			volumeDirs, err := util.ReadDirNoStat(volumePluginPath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return volumes, fmt.Errorf("Could not read directory %s: %v", volumePluginPath, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, volumeDir := range volumeDirs {
0000000000000000000000000000000000000000;;				volumes = append(volumes, filepath.Join(volumePluginPath, volumeDir))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volumes, nil
0000000000000000000000000000000000000000;;	}
