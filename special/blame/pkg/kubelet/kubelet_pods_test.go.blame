0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
266eb08abb15154da4c0d887a3224856c04ae856;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/require"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		containertest "k8s.io/kubernetes/pkg/kubelet/container/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/server/portforward"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/server/remotecommand"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMakeMounts(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			container      v1.Container
0000000000000000000000000000000000000000;;			podVolumes     kubecontainer.VolumeMap
0000000000000000000000000000000000000000;;			expectErr      bool
0000000000000000000000000000000000000000;;			expectedErrMsg string
0000000000000000000000000000000000000000;;			expectedMounts []kubecontainer.Mount
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"valid mounts": {
0000000000000000000000000000000000000000;;				podVolumes: kubecontainer.VolumeMap{
0000000000000000000000000000000000000000;;					"disk":  kubecontainer.VolumeInfo{Mounter: &stubVolume{path: "/mnt/disk"}},
0000000000000000000000000000000000000000;;					"disk4": kubecontainer.VolumeInfo{Mounter: &stubVolume{path: "/mnt/host"}},
0000000000000000000000000000000000000000;;					"disk5": kubecontainer.VolumeInfo{Mounter: &stubVolume{path: "/var/lib/kubelet/podID/volumes/empty/disk5"}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				container: v1.Container{
0000000000000000000000000000000000000000;;					VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							MountPath: "/etc/hosts",
0000000000000000000000000000000000000000;;							Name:      "disk",
0000000000000000000000000000000000000000;;							ReadOnly:  false,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							MountPath: "/mnt/path3",
0000000000000000000000000000000000000000;;							Name:      "disk",
0000000000000000000000000000000000000000;;							ReadOnly:  true,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							MountPath: "/mnt/path4",
0000000000000000000000000000000000000000;;							Name:      "disk4",
0000000000000000000000000000000000000000;;							ReadOnly:  false,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							MountPath: "/mnt/path5",
0000000000000000000000000000000000000000;;							Name:      "disk5",
0000000000000000000000000000000000000000;;							ReadOnly:  false,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedMounts: []kubecontainer.Mount{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:           "disk",
0000000000000000000000000000000000000000;;						ContainerPath:  "/etc/hosts",
0000000000000000000000000000000000000000;;						HostPath:       "/mnt/disk",
0000000000000000000000000000000000000000;;						ReadOnly:       false,
0000000000000000000000000000000000000000;;						SELinuxRelabel: false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:           "disk",
0000000000000000000000000000000000000000;;						ContainerPath:  "/mnt/path3",
0000000000000000000000000000000000000000;;						HostPath:       "/mnt/disk",
0000000000000000000000000000000000000000;;						ReadOnly:       true,
0000000000000000000000000000000000000000;;						SELinuxRelabel: false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:           "disk4",
0000000000000000000000000000000000000000;;						ContainerPath:  "/mnt/path4",
0000000000000000000000000000000000000000;;						HostPath:       "/mnt/host",
0000000000000000000000000000000000000000;;						ReadOnly:       false,
0000000000000000000000000000000000000000;;						SELinuxRelabel: false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:           "disk5",
0000000000000000000000000000000000000000;;						ContainerPath:  "/mnt/path5",
0000000000000000000000000000000000000000;;						HostPath:       "/var/lib/kubelet/podID/volumes/empty/disk5",
0000000000000000000000000000000000000000;;						ReadOnly:       false,
0000000000000000000000000000000000000000;;						SELinuxRelabel: false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid absolute SubPath": {
0000000000000000000000000000000000000000;;				podVolumes: kubecontainer.VolumeMap{
0000000000000000000000000000000000000000;;					"disk": kubecontainer.VolumeInfo{Mounter: &stubVolume{path: "/mnt/disk"}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				container: v1.Container{
0000000000000000000000000000000000000000;;					VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							MountPath: "/mnt/path3",
0000000000000000000000000000000000000000;;							SubPath:   "/must/not/be/absolute",
0000000000000000000000000000000000000000;;							Name:      "disk",
0000000000000000000000000000000000000000;;							ReadOnly:  true,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr:      true,
0000000000000000000000000000000000000000;;				expectedErrMsg: "error SubPath `/must/not/be/absolute` must not be an absolute path",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid SubPath with backsteps": {
0000000000000000000000000000000000000000;;				podVolumes: kubecontainer.VolumeMap{
0000000000000000000000000000000000000000;;					"disk": kubecontainer.VolumeInfo{Mounter: &stubVolume{path: "/mnt/disk"}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				container: v1.Container{
0000000000000000000000000000000000000000;;					VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							MountPath: "/mnt/path3",
0000000000000000000000000000000000000000;;							SubPath:   "no/backsteps/../allowed",
0000000000000000000000000000000000000000;;							Name:      "disk",
0000000000000000000000000000000000000000;;							ReadOnly:  true,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr:      true,
0000000000000000000000000000000000000000;;				expectedErrMsg: "unable to provision SubPath `no/backsteps/../allowed`: must not contain '..'",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, tc := range testCases {
0000000000000000000000000000000000000000;;			t.Run(name, func(t *testing.T) {
0000000000000000000000000000000000000000;;				pod := v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						HostNetwork: true,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				mounts, err := makeMounts(&pod, "/pod", &tc.container, "fakepodname", "", "", tc.podVolumes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// validate only the error if we expect an error
0000000000000000000000000000000000000000;;				if tc.expectErr {
0000000000000000000000000000000000000000;;					if err == nil || err.Error() != tc.expectedErrMsg {
0000000000000000000000000000000000000000;;						t.Fatalf("expected error message `%s` but got `%v`", tc.expectedErrMsg, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// otherwise validate the mounts
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatal(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				assert.Equal(t, tc.expectedMounts, mounts, "mounts of container %+v", tc.container)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHostsFileContent(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			hostIP          string
0000000000000000000000000000000000000000;;			hostName        string
0000000000000000000000000000000000000000;;			hostDomainName  string
0000000000000000000000000000000000000000;;			hostAliases     []v1.HostAlias
0000000000000000000000000000000000000000;;			expectedContent string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"123.45.67.89",
0000000000000000000000000000000000000000;;				"podFoo",
0000000000000000000000000000000000000000;;				"",
0000000000000000000000000000000000000000;;				[]v1.HostAlias{},
0000000000000000000000000000000000000000;;				`# Kubernetes-managed hosts file.
0000000000000000000000000000000000000000;;	127.0.0.1	localhost
0000000000000000000000000000000000000000;;	::1	localhost ip6-localhost ip6-loopback
0000000000000000000000000000000000000000;;	fe00::0	ip6-localnet
0000000000000000000000000000000000000000;;	fe00::0	ip6-mcastprefix
0000000000000000000000000000000000000000;;	fe00::1	ip6-allnodes
0000000000000000000000000000000000000000;;	fe00::2	ip6-allrouters
0000000000000000000000000000000000000000;;	123.45.67.89	podFoo
0000000000000000000000000000000000000000;;	`,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"203.0.113.1",
0000000000000000000000000000000000000000;;				"podFoo",
0000000000000000000000000000000000000000;;				"domainFoo",
0000000000000000000000000000000000000000;;				[]v1.HostAlias{},
0000000000000000000000000000000000000000;;				`# Kubernetes-managed hosts file.
0000000000000000000000000000000000000000;;	127.0.0.1	localhost
0000000000000000000000000000000000000000;;	::1	localhost ip6-localhost ip6-loopback
0000000000000000000000000000000000000000;;	fe00::0	ip6-localnet
0000000000000000000000000000000000000000;;	fe00::0	ip6-mcastprefix
0000000000000000000000000000000000000000;;	fe00::1	ip6-allnodes
0000000000000000000000000000000000000000;;	fe00::2	ip6-allrouters
0000000000000000000000000000000000000000;;	203.0.113.1	podFoo.domainFoo	podFoo
0000000000000000000000000000000000000000;;	`,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"203.0.113.1",
0000000000000000000000000000000000000000;;				"podFoo",
0000000000000000000000000000000000000000;;				"domainFoo",
0000000000000000000000000000000000000000;;				[]v1.HostAlias{
0000000000000000000000000000000000000000;;					{IP: "123.45.67.89", Hostnames: []string{"foo", "bar", "baz"}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				`# Kubernetes-managed hosts file.
0000000000000000000000000000000000000000;;	127.0.0.1	localhost
0000000000000000000000000000000000000000;;	::1	localhost ip6-localhost ip6-loopback
0000000000000000000000000000000000000000;;	fe00::0	ip6-localnet
0000000000000000000000000000000000000000;;	fe00::0	ip6-mcastprefix
0000000000000000000000000000000000000000;;	fe00::1	ip6-allnodes
0000000000000000000000000000000000000000;;	fe00::2	ip6-allrouters
0000000000000000000000000000000000000000;;	203.0.113.1	podFoo.domainFoo	podFoo
0000000000000000000000000000000000000000;;	123.45.67.89	foo
0000000000000000000000000000000000000000;;	123.45.67.89	bar
0000000000000000000000000000000000000000;;	123.45.67.89	baz
0000000000000000000000000000000000000000;;	`,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"203.0.113.1",
0000000000000000000000000000000000000000;;				"podFoo",
0000000000000000000000000000000000000000;;				"domainFoo",
0000000000000000000000000000000000000000;;				[]v1.HostAlias{
0000000000000000000000000000000000000000;;					{IP: "123.45.67.89", Hostnames: []string{"foo", "bar", "baz"}},
0000000000000000000000000000000000000000;;					{IP: "456.78.90.123", Hostnames: []string{"park", "doo", "boo"}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				`# Kubernetes-managed hosts file.
0000000000000000000000000000000000000000;;	127.0.0.1	localhost
0000000000000000000000000000000000000000;;	::1	localhost ip6-localhost ip6-loopback
0000000000000000000000000000000000000000;;	fe00::0	ip6-localnet
0000000000000000000000000000000000000000;;	fe00::0	ip6-mcastprefix
0000000000000000000000000000000000000000;;	fe00::1	ip6-allnodes
0000000000000000000000000000000000000000;;	fe00::2	ip6-allrouters
0000000000000000000000000000000000000000;;	203.0.113.1	podFoo.domainFoo	podFoo
0000000000000000000000000000000000000000;;	123.45.67.89	foo
0000000000000000000000000000000000000000;;	123.45.67.89	bar
0000000000000000000000000000000000000000;;	123.45.67.89	baz
0000000000000000000000000000000000000000;;	456.78.90.123	park
0000000000000000000000000000000000000000;;	456.78.90.123	doo
0000000000000000000000000000000000000000;;	456.78.90.123	boo
0000000000000000000000000000000000000000;;	`,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, testCase := range testCases {
0000000000000000000000000000000000000000;;			actualContent := string(hostsFileContent(testCase.hostIP, testCase.hostName, testCase.hostDomainName, testCase.hostAliases))
0000000000000000000000000000000000000000;;			assert.Equal(t, testCase.expectedContent, actualContent, "hosts file content not expected")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRunInContainerNoSuchPod(t *testing.T) {
0000000000000000000000000000000000000000;;		testKubelet := newTestKubelet(t, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;		defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;		kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;		fakeRuntime := testKubelet.fakeRuntime
0000000000000000000000000000000000000000;;		fakeRuntime.PodList = []*containertest.FakePod{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podName := "podFoo"
0000000000000000000000000000000000000000;;		podNamespace := "nsFoo"
0000000000000000000000000000000000000000;;		containerName := "containerFoo"
0000000000000000000000000000000000000000;;		output, err := kubelet.RunInContainer(
0000000000000000000000000000000000000000;;			kubecontainer.GetPodFullName(&v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: podName, Namespace: podNamespace}}),
0000000000000000000000000000000000000000;;			"",
0000000000000000000000000000000000000000;;			containerName,
0000000000000000000000000000000000000000;;			[]string{"ls"})
0000000000000000000000000000000000000000;;		assert.Error(t, err)
0000000000000000000000000000000000000000;;		assert.Nil(t, output, "output should be nil")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRunInContainer(t *testing.T) {
0000000000000000000000000000000000000000;;		for _, testError := range []error{nil, errors.New("bar")} {
0000000000000000000000000000000000000000;;			testKubelet := newTestKubelet(t, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;			defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;			kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;			fakeRuntime := testKubelet.fakeRuntime
0000000000000000000000000000000000000000;;			fakeCommandRunner := containertest.FakeContainerCommandRunner{
0000000000000000000000000000000000000000;;				Err:    testError,
0000000000000000000000000000000000000000;;				Stdout: "foo",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			kubelet.runner = &fakeCommandRunner
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			containerID := kubecontainer.ContainerID{Type: "test", ID: "abc1234"}
0000000000000000000000000000000000000000;;			fakeRuntime.PodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;				{Pod: &kubecontainer.Pod{
0000000000000000000000000000000000000000;;					ID:        "12345678",
0000000000000000000000000000000000000000;;					Name:      "podFoo",
0000000000000000000000000000000000000000;;					Namespace: "nsFoo",
0000000000000000000000000000000000000000;;					Containers: []*kubecontainer.Container{
0000000000000000000000000000000000000000;;						{Name: "containerFoo",
0000000000000000000000000000000000000000;;							ID: containerID,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cmd := []string{"ls"}
0000000000000000000000000000000000000000;;			actualOutput, err := kubelet.RunInContainer("podFoo_nsFoo", "", "containerFoo", cmd)
0000000000000000000000000000000000000000;;			assert.Equal(t, containerID, fakeCommandRunner.ContainerID, "(testError=%v) ID", testError)
0000000000000000000000000000000000000000;;			assert.Equal(t, cmd, fakeCommandRunner.Cmd, "(testError=%v) command", testError)
0000000000000000000000000000000000000000;;			// this isn't 100% foolproof as a bug in a real ContainerCommandRunner where it fails to copy to stdout/stderr wouldn't be caught by this test
0000000000000000000000000000000000000000;;			assert.Equal(t, "foo", string(actualOutput), "(testError=%v) output", testError)
0000000000000000000000000000000000000000;;			assert.Equal(t, err, testError, "(testError=%v) err", testError)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGenerateRunContainerOptions_DNSConfigurationParams(t *testing.T) {
0000000000000000000000000000000000000000;;		testKubelet := newTestKubelet(t, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;		defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;		kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clusterNS := "203.0.113.1"
0000000000000000000000000000000000000000;;		kubelet.clusterDomain = "kubernetes.io"
0000000000000000000000000000000000000000;;		kubelet.clusterDNS = []net.IP{net.ParseIP(clusterNS)}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods := newTestPods(4)
0000000000000000000000000000000000000000;;		pods[0].Spec.DNSPolicy = v1.DNSClusterFirstWithHostNet
0000000000000000000000000000000000000000;;		pods[1].Spec.DNSPolicy = v1.DNSClusterFirst
0000000000000000000000000000000000000000;;		pods[2].Spec.DNSPolicy = v1.DNSClusterFirst
0000000000000000000000000000000000000000;;		pods[2].Spec.HostNetwork = false
0000000000000000000000000000000000000000;;		pods[3].Spec.DNSPolicy = v1.DNSDefault
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options := make([]*kubecontainer.RunContainerOptions, 4)
0000000000000000000000000000000000000000;;		for i, pod := range pods {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			options[i], _, err = kubelet.GenerateRunContainerOptions(pod, &v1.Container{}, "")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("failed to generate container options: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(options[0].DNS) != 1 || options[0].DNS[0] != clusterNS {
0000000000000000000000000000000000000000;;			t.Errorf("expected nameserver %s, got %+v", clusterNS, options[0].DNS)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(options[0].DNSSearch) == 0 || options[0].DNSSearch[0] != ".svc."+kubelet.clusterDomain {
0000000000000000000000000000000000000000;;			t.Errorf("expected search %s, got %+v", ".svc."+kubelet.clusterDomain, options[0].DNSSearch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(options[1].DNS) != 1 || options[1].DNS[0] != "127.0.0.1" {
0000000000000000000000000000000000000000;;			t.Errorf("expected nameserver 127.0.0.1, got %+v", options[1].DNS)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(options[1].DNSSearch) != 1 || options[1].DNSSearch[0] != "." {
0000000000000000000000000000000000000000;;			t.Errorf("expected search \".\", got %+v", options[1].DNSSearch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(options[2].DNS) != 1 || options[2].DNS[0] != clusterNS {
0000000000000000000000000000000000000000;;			t.Errorf("expected nameserver %s, got %+v", clusterNS, options[2].DNS)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(options[2].DNSSearch) == 0 || options[2].DNSSearch[0] != ".svc."+kubelet.clusterDomain {
0000000000000000000000000000000000000000;;			t.Errorf("expected search %s, got %+v", ".svc."+kubelet.clusterDomain, options[2].DNSSearch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(options[3].DNS) != 1 || options[3].DNS[0] != "127.0.0.1" {
0000000000000000000000000000000000000000;;			t.Errorf("expected nameserver 127.0.0.1, got %+v", options[3].DNS)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(options[3].DNSSearch) != 1 || options[3].DNSSearch[0] != "." {
0000000000000000000000000000000000000000;;			t.Errorf("expected search \".\", got %+v", options[3].DNSSearch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubelet.resolverConfig = "/etc/resolv.conf"
0000000000000000000000000000000000000000;;		for i, pod := range pods {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			options[i], _, err = kubelet.GenerateRunContainerOptions(pod, &v1.Container{}, "")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("failed to generate container options: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Logf("nameservers %+v", options[1].DNS)
0000000000000000000000000000000000000000;;		if len(options[0].DNS) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected cluster nameserver only, got %+v", options[0].DNS)
0000000000000000000000000000000000000000;;		} else if options[0].DNS[0] != clusterNS {
0000000000000000000000000000000000000000;;			t.Errorf("expected nameserver %s, got %v", clusterNS, options[0].DNS[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expLength := len(options[1].DNSSearch) + 3
0000000000000000000000000000000000000000;;		if expLength > 6 {
0000000000000000000000000000000000000000;;			expLength = 6
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(options[0].DNSSearch) != expLength {
0000000000000000000000000000000000000000;;			t.Errorf("expected prepend of cluster domain, got %+v", options[0].DNSSearch)
0000000000000000000000000000000000000000;;		} else if options[0].DNSSearch[0] != ".svc."+kubelet.clusterDomain {
0000000000000000000000000000000000000000;;			t.Errorf("expected domain %s, got %s", ".svc."+kubelet.clusterDomain, options[0].DNSSearch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(options[2].DNS) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected cluster nameserver only, got %+v", options[2].DNS)
0000000000000000000000000000000000000000;;		} else if options[2].DNS[0] != clusterNS {
0000000000000000000000000000000000000000;;			t.Errorf("expected nameserver %s, got %v", clusterNS, options[2].DNS[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(options[2].DNSSearch) != expLength {
0000000000000000000000000000000000000000;;			t.Errorf("expected prepend of cluster domain, got %+v", options[2].DNSSearch)
0000000000000000000000000000000000000000;;		} else if options[2].DNSSearch[0] != ".svc."+kubelet.clusterDomain {
0000000000000000000000000000000000000000;;			t.Errorf("expected domain %s, got %s", ".svc."+kubelet.clusterDomain, options[0].DNSSearch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testServiceLister struct {
0000000000000000000000000000000000000000;;		services []*v1.Service
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ls testServiceLister) List(labels.Selector) ([]*v1.Service, error) {
0000000000000000000000000000000000000000;;		return ls.services, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type envs []kubecontainer.EnvVar
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e envs) Len() int {
0000000000000000000000000000000000000000;;		return len(e)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e envs) Swap(i, j int) { e[i], e[j] = e[j], e[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e envs) Less(i, j int) bool { return e[i].Name < e[j].Name }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildService(name, namespace, clusterIP, protocol string, port int) *v1.Service {
0000000000000000000000000000000000000000;;		return &v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: name, Namespace: namespace},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;					Protocol: v1.Protocol(protocol),
0000000000000000000000000000000000000000;;					Port:     int32(port),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				ClusterIP: clusterIP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMakeEnvironmentVariables(t *testing.T) {
0000000000000000000000000000000000000000;;		trueVal := true
0000000000000000000000000000000000000000;;		services := []*v1.Service{
0000000000000000000000000000000000000000;;			buildService("kubernetes", metav1.NamespaceDefault, "1.2.3.1", "TCP", 8081),
0000000000000000000000000000000000000000;;			buildService("test", "test1", "1.2.3.3", "TCP", 8083),
0000000000000000000000000000000000000000;;			buildService("kubernetes", "test2", "1.2.3.4", "TCP", 8084),
0000000000000000000000000000000000000000;;			buildService("test", "test2", "1.2.3.5", "TCP", 8085),
0000000000000000000000000000000000000000;;			buildService("test", "test2", "None", "TCP", 8085),
0000000000000000000000000000000000000000;;			buildService("test", "test2", "", "TCP", 8085),
0000000000000000000000000000000000000000;;			buildService("kubernetes", "kubernetes", "1.2.3.6", "TCP", 8086),
0000000000000000000000000000000000000000;;			buildService("not-special", "kubernetes", "1.2.3.8", "TCP", 8088),
0000000000000000000000000000000000000000;;			buildService("not-special", "kubernetes", "None", "TCP", 8088),
0000000000000000000000000000000000000000;;			buildService("not-special", "kubernetes", "", "TCP", 8088),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			name            string                 // the name of the test case
0000000000000000000000000000000000000000;;			ns              string                 // the namespace to generate environment for
0000000000000000000000000000000000000000;;			container       *v1.Container          // the container to use
0000000000000000000000000000000000000000;;			masterServiceNs string                 // the namespace to read master service info from
0000000000000000000000000000000000000000;;			nilLister       bool                   // whether the lister should be nil
0000000000000000000000000000000000000000;;			configMap       *v1.ConfigMap          // an optional ConfigMap to pull from
0000000000000000000000000000000000000000;;			secret          *v1.Secret             // an optional Secret to pull from
0000000000000000000000000000000000000000;;			expectedEnvs    []kubecontainer.EnvVar // a set of expected environment vars
0000000000000000000000000000000000000000;;			expectedError   bool                   // does the test fail
0000000000000000000000000000000000000000;;			expectedEvent   string                 // does the test emit an event
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "api server = Y, kubelet = Y",
0000000000000000000000000000000000000000;;				ns:   "test1",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;						{Name: "FOO", Value: "BAR"},
0000000000000000000000000000000000000000;;						{Name: "TEST_SERVICE_HOST", Value: "1.2.3.3"},
0000000000000000000000000000000000000000;;						{Name: "TEST_SERVICE_PORT", Value: "8083"},
0000000000000000000000000000000000000000;;						{Name: "TEST_PORT", Value: "tcp://1.2.3.3:8083"},
0000000000000000000000000000000000000000;;						{Name: "TEST_PORT_8083_TCP", Value: "tcp://1.2.3.3:8083"},
0000000000000000000000000000000000000000;;						{Name: "TEST_PORT_8083_TCP_PROTO", Value: "tcp"},
0000000000000000000000000000000000000000;;						{Name: "TEST_PORT_8083_TCP_PORT", Value: "8083"},
0000000000000000000000000000000000000000;;						{Name: "TEST_PORT_8083_TCP_ADDR", Value: "1.2.3.3"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				masterServiceNs: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				nilLister:       false,
0000000000000000000000000000000000000000;;				expectedEnvs: []kubecontainer.EnvVar{
0000000000000000000000000000000000000000;;					{Name: "FOO", Value: "BAR"},
0000000000000000000000000000000000000000;;					{Name: "TEST_SERVICE_HOST", Value: "1.2.3.3"},
0000000000000000000000000000000000000000;;					{Name: "TEST_SERVICE_PORT", Value: "8083"},
0000000000000000000000000000000000000000;;					{Name: "TEST_PORT", Value: "tcp://1.2.3.3:8083"},
0000000000000000000000000000000000000000;;					{Name: "TEST_PORT_8083_TCP", Value: "tcp://1.2.3.3:8083"},
0000000000000000000000000000000000000000;;					{Name: "TEST_PORT_8083_TCP_PROTO", Value: "tcp"},
0000000000000000000000000000000000000000;;					{Name: "TEST_PORT_8083_TCP_PORT", Value: "8083"},
0000000000000000000000000000000000000000;;					{Name: "TEST_PORT_8083_TCP_ADDR", Value: "1.2.3.3"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_SERVICE_PORT", Value: "8081"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_SERVICE_HOST", Value: "1.2.3.1"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_PORT", Value: "tcp://1.2.3.1:8081"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_PORT_8081_TCP", Value: "tcp://1.2.3.1:8081"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_PORT_8081_TCP_PROTO", Value: "tcp"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_PORT_8081_TCP_PORT", Value: "8081"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_PORT_8081_TCP_ADDR", Value: "1.2.3.1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "api server = Y, kubelet = N",
0000000000000000000000000000000000000000;;				ns:   "test1",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;						{Name: "FOO", Value: "BAR"},
0000000000000000000000000000000000000000;;						{Name: "TEST_SERVICE_HOST", Value: "1.2.3.3"},
0000000000000000000000000000000000000000;;						{Name: "TEST_SERVICE_PORT", Value: "8083"},
0000000000000000000000000000000000000000;;						{Name: "TEST_PORT", Value: "tcp://1.2.3.3:8083"},
0000000000000000000000000000000000000000;;						{Name: "TEST_PORT_8083_TCP", Value: "tcp://1.2.3.3:8083"},
0000000000000000000000000000000000000000;;						{Name: "TEST_PORT_8083_TCP_PROTO", Value: "tcp"},
0000000000000000000000000000000000000000;;						{Name: "TEST_PORT_8083_TCP_PORT", Value: "8083"},
0000000000000000000000000000000000000000;;						{Name: "TEST_PORT_8083_TCP_ADDR", Value: "1.2.3.3"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				masterServiceNs: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				nilLister:       true,
0000000000000000000000000000000000000000;;				expectedEnvs: []kubecontainer.EnvVar{
0000000000000000000000000000000000000000;;					{Name: "FOO", Value: "BAR"},
0000000000000000000000000000000000000000;;					{Name: "TEST_SERVICE_HOST", Value: "1.2.3.3"},
0000000000000000000000000000000000000000;;					{Name: "TEST_SERVICE_PORT", Value: "8083"},
0000000000000000000000000000000000000000;;					{Name: "TEST_PORT", Value: "tcp://1.2.3.3:8083"},
0000000000000000000000000000000000000000;;					{Name: "TEST_PORT_8083_TCP", Value: "tcp://1.2.3.3:8083"},
0000000000000000000000000000000000000000;;					{Name: "TEST_PORT_8083_TCP_PROTO", Value: "tcp"},
0000000000000000000000000000000000000000;;					{Name: "TEST_PORT_8083_TCP_PORT", Value: "8083"},
0000000000000000000000000000000000000000;;					{Name: "TEST_PORT_8083_TCP_ADDR", Value: "1.2.3.3"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "api server = N; kubelet = Y",
0000000000000000000000000000000000000000;;				ns:   "test1",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;						{Name: "FOO", Value: "BAZ"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				masterServiceNs: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				nilLister:       false,
0000000000000000000000000000000000000000;;				expectedEnvs: []kubecontainer.EnvVar{
0000000000000000000000000000000000000000;;					{Name: "FOO", Value: "BAZ"},
0000000000000000000000000000000000000000;;					{Name: "TEST_SERVICE_HOST", Value: "1.2.3.3"},
0000000000000000000000000000000000000000;;					{Name: "TEST_SERVICE_PORT", Value: "8083"},
0000000000000000000000000000000000000000;;					{Name: "TEST_PORT", Value: "tcp://1.2.3.3:8083"},
0000000000000000000000000000000000000000;;					{Name: "TEST_PORT_8083_TCP", Value: "tcp://1.2.3.3:8083"},
0000000000000000000000000000000000000000;;					{Name: "TEST_PORT_8083_TCP_PROTO", Value: "tcp"},
0000000000000000000000000000000000000000;;					{Name: "TEST_PORT_8083_TCP_PORT", Value: "8083"},
0000000000000000000000000000000000000000;;					{Name: "TEST_PORT_8083_TCP_ADDR", Value: "1.2.3.3"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_SERVICE_HOST", Value: "1.2.3.1"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_SERVICE_PORT", Value: "8081"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_PORT", Value: "tcp://1.2.3.1:8081"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_PORT_8081_TCP", Value: "tcp://1.2.3.1:8081"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_PORT_8081_TCP_PROTO", Value: "tcp"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_PORT_8081_TCP_PORT", Value: "8081"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_PORT_8081_TCP_ADDR", Value: "1.2.3.1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "master service in pod ns",
0000000000000000000000000000000000000000;;				ns:   "test2",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;						{Name: "FOO", Value: "ZAP"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				masterServiceNs: "kubernetes",
0000000000000000000000000000000000000000;;				nilLister:       false,
0000000000000000000000000000000000000000;;				expectedEnvs: []kubecontainer.EnvVar{
0000000000000000000000000000000000000000;;					{Name: "FOO", Value: "ZAP"},
0000000000000000000000000000000000000000;;					{Name: "TEST_SERVICE_HOST", Value: "1.2.3.5"},
0000000000000000000000000000000000000000;;					{Name: "TEST_SERVICE_PORT", Value: "8085"},
0000000000000000000000000000000000000000;;					{Name: "TEST_PORT", Value: "tcp://1.2.3.5:8085"},
0000000000000000000000000000000000000000;;					{Name: "TEST_PORT_8085_TCP", Value: "tcp://1.2.3.5:8085"},
0000000000000000000000000000000000000000;;					{Name: "TEST_PORT_8085_TCP_PROTO", Value: "tcp"},
0000000000000000000000000000000000000000;;					{Name: "TEST_PORT_8085_TCP_PORT", Value: "8085"},
0000000000000000000000000000000000000000;;					{Name: "TEST_PORT_8085_TCP_ADDR", Value: "1.2.3.5"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_SERVICE_HOST", Value: "1.2.3.4"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_SERVICE_PORT", Value: "8084"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_PORT", Value: "tcp://1.2.3.4:8084"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_PORT_8084_TCP", Value: "tcp://1.2.3.4:8084"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_PORT_8084_TCP_PROTO", Value: "tcp"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_PORT_8084_TCP_PORT", Value: "8084"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_PORT_8084_TCP_ADDR", Value: "1.2.3.4"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:            "pod in master service ns",
0000000000000000000000000000000000000000;;				ns:              "kubernetes",
0000000000000000000000000000000000000000;;				container:       &v1.Container{},
0000000000000000000000000000000000000000;;				masterServiceNs: "kubernetes",
0000000000000000000000000000000000000000;;				nilLister:       false,
0000000000000000000000000000000000000000;;				expectedEnvs: []kubecontainer.EnvVar{
0000000000000000000000000000000000000000;;					{Name: "NOT_SPECIAL_SERVICE_HOST", Value: "1.2.3.8"},
0000000000000000000000000000000000000000;;					{Name: "NOT_SPECIAL_SERVICE_PORT", Value: "8088"},
0000000000000000000000000000000000000000;;					{Name: "NOT_SPECIAL_PORT", Value: "tcp://1.2.3.8:8088"},
0000000000000000000000000000000000000000;;					{Name: "NOT_SPECIAL_PORT_8088_TCP", Value: "tcp://1.2.3.8:8088"},
0000000000000000000000000000000000000000;;					{Name: "NOT_SPECIAL_PORT_8088_TCP_PROTO", Value: "tcp"},
0000000000000000000000000000000000000000;;					{Name: "NOT_SPECIAL_PORT_8088_TCP_PORT", Value: "8088"},
0000000000000000000000000000000000000000;;					{Name: "NOT_SPECIAL_PORT_8088_TCP_ADDR", Value: "1.2.3.8"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_SERVICE_HOST", Value: "1.2.3.6"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_SERVICE_PORT", Value: "8086"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_PORT", Value: "tcp://1.2.3.6:8086"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_PORT_8086_TCP", Value: "tcp://1.2.3.6:8086"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_PORT_8086_TCP_PROTO", Value: "tcp"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_PORT_8086_TCP_PORT", Value: "8086"},
0000000000000000000000000000000000000000;;					{Name: "KUBERNETES_PORT_8086_TCP_ADDR", Value: "1.2.3.6"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "downward api pod",
0000000000000000000000000000000000000000;;				ns:   "downward-api",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: "POD_NAME",
0000000000000000000000000000000000000000;;							ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;								FieldRef: &v1.ObjectFieldSelector{
0000000000000000000000000000000000000000;;									APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String(),
0000000000000000000000000000000000000000;;									FieldPath:  "metadata.name",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: "POD_NAMESPACE",
0000000000000000000000000000000000000000;;							ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;								FieldRef: &v1.ObjectFieldSelector{
0000000000000000000000000000000000000000;;									APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String(),
0000000000000000000000000000000000000000;;									FieldPath:  "metadata.namespace",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: "POD_NODE_NAME",
0000000000000000000000000000000000000000;;							ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;								FieldRef: &v1.ObjectFieldSelector{
0000000000000000000000000000000000000000;;									APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String(),
0000000000000000000000000000000000000000;;									FieldPath:  "spec.nodeName",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: "POD_SERVICE_ACCOUNT_NAME",
0000000000000000000000000000000000000000;;							ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;								FieldRef: &v1.ObjectFieldSelector{
0000000000000000000000000000000000000000;;									APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String(),
0000000000000000000000000000000000000000;;									FieldPath:  "spec.serviceAccountName",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: "POD_IP",
0000000000000000000000000000000000000000;;							ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;								FieldRef: &v1.ObjectFieldSelector{
0000000000000000000000000000000000000000;;									APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String(),
0000000000000000000000000000000000000000;;									FieldPath:  "status.podIP",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: "HOST_IP",
0000000000000000000000000000000000000000;;							ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;								FieldRef: &v1.ObjectFieldSelector{
0000000000000000000000000000000000000000;;									APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String(),
0000000000000000000000000000000000000000;;									FieldPath:  "status.hostIP",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				masterServiceNs: "nothing",
0000000000000000000000000000000000000000;;				nilLister:       true,
0000000000000000000000000000000000000000;;				expectedEnvs: []kubecontainer.EnvVar{
0000000000000000000000000000000000000000;;					{Name: "POD_NAME", Value: "dapi-test-pod-name"},
0000000000000000000000000000000000000000;;					{Name: "POD_NAMESPACE", Value: "downward-api"},
0000000000000000000000000000000000000000;;					{Name: "POD_NODE_NAME", Value: "node-name"},
0000000000000000000000000000000000000000;;					{Name: "POD_SERVICE_ACCOUNT_NAME", Value: "special"},
0000000000000000000000000000000000000000;;					{Name: "POD_IP", Value: "1.2.3.4"},
0000000000000000000000000000000000000000;;					{Name: "HOST_IP", Value: testKubeletHostIP},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "env expansion",
0000000000000000000000000000000000000000;;				ns:   "test1",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "TEST_LITERAL",
0000000000000000000000000000000000000000;;							Value: "test-test-test",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: "POD_NAME",
0000000000000000000000000000000000000000;;							ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;								FieldRef: &v1.ObjectFieldSelector{
0000000000000000000000000000000000000000;;									APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String(),
0000000000000000000000000000000000000000;;									FieldPath:  "metadata.name",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "OUT_OF_ORDER_TEST",
0000000000000000000000000000000000000000;;							Value: "$(OUT_OF_ORDER_TARGET)",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "OUT_OF_ORDER_TARGET",
0000000000000000000000000000000000000000;;							Value: "FOO",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: "EMPTY_VAR",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "EMPTY_TEST",
0000000000000000000000000000000000000000;;							Value: "foo-$(EMPTY_VAR)",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "POD_NAME_TEST2",
0000000000000000000000000000000000000000;;							Value: "test2-$(POD_NAME)",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "POD_NAME_TEST3",
0000000000000000000000000000000000000000;;							Value: "$(POD_NAME_TEST2)-3",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "LITERAL_TEST",
0000000000000000000000000000000000000000;;							Value: "literal-$(TEST_LITERAL)",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "SERVICE_VAR_TEST",
0000000000000000000000000000000000000000;;							Value: "$(TEST_SERVICE_HOST):$(TEST_SERVICE_PORT)",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "TEST_UNDEFINED",
0000000000000000000000000000000000000000;;							Value: "$(UNDEFINED_VAR)",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				masterServiceNs: "nothing",
0000000000000000000000000000000000000000;;				nilLister:       false,
0000000000000000000000000000000000000000;;				expectedEnvs: []kubecontainer.EnvVar{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_LITERAL",
0000000000000000000000000000000000000000;;						Value: "test-test-test",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "POD_NAME",
0000000000000000000000000000000000000000;;						Value: "dapi-test-pod-name",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "POD_NAME_TEST2",
0000000000000000000000000000000000000000;;						Value: "test2-dapi-test-pod-name",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "POD_NAME_TEST3",
0000000000000000000000000000000000000000;;						Value: "test2-dapi-test-pod-name-3",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "LITERAL_TEST",
0000000000000000000000000000000000000000;;						Value: "literal-test-test-test",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_SERVICE_HOST",
0000000000000000000000000000000000000000;;						Value: "1.2.3.3",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_SERVICE_PORT",
0000000000000000000000000000000000000000;;						Value: "8083",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_PORT",
0000000000000000000000000000000000000000;;						Value: "tcp://1.2.3.3:8083",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_PORT_8083_TCP",
0000000000000000000000000000000000000000;;						Value: "tcp://1.2.3.3:8083",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_PORT_8083_TCP_PROTO",
0000000000000000000000000000000000000000;;						Value: "tcp",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_PORT_8083_TCP_PORT",
0000000000000000000000000000000000000000;;						Value: "8083",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_PORT_8083_TCP_ADDR",
0000000000000000000000000000000000000000;;						Value: "1.2.3.3",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "SERVICE_VAR_TEST",
0000000000000000000000000000000000000000;;						Value: "1.2.3.3:8083",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "OUT_OF_ORDER_TEST",
0000000000000000000000000000000000000000;;						Value: "$(OUT_OF_ORDER_TARGET)",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "OUT_OF_ORDER_TARGET",
0000000000000000000000000000000000000000;;						Value: "FOO",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_UNDEFINED",
0000000000000000000000000000000000000000;;						Value: "$(UNDEFINED_VAR)",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "EMPTY_VAR",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "EMPTY_TEST",
0000000000000000000000000000000000000000;;						Value: "foo-",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "configmapkeyref_missing_optional",
0000000000000000000000000000000000000000;;				ns:   "test",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: "POD_NAME",
0000000000000000000000000000000000000000;;							ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;								ConfigMapKeyRef: &v1.ConfigMapKeySelector{
0000000000000000000000000000000000000000;;									LocalObjectReference: v1.LocalObjectReference{Name: "missing-config-map"},
0000000000000000000000000000000000000000;;									Key:                  "key",
0000000000000000000000000000000000000000;;									Optional:             &trueVal,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				masterServiceNs: "nothing",
0000000000000000000000000000000000000000;;				expectedEnvs:    nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "configmapkeyref_missing_key_optional",
0000000000000000000000000000000000000000;;				ns:   "test",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: "POD_NAME",
0000000000000000000000000000000000000000;;							ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;								ConfigMapKeyRef: &v1.ConfigMapKeySelector{
0000000000000000000000000000000000000000;;									LocalObjectReference: v1.LocalObjectReference{Name: "test-config-map"},
0000000000000000000000000000000000000000;;									Key:                  "key",
0000000000000000000000000000000000000000;;									Optional:             &trueVal,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				masterServiceNs: "nothing",
0000000000000000000000000000000000000000;;				nilLister:       true,
0000000000000000000000000000000000000000;;				configMap: &v1.ConfigMap{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Namespace: "test1",
0000000000000000000000000000000000000000;;						Name:      "test-configmap",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Data: map[string]string{
0000000000000000000000000000000000000000;;						"a": "b",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedEnvs: nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "secretkeyref_missing_optional",
0000000000000000000000000000000000000000;;				ns:   "test",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: "POD_NAME",
0000000000000000000000000000000000000000;;							ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;								SecretKeyRef: &v1.SecretKeySelector{
0000000000000000000000000000000000000000;;									LocalObjectReference: v1.LocalObjectReference{Name: "missing-secret"},
0000000000000000000000000000000000000000;;									Key:                  "key",
0000000000000000000000000000000000000000;;									Optional:             &trueVal,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				masterServiceNs: "nothing",
0000000000000000000000000000000000000000;;				expectedEnvs:    nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "secretkeyref_missing_key_optional",
0000000000000000000000000000000000000000;;				ns:   "test",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: "POD_NAME",
0000000000000000000000000000000000000000;;							ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;								SecretKeyRef: &v1.SecretKeySelector{
0000000000000000000000000000000000000000;;									LocalObjectReference: v1.LocalObjectReference{Name: "test-secret"},
0000000000000000000000000000000000000000;;									Key:                  "key",
0000000000000000000000000000000000000000;;									Optional:             &trueVal,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				masterServiceNs: "nothing",
0000000000000000000000000000000000000000;;				nilLister:       true,
0000000000000000000000000000000000000000;;				secret: &v1.Secret{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Namespace: "test1",
0000000000000000000000000000000000000000;;						Name:      "test-secret",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Data: map[string][]byte{
0000000000000000000000000000000000000000;;						"a": []byte("b"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedEnvs: nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "configmap",
0000000000000000000000000000000000000000;;				ns:   "test1",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					EnvFrom: []v1.EnvFromSource{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ConfigMapRef: &v1.ConfigMapEnvSource{LocalObjectReference: v1.LocalObjectReference{Name: "test-config-map"}},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Prefix:       "p_",
0000000000000000000000000000000000000000;;							ConfigMapRef: &v1.ConfigMapEnvSource{LocalObjectReference: v1.LocalObjectReference{Name: "test-config-map"}},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "TEST_LITERAL",
0000000000000000000000000000000000000000;;							Value: "test-test-test",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "EXPANSION_TEST",
0000000000000000000000000000000000000000;;							Value: "$(REPLACE_ME)",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "DUPE_TEST",
0000000000000000000000000000000000000000;;							Value: "ENV_VAR",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				masterServiceNs: "nothing",
0000000000000000000000000000000000000000;;				nilLister:       false,
0000000000000000000000000000000000000000;;				configMap: &v1.ConfigMap{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Namespace: "test1",
0000000000000000000000000000000000000000;;						Name:      "test-configmap",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Data: map[string]string{
0000000000000000000000000000000000000000;;						"REPLACE_ME": "FROM_CONFIG_MAP",
0000000000000000000000000000000000000000;;						"DUPE_TEST":  "CONFIG_MAP",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedEnvs: []kubecontainer.EnvVar{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_LITERAL",
0000000000000000000000000000000000000000;;						Value: "test-test-test",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_SERVICE_HOST",
0000000000000000000000000000000000000000;;						Value: "1.2.3.3",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_SERVICE_PORT",
0000000000000000000000000000000000000000;;						Value: "8083",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_PORT",
0000000000000000000000000000000000000000;;						Value: "tcp://1.2.3.3:8083",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_PORT_8083_TCP",
0000000000000000000000000000000000000000;;						Value: "tcp://1.2.3.3:8083",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_PORT_8083_TCP_PROTO",
0000000000000000000000000000000000000000;;						Value: "tcp",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_PORT_8083_TCP_PORT",
0000000000000000000000000000000000000000;;						Value: "8083",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_PORT_8083_TCP_ADDR",
0000000000000000000000000000000000000000;;						Value: "1.2.3.3",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "REPLACE_ME",
0000000000000000000000000000000000000000;;						Value: "FROM_CONFIG_MAP",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "EXPANSION_TEST",
0000000000000000000000000000000000000000;;						Value: "FROM_CONFIG_MAP",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "DUPE_TEST",
0000000000000000000000000000000000000000;;						Value: "ENV_VAR",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "p_REPLACE_ME",
0000000000000000000000000000000000000000;;						Value: "FROM_CONFIG_MAP",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "p_DUPE_TEST",
0000000000000000000000000000000000000000;;						Value: "CONFIG_MAP",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "configmap_missing",
0000000000000000000000000000000000000000;;				ns:   "test1",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					EnvFrom: []v1.EnvFromSource{
0000000000000000000000000000000000000000;;						{ConfigMapRef: &v1.ConfigMapEnvSource{LocalObjectReference: v1.LocalObjectReference{Name: "test-config-map"}}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				masterServiceNs: "nothing",
0000000000000000000000000000000000000000;;				expectedError:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "configmap_missing_optional",
0000000000000000000000000000000000000000;;				ns:   "test",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					EnvFrom: []v1.EnvFromSource{
0000000000000000000000000000000000000000;;						{ConfigMapRef: &v1.ConfigMapEnvSource{
0000000000000000000000000000000000000000;;							Optional:             &trueVal,
0000000000000000000000000000000000000000;;							LocalObjectReference: v1.LocalObjectReference{Name: "missing-config-map"}}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				masterServiceNs: "nothing",
0000000000000000000000000000000000000000;;				expectedEnvs:    nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "configmap_invalid_keys",
0000000000000000000000000000000000000000;;				ns:   "test",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					EnvFrom: []v1.EnvFromSource{
0000000000000000000000000000000000000000;;						{ConfigMapRef: &v1.ConfigMapEnvSource{LocalObjectReference: v1.LocalObjectReference{Name: "test-config-map"}}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				masterServiceNs: "nothing",
0000000000000000000000000000000000000000;;				configMap: &v1.ConfigMap{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Namespace: "test1",
0000000000000000000000000000000000000000;;						Name:      "test-configmap",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Data: map[string]string{
0000000000000000000000000000000000000000;;						"1234": "abc",
0000000000000000000000000000000000000000;;						"1z":   "abc",
0000000000000000000000000000000000000000;;						"key":  "value",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedEnvs: []kubecontainer.EnvVar{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "key",
0000000000000000000000000000000000000000;;						Value: "value",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedEvent: "Warning InvalidEnvironmentVariableNames Keys [1234, 1z] from the EnvFrom configMap test/test-config-map were skipped since they are considered invalid environment variable names.",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "configmap_invalid_keys_valid",
0000000000000000000000000000000000000000;;				ns:   "test",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					EnvFrom: []v1.EnvFromSource{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Prefix:       "p_",
0000000000000000000000000000000000000000;;							ConfigMapRef: &v1.ConfigMapEnvSource{LocalObjectReference: v1.LocalObjectReference{Name: "test-config-map"}},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				masterServiceNs: "",
0000000000000000000000000000000000000000;;				configMap: &v1.ConfigMap{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Namespace: "test1",
0000000000000000000000000000000000000000;;						Name:      "test-configmap",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Data: map[string]string{
0000000000000000000000000000000000000000;;						"1234": "abc",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedEnvs: []kubecontainer.EnvVar{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "p_1234",
0000000000000000000000000000000000000000;;						Value: "abc",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "secret",
0000000000000000000000000000000000000000;;				ns:   "test1",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					EnvFrom: []v1.EnvFromSource{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							SecretRef: &v1.SecretEnvSource{LocalObjectReference: v1.LocalObjectReference{Name: "test-secret"}},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Prefix:    "p_",
0000000000000000000000000000000000000000;;							SecretRef: &v1.SecretEnvSource{LocalObjectReference: v1.LocalObjectReference{Name: "test-secret"}},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "TEST_LITERAL",
0000000000000000000000000000000000000000;;							Value: "test-test-test",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "EXPANSION_TEST",
0000000000000000000000000000000000000000;;							Value: "$(REPLACE_ME)",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "DUPE_TEST",
0000000000000000000000000000000000000000;;							Value: "ENV_VAR",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				masterServiceNs: "nothing",
0000000000000000000000000000000000000000;;				nilLister:       false,
0000000000000000000000000000000000000000;;				secret: &v1.Secret{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Namespace: "test1",
0000000000000000000000000000000000000000;;						Name:      "test-secret",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Data: map[string][]byte{
0000000000000000000000000000000000000000;;						"REPLACE_ME": []byte("FROM_SECRET"),
0000000000000000000000000000000000000000;;						"DUPE_TEST":  []byte("SECRET"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedEnvs: []kubecontainer.EnvVar{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_LITERAL",
0000000000000000000000000000000000000000;;						Value: "test-test-test",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_SERVICE_HOST",
0000000000000000000000000000000000000000;;						Value: "1.2.3.3",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_SERVICE_PORT",
0000000000000000000000000000000000000000;;						Value: "8083",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_PORT",
0000000000000000000000000000000000000000;;						Value: "tcp://1.2.3.3:8083",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_PORT_8083_TCP",
0000000000000000000000000000000000000000;;						Value: "tcp://1.2.3.3:8083",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_PORT_8083_TCP_PROTO",
0000000000000000000000000000000000000000;;						Value: "tcp",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_PORT_8083_TCP_PORT",
0000000000000000000000000000000000000000;;						Value: "8083",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "TEST_PORT_8083_TCP_ADDR",
0000000000000000000000000000000000000000;;						Value: "1.2.3.3",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "REPLACE_ME",
0000000000000000000000000000000000000000;;						Value: "FROM_SECRET",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "EXPANSION_TEST",
0000000000000000000000000000000000000000;;						Value: "FROM_SECRET",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "DUPE_TEST",
0000000000000000000000000000000000000000;;						Value: "ENV_VAR",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "p_REPLACE_ME",
0000000000000000000000000000000000000000;;						Value: "FROM_SECRET",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "p_DUPE_TEST",
0000000000000000000000000000000000000000;;						Value: "SECRET",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "secret_missing",
0000000000000000000000000000000000000000;;				ns:   "test1",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					EnvFrom: []v1.EnvFromSource{
0000000000000000000000000000000000000000;;						{SecretRef: &v1.SecretEnvSource{LocalObjectReference: v1.LocalObjectReference{Name: "test-secret"}}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				masterServiceNs: "nothing",
0000000000000000000000000000000000000000;;				expectedError:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "secret_missing_optional",
0000000000000000000000000000000000000000;;				ns:   "test",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					EnvFrom: []v1.EnvFromSource{
0000000000000000000000000000000000000000;;						{SecretRef: &v1.SecretEnvSource{
0000000000000000000000000000000000000000;;							LocalObjectReference: v1.LocalObjectReference{Name: "missing-secret"},
0000000000000000000000000000000000000000;;							Optional:             &trueVal}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				masterServiceNs: "nothing",
0000000000000000000000000000000000000000;;				expectedEnvs:    nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "secret_invalid_keys",
0000000000000000000000000000000000000000;;				ns:   "test",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					EnvFrom: []v1.EnvFromSource{
0000000000000000000000000000000000000000;;						{SecretRef: &v1.SecretEnvSource{LocalObjectReference: v1.LocalObjectReference{Name: "test-secret"}}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				masterServiceNs: "nothing",
0000000000000000000000000000000000000000;;				secret: &v1.Secret{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Namespace: "test1",
0000000000000000000000000000000000000000;;						Name:      "test-secret",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Data: map[string][]byte{
0000000000000000000000000000000000000000;;						"1234": []byte("abc"),
0000000000000000000000000000000000000000;;						"1z":   []byte("abc"),
0000000000000000000000000000000000000000;;						"key":  []byte("value"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedEnvs: []kubecontainer.EnvVar{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "key",
0000000000000000000000000000000000000000;;						Value: "value",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedEvent: "Warning InvalidEnvironmentVariableNames Keys [1234, 1z] from the EnvFrom secret test/test-secret were skipped since they are considered invalid environment variable names.",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "secret_invalid_keys_valid",
0000000000000000000000000000000000000000;;				ns:   "test",
0000000000000000000000000000000000000000;;				container: &v1.Container{
0000000000000000000000000000000000000000;;					EnvFrom: []v1.EnvFromSource{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Prefix:    "p_",
0000000000000000000000000000000000000000;;							SecretRef: &v1.SecretEnvSource{LocalObjectReference: v1.LocalObjectReference{Name: "test-secret"}},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				masterServiceNs: "",
0000000000000000000000000000000000000000;;				secret: &v1.Secret{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Namespace: "test1",
0000000000000000000000000000000000000000;;						Name:      "test-secret",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Data: map[string][]byte{
0000000000000000000000000000000000000000;;						"1234": []byte("abc"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedEnvs: []kubecontainer.EnvVar{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "p_1234",
0000000000000000000000000000000000000000;;						Value: "abc",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			fakeRecorder := record.NewFakeRecorder(1)
0000000000000000000000000000000000000000;;			testKubelet := newTestKubelet(t, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;			testKubelet.kubelet.recorder = fakeRecorder
0000000000000000000000000000000000000000;;			defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;			kl := testKubelet.kubelet
0000000000000000000000000000000000000000;;			kl.masterServiceNamespace = tc.masterServiceNs
0000000000000000000000000000000000000000;;			if tc.nilLister {
0000000000000000000000000000000000000000;;				kl.serviceLister = nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				kl.serviceLister = testServiceLister{services}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			testKubelet.fakeKubeClient.AddReactor("get", "configmaps", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				if tc.configMap == nil {
0000000000000000000000000000000000000000;;					err = apierrors.NewNotFound(action.GetResource().GroupResource(), "configmap-name")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, tc.configMap, err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			testKubelet.fakeKubeClient.AddReactor("get", "secrets", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				if tc.secret == nil {
0000000000000000000000000000000000000000;;					err = apierrors.NewNotFound(action.GetResource().GroupResource(), "secret-name")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, tc.secret, err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			testKubelet.fakeKubeClient.AddReactor("get", "secrets", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				if tc.secret == nil {
0000000000000000000000000000000000000000;;					err = errors.New("no secret defined")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, tc.secret, err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			testPod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: tc.ns,
0000000000000000000000000000000000000000;;					Name:      "dapi-test-pod-name",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					ServiceAccountName: "special",
0000000000000000000000000000000000000000;;					NodeName:           "node-name",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podIP := "1.2.3.4"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			result, err := kl.makeEnvironmentVariables(testPod, tc.container, podIP)
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case e := <-fakeRecorder.Events:
0000000000000000000000000000000000000000;;				assert.Equal(t, tc.expectedEvent, e)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				assert.Equal(t, "", tc.expectedEvent)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tc.expectedError {
0000000000000000000000000000000000000000;;				assert.Error(t, err, tc.name)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				assert.NoError(t, err, "[%s]", tc.name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				sort.Sort(envs(result))
0000000000000000000000000000000000000000;;				sort.Sort(envs(tc.expectedEnvs))
0000000000000000000000000000000000000000;;				assert.Equal(t, tc.expectedEnvs, result, "[%s] env entries", tc.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitingState(cName string) v1.ContainerStatus {
0000000000000000000000000000000000000000;;		return v1.ContainerStatus{
0000000000000000000000000000000000000000;;			Name: cName,
0000000000000000000000000000000000000000;;			State: v1.ContainerState{
0000000000000000000000000000000000000000;;				Waiting: &v1.ContainerStateWaiting{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func waitingStateWithLastTermination(cName string) v1.ContainerStatus {
0000000000000000000000000000000000000000;;		return v1.ContainerStatus{
0000000000000000000000000000000000000000;;			Name: cName,
0000000000000000000000000000000000000000;;			State: v1.ContainerState{
0000000000000000000000000000000000000000;;				Waiting: &v1.ContainerStateWaiting{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			LastTerminationState: v1.ContainerState{
0000000000000000000000000000000000000000;;				Terminated: &v1.ContainerStateTerminated{
0000000000000000000000000000000000000000;;					ExitCode: 0,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func runningState(cName string) v1.ContainerStatus {
0000000000000000000000000000000000000000;;		return v1.ContainerStatus{
0000000000000000000000000000000000000000;;			Name: cName,
0000000000000000000000000000000000000000;;			State: v1.ContainerState{
0000000000000000000000000000000000000000;;				Running: &v1.ContainerStateRunning{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func stoppedState(cName string) v1.ContainerStatus {
0000000000000000000000000000000000000000;;		return v1.ContainerStatus{
0000000000000000000000000000000000000000;;			Name: cName,
0000000000000000000000000000000000000000;;			State: v1.ContainerState{
0000000000000000000000000000000000000000;;				Terminated: &v1.ContainerStateTerminated{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func succeededState(cName string) v1.ContainerStatus {
0000000000000000000000000000000000000000;;		return v1.ContainerStatus{
0000000000000000000000000000000000000000;;			Name: cName,
0000000000000000000000000000000000000000;;			State: v1.ContainerState{
0000000000000000000000000000000000000000;;				Terminated: &v1.ContainerStateTerminated{
0000000000000000000000000000000000000000;;					ExitCode: 0,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func failedState(cName string) v1.ContainerStatus {
0000000000000000000000000000000000000000;;		return v1.ContainerStatus{
0000000000000000000000000000000000000000;;			Name: cName,
0000000000000000000000000000000000000000;;			State: v1.ContainerState{
0000000000000000000000000000000000000000;;				Terminated: &v1.ContainerStateTerminated{
0000000000000000000000000000000000000000;;					ExitCode: -1,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodPhaseWithRestartAlways(t *testing.T) {
0000000000000000000000000000000000000000;;		desiredState := v1.PodSpec{
0000000000000000000000000000000000000000;;			NodeName: "machine",
0000000000000000000000000000000000000000;;			Containers: []v1.Container{
0000000000000000000000000000000000000000;;				{Name: "containerA"},
0000000000000000000000000000000000000000;;				{Name: "containerB"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			RestartPolicy: v1.RestartPolicyAlways,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod    *v1.Pod
0000000000000000000000000000000000000000;;			status v1.PodPhase
0000000000000000000000000000000000000000;;			test   string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{&v1.Pod{Spec: desiredState, Status: v1.PodStatus{}}, v1.PodPending, "waiting"},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Pod{
0000000000000000000000000000000000000000;;					Spec: desiredState,
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						ContainerStatuses: []v1.ContainerStatus{
0000000000000000000000000000000000000000;;							runningState("containerA"),
0000000000000000000000000000000000000000;;							runningState("containerB"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				v1.PodRunning,
0000000000000000000000000000000000000000;;				"all running",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Pod{
0000000000000000000000000000000000000000;;					Spec: desiredState,
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						ContainerStatuses: []v1.ContainerStatus{
0000000000000000000000000000000000000000;;							stoppedState("containerA"),
0000000000000000000000000000000000000000;;							stoppedState("containerB"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				v1.PodRunning,
0000000000000000000000000000000000000000;;				"all stopped with restart always",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Pod{
0000000000000000000000000000000000000000;;					Spec: desiredState,
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						ContainerStatuses: []v1.ContainerStatus{
0000000000000000000000000000000000000000;;							runningState("containerA"),
0000000000000000000000000000000000000000;;							stoppedState("containerB"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				v1.PodRunning,
0000000000000000000000000000000000000000;;				"mixed state #1 with restart always",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Pod{
0000000000000000000000000000000000000000;;					Spec: desiredState,
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						ContainerStatuses: []v1.ContainerStatus{
0000000000000000000000000000000000000000;;							runningState("containerA"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				v1.PodPending,
0000000000000000000000000000000000000000;;				"mixed state #2 with restart always",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Pod{
0000000000000000000000000000000000000000;;					Spec: desiredState,
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						ContainerStatuses: []v1.ContainerStatus{
0000000000000000000000000000000000000000;;							runningState("containerA"),
0000000000000000000000000000000000000000;;							waitingState("containerB"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				v1.PodPending,
0000000000000000000000000000000000000000;;				"mixed state #3 with restart always",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Pod{
0000000000000000000000000000000000000000;;					Spec: desiredState,
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						ContainerStatuses: []v1.ContainerStatus{
0000000000000000000000000000000000000000;;							runningState("containerA"),
0000000000000000000000000000000000000000;;							waitingStateWithLastTermination("containerB"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				v1.PodRunning,
0000000000000000000000000000000000000000;;				"backoff crashloop container with restart always",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			status := GetPhase(&test.pod.Spec, test.pod.Status.ContainerStatuses)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.status, status, "[test %s]", test.test)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodPhaseWithRestartNever(t *testing.T) {
0000000000000000000000000000000000000000;;		desiredState := v1.PodSpec{
0000000000000000000000000000000000000000;;			NodeName: "machine",
0000000000000000000000000000000000000000;;			Containers: []v1.Container{
0000000000000000000000000000000000000000;;				{Name: "containerA"},
0000000000000000000000000000000000000000;;				{Name: "containerB"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod    *v1.Pod
0000000000000000000000000000000000000000;;			status v1.PodPhase
0000000000000000000000000000000000000000;;			test   string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{&v1.Pod{Spec: desiredState, Status: v1.PodStatus{}}, v1.PodPending, "waiting"},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Pod{
0000000000000000000000000000000000000000;;					Spec: desiredState,
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						ContainerStatuses: []v1.ContainerStatus{
0000000000000000000000000000000000000000;;							runningState("containerA"),
0000000000000000000000000000000000000000;;							runningState("containerB"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				v1.PodRunning,
0000000000000000000000000000000000000000;;				"all running with restart never",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Pod{
0000000000000000000000000000000000000000;;					Spec: desiredState,
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						ContainerStatuses: []v1.ContainerStatus{
0000000000000000000000000000000000000000;;							succeededState("containerA"),
0000000000000000000000000000000000000000;;							succeededState("containerB"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				v1.PodSucceeded,
0000000000000000000000000000000000000000;;				"all succeeded with restart never",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Pod{
0000000000000000000000000000000000000000;;					Spec: desiredState,
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						ContainerStatuses: []v1.ContainerStatus{
0000000000000000000000000000000000000000;;							failedState("containerA"),
0000000000000000000000000000000000000000;;							failedState("containerB"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				v1.PodFailed,
0000000000000000000000000000000000000000;;				"all failed with restart never",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Pod{
0000000000000000000000000000000000000000;;					Spec: desiredState,
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						ContainerStatuses: []v1.ContainerStatus{
0000000000000000000000000000000000000000;;							runningState("containerA"),
0000000000000000000000000000000000000000;;							succeededState("containerB"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				v1.PodRunning,
0000000000000000000000000000000000000000;;				"mixed state #1 with restart never",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Pod{
0000000000000000000000000000000000000000;;					Spec: desiredState,
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						ContainerStatuses: []v1.ContainerStatus{
0000000000000000000000000000000000000000;;							runningState("containerA"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				v1.PodPending,
0000000000000000000000000000000000000000;;				"mixed state #2 with restart never",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Pod{
0000000000000000000000000000000000000000;;					Spec: desiredState,
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						ContainerStatuses: []v1.ContainerStatus{
0000000000000000000000000000000000000000;;							runningState("containerA"),
0000000000000000000000000000000000000000;;							waitingState("containerB"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				v1.PodPending,
0000000000000000000000000000000000000000;;				"mixed state #3 with restart never",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			status := GetPhase(&test.pod.Spec, test.pod.Status.ContainerStatuses)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.status, status, "[test %s]", test.test)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodPhaseWithRestartOnFailure(t *testing.T) {
0000000000000000000000000000000000000000;;		desiredState := v1.PodSpec{
0000000000000000000000000000000000000000;;			NodeName: "machine",
0000000000000000000000000000000000000000;;			Containers: []v1.Container{
0000000000000000000000000000000000000000;;				{Name: "containerA"},
0000000000000000000000000000000000000000;;				{Name: "containerB"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			RestartPolicy: v1.RestartPolicyOnFailure,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod    *v1.Pod
0000000000000000000000000000000000000000;;			status v1.PodPhase
0000000000000000000000000000000000000000;;			test   string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{&v1.Pod{Spec: desiredState, Status: v1.PodStatus{}}, v1.PodPending, "waiting"},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Pod{
0000000000000000000000000000000000000000;;					Spec: desiredState,
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						ContainerStatuses: []v1.ContainerStatus{
0000000000000000000000000000000000000000;;							runningState("containerA"),
0000000000000000000000000000000000000000;;							runningState("containerB"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				v1.PodRunning,
0000000000000000000000000000000000000000;;				"all running with restart onfailure",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Pod{
0000000000000000000000000000000000000000;;					Spec: desiredState,
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						ContainerStatuses: []v1.ContainerStatus{
0000000000000000000000000000000000000000;;							succeededState("containerA"),
0000000000000000000000000000000000000000;;							succeededState("containerB"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				v1.PodSucceeded,
0000000000000000000000000000000000000000;;				"all succeeded with restart onfailure",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Pod{
0000000000000000000000000000000000000000;;					Spec: desiredState,
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						ContainerStatuses: []v1.ContainerStatus{
0000000000000000000000000000000000000000;;							failedState("containerA"),
0000000000000000000000000000000000000000;;							failedState("containerB"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				v1.PodRunning,
0000000000000000000000000000000000000000;;				"all failed with restart never",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Pod{
0000000000000000000000000000000000000000;;					Spec: desiredState,
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						ContainerStatuses: []v1.ContainerStatus{
0000000000000000000000000000000000000000;;							runningState("containerA"),
0000000000000000000000000000000000000000;;							succeededState("containerB"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				v1.PodRunning,
0000000000000000000000000000000000000000;;				"mixed state #1 with restart onfailure",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Pod{
0000000000000000000000000000000000000000;;					Spec: desiredState,
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						ContainerStatuses: []v1.ContainerStatus{
0000000000000000000000000000000000000000;;							runningState("containerA"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				v1.PodPending,
0000000000000000000000000000000000000000;;				"mixed state #2 with restart onfailure",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Pod{
0000000000000000000000000000000000000000;;					Spec: desiredState,
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						ContainerStatuses: []v1.ContainerStatus{
0000000000000000000000000000000000000000;;							runningState("containerA"),
0000000000000000000000000000000000000000;;							waitingState("containerB"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				v1.PodPending,
0000000000000000000000000000000000000000;;				"mixed state #3 with restart onfailure",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Pod{
0000000000000000000000000000000000000000;;					Spec: desiredState,
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						ContainerStatuses: []v1.ContainerStatus{
0000000000000000000000000000000000000000;;							runningState("containerA"),
0000000000000000000000000000000000000000;;							waitingStateWithLastTermination("containerB"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				v1.PodRunning,
0000000000000000000000000000000000000000;;				"backoff crashloop container with restart onfailure",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			status := GetPhase(&test.pod.Spec, test.pod.Status.ContainerStatuses)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.status, status, "[test %s]", test.test)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeReadWriteCloser struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeReadWriteCloser) Write(data []byte) (int, error) {
0000000000000000000000000000000000000000;;		return 0, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeReadWriteCloser) Read(data []byte) (int, error) {
0000000000000000000000000000000000000000;;		return 0, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeReadWriteCloser) Close() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestExec(t *testing.T) {
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			podName                = "podFoo"
0000000000000000000000000000000000000000;;			podNamespace           = "nsFoo"
0000000000000000000000000000000000000000;;			podUID       types.UID = "12345678"
0000000000000000000000000000000000000000;;			containerID            = "containerFoo"
0000000000000000000000000000000000000000;;			tty                    = true
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			podFullName = kubecontainer.GetPodFullName(podWithUidNameNs(podUID, podName, podNamespace))
0000000000000000000000000000000000000000;;			command     = []string{"ls"}
0000000000000000000000000000000000000000;;			stdin       = &bytes.Buffer{}
0000000000000000000000000000000000000000;;			stdout      = &fakeReadWriteCloser{}
0000000000000000000000000000000000000000;;			stderr      = &fakeReadWriteCloser{}
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testcases := []struct {
0000000000000000000000000000000000000000;;			description string
0000000000000000000000000000000000000000;;			podFullName string
0000000000000000000000000000000000000000;;			container   string
0000000000000000000000000000000000000000;;			expectError bool
0000000000000000000000000000000000000000;;		}{{
0000000000000000000000000000000000000000;;			description: "success case",
0000000000000000000000000000000000000000;;			podFullName: podFullName,
0000000000000000000000000000000000000000;;			container:   containerID,
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			description: "no such pod",
0000000000000000000000000000000000000000;;			podFullName: "bar" + podFullName,
0000000000000000000000000000000000000000;;			container:   containerID,
0000000000000000000000000000000000000000;;			expectError: true,
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			description: "no such container",
0000000000000000000000000000000000000000;;			podFullName: podFullName,
0000000000000000000000000000000000000000;;			container:   "containerBar",
0000000000000000000000000000000000000000;;			expectError: true,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testcases {
0000000000000000000000000000000000000000;;			testKubelet := newTestKubelet(t, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;			defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;			kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;			testKubelet.fakeRuntime.PodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;				{Pod: &kubecontainer.Pod{
0000000000000000000000000000000000000000;;					ID:        podUID,
0000000000000000000000000000000000000000;;					Name:      podName,
0000000000000000000000000000000000000000;;					Namespace: podNamespace,
0000000000000000000000000000000000000000;;					Containers: []*kubecontainer.Container{
0000000000000000000000000000000000000000;;						{Name: containerID,
0000000000000000000000000000000000000000;;							ID: kubecontainer.ContainerID{Type: "test", ID: containerID},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{ // No streaming case
0000000000000000000000000000000000000000;;				description := "no streaming - " + tc.description
0000000000000000000000000000000000000000;;				redirect, err := kubelet.GetExec(tc.podFullName, podUID, tc.container, command, remotecommand.Options{})
0000000000000000000000000000000000000000;;				assert.Error(t, err, description)
0000000000000000000000000000000000000000;;				assert.Nil(t, redirect, description)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = kubelet.ExecInContainer(tc.podFullName, podUID, tc.container, command, stdin, stdout, stderr, tty, nil, 0)
0000000000000000000000000000000000000000;;				assert.Error(t, err, description)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			{ // Direct streaming case
0000000000000000000000000000000000000000;;				description := "direct streaming - " + tc.description
0000000000000000000000000000000000000000;;				fakeRuntime := &containertest.FakeDirectStreamingRuntime{FakeRuntime: testKubelet.fakeRuntime}
0000000000000000000000000000000000000000;;				kubelet.containerRuntime = fakeRuntime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				redirect, err := kubelet.GetExec(tc.podFullName, podUID, tc.container, command, remotecommand.Options{})
0000000000000000000000000000000000000000;;				assert.NoError(t, err, description)
0000000000000000000000000000000000000000;;				assert.Nil(t, redirect, description)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = kubelet.ExecInContainer(tc.podFullName, podUID, tc.container, command, stdin, stdout, stderr, tty, nil, 0)
0000000000000000000000000000000000000000;;				if tc.expectError {
0000000000000000000000000000000000000000;;					assert.Error(t, err, description)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					assert.NoError(t, err, description)
0000000000000000000000000000000000000000;;					assert.Equal(t, fakeRuntime.Args.ContainerID.ID, containerID, description+": ID")
0000000000000000000000000000000000000000;;					assert.Equal(t, fakeRuntime.Args.Cmd, command, description+": Command")
0000000000000000000000000000000000000000;;					assert.Equal(t, fakeRuntime.Args.Stdin, stdin, description+": Stdin")
0000000000000000000000000000000000000000;;					assert.Equal(t, fakeRuntime.Args.Stdout, stdout, description+": Stdout")
0000000000000000000000000000000000000000;;					assert.Equal(t, fakeRuntime.Args.Stderr, stderr, description+": Stderr")
0000000000000000000000000000000000000000;;					assert.Equal(t, fakeRuntime.Args.TTY, tty, description+": TTY")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			{ // Indirect streaming case
0000000000000000000000000000000000000000;;				description := "indirect streaming - " + tc.description
0000000000000000000000000000000000000000;;				fakeRuntime := &containertest.FakeIndirectStreamingRuntime{FakeRuntime: testKubelet.fakeRuntime}
0000000000000000000000000000000000000000;;				kubelet.containerRuntime = fakeRuntime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				redirect, err := kubelet.GetExec(tc.podFullName, podUID, tc.container, command, remotecommand.Options{})
0000000000000000000000000000000000000000;;				if tc.expectError {
0000000000000000000000000000000000000000;;					assert.Error(t, err, description)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					assert.NoError(t, err, description)
0000000000000000000000000000000000000000;;					assert.Equal(t, containertest.FakeHost, redirect.Host, description+": redirect")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = kubelet.ExecInContainer(tc.podFullName, podUID, tc.container, command, stdin, stdout, stderr, tty, nil, 0)
0000000000000000000000000000000000000000;;				assert.Error(t, err, description)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPortForward(t *testing.T) {
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			podName                = "podFoo"
0000000000000000000000000000000000000000;;			podNamespace           = "nsFoo"
0000000000000000000000000000000000000000;;			podUID       types.UID = "12345678"
0000000000000000000000000000000000000000;;			port         int32     = 5000
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			stream = &fakeReadWriteCloser{}
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testcases := []struct {
0000000000000000000000000000000000000000;;			description string
0000000000000000000000000000000000000000;;			podName     string
0000000000000000000000000000000000000000;;			expectError bool
0000000000000000000000000000000000000000;;		}{{
0000000000000000000000000000000000000000;;			description: "success case",
0000000000000000000000000000000000000000;;			podName:     podName,
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			description: "no such pod",
0000000000000000000000000000000000000000;;			podName:     "bar",
0000000000000000000000000000000000000000;;			expectError: true,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testcases {
0000000000000000000000000000000000000000;;			testKubelet := newTestKubelet(t, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;			defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;			kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;			testKubelet.fakeRuntime.PodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;				{Pod: &kubecontainer.Pod{
0000000000000000000000000000000000000000;;					ID:        podUID,
0000000000000000000000000000000000000000;;					Name:      podName,
0000000000000000000000000000000000000000;;					Namespace: podNamespace,
0000000000000000000000000000000000000000;;					Containers: []*kubecontainer.Container{
0000000000000000000000000000000000000000;;						{Name: "foo",
0000000000000000000000000000000000000000;;							ID: kubecontainer.ContainerID{Type: "test", ID: "foo"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			podFullName := kubecontainer.GetPodFullName(podWithUidNameNs(podUID, tc.podName, podNamespace))
0000000000000000000000000000000000000000;;			{ // No streaming case
0000000000000000000000000000000000000000;;				description := "no streaming - " + tc.description
0000000000000000000000000000000000000000;;				redirect, err := kubelet.GetPortForward(tc.podName, podNamespace, podUID, portforward.V4Options{})
0000000000000000000000000000000000000000;;				assert.Error(t, err, description)
0000000000000000000000000000000000000000;;				assert.Nil(t, redirect, description)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = kubelet.PortForward(podFullName, podUID, port, stream)
0000000000000000000000000000000000000000;;				assert.Error(t, err, description)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			{ // Direct streaming case
0000000000000000000000000000000000000000;;				description := "direct streaming - " + tc.description
0000000000000000000000000000000000000000;;				fakeRuntime := &containertest.FakeDirectStreamingRuntime{FakeRuntime: testKubelet.fakeRuntime}
0000000000000000000000000000000000000000;;				kubelet.containerRuntime = fakeRuntime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				redirect, err := kubelet.GetPortForward(tc.podName, podNamespace, podUID, portforward.V4Options{})
0000000000000000000000000000000000000000;;				assert.NoError(t, err, description)
0000000000000000000000000000000000000000;;				assert.Nil(t, redirect, description)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = kubelet.PortForward(podFullName, podUID, port, stream)
0000000000000000000000000000000000000000;;				if tc.expectError {
0000000000000000000000000000000000000000;;					assert.Error(t, err, description)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					assert.NoError(t, err, description)
0000000000000000000000000000000000000000;;					require.Equal(t, fakeRuntime.Args.Pod.ID, podUID, description+": Pod UID")
0000000000000000000000000000000000000000;;					require.Equal(t, fakeRuntime.Args.Port, port, description+": Port")
0000000000000000000000000000000000000000;;					require.Equal(t, fakeRuntime.Args.Stream, stream, description+": stream")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			{ // Indirect streaming case
0000000000000000000000000000000000000000;;				description := "indirect streaming - " + tc.description
0000000000000000000000000000000000000000;;				fakeRuntime := &containertest.FakeIndirectStreamingRuntime{FakeRuntime: testKubelet.fakeRuntime}
0000000000000000000000000000000000000000;;				kubelet.containerRuntime = fakeRuntime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				redirect, err := kubelet.GetPortForward(tc.podName, podNamespace, podUID, portforward.V4Options{})
0000000000000000000000000000000000000000;;				if tc.expectError {
0000000000000000000000000000000000000000;;					assert.Error(t, err, description)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					assert.NoError(t, err, description)
0000000000000000000000000000000000000000;;					assert.Equal(t, containertest.FakeHost, redirect.Host, description+": redirect")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = kubelet.PortForward(podFullName, podUID, port, stream)
0000000000000000000000000000000000000000;;				assert.Error(t, err, description)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tests that identify the host port conflicts are detected correctly.
0000000000000000000000000000000000000000;;	func TestGetHostPortConflicts(t *testing.T) {
0000000000000000000000000000000000000000;;		pods := []*v1.Pod{
0000000000000000000000000000000000000000;;			{Spec: v1.PodSpec{Containers: []v1.Container{{Ports: []v1.ContainerPort{{HostPort: 80}}}}}},
0000000000000000000000000000000000000000;;			{Spec: v1.PodSpec{Containers: []v1.Container{{Ports: []v1.ContainerPort{{HostPort: 81}}}}}},
0000000000000000000000000000000000000000;;			{Spec: v1.PodSpec{Containers: []v1.Container{{Ports: []v1.ContainerPort{{HostPort: 82}}}}}},
0000000000000000000000000000000000000000;;			{Spec: v1.PodSpec{Containers: []v1.Container{{Ports: []v1.ContainerPort{{HostPort: 83}}}}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Pods should not cause any conflict.
0000000000000000000000000000000000000000;;		assert.False(t, hasHostPortConflicts(pods), "Should not have port conflicts")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{Containers: []v1.Container{{Ports: []v1.ContainerPort{{HostPort: 81}}}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// The new pod should cause conflict and be reported.
0000000000000000000000000000000000000000;;		pods = append(pods, expected)
0000000000000000000000000000000000000000;;		assert.True(t, hasHostPortConflicts(pods), "Should have port conflicts")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHasHostMountPVC(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			pvError       error
0000000000000000000000000000000000000000;;			pvcError      error
0000000000000000000000000000000000000000;;			expected      bool
0000000000000000000000000000000000000000;;			podHasPVC     bool
0000000000000000000000000000000000000000;;			pvcIsHostPath bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"no pvc": {podHasPVC: false, expected: false},
0000000000000000000000000000000000000000;;			"error fetching pvc": {
0000000000000000000000000000000000000000;;				podHasPVC: true,
0000000000000000000000000000000000000000;;				pvcError:  fmt.Errorf("foo"),
0000000000000000000000000000000000000000;;				expected:  false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"error fetching pv": {
0000000000000000000000000000000000000000;;				podHasPVC: true,
0000000000000000000000000000000000000000;;				pvError:   fmt.Errorf("foo"),
0000000000000000000000000000000000000000;;				expected:  false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"host path pvc": {
0000000000000000000000000000000000000000;;				podHasPVC:     true,
0000000000000000000000000000000000000000;;				pvcIsHostPath: true,
0000000000000000000000000000000000000000;;				expected:      true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"non host path pvc": {
0000000000000000000000000000000000000000;;				podHasPVC:     true,
0000000000000000000000000000000000000000;;				pvcIsHostPath: false,
0000000000000000000000000000000000000000;;				expected:      false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			testKubelet := newTestKubelet(t, false)
0000000000000000000000000000000000000000;;			defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			volumeToReturn := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;				Spec: v1.PersistentVolumeSpec{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v.podHasPVC {
0000000000000000000000000000000000000000;;				pod.Spec.Volumes = []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							PersistentVolumeClaim: &v1.PersistentVolumeClaimVolumeSource{},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if v.pvcIsHostPath {
0000000000000000000000000000000000000000;;					volumeToReturn.Spec.PersistentVolumeSource = v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						HostPath: &v1.HostPathVolumeSource{},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			testKubelet.fakeKubeClient.AddReactor("get", "persistentvolumeclaims", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;				return true, &v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;					Spec: v1.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;						VolumeName: "foo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}, v.pvcError
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			testKubelet.fakeKubeClient.AddReactor("get", "persistentvolumes", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;				return true, volumeToReturn, v.pvError
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			actual := testKubelet.kubelet.hasHostMountPVC(pod)
0000000000000000000000000000000000000000;;			if actual != v.expected {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected %t but got %t", k, v.expected, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHasNonNamespacedCapability(t *testing.T) {
0000000000000000000000000000000000000000;;		createPodWithCap := func(caps []v1.Capability) *v1.Pod {
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{{}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(caps) > 0 {
0000000000000000000000000000000000000000;;				pod.Spec.Containers[0].SecurityContext = &v1.SecurityContext{
0000000000000000000000000000000000000000;;					Capabilities: &v1.Capabilities{
0000000000000000000000000000000000000000;;						Add: caps,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nilCaps := createPodWithCap([]v1.Capability{v1.Capability("foo")})
0000000000000000000000000000000000000000;;		nilCaps.Spec.Containers[0].SecurityContext = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			pod      *v1.Pod
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"nil security contxt":           {createPodWithCap(nil), false},
0000000000000000000000000000000000000000;;			"nil caps":                      {nilCaps, false},
0000000000000000000000000000000000000000;;			"namespaced cap":                {createPodWithCap([]v1.Capability{v1.Capability("foo")}), false},
0000000000000000000000000000000000000000;;			"non-namespaced cap MKNOD":      {createPodWithCap([]v1.Capability{v1.Capability("MKNOD")}), true},
0000000000000000000000000000000000000000;;			"non-namespaced cap SYS_TIME":   {createPodWithCap([]v1.Capability{v1.Capability("SYS_TIME")}), true},
0000000000000000000000000000000000000000;;			"non-namespaced cap SYS_MODULE": {createPodWithCap([]v1.Capability{v1.Capability("SYS_MODULE")}), true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			actual := hasNonNamespacedCapability(v.pod)
0000000000000000000000000000000000000000;;			if actual != v.expected {
0000000000000000000000000000000000000000;;				t.Errorf("%s failed, expected %t but got %t", k, v.expected, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHasHostVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							HostPath: &v1.HostPathVolumeSource{},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := hasHostVolume(pod)
0000000000000000000000000000000000000000;;		if !result {
0000000000000000000000000000000000000000;;			t.Errorf("expected host volume to enable host user namespace")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod.Spec.Volumes[0].VolumeSource.HostPath = nil
0000000000000000000000000000000000000000;;		result = hasHostVolume(pod)
0000000000000000000000000000000000000000;;		if result {
0000000000000000000000000000000000000000;;			t.Errorf("expected nil host volume to not enable host user namespace")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHasHostNamespace(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			ps       v1.PodSpec
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"nil psc": {
0000000000000000000000000000000000000000;;				ps:       v1.PodSpec{},
0000000000000000000000000000000000000000;;				expected: false},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"host pid true": {
0000000000000000000000000000000000000000;;				ps: v1.PodSpec{
0000000000000000000000000000000000000000;;					HostPID:         true,
0000000000000000000000000000000000000000;;					SecurityContext: &v1.PodSecurityContext{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"host ipc true": {
0000000000000000000000000000000000000000;;				ps: v1.PodSpec{
0000000000000000000000000000000000000000;;					HostIPC:         true,
0000000000000000000000000000000000000000;;					SecurityContext: &v1.PodSecurityContext{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"host net true": {
0000000000000000000000000000000000000000;;				ps: v1.PodSpec{
0000000000000000000000000000000000000000;;					HostNetwork:     true,
0000000000000000000000000000000000000000;;					SecurityContext: &v1.PodSecurityContext{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no host ns": {
0000000000000000000000000000000000000000;;				ps: v1.PodSpec{
0000000000000000000000000000000000000000;;					SecurityContext: &v1.PodSecurityContext{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				Spec: v.ps,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			actual := hasHostNamespace(pod)
0000000000000000000000000000000000000000;;			if actual != v.expected {
0000000000000000000000000000000000000000;;				t.Errorf("%s failed, expected %t but got %t", k, v.expected, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTruncatePodHostname(t *testing.T) {
0000000000000000000000000000000000000000;;		for c, test := range map[string]struct {
0000000000000000000000000000000000000000;;			input  string
0000000000000000000000000000000000000000;;			output string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"valid hostname": {
0000000000000000000000000000000000000000;;				input:  "test.pod.hostname",
0000000000000000000000000000000000000000;;				output: "test.pod.hostname",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"too long hostname": {
0000000000000000000000000000000000000000;;				input:  "1234567.1234567.1234567.1234567.1234567.1234567.1234567.1234567.1234567.", // 8*9=72 chars
0000000000000000000000000000000000000000;;				output: "1234567.1234567.1234567.1234567.1234567.1234567.1234567.1234567",          //8*8-1=63 chars
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"hostname end with .": {
0000000000000000000000000000000000000000;;				input:  "1234567.1234567.1234567.1234567.1234567.1234567.1234567.123456.1234567.", // 8*9-1=71 chars
0000000000000000000000000000000000000000;;				output: "1234567.1234567.1234567.1234567.1234567.1234567.1234567.123456",          //8*8-2=62 chars
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"hostname end with -": {
0000000000000000000000000000000000000000;;				input:  "1234567.1234567.1234567.1234567.1234567.1234567.1234567.123456-1234567.", // 8*9-1=71 chars
0000000000000000000000000000000000000000;;				output: "1234567.1234567.1234567.1234567.1234567.1234567.1234567.123456",          //8*8-2=62 chars
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			t.Logf("TestCase: %q", c)
0000000000000000000000000000000000000000;;			output, err := truncatePodHostnameIfNeeded("test-pod", test.input)
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.output, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
