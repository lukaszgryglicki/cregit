0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
8cbd509fa9e81a54c6d6023bfbd88bc3e817eea0;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// The limit on the number of buffered container deletion requests
0000000000000000000000000000000000000000;;		// This number is a bit arbitrary and may be adjusted in the future.
0000000000000000000000000000000000000000;;		containerDeletorBufferLimit = 50
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type containerStatusbyCreatedList []*kubecontainer.ContainerStatus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type podContainerDeletor struct {
0000000000000000000000000000000000000000;;		worker           chan<- kubecontainer.ContainerID
0000000000000000000000000000000000000000;;		containersToKeep int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a containerStatusbyCreatedList) Len() int           { return len(a) }
0000000000000000000000000000000000000000;;	func (a containerStatusbyCreatedList) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
0000000000000000000000000000000000000000;;	func (a containerStatusbyCreatedList) Less(i, j int) bool { return a[i].CreatedAt.After(a[j].CreatedAt) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPodContainerDeletor(runtime kubecontainer.Runtime, containersToKeep int) *podContainerDeletor {
0000000000000000000000000000000000000000;;		buffer := make(chan kubecontainer.ContainerID, containerDeletorBufferLimit)
0000000000000000000000000000000000000000;;		go wait.Until(func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case id := <-buffer:
0000000000000000000000000000000000000000;;					runtime.DeleteContainer(id)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}, 0, wait.NeverStop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &podContainerDeletor{
0000000000000000000000000000000000000000;;			worker:           buffer,
0000000000000000000000000000000000000000;;			containersToKeep: containersToKeep,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getContainersToDeleteInPod returns the exited containers in a pod whose name matches the name inferred from filterContainerId (if not empty), ordered by the creation time from the latest to the earliest.
0000000000000000000000000000000000000000;;	// If filterContainerId is empty, all dead containers in the pod are returned.
0000000000000000000000000000000000000000;;	func getContainersToDeleteInPod(filterContainerId string, podStatus *kubecontainer.PodStatus, containersToKeep int) containerStatusbyCreatedList {
0000000000000000000000000000000000000000;;		matchedContainer := func(filterContainerId string, podStatus *kubecontainer.PodStatus) *kubecontainer.ContainerStatus {
0000000000000000000000000000000000000000;;			if filterContainerId == "" {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, containerStatus := range podStatus.ContainerStatuses {
0000000000000000000000000000000000000000;;				if containerStatus.ID.ID == filterContainerId {
0000000000000000000000000000000000000000;;					return containerStatus
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}(filterContainerId, podStatus)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if filterContainerId != "" && matchedContainer == nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Container %q not found in pod's containers", filterContainerId)
0000000000000000000000000000000000000000;;			return containerStatusbyCreatedList{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find the exited containers whose name matches the name of the container with id being filterContainerId
0000000000000000000000000000000000000000;;		var candidates containerStatusbyCreatedList
0000000000000000000000000000000000000000;;		for _, containerStatus := range podStatus.ContainerStatuses {
0000000000000000000000000000000000000000;;			if containerStatus.State != kubecontainer.ContainerStateExited {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if matchedContainer == nil || matchedContainer.Name == containerStatus.Name {
0000000000000000000000000000000000000000;;				candidates = append(candidates, containerStatus)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(candidates) <= containersToKeep {
0000000000000000000000000000000000000000;;			return containerStatusbyCreatedList{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(candidates)
0000000000000000000000000000000000000000;;		return candidates[containersToKeep:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteContainersInPod issues container deletion requests for containers selected by getContainersToDeleteInPod.
0000000000000000000000000000000000000000;;	func (p *podContainerDeletor) deleteContainersInPod(filterContainerId string, podStatus *kubecontainer.PodStatus, removeAll bool) {
0000000000000000000000000000000000000000;;		containersToKeep := p.containersToKeep
0000000000000000000000000000000000000000;;		if removeAll {
0000000000000000000000000000000000000000;;			containersToKeep = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, candidate := range getContainersToDeleteInPod(filterContainerId, podStatus, containersToKeep) {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case p.worker <- candidate.ID:
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to issue the request to remove container %v", candidate.ID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
