0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
c7a5084b80c00afab2bb29dd678fe7f5eb511aba;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReasonCache(t *testing.T) {
0000000000000000000000000000000000000000;;		// Create test sync result
0000000000000000000000000000000000000000;;		syncResult := kubecontainer.PodSyncResult{}
0000000000000000000000000000000000000000;;		results := []*kubecontainer.SyncResult{
0000000000000000000000000000000000000000;;			// reason cache should be set for SyncResult with StartContainer action and error
0000000000000000000000000000000000000000;;			kubecontainer.NewSyncResult(kubecontainer.StartContainer, "container_1"),
0000000000000000000000000000000000000000;;			// reason cache should not be set for SyncResult with StartContainer action but without error
0000000000000000000000000000000000000000;;			kubecontainer.NewSyncResult(kubecontainer.StartContainer, "container_2"),
0000000000000000000000000000000000000000;;			// reason cache should not be set for SyncResult with other actions
0000000000000000000000000000000000000000;;			kubecontainer.NewSyncResult(kubecontainer.KillContainer, "container_3"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		results[0].Fail(kubecontainer.ErrRunContainer, "message_1")
0000000000000000000000000000000000000000;;		results[2].Fail(kubecontainer.ErrKillContainer, "message_3")
0000000000000000000000000000000000000000;;		syncResult.AddSyncResult(results...)
0000000000000000000000000000000000000000;;		uid := types.UID("pod_1")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reasonCache := NewReasonCache()
0000000000000000000000000000000000000000;;		reasonCache.Update(uid, syncResult)
0000000000000000000000000000000000000000;;		assertReasonInfo(t, reasonCache, uid, results[0], true)
0000000000000000000000000000000000000000;;		assertReasonInfo(t, reasonCache, uid, results[1], false)
0000000000000000000000000000000000000000;;		assertReasonInfo(t, reasonCache, uid, results[2], false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reasonCache.Remove(uid, results[0].Target.(string))
0000000000000000000000000000000000000000;;		assertReasonInfo(t, reasonCache, uid, results[0], false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func assertReasonInfo(t *testing.T, cache *ReasonCache, uid types.UID, result *kubecontainer.SyncResult, found bool) {
0000000000000000000000000000000000000000;;		name := result.Target.(string)
0000000000000000000000000000000000000000;;		actualReason, actualMessage, ok := cache.Get(uid, name)
0000000000000000000000000000000000000000;;		if ok && !found {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected cache hit: %v, %q", actualReason, actualMessage)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ok && found {
0000000000000000000000000000000000000000;;			t.Fatalf("corresponding reason info not found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		reason := result.Error
0000000000000000000000000000000000000000;;		message := result.Message
0000000000000000000000000000000000000000;;		if actualReason != reason || actualMessage != message {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v %q, got %v %q", reason, message, actualReason, actualMessage)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
