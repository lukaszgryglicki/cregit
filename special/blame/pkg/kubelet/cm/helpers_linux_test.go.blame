0000000000000000000000000000000000000000;;	// +build linux
75d6011d7e8bd4a3d1d3b459de58b7d2308ff98c;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getResourceList returns a ResourceList with the
0000000000000000000000000000000000000000;;	// specified cpu and memory resource values
0000000000000000000000000000000000000000;;	func getResourceList(cpu, memory string) v1.ResourceList {
0000000000000000000000000000000000000000;;		res := v1.ResourceList{}
0000000000000000000000000000000000000000;;		if cpu != "" {
0000000000000000000000000000000000000000;;			res[v1.ResourceCPU] = resource.MustParse(cpu)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if memory != "" {
0000000000000000000000000000000000000000;;			res[v1.ResourceMemory] = resource.MustParse(memory)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getResourceRequirements returns a ResourceRequirements object
0000000000000000000000000000000000000000;;	func getResourceRequirements(requests, limits v1.ResourceList) v1.ResourceRequirements {
0000000000000000000000000000000000000000;;		res := v1.ResourceRequirements{}
0000000000000000000000000000000000000000;;		res.Requests = requests
0000000000000000000000000000000000000000;;		res.Limits = limits
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestResourceConfigForPod(t *testing.T) {
0000000000000000000000000000000000000000;;		minShares := int64(MinShares)
0000000000000000000000000000000000000000;;		burstableShares := MilliCPUToShares(100)
0000000000000000000000000000000000000000;;		memoryQuantity := resource.MustParse("200Mi")
0000000000000000000000000000000000000000;;		burstableMemory := memoryQuantity.Value()
0000000000000000000000000000000000000000;;		burstablePartialShares := MilliCPUToShares(200)
0000000000000000000000000000000000000000;;		burstableQuota, burstablePeriod := MilliCPUToQuota(200)
0000000000000000000000000000000000000000;;		guaranteedShares := MilliCPUToShares(100)
0000000000000000000000000000000000000000;;		guaranteedQuota, guaranteedPeriod := MilliCPUToQuota(100)
0000000000000000000000000000000000000000;;		memoryQuantity = resource.MustParse("100Mi")
0000000000000000000000000000000000000000;;		guaranteedMemory := memoryQuantity.Value()
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			pod      *v1.Pod
0000000000000000000000000000000000000000;;			expected *ResourceConfig
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"besteffort": {
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Resources: getResourceRequirements(getResourceList("", ""), getResourceList("", "")),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: &ResourceConfig{CpuShares: &minShares},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"burstable-no-limits": {
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Resources: getResourceRequirements(getResourceList("100m", "100Mi"), getResourceList("", "")),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: &ResourceConfig{CpuShares: &burstableShares},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"burstable-with-limits": {
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Resources: getResourceRequirements(getResourceList("100m", "100Mi"), getResourceList("200m", "200Mi")),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: &ResourceConfig{CpuShares: &burstableShares, CpuQuota: &burstableQuota, CpuPeriod: &burstablePeriod, Memory: &burstableMemory},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"burstable-partial-limits": {
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Resources: getResourceRequirements(getResourceList("100m", "100Mi"), getResourceList("200m", "200Mi")),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Resources: getResourceRequirements(getResourceList("100m", "100Mi"), getResourceList("", "")),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: &ResourceConfig{CpuShares: &burstablePartialShares},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"guaranteed": {
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Resources: getResourceRequirements(getResourceList("100m", "100Mi"), getResourceList("100m", "100Mi")),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: &ResourceConfig{CpuShares: &guaranteedShares, CpuQuota: &guaranteedQuota, CpuPeriod: &guaranteedPeriod, Memory: &guaranteedMemory},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for testName, testCase := range testCases {
0000000000000000000000000000000000000000;;			actual := ResourceConfigForPod(testCase.pod)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(actual.CpuPeriod, testCase.expected.CpuPeriod) {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected result, test: %v, cpu period not as expected", testName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(actual.CpuQuota, testCase.expected.CpuQuota) {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected result, test: %v, cpu quota not as expected", testName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(actual.CpuShares, testCase.expected.CpuShares) {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected result, test: %v, cpu shares not as expected", testName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(actual.Memory, testCase.expected.Memory) {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected result, test: %v, memory not as expected", testName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMilliCPUToQuota(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			input  int64
0000000000000000000000000000000000000000;;			quota  int64
0000000000000000000000000000000000000000;;			period int64
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input:  int64(0),
0000000000000000000000000000000000000000;;				quota:  int64(0),
0000000000000000000000000000000000000000;;				period: int64(0),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input:  int64(5),
0000000000000000000000000000000000000000;;				quota:  int64(1000),
0000000000000000000000000000000000000000;;				period: int64(100000),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input:  int64(9),
0000000000000000000000000000000000000000;;				quota:  int64(1000),
0000000000000000000000000000000000000000;;				period: int64(100000),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input:  int64(10),
0000000000000000000000000000000000000000;;				quota:  int64(1000),
0000000000000000000000000000000000000000;;				period: int64(100000),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input:  int64(200),
0000000000000000000000000000000000000000;;				quota:  int64(20000),
0000000000000000000000000000000000000000;;				period: int64(100000),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input:  int64(500),
0000000000000000000000000000000000000000;;				quota:  int64(50000),
0000000000000000000000000000000000000000;;				period: int64(100000),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input:  int64(1000),
0000000000000000000000000000000000000000;;				quota:  int64(100000),
0000000000000000000000000000000000000000;;				period: int64(100000),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input:  int64(1500),
0000000000000000000000000000000000000000;;				quota:  int64(150000),
0000000000000000000000000000000000000000;;				period: int64(100000),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, testCase := range testCases {
0000000000000000000000000000000000000000;;			quota, period := MilliCPUToQuota(testCase.input)
0000000000000000000000000000000000000000;;			if quota != testCase.quota || period != testCase.period {
0000000000000000000000000000000000000000;;				t.Errorf("Input %v, expected quota %v period %v, but got quota %v period %v", testCase.input, testCase.quota, testCase.period, quota, period)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
