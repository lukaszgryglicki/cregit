0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
d6be995a7d00c65db5742a2cc897e6eb72c4a896;pkg/kubelet/container_manager.go[pkg/kubelet/container_manager.go][pkg/kubelet/cm/container_manager.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		// TODO: Migrate kubelet to either use its own internal objects or client library.
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		evictionapi "k8s.io/kubernetes/pkg/kubelet/eviction/api"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ActivePodsFunc func() []*v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Manages the containers running on a machine.
0000000000000000000000000000000000000000;;	type ContainerManager interface {
0000000000000000000000000000000000000000;;		// Runs the container manager's housekeeping.
0000000000000000000000000000000000000000;;		// - Ensures that the Docker daemon is in a container.
0000000000000000000000000000000000000000;;		// - Creates the system container where all non-containerized processes run.
0000000000000000000000000000000000000000;;		Start(*v1.Node, ActivePodsFunc) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns resources allocated to system cgroups in the machine.
0000000000000000000000000000000000000000;;		// These cgroups include the system and Kubernetes services.
0000000000000000000000000000000000000000;;		SystemCgroupsLimit() v1.ResourceList
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns a NodeConfig that is being used by the container manager.
0000000000000000000000000000000000000000;;		GetNodeConfig() NodeConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns internal Status.
0000000000000000000000000000000000000000;;		Status() Status
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NewPodContainerManager is a factory method which returns a podContainerManager object
0000000000000000000000000000000000000000;;		// Returns a noop implementation if qos cgroup hierarchy is not enabled
0000000000000000000000000000000000000000;;		NewPodContainerManager() PodContainerManager
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetMountedSubsystems returns the mounted cgroup subsystems on the node
0000000000000000000000000000000000000000;;		GetMountedSubsystems() *CgroupSubsystems
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetQOSContainersInfo returns the names of top level QoS containers
0000000000000000000000000000000000000000;;		GetQOSContainersInfo() QOSContainersInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetNodeAllocatable returns the amount of compute resources that have to be reserved from scheduling.
0000000000000000000000000000000000000000;;		GetNodeAllocatableReservation() v1.ResourceList
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetCapacity returns the amount of compute resources tracked by container manager available on the node.
0000000000000000000000000000000000000000;;		GetCapacity() v1.ResourceList
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UpdateQOSCgroups performs housekeeping updates to ensure that the top
0000000000000000000000000000000000000000;;		// level QoS containers have their desired state in a thread-safe way
0000000000000000000000000000000000000000;;		UpdateQOSCgroups() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NodeConfig struct {
0000000000000000000000000000000000000000;;		RuntimeCgroupsName    string
0000000000000000000000000000000000000000;;		SystemCgroupsName     string
0000000000000000000000000000000000000000;;		KubeletCgroupsName    string
0000000000000000000000000000000000000000;;		ContainerRuntime      string
0000000000000000000000000000000000000000;;		CgroupsPerQOS         bool
0000000000000000000000000000000000000000;;		CgroupRoot            string
0000000000000000000000000000000000000000;;		CgroupDriver          string
0000000000000000000000000000000000000000;;		ProtectKernelDefaults bool
0000000000000000000000000000000000000000;;		NodeAllocatableConfig
0000000000000000000000000000000000000000;;		ExperimentalQOSReserved map[v1.ResourceName]int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NodeAllocatableConfig struct {
0000000000000000000000000000000000000000;;		KubeReservedCgroupName   string
0000000000000000000000000000000000000000;;		SystemReservedCgroupName string
0000000000000000000000000000000000000000;;		EnforceNodeAllocatable   sets.String
0000000000000000000000000000000000000000;;		KubeReserved             v1.ResourceList
0000000000000000000000000000000000000000;;		SystemReserved           v1.ResourceList
0000000000000000000000000000000000000000;;		HardEvictionThresholds   []evictionapi.Threshold
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Status struct {
0000000000000000000000000000000000000000;;		// Any soft requirements that were unsatisfied.
0000000000000000000000000000000000000000;;		SoftRequirements error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Uer visible keys for managing node allocatable enforcement on the node.
0000000000000000000000000000000000000000;;		NodeAllocatableEnforcementKey = "pods"
0000000000000000000000000000000000000000;;		SystemReservedEnforcementKey  = "system-reserved"
0000000000000000000000000000000000000000;;		KubeReservedEnforcementKey    = "kube-reserved"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// containerManager for the kubelet is currently an injected dependency.
0000000000000000000000000000000000000000;;	// We need to parse the --qos-reserve-requests option in
0000000000000000000000000000000000000000;;	// cmd/kubelet/app/server.go and there isn't really a good place to put
0000000000000000000000000000000000000000;;	// the code.  If/When the kubelet dependency injection gets worked out,
0000000000000000000000000000000000000000;;	// maybe there will be a better place for it.
0000000000000000000000000000000000000000;;	func parsePercentage(v string) (int64, error) {
0000000000000000000000000000000000000000;;		if !strings.HasSuffix(v, "%") {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("percentage expected, got '%s'", v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		percentage, err := strconv.ParseInt(strings.TrimRight(v, "%"), 10, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("invalid number in percentage '%s'", v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if percentage < 0 || percentage > 100 {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("percentage must be between 0 and 100")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return percentage, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseQOSReserved parses the --qos-reserve-requests option
0000000000000000000000000000000000000000;;	func ParseQOSReserved(m componentconfig.ConfigurationMap) (*map[v1.ResourceName]int64, error) {
0000000000000000000000000000000000000000;;		reservations := make(map[v1.ResourceName]int64)
0000000000000000000000000000000000000000;;		for k, v := range m {
0000000000000000000000000000000000000000;;			switch v1.ResourceName(k) {
0000000000000000000000000000000000000000;;			// Only memory resources are supported.
0000000000000000000000000000000000000000;;			case v1.ResourceMemory:
0000000000000000000000000000000000000000;;				q, err := parsePercentage(v)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				reservations[v1.ResourceName(k)] = q
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("cannot reserve %q resource", k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &reservations, nil
0000000000000000000000000000000000000000;;	}
