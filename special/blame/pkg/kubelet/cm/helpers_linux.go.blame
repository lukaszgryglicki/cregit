0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
4a391214a4b20b9ad9639278ccafbadc66d203dd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		libcontainercgroups "github.com/opencontainers/runc/libcontainer/cgroups"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		v1qos "k8s.io/kubernetes/pkg/api/v1/helper/qos"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/v1/resource"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Taken from lmctfy https://github.com/google/lmctfy/blob/master/lmctfy/controllers/cpu_controller.cc
0000000000000000000000000000000000000000;;		MinShares     = 2
0000000000000000000000000000000000000000;;		SharesPerCPU  = 1024
0000000000000000000000000000000000000000;;		MilliCPUToCPU = 1000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 100000 is equivalent to 100ms
0000000000000000000000000000000000000000;;		QuotaPeriod    = 100000
0000000000000000000000000000000000000000;;		MinQuotaPeriod = 1000
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MilliCPUToQuota converts milliCPU to CFS quota and period values.
0000000000000000000000000000000000000000;;	func MilliCPUToQuota(milliCPU int64) (quota int64, period int64) {
0000000000000000000000000000000000000000;;		// CFS quota is measured in two values:
0000000000000000000000000000000000000000;;		//  - cfs_period_us=100ms (the amount of time to measure usage across)
0000000000000000000000000000000000000000;;		//  - cfs_quota=20ms (the amount of cpu time allowed to be used across a period)
0000000000000000000000000000000000000000;;		// so in the above example, you are limited to 20% of a single CPU
0000000000000000000000000000000000000000;;		// for multi-cpu environments, you just scale equivalent amounts
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if milliCPU == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we set the period to 100ms by default
0000000000000000000000000000000000000000;;		period = QuotaPeriod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we then convert your milliCPU to a value normalized over a period
0000000000000000000000000000000000000000;;		quota = (milliCPU * QuotaPeriod) / MilliCPUToCPU
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// quota needs to be a minimum of 1ms.
0000000000000000000000000000000000000000;;		if quota < MinQuotaPeriod {
0000000000000000000000000000000000000000;;			quota = MinQuotaPeriod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MilliCPUToShares converts the milliCPU to CFS shares.
0000000000000000000000000000000000000000;;	func MilliCPUToShares(milliCPU int64) int64 {
0000000000000000000000000000000000000000;;		if milliCPU == 0 {
0000000000000000000000000000000000000000;;			// Docker converts zero milliCPU to unset, which maps to kernel default
0000000000000000000000000000000000000000;;			// for unset: 1024. Return 2 here to really match kernel default for
0000000000000000000000000000000000000000;;			// zero milliCPU.
0000000000000000000000000000000000000000;;			return MinShares
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Conceptually (milliCPU / milliCPUToCPU) * sharesPerCPU, but factored to improve rounding.
0000000000000000000000000000000000000000;;		shares := (milliCPU * SharesPerCPU) / MilliCPUToCPU
0000000000000000000000000000000000000000;;		if shares < MinShares {
0000000000000000000000000000000000000000;;			return MinShares
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return shares
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceConfigForPod takes the input pod and outputs the cgroup resource config.
0000000000000000000000000000000000000000;;	func ResourceConfigForPod(pod *v1.Pod) *ResourceConfig {
0000000000000000000000000000000000000000;;		// sum requests and limits.
0000000000000000000000000000000000000000;;		reqs, limits := resource.PodRequestsAndLimits(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cpuRequests := int64(0)
0000000000000000000000000000000000000000;;		cpuLimits := int64(0)
0000000000000000000000000000000000000000;;		memoryLimits := int64(0)
0000000000000000000000000000000000000000;;		if request, found := reqs[v1.ResourceCPU]; found {
0000000000000000000000000000000000000000;;			cpuRequests = request.MilliValue()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if limit, found := limits[v1.ResourceCPU]; found {
0000000000000000000000000000000000000000;;			cpuLimits = limit.MilliValue()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if limit, found := limits[v1.ResourceMemory]; found {
0000000000000000000000000000000000000000;;			memoryLimits = limit.Value()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// convert to CFS values
0000000000000000000000000000000000000000;;		cpuShares := MilliCPUToShares(cpuRequests)
0000000000000000000000000000000000000000;;		cpuQuota, cpuPeriod := MilliCPUToQuota(cpuLimits)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// track if limits were applied for each resource.
0000000000000000000000000000000000000000;;		memoryLimitsDeclared := true
0000000000000000000000000000000000000000;;		cpuLimitsDeclared := true
0000000000000000000000000000000000000000;;		for _, container := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			if container.Resources.Limits.Cpu().IsZero() {
0000000000000000000000000000000000000000;;				cpuLimitsDeclared = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if container.Resources.Limits.Memory().IsZero() {
0000000000000000000000000000000000000000;;				memoryLimitsDeclared = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// determine the qos class
0000000000000000000000000000000000000000;;		qosClass := v1qos.GetPodQOS(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// build the result
0000000000000000000000000000000000000000;;		result := &ResourceConfig{}
0000000000000000000000000000000000000000;;		if qosClass == v1.PodQOSGuaranteed {
0000000000000000000000000000000000000000;;			result.CpuShares = &cpuShares
0000000000000000000000000000000000000000;;			result.CpuQuota = &cpuQuota
0000000000000000000000000000000000000000;;			result.CpuPeriod = &cpuPeriod
0000000000000000000000000000000000000000;;			result.Memory = &memoryLimits
0000000000000000000000000000000000000000;;		} else if qosClass == v1.PodQOSBurstable {
0000000000000000000000000000000000000000;;			result.CpuShares = &cpuShares
0000000000000000000000000000000000000000;;			if cpuLimitsDeclared {
0000000000000000000000000000000000000000;;				result.CpuQuota = &cpuQuota
0000000000000000000000000000000000000000;;				result.CpuPeriod = &cpuPeriod
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if memoryLimitsDeclared {
0000000000000000000000000000000000000000;;				result.Memory = &memoryLimits
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			shares := int64(MinShares)
0000000000000000000000000000000000000000;;			result.CpuShares = &shares
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetCgroupSubsystems returns information about the mounted cgroup subsystems
0000000000000000000000000000000000000000;;	func GetCgroupSubsystems() (*CgroupSubsystems, error) {
0000000000000000000000000000000000000000;;		// get all cgroup mounts.
0000000000000000000000000000000000000000;;		allCgroups, err := libcontainercgroups.GetCgroupMounts(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return &CgroupSubsystems{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(allCgroups) == 0 {
0000000000000000000000000000000000000000;;			return &CgroupSubsystems{}, fmt.Errorf("failed to find cgroup mounts")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mountPoints := make(map[string]string, len(allCgroups))
0000000000000000000000000000000000000000;;		for _, mount := range allCgroups {
0000000000000000000000000000000000000000;;			for _, subsystem := range mount.Subsystems {
0000000000000000000000000000000000000000;;				mountPoints[subsystem] = mount.Mountpoint
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &CgroupSubsystems{
0000000000000000000000000000000000000000;;			Mounts:      allCgroups,
0000000000000000000000000000000000000000;;			MountPoints: mountPoints,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getCgroupProcs takes a cgroup directory name as an argument
0000000000000000000000000000000000000000;;	// reads through the cgroup's procs file and returns a list of tgid's.
0000000000000000000000000000000000000000;;	// It returns an empty list if a procs file doesn't exists
0000000000000000000000000000000000000000;;	func getCgroupProcs(dir string) ([]int, error) {
0000000000000000000000000000000000000000;;		procsFile := filepath.Join(dir, "cgroup.procs")
0000000000000000000000000000000000000000;;		f, err := os.Open(procsFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				// The procsFile does not exist, So no pids attached to this directory
0000000000000000000000000000000000000000;;				return []int{}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := bufio.NewScanner(f)
0000000000000000000000000000000000000000;;		out := []int{}
0000000000000000000000000000000000000000;;		for s.Scan() {
0000000000000000000000000000000000000000;;			if t := s.Text(); t != "" {
0000000000000000000000000000000000000000;;				pid, err := strconv.Atoi(t)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("unexpected line in %v; could not convert to pid: %v", procsFile, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				out = append(out, pid)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
