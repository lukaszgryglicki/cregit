0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
569bc94c359ec4bc4cf257d1d4470aa2b1a345dd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		v1qos "k8s.io/kubernetes/pkg/api/v1/helper/qos"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		podCgroupNamePrefix = "pod"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// podContainerManagerImpl implements podContainerManager interface.
0000000000000000000000000000000000000000;;	// It is the general implementation which allows pod level container
0000000000000000000000000000000000000000;;	// management if qos Cgroup is enabled.
0000000000000000000000000000000000000000;;	type podContainerManagerImpl struct {
0000000000000000000000000000000000000000;;		// qosContainersInfo hold absolute paths of the top level qos containers
0000000000000000000000000000000000000000;;		qosContainersInfo QOSContainersInfo
0000000000000000000000000000000000000000;;		// Stores the mounted cgroup subsystems
0000000000000000000000000000000000000000;;		subsystems *CgroupSubsystems
0000000000000000000000000000000000000000;;		// cgroupManager is the cgroup Manager Object responsible for managing all
0000000000000000000000000000000000000000;;		// pod cgroups.
0000000000000000000000000000000000000000;;		cgroupManager CgroupManager
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Make sure that podContainerManagerImpl implements the PodContainerManager interface
0000000000000000000000000000000000000000;;	var _ PodContainerManager = &podContainerManagerImpl{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// applyLimits sets pod cgroup resource limits
0000000000000000000000000000000000000000;;	// It also updates the resource limits on top level qos containers.
0000000000000000000000000000000000000000;;	func (m *podContainerManagerImpl) applyLimits(pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		// This function will house the logic for setting the resource parameters
0000000000000000000000000000000000000000;;		// on the pod container config and updating top level qos container configs
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Exists checks if the pod's cgroup already exists
0000000000000000000000000000000000000000;;	func (m *podContainerManagerImpl) Exists(pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		podContainerName, _ := m.GetPodContainerName(pod)
0000000000000000000000000000000000000000;;		return m.cgroupManager.Exists(podContainerName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnsureExists takes a pod as argument and makes sure that
0000000000000000000000000000000000000000;;	// pod cgroup exists if qos cgroup hierarchy flag is enabled.
0000000000000000000000000000000000000000;;	// If the pod level container doesen't already exist it is created.
0000000000000000000000000000000000000000;;	func (m *podContainerManagerImpl) EnsureExists(pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		podContainerName, _ := m.GetPodContainerName(pod)
0000000000000000000000000000000000000000;;		// check if container already exist
0000000000000000000000000000000000000000;;		alreadyExists := m.Exists(pod)
0000000000000000000000000000000000000000;;		if !alreadyExists {
0000000000000000000000000000000000000000;;			// Create the pod container
0000000000000000000000000000000000000000;;			containerConfig := &CgroupConfig{
0000000000000000000000000000000000000000;;				Name:               podContainerName,
0000000000000000000000000000000000000000;;				ResourceParameters: ResourceConfigForPod(pod),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := m.cgroupManager.Create(containerConfig); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to create container for %v : %v", podContainerName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Apply appropriate resource limits on the pod container
0000000000000000000000000000000000000000;;		// Top level qos containers limits are not updated
0000000000000000000000000000000000000000;;		// until we figure how to maintain the desired state in the kubelet.
0000000000000000000000000000000000000000;;		// Because maintaining the desired state is difficult without checkpointing.
0000000000000000000000000000000000000000;;		if err := m.applyLimits(pod); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to apply resource limits on container for %v : %v", podContainerName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPodContainerName returns the CgroupName identifer, and its literal cgroupfs form on the host.
0000000000000000000000000000000000000000;;	func (m *podContainerManagerImpl) GetPodContainerName(pod *v1.Pod) (CgroupName, string) {
0000000000000000000000000000000000000000;;		podQOS := v1qos.GetPodQOS(pod)
0000000000000000000000000000000000000000;;		// Get the parent QOS container name
0000000000000000000000000000000000000000;;		var parentContainer string
0000000000000000000000000000000000000000;;		switch podQOS {
0000000000000000000000000000000000000000;;		case v1.PodQOSGuaranteed:
0000000000000000000000000000000000000000;;			parentContainer = m.qosContainersInfo.Guaranteed
0000000000000000000000000000000000000000;;		case v1.PodQOSBurstable:
0000000000000000000000000000000000000000;;			parentContainer = m.qosContainersInfo.Burstable
0000000000000000000000000000000000000000;;		case v1.PodQOSBestEffort:
0000000000000000000000000000000000000000;;			parentContainer = m.qosContainersInfo.BestEffort
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podContainer := podCgroupNamePrefix + string(pod.UID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the absolute path of the cgroup
0000000000000000000000000000000000000000;;		cgroupName := (CgroupName)(path.Join(parentContainer, podContainer))
0000000000000000000000000000000000000000;;		// Get the literal cgroupfs name
0000000000000000000000000000000000000000;;		cgroupfsName := m.cgroupManager.Name(cgroupName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cgroupName, cgroupfsName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan through the whole cgroup directory and kill all processes either
0000000000000000000000000000000000000000;;	// attached to the pod cgroup or to a container cgroup under the pod cgroup
0000000000000000000000000000000000000000;;	func (m *podContainerManagerImpl) tryKillingCgroupProcesses(podCgroup CgroupName) error {
0000000000000000000000000000000000000000;;		pidsToKill := m.cgroupManager.Pids(podCgroup)
0000000000000000000000000000000000000000;;		// No pids charged to the terminated pod cgroup return
0000000000000000000000000000000000000000;;		if len(pidsToKill) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var errlist []error
0000000000000000000000000000000000000000;;		// os.Kill often errors out,
0000000000000000000000000000000000000000;;		// We try killing all the pids multiple times
0000000000000000000000000000000000000000;;		for i := 0; i < 5; i++ {
0000000000000000000000000000000000000000;;			if i != 0 {
0000000000000000000000000000000000000000;;				glog.V(3).Infof("Attempt %v failed to kill all unwanted process. Retyring", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			errlist = []error{}
0000000000000000000000000000000000000000;;			for _, pid := range pidsToKill {
0000000000000000000000000000000000000000;;				p, err := os.FindProcess(pid)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// Process not running anymore, do nothing
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(3).Infof("Attempt to kill process with pid: %v", pid)
0000000000000000000000000000000000000000;;				if err := p.Kill(); err != nil {
0000000000000000000000000000000000000000;;					glog.V(3).Infof("failed to kill process with pid: %v", pid)
0000000000000000000000000000000000000000;;					errlist = append(errlist, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(errlist) == 0 {
0000000000000000000000000000000000000000;;				glog.V(3).Infof("successfully killed all unwanted processes.")
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(errlist)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Destroy destroys the pod container cgroup paths
0000000000000000000000000000000000000000;;	func (m *podContainerManagerImpl) Destroy(podCgroup CgroupName) error {
0000000000000000000000000000000000000000;;		// Try killing all the processes attached to the pod cgroup
0000000000000000000000000000000000000000;;		if err := m.tryKillingCgroupProcesses(podCgroup); err != nil {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("failed to kill all the processes attached to the %v cgroups", podCgroup)
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to kill all the processes attached to the %v cgroups : %v", podCgroup, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now its safe to remove the pod's cgroup
0000000000000000000000000000000000000000;;		containerConfig := &CgroupConfig{
0000000000000000000000000000000000000000;;			Name:               podCgroup,
0000000000000000000000000000000000000000;;			ResourceParameters: &ResourceConfig{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := m.cgroupManager.Destroy(containerConfig); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to delete cgroup paths for %v : %v", podCgroup, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReduceCPULimits reduces the CPU CFS values to the minimum amount of shares.
0000000000000000000000000000000000000000;;	func (m *podContainerManagerImpl) ReduceCPULimits(podCgroup CgroupName) error {
0000000000000000000000000000000000000000;;		return m.cgroupManager.ReduceCPULimits(podCgroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAllPodsFromCgroups scans through all the subsystems of pod cgroups
0000000000000000000000000000000000000000;;	// Get list of pods whose cgroup still exist on the cgroup mounts
0000000000000000000000000000000000000000;;	func (m *podContainerManagerImpl) GetAllPodsFromCgroups() (map[types.UID]CgroupName, error) {
0000000000000000000000000000000000000000;;		// Map for storing all the found pods on the disk
0000000000000000000000000000000000000000;;		foundPods := make(map[types.UID]CgroupName)
0000000000000000000000000000000000000000;;		qosContainersList := [3]string{m.qosContainersInfo.BestEffort, m.qosContainersInfo.Burstable, m.qosContainersInfo.Guaranteed}
0000000000000000000000000000000000000000;;		// Scan through all the subsystem mounts
0000000000000000000000000000000000000000;;		// and through each QoS cgroup directory for each subsystem mount
0000000000000000000000000000000000000000;;		// If a pod cgroup exists in even a single subsystem mount
0000000000000000000000000000000000000000;;		// we will attempt to delete it
0000000000000000000000000000000000000000;;		for _, val := range m.subsystems.MountPoints {
0000000000000000000000000000000000000000;;			for _, qosContainerName := range qosContainersList {
0000000000000000000000000000000000000000;;				// get the subsystems QoS cgroup absolute name
0000000000000000000000000000000000000000;;				qcConversion := m.cgroupManager.Name(CgroupName(qosContainerName))
0000000000000000000000000000000000000000;;				qc := path.Join(val, qcConversion)
0000000000000000000000000000000000000000;;				dirInfo, err := ioutil.ReadDir(qc)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("failed to read the cgroup directory %v : %v", qc, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for i := range dirInfo {
0000000000000000000000000000000000000000;;					// its not a directory, so continue on...
0000000000000000000000000000000000000000;;					if !dirInfo[i].IsDir() {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// convert the concrete cgroupfs name back to an internal identifier
0000000000000000000000000000000000000000;;					// this is needed to handle path conversion for systemd environments.
0000000000000000000000000000000000000000;;					// we pass the fully qualified path so decoding can work as expected
0000000000000000000000000000000000000000;;					// since systemd encodes the path in each segment.
0000000000000000000000000000000000000000;;					cgroupfsPath := path.Join(qcConversion, dirInfo[i].Name())
0000000000000000000000000000000000000000;;					internalPath := m.cgroupManager.CgroupName(cgroupfsPath)
0000000000000000000000000000000000000000;;					// we only care about base segment of the converted path since that
0000000000000000000000000000000000000000;;					// is what we are reading currently to know if it is a pod or not.
0000000000000000000000000000000000000000;;					basePath := path.Base(string(internalPath))
0000000000000000000000000000000000000000;;					if !strings.Contains(basePath, podCgroupNamePrefix) {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// we then split the name on the pod prefix to determine the uid
0000000000000000000000000000000000000000;;					parts := strings.Split(basePath, podCgroupNamePrefix)
0000000000000000000000000000000000000000;;					// the uid is missing, so we log the unexpected cgroup not of form pod<uid>
0000000000000000000000000000000000000000;;					if len(parts) != 2 {
0000000000000000000000000000000000000000;;						glog.Errorf("pod cgroup manager ignoring unexpected cgroup %v because it is not a pod", cgroupfsPath)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					podUID := parts[1]
0000000000000000000000000000000000000000;;					foundPods[types.UID(podUID)] = internalPath
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return foundPods, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// podContainerManagerNoop implements podContainerManager interface.
0000000000000000000000000000000000000000;;	// It is a no-op implementation and basically does nothing
0000000000000000000000000000000000000000;;	// podContainerManagerNoop is used in case the QoS cgroup Hierarchy is not
0000000000000000000000000000000000000000;;	// enabled, so Exists() returns true always as the cgroupRoot
0000000000000000000000000000000000000000;;	// is expected to always exist.
0000000000000000000000000000000000000000;;	type podContainerManagerNoop struct {
0000000000000000000000000000000000000000;;		cgroupRoot CgroupName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Make sure that podContainerManagerStub implements the PodContainerManager interface
0000000000000000000000000000000000000000;;	var _ PodContainerManager = &podContainerManagerNoop{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *podContainerManagerNoop) Exists(_ *v1.Pod) bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *podContainerManagerNoop) EnsureExists(_ *v1.Pod) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *podContainerManagerNoop) GetPodContainerName(_ *v1.Pod) (CgroupName, string) {
0000000000000000000000000000000000000000;;		return m.cgroupRoot, string(m.cgroupRoot)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *podContainerManagerNoop) GetPodContainerNameForDriver(_ *v1.Pod) string {
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Destroy destroys the pod container cgroup paths
0000000000000000000000000000000000000000;;	func (m *podContainerManagerNoop) Destroy(_ CgroupName) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *podContainerManagerNoop) ReduceCPULimits(_ CgroupName) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *podContainerManagerNoop) GetAllPodsFromCgroups() (map[types.UID]CgroupName, error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
