0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
4a391214a4b20b9ad9639278ccafbadc66d203dd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		libcontainercgroups "github.com/opencontainers/runc/libcontainer/cgroups"
0000000000000000000000000000000000000000;;		cgroupfs "github.com/opencontainers/runc/libcontainer/cgroups/fs"
0000000000000000000000000000000000000000;;		cgroupsystemd "github.com/opencontainers/runc/libcontainer/cgroups/systemd"
0000000000000000000000000000000000000000;;		libcontainerconfigs "github.com/opencontainers/runc/libcontainer/configs"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/metrics"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// libcontainerCgroupManagerType defines how to interface with libcontainer
0000000000000000000000000000000000000000;;	type libcontainerCgroupManagerType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// libcontainerCgroupfs means use libcontainer with cgroupfs
0000000000000000000000000000000000000000;;		libcontainerCgroupfs libcontainerCgroupManagerType = "cgroupfs"
0000000000000000000000000000000000000000;;		// libcontainerSystemd means use libcontainer with systemd
0000000000000000000000000000000000000000;;		libcontainerSystemd libcontainerCgroupManagerType = "systemd"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConvertCgroupNameToSystemd converts the internal cgroup name to a systemd name.
0000000000000000000000000000000000000000;;	// For example, the name /Burstable/pod_123-456 becomes Burstable-pod_123_456.slice
0000000000000000000000000000000000000000;;	// If outputToCgroupFs is true, it expands the systemd name into the cgroupfs form.
0000000000000000000000000000000000000000;;	// For example, it will return /Burstable.slice/Burstable-pod_123_456.slice in above scenario.
0000000000000000000000000000000000000000;;	func ConvertCgroupNameToSystemd(cgroupName CgroupName, outputToCgroupFs bool) string {
0000000000000000000000000000000000000000;;		name := string(cgroupName)
0000000000000000000000000000000000000000;;		result := ""
0000000000000000000000000000000000000000;;		if name != "" && name != "/" {
0000000000000000000000000000000000000000;;			parts := strings.Split(name, "/")
0000000000000000000000000000000000000000;;			results := []string{}
0000000000000000000000000000000000000000;;			for _, part := range parts {
0000000000000000000000000000000000000000;;				// ignore leading stuff
0000000000000000000000000000000000000000;;				if part == "" {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// detect if we are given a systemd style name.
0000000000000000000000000000000000000000;;				// if so, we do not want to do double encoding.
0000000000000000000000000000000000000000;;				if strings.HasSuffix(part, ".slice") {
0000000000000000000000000000000000000000;;					part = strings.TrimSuffix(part, ".slice")
0000000000000000000000000000000000000000;;					separatorIndex := strings.LastIndex(part, "-")
0000000000000000000000000000000000000000;;					if separatorIndex >= 0 && separatorIndex < len(part) {
0000000000000000000000000000000000000000;;						part = part[separatorIndex+1:]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// systemd treats - as a step in the hierarchy, we convert all - to _
0000000000000000000000000000000000000000;;					part = strings.Replace(part, "-", "_", -1)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				results = append(results, part)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// each part is appended with systemd style -
0000000000000000000000000000000000000000;;			result = strings.Join(results, "-")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// root converts to -
0000000000000000000000000000000000000000;;			result = "-"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// always have a .slice suffix
0000000000000000000000000000000000000000;;		if !strings.HasSuffix(result, ".slice") {
0000000000000000000000000000000000000000;;			result = result + ".slice"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if the caller desired the result in cgroupfs format...
0000000000000000000000000000000000000000;;		if outputToCgroupFs {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			result, err = cgroupsystemd.ExpandSlice(result)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(fmt.Errorf("error adapting cgroup name, input: %v, err: %v", name, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConvertCgroupFsNameToSystemd converts an expanded cgroupfs name to its systemd name.
0000000000000000000000000000000000000000;;	// For example, it will convert test.slice/test-a.slice/test-a-b.slice to become test-a-b.slice
0000000000000000000000000000000000000000;;	// NOTE: this is public right now to allow its usage in dockermanager and dockershim, ideally both those
0000000000000000000000000000000000000000;;	// code areas could use something from libcontainer if we get this style function upstream.
0000000000000000000000000000000000000000;;	func ConvertCgroupFsNameToSystemd(cgroupfsName string) (string, error) {
0000000000000000000000000000000000000000;;		// TODO: see if libcontainer systemd implementation could use something similar, and if so, move
0000000000000000000000000000000000000000;;		// this function up to that library.  At that time, it would most likely do validation specific to systemd
0000000000000000000000000000000000000000;;		// above and beyond the simple assumption here that the base of the path encodes the hierarchy
0000000000000000000000000000000000000000;;		// per systemd convention.
0000000000000000000000000000000000000000;;		return path.Base(cgroupfsName), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// libcontainerAdapter provides a simplified interface to libcontainer based on libcontainer type.
0000000000000000000000000000000000000000;;	type libcontainerAdapter struct {
0000000000000000000000000000000000000000;;		// cgroupManagerType defines how to interface with libcontainer
0000000000000000000000000000000000000000;;		cgroupManagerType libcontainerCgroupManagerType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newLibcontainerAdapter returns a configured libcontainerAdapter for specified manager.
0000000000000000000000000000000000000000;;	// it does any initialization required by that manager to function.
0000000000000000000000000000000000000000;;	func newLibcontainerAdapter(cgroupManagerType libcontainerCgroupManagerType) *libcontainerAdapter {
0000000000000000000000000000000000000000;;		return &libcontainerAdapter{cgroupManagerType: cgroupManagerType}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newManager returns an implementation of cgroups.Manager
0000000000000000000000000000000000000000;;	func (l *libcontainerAdapter) newManager(cgroups *libcontainerconfigs.Cgroup, paths map[string]string) (libcontainercgroups.Manager, error) {
0000000000000000000000000000000000000000;;		switch l.cgroupManagerType {
0000000000000000000000000000000000000000;;		case libcontainerCgroupfs:
0000000000000000000000000000000000000000;;			return &cgroupfs.Manager{
0000000000000000000000000000000000000000;;				Cgroups: cgroups,
0000000000000000000000000000000000000000;;				Paths:   paths,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		case libcontainerSystemd:
0000000000000000000000000000000000000000;;			// this means you asked systemd to manage cgroups, but systemd was not on the host, so all you can do is panic...
0000000000000000000000000000000000000000;;			if !cgroupsystemd.UseSystemd() {
0000000000000000000000000000000000000000;;				panic("systemd cgroup manager not available")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &cgroupsystemd.Manager{
0000000000000000000000000000000000000000;;				Cgroups: cgroups,
0000000000000000000000000000000000000000;;				Paths:   paths,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("invalid cgroup manager configuration")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *libcontainerAdapter) revertName(name string) CgroupName {
0000000000000000000000000000000000000000;;		if l.cgroupManagerType != libcontainerSystemd {
0000000000000000000000000000000000000000;;			return CgroupName(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		driverName, err := ConvertCgroupFsNameToSystemd(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		driverName = strings.TrimSuffix(driverName, ".slice")
0000000000000000000000000000000000000000;;		driverName = strings.Replace(driverName, "-", "/", -1)
0000000000000000000000000000000000000000;;		driverName = strings.Replace(driverName, "_", "-", -1)
0000000000000000000000000000000000000000;;		return CgroupName(driverName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// adaptName converts a CgroupName identifer to a driver specific conversion value.
0000000000000000000000000000000000000000;;	// if outputToCgroupFs is true, the result is returned in the cgroupfs format rather than the driver specific form.
0000000000000000000000000000000000000000;;	func (l *libcontainerAdapter) adaptName(cgroupName CgroupName, outputToCgroupFs bool) string {
0000000000000000000000000000000000000000;;		if l.cgroupManagerType != libcontainerSystemd {
0000000000000000000000000000000000000000;;			name := string(cgroupName)
0000000000000000000000000000000000000000;;			return name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ConvertCgroupNameToSystemd(cgroupName, outputToCgroupFs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CgroupSubsystems holds information about the mounted cgroup subsystems
0000000000000000000000000000000000000000;;	type CgroupSubsystems struct {
0000000000000000000000000000000000000000;;		// Cgroup subsystem mounts.
0000000000000000000000000000000000000000;;		// e.g.: "/sys/fs/cgroup/cpu" -> ["cpu", "cpuacct"]
0000000000000000000000000000000000000000;;		Mounts []libcontainercgroups.Mount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Cgroup subsystem to their mount location.
0000000000000000000000000000000000000000;;		// e.g.: "cpu" -> "/sys/fs/cgroup/cpu"
0000000000000000000000000000000000000000;;		MountPoints map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cgroupManagerImpl implements the CgroupManager interface.
0000000000000000000000000000000000000000;;	// Its a stateless object which can be used to
0000000000000000000000000000000000000000;;	// update,create or delete any number of cgroups
0000000000000000000000000000000000000000;;	// It uses the Libcontainer raw fs cgroup manager for cgroup management.
0000000000000000000000000000000000000000;;	type cgroupManagerImpl struct {
0000000000000000000000000000000000000000;;		// subsystems holds information about all the
0000000000000000000000000000000000000000;;		// mounted cgroup subsystems on the node
0000000000000000000000000000000000000000;;		subsystems *CgroupSubsystems
0000000000000000000000000000000000000000;;		// simplifies interaction with libcontainer and its cgroup managers
0000000000000000000000000000000000000000;;		adapter *libcontainerAdapter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Make sure that cgroupManagerImpl implements the CgroupManager interface
0000000000000000000000000000000000000000;;	var _ CgroupManager = &cgroupManagerImpl{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCgroupManager is a factory method that returns a CgroupManager
0000000000000000000000000000000000000000;;	func NewCgroupManager(cs *CgroupSubsystems, cgroupDriver string) CgroupManager {
0000000000000000000000000000000000000000;;		managerType := libcontainerCgroupfs
0000000000000000000000000000000000000000;;		if cgroupDriver == string(libcontainerSystemd) {
0000000000000000000000000000000000000000;;			managerType = libcontainerSystemd
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &cgroupManagerImpl{
0000000000000000000000000000000000000000;;			subsystems: cs,
0000000000000000000000000000000000000000;;			adapter:    newLibcontainerAdapter(managerType),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name converts the cgroup to the driver specific value in cgroupfs form.
0000000000000000000000000000000000000000;;	func (m *cgroupManagerImpl) Name(name CgroupName) string {
0000000000000000000000000000000000000000;;		return m.adapter.adaptName(name, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CgroupName converts the literal cgroupfs name on the host to an internal identifier.
0000000000000000000000000000000000000000;;	func (m *cgroupManagerImpl) CgroupName(name string) CgroupName {
0000000000000000000000000000000000000000;;		return m.adapter.revertName(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildCgroupPaths builds a path to each cgroup subsystem for the specified name.
0000000000000000000000000000000000000000;;	func (m *cgroupManagerImpl) buildCgroupPaths(name CgroupName) map[string]string {
0000000000000000000000000000000000000000;;		cgroupFsAdaptedName := m.Name(name)
0000000000000000000000000000000000000000;;		cgroupPaths := make(map[string]string, len(m.subsystems.MountPoints))
0000000000000000000000000000000000000000;;		for key, val := range m.subsystems.MountPoints {
0000000000000000000000000000000000000000;;			cgroupPaths[key] = path.Join(val, cgroupFsAdaptedName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cgroupPaths
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Exists checks if all subsystem cgroups already exist
0000000000000000000000000000000000000000;;	func (m *cgroupManagerImpl) Exists(name CgroupName) bool {
0000000000000000000000000000000000000000;;		// Get map of all cgroup paths on the system for the particular cgroup
0000000000000000000000000000000000000000;;		cgroupPaths := m.buildCgroupPaths(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the presence of alternative control groups not known to runc confuses
0000000000000000000000000000000000000000;;		// the kubelet existence checks.
0000000000000000000000000000000000000000;;		// ideally, we would have a mechaninsm in runc to support Exists() logic
0000000000000000000000000000000000000000;;		// scoped to the set control groups it understands.  this is being discussed
0000000000000000000000000000000000000000;;		// in https://github.com/opencontainers/runc/issues/1440
0000000000000000000000000000000000000000;;		// once resolved, we can remove this code.
0000000000000000000000000000000000000000;;		whitelistControllers := sets.NewString("cpu", "cpuacct", "cpuset", "memory", "hugetlb", "systemd")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If even one cgroup path doesn't exist, then the cgroup doesn't exist.
0000000000000000000000000000000000000000;;		for controller, path := range cgroupPaths {
0000000000000000000000000000000000000000;;			// ignore mounts we dont care about
0000000000000000000000000000000000000000;;			if !whitelistControllers.Has(controller) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !libcontainercgroups.PathExists(path) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Destroy destroys the specified cgroup
0000000000000000000000000000000000000000;;	func (m *cgroupManagerImpl) Destroy(cgroupConfig *CgroupConfig) error {
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			metrics.CgroupManagerLatency.WithLabelValues("destroy").Observe(metrics.SinceInMicroseconds(start))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cgroupPaths := m.buildCgroupPaths(cgroupConfig.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we take the location in traditional cgroupfs format.
0000000000000000000000000000000000000000;;		abstractCgroupFsName := string(cgroupConfig.Name)
0000000000000000000000000000000000000000;;		abstractParent := CgroupName(path.Dir(abstractCgroupFsName))
0000000000000000000000000000000000000000;;		abstractName := CgroupName(path.Base(abstractCgroupFsName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		driverParent := m.adapter.adaptName(abstractParent, false)
0000000000000000000000000000000000000000;;		driverName := m.adapter.adaptName(abstractName, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this is an ugly abstraction bleed, but systemd cgroup driver requires full paths...
0000000000000000000000000000000000000000;;		if m.adapter.cgroupManagerType == libcontainerSystemd {
0000000000000000000000000000000000000000;;			driverName = m.adapter.adaptName(cgroupConfig.Name, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Initialize libcontainer's cgroup config with driver specific naming.
0000000000000000000000000000000000000000;;		libcontainerCgroupConfig := &libcontainerconfigs.Cgroup{
0000000000000000000000000000000000000000;;			Name:   driverName,
0000000000000000000000000000000000000000;;			Parent: driverParent,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		manager, err := m.adapter.newManager(libcontainerCgroupConfig, cgroupPaths)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete cgroups using libcontainers Managers Destroy() method
0000000000000000000000000000000000000000;;		if err = manager.Destroy(); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Unable to destroy cgroup paths for cgroup %v : %v", cgroupConfig.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type subsystem interface {
0000000000000000000000000000000000000000;;		// Name returns the name of the subsystem.
0000000000000000000000000000000000000000;;		Name() string
0000000000000000000000000000000000000000;;		// Set the cgroup represented by cgroup.
0000000000000000000000000000000000000000;;		Set(path string, cgroup *libcontainerconfigs.Cgroup) error
0000000000000000000000000000000000000000;;		// GetStats returns the statistics associated with the cgroup
0000000000000000000000000000000000000000;;		GetStats(path string, stats *libcontainercgroups.Stats) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cgroup subsystems we currently support
0000000000000000000000000000000000000000;;	var supportedSubsystems = []subsystem{
0000000000000000000000000000000000000000;;		&cgroupfs.MemoryGroup{},
0000000000000000000000000000000000000000;;		&cgroupfs.CpuGroup{},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setSupportedSubsystems sets cgroup resource limits only on the supported
0000000000000000000000000000000000000000;;	// subsystems. ie. cpu and memory. We don't use libcontainer's cgroup/fs/Set()
0000000000000000000000000000000000000000;;	// method as it doesn't allow us to skip updates on the devices cgroup
0000000000000000000000000000000000000000;;	// Allowing or denying all devices by writing 'a' to devices.allow or devices.deny is
0000000000000000000000000000000000000000;;	// not possible once the device cgroups has children. Once the pod level cgroup are
0000000000000000000000000000000000000000;;	// created under the QOS level cgroup we cannot update the QOS level device cgroup.
0000000000000000000000000000000000000000;;	// We would like to skip setting any values on the device cgroup in this case
0000000000000000000000000000000000000000;;	// but this is not possible with libcontainers Set() method
0000000000000000000000000000000000000000;;	// See https://github.com/opencontainers/runc/issues/932
0000000000000000000000000000000000000000;;	func setSupportedSubsystems(cgroupConfig *libcontainerconfigs.Cgroup) error {
0000000000000000000000000000000000000000;;		for _, sys := range supportedSubsystems {
0000000000000000000000000000000000000000;;			if _, ok := cgroupConfig.Paths[sys.Name()]; !ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Failed to find subsystem mount for subsystem: %v", sys.Name())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := sys.Set(cgroupConfig.Paths[sys.Name()], cgroupConfig); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Failed to set config for supported subsystems : %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *cgroupManagerImpl) toResources(resourceConfig *ResourceConfig) *libcontainerconfigs.Resources {
0000000000000000000000000000000000000000;;		resources := &libcontainerconfigs.Resources{}
0000000000000000000000000000000000000000;;		if resourceConfig == nil {
0000000000000000000000000000000000000000;;			return resources
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resourceConfig.Memory != nil {
0000000000000000000000000000000000000000;;			resources.Memory = *resourceConfig.Memory
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resourceConfig.CpuShares != nil {
0000000000000000000000000000000000000000;;			resources.CpuShares = *resourceConfig.CpuShares
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resourceConfig.CpuQuota != nil {
0000000000000000000000000000000000000000;;			resources.CpuQuota = *resourceConfig.CpuQuota
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resourceConfig.CpuPeriod != nil {
0000000000000000000000000000000000000000;;			resources.CpuPeriod = *resourceConfig.CpuPeriod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resources
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update updates the cgroup with the specified Cgroup Configuration
0000000000000000000000000000000000000000;;	func (m *cgroupManagerImpl) Update(cgroupConfig *CgroupConfig) error {
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			metrics.CgroupManagerLatency.WithLabelValues("update").Observe(metrics.SinceInMicroseconds(start))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Extract the cgroup resource parameters
0000000000000000000000000000000000000000;;		resourceConfig := cgroupConfig.ResourceParameters
0000000000000000000000000000000000000000;;		resources := m.toResources(resourceConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cgroupPaths := m.buildCgroupPaths(cgroupConfig.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we take the location in traditional cgroupfs format.
0000000000000000000000000000000000000000;;		abstractCgroupFsName := string(cgroupConfig.Name)
0000000000000000000000000000000000000000;;		abstractParent := CgroupName(path.Dir(abstractCgroupFsName))
0000000000000000000000000000000000000000;;		abstractName := CgroupName(path.Base(abstractCgroupFsName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		driverParent := m.adapter.adaptName(abstractParent, false)
0000000000000000000000000000000000000000;;		driverName := m.adapter.adaptName(abstractName, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this is an ugly abstraction bleed, but systemd cgroup driver requires full paths...
0000000000000000000000000000000000000000;;		if m.adapter.cgroupManagerType == libcontainerSystemd {
0000000000000000000000000000000000000000;;			driverName = m.adapter.adaptName(cgroupConfig.Name, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Initialize libcontainer's cgroup config
0000000000000000000000000000000000000000;;		libcontainerCgroupConfig := &libcontainerconfigs.Cgroup{
0000000000000000000000000000000000000000;;			Name:      driverName,
0000000000000000000000000000000000000000;;			Parent:    driverParent,
0000000000000000000000000000000000000000;;			Resources: resources,
0000000000000000000000000000000000000000;;			Paths:     cgroupPaths,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := setSupportedSubsystems(libcontainerCgroupConfig); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to set supported cgroup subsystems for cgroup %v: %v", cgroupConfig.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create creates the specified cgroup
0000000000000000000000000000000000000000;;	func (m *cgroupManagerImpl) Create(cgroupConfig *CgroupConfig) error {
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			metrics.CgroupManagerLatency.WithLabelValues("create").Observe(metrics.SinceInMicroseconds(start))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we take the location in traditional cgroupfs format.
0000000000000000000000000000000000000000;;		abstractCgroupFsName := string(cgroupConfig.Name)
0000000000000000000000000000000000000000;;		abstractParent := CgroupName(path.Dir(abstractCgroupFsName))
0000000000000000000000000000000000000000;;		abstractName := CgroupName(path.Base(abstractCgroupFsName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		driverParent := m.adapter.adaptName(abstractParent, false)
0000000000000000000000000000000000000000;;		driverName := m.adapter.adaptName(abstractName, false)
0000000000000000000000000000000000000000;;		// this is an ugly abstraction bleed, but systemd cgroup driver requires full paths...
0000000000000000000000000000000000000000;;		if m.adapter.cgroupManagerType == libcontainerSystemd {
0000000000000000000000000000000000000000;;			driverName = m.adapter.adaptName(cgroupConfig.Name, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resources := m.toResources(cgroupConfig.ResourceParameters)
0000000000000000000000000000000000000000;;		// Initialize libcontainer's cgroup config with driver specific naming.
0000000000000000000000000000000000000000;;		libcontainerCgroupConfig := &libcontainerconfigs.Cgroup{
0000000000000000000000000000000000000000;;			Name:      driverName,
0000000000000000000000000000000000000000;;			Parent:    driverParent,
0000000000000000000000000000000000000000;;			Resources: resources,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get the manager with the specified cgroup configuration
0000000000000000000000000000000000000000;;		manager, err := m.adapter.newManager(libcontainerCgroupConfig, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Apply(-1) is a hack to create the cgroup directories for each resource
0000000000000000000000000000000000000000;;		// subsystem. The function [cgroups.Manager.apply()] applies cgroup
0000000000000000000000000000000000000000;;		// configuration to the process with the specified pid.
0000000000000000000000000000000000000000;;		// It creates cgroup files for each subsystems and writes the pid
0000000000000000000000000000000000000000;;		// in the tasks file. We use the function to create all the required
0000000000000000000000000000000000000000;;		// cgroup files but not attach any "real" pid to the cgroup.
0000000000000000000000000000000000000000;;		if err := manager.Apply(-1); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// it may confuse why we call set after we do apply, but the issue is that runc
0000000000000000000000000000000000000000;;		// follows a similar pattern.  it's needed to ensure cpu quota is set properly.
0000000000000000000000000000000000000000;;		m.Update(cgroupConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scans through all subsystems to find pids associated with specified cgroup.
0000000000000000000000000000000000000000;;	func (m *cgroupManagerImpl) Pids(name CgroupName) []int {
0000000000000000000000000000000000000000;;		// we need the driver specific name
0000000000000000000000000000000000000000;;		cgroupFsName := m.Name(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get a list of processes that we need to kill
0000000000000000000000000000000000000000;;		pidsToKill := sets.NewInt()
0000000000000000000000000000000000000000;;		var pids []int
0000000000000000000000000000000000000000;;		for _, val := range m.subsystems.MountPoints {
0000000000000000000000000000000000000000;;			dir := path.Join(val, cgroupFsName)
0000000000000000000000000000000000000000;;			_, err := os.Stat(dir)
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				// The subsystem pod cgroup is already deleted
0000000000000000000000000000000000000000;;				// do nothing, continue
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Get a list of pids that are still charged to the pod's cgroup
0000000000000000000000000000000000000000;;			pids, err = getCgroupProcs(dir)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pidsToKill.Insert(pids...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// WalkFunc which is called for each file and directory in the pod cgroup dir
0000000000000000000000000000000000000000;;			visitor := func(path string, info os.FileInfo, err error) error {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("cgroup manager encountered error scanning cgroup path %q: %v", path, err)
0000000000000000000000000000000000000000;;					return filepath.SkipDir
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !info.IsDir() {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pids, err = getCgroupProcs(path)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("cgroup manager encountered error getting procs for cgroup path %q: %v", path, err)
0000000000000000000000000000000000000000;;					return filepath.SkipDir
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pidsToKill.Insert(pids...)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Walk through the pod cgroup directory to check if
0000000000000000000000000000000000000000;;			// container cgroups haven't been GCed yet. Get attached processes to
0000000000000000000000000000000000000000;;			// all such unwanted containers under the pod cgroup
0000000000000000000000000000000000000000;;			if err = filepath.Walk(dir, visitor); err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("cgroup manager encountered error scanning pids for directory: %q: %v", dir, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pidsToKill.List()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReduceCPULimits reduces the cgroup's cpu shares to the lowest possible value
0000000000000000000000000000000000000000;;	func (m *cgroupManagerImpl) ReduceCPULimits(cgroupName CgroupName) error {
0000000000000000000000000000000000000000;;		// Set lowest possible CpuShares value for the cgroup
0000000000000000000000000000000000000000;;		minimumCPUShares := int64(MinShares)
0000000000000000000000000000000000000000;;		resources := &ResourceConfig{
0000000000000000000000000000000000000000;;			CpuShares: &minimumCPUShares,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		containerConfig := &CgroupConfig{
0000000000000000000000000000000000000000;;			Name:               cgroupName,
0000000000000000000000000000000000000000;;			ResourceParameters: resources,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m.Update(containerConfig)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getStatsSupportedSubsystems(cgroupPaths map[string]string) (*libcontainercgroups.Stats, error) {
0000000000000000000000000000000000000000;;		stats := libcontainercgroups.NewStats()
0000000000000000000000000000000000000000;;		for _, sys := range supportedSubsystems {
0000000000000000000000000000000000000000;;			if _, ok := cgroupPaths[sys.Name()]; !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Failed to find subsystem mount for subsystem: %v", sys.Name())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := sys.GetStats(cgroupPaths[sys.Name()], stats); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Failed to get stats for supported subsystems : %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stats, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toResourceStats(stats *libcontainercgroups.Stats) *ResourceStats {
0000000000000000000000000000000000000000;;		return &ResourceStats{
0000000000000000000000000000000000000000;;			MemoryStats: &MemoryStats{
0000000000000000000000000000000000000000;;				Usage: int64(stats.MemoryStats.Usage.Usage),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get sets the ResourceParameters of the specified cgroup as read from the cgroup fs
0000000000000000000000000000000000000000;;	func (m *cgroupManagerImpl) GetResourceStats(name CgroupName) (*ResourceStats, error) {
0000000000000000000000000000000000000000;;		cgroupPaths := m.buildCgroupPaths(name)
0000000000000000000000000000000000000000;;		stats, err := getStatsSupportedSubsystems(cgroupPaths)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to get stats supported cgroup subsystems for cgroup %v: %v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return toResourceStats(stats), nil
0000000000000000000000000000000000000000;;	}
