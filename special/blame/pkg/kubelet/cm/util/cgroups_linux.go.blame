0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
592a84c4d00ad17be524ae994940cd1edac91a23;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		libcontainercgroups "github.com/opencontainers/runc/libcontainer/cgroups"
0000000000000000000000000000000000000000;;		libcontainerutils "github.com/opencontainers/runc/libcontainer/utils"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Forked from opencontainers/runc/libcontainer/cgroup/fs.Manager.GetPids()
0000000000000000000000000000000000000000;;	func GetPids(cgroupPath string) ([]int, error) {
0000000000000000000000000000000000000000;;		dir, err := getCgroupPath(cgroupPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return libcontainercgroups.GetPids(dir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getCgroupPath gets the file path to the "devices" subsystem of the desired cgroup.
0000000000000000000000000000000000000000;;	// cgroupPath is the path in the cgroup hierarchy.
0000000000000000000000000000000000000000;;	func getCgroupPath(cgroupPath string) (string, error) {
0000000000000000000000000000000000000000;;		cgroupPath = libcontainerutils.CleanPath(cgroupPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mnt, root, err := libcontainercgroups.FindCgroupMountpointAndRoot("devices")
0000000000000000000000000000000000000000;;		// If we didn't mount the subsystem, there is no point we make the path.
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the cgroup name/path is absolute do not look relative to the cgroup of the init process.
0000000000000000000000000000000000000000;;		if filepath.IsAbs(cgroupPath) {
0000000000000000000000000000000000000000;;			// Sometimes subsystems can be mounted togethger as 'cpu,cpuacct'.
0000000000000000000000000000000000000000;;			return filepath.Join(root, mnt, cgroupPath), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parentPath, err := getCgroupParentPath(mnt, root)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return filepath.Join(parentPath, cgroupPath), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getCgroupParentPath gets the parent filepath to this cgroup, for resolving relative cgroup paths.
0000000000000000000000000000000000000000;;	func getCgroupParentPath(mountpoint, root string) (string, error) {
0000000000000000000000000000000000000000;;		// Use GetThisCgroupDir instead of GetInitCgroupDir, because the creating
0000000000000000000000000000000000000000;;		// process could in container and shared pid namespace with host, and
0000000000000000000000000000000000000000;;		// /proc/1/cgroup could point to whole other world of cgroups.
0000000000000000000000000000000000000000;;		initPath, err := libcontainercgroups.GetThisCgroupDir("devices")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// This is needed for nested containers, because in /proc/self/cgroup we
0000000000000000000000000000000000000000;;		// see paths from host, which don't exist in container.
0000000000000000000000000000000000000000;;		relDir, err := filepath.Rel(root, initPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filepath.Join(mountpoint, relDir), nil
0000000000000000000000000000000000000000;;	}
