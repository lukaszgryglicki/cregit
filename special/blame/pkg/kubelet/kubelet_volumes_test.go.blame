0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d8028a7339b55ca34095bf869d82efc4b1e47468;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetest "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestListVolumesForPod(t *testing.T) {
0000000000000000000000000000000000000000;;		testKubelet := newTestKubelet(t, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;		defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;		kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := podWithUidNameNsSpec("12345678", "foo", "test", v1.PodSpec{
0000000000000000000000000000000000000000;;			Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name: "vol1",
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;							PDName: "fake-device1",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name: "vol2",
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;							PDName: "fake-device2",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := runVolumeManager(kubelet)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubelet.podManager.SetPods([]*v1.Pod{pod})
0000000000000000000000000000000000000000;;		err := kubelet.volumeManager.WaitForAttachAndMount(pod)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podName := volumehelper.GetUniquePodName(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumesToReturn, volumeExsit := kubelet.ListVolumesForPod(types.UID(podName))
0000000000000000000000000000000000000000;;		assert.True(t, volumeExsit, "expected to find volumes for pod %q", podName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		outerVolumeSpecName1 := "vol1"
0000000000000000000000000000000000000000;;		assert.NotNil(t, volumesToReturn[outerVolumeSpecName1], "key %s", outerVolumeSpecName1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		outerVolumeSpecName2 := "vol2"
0000000000000000000000000000000000000000;;		assert.NotNil(t, volumesToReturn[outerVolumeSpecName2], "key %s", outerVolumeSpecName2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodVolumesExist(t *testing.T) {
0000000000000000000000000000000000000000;;		testKubelet := newTestKubelet(t, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;		defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;		kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods := []*v1.Pod{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "pod1",
0000000000000000000000000000000000000000;;					UID:  "pod1uid",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: "vol1",
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;									PDName: "fake-device1",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "pod2",
0000000000000000000000000000000000000000;;					UID:  "pod2uid",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: "vol2",
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;									PDName: "fake-device2",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "pod3",
0000000000000000000000000000000000000000;;					UID:  "pod3uid",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: "vol3",
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;									PDName: "fake-device3",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := runVolumeManager(kubelet)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubelet.podManager.SetPods(pods)
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			err := kubelet.volumeManager.WaitForAttachAndMount(pod)
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			podVolumesExist := kubelet.podVolumesExist(pod.UID)
0000000000000000000000000000000000000000;;			assert.True(t, podVolumesExist, "pod %q", pod.UID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestVolumeAttachAndMountControllerDisabled(t *testing.T) {
0000000000000000000000000000000000000000;;		testKubelet := newTestKubelet(t, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;		defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;		kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := podWithUidNameNsSpec("12345678", "foo", "test", v1.PodSpec{
0000000000000000000000000000000000000000;;			Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name: "vol1",
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;							PDName: "fake-device",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := runVolumeManager(kubelet)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubelet.podManager.SetPods([]*v1.Pod{pod})
0000000000000000000000000000000000000000;;		err := kubelet.volumeManager.WaitForAttachAndMount(pod)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podVolumes := kubelet.volumeManager.GetMountedVolumesForPod(
0000000000000000000000000000000000000000;;			volumehelper.GetUniquePodName(pod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedPodVolumes := []string{"vol1"}
0000000000000000000000000000000000000000;;		assert.Len(t, podVolumes, len(expectedPodVolumes), "Volumes for pod %+v", pod)
0000000000000000000000000000000000000000;;		for _, name := range expectedPodVolumes {
0000000000000000000000000000000000000000;;			assert.Contains(t, podVolumes, name, "Volumes for pod %+v", pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		assert.True(t, testKubelet.volumePlugin.GetNewAttacherCallCount() >= 1, "Expected plugin NewAttacher to be called at least once")
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetest.VerifyWaitForAttachCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedWaitForAttachCallCount */, testKubelet.volumePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetest.VerifyAttachCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedAttachCallCount */, testKubelet.volumePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetest.VerifyMountDeviceCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedMountDeviceCallCount */, testKubelet.volumePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetest.VerifySetUpCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedSetUpCallCount */, testKubelet.volumePlugin))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestVolumeUnmountAndDetachControllerDisabled(t *testing.T) {
0000000000000000000000000000000000000000;;		testKubelet := newTestKubelet(t, false /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;		defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;		kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := podWithUidNameNsSpec("12345678", "foo", "test", v1.PodSpec{
0000000000000000000000000000000000000000;;			Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name: "vol1",
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;							PDName: "fake-device",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := runVolumeManager(kubelet)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add pod
0000000000000000000000000000000000000000;;		kubelet.podManager.SetPods([]*v1.Pod{pod})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify volumes attached
0000000000000000000000000000000000000000;;		err := kubelet.volumeManager.WaitForAttachAndMount(pod)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podVolumes := kubelet.volumeManager.GetMountedVolumesForPod(
0000000000000000000000000000000000000000;;			volumehelper.GetUniquePodName(pod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedPodVolumes := []string{"vol1"}
0000000000000000000000000000000000000000;;		assert.Len(t, podVolumes, len(expectedPodVolumes), "Volumes for pod %+v", pod)
0000000000000000000000000000000000000000;;		for _, name := range expectedPodVolumes {
0000000000000000000000000000000000000000;;			assert.Contains(t, podVolumes, name, "Volumes for pod %+v", pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.True(t, testKubelet.volumePlugin.GetNewAttacherCallCount() >= 1, "Expected plugin NewAttacher to be called at least once")
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetest.VerifyWaitForAttachCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedWaitForAttachCallCount */, testKubelet.volumePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetest.VerifyAttachCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedAttachCallCount */, testKubelet.volumePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetest.VerifyMountDeviceCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedMountDeviceCallCount */, testKubelet.volumePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetest.VerifySetUpCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedSetUpCallCount */, testKubelet.volumePlugin))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove pod
0000000000000000000000000000000000000000;;		kubelet.podManager.SetPods([]*v1.Pod{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.NoError(t, waitForVolumeUnmount(kubelet.volumeManager, pod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify volumes unmounted
0000000000000000000000000000000000000000;;		podVolumes = kubelet.volumeManager.GetMountedVolumesForPod(
0000000000000000000000000000000000000000;;			volumehelper.GetUniquePodName(pod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.Len(t, podVolumes, 0,
0000000000000000000000000000000000000000;;			"Expected volumes to be unmounted and detached. But some volumes are still mounted: %#v", podVolumes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetest.VerifyTearDownCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedTearDownCallCount */, testKubelet.volumePlugin))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify volumes detached and no longer reported as in use
0000000000000000000000000000000000000000;;		assert.NoError(t, waitForVolumeDetach(v1.UniqueVolumeName("fake/vol1"), kubelet.volumeManager))
0000000000000000000000000000000000000000;;		assert.True(t, testKubelet.volumePlugin.GetNewAttacherCallCount() >= 1, "Expected plugin NewAttacher to be called at least once")
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetest.VerifyDetachCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedDetachCallCount */, testKubelet.volumePlugin))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestVolumeAttachAndMountControllerEnabled(t *testing.T) {
0000000000000000000000000000000000000000;;		testKubelet := newTestKubelet(t, true /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;		defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;		kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;		kubeClient := testKubelet.fakeKubeClient
0000000000000000000000000000000000000000;;		kubeClient.AddReactor("get", "nodes",
0000000000000000000000000000000000000000;;			func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;				return true, &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: testKubeletHostname},
0000000000000000000000000000000000000000;;					Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;						VolumesAttached: []v1.AttachedVolume{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:       "fake/vol1",
0000000000000000000000000000000000000000;;								DevicePath: "fake/path",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{ExternalID: testKubeletHostname},
0000000000000000000000000000000000000000;;				}, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		kubeClient.AddReactor("*", "*", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			return true, nil, fmt.Errorf("no reaction implemented for %s", action)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := podWithUidNameNsSpec("12345678", "foo", "test", v1.PodSpec{
0000000000000000000000000000000000000000;;			Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name: "vol1",
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;							PDName: "fake-device",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := runVolumeManager(kubelet)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubelet.podManager.SetPods([]*v1.Pod{pod})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fake node status update
0000000000000000000000000000000000000000;;		go simulateVolumeInUseUpdate(
0000000000000000000000000000000000000000;;			v1.UniqueVolumeName("fake/vol1"),
0000000000000000000000000000000000000000;;			stopCh,
0000000000000000000000000000000000000000;;			kubelet.volumeManager)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.NoError(t, kubelet.volumeManager.WaitForAttachAndMount(pod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podVolumes := kubelet.volumeManager.GetMountedVolumesForPod(
0000000000000000000000000000000000000000;;			volumehelper.GetUniquePodName(pod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedPodVolumes := []string{"vol1"}
0000000000000000000000000000000000000000;;		assert.Len(t, podVolumes, len(expectedPodVolumes), "Volumes for pod %+v", pod)
0000000000000000000000000000000000000000;;		for _, name := range expectedPodVolumes {
0000000000000000000000000000000000000000;;			assert.Contains(t, podVolumes, name, "Volumes for pod %+v", pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		assert.True(t, testKubelet.volumePlugin.GetNewAttacherCallCount() >= 1, "Expected plugin NewAttacher to be called at least once")
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetest.VerifyWaitForAttachCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedWaitForAttachCallCount */, testKubelet.volumePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetest.VerifyZeroAttachCalls(testKubelet.volumePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetest.VerifyMountDeviceCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedMountDeviceCallCount */, testKubelet.volumePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetest.VerifySetUpCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedSetUpCallCount */, testKubelet.volumePlugin))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestVolumeUnmountAndDetachControllerEnabled(t *testing.T) {
0000000000000000000000000000000000000000;;		testKubelet := newTestKubelet(t, true /* controllerAttachDetachEnabled */)
0000000000000000000000000000000000000000;;		defer testKubelet.Cleanup()
0000000000000000000000000000000000000000;;		kubelet := testKubelet.kubelet
0000000000000000000000000000000000000000;;		kubeClient := testKubelet.fakeKubeClient
0000000000000000000000000000000000000000;;		kubeClient.AddReactor("get", "nodes",
0000000000000000000000000000000000000000;;			func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;				return true, &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: testKubeletHostname},
0000000000000000000000000000000000000000;;					Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;						VolumesAttached: []v1.AttachedVolume{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:       "fake/vol1",
0000000000000000000000000000000000000000;;								DevicePath: "fake/path",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{ExternalID: testKubeletHostname},
0000000000000000000000000000000000000000;;				}, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		kubeClient.AddReactor("*", "*", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			return true, nil, fmt.Errorf("no reaction implemented for %s", action)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := podWithUidNameNsSpec("12345678", "foo", "test", v1.PodSpec{
0000000000000000000000000000000000000000;;			Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name: "vol1",
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;							PDName: "fake-device",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := runVolumeManager(kubelet)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add pod
0000000000000000000000000000000000000000;;		kubelet.podManager.SetPods([]*v1.Pod{pod})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fake node status update
0000000000000000000000000000000000000000;;		go simulateVolumeInUseUpdate(
0000000000000000000000000000000000000000;;			v1.UniqueVolumeName("fake/vol1"),
0000000000000000000000000000000000000000;;			stopCh,
0000000000000000000000000000000000000000;;			kubelet.volumeManager)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify volumes attached
0000000000000000000000000000000000000000;;		assert.NoError(t, kubelet.volumeManager.WaitForAttachAndMount(pod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podVolumes := kubelet.volumeManager.GetMountedVolumesForPod(
0000000000000000000000000000000000000000;;			volumehelper.GetUniquePodName(pod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedPodVolumes := []string{"vol1"}
0000000000000000000000000000000000000000;;		assert.Len(t, podVolumes, len(expectedPodVolumes), "Volumes for pod %+v", pod)
0000000000000000000000000000000000000000;;		for _, name := range expectedPodVolumes {
0000000000000000000000000000000000000000;;			assert.Contains(t, podVolumes, name, "Volumes for pod %+v", pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.True(t, testKubelet.volumePlugin.GetNewAttacherCallCount() >= 1, "Expected plugin NewAttacher to be called at least once")
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetest.VerifyWaitForAttachCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedWaitForAttachCallCount */, testKubelet.volumePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetest.VerifyZeroAttachCalls(testKubelet.volumePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetest.VerifyMountDeviceCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedMountDeviceCallCount */, testKubelet.volumePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetest.VerifySetUpCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedSetUpCallCount */, testKubelet.volumePlugin))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove pod
0000000000000000000000000000000000000000;;		kubelet.podManager.SetPods([]*v1.Pod{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.NoError(t, waitForVolumeUnmount(kubelet.volumeManager, pod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify volumes unmounted
0000000000000000000000000000000000000000;;		podVolumes = kubelet.volumeManager.GetMountedVolumesForPod(
0000000000000000000000000000000000000000;;			volumehelper.GetUniquePodName(pod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.Len(t, podVolumes, 0,
0000000000000000000000000000000000000000;;			"Expected volumes to be unmounted and detached. But some volumes are still mounted: %#v", podVolumes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetest.VerifyTearDownCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedTearDownCallCount */, testKubelet.volumePlugin))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify volumes detached and no longer reported as in use
0000000000000000000000000000000000000000;;		assert.NoError(t, waitForVolumeDetach(v1.UniqueVolumeName("fake/vol1"), kubelet.volumeManager))
0000000000000000000000000000000000000000;;		assert.True(t, testKubelet.volumePlugin.GetNewAttacherCallCount() >= 1, "Expected plugin NewAttacher to be called at least once")
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetest.VerifyZeroDetachCallCount(testKubelet.volumePlugin))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type stubVolume struct {
0000000000000000000000000000000000000000;;		path string
0000000000000000000000000000000000000000;;		volume.MetricsNil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *stubVolume) GetPath() string {
0000000000000000000000000000000000000000;;		return f.path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *stubVolume) GetAttributes() volume.Attributes {
0000000000000000000000000000000000000000;;		return volume.Attributes{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *stubVolume) CanMount() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *stubVolume) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *stubVolume) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
