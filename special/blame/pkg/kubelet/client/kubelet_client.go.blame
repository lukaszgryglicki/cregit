0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
9fbdd758c00a160e902805405146a779d3acf5d8;pkg/client/container_info.go[pkg/client/container_info.go][pkg/kubelet/client/kubelet_client.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/transport"
0000000000000000000000000000000000000000;;		nodeutil "k8s.io/kubernetes/pkg/util/node"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type KubeletClientConfig struct {
0000000000000000000000000000000000000000;;		// Default port - used if no information about Kubelet port can be found in Node.NodeStatus.DaemonEndpoints.
0000000000000000000000000000000000000000;;		Port         uint
0000000000000000000000000000000000000000;;		ReadOnlyPort uint
0000000000000000000000000000000000000000;;		EnableHttps  bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PreferredAddressTypes - used to select an address from Node.NodeStatus.Addresses
0000000000000000000000000000000000000000;;		PreferredAddressTypes []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TLSClientConfig contains settings to enable transport layer security
0000000000000000000000000000000000000000;;		restclient.TLSClientConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Server requires Bearer authentication
0000000000000000000000000000000000000000;;		BearerToken string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HTTPTimeout is used by the client to timeout http requests to Kubelet.
0000000000000000000000000000000000000000;;		HTTPTimeout time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Dial is a custom dialer used for the client
0000000000000000000000000000000000000000;;		Dial utilnet.DialFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConnectionInfo provides the information needed to connect to a kubelet
0000000000000000000000000000000000000000;;	type ConnectionInfo struct {
0000000000000000000000000000000000000000;;		Scheme    string
0000000000000000000000000000000000000000;;		Hostname  string
0000000000000000000000000000000000000000;;		Port      string
0000000000000000000000000000000000000000;;		Transport http.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConnectionInfoGetter provides ConnectionInfo for the kubelet running on a named node
0000000000000000000000000000000000000000;;	type ConnectionInfoGetter interface {
0000000000000000000000000000000000000000;;		GetConnectionInfo(nodeName types.NodeName) (*ConnectionInfo, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MakeTransport(config *KubeletClientConfig) (http.RoundTripper, error) {
0000000000000000000000000000000000000000;;		tlsConfig, err := transport.TLSConfigFor(config.transportConfig())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rt := http.DefaultTransport
0000000000000000000000000000000000000000;;		if config.Dial != nil || tlsConfig != nil {
0000000000000000000000000000000000000000;;			rt = utilnet.SetOldTransportDefaults(&http.Transport{
0000000000000000000000000000000000000000;;				Dial:            config.Dial,
0000000000000000000000000000000000000000;;				TLSClientConfig: tlsConfig,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return transport.HTTPWrappersForConfig(config.transportConfig(), rt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// transportConfig converts a client config to an appropriate transport config.
0000000000000000000000000000000000000000;;	func (c *KubeletClientConfig) transportConfig() *transport.Config {
0000000000000000000000000000000000000000;;		cfg := &transport.Config{
0000000000000000000000000000000000000000;;			TLS: transport.TLSConfig{
0000000000000000000000000000000000000000;;				CAFile:   c.CAFile,
0000000000000000000000000000000000000000;;				CAData:   c.CAData,
0000000000000000000000000000000000000000;;				CertFile: c.CertFile,
0000000000000000000000000000000000000000;;				CertData: c.CertData,
0000000000000000000000000000000000000000;;				KeyFile:  c.KeyFile,
0000000000000000000000000000000000000000;;				KeyData:  c.KeyData,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			BearerToken: c.BearerToken,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.EnableHttps && !cfg.HasCA() {
0000000000000000000000000000000000000000;;			cfg.TLS.Insecure = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cfg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeGetter defines an interface for looking up a node by name
0000000000000000000000000000000000000000;;	type NodeGetter interface {
0000000000000000000000000000000000000000;;		Get(name string, options metav1.GetOptions) (*v1.Node, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeGetterFunc allows implementing NodeGetter with a function
0000000000000000000000000000000000000000;;	type NodeGetterFunc func(name string, options metav1.GetOptions) (*v1.Node, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f NodeGetterFunc) Get(name string, options metav1.GetOptions) (*v1.Node, error) {
0000000000000000000000000000000000000000;;		return f(name, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeConnectionInfoGetter obtains connection info from the status of a Node API object
0000000000000000000000000000000000000000;;	type NodeConnectionInfoGetter struct {
0000000000000000000000000000000000000000;;		// nodes is used to look up Node objects
0000000000000000000000000000000000000000;;		nodes NodeGetter
0000000000000000000000000000000000000000;;		// scheme is the scheme to use to connect to all kubelets
0000000000000000000000000000000000000000;;		scheme string
0000000000000000000000000000000000000000;;		// defaultPort is the port to use if no Kubelet endpoint port is recorded in the node status
0000000000000000000000000000000000000000;;		defaultPort int
0000000000000000000000000000000000000000;;		// transport is the transport to use to send a request to all kubelets
0000000000000000000000000000000000000000;;		transport http.RoundTripper
0000000000000000000000000000000000000000;;		// preferredAddressTypes specifies the preferred order to use to find a node address
0000000000000000000000000000000000000000;;		preferredAddressTypes []v1.NodeAddressType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNodeConnectionInfoGetter(nodes NodeGetter, config KubeletClientConfig) (ConnectionInfoGetter, error) {
0000000000000000000000000000000000000000;;		scheme := "http"
0000000000000000000000000000000000000000;;		if config.EnableHttps {
0000000000000000000000000000000000000000;;			scheme = "https"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		transport, err := MakeTransport(&config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		types := []v1.NodeAddressType{}
0000000000000000000000000000000000000000;;		for _, t := range config.PreferredAddressTypes {
0000000000000000000000000000000000000000;;			types = append(types, v1.NodeAddressType(t))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &NodeConnectionInfoGetter{
0000000000000000000000000000000000000000;;			nodes:       nodes,
0000000000000000000000000000000000000000;;			scheme:      scheme,
0000000000000000000000000000000000000000;;			defaultPort: int(config.Port),
0000000000000000000000000000000000000000;;			transport:   transport,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			preferredAddressTypes: types,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k *NodeConnectionInfoGetter) GetConnectionInfo(nodeName types.NodeName) (*ConnectionInfo, error) {
0000000000000000000000000000000000000000;;		node, err := k.nodes.Get(string(nodeName), metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find a kubelet-reported address, using preferred address type
0000000000000000000000000000000000000000;;		host, err := nodeutil.GetPreferredNodeAddress(node, k.preferredAddressTypes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use the kubelet-reported port, if present
0000000000000000000000000000000000000000;;		port := int(node.Status.DaemonEndpoints.KubeletEndpoint.Port)
0000000000000000000000000000000000000000;;		if port <= 0 {
0000000000000000000000000000000000000000;;			port = k.defaultPort
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &ConnectionInfo{
0000000000000000000000000000000000000000;;			Scheme:    k.scheme,
0000000000000000000000000000000000000000;;			Hostname:  host,
0000000000000000000000000000000000000000;;			Port:      strconv.Itoa(port),
0000000000000000000000000000000000000000;;			Transport: k.transport,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
