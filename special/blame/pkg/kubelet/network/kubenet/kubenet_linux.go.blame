0000000000000000000000000000000000000000;;	// +build linux
e26d18c6cce81b54f8a4cfc6f0100bcc62343822;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubenet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/containernetworking/cni/libcni"
0000000000000000000000000000000000000000;;		cnitypes "github.com/containernetworking/cni/pkg/types"
0000000000000000000000000000000000000000;;		cnitypes020 "github.com/containernetworking/cni/pkg/types/020"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/vishvananda/netlink"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		utilsets "k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/network"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/network/hostport"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/bandwidth"
0000000000000000000000000000000000000000;;		utildbus "k8s.io/kubernetes/pkg/util/dbus"
0000000000000000000000000000000000000000;;		utilebtables "k8s.io/kubernetes/pkg/util/ebtables"
0000000000000000000000000000000000000000;;		utilexec "k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		utiliptables "k8s.io/kubernetes/pkg/util/iptables"
0000000000000000000000000000000000000000;;		utilsysctl "k8s.io/kubernetes/pkg/util/sysctl"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		BridgeName    = "cbr0"
0000000000000000000000000000000000000000;;		DefaultCNIDir = "/opt/cni/bin"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sysctlBridgeCallIPTables = "net/bridge/bridge-nf-call-iptables"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// fallbackMTU is used if an MTU is not specified, and we cannot determine the MTU
0000000000000000000000000000000000000000;;		fallbackMTU = 1460
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// private mac prefix safe to use
0000000000000000000000000000000000000000;;		// Universally administered and locally administered addresses are distinguished by setting the second-least-significant
0000000000000000000000000000000000000000;;		// bit of the first octet of the address. If it is 1, the address is locally administered. For example, for address 0a:00:00:00:00:00,
0000000000000000000000000000000000000000;;		// the first cotet is 0a(hex), the binary form of which is 00001010, where the second-least-significant bit is 1.
0000000000000000000000000000000000000000;;		privateMACPrefix = "0a:58"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ebtables Chain to store dedup rules
0000000000000000000000000000000000000000;;		dedupChain = utilebtables.Chain("KUBE-DEDUP")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// defaultIPAMDir is the default location for the checkpoint files stored by host-local ipam
0000000000000000000000000000000000000000;;		// https://github.com/containernetworking/cni/tree/master/plugins/ipam/host-local#backends
0000000000000000000000000000000000000000;;		defaultIPAMDir = "/var/lib/cni/networks"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CNI plugins required by kubenet in /opt/cni/bin or vendor directory
0000000000000000000000000000000000000000;;	var requiredCNIPlugins = [...]string{"bridge", "host-local", "loopback"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type kubenetNetworkPlugin struct {
0000000000000000000000000000000000000000;;		network.NoopNetworkPlugin
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		host            network.Host
0000000000000000000000000000000000000000;;		netConfig       *libcni.NetworkConfig
0000000000000000000000000000000000000000;;		loConfig        *libcni.NetworkConfig
0000000000000000000000000000000000000000;;		cniConfig       libcni.CNI
0000000000000000000000000000000000000000;;		bandwidthShaper bandwidth.BandwidthShaper
0000000000000000000000000000000000000000;;		mu              sync.Mutex //Mutex for protecting podIPs map, netConfig, and shaper initialization
0000000000000000000000000000000000000000;;		podIPs          map[kubecontainer.ContainerID]string
0000000000000000000000000000000000000000;;		mtu             int
0000000000000000000000000000000000000000;;		execer          utilexec.Interface
0000000000000000000000000000000000000000;;		nsenterPath     string
0000000000000000000000000000000000000000;;		hairpinMode     componentconfig.HairpinMode
0000000000000000000000000000000000000000;;		// kubenet can use either hostportSyncer and hostportManager to implement hostports
0000000000000000000000000000000000000000;;		// Currently, if network host supports legacy features, hostportSyncer will be used,
0000000000000000000000000000000000000000;;		// otherwise, hostportManager will be used.
0000000000000000000000000000000000000000;;		hostportSyncer  hostport.HostportSyncer
0000000000000000000000000000000000000000;;		hostportManager hostport.HostPortManager
0000000000000000000000000000000000000000;;		iptables        utiliptables.Interface
0000000000000000000000000000000000000000;;		sysctl          utilsysctl.Interface
0000000000000000000000000000000000000000;;		ebtables        utilebtables.Interface
0000000000000000000000000000000000000000;;		// vendorDir is passed by kubelet network-plugin-dir parameter.
0000000000000000000000000000000000000000;;		// kubenet will search for cni binaries in DefaultCNIDir first, then continue to vendorDir.
0000000000000000000000000000000000000000;;		vendorDir         string
0000000000000000000000000000000000000000;;		nonMasqueradeCIDR string
0000000000000000000000000000000000000000;;		podCidr           string
0000000000000000000000000000000000000000;;		gateway           net.IP
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewPlugin(networkPluginDir string) network.NetworkPlugin {
0000000000000000000000000000000000000000;;		protocol := utiliptables.ProtocolIpv4
0000000000000000000000000000000000000000;;		execer := utilexec.New()
0000000000000000000000000000000000000000;;		dbus := utildbus.New()
0000000000000000000000000000000000000000;;		sysctl := utilsysctl.New()
0000000000000000000000000000000000000000;;		iptInterface := utiliptables.New(execer, dbus, protocol)
0000000000000000000000000000000000000000;;		return &kubenetNetworkPlugin{
0000000000000000000000000000000000000000;;			podIPs:            make(map[kubecontainer.ContainerID]string),
0000000000000000000000000000000000000000;;			execer:            utilexec.New(),
0000000000000000000000000000000000000000;;			iptables:          iptInterface,
0000000000000000000000000000000000000000;;			sysctl:            sysctl,
0000000000000000000000000000000000000000;;			vendorDir:         networkPluginDir,
0000000000000000000000000000000000000000;;			hostportSyncer:    hostport.NewHostportSyncer(iptInterface),
0000000000000000000000000000000000000000;;			hostportManager:   hostport.NewHostportManager(iptInterface),
0000000000000000000000000000000000000000;;			nonMasqueradeCIDR: "10.0.0.0/8",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) Init(host network.Host, hairpinMode componentconfig.HairpinMode, nonMasqueradeCIDR string, mtu int) error {
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;		plugin.hairpinMode = hairpinMode
0000000000000000000000000000000000000000;;		plugin.nonMasqueradeCIDR = nonMasqueradeCIDR
0000000000000000000000000000000000000000;;		plugin.cniConfig = &libcni.CNIConfig{
0000000000000000000000000000000000000000;;			Path: []string{DefaultCNIDir, plugin.vendorDir},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mtu == network.UseDefaultMTU {
0000000000000000000000000000000000000000;;			if link, err := findMinMTU(); err == nil {
0000000000000000000000000000000000000000;;				plugin.mtu = link.MTU
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Using interface %s MTU %d as bridge MTU", link.Name, link.MTU)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				plugin.mtu = fallbackMTU
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to find default bridge MTU, using %d: %v", fallbackMTU, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			plugin.mtu = mtu
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Since this plugin uses a Linux bridge, set bridge-nf-call-iptables=1
0000000000000000000000000000000000000000;;		// is necessary to ensure kube-proxy functions correctly.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// This will return an error on older kernel version (< 3.18) as the module
0000000000000000000000000000000000000000;;		// was built-in, we simply ignore the error here. A better thing to do is
0000000000000000000000000000000000000000;;		// to check the kernel version in the future.
0000000000000000000000000000000000000000;;		plugin.execer.Command("modprobe", "br-netfilter").CombinedOutput()
0000000000000000000000000000000000000000;;		err := plugin.sysctl.SetSysctl(sysctlBridgeCallIPTables, 1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("can't set sysctl %s: %v", sysctlBridgeCallIPTables, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugin.loConfig, err = libcni.ConfFromBytes([]byte(`{
0000000000000000000000000000000000000000;;	  "cniVersion": "0.1.0",
0000000000000000000000000000000000000000;;	  "name": "kubenet-loopback",
0000000000000000000000000000000000000000;;	  "type": "loopback"
0000000000000000000000000000000000000000;;	}`))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to generate loopback config: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugin.nsenterPath, err = plugin.execer.LookPath("nsenter")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to find nsenter binary: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Need to SNAT outbound traffic from cluster
0000000000000000000000000000000000000000;;		if err = plugin.ensureMasqRule(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: move thic logic into cni bridge plugin and remove this from kubenet
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) ensureMasqRule() error {
0000000000000000000000000000000000000000;;		if plugin.nonMasqueradeCIDR != "0.0.0.0/0" {
0000000000000000000000000000000000000000;;			if _, err := plugin.iptables.EnsureRule(utiliptables.Append, utiliptables.TableNAT, utiliptables.ChainPostrouting,
0000000000000000000000000000000000000000;;				"-m", "comment", "--comment", "kubenet: SNAT for outbound traffic from cluster",
0000000000000000000000000000000000000000;;				"-m", "addrtype", "!", "--dst-type", "LOCAL",
0000000000000000000000000000000000000000;;				"!", "-d", plugin.nonMasqueradeCIDR,
0000000000000000000000000000000000000000;;				"-j", "MASQUERADE"); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Failed to ensure that %s chain %s jumps to MASQUERADE: %v", utiliptables.TableNAT, utiliptables.ChainPostrouting, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findMinMTU() (*net.Interface, error) {
0000000000000000000000000000000000000000;;		intfs, err := net.Interfaces()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mtu := 999999
0000000000000000000000000000000000000000;;		defIntfIndex := -1
0000000000000000000000000000000000000000;;		for i, intf := range intfs {
0000000000000000000000000000000000000000;;			if ((intf.Flags & net.FlagUp) != 0) && (intf.Flags&(net.FlagLoopback|net.FlagPointToPoint) == 0) {
0000000000000000000000000000000000000000;;				if intf.MTU < mtu {
0000000000000000000000000000000000000000;;					mtu = intf.MTU
0000000000000000000000000000000000000000;;					defIntfIndex = i
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mtu >= 999999 || mtu < 576 || defIntfIndex < 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no suitable interface: %v", BridgeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &intfs[defIntfIndex], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const NET_CONFIG_TEMPLATE = `{
0000000000000000000000000000000000000000;;	  "cniVersion": "0.1.0",
0000000000000000000000000000000000000000;;	  "name": "kubenet",
0000000000000000000000000000000000000000;;	  "type": "bridge",
0000000000000000000000000000000000000000;;	  "bridge": "%s",
0000000000000000000000000000000000000000;;	  "mtu": %d,
0000000000000000000000000000000000000000;;	  "addIf": "%s",
0000000000000000000000000000000000000000;;	  "isGateway": true,
0000000000000000000000000000000000000000;;	  "ipMasq": false,
0000000000000000000000000000000000000000;;	  "hairpinMode": %t,
0000000000000000000000000000000000000000;;	  "ipam": {
0000000000000000000000000000000000000000;;	    "type": "host-local",
0000000000000000000000000000000000000000;;	    "subnet": "%s",
0000000000000000000000000000000000000000;;	    "gateway": "%s",
0000000000000000000000000000000000000000;;	    "routes": [
0000000000000000000000000000000000000000;;	      { "dst": "0.0.0.0/0" }
0000000000000000000000000000000000000000;;	    ]
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) Event(name string, details map[string]interface{}) {
0000000000000000000000000000000000000000;;		if name != network.NET_PLUGIN_EVENT_POD_CIDR_CHANGE {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugin.mu.Lock()
0000000000000000000000000000000000000000;;		defer plugin.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podCIDR, ok := details[network.NET_PLUGIN_EVENT_POD_CIDR_CHANGE_DETAIL_CIDR].(string)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.Warningf("%s event didn't contain pod CIDR", network.NET_PLUGIN_EVENT_POD_CIDR_CHANGE)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if plugin.netConfig != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Ignoring subsequent pod CIDR update to %s", podCIDR)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("PodCIDR is set to %q", podCIDR)
0000000000000000000000000000000000000000;;		_, cidr, err := net.ParseCIDR(podCIDR)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			setHairpin := plugin.hairpinMode == componentconfig.HairpinVeth
0000000000000000000000000000000000000000;;			// Set bridge address to first address in IPNet
0000000000000000000000000000000000000000;;			cidr.IP[len(cidr.IP)-1] += 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			json := fmt.Sprintf(NET_CONFIG_TEMPLATE, BridgeName, plugin.mtu, network.DefaultInterfaceName, setHairpin, podCIDR, cidr.IP.String())
0000000000000000000000000000000000000000;;			glog.V(2).Infof("CNI network config set to %v", json)
0000000000000000000000000000000000000000;;			plugin.netConfig, err = libcni.ConfFromBytes([]byte(json))
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("CNI network config:\n%s", json)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Ensure cbr0 has no conflicting addresses; CNI's 'bridge'
0000000000000000000000000000000000000000;;				// plugin will bail out if the bridge has an unexpected one
0000000000000000000000000000000000000000;;				plugin.clearBridgeAddressesExcept(cidr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			plugin.podCidr = podCIDR
0000000000000000000000000000000000000000;;			plugin.gateway = cidr.IP
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Failed to generate CNI network config: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) clearBridgeAddressesExcept(keep *net.IPNet) {
0000000000000000000000000000000000000000;;		bridge, err := netlink.LinkByName(BridgeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addrs, err := netlink.AddrList(bridge, syscall.AF_INET)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, addr := range addrs {
0000000000000000000000000000000000000000;;			if !utilnet.IPNetEqual(addr.IPNet, keep) {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Removing old address %s from %s", addr.IPNet.String(), BridgeName)
0000000000000000000000000000000000000000;;				netlink.AddrDel(bridge, &addr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) Name() string {
0000000000000000000000000000000000000000;;		return KubenetPluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) Capabilities() utilsets.Int {
0000000000000000000000000000000000000000;;		return utilsets.NewInt()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setup sets up networking through CNI using the given ns/name and sandbox ID.
0000000000000000000000000000000000000000;;	// TODO: Don't pass the pod to this method, it only needs it for bandwidth
0000000000000000000000000000000000000000;;	// shaping and hostport management.
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) setup(namespace string, name string, id kubecontainer.ContainerID, pod *v1.Pod, annotations map[string]string) error {
0000000000000000000000000000000000000000;;		// Bring up container loopback interface
0000000000000000000000000000000000000000;;		if _, err := plugin.addContainerToNetwork(plugin.loConfig, "lo", namespace, name, id); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Hook container up with our bridge
0000000000000000000000000000000000000000;;		resT, err := plugin.addContainerToNetwork(plugin.netConfig, network.DefaultInterfaceName, namespace, name, id)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Coerce the CNI result version
0000000000000000000000000000000000000000;;		res, err := cnitypes020.GetResult(resT)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to understand network config: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if res.IP4 == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("CNI plugin reported no IPv4 address for container %v.", id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ip4 := res.IP4.IP.IP.To4()
0000000000000000000000000000000000000000;;		if ip4 == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("CNI plugin reported an invalid IPv4 address for container %v: %+v.", id, res.IP4)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Explicitly assign mac address to cbr0. If bridge mac address is not explicitly set will adopt the lowest MAC address of the attached veths.
0000000000000000000000000000000000000000;;		// TODO: Remove this once upstream cni bridge plugin handles this
0000000000000000000000000000000000000000;;		link, err := netlink.LinkByName(BridgeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to lookup %q: %v", BridgeName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		macAddr, err := generateHardwareAddr(plugin.gateway)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Configure %q mac address to %v", BridgeName, macAddr)
0000000000000000000000000000000000000000;;		err = netlink.LinkSetHardwareAddr(link, macAddr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to configure %q mac address to %q: %v", BridgeName, macAddr, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Put the container bridge into promiscuous mode to force it to accept hairpin packets.
0000000000000000000000000000000000000000;;		// TODO: Remove this once the kernel bug (#20096) is fixed.
0000000000000000000000000000000000000000;;		// TODO: check and set promiscuous mode with netlink once vishvananda/netlink supports it
0000000000000000000000000000000000000000;;		if plugin.hairpinMode == componentconfig.PromiscuousBridge {
0000000000000000000000000000000000000000;;			output, err := plugin.execer.Command("ip", "link", "show", "dev", BridgeName).CombinedOutput()
0000000000000000000000000000000000000000;;			if err != nil || strings.Index(string(output), "PROMISC") < 0 {
0000000000000000000000000000000000000000;;				_, err := plugin.execer.Command("ip", "link", "set", BridgeName, "promisc", "on").CombinedOutput()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("Error setting promiscuous mode on %s: %v", BridgeName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// configure the ebtables rules to eliminate duplicate packets by best effort
0000000000000000000000000000000000000000;;			plugin.syncEbtablesDedupRules(macAddr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugin.podIPs[id] = ip4.String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The first SetUpPod call creates the bridge; get a shaper for the sake of initialization
0000000000000000000000000000000000000000;;		// TODO: replace with CNI traffic shaper plugin
0000000000000000000000000000000000000000;;		shaper := plugin.shaper()
0000000000000000000000000000000000000000;;		ingress, egress, err := bandwidth.ExtractPodBandwidthResources(annotations)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error reading pod bandwidth annotations: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if egress != nil || ingress != nil {
0000000000000000000000000000000000000000;;			if err := shaper.ReconcileCIDR(fmt.Sprintf("%s/32", ip4.String()), egress, ingress); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Failed to add pod to shaper: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The host can choose to not support "legacy" features. The remote
0000000000000000000000000000000000000000;;		// shim doesn't support it (#35457), but the kubelet does.
0000000000000000000000000000000000000000;;		if plugin.host.SupportsLegacyFeatures() {
0000000000000000000000000000000000000000;;			// Open any hostport the pod's containers want
0000000000000000000000000000000000000000;;			activePodPortMappings, err := plugin.getPodPortMappings()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			newPodPortMapping := hostport.ConstructPodPortMapping(pod, ip4)
0000000000000000000000000000000000000000;;			if err := plugin.hostportSyncer.OpenPodHostportsAndSync(newPodPortMapping, BridgeName, activePodPortMappings); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// TODO: replace with CNI port-forwarding plugin
0000000000000000000000000000000000000000;;			portMappings, err := plugin.host.GetPodPortMappings(id.ID)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if portMappings != nil && len(portMappings) > 0 {
0000000000000000000000000000000000000000;;				if err := plugin.hostportManager.Add(id.ID, &hostport.PodPortMapping{
0000000000000000000000000000000000000000;;					Namespace:    namespace,
0000000000000000000000000000000000000000;;					Name:         name,
0000000000000000000000000000000000000000;;					PortMappings: portMappings,
0000000000000000000000000000000000000000;;					IP:           ip4,
0000000000000000000000000000000000000000;;					HostNetwork:  false,
0000000000000000000000000000000000000000;;				}, BridgeName); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) SetUpPod(namespace string, name string, id kubecontainer.ContainerID, annotations map[string]string) error {
0000000000000000000000000000000000000000;;		plugin.mu.Lock()
0000000000000000000000000000000000000000;;		defer plugin.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("SetUpPod took %v for %s/%s", time.Since(start), namespace, name)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Entire pod object only required for bw shaping and hostport.
0000000000000000000000000000000000000000;;		pod, ok := plugin.host.GetPodByName(namespace, name)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("pod %q cannot be found", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := plugin.Status(); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Kubenet cannot SetUpPod: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := plugin.setup(namespace, name, id, pod, annotations); err != nil {
0000000000000000000000000000000000000000;;			// Make sure everything gets cleaned up on errors
0000000000000000000000000000000000000000;;			podIP, _ := plugin.podIPs[id]
0000000000000000000000000000000000000000;;			if err := plugin.teardown(namespace, name, id, podIP); err != nil {
0000000000000000000000000000000000000000;;				// Not a hard error or warning
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Failed to clean up %s/%s after SetUpPod failure: %v", namespace, name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO(#34278): Figure out if we need IP GC through the cri.
0000000000000000000000000000000000000000;;			// The cri should always send us teardown events for stale sandboxes,
0000000000000000000000000000000000000000;;			// this obviates the need for GC in the common case, for kubenet.
0000000000000000000000000000000000000000;;			if plugin.host.SupportsLegacyFeatures() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// TODO: Remove this hack once we've figured out how to retrieve the netns
0000000000000000000000000000000000000000;;				// of an exited container. Currently, restarting docker will leak a bunch of
0000000000000000000000000000000000000000;;				// ips. This will exhaust available ip space unless we cleanup old ips. At the
0000000000000000000000000000000000000000;;				// same time we don't want to try GC'ing them periodically as that could lead
0000000000000000000000000000000000000000;;				// to a performance regression in starting pods. So on each setup failure, try
0000000000000000000000000000000000000000;;				// GC on the assumption that the kubelet is going to retry pod creation, and
0000000000000000000000000000000000000000;;				// when it does, there will be ips.
0000000000000000000000000000000000000000;;				plugin.ipamGarbageCollection()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Need to SNAT outbound traffic from cluster
0000000000000000000000000000000000000000;;		if err := plugin.ensureMasqRule(); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to ensure MASQ rule: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tears down as much of a pod's network as it can even if errors occur.  Returns
0000000000000000000000000000000000000000;;	// an aggregate error composed of all errors encountered during the teardown.
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) teardown(namespace string, name string, id kubecontainer.ContainerID, podIP string) error {
0000000000000000000000000000000000000000;;		errList := []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if podIP != "" {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("Removing pod IP %s from shaper", podIP)
0000000000000000000000000000000000000000;;			// shaper wants /32
0000000000000000000000000000000000000000;;			if err := plugin.shaper().Reset(fmt.Sprintf("%s/32", podIP)); err != nil {
0000000000000000000000000000000000000000;;				// Possible bandwidth shaping wasn't enabled for this pod anyways
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Failed to remove pod IP %s from shaper: %v", podIP, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			delete(plugin.podIPs, id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := plugin.delContainerFromNetwork(plugin.netConfig, network.DefaultInterfaceName, namespace, name, id); err != nil {
0000000000000000000000000000000000000000;;			// This is to prevent returning error when TearDownPod is called twice on the same pod. This helps to reduce event pollution.
0000000000000000000000000000000000000000;;			if podIP != "" {
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to delete container from kubenet: %v", err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				errList = append(errList, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The host can choose to not support "legacy" features. The remote
0000000000000000000000000000000000000000;;		// shim doesn't support it (#35457), but the kubelet does.
0000000000000000000000000000000000000000;;		if plugin.host.SupportsLegacyFeatures() {
0000000000000000000000000000000000000000;;			activePodPortMapping, err := plugin.getPodPortMappings()
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				err = plugin.hostportSyncer.SyncHostports(BridgeName, activePodPortMapping)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errList = append(errList, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			portMappings, err := plugin.host.GetPodPortMappings(id.ID)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errList = append(errList, err)
0000000000000000000000000000000000000000;;			} else if portMappings != nil && len(portMappings) > 0 {
0000000000000000000000000000000000000000;;				if err = plugin.hostportManager.Remove(id.ID, &hostport.PodPortMapping{
0000000000000000000000000000000000000000;;					Namespace:    namespace,
0000000000000000000000000000000000000000;;					Name:         name,
0000000000000000000000000000000000000000;;					PortMappings: portMappings,
0000000000000000000000000000000000000000;;					HostNetwork:  false,
0000000000000000000000000000000000000000;;				}); err != nil {
0000000000000000000000000000000000000000;;					errList = append(errList, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(errList)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) TearDownPod(namespace string, name string, id kubecontainer.ContainerID) error {
0000000000000000000000000000000000000000;;		plugin.mu.Lock()
0000000000000000000000000000000000000000;;		defer plugin.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("TearDownPod took %v for %s/%s", time.Since(start), namespace, name)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if plugin.netConfig == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Kubenet needs a PodCIDR to tear down pods")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// no cached IP is Ok during teardown
0000000000000000000000000000000000000000;;		podIP, _ := plugin.podIPs[id]
0000000000000000000000000000000000000000;;		if err := plugin.teardown(namespace, name, id, podIP); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Need to SNAT outbound traffic from cluster
0000000000000000000000000000000000000000;;		if err := plugin.ensureMasqRule(); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to ensure MASQ rule: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Use the addToNetwork function to obtain the IP of the Pod. That will assume idempotent ADD call to the plugin.
0000000000000000000000000000000000000000;;	// Also fix the runtime's call to Status function to be done only in the case that the IP is lost, no need to do periodic calls
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) GetPodNetworkStatus(namespace string, name string, id kubecontainer.ContainerID) (*network.PodNetworkStatus, error) {
0000000000000000000000000000000000000000;;		plugin.mu.Lock()
0000000000000000000000000000000000000000;;		defer plugin.mu.Unlock()
0000000000000000000000000000000000000000;;		// Assuming the ip of pod does not change. Try to retrieve ip from kubenet map first.
0000000000000000000000000000000000000000;;		if podIP, ok := plugin.podIPs[id]; ok {
0000000000000000000000000000000000000000;;			return &network.PodNetworkStatus{IP: net.ParseIP(podIP)}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		netnsPath, err := plugin.host.GetNetNS(id.ID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Kubenet failed to retrieve network namespace path: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if netnsPath == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Cannot find the network namespace, skipping pod network status for container %q", id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ip, err := network.GetPodIP(plugin.execer, plugin.nsenterPath, netnsPath, network.DefaultInterfaceName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugin.podIPs[id] = ip.String()
0000000000000000000000000000000000000000;;		return &network.PodNetworkStatus{IP: ip}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) Status() error {
0000000000000000000000000000000000000000;;		// Can't set up pods if we don't have a PodCIDR yet
0000000000000000000000000000000000000000;;		if plugin.netConfig == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Kubenet does not have netConfig. This is most likely due to lack of PodCIDR")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !plugin.checkCNIPlugin() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("could not locate kubenet required CNI plugins %v at %q or %q", requiredCNIPlugins, DefaultCNIDir, plugin.vendorDir)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkCNIPlugin returns if all kubenet required cni plugins can be found at /opt/cni/bin or user specifed NetworkPluginDir.
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) checkCNIPlugin() bool {
0000000000000000000000000000000000000000;;		if plugin.checkCNIPluginInDir(DefaultCNIDir) || plugin.checkCNIPluginInDir(plugin.vendorDir) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkCNIPluginInDir returns if all required cni plugins are placed in dir
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) checkCNIPluginInDir(dir string) bool {
0000000000000000000000000000000000000000;;		files, err := ioutil.ReadDir(dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, cniPlugin := range requiredCNIPlugins {
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			for _, file := range files {
0000000000000000000000000000000000000000;;				if strings.TrimSpace(file.Name()) == cniPlugin {
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getNonExitedPods returns a list of pods that have at least one running container.
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) getNonExitedPods() ([]*kubecontainer.Pod, error) {
0000000000000000000000000000000000000000;;		ret := []*kubecontainer.Pod{}
0000000000000000000000000000000000000000;;		pods, err := plugin.host.GetRuntime().GetPods(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Failed to retrieve pods from runtime: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, p := range pods {
0000000000000000000000000000000000000000;;			if podIsExited(p) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ret = append(ret, p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) getPodPortMappings() ([]*hostport.PodPortMapping, error) {
0000000000000000000000000000000000000000;;		pods, err := plugin.getNonExitedPods()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		activePodPortMappings := make([]*hostport.PodPortMapping, 0)
0000000000000000000000000000000000000000;;		for _, p := range pods {
0000000000000000000000000000000000000000;;			containerID, err := plugin.host.GetRuntime().GetPodContainerID(p)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ipString, ok := plugin.podIPs[containerID]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podIP := net.ParseIP(ipString)
0000000000000000000000000000000000000000;;			if podIP == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pod, ok := plugin.host.GetPodByName(p.Namespace, p.Name); ok {
0000000000000000000000000000000000000000;;				activePodPortMappings = append(activePodPortMappings, hostport.ConstructPodPortMapping(pod, podIP))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return activePodPortMappings, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ipamGarbageCollection will release unused IP.
0000000000000000000000000000000000000000;;	// kubenet uses the CNI bridge plugin, which stores allocated ips on file. Each
0000000000000000000000000000000000000000;;	// file created under defaultIPAMDir has the format: ip/container-hash. So this
0000000000000000000000000000000000000000;;	// routine looks for hashes that are not reported by the currently running docker,
0000000000000000000000000000000000000000;;	// and invokes DelNetwork on each one. Note that this will only work for the
0000000000000000000000000000000000000000;;	// current CNI bridge plugin, because we have no way of finding the NetNs.
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) ipamGarbageCollection() {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Starting IP garbage collection")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ipamDir := filepath.Join(defaultIPAMDir, KubenetPluginName)
0000000000000000000000000000000000000000;;		files, err := ioutil.ReadDir(ipamDir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to list files in %q: %v", ipamDir, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// gather containerIDs for allocated ips
0000000000000000000000000000000000000000;;		ipContainerIdMap := make(map[string]string)
0000000000000000000000000000000000000000;;		for _, file := range files {
0000000000000000000000000000000000000000;;			// skip non checkpoint file
0000000000000000000000000000000000000000;;			if ip := net.ParseIP(file.Name()); ip == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			content, err := ioutil.ReadFile(filepath.Join(ipamDir, file.Name()))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to read file %v: %v", file, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ipContainerIdMap[file.Name()] = strings.TrimSpace(string(content))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// gather infra container IDs of current running Pods
0000000000000000000000000000000000000000;;		runningContainerIDs := utilsets.String{}
0000000000000000000000000000000000000000;;		pods, err := plugin.getNonExitedPods()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to get pods: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			containerID, err := plugin.host.GetRuntime().GetPodContainerID(pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to get infra containerID of %q/%q: %v", pod.Namespace, pod.Name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			runningContainerIDs.Insert(strings.TrimSpace(containerID.ID))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// release leaked ips
0000000000000000000000000000000000000000;;		for ip, containerID := range ipContainerIdMap {
0000000000000000000000000000000000000000;;			// if the container is not running, release IP
0000000000000000000000000000000000000000;;			if runningContainerIDs.Has(containerID) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// CNI requires all config to be presented, although only containerID is needed in this case
0000000000000000000000000000000000000000;;			rt := &libcni.RuntimeConf{
0000000000000000000000000000000000000000;;				ContainerID: containerID,
0000000000000000000000000000000000000000;;				IfName:      network.DefaultInterfaceName,
0000000000000000000000000000000000000000;;				// TODO: How do we find the NetNs of an exited container? docker inspect
0000000000000000000000000000000000000000;;				// doesn't show us the pid, so we probably need to checkpoint
0000000000000000000000000000000000000000;;				NetNS: "",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Releasing IP %q allocated to %q.", ip, containerID)
0000000000000000000000000000000000000000;;			// CNI bridge plugin should try to release IP and then return
0000000000000000000000000000000000000000;;			if err := plugin.cniConfig.DelNetwork(plugin.netConfig, rt); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Error while releasing IP: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// podIsExited returns true if the pod is exited (all containers inside are exited).
0000000000000000000000000000000000000000;;	func podIsExited(p *kubecontainer.Pod) bool {
0000000000000000000000000000000000000000;;		for _, c := range p.Containers {
0000000000000000000000000000000000000000;;			if c.State != kubecontainer.ContainerStateExited {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range p.Sandboxes {
0000000000000000000000000000000000000000;;			if c.State != kubecontainer.ContainerStateExited {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) buildCNIRuntimeConf(ifName string, id kubecontainer.ContainerID, needNetNs bool) (*libcni.RuntimeConf, error) {
0000000000000000000000000000000000000000;;		netnsPath, err := plugin.host.GetNetNS(id.ID)
0000000000000000000000000000000000000000;;		if needNetNs && err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Kubenet failed to retrieve network namespace path: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &libcni.RuntimeConf{
0000000000000000000000000000000000000000;;			ContainerID: id.ID,
0000000000000000000000000000000000000000;;			NetNS:       netnsPath,
0000000000000000000000000000000000000000;;			IfName:      ifName,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) addContainerToNetwork(config *libcni.NetworkConfig, ifName, namespace, name string, id kubecontainer.ContainerID) (cnitypes.Result, error) {
0000000000000000000000000000000000000000;;		rt, err := plugin.buildCNIRuntimeConf(ifName, id, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Error building CNI config: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Adding %s/%s to '%s' with CNI '%s' plugin and runtime: %+v", namespace, name, config.Network.Name, config.Network.Type, rt)
0000000000000000000000000000000000000000;;		res, err := plugin.cniConfig.AddNetwork(config, rt)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Error adding container to network: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) delContainerFromNetwork(config *libcni.NetworkConfig, ifName, namespace, name string, id kubecontainer.ContainerID) error {
0000000000000000000000000000000000000000;;		rt, err := plugin.buildCNIRuntimeConf(ifName, id, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error building CNI config: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Removing %s/%s from '%s' with CNI '%s' plugin and runtime: %+v", namespace, name, config.Network.Name, config.Network.Type, rt)
0000000000000000000000000000000000000000;;		if err := plugin.cniConfig.DelNetwork(config, rt); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error removing container from network: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shaper retrieves the bandwidth shaper and, if it hasn't been fetched before,
0000000000000000000000000000000000000000;;	// initializes it and ensures the bridge is appropriately configured
0000000000000000000000000000000000000000;;	// This function should only be called while holding the `plugin.mu` lock
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) shaper() bandwidth.BandwidthShaper {
0000000000000000000000000000000000000000;;		if plugin.bandwidthShaper == nil {
0000000000000000000000000000000000000000;;			plugin.bandwidthShaper = bandwidth.NewTCShaper(BridgeName)
0000000000000000000000000000000000000000;;			plugin.bandwidthShaper.ReconcileInterface()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return plugin.bandwidthShaper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//TODO: make this into a goroutine and rectify the dedup rules periodically
0000000000000000000000000000000000000000;;	func (plugin *kubenetNetworkPlugin) syncEbtablesDedupRules(macAddr net.HardwareAddr) {
0000000000000000000000000000000000000000;;		if plugin.ebtables == nil {
0000000000000000000000000000000000000000;;			plugin.ebtables = utilebtables.New(plugin.execer)
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Flushing dedup chain")
0000000000000000000000000000000000000000;;			if err := plugin.ebtables.FlushChain(utilebtables.TableFilter, dedupChain); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to flush dedup chain: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := plugin.ebtables.GetVersion()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Failed to get ebtables version. Skip syncing ebtables dedup rules: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Filtering packets with ebtables on mac address: %v, gateway: %v, pod CIDR: %v", macAddr.String(), plugin.gateway.String(), plugin.podCidr)
0000000000000000000000000000000000000000;;		_, err = plugin.ebtables.EnsureChain(utilebtables.TableFilter, dedupChain)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to ensure %v chain %v", utilebtables.TableFilter, dedupChain)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = plugin.ebtables.EnsureRule(utilebtables.Append, utilebtables.TableFilter, utilebtables.ChainOutput, "-j", string(dedupChain))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to ensure %v chain %v jump to %v chain: %v", utilebtables.TableFilter, utilebtables.ChainOutput, dedupChain, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		commonArgs := []string{"-p", "IPv4", "-s", macAddr.String(), "-o", "veth+"}
0000000000000000000000000000000000000000;;		_, err = plugin.ebtables.EnsureRule(utilebtables.Prepend, utilebtables.TableFilter, dedupChain, append(commonArgs, "--ip-src", plugin.gateway.String(), "-j", "ACCEPT")...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to ensure packets from cbr0 gateway to be accepted")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = plugin.ebtables.EnsureRule(utilebtables.Append, utilebtables.TableFilter, dedupChain, append(commonArgs, "--ip-src", plugin.podCidr, "-j", "DROP")...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to ensure packets from podCidr but has mac address of cbr0 to get dropped.")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateHardwareAddr generates 48 bit virtual mac addresses based on the IP input.
0000000000000000000000000000000000000000;;	func generateHardwareAddr(ip net.IP) (net.HardwareAddr, error) {
0000000000000000000000000000000000000000;;		if ip.To4() == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("generateHardwareAddr only support valid ipv4 address as input")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mac := privateMACPrefix
0000000000000000000000000000000000000000;;		sections := strings.Split(ip.String(), ".")
0000000000000000000000000000000000000000;;		for _, s := range sections {
0000000000000000000000000000000000000000;;			i, _ := strconv.Atoi(s)
0000000000000000000000000000000000000000;;			mac = mac + ":" + fmt.Sprintf("%02x", i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hwAddr, err := net.ParseMAC(mac)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Failed to parse mac address %s generated based on ip %s due to: %v", mac, ip, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hwAddr, nil
0000000000000000000000000000000000000000;;	}
