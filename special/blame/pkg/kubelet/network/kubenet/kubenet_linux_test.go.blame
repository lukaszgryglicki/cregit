0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
14c8d30746285518661bfce683eab254c53588c9;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubenet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/mock"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/network"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/network/cni/testing"
0000000000000000000000000000000000000000;;		hostporttest "k8s.io/kubernetes/pkg/kubelet/network/hostport/testing"
0000000000000000000000000000000000000000;;		nettest "k8s.io/kubernetes/pkg/kubelet/network/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/bandwidth"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		ipttest "k8s.io/kubernetes/pkg/util/iptables/testing"
0000000000000000000000000000000000000000;;		sysctltest "k8s.io/kubernetes/pkg/util/sysctl/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// test it fulfills the NetworkPlugin interface
0000000000000000000000000000000000000000;;	var _ network.NetworkPlugin = &kubenetNetworkPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFakeKubenetPlugin(initMap map[kubecontainer.ContainerID]string, execer exec.Interface, host network.Host) *kubenetNetworkPlugin {
0000000000000000000000000000000000000000;;		return &kubenetNetworkPlugin{
0000000000000000000000000000000000000000;;			podIPs: initMap,
0000000000000000000000000000000000000000;;			execer: execer,
0000000000000000000000000000000000000000;;			mtu:    1460,
0000000000000000000000000000000000000000;;			host:   host,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetPodNetworkStatus(t *testing.T) {
0000000000000000000000000000000000000000;;		podIPMap := make(map[kubecontainer.ContainerID]string)
0000000000000000000000000000000000000000;;		podIPMap[kubecontainer.ContainerID{ID: "1"}] = "10.245.0.2"
0000000000000000000000000000000000000000;;		podIPMap[kubecontainer.ContainerID{ID: "2"}] = "10.245.0.3"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			id          string
0000000000000000000000000000000000000000;;			expectError bool
0000000000000000000000000000000000000000;;			expectIP    string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			//in podCIDR map
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"1",
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				"10.245.0.2",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"2",
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				"10.245.0.3",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			//not in podCIDR map
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"3",
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;				"",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			//TODO: add test cases for retrieving ip inside container network namespace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeCmds := make([]exec.FakeCommandAction, 0)
0000000000000000000000000000000000000000;;		for _, t := range testCases {
0000000000000000000000000000000000000000;;			// the fake commands return the IP from the given index, or an error
0000000000000000000000000000000000000000;;			fCmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;				CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;					func() ([]byte, error) {
0000000000000000000000000000000000000000;;						ip, ok := podIPMap[kubecontainer.ContainerID{ID: t.id}]
0000000000000000000000000000000000000000;;						if !ok {
0000000000000000000000000000000000000000;;							return nil, fmt.Errorf("Pod IP %q not found", t.id)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return []byte(ip), nil
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fakeCmds = append(fakeCmds, func(cmd string, args ...string) exec.Cmd {
0000000000000000000000000000000000000000;;				return exec.InitFakeCmd(&fCmd, cmd, args...)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: fakeCmds,
0000000000000000000000000000000000000000;;			LookPathFunc: func(file string) (string, error) {
0000000000000000000000000000000000000000;;				return fmt.Sprintf("/fake-bin/%s", file), nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fhost := nettest.NewFakeHost(nil)
0000000000000000000000000000000000000000;;		fakeKubenet := newFakeKubenetPlugin(podIPMap, &fexec, fhost)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			out, err := fakeKubenet.GetPodNetworkStatus("", "", kubecontainer.ContainerID{ID: tc.id})
0000000000000000000000000000000000000000;;			if tc.expectError {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("Test case %d expects error but got none", i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("Test case %d expects error but got error: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tc.expectIP != out.IP.String() {
0000000000000000000000000000000000000000;;				t.Errorf("Test case %d expects ip %s but got %s", i, tc.expectIP, out.IP.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestTeardownCallsShaper tests that a `TearDown` call does call
0000000000000000000000000000000000000000;;	// `shaper.Reset`
0000000000000000000000000000000000000000;;	func TestTeardownCallsShaper(t *testing.T) {
0000000000000000000000000000000000000000;;		fexec := &exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{},
0000000000000000000000000000000000000000;;			LookPathFunc: func(file string) (string, error) {
0000000000000000000000000000000000000000;;				return fmt.Sprintf("/fake-bin/%s", file), nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fhost := nettest.NewFakeHost(nil)
0000000000000000000000000000000000000000;;		fshaper := &bandwidth.FakeShaper{}
0000000000000000000000000000000000000000;;		mockcni := &mock_cni.MockCNI{}
0000000000000000000000000000000000000000;;		kubenet := newFakeKubenetPlugin(map[kubecontainer.ContainerID]string{}, fexec, fhost)
0000000000000000000000000000000000000000;;		kubenet.cniConfig = mockcni
0000000000000000000000000000000000000000;;		kubenet.iptables = ipttest.NewFake()
0000000000000000000000000000000000000000;;		kubenet.bandwidthShaper = fshaper
0000000000000000000000000000000000000000;;		kubenet.hostportSyncer = hostporttest.NewFakeHostportSyncer()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mockcni.On("DelNetwork", mock.AnythingOfType("*libcni.NetworkConfig"), mock.AnythingOfType("*libcni.RuntimeConf")).Return(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		details := make(map[string]interface{})
0000000000000000000000000000000000000000;;		details[network.NET_PLUGIN_EVENT_POD_CIDR_CHANGE_DETAIL_CIDR] = "10.0.0.1/24"
0000000000000000000000000000000000000000;;		kubenet.Event(network.NET_PLUGIN_EVENT_POD_CIDR_CHANGE, details)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existingContainerID := kubecontainer.BuildContainerID("docker", "123")
0000000000000000000000000000000000000000;;		kubenet.podIPs[existingContainerID] = "10.0.0.1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := kubenet.TearDownPod("namespace", "name", existingContainerID); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error in TearDownPod: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		assert.Equal(t, []string{"10.0.0.1/32"}, fshaper.ResetCIDRs, "shaper.Reset should have been called")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mockcni.AssertExpectations(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestInit tests that a `Init` call with an MTU sets the MTU
0000000000000000000000000000000000000000;;	func TestInit_MTU(t *testing.T) {
0000000000000000000000000000000000000000;;		var fakeCmds []exec.FakeCommandAction
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			// modprobe br-netfilter
0000000000000000000000000000000000000000;;			fCmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;				CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;					func() ([]byte, error) {
0000000000000000000000000000000000000000;;						return make([]byte, 0), nil
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fakeCmds = append(fakeCmds, func(cmd string, args ...string) exec.Cmd {
0000000000000000000000000000000000000000;;				return exec.InitFakeCmd(&fCmd, cmd, args...)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fexec := &exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: fakeCmds,
0000000000000000000000000000000000000000;;			LookPathFunc: func(file string) (string, error) {
0000000000000000000000000000000000000000;;				return fmt.Sprintf("/fake-bin/%s", file), nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fhost := nettest.NewFakeHost(nil)
0000000000000000000000000000000000000000;;		kubenet := newFakeKubenetPlugin(map[kubecontainer.ContainerID]string{}, fexec, fhost)
0000000000000000000000000000000000000000;;		kubenet.iptables = ipttest.NewFake()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sysctl := sysctltest.NewFake()
0000000000000000000000000000000000000000;;		sysctl.Settings["net/bridge/bridge-nf-call-iptables"] = 0
0000000000000000000000000000000000000000;;		kubenet.sysctl = sysctl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := kubenet.Init(nettest.NewFakeHost(nil), componentconfig.HairpinNone, "10.0.0.0/8", 1234); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error in Init: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		assert.Equal(t, 1234, kubenet.mtu, "kubenet.mtu should have been set")
0000000000000000000000000000000000000000;;		assert.Equal(t, 1, sysctl.Settings["net/bridge/bridge-nf-call-iptables"], "net/bridge/bridge-nf-call-iptables sysctl should have been set")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGenerateMacAddress(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			ip          net.IP
0000000000000000000000000000000000000000;;			expectedMAC string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ip:          net.ParseIP("10.0.0.2"),
0000000000000000000000000000000000000000;;				expectedMAC: privateMACPrefix + ":0a:00:00:02",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ip:          net.ParseIP("10.250.0.244"),
0000000000000000000000000000000000000000;;				expectedMAC: privateMACPrefix + ":0a:fa:00:f4",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ip:          net.ParseIP("172.17.0.2"),
0000000000000000000000000000000000000000;;				expectedMAC: privateMACPrefix + ":ac:11:00:02",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			mac, err := generateHardwareAddr(tc.ip)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Did not expect error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if mac.String() != tc.expectedMAC {
0000000000000000000000000000000000000000;;				t.Errorf("generated mac: %q, expecting: %q", mac.String(), tc.expectedMAC)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestInvocationWithoutRuntime invokes the plugin without a runtime.
0000000000000000000000000000000000000000;;	// This is how kubenet is invoked from the cri.
0000000000000000000000000000000000000000;;	func TestTearDownWithoutRuntime(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			podCIDR         string
0000000000000000000000000000000000000000;;			ip              string
0000000000000000000000000000000000000000;;			expectedGateway string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podCIDR:         "10.0.0.1/24",
0000000000000000000000000000000000000000;;				ip:              "10.0.0.1",
0000000000000000000000000000000000000000;;				expectedGateway: "10.0.0.1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podCIDR:         "2001:beef::1/48",
0000000000000000000000000000000000000000;;				ip:              "2001:beef::1",
0000000000000000000000000000000000000000;;				expectedGateway: "2001:beef::1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			fhost := nettest.NewFakeHost(nil)
0000000000000000000000000000000000000000;;			fhost.Legacy = false
0000000000000000000000000000000000000000;;			fhost.Runtime = nil
0000000000000000000000000000000000000000;;			mockcni := &mock_cni.MockCNI{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fexec := &exec.FakeExec{
0000000000000000000000000000000000000000;;				CommandScript: []exec.FakeCommandAction{},
0000000000000000000000000000000000000000;;				LookPathFunc: func(file string) (string, error) {
0000000000000000000000000000000000000000;;					return fmt.Sprintf("/fake-bin/%s", file), nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			kubenet := newFakeKubenetPlugin(map[kubecontainer.ContainerID]string{}, fexec, fhost)
0000000000000000000000000000000000000000;;			kubenet.cniConfig = mockcni
0000000000000000000000000000000000000000;;			kubenet.iptables = ipttest.NewFake()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			details := make(map[string]interface{})
0000000000000000000000000000000000000000;;			details[network.NET_PLUGIN_EVENT_POD_CIDR_CHANGE_DETAIL_CIDR] = tc.podCIDR
0000000000000000000000000000000000000000;;			kubenet.Event(network.NET_PLUGIN_EVENT_POD_CIDR_CHANGE, details)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if kubenet.gateway.String() != tc.expectedGateway {
0000000000000000000000000000000000000000;;				t.Errorf("generated gateway: %q, expecting: %q", kubenet.gateway.String(), tc.expectedGateway)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if kubenet.podCidr != tc.podCIDR {
0000000000000000000000000000000000000000;;				t.Errorf("generated podCidr: %q, expecting: %q", kubenet.podCidr, tc.podCIDR)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			existingContainerID := kubecontainer.BuildContainerID("docker", "123")
0000000000000000000000000000000000000000;;			kubenet.podIPs[existingContainerID] = tc.ip
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mockcni.On("DelNetwork", mock.AnythingOfType("*libcni.NetworkConfig"), mock.AnythingOfType("*libcni.RuntimeConf")).Return(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := kubenet.TearDownPod("namespace", "name", existingContainerID); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected error in TearDownPod: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Assert that the CNI DelNetwork made it through and we didn't crash
0000000000000000000000000000000000000000;;			// without a runtime.
0000000000000000000000000000000000000000;;			mockcni.AssertExpectations(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//TODO: add unit test for each implementation of network plugin interface
