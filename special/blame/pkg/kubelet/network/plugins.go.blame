0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
d37c4630c63893cfd200b6a00c0955df82481507;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package network
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		utilsets "k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/network/hostport"
0000000000000000000000000000000000000000;;		utilexec "k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		utilsysctl "k8s.io/kubernetes/pkg/util/sysctl"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const DefaultPluginName = "kubernetes.io/no-op"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Called when the node's Pod CIDR is known when using the
0000000000000000000000000000000000000000;;	// controller manager's --allocate-node-cidrs=true option
0000000000000000000000000000000000000000;;	const NET_PLUGIN_EVENT_POD_CIDR_CHANGE = "pod-cidr-change"
0000000000000000000000000000000000000000;;	const NET_PLUGIN_EVENT_POD_CIDR_CHANGE_DETAIL_CIDR = "pod-cidr"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Plugin is an interface to network plugins for the kubelet
0000000000000000000000000000000000000000;;	type NetworkPlugin interface {
0000000000000000000000000000000000000000;;		// Init initializes the plugin.  This will be called exactly once
0000000000000000000000000000000000000000;;		// before any other methods are called.
0000000000000000000000000000000000000000;;		Init(host Host, hairpinMode componentconfig.HairpinMode, nonMasqueradeCIDR string, mtu int) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Called on various events like:
0000000000000000000000000000000000000000;;		// NET_PLUGIN_EVENT_POD_CIDR_CHANGE
0000000000000000000000000000000000000000;;		Event(name string, details map[string]interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name returns the plugin's name. This will be used when searching
0000000000000000000000000000000000000000;;		// for a plugin by name, e.g.
0000000000000000000000000000000000000000;;		Name() string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns a set of NET_PLUGIN_CAPABILITY_*
0000000000000000000000000000000000000000;;		Capabilities() utilsets.Int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SetUpPod is the method called after the infra container of
0000000000000000000000000000000000000000;;		// the pod has been created but before the other containers of the
0000000000000000000000000000000000000000;;		// pod are launched.
0000000000000000000000000000000000000000;;		// TODO: rename podInfraContainerID to sandboxID
0000000000000000000000000000000000000000;;		SetUpPod(namespace string, name string, podInfraContainerID kubecontainer.ContainerID, annotations map[string]string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TearDownPod is the method called before a pod's infra container will be deleted
0000000000000000000000000000000000000000;;		// TODO: rename podInfraContainerID to sandboxID
0000000000000000000000000000000000000000;;		TearDownPod(namespace string, name string, podInfraContainerID kubecontainer.ContainerID) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetPodNetworkStatus is the method called to obtain the ipv4 or ipv6 addresses of the container
0000000000000000000000000000000000000000;;		// TODO: rename podInfraContainerID to sandboxID
0000000000000000000000000000000000000000;;		GetPodNetworkStatus(namespace string, name string, podInfraContainerID kubecontainer.ContainerID) (*PodNetworkStatus, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status returns error if the network plugin is in error state
0000000000000000000000000000000000000000;;		Status() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodNetworkStatus stores the network status of a pod (currently just the primary IP address)
0000000000000000000000000000000000000000;;	// This struct represents version "v1beta1"
0000000000000000000000000000000000000000;;	type PodNetworkStatus struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IP is the primary ipv4/ipv6 address of the pod. Among other things it is the address that -
0000000000000000000000000000000000000000;;		//   - kube expects to be reachable across the cluster
0000000000000000000000000000000000000000;;		//   - service endpoints are constructed with
0000000000000000000000000000000000000000;;		//   - will be reported in the PodStatus.PodIP field (will override the IP reported by docker)
0000000000000000000000000000000000000000;;		IP net.IP `json:"ip" description:"Primary IP address of the pod"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LegacyHost implements the methods required by network plugins that
0000000000000000000000000000000000000000;;	// were directly invoked by the kubelet. Implementations of this interface
0000000000000000000000000000000000000000;;	// that do not wish to support these features can simply return false
0000000000000000000000000000000000000000;;	// to SupportsLegacyFeatures.
0000000000000000000000000000000000000000;;	type LegacyHost interface {
0000000000000000000000000000000000000000;;		// Get the pod structure by its name, namespace
0000000000000000000000000000000000000000;;		// Only used for hostport management and bw shaping
0000000000000000000000000000000000000000;;		GetPodByName(namespace, name string) (*v1.Pod, bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetKubeClient returns a client interface
0000000000000000000000000000000000000000;;		// Only used in testing
0000000000000000000000000000000000000000;;		GetKubeClient() clientset.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetContainerRuntime returns the container runtime that implements the containers (e.g. docker/rkt)
0000000000000000000000000000000000000000;;		// Only used for hostport management
0000000000000000000000000000000000000000;;		GetRuntime() kubecontainer.Runtime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SupportsLegacyFeatures returns true if the network host support GetPodByName, KubeClient interface and kubelet
0000000000000000000000000000000000000000;;		// runtime interface. These interfaces will no longer be implemented by CRI shims.
0000000000000000000000000000000000000000;;		// This function helps network plugins to choose their behavior based on runtime.
0000000000000000000000000000000000000000;;		SupportsLegacyFeatures() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Host is an interface that plugins can use to access the kubelet.
0000000000000000000000000000000000000000;;	// TODO(#35457): get rid of this backchannel to the kubelet. The scope of
0000000000000000000000000000000000000000;;	// the back channel is restricted to host-ports/testing, and restricted
0000000000000000000000000000000000000000;;	// to kubenet. No other network plugin wrapper needs it. Other plugins
0000000000000000000000000000000000000000;;	// only require a way to access namespace information and port mapping
0000000000000000000000000000000000000000;;	// information , which they can do directly through the embedded interfaces.
0000000000000000000000000000000000000000;;	type Host interface {
0000000000000000000000000000000000000000;;		// NamespaceGetter is a getter for sandbox namespace information.
0000000000000000000000000000000000000000;;		NamespaceGetter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PortMappingGetter is a getter for sandbox port mapping information.
0000000000000000000000000000000000000000;;		PortMappingGetter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// LegacyHost contains methods that trap back into the Kubelet. Dependence
0000000000000000000000000000000000000000;;		// *do not* add more dependencies in this interface. In a post-cri world,
0000000000000000000000000000000000000000;;		// network plugins will be invoked by the runtime shim, and should only
0000000000000000000000000000000000000000;;		// require GetNetNS and GetPodPortMappings.
0000000000000000000000000000000000000000;;		LegacyHost
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceGetter is an interface to retrieve namespace information for a given
0000000000000000000000000000000000000000;;	// sandboxID. Typically implemented by runtime shims that are closely coupled to
0000000000000000000000000000000000000000;;	// CNI plugin wrappers like kubenet.
0000000000000000000000000000000000000000;;	type NamespaceGetter interface {
0000000000000000000000000000000000000000;;		// GetNetNS returns network namespace information for the given containerID.
0000000000000000000000000000000000000000;;		// Runtimes should *never* return an empty namespace and nil error for
0000000000000000000000000000000000000000;;		// a container; if error is nil then the namespace string must be valid.
0000000000000000000000000000000000000000;;		GetNetNS(containerID string) (string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PortMappingGetter is an interface to retrieve port mapping information for a given
0000000000000000000000000000000000000000;;	// sandboxID. Typically implemented by runtime shims that are closely coupled to
0000000000000000000000000000000000000000;;	// CNI plugin wrappers like kubenet.
0000000000000000000000000000000000000000;;	type PortMappingGetter interface {
0000000000000000000000000000000000000000;;		// GetPodPortMappings returns sandbox port mappings information.
0000000000000000000000000000000000000000;;		GetPodPortMappings(containerID string) ([]*hostport.PortMapping, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InitNetworkPlugin inits the plugin that matches networkPluginName. Plugins must have unique names.
0000000000000000000000000000000000000000;;	func InitNetworkPlugin(plugins []NetworkPlugin, networkPluginName string, host Host, hairpinMode componentconfig.HairpinMode, nonMasqueradeCIDR string, mtu int) (NetworkPlugin, error) {
0000000000000000000000000000000000000000;;		if networkPluginName == "" {
0000000000000000000000000000000000000000;;			// default to the no_op plugin
0000000000000000000000000000000000000000;;			plug := &NoopNetworkPlugin{}
0000000000000000000000000000000000000000;;			if err := plug.Init(host, hairpinMode, nonMasqueradeCIDR, mtu); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return plug, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pluginMap := map[string]NetworkPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs := []error{}
0000000000000000000000000000000000000000;;		for _, plugin := range plugins {
0000000000000000000000000000000000000000;;			name := plugin.Name()
0000000000000000000000000000000000000000;;			if errs := validation.IsQualifiedName(name); len(errs) != 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("network plugin has invalid name: %q: %s", name, strings.Join(errs, ";")))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, found := pluginMap[name]; found {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("network plugin %q was registered more than once", name))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pluginMap[name] = plugin
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		chosenPlugin := pluginMap[networkPluginName]
0000000000000000000000000000000000000000;;		if chosenPlugin != nil {
0000000000000000000000000000000000000000;;			err := chosenPlugin.Init(host, hairpinMode, nonMasqueradeCIDR, mtu)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("Network plugin %q failed init: %v", networkPluginName, err))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.V(1).Infof("Loaded network plugin %q", networkPluginName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, fmt.Errorf("Network plugin %q not found.", networkPluginName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return chosenPlugin, utilerrors.NewAggregate(allErrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func UnescapePluginName(in string) string {
0000000000000000000000000000000000000000;;		return strings.Replace(in, "~", "/", -1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NoopNetworkPlugin struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const sysctlBridgeCallIPTables = "net/bridge/bridge-nf-call-iptables"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *NoopNetworkPlugin) Init(host Host, hairpinMode componentconfig.HairpinMode, nonMasqueradeCIDR string, mtu int) error {
0000000000000000000000000000000000000000;;		// Set bridge-nf-call-iptables=1 to maintain compatibility with older
0000000000000000000000000000000000000000;;		// kubernetes versions to ensure the iptables-based kube proxy functions
0000000000000000000000000000000000000000;;		// correctly.  Other plugins are responsible for setting this correctly
0000000000000000000000000000000000000000;;		// depending on whether or not they connect containers to Linux bridges
0000000000000000000000000000000000000000;;		// or use some other mechanism (ie, SDN vswitch).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure the netfilter module is loaded on kernel >= 3.18; previously
0000000000000000000000000000000000000000;;		// it was built-in.
0000000000000000000000000000000000000000;;		utilexec.New().Command("modprobe", "br-netfilter").CombinedOutput()
0000000000000000000000000000000000000000;;		if err := utilsysctl.New().SetSysctl(sysctlBridgeCallIPTables, 1); err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("can't set sysctl %s: %v", sysctlBridgeCallIPTables, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *NoopNetworkPlugin) Event(name string, details map[string]interface{}) {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *NoopNetworkPlugin) Name() string {
0000000000000000000000000000000000000000;;		return DefaultPluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *NoopNetworkPlugin) Capabilities() utilsets.Int {
0000000000000000000000000000000000000000;;		return utilsets.NewInt()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *NoopNetworkPlugin) SetUpPod(namespace string, name string, id kubecontainer.ContainerID, annotations map[string]string) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *NoopNetworkPlugin) TearDownPod(namespace string, name string, id kubecontainer.ContainerID) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *NoopNetworkPlugin) GetPodNetworkStatus(namespace string, name string, id kubecontainer.ContainerID) (*PodNetworkStatus, error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *NoopNetworkPlugin) Status() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getOnePodIP(execer utilexec.Interface, nsenterPath, netnsPath, interfaceName, addrType string) (net.IP, error) {
0000000000000000000000000000000000000000;;		// Try to retrieve ip inside container network namespace
0000000000000000000000000000000000000000;;		output, err := execer.Command(nsenterPath, fmt.Sprintf("--net=%s", netnsPath), "-F", "--",
0000000000000000000000000000000000000000;;			"ip", "-o", addrType, "addr", "show", "dev", interfaceName, "scope", "global").CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unexpected command output %s with error: %v", output, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lines := strings.Split(string(output), "\n")
0000000000000000000000000000000000000000;;		if len(lines) < 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unexpected command output %s", output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fields := strings.Fields(lines[0])
0000000000000000000000000000000000000000;;		if len(fields) < 4 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unexpected address output %s ", lines[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ip, _, err := net.ParseCIDR(fields[3])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("CNI failed to parse ip from output %s due to %v", output, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ip, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPodIP gets the IP of the pod by inspecting the network info inside the pod's network namespace.
0000000000000000000000000000000000000000;;	func GetPodIP(execer utilexec.Interface, nsenterPath, netnsPath, interfaceName string) (net.IP, error) {
0000000000000000000000000000000000000000;;		ip, err := getOnePodIP(execer, nsenterPath, netnsPath, interfaceName, "-4")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Fall back to IPv6 address if no IPv4 address is present
0000000000000000000000000000000000000000;;			ip, err = getOnePodIP(execer, nsenterPath, netnsPath, interfaceName, "-6")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ip, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NoopPortMappingGetter struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*NoopPortMappingGetter) GetPodPortMappings(containerID string) ([]*hostport.PortMapping, error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The PluginManager wraps a kubelet network plugin and provides synchronization
0000000000000000000000000000000000000000;;	// for a given pod's network operations.  Each pod's setup/teardown/status operations
0000000000000000000000000000000000000000;;	// are synchronized against each other, but network operations of other pods can
0000000000000000000000000000000000000000;;	// proceed in parallel.
0000000000000000000000000000000000000000;;	type PluginManager struct {
0000000000000000000000000000000000000000;;		// Network plugin being wrapped
0000000000000000000000000000000000000000;;		plugin NetworkPlugin
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pod list and lock
0000000000000000000000000000000000000000;;		podsLock sync.Mutex
0000000000000000000000000000000000000000;;		pods     map[string]*podLock
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewPluginManager(plugin NetworkPlugin) *PluginManager {
0000000000000000000000000000000000000000;;		return &PluginManager{
0000000000000000000000000000000000000000;;			plugin: plugin,
0000000000000000000000000000000000000000;;			pods:   make(map[string]*podLock),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *PluginManager) PluginName() string {
0000000000000000000000000000000000000000;;		return pm.plugin.Name()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *PluginManager) Event(name string, details map[string]interface{}) {
0000000000000000000000000000000000000000;;		pm.plugin.Event(name, details)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *PluginManager) Status() error {
0000000000000000000000000000000000000000;;		return pm.plugin.Status()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type podLock struct {
0000000000000000000000000000000000000000;;		// Count of in-flight operations for this pod; when this reaches zero
0000000000000000000000000000000000000000;;		// the lock can be removed from the pod map
0000000000000000000000000000000000000000;;		refcount uint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Lock to synchronize operations for this specific pod
0000000000000000000000000000000000000000;;		mu sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lock network operations for a specific pod.  If that pod is not yet in
0000000000000000000000000000000000000000;;	// the pod map, it will be added.  The reference count for the pod will
0000000000000000000000000000000000000000;;	// be increased.
0000000000000000000000000000000000000000;;	func (pm *PluginManager) podLock(fullPodName string) *sync.Mutex {
0000000000000000000000000000000000000000;;		pm.podsLock.Lock()
0000000000000000000000000000000000000000;;		defer pm.podsLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lock, ok := pm.pods[fullPodName]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			lock = &podLock{}
0000000000000000000000000000000000000000;;			pm.pods[fullPodName] = lock
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lock.refcount++
0000000000000000000000000000000000000000;;		return &lock.mu
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unlock network operations for a specific pod.  The reference count for the
0000000000000000000000000000000000000000;;	// pod will be decreased.  If the reference count reaches zero, the pod will be
0000000000000000000000000000000000000000;;	// removed from the pod map.
0000000000000000000000000000000000000000;;	func (pm *PluginManager) podUnlock(fullPodName string) {
0000000000000000000000000000000000000000;;		pm.podsLock.Lock()
0000000000000000000000000000000000000000;;		defer pm.podsLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lock, ok := pm.pods[fullPodName]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.Warningf("Unbalanced pod lock unref for %s", fullPodName)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		} else if lock.refcount == 0 {
0000000000000000000000000000000000000000;;			// This should never ever happen, but handle it anyway
0000000000000000000000000000000000000000;;			delete(pm.pods, fullPodName)
0000000000000000000000000000000000000000;;			glog.Warningf("Pod lock for %s still in map with zero refcount", fullPodName)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lock.refcount--
0000000000000000000000000000000000000000;;		lock.mu.Unlock()
0000000000000000000000000000000000000000;;		if lock.refcount == 0 {
0000000000000000000000000000000000000000;;			delete(pm.pods, fullPodName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *PluginManager) GetPodNetworkStatus(podNamespace, podName string, id kubecontainer.ContainerID) (*PodNetworkStatus, error) {
0000000000000000000000000000000000000000;;		fullPodName := kubecontainer.BuildPodFullName(podName, podNamespace)
0000000000000000000000000000000000000000;;		pm.podLock(fullPodName).Lock()
0000000000000000000000000000000000000000;;		defer pm.podUnlock(fullPodName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		netStatus, err := pm.plugin.GetPodNetworkStatus(podNamespace, podName, id)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("NetworkPlugin %s failed on the status hook for pod %q: %v", pm.plugin.Name(), fullPodName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return netStatus, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *PluginManager) SetUpPod(podNamespace, podName string, id kubecontainer.ContainerID, annotations map[string]string) error {
0000000000000000000000000000000000000000;;		fullPodName := kubecontainer.BuildPodFullName(podName, podNamespace)
0000000000000000000000000000000000000000;;		pm.podLock(fullPodName).Lock()
0000000000000000000000000000000000000000;;		defer pm.podUnlock(fullPodName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Calling network plugin %s to set up pod %q", pm.plugin.Name(), fullPodName)
0000000000000000000000000000000000000000;;		if err := pm.plugin.SetUpPod(podNamespace, podName, id, annotations); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("NetworkPlugin %s failed to set up pod %q network: %v", pm.plugin.Name(), fullPodName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *PluginManager) TearDownPod(podNamespace, podName string, id kubecontainer.ContainerID) error {
0000000000000000000000000000000000000000;;		fullPodName := kubecontainer.BuildPodFullName(podName, podNamespace)
0000000000000000000000000000000000000000;;		pm.podLock(fullPodName).Lock()
0000000000000000000000000000000000000000;;		defer pm.podUnlock(fullPodName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Calling network plugin %s to tear down pod %q", pm.plugin.Name(), fullPodName)
0000000000000000000000000000000000000000;;		if err := pm.plugin.TearDownPod(podNamespace, podName, id); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("NetworkPlugin %s failed to teardown pod %q network: %v", pm.plugin.Name(), fullPodName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
