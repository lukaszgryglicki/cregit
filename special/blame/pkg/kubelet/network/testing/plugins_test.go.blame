0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
4da563c58b4a778f8f7792fbcd8230a2c12ded80;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package testing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilsets "k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/network"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/mock/gomock"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSelectDefaultPlugin(t *testing.T) {
0000000000000000000000000000000000000000;;		all_plugins := []network.NetworkPlugin{}
0000000000000000000000000000000000000000;;		plug, err := network.InitNetworkPlugin(all_plugins, "", NewFakeHost(nil), componentconfig.HairpinNone, "10.0.0.0/8", network.UseDefaultMTU)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error in selecting default plugin: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plug == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to select the default plugin.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plug.Name() != network.DefaultPluginName {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to select the default plugin. Expected %s. Got %s", network.DefaultPluginName, plug.Name())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPluginManager(t *testing.T) {
0000000000000000000000000000000000000000;;		ctrl := gomock.NewController(t)
0000000000000000000000000000000000000000;;		fnp := NewMockNetworkPlugin(ctrl)
0000000000000000000000000000000000000000;;		defer fnp.Finish()
0000000000000000000000000000000000000000;;		pm := network.NewPluginManager(fnp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fnp.EXPECT().Name().Return("someNetworkPlugin").AnyTimes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allCreatedWg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		allCreatedWg.Add(1)
0000000000000000000000000000000000000000;;		allDoneWg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 10 pods, 4 setup/status/teardown runs each.  Ensure that network locking
0000000000000000000000000000000000000000;;		// works and the pod map isn't concurrently accessed
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;			podName := fmt.Sprintf("pod%d", i)
0000000000000000000000000000000000000000;;			containerID := kubecontainer.ContainerID{ID: podName}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fnp.EXPECT().SetUpPod("", podName, containerID).Return(nil).Times(4)
0000000000000000000000000000000000000000;;			fnp.EXPECT().GetPodNetworkStatus("", podName, containerID).Return(&network.PodNetworkStatus{IP: net.ParseIP("1.2.3.4")}, nil).Times(4)
0000000000000000000000000000000000000000;;			fnp.EXPECT().TearDownPod("", podName, containerID).Return(nil).Times(4)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for x := 0; x < 4; x++ {
0000000000000000000000000000000000000000;;				allDoneWg.Add(1)
0000000000000000000000000000000000000000;;				go func(name string, id kubecontainer.ContainerID, num int) {
0000000000000000000000000000000000000000;;					defer allDoneWg.Done()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Block all goroutines from running until all have
0000000000000000000000000000000000000000;;					// been created and are ready.  This ensures we
0000000000000000000000000000000000000000;;					// have more pod network operations running
0000000000000000000000000000000000000000;;					// concurrently.
0000000000000000000000000000000000000000;;					allCreatedWg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if err := pm.SetUpPod("", name, id, nil); err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("Failed to set up pod %q: %v", name, err)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if _, err := pm.GetPodNetworkStatus("", name, id); err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("Failed to inspect pod %q: %v", name, err)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if err := pm.TearDownPod("", name, id); err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("Failed to tear down pod %q: %v", name, err)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}(podName, containerID, x)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Block all goroutines from running until all have been created and started
0000000000000000000000000000000000000000;;		allCreatedWg.Done()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for them all to finish
0000000000000000000000000000000000000000;;		allDoneWg.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hookableFakeNetworkPluginSetupHook func(namespace, name string, id kubecontainer.ContainerID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hookableFakeNetworkPlugin struct {
0000000000000000000000000000000000000000;;		setupHook hookableFakeNetworkPluginSetupHook
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newHookableFakeNetworkPlugin(setupHook hookableFakeNetworkPluginSetupHook) *hookableFakeNetworkPlugin {
0000000000000000000000000000000000000000;;		return &hookableFakeNetworkPlugin{
0000000000000000000000000000000000000000;;			setupHook: setupHook,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *hookableFakeNetworkPlugin) Init(host network.Host, hairpinMode componentconfig.HairpinMode, nonMasqueradeCIDR string, mtu int) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *hookableFakeNetworkPlugin) Event(name string, details map[string]interface{}) {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *hookableFakeNetworkPlugin) Name() string {
0000000000000000000000000000000000000000;;		return "fakeplugin"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *hookableFakeNetworkPlugin) Capabilities() utilsets.Int {
0000000000000000000000000000000000000000;;		return utilsets.NewInt()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *hookableFakeNetworkPlugin) SetUpPod(namespace string, name string, id kubecontainer.ContainerID, annotations map[string]string) error {
0000000000000000000000000000000000000000;;		if p.setupHook != nil {
0000000000000000000000000000000000000000;;			p.setupHook(namespace, name, id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *hookableFakeNetworkPlugin) TearDownPod(string, string, kubecontainer.ContainerID) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *hookableFakeNetworkPlugin) GetPodNetworkStatus(string, string, kubecontainer.ContainerID) (*network.PodNetworkStatus, error) {
0000000000000000000000000000000000000000;;		return &network.PodNetworkStatus{IP: net.ParseIP("10.1.2.3")}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *hookableFakeNetworkPlugin) Status() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensure that one pod's network operations don't block another's.  If the
0000000000000000000000000000000000000000;;	// test is successful (eg, first pod doesn't block on second) the test
0000000000000000000000000000000000000000;;	// will complete.  If unsuccessful, it will hang and get killed.
0000000000000000000000000000000000000000;;	func TestMultiPodParallelNetworkOps(t *testing.T) {
0000000000000000000000000000000000000000;;		podWg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		podWg.Add(1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Can't do this with MockNetworkPlugin because the gomock controller
0000000000000000000000000000000000000000;;		// has its own locks which don't allow the parallel network operation
0000000000000000000000000000000000000000;;		// to proceed.
0000000000000000000000000000000000000000;;		didWait := false
0000000000000000000000000000000000000000;;		fakePlugin := newHookableFakeNetworkPlugin(func(podNamespace, podName string, id kubecontainer.ContainerID) {
0000000000000000000000000000000000000000;;			if podName == "waiter" {
0000000000000000000000000000000000000000;;				podWg.Wait()
0000000000000000000000000000000000000000;;				didWait = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		pm := network.NewPluginManager(fakePlugin)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opsWg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start the pod that will wait for the other to complete
0000000000000000000000000000000000000000;;		opsWg.Add(1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer opsWg.Done()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			podName := "waiter"
0000000000000000000000000000000000000000;;			containerID := kubecontainer.ContainerID{ID: podName}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Setup will block on the runner pod completing.  If network
0000000000000000000000000000000000000000;;			// operations locking isn't correct (eg pod network operations
0000000000000000000000000000000000000000;;			// block other pods) setUpPod() will never return.
0000000000000000000000000000000000000000;;			if err := pm.SetUpPod("", podName, containerID, nil); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Failed to set up waiter pod: %v", err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := pm.TearDownPod("", podName, containerID); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Failed to tear down waiter pod: %v", err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opsWg.Add(1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer opsWg.Done()
0000000000000000000000000000000000000000;;			// Let other pod proceed
0000000000000000000000000000000000000000;;			defer podWg.Done()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			podName := "runner"
0000000000000000000000000000000000000000;;			containerID := kubecontainer.ContainerID{ID: podName}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := pm.SetUpPod("", podName, containerID, nil); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Failed to set up runner pod: %v", err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := pm.TearDownPod("", podName, containerID); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Failed to tear down runner pod: %v", err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opsWg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !didWait {
0000000000000000000000000000000000000000;;			t.Errorf("waiter pod didn't wait for runner pod!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
