0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
350b88069342129c4911863376c2eff9fa6f8b94;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cni
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/containernetworking/cni/libcni"
0000000000000000000000000000000000000000;;		cnitypes "github.com/containernetworking/cni/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/network"
0000000000000000000000000000000000000000;;		utilexec "k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		CNIPluginName        = "cni"
0000000000000000000000000000000000000000;;		DefaultNetDir        = "/etc/cni/net.d"
0000000000000000000000000000000000000000;;		DefaultCNIDir        = "/opt/cni/bin"
0000000000000000000000000000000000000000;;		VendorCNIDirTemplate = "%s/opt/%s/bin"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cniNetworkPlugin struct {
0000000000000000000000000000000000000000;;		network.NoopNetworkPlugin
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		loNetwork *cniNetwork
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;		defaultNetwork *cniNetwork
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		host               network.Host
0000000000000000000000000000000000000000;;		execer             utilexec.Interface
0000000000000000000000000000000000000000;;		nsenterPath        string
0000000000000000000000000000000000000000;;		pluginDir          string
0000000000000000000000000000000000000000;;		binDir             string
0000000000000000000000000000000000000000;;		vendorCNIDirPrefix string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cniNetwork struct {
0000000000000000000000000000000000000000;;		name          string
0000000000000000000000000000000000000000;;		NetworkConfig *libcni.NetworkConfigList
0000000000000000000000000000000000000000;;		CNIConfig     libcni.CNI
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cniPortMapping maps to the standard CNI portmapping Capability
0000000000000000000000000000000000000000;;	// see: https://github.com/containernetworking/cni/blob/master/CONVENTIONS.md
0000000000000000000000000000000000000000;;	type cniPortMapping struct {
0000000000000000000000000000000000000000;;		HostPort      int32  `json:"hostPort"`
0000000000000000000000000000000000000000;;		ContainerPort int32  `json:"containerPort"`
0000000000000000000000000000000000000000;;		Protocol      string `json:"protocol"`
0000000000000000000000000000000000000000;;		HostIP        string `json:"hostIP"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func probeNetworkPluginsWithVendorCNIDirPrefix(pluginDir, binDir, vendorCNIDirPrefix string) []network.NetworkPlugin {
0000000000000000000000000000000000000000;;		if binDir == "" {
0000000000000000000000000000000000000000;;			binDir = DefaultCNIDir
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plugin := &cniNetworkPlugin{
0000000000000000000000000000000000000000;;			defaultNetwork:     nil,
0000000000000000000000000000000000000000;;			loNetwork:          getLoNetwork(binDir, vendorCNIDirPrefix),
0000000000000000000000000000000000000000;;			execer:             utilexec.New(),
0000000000000000000000000000000000000000;;			pluginDir:          pluginDir,
0000000000000000000000000000000000000000;;			binDir:             binDir,
0000000000000000000000000000000000000000;;			vendorCNIDirPrefix: vendorCNIDirPrefix,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// sync NetworkConfig in best effort during probing.
0000000000000000000000000000000000000000;;		plugin.syncNetworkConfig()
0000000000000000000000000000000000000000;;		return []network.NetworkPlugin{plugin}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ProbeNetworkPlugins(pluginDir, binDir string) []network.NetworkPlugin {
0000000000000000000000000000000000000000;;		return probeNetworkPluginsWithVendorCNIDirPrefix(pluginDir, binDir, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getDefaultCNINetwork(pluginDir, binDir, vendorCNIDirPrefix string) (*cniNetwork, error) {
0000000000000000000000000000000000000000;;		if pluginDir == "" {
0000000000000000000000000000000000000000;;			pluginDir = DefaultNetDir
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		files, err := libcni.ConfFiles(pluginDir, []string{".conf", ".conflist", ".json"})
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case err != nil:
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		case len(files) == 0:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("No networks found in %s", pluginDir)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sort.Strings(files)
0000000000000000000000000000000000000000;;		for _, confFile := range files {
0000000000000000000000000000000000000000;;			var confList *libcni.NetworkConfigList
0000000000000000000000000000000000000000;;			if strings.HasSuffix(confFile, ".conflist") {
0000000000000000000000000000000000000000;;				confList, err = libcni.ConfListFromFile(confFile)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Warningf("Error loading CNI config list file %s: %v", confFile, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				conf, err := libcni.ConfFromFile(confFile)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Warningf("Error loading CNI config file %s: %v", confFile, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				confList, err = libcni.ConfListFromConf(conf)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Warningf("Error converting CNI config file %s to list: %v", confFile, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(confList.Plugins) == 0 {
0000000000000000000000000000000000000000;;				glog.Warningf("CNI config list %s has no networks, skipping", confFile)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			confType := confList.Plugins[0].Network.Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Search for vendor-specific plugins as well as default plugins in the CNI codebase.
0000000000000000000000000000000000000000;;			vendorDir := vendorCNIDir(vendorCNIDirPrefix, confType)
0000000000000000000000000000000000000000;;			cninet := &libcni.CNIConfig{
0000000000000000000000000000000000000000;;				Path: []string{vendorDir, binDir},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			network := &cniNetwork{name: confList.Name, NetworkConfig: confList, CNIConfig: cninet}
0000000000000000000000000000000000000000;;			return network, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("No valid networks found in %s", pluginDir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func vendorCNIDir(prefix, pluginType string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(VendorCNIDirTemplate, prefix, pluginType)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getLoNetwork(binDir, vendorDirPrefix string) *cniNetwork {
0000000000000000000000000000000000000000;;		loConfig, err := libcni.ConfListFromBytes([]byte(`{
0000000000000000000000000000000000000000;;	  "cniVersion": "0.2.0",
0000000000000000000000000000000000000000;;	  "name": "cni-loopback",
0000000000000000000000000000000000000000;;	  "plugins":[{
0000000000000000000000000000000000000000;;	    "type": "loopback"
0000000000000000000000000000000000000000;;	  }]
0000000000000000000000000000000000000000;;	}`))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// The hardcoded config above should always be valid and unit tests will
0000000000000000000000000000000000000000;;			// catch this
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cninet := &libcni.CNIConfig{
0000000000000000000000000000000000000000;;			Path: []string{vendorCNIDir(vendorDirPrefix, "loopback"), binDir},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loNetwork := &cniNetwork{
0000000000000000000000000000000000000000;;			name:          "lo",
0000000000000000000000000000000000000000;;			NetworkConfig: loConfig,
0000000000000000000000000000000000000000;;			CNIConfig:     cninet,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return loNetwork
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cniNetworkPlugin) Init(host network.Host, hairpinMode componentconfig.HairpinMode, nonMasqueradeCIDR string, mtu int) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		plugin.nsenterPath, err = plugin.execer.LookPath("nsenter")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugin.syncNetworkConfig()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cniNetworkPlugin) syncNetworkConfig() {
0000000000000000000000000000000000000000;;		network, err := getDefaultCNINetwork(plugin.pluginDir, plugin.binDir, plugin.vendorCNIDirPrefix)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Unable to update cni config: %s", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plugin.setDefaultNetwork(network)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cniNetworkPlugin) getDefaultNetwork() *cniNetwork {
0000000000000000000000000000000000000000;;		plugin.RLock()
0000000000000000000000000000000000000000;;		defer plugin.RUnlock()
0000000000000000000000000000000000000000;;		return plugin.defaultNetwork
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cniNetworkPlugin) setDefaultNetwork(n *cniNetwork) {
0000000000000000000000000000000000000000;;		plugin.Lock()
0000000000000000000000000000000000000000;;		defer plugin.Unlock()
0000000000000000000000000000000000000000;;		plugin.defaultNetwork = n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cniNetworkPlugin) checkInitialized() error {
0000000000000000000000000000000000000000;;		if plugin.getDefaultNetwork() == nil {
0000000000000000000000000000000000000000;;			return errors.New("cni config uninitialized")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cniNetworkPlugin) Name() string {
0000000000000000000000000000000000000000;;		return CNIPluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cniNetworkPlugin) Status() error {
0000000000000000000000000000000000000000;;		// sync network config from pluginDir periodically to detect network config updates
0000000000000000000000000000000000000000;;		plugin.syncNetworkConfig()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Can't set up pods if we don't have any CNI network configs yet
0000000000000000000000000000000000000000;;		return plugin.checkInitialized()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cniNetworkPlugin) SetUpPod(namespace string, name string, id kubecontainer.ContainerID, annotations map[string]string) error {
0000000000000000000000000000000000000000;;		if err := plugin.checkInitialized(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		netnsPath, err := plugin.host.GetNetNS(id.ID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("CNI failed to retrieve network namespace path: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = plugin.addToNetwork(plugin.loNetwork, name, namespace, id, netnsPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error while adding to cni lo network: %s", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = plugin.addToNetwork(plugin.getDefaultNetwork(), name, namespace, id, netnsPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error while adding to cni network: %s", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cniNetworkPlugin) TearDownPod(namespace string, name string, id kubecontainer.ContainerID) error {
0000000000000000000000000000000000000000;;		if err := plugin.checkInitialized(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Lack of namespace should not be fatal on teardown
0000000000000000000000000000000000000000;;		netnsPath, err := plugin.host.GetNetNS(id.ID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("CNI failed to retrieve network namespace path: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return plugin.deleteFromNetwork(plugin.getDefaultNetwork(), name, namespace, id, netnsPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Use the addToNetwork function to obtain the IP of the Pod. That will assume idempotent ADD call to the plugin.
0000000000000000000000000000000000000000;;	// Also fix the runtime's call to Status function to be done only in the case that the IP is lost, no need to do periodic calls
0000000000000000000000000000000000000000;;	func (plugin *cniNetworkPlugin) GetPodNetworkStatus(namespace string, name string, id kubecontainer.ContainerID) (*network.PodNetworkStatus, error) {
0000000000000000000000000000000000000000;;		netnsPath, err := plugin.host.GetNetNS(id.ID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("CNI failed to retrieve network namespace path: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if netnsPath == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Cannot find the network namespace, skipping pod network status for container %q", id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ip, err := network.GetPodIP(plugin.execer, plugin.nsenterPath, netnsPath, network.DefaultInterfaceName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &network.PodNetworkStatus{IP: ip}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cniNetworkPlugin) addToNetwork(network *cniNetwork, podName string, podNamespace string, podInfraContainerID kubecontainer.ContainerID, podNetnsPath string) (cnitypes.Result, error) {
0000000000000000000000000000000000000000;;		rt, err := plugin.buildCNIRuntimeConf(podName, podNamespace, podInfraContainerID, podNetnsPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error adding network when building cni runtime conf: %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		netConf, cniNet := network.NetworkConfig, network.CNIConfig
0000000000000000000000000000000000000000;;		glog.V(4).Infof("About to add CNI network %v (type=%v)", netConf.Name, netConf.Plugins[0].Network.Type)
0000000000000000000000000000000000000000;;		res, err := cniNet.AddNetworkList(netConf, rt)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error adding network: %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cniNetworkPlugin) deleteFromNetwork(network *cniNetwork, podName string, podNamespace string, podInfraContainerID kubecontainer.ContainerID, podNetnsPath string) error {
0000000000000000000000000000000000000000;;		rt, err := plugin.buildCNIRuntimeConf(podName, podNamespace, podInfraContainerID, podNetnsPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error deleting network when building cni runtime conf: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		netConf, cniNet := network.NetworkConfig, network.CNIConfig
0000000000000000000000000000000000000000;;		glog.V(4).Infof("About to del CNI network %v (type=%v)", netConf.Name, netConf.Plugins[0].Network.Type)
0000000000000000000000000000000000000000;;		err = cniNet.DelNetworkList(netConf, rt)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error deleting network: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cniNetworkPlugin) buildCNIRuntimeConf(podName string, podNs string, podInfraContainerID kubecontainer.ContainerID, podNetnsPath string) (*libcni.RuntimeConf, error) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Got netns path %v", podNetnsPath)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Using netns path %v", podNs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rt := &libcni.RuntimeConf{
0000000000000000000000000000000000000000;;			ContainerID: podInfraContainerID.ID,
0000000000000000000000000000000000000000;;			NetNS:       podNetnsPath,
0000000000000000000000000000000000000000;;			IfName:      network.DefaultInterfaceName,
0000000000000000000000000000000000000000;;			Args: [][2]string{
0000000000000000000000000000000000000000;;				{"IgnoreUnknown", "1"},
0000000000000000000000000000000000000000;;				{"K8S_POD_NAMESPACE", podNs},
0000000000000000000000000000000000000000;;				{"K8S_POD_NAME", podName},
0000000000000000000000000000000000000000;;				{"K8S_POD_INFRA_CONTAINER_ID", podInfraContainerID.ID},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// port mappings are a cni capability-based args, rather than parameters
0000000000000000000000000000000000000000;;		// to a specific plugin
0000000000000000000000000000000000000000;;		portMappings, err := plugin.host.GetPodPortMappings(podInfraContainerID.ID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("could not retrieve port mappings: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		portMappingsParam := make([]cniPortMapping, 0, len(portMappings))
0000000000000000000000000000000000000000;;		for _, p := range portMappings {
0000000000000000000000000000000000000000;;			if p.HostPort <= 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			portMappingsParam = append(portMappingsParam, cniPortMapping{
0000000000000000000000000000000000000000;;				HostPort:      p.HostPort,
0000000000000000000000000000000000000000;;				ContainerPort: p.ContainerPort,
0000000000000000000000000000000000000000;;				Protocol:      strings.ToLower(string(p.Protocol)),
0000000000000000000000000000000000000000;;				HostIP:        p.HostIP,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rt.CapabilityArgs = map[string]interface{}{
0000000000000000000000000000000000000000;;			"portMappings": portMappingsParam,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rt, nil
0000000000000000000000000000000000000000;;	}
