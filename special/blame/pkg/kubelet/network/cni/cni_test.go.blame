0000000000000000000000000000000000000000;;	// +build linux
350b88069342129c4911863376c2eff9fa6f8b94;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cni
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"text/template"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		types020 "github.com/containernetworking/cni/pkg/types/020"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/mock"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		containertest "k8s.io/kubernetes/pkg/kubelet/container/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/network"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/network/cni/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/network/hostport"
0000000000000000000000000000000000000000;;		networktest "k8s.io/kubernetes/pkg/kubelet/network/testing"
0000000000000000000000000000000000000000;;		utilexec "k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func installPluginUnderTest(t *testing.T, testVendorCNIDirPrefix, testNetworkConfigPath, vendorName string, plugName string) {
0000000000000000000000000000000000000000;;		pluginDir := path.Join(testNetworkConfigPath, plugName)
0000000000000000000000000000000000000000;;		err := os.MkdirAll(pluginDir, 0777)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create plugin config dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pluginConfig := path.Join(pluginDir, plugName+".conf")
0000000000000000000000000000000000000000;;		f, err := os.Create(pluginConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to install plugin")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		networkConfig := fmt.Sprintf(`{ "name": "%s", "type": "%s", "capabilities": {"portMappings": true}  }`, plugName, vendorName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = f.WriteString(networkConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to write network config file (%v)", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vendorCNIDir := fmt.Sprintf(VendorCNIDirTemplate, testVendorCNIDirPrefix, vendorName)
0000000000000000000000000000000000000000;;		err = os.MkdirAll(vendorCNIDir, 0777)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create plugin dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pluginExec := path.Join(vendorCNIDir, vendorName)
0000000000000000000000000000000000000000;;		f, err = os.Create(pluginExec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const execScriptTempl = `#!/bin/bash
0000000000000000000000000000000000000000;;	cat > {{.InputFile}}
0000000000000000000000000000000000000000;;	env > {{.OutputEnv}}
0000000000000000000000000000000000000000;;	echo "%@" >> {{.OutputEnv}}
0000000000000000000000000000000000000000;;	export $(echo ${CNI_ARGS} | sed 's/;/ /g') &> /dev/null
0000000000000000000000000000000000000000;;	mkdir -p {{.OutputDir}} &> /dev/null
0000000000000000000000000000000000000000;;	echo -n "$CNI_COMMAND $CNI_NETNS $K8S_POD_NAMESPACE $K8S_POD_NAME $K8S_POD_INFRA_CONTAINER_ID" >& {{.OutputFile}}
0000000000000000000000000000000000000000;;	echo -n "{ \"ip4\": { \"ip\": \"10.1.0.23/24\" } }"
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;		execTemplateData := &map[string]interface{}{
0000000000000000000000000000000000000000;;			"InputFile":  path.Join(pluginDir, plugName+".in"),
0000000000000000000000000000000000000000;;			"OutputFile": path.Join(pluginDir, plugName+".out"),
0000000000000000000000000000000000000000;;			"OutputEnv":  path.Join(pluginDir, plugName+".env"),
0000000000000000000000000000000000000000;;			"OutputDir":  pluginDir,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tObj := template.Must(template.New("test").Parse(execScriptTempl))
0000000000000000000000000000000000000000;;		buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		if err := tObj.Execute(buf, *execTemplateData); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error in executing script template - %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		execScript := buf.String()
0000000000000000000000000000000000000000;;		_, err = f.WriteString(execScript)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to write plugin exec - %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = f.Chmod(0777)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to set exec perms on plugin")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tearDownPlugin(tmpDir string) {
0000000000000000000000000000000000000000;;		err := os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Printf("Error in cleaning up test: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeNetworkHost struct {
0000000000000000000000000000000000000000;;		networktest.FakePortMappingGetter
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface
0000000000000000000000000000000000000000;;		runtime    kubecontainer.Runtime
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakeHost(kubeClient clientset.Interface, pods []*containertest.FakePod, ports map[string][]*hostport.PortMapping) *fakeNetworkHost {
0000000000000000000000000000000000000000;;		host := &fakeNetworkHost{
0000000000000000000000000000000000000000;;			networktest.FakePortMappingGetter{PortMaps: ports},
0000000000000000000000000000000000000000;;			kubeClient,
0000000000000000000000000000000000000000;;			&containertest.FakeRuntime{
0000000000000000000000000000000000000000;;				AllPodList: pods,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return host
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fnh *fakeNetworkHost) GetPodByName(name, namespace string) (*v1.Pod, bool) {
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fnh *fakeNetworkHost) GetKubeClient() clientset.Interface {
0000000000000000000000000000000000000000;;		return fnh.kubeClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fnh *fakeNetworkHost) GetRuntime() kubecontainer.Runtime {
0000000000000000000000000000000000000000;;		return fnh.runtime
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fnh *fakeNetworkHost) GetNetNS(containerID string) (string, error) {
0000000000000000000000000000000000000000;;		return fnh.GetRuntime().GetNetNS(kubecontainer.ContainerID{Type: "test", ID: containerID})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fnh *fakeNetworkHost) SupportsLegacyFeatures() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCNIPlugin(t *testing.T) {
0000000000000000000000000000000000000000;;		// install some random plugin
0000000000000000000000000000000000000000;;		pluginName := fmt.Sprintf("test%d", rand.Intn(1000))
0000000000000000000000000000000000000000;;		vendorName := fmt.Sprintf("test_vendor%d", rand.Intn(1000))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podIP := "10.0.0.2"
0000000000000000000000000000000000000000;;		podIPOutput := fmt.Sprintf("4: eth0    inet %s/24 scope global dynamic eth0\\       valid_lft forever preferred_lft forever", podIP)
0000000000000000000000000000000000000000;;		fakeCmds := []utilexec.FakeCommandAction{
0000000000000000000000000000000000000000;;			func(cmd string, args ...string) utilexec.Cmd {
0000000000000000000000000000000000000000;;				return utilexec.InitFakeCmd(&utilexec.FakeCmd{
0000000000000000000000000000000000000000;;					CombinedOutputScript: []utilexec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;						func() ([]byte, error) {
0000000000000000000000000000000000000000;;							return []byte(podIPOutput), nil
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}, cmd, args...)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fexec := &utilexec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: fakeCmds,
0000000000000000000000000000000000000000;;			LookPathFunc: func(file string) (string, error) {
0000000000000000000000000000000000000000;;				return fmt.Sprintf("/fake-bin/%s", file), nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mockLoCNI := &mock_cni.MockCNI{}
0000000000000000000000000000000000000000;;		// TODO mock for the test plugin too
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tmpDir := utiltesting.MkTmpdirOrDie("cni-test")
0000000000000000000000000000000000000000;;		testNetworkConfigPath := path.Join(tmpDir, "plugins", "net", "cni")
0000000000000000000000000000000000000000;;		testVendorCNIDirPrefix := tmpDir
0000000000000000000000000000000000000000;;		defer tearDownPlugin(tmpDir)
0000000000000000000000000000000000000000;;		installPluginUnderTest(t, testVendorCNIDirPrefix, testNetworkConfigPath, vendorName, pluginName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containerID := kubecontainer.ContainerID{Type: "test", ID: "test_infra_container"}
0000000000000000000000000000000000000000;;		pods := []*containertest.FakePod{{
0000000000000000000000000000000000000000;;			Pod: &kubecontainer.Pod{
0000000000000000000000000000000000000000;;				Containers: []*kubecontainer.Container{
0000000000000000000000000000000000000000;;					{ID: containerID},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			NetnsPath: "/proc/12345/ns/net",
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugins := probeNetworkPluginsWithVendorCNIDirPrefix(path.Join(testNetworkConfigPath, pluginName), "", testVendorCNIDirPrefix)
0000000000000000000000000000000000000000;;		if len(plugins) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected only one network plugin, got %d", len(plugins))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plugins[0].Name() != "cni" {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected CNI network plugin, got %q", plugins[0].Name())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cniPlugin, ok := plugins[0].(*cniNetworkPlugin)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("Not a CNI network plugin!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cniPlugin.execer = fexec
0000000000000000000000000000000000000000;;		cniPlugin.loNetwork.CNIConfig = mockLoCNI
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mockLoCNI.On("AddNetworkList", cniPlugin.loNetwork.NetworkConfig, mock.AnythingOfType("*libcni.RuntimeConf")).Return(&types020.Result{IP4: &types020.IPConfig{IP: net.IPNet{IP: []byte{127, 0, 0, 1}}}}, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ports := map[string][]*hostport.PortMapping{
0000000000000000000000000000000000000000;;			containerID.ID: {
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:          "name",
0000000000000000000000000000000000000000;;					HostPort:      8008,
0000000000000000000000000000000000000000;;					ContainerPort: 80,
0000000000000000000000000000000000000000;;					Protocol:      "UDP",
0000000000000000000000000000000000000000;;					HostIP:        "0.0.0.0",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeHost := NewFakeHost(nil, pods, ports)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plug, err := network.InitNetworkPlugin(plugins, "cni", fakeHost, componentconfig.HairpinNone, "10.0.0.0/8", network.UseDefaultMTU)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to select the desired plugin: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up the pod
0000000000000000000000000000000000000000;;		err = plug.SetUpPod("podNamespace", "podName", containerID, map[string]string{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected nil: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		outputEnv := path.Join(testNetworkConfigPath, pluginName, pluginName+".env")
0000000000000000000000000000000000000000;;		eo, eerr := ioutil.ReadFile(outputEnv)
0000000000000000000000000000000000000000;;		outputFile := path.Join(testNetworkConfigPath, pluginName, pluginName+".out")
0000000000000000000000000000000000000000;;		output, err := ioutil.ReadFile(outputFile)
0000000000000000000000000000000000000000;;		if err != nil || eerr != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to read output file %s: %v (env %s err %v)", outputFile, err, eo, eerr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedOutput := "ADD /proc/12345/ns/net podNamespace podName test_infra_container"
0000000000000000000000000000000000000000;;		if string(output) != expectedOutput {
0000000000000000000000000000000000000000;;			t.Errorf("Mismatch in expected output for setup hook. Expected '%s', got '%s'", expectedOutput, string(output))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify the correct network configuration was passed
0000000000000000000000000000000000000000;;		inputConfig := struct {
0000000000000000000000000000000000000000;;			RuntimeConfig struct {
0000000000000000000000000000000000000000;;				PortMappings []map[string]interface{} `json:"portMappings"`
0000000000000000000000000000000000000000;;			} `json:"runtimeConfig"`
0000000000000000000000000000000000000000;;		}{}
0000000000000000000000000000000000000000;;		inputFile := path.Join(testNetworkConfigPath, pluginName, pluginName+".in")
0000000000000000000000000000000000000000;;		inputBytes, inerr := ioutil.ReadFile(inputFile)
0000000000000000000000000000000000000000;;		parseerr := json.Unmarshal(inputBytes, &inputConfig)
0000000000000000000000000000000000000000;;		if inerr != nil || parseerr != nil {
0000000000000000000000000000000000000000;;			t.Errorf("failed to parse reported cni input config %s: (%v %v)", inputFile, inerr, parseerr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedMappings := []map[string]interface{}{
0000000000000000000000000000000000000000;;			// hah, golang always unmarshals unstructured json numbers as float64
0000000000000000000000000000000000000000;;			{"hostPort": 8008.0, "containerPort": 80.0, "protocol": "udp", "hostIP": "0.0.0.0"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(inputConfig.RuntimeConfig.PortMappings, expectedMappings) {
0000000000000000000000000000000000000000;;			t.Errorf("mismatch in expected port mappings. expected %v got %v", expectedMappings, inputConfig.RuntimeConfig.PortMappings)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get its IP address
0000000000000000000000000000000000000000;;		status, err := plug.GetPodNetworkStatus("podNamespace", "podName", containerID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to read pod network status: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if status.IP.String() != podIP {
0000000000000000000000000000000000000000;;			t.Errorf("Expected pod IP %q but got %q", podIP, status.IP.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Tear it down
0000000000000000000000000000000000000000;;		err = plug.TearDownPod("podNamespace", "podName", containerID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected nil: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output, err = ioutil.ReadFile(path.Join(testNetworkConfigPath, pluginName, pluginName+".out"))
0000000000000000000000000000000000000000;;		expectedOutput = "DEL /proc/12345/ns/net podNamespace podName test_infra_container"
0000000000000000000000000000000000000000;;		if string(output) != expectedOutput {
0000000000000000000000000000000000000000;;			t.Errorf("Mismatch in expected output for setup hook. Expected '%s', got '%s'", expectedOutput, string(output))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mockLoCNI.AssertExpectations(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLoNetNonNil(t *testing.T) {
0000000000000000000000000000000000000000;;		if conf := getLoNetwork("", ""); conf == nil {
0000000000000000000000000000000000000000;;			t.Error("Expected non-nil lo network")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
