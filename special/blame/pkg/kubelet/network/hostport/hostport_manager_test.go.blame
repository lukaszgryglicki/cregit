0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
43d9087c77adc42644578adbe6a968d1b5b460fa;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package hostport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		utiliptables "k8s.io/kubernetes/pkg/util/iptables"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakeHostportManager() HostPortManager {
0000000000000000000000000000000000000000;;		return &hostportManager{
0000000000000000000000000000000000000000;;			hostPortMap: make(map[hostport]closeable),
0000000000000000000000000000000000000000;;			iptables:    NewFakeIPTables(),
0000000000000000000000000000000000000000;;			portOpener:  NewFakeSocketManager().openFakeSocket,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHostportManager(t *testing.T) {
0000000000000000000000000000000000000000;;		iptables := NewFakeIPTables()
0000000000000000000000000000000000000000;;		portOpener := NewFakeSocketManager()
0000000000000000000000000000000000000000;;		manager := &hostportManager{
0000000000000000000000000000000000000000;;			hostPortMap: make(map[hostport]closeable),
0000000000000000000000000000000000000000;;			iptables:    iptables,
0000000000000000000000000000000000000000;;			portOpener:  portOpener.openFakeSocket,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			mapping     *PodPortMapping
0000000000000000000000000000000000000000;;			expectError bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				mapping: &PodPortMapping{
0000000000000000000000000000000000000000;;					Name:        "pod1",
0000000000000000000000000000000000000000;;					Namespace:   "ns1",
0000000000000000000000000000000000000000;;					IP:          net.ParseIP("10.1.1.2"),
0000000000000000000000000000000000000000;;					HostNetwork: false,
0000000000000000000000000000000000000000;;					PortMappings: []*PortMapping{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							HostPort:      8080,
0000000000000000000000000000000000000000;;							ContainerPort: 80,
0000000000000000000000000000000000000000;;							Protocol:      v1.ProtocolTCP,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							HostPort:      8081,
0000000000000000000000000000000000000000;;							ContainerPort: 81,
0000000000000000000000000000000000000000;;							Protocol:      v1.ProtocolUDP,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectError: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				mapping: &PodPortMapping{
0000000000000000000000000000000000000000;;					Name:        "pod2",
0000000000000000000000000000000000000000;;					Namespace:   "ns1",
0000000000000000000000000000000000000000;;					IP:          net.ParseIP("10.1.1.3"),
0000000000000000000000000000000000000000;;					HostNetwork: false,
0000000000000000000000000000000000000000;;					PortMappings: []*PortMapping{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							HostPort:      8082,
0000000000000000000000000000000000000000;;							ContainerPort: 80,
0000000000000000000000000000000000000000;;							Protocol:      v1.ProtocolTCP,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							HostPort:      8081,
0000000000000000000000000000000000000000;;							ContainerPort: 81,
0000000000000000000000000000000000000000;;							Protocol:      v1.ProtocolUDP,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectError: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				mapping: &PodPortMapping{
0000000000000000000000000000000000000000;;					Name:        "pod3",
0000000000000000000000000000000000000000;;					Namespace:   "ns1",
0000000000000000000000000000000000000000;;					IP:          net.ParseIP("10.1.1.4"),
0000000000000000000000000000000000000000;;					HostNetwork: false,
0000000000000000000000000000000000000000;;					PortMappings: []*PortMapping{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							HostPort:      8443,
0000000000000000000000000000000000000000;;							ContainerPort: 443,
0000000000000000000000000000000000000000;;							Protocol:      v1.ProtocolTCP,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectError: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add Hostports
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			err := manager.Add("id", tc.mapping, "cbr0")
0000000000000000000000000000000000000000;;			if tc.expectError {
0000000000000000000000000000000000000000;;				assert.Error(t, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check port opened
0000000000000000000000000000000000000000;;		expectedPorts := []hostport{{8080, "tcp"}, {8081, "udp"}, {8443, "tcp"}}
0000000000000000000000000000000000000000;;		openedPorts := make(map[hostport]bool)
0000000000000000000000000000000000000000;;		for hp, port := range portOpener.mem {
0000000000000000000000000000000000000000;;			if !port.closed {
0000000000000000000000000000000000000000;;				openedPorts[hp] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		assert.EqualValues(t, len(openedPorts), len(expectedPorts))
0000000000000000000000000000000000000000;;		for _, hp := range expectedPorts {
0000000000000000000000000000000000000000;;			_, ok := openedPorts[hp]
0000000000000000000000000000000000000000;;			assert.EqualValues(t, true, ok)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check Iptables-save result after adding hostports
0000000000000000000000000000000000000000;;		raw := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;		err := iptables.SaveInto(utiliptables.TableNAT, raw)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lines := strings.Split(string(raw.Bytes()), "\n")
0000000000000000000000000000000000000000;;		expectedLines := map[string]bool{
0000000000000000000000000000000000000000;;			`*nat`: true,
0000000000000000000000000000000000000000;;			`:KUBE-HOSTPORTS - [0:0]`:                                                                                                         true,
0000000000000000000000000000000000000000;;			`:OUTPUT - [0:0]`:                                                                                                                 true,
0000000000000000000000000000000000000000;;			`:PREROUTING - [0:0]`:                                                                                                             true,
0000000000000000000000000000000000000000;;			`:POSTROUTING - [0:0]`:                                                                                                            true,
0000000000000000000000000000000000000000;;			`:KUBE-HP-4YVONL46AKYWSKS3 - [0:0]`:                                                                                               true,
0000000000000000000000000000000000000000;;			`:KUBE-HP-7THKRFSEH4GIIXK7 - [0:0]`:                                                                                               true,
0000000000000000000000000000000000000000;;			`:KUBE-HP-5N7UH5JAXCVP5UJR - [0:0]`:                                                                                               true,
0000000000000000000000000000000000000000;;			"-A KUBE-HOSTPORTS -m comment --comment \"pod3_ns1 hostport 8443\" -m tcp -p tcp --dport 8443 -j KUBE-HP-5N7UH5JAXCVP5UJR":        true,
0000000000000000000000000000000000000000;;			"-A KUBE-HOSTPORTS -m comment --comment \"pod1_ns1 hostport 8081\" -m udp -p udp --dport 8081 -j KUBE-HP-7THKRFSEH4GIIXK7":        true,
0000000000000000000000000000000000000000;;			"-A KUBE-HOSTPORTS -m comment --comment \"pod1_ns1 hostport 8080\" -m tcp -p tcp --dport 8080 -j KUBE-HP-4YVONL46AKYWSKS3":        true,
0000000000000000000000000000000000000000;;			"-A OUTPUT -m comment --comment \"kube hostport portals\" -m addrtype --dst-type LOCAL -j KUBE-HOSTPORTS":                         true,
0000000000000000000000000000000000000000;;			"-A PREROUTING -m comment --comment \"kube hostport portals\" -m addrtype --dst-type LOCAL -j KUBE-HOSTPORTS":                     true,
0000000000000000000000000000000000000000;;			"-A POSTROUTING -m comment --comment \"SNAT for localhost access to hostports\" -o cbr0 -s 127.0.0.0/8 -j MASQUERADE":             true,
0000000000000000000000000000000000000000;;			"-A KUBE-HP-4YVONL46AKYWSKS3 -m comment --comment \"pod1_ns1 hostport 8080\" -s 10.1.1.2/32 -j KUBE-MARK-MASQ":                    true,
0000000000000000000000000000000000000000;;			"-A KUBE-HP-4YVONL46AKYWSKS3 -m comment --comment \"pod1_ns1 hostport 8080\" -m tcp -p tcp -j DNAT --to-destination 10.1.1.2:80":  true,
0000000000000000000000000000000000000000;;			"-A KUBE-HP-7THKRFSEH4GIIXK7 -m comment --comment \"pod1_ns1 hostport 8081\" -s 10.1.1.2/32 -j KUBE-MARK-MASQ":                    true,
0000000000000000000000000000000000000000;;			"-A KUBE-HP-7THKRFSEH4GIIXK7 -m comment --comment \"pod1_ns1 hostport 8081\" -m udp -p udp -j DNAT --to-destination 10.1.1.2:81":  true,
0000000000000000000000000000000000000000;;			"-A KUBE-HP-5N7UH5JAXCVP5UJR -m comment --comment \"pod3_ns1 hostport 8443\" -s 10.1.1.4/32 -j KUBE-MARK-MASQ":                    true,
0000000000000000000000000000000000000000;;			"-A KUBE-HP-5N7UH5JAXCVP5UJR -m comment --comment \"pod3_ns1 hostport 8443\" -m tcp -p tcp -j DNAT --to-destination 10.1.1.4:443": true,
0000000000000000000000000000000000000000;;			`COMMIT`: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, line := range lines {
0000000000000000000000000000000000000000;;			if len(strings.TrimSpace(line)) > 0 {
0000000000000000000000000000000000000000;;				_, ok := expectedLines[strings.TrimSpace(line)]
0000000000000000000000000000000000000000;;				assert.EqualValues(t, true, ok)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove all added hostports
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			if !tc.expectError {
0000000000000000000000000000000000000000;;				err := manager.Remove("id", tc.mapping)
0000000000000000000000000000000000000000;;				assert.NoError(t, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check Iptables-save result after deleting hostports
0000000000000000000000000000000000000000;;		raw.Reset()
0000000000000000000000000000000000000000;;		err = iptables.SaveInto(utiliptables.TableNAT, raw)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		lines = strings.Split(string(raw.Bytes()), "\n")
0000000000000000000000000000000000000000;;		remainingChains := make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, line := range lines {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(line, ":") {
0000000000000000000000000000000000000000;;				remainingChains[strings.TrimSpace(line)] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectDeletedChains := []string{"KUBE-HP-4YVONL46AKYWSKS3", "KUBE-HP-7THKRFSEH4GIIXK7", "KUBE-HP-5N7UH5JAXCVP5UJR"}
0000000000000000000000000000000000000000;;		for _, chain := range expectDeletedChains {
0000000000000000000000000000000000000000;;			_, ok := remainingChains[chain]
0000000000000000000000000000000000000000;;			assert.EqualValues(t, false, ok)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check if all ports are closed
0000000000000000000000000000000000000000;;		for _, port := range portOpener.mem {
0000000000000000000000000000000000000000;;			assert.EqualValues(t, true, port.closed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
