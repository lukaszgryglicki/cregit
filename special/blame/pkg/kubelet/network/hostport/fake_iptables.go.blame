0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
a7f888e7fc6def8fc4382f30b7e107a0ddc9a593;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package hostport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utiliptables "k8s.io/kubernetes/pkg/util/iptables"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeChain struct {
0000000000000000000000000000000000000000;;		name  utiliptables.Chain
0000000000000000000000000000000000000000;;		rules []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeTable struct {
0000000000000000000000000000000000000000;;		name   utiliptables.Table
0000000000000000000000000000000000000000;;		chains map[string]*fakeChain
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeIPTables struct {
0000000000000000000000000000000000000000;;		tables map[string]*fakeTable
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakeIPTables() *fakeIPTables {
0000000000000000000000000000000000000000;;		return &fakeIPTables{
0000000000000000000000000000000000000000;;			tables: make(map[string]*fakeTable, 0),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeIPTables) GetVersion() (string, error) {
0000000000000000000000000000000000000000;;		return "1.4.21", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeIPTables) getTable(tableName utiliptables.Table) (*fakeTable, error) {
0000000000000000000000000000000000000000;;		table, ok := f.tables[string(tableName)]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Table %s does not exist", tableName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return table, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeIPTables) getChain(tableName utiliptables.Table, chainName utiliptables.Chain) (*fakeTable, *fakeChain, error) {
0000000000000000000000000000000000000000;;		table, err := f.getTable(tableName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		chain, ok := table.chains[string(chainName)]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return table, nil, fmt.Errorf("Chain %s/%s does not exist", tableName, chainName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return table, chain, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeIPTables) ensureChain(tableName utiliptables.Table, chainName utiliptables.Chain) (bool, *fakeChain) {
0000000000000000000000000000000000000000;;		table, chain, err := f.getChain(tableName, chainName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// either table or table+chain don't exist yet
0000000000000000000000000000000000000000;;			if table == nil {
0000000000000000000000000000000000000000;;				table = &fakeTable{
0000000000000000000000000000000000000000;;					name:   tableName,
0000000000000000000000000000000000000000;;					chains: make(map[string]*fakeChain),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				f.tables[string(tableName)] = table
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			chain := &fakeChain{
0000000000000000000000000000000000000000;;				name:  chainName,
0000000000000000000000000000000000000000;;				rules: make([]string, 0),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			table.chains[string(chainName)] = chain
0000000000000000000000000000000000000000;;			return false, chain
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, chain
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeIPTables) EnsureChain(tableName utiliptables.Table, chainName utiliptables.Chain) (bool, error) {
0000000000000000000000000000000000000000;;		existed, _ := f.ensureChain(tableName, chainName)
0000000000000000000000000000000000000000;;		return existed, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeIPTables) FlushChain(tableName utiliptables.Table, chainName utiliptables.Chain) error {
0000000000000000000000000000000000000000;;		_, chain, err := f.getChain(tableName, chainName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		chain.rules = make([]string, 0)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeIPTables) DeleteChain(tableName utiliptables.Table, chainName utiliptables.Chain) error {
0000000000000000000000000000000000000000;;		table, _, err := f.getChain(tableName, chainName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(table.chains, string(chainName))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns index of rule in array; < 0 if rule is not found
0000000000000000000000000000000000000000;;	func findRule(chain *fakeChain, rule string) int {
0000000000000000000000000000000000000000;;		for i, candidate := range chain.rules {
0000000000000000000000000000000000000000;;			if rule == candidate {
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeIPTables) ensureRule(position utiliptables.RulePosition, tableName utiliptables.Table, chainName utiliptables.Chain, rule string) (bool, error) {
0000000000000000000000000000000000000000;;		_, chain, err := f.getChain(tableName, chainName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			_, chain = f.ensureChain(tableName, chainName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rule, err = normalizeRule(rule)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ruleIdx := findRule(chain, rule)
0000000000000000000000000000000000000000;;		if ruleIdx >= 0 {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if position == utiliptables.Prepend {
0000000000000000000000000000000000000000;;			chain.rules = append([]string{rule}, chain.rules...)
0000000000000000000000000000000000000000;;		} else if position == utiliptables.Append {
0000000000000000000000000000000000000000;;			chain.rules = append(chain.rules, rule)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Unknown position argument %q", position)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func normalizeRule(rule string) (string, error) {
0000000000000000000000000000000000000000;;		normalized := ""
0000000000000000000000000000000000000000;;		remaining := strings.TrimSpace(rule)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var end int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if strings.HasPrefix(remaining, "--to-destination=") {
0000000000000000000000000000000000000000;;				remaining = strings.Replace(remaining, "=", " ", 1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if remaining[0] == '"' {
0000000000000000000000000000000000000000;;				end = strings.Index(remaining[1:], "\"")
0000000000000000000000000000000000000000;;				if end < 0 {
0000000000000000000000000000000000000000;;					return "", fmt.Errorf("Invalid rule syntax: mismatched quotes")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				end += 2
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				end = strings.Index(remaining, " ")
0000000000000000000000000000000000000000;;				if end < 0 {
0000000000000000000000000000000000000000;;					end = len(remaining)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			arg := remaining[:end]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Normalize un-prefixed IP addresses like iptables does
0000000000000000000000000000000000000000;;			if net.ParseIP(arg) != nil {
0000000000000000000000000000000000000000;;				arg = arg + "/32"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(normalized) > 0 {
0000000000000000000000000000000000000000;;				normalized += " "
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			normalized += strings.TrimSpace(arg)
0000000000000000000000000000000000000000;;			if len(remaining) == end {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			remaining = remaining[end+1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return normalized, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeIPTables) EnsureRule(position utiliptables.RulePosition, tableName utiliptables.Table, chainName utiliptables.Chain, args ...string) (bool, error) {
0000000000000000000000000000000000000000;;		ruleArgs := make([]string, 0)
0000000000000000000000000000000000000000;;		for _, arg := range args {
0000000000000000000000000000000000000000;;			// quote args with internal spaces (like comments)
0000000000000000000000000000000000000000;;			if strings.Index(arg, " ") >= 0 {
0000000000000000000000000000000000000000;;				arg = fmt.Sprintf("\"%s\"", arg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ruleArgs = append(ruleArgs, arg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.ensureRule(position, tableName, chainName, strings.Join(ruleArgs, " "))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeIPTables) DeleteRule(tableName utiliptables.Table, chainName utiliptables.Chain, args ...string) error {
0000000000000000000000000000000000000000;;		_, chain, err := f.getChain(tableName, chainName)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			rule := strings.Join(args, " ")
0000000000000000000000000000000000000000;;			ruleIdx := findRule(chain, rule)
0000000000000000000000000000000000000000;;			if ruleIdx < 0 {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			chain.rules = append(chain.rules[:ruleIdx], chain.rules[ruleIdx+1:]...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeIPTables) IsIpv6() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func saveChain(chain *fakeChain, data *bytes.Buffer) {
0000000000000000000000000000000000000000;;		for _, rule := range chain.rules {
0000000000000000000000000000000000000000;;			data.WriteString(fmt.Sprintf("-A %s %s\n", chain.name, rule))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeIPTables) SaveInto(tableName utiliptables.Table, buffer *bytes.Buffer) error {
0000000000000000000000000000000000000000;;		table, err := f.getTable(tableName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buffer.WriteString(fmt.Sprintf("*%s\n", table.name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rules := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;		for _, chain := range table.chains {
0000000000000000000000000000000000000000;;			buffer.WriteString(fmt.Sprintf(":%s - [0:0]\n", string(chain.name)))
0000000000000000000000000000000000000000;;			saveChain(chain, rules)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buffer.Write(rules.Bytes())
0000000000000000000000000000000000000000;;		buffer.WriteString("COMMIT\n")
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeIPTables) restore(restoreTableName utiliptables.Table, data []byte, flush utiliptables.FlushFlag) error {
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer(data)
0000000000000000000000000000000000000000;;		var tableName utiliptables.Table
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			line, err := buf.ReadString('\n')
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if line[0] == '#' {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			line = strings.TrimSuffix(line, "\n")
0000000000000000000000000000000000000000;;			if strings.HasPrefix(line, "*") {
0000000000000000000000000000000000000000;;				tableName = utiliptables.Table(line[1:])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tableName != "" {
0000000000000000000000000000000000000000;;				if restoreTableName != "" && restoreTableName != tableName {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if strings.HasPrefix(line, ":") {
0000000000000000000000000000000000000000;;					chainName := utiliptables.Chain(strings.Split(line[1:], " ")[0])
0000000000000000000000000000000000000000;;					if flush == utiliptables.FlushTables {
0000000000000000000000000000000000000000;;						table, chain, _ := f.getChain(tableName, chainName)
0000000000000000000000000000000000000000;;						if chain != nil {
0000000000000000000000000000000000000000;;							delete(table.chains, string(chainName))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					_, _ = f.ensureChain(tableName, chainName)
0000000000000000000000000000000000000000;;				} else if strings.HasPrefix(line, "-A") {
0000000000000000000000000000000000000000;;					parts := strings.Split(line, " ")
0000000000000000000000000000000000000000;;					if len(parts) < 3 {
0000000000000000000000000000000000000000;;						return fmt.Errorf("Invalid iptables rule '%s'", line)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					chainName := utiliptables.Chain(parts[1])
0000000000000000000000000000000000000000;;					rule := strings.TrimPrefix(line, fmt.Sprintf("-A %s ", chainName))
0000000000000000000000000000000000000000;;					_, err := f.ensureRule(utiliptables.Append, tableName, chainName, rule)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if strings.HasPrefix(line, "-I") {
0000000000000000000000000000000000000000;;					parts := strings.Split(line, " ")
0000000000000000000000000000000000000000;;					if len(parts) < 3 {
0000000000000000000000000000000000000000;;						return fmt.Errorf("Invalid iptables rule '%s'", line)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					chainName := utiliptables.Chain(parts[1])
0000000000000000000000000000000000000000;;					rule := strings.TrimPrefix(line, fmt.Sprintf("-I %s ", chainName))
0000000000000000000000000000000000000000;;					_, err := f.ensureRule(utiliptables.Prepend, tableName, chainName, rule)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if strings.HasPrefix(line, "-X") {
0000000000000000000000000000000000000000;;					parts := strings.Split(line, " ")
0000000000000000000000000000000000000000;;					if len(parts) < 2 {
0000000000000000000000000000000000000000;;						return fmt.Errorf("Invalid iptables rule '%s'", line)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err := f.DeleteChain(tableName, utiliptables.Chain(parts[1])); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if line == "COMMIT" {
0000000000000000000000000000000000000000;;					if restoreTableName == tableName {
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					tableName = ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeIPTables) Restore(tableName utiliptables.Table, data []byte, flush utiliptables.FlushFlag, counters utiliptables.RestoreCountersFlag) error {
0000000000000000000000000000000000000000;;		return f.restore(tableName, data, flush)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeIPTables) RestoreAll(data []byte, flush utiliptables.FlushFlag, counters utiliptables.RestoreCountersFlag) error {
0000000000000000000000000000000000000000;;		return f.restore("", data, flush)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeIPTables) AddReloadFunc(reloadFunc func()) {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeIPTables) Destroy() {
0000000000000000000000000000000000000000;;	}
