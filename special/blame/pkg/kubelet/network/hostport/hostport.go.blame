0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
6559bfae92e9ed2aae73fe75d17c9af35819ab20;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package hostport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		utiliptables "k8s.io/kubernetes/pkg/util/iptables"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// the hostport chain
0000000000000000000000000000000000000000;;		kubeHostportsChain utiliptables.Chain = "KUBE-HOSTPORTS"
0000000000000000000000000000000000000000;;		// prefix for hostport chains
0000000000000000000000000000000000000000;;		kubeHostportChainPrefix string = "KUBE-HP-"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PortMapping represents a network port in a container
0000000000000000000000000000000000000000;;	type PortMapping struct {
0000000000000000000000000000000000000000;;		Name          string
0000000000000000000000000000000000000000;;		HostPort      int32
0000000000000000000000000000000000000000;;		ContainerPort int32
0000000000000000000000000000000000000000;;		Protocol      v1.Protocol
0000000000000000000000000000000000000000;;		HostIP        string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodPortMapping represents a pod's network state and associated container port mappings
0000000000000000000000000000000000000000;;	type PodPortMapping struct {
0000000000000000000000000000000000000000;;		Namespace    string
0000000000000000000000000000000000000000;;		Name         string
0000000000000000000000000000000000000000;;		PortMappings []*PortMapping
0000000000000000000000000000000000000000;;		HostNetwork  bool
0000000000000000000000000000000000000000;;		IP           net.IP
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConstructPodPortMapping creates a PodPortMapping from the ports specified in the pod's
0000000000000000000000000000000000000000;;	// containers.
0000000000000000000000000000000000000000;;	func ConstructPodPortMapping(pod *v1.Pod, podIP net.IP) *PodPortMapping {
0000000000000000000000000000000000000000;;		portMappings := make([]*PortMapping, 0)
0000000000000000000000000000000000000000;;		for _, c := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			for _, port := range c.Ports {
0000000000000000000000000000000000000000;;				portMappings = append(portMappings, &PortMapping{
0000000000000000000000000000000000000000;;					Name:          port.Name,
0000000000000000000000000000000000000000;;					HostPort:      port.HostPort,
0000000000000000000000000000000000000000;;					ContainerPort: port.ContainerPort,
0000000000000000000000000000000000000000;;					Protocol:      port.Protocol,
0000000000000000000000000000000000000000;;					HostIP:        port.HostIP,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &PodPortMapping{
0000000000000000000000000000000000000000;;			Namespace:    pod.Namespace,
0000000000000000000000000000000000000000;;			Name:         pod.Name,
0000000000000000000000000000000000000000;;			PortMappings: portMappings,
0000000000000000000000000000000000000000;;			HostNetwork:  pod.Spec.HostNetwork,
0000000000000000000000000000000000000000;;			IP:           podIP,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hostport struct {
0000000000000000000000000000000000000000;;		port     int32
0000000000000000000000000000000000000000;;		protocol string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hostportOpener func(*hostport) (closeable, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type closeable interface {
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func openLocalPort(hp *hostport) (closeable, error) {
0000000000000000000000000000000000000000;;		// For ports on node IPs, open the actual port and hold it, even though we
0000000000000000000000000000000000000000;;		// use iptables to redirect traffic.
0000000000000000000000000000000000000000;;		// This ensures a) that it's safe to use that port and b) that (a) stays
0000000000000000000000000000000000000000;;		// true.  The risk is that some process on the node (e.g. sshd or kubelet)
0000000000000000000000000000000000000000;;		// is using a port and we give that same port out to a Service.  That would
0000000000000000000000000000000000000000;;		// be bad because iptables would silently claim the traffic but the process
0000000000000000000000000000000000000000;;		// would never know.
0000000000000000000000000000000000000000;;		// NOTE: We should not need to have a real listen()ing socket - bind()
0000000000000000000000000000000000000000;;		// should be enough, but I can't figure out a way to e2e test without
0000000000000000000000000000000000000000;;		// it.  Tools like 'ss' and 'netstat' do not show sockets that are
0000000000000000000000000000000000000000;;		// bind()ed but not listen()ed, and at least the default debian netcat
0000000000000000000000000000000000000000;;		// has no way to avoid about 10 seconds of retries.
0000000000000000000000000000000000000000;;		var socket closeable
0000000000000000000000000000000000000000;;		switch hp.protocol {
0000000000000000000000000000000000000000;;		case "tcp":
0000000000000000000000000000000000000000;;			listener, err := net.Listen("tcp", fmt.Sprintf(":%d", hp.port))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			socket = listener
0000000000000000000000000000000000000000;;		case "udp":
0000000000000000000000000000000000000000;;			addr, err := net.ResolveUDPAddr("udp", fmt.Sprintf(":%d", hp.port))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			conn, err := net.ListenUDP("udp", addr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			socket = conn
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unknown protocol %q", hp.protocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Opened local port %s", hp.String())
0000000000000000000000000000000000000000;;		return socket, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// openHostports opens all given hostports using the given hostportOpener
0000000000000000000000000000000000000000;;	// If encounter any error, clean up and return the error
0000000000000000000000000000000000000000;;	// If all ports are opened successfully, return the hostport and socket mapping
0000000000000000000000000000000000000000;;	// TODO: move openHostports and closeHostports into a common struct
0000000000000000000000000000000000000000;;	func openHostports(portOpener hostportOpener, podPortMapping *PodPortMapping) (map[hostport]closeable, error) {
0000000000000000000000000000000000000000;;		var retErr error
0000000000000000000000000000000000000000;;		ports := make(map[hostport]closeable)
0000000000000000000000000000000000000000;;		for _, pm := range podPortMapping.PortMappings {
0000000000000000000000000000000000000000;;			if pm.HostPort <= 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hp := portMappingToHostport(pm)
0000000000000000000000000000000000000000;;			socket, err := portOpener(&hp)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				retErr = fmt.Errorf("cannot open hostport %d for pod %s: %v", pm.HostPort, getPodFullName(podPortMapping), err)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ports[hp] = socket
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If encounter any error, close all hostports that just got opened.
0000000000000000000000000000000000000000;;		if retErr != nil {
0000000000000000000000000000000000000000;;			for hp, socket := range ports {
0000000000000000000000000000000000000000;;				if err := socket.Close(); err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Cannot clean up hostport %d for pod %s: %v", hp.port, getPodFullName(podPortMapping), err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, retErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ports, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// portMappingToHostport creates hostport structure based on input portmapping
0000000000000000000000000000000000000000;;	func portMappingToHostport(portMapping *PortMapping) hostport {
0000000000000000000000000000000000000000;;		return hostport{
0000000000000000000000000000000000000000;;			port:     portMapping.HostPort,
0000000000000000000000000000000000000000;;			protocol: strings.ToLower(string(portMapping.Protocol)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ensureKubeHostportChains ensures the KUBE-HOSTPORTS chain is setup correctly
0000000000000000000000000000000000000000;;	func ensureKubeHostportChains(iptables utiliptables.Interface, natInterfaceName string) error {
0000000000000000000000000000000000000000;;		glog.V(4).Info("Ensuring kubelet hostport chains")
0000000000000000000000000000000000000000;;		// Ensure kubeHostportChain
0000000000000000000000000000000000000000;;		if _, err := iptables.EnsureChain(utiliptables.TableNAT, kubeHostportsChain); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to ensure that %s chain %s exists: %v", utiliptables.TableNAT, kubeHostportsChain, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tableChainsNeedJumpServices := []struct {
0000000000000000000000000000000000000000;;			table utiliptables.Table
0000000000000000000000000000000000000000;;			chain utiliptables.Chain
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{utiliptables.TableNAT, utiliptables.ChainOutput},
0000000000000000000000000000000000000000;;			{utiliptables.TableNAT, utiliptables.ChainPrerouting},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		args := []string{"-m", "comment", "--comment", "kube hostport portals",
0000000000000000000000000000000000000000;;			"-m", "addrtype", "--dst-type", "LOCAL",
0000000000000000000000000000000000000000;;			"-j", string(kubeHostportsChain)}
0000000000000000000000000000000000000000;;		for _, tc := range tableChainsNeedJumpServices {
0000000000000000000000000000000000000000;;			// KUBE-HOSTPORTS chain needs to be appended to the system chains.
0000000000000000000000000000000000000000;;			// This ensures KUBE-SERVICES chain gets processed first.
0000000000000000000000000000000000000000;;			// Since rules in KUBE-HOSTPORTS chain matches broader cases, allow the more specific rules to be processed first.
0000000000000000000000000000000000000000;;			if _, err := iptables.EnsureRule(utiliptables.Append, tc.table, tc.chain, args...); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Failed to ensure that %s chain %s jumps to %s: %v", tc.table, tc.chain, kubeHostportsChain, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Need to SNAT traffic from localhost
0000000000000000000000000000000000000000;;		args = []string{"-m", "comment", "--comment", "SNAT for localhost access to hostports", "-o", natInterfaceName, "-s", "127.0.0.0/8", "-j", "MASQUERADE"}
0000000000000000000000000000000000000000;;		if _, err := iptables.EnsureRule(utiliptables.Append, utiliptables.TableNAT, utiliptables.ChainPostrouting, args...); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to ensure that %s chain %s jumps to MASQUERADE: %v", utiliptables.TableNAT, utiliptables.ChainPostrouting, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
