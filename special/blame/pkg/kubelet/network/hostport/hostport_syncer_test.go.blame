0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
a7f888e7fc6def8fc4382f30b7e107a0ddc9a593;pkg/kubelet/network/hostport/hostport_test.go[pkg/kubelet/network/hostport/hostport_test.go][pkg/kubelet/network/hostport/hostport_syncer_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package hostport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		utiliptables "k8s.io/kubernetes/pkg/util/iptables"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ruleMatch struct {
0000000000000000000000000000000000000000;;		hostport int
0000000000000000000000000000000000000000;;		chain    string
0000000000000000000000000000000000000000;;		match    string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOpenPodHostports(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeIPTables := NewFakeIPTables()
0000000000000000000000000000000000000000;;		fakeOpener := NewFakeSocketManager()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := &hostportSyncer{
0000000000000000000000000000000000000000;;			hostPortMap: make(map[hostport]closeable),
0000000000000000000000000000000000000000;;			iptables:    fakeIPTables,
0000000000000000000000000000000000000000;;			portOpener:  fakeOpener.openFakeSocket,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			mapping *PodPortMapping
0000000000000000000000000000000000000000;;			matches []*ruleMatch
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// New pod that we are going to add
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&PodPortMapping{
0000000000000000000000000000000000000000;;					Name:        "test-pod",
0000000000000000000000000000000000000000;;					Namespace:   v1.NamespaceDefault,
0000000000000000000000000000000000000000;;					IP:          net.ParseIP("10.1.1.2"),
0000000000000000000000000000000000000000;;					HostNetwork: false,
0000000000000000000000000000000000000000;;					PortMappings: []*PortMapping{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							HostPort:      4567,
0000000000000000000000000000000000000000;;							ContainerPort: 80,
0000000000000000000000000000000000000000;;							Protocol:      v1.ProtocolTCP,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							HostPort:      5678,
0000000000000000000000000000000000000000;;							ContainerPort: 81,
0000000000000000000000000000000000000000;;							Protocol:      v1.ProtocolUDP,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				[]*ruleMatch{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						-1,
0000000000000000000000000000000000000000;;						"KUBE-HOSTPORTS",
0000000000000000000000000000000000000000;;						"-m comment --comment \"test-pod_default hostport 4567\" -m tcp -p tcp --dport 4567",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						4567,
0000000000000000000000000000000000000000;;						"",
0000000000000000000000000000000000000000;;						"-m comment --comment \"test-pod_default hostport 4567\" -s 10.1.1.2/32 -j KUBE-MARK-MASQ",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						4567,
0000000000000000000000000000000000000000;;						"",
0000000000000000000000000000000000000000;;						"-m comment --comment \"test-pod_default hostport 4567\" -m tcp -p tcp -j DNAT --to-destination 10.1.1.2:80",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						-1,
0000000000000000000000000000000000000000;;						"KUBE-HOSTPORTS",
0000000000000000000000000000000000000000;;						"-m comment --comment \"test-pod_default hostport 5678\" -m udp -p udp --dport 5678",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						5678,
0000000000000000000000000000000000000000;;						"",
0000000000000000000000000000000000000000;;						"-m comment --comment \"test-pod_default hostport 5678\" -s 10.1.1.2/32 -j KUBE-MARK-MASQ",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						5678,
0000000000000000000000000000000000000000;;						"",
0000000000000000000000000000000000000000;;						"-m comment --comment \"test-pod_default hostport 5678\" -m udp -p udp -j DNAT --to-destination 10.1.1.2:81",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Already running pod
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&PodPortMapping{
0000000000000000000000000000000000000000;;					Name:        "another-test-pod",
0000000000000000000000000000000000000000;;					Namespace:   v1.NamespaceDefault,
0000000000000000000000000000000000000000;;					IP:          net.ParseIP("10.1.1.5"),
0000000000000000000000000000000000000000;;					HostNetwork: false,
0000000000000000000000000000000000000000;;					PortMappings: []*PortMapping{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							HostPort:      123,
0000000000000000000000000000000000000000;;							ContainerPort: 654,
0000000000000000000000000000000000000000;;							Protocol:      v1.ProtocolTCP,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				[]*ruleMatch{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						-1,
0000000000000000000000000000000000000000;;						"KUBE-HOSTPORTS",
0000000000000000000000000000000000000000;;						"-m comment --comment \"another-test-pod_default hostport 123\" -m tcp -p tcp --dport 123",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						123,
0000000000000000000000000000000000000000;;						"",
0000000000000000000000000000000000000000;;						"-m comment --comment \"another-test-pod_default hostport 123\" -s 10.1.1.5/32 -j KUBE-MARK-MASQ",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						123,
0000000000000000000000000000000000000000;;						"",
0000000000000000000000000000000000000000;;						"-m comment --comment \"another-test-pod_default hostport 123\" -m tcp -p tcp -j DNAT --to-destination 10.1.1.5:654",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		activePodPortMapping := make([]*PodPortMapping, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fill in any match rules missing chain names
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			for _, match := range test.matches {
0000000000000000000000000000000000000000;;				if match.hostport >= 0 {
0000000000000000000000000000000000000000;;					found := false
0000000000000000000000000000000000000000;;					for _, pm := range test.mapping.PortMappings {
0000000000000000000000000000000000000000;;						if int(pm.HostPort) == match.hostport {
0000000000000000000000000000000000000000;;							match.chain = string(hostportChainName(pm, getPodFullName(test.mapping)))
0000000000000000000000000000000000000000;;							found = true
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !found {
0000000000000000000000000000000000000000;;						t.Fatalf("Failed to find ContainerPort for match %d/'%s'", match.hostport, match.match)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			activePodPortMapping = append(activePodPortMapping, test.mapping)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Already running pod's host port
0000000000000000000000000000000000000000;;		hp := hostport{
0000000000000000000000000000000000000000;;			tests[1].mapping.PortMappings[0].HostPort,
0000000000000000000000000000000000000000;;			strings.ToLower(string(tests[1].mapping.PortMappings[0].Protocol)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h.hostPortMap[hp] = &fakeSocket{
0000000000000000000000000000000000000000;;			tests[1].mapping.PortMappings[0].HostPort,
0000000000000000000000000000000000000000;;			strings.ToLower(string(tests[1].mapping.PortMappings[0].Protocol)),
0000000000000000000000000000000000000000;;			false,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := h.OpenPodHostportsAndSync(tests[0].mapping, "br0", activePodPortMapping)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to OpenPodHostportsAndSync: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generic rules
0000000000000000000000000000000000000000;;		genericRules := []*ruleMatch{
0000000000000000000000000000000000000000;;			{-1, "POSTROUTING", "-m comment --comment \"SNAT for localhost access to hostports\" -o br0 -s 127.0.0.0/8 -j MASQUERADE"},
0000000000000000000000000000000000000000;;			{-1, "PREROUTING", "-m comment --comment \"kube hostport portals\" -m addrtype --dst-type LOCAL -j KUBE-HOSTPORTS"},
0000000000000000000000000000000000000000;;			{-1, "OUTPUT", "-m comment --comment \"kube hostport portals\" -m addrtype --dst-type LOCAL -j KUBE-HOSTPORTS"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rule := range genericRules {
0000000000000000000000000000000000000000;;			_, chain, err := fakeIPTables.getChain(utiliptables.TableNAT, utiliptables.Chain(rule.chain))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Expected NAT chain %s did not exist", rule.chain)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !matchRule(chain, rule.match) {
0000000000000000000000000000000000000000;;				t.Fatalf("Expected %s chain rule match '%s' not found", rule.chain, rule.match)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pod rules
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			for _, match := range test.matches {
0000000000000000000000000000000000000000;;				// Ensure chain exists
0000000000000000000000000000000000000000;;				_, chain, err := fakeIPTables.getChain(utiliptables.TableNAT, utiliptables.Chain(match.chain))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("Expected NAT chain %s did not exist", match.chain)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !matchRule(chain, match.match) {
0000000000000000000000000000000000000000;;					t.Fatalf("Expected NAT chain %s rule containing '%s' not found", match.chain, match.match)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Socket
0000000000000000000000000000000000000000;;		hostPortMap := map[hostport]closeable{
0000000000000000000000000000000000000000;;			{123, "tcp"}:  &fakeSocket{123, "tcp", false},
0000000000000000000000000000000000000000;;			{4567, "tcp"}: &fakeSocket{4567, "tcp", false},
0000000000000000000000000000000000000000;;			{5678, "udp"}: &fakeSocket{5678, "udp", false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(hostPortMap, h.hostPortMap) {
0000000000000000000000000000000000000000;;			t.Fatalf("Mismatch in expected hostPortMap. Expected '%v', got '%v'", hostPortMap, h.hostPortMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func matchRule(chain *fakeChain, match string) bool {
0000000000000000000000000000000000000000;;		for _, rule := range chain.rules {
0000000000000000000000000000000000000000;;			if strings.Contains(rule, match) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
