0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
a7f888e7fc6def8fc4382f30b7e107a0ddc9a593;pkg/kubelet/network/hostport/hostport.go[pkg/kubelet/network/hostport/hostport.go][pkg/kubelet/network/hostport/hostport_syncer.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package hostport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/sha256"
0000000000000000000000000000000000000000;;		"encoding/base32"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		iptablesproxy "k8s.io/kubernetes/pkg/proxy/iptables"
0000000000000000000000000000000000000000;;		utiliptables "k8s.io/kubernetes/pkg/util/iptables"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HostportSyncer takes a list of PodPortMappings and implements hostport all at once
0000000000000000000000000000000000000000;;	type HostportSyncer interface {
0000000000000000000000000000000000000000;;		// SyncHostports gathers all hostports on node and setup iptables rules to enable them.
0000000000000000000000000000000000000000;;		// On each invocation existing ports are synced and stale rules are deleted.
0000000000000000000000000000000000000000;;		SyncHostports(natInterfaceName string, activePodPortMappings []*PodPortMapping) error
0000000000000000000000000000000000000000;;		// OpenPodHostportsAndSync opens hostports for a new PodPortMapping, gathers all hostports on
0000000000000000000000000000000000000000;;		// node, sets up iptables rules enable them. On each invocation existing ports are synced and stale rules are deleted.
0000000000000000000000000000000000000000;;		// 'newPortMapping' must also be present in 'activePodPortMappings'.
0000000000000000000000000000000000000000;;		OpenPodHostportsAndSync(newPortMapping *PodPortMapping, natInterfaceName string, activePodPortMappings []*PodPortMapping) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hostportSyncer struct {
0000000000000000000000000000000000000000;;		hostPortMap map[hostport]closeable
0000000000000000000000000000000000000000;;		iptables    utiliptables.Interface
0000000000000000000000000000000000000000;;		portOpener  hostportOpener
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewHostportSyncer(iptables utiliptables.Interface) HostportSyncer {
0000000000000000000000000000000000000000;;		return &hostportSyncer{
0000000000000000000000000000000000000000;;			hostPortMap: make(map[hostport]closeable),
0000000000000000000000000000000000000000;;			iptables:    iptables,
0000000000000000000000000000000000000000;;			portOpener:  openLocalPort,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type targetPod struct {
0000000000000000000000000000000000000000;;		podFullName string
0000000000000000000000000000000000000000;;		podIP       string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (hp *hostport) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s:%d", hp.protocol, hp.port)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//openPodHostports opens all hostport for pod and returns the map of hostport and socket
0000000000000000000000000000000000000000;;	func (h *hostportSyncer) openHostports(podHostportMapping *PodPortMapping) error {
0000000000000000000000000000000000000000;;		var retErr error
0000000000000000000000000000000000000000;;		ports := make(map[hostport]closeable)
0000000000000000000000000000000000000000;;		for _, port := range podHostportMapping.PortMappings {
0000000000000000000000000000000000000000;;			if port.HostPort <= 0 {
0000000000000000000000000000000000000000;;				// Assume hostport is not specified in this portmapping. So skip
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hp := hostport{
0000000000000000000000000000000000000000;;				port:     port.HostPort,
0000000000000000000000000000000000000000;;				protocol: strings.ToLower(string(port.Protocol)),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			socket, err := h.portOpener(&hp)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				retErr = fmt.Errorf("cannot open hostport %d for pod %s: %v", port.HostPort, getPodFullName(podHostportMapping), err)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ports[hp] = socket
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If encounter any error, close all hostports that just got opened.
0000000000000000000000000000000000000000;;		if retErr != nil {
0000000000000000000000000000000000000000;;			for hp, socket := range ports {
0000000000000000000000000000000000000000;;				if err := socket.Close(); err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Cannot clean up hostport %d for pod %s: %v", hp.port, getPodFullName(podHostportMapping), err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return retErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for hostPort, socket := range ports {
0000000000000000000000000000000000000000;;			h.hostPortMap[hostPort] = socket
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPodFullName(pod *PodPortMapping) string {
0000000000000000000000000000000000000000;;		// Use underscore as the delimiter because it is not allowed in pod name
0000000000000000000000000000000000000000;;		// (DNS subdomain format), while allowed in the container name format.
0000000000000000000000000000000000000000;;		return pod.Name + "_" + pod.Namespace
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// gatherAllHostports returns all hostports that should be presented on node,
0000000000000000000000000000000000000000;;	// given the list of pods running on that node and ignoring host network
0000000000000000000000000000000000000000;;	// pods (which don't need hostport <-> container port mapping).
0000000000000000000000000000000000000000;;	func gatherAllHostports(activePodPortMappings []*PodPortMapping) (map[*PortMapping]targetPod, error) {
0000000000000000000000000000000000000000;;		podHostportMap := make(map[*PortMapping]targetPod)
0000000000000000000000000000000000000000;;		for _, pm := range activePodPortMappings {
0000000000000000000000000000000000000000;;			if pm.IP.To4() == nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Invalid or missing pod %s IP", getPodFullName(pm))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// should not handle hostports for hostnetwork pods
0000000000000000000000000000000000000000;;			if pm.HostNetwork {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, port := range pm.PortMappings {
0000000000000000000000000000000000000000;;				if port.HostPort != 0 {
0000000000000000000000000000000000000000;;					podHostportMap[port] = targetPod{podFullName: getPodFullName(pm), podIP: pm.IP.String()}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return podHostportMap, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Join all words with spaces, terminate with newline and write to buf.
0000000000000000000000000000000000000000;;	func writeLine(buf *bytes.Buffer, words ...string) {
0000000000000000000000000000000000000000;;		buf.WriteString(strings.Join(words, " ") + "\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//hostportChainName takes containerPort for a pod and returns associated iptables chain.
0000000000000000000000000000000000000000;;	// This is computed by hashing (sha256)
0000000000000000000000000000000000000000;;	// then encoding to base32 and truncating with the prefix "KUBE-SVC-".  We do
0000000000000000000000000000000000000000;;	// this because IPTables Chain Names must be <= 28 chars long, and the longer
0000000000000000000000000000000000000000;;	// they are the harder they are to read.
0000000000000000000000000000000000000000;;	func hostportChainName(pm *PortMapping, podFullName string) utiliptables.Chain {
0000000000000000000000000000000000000000;;		hash := sha256.Sum256([]byte(string(pm.HostPort) + string(pm.Protocol) + podFullName))
0000000000000000000000000000000000000000;;		encoded := base32.StdEncoding.EncodeToString(hash[:])
0000000000000000000000000000000000000000;;		return utiliptables.Chain(kubeHostportChainPrefix + encoded[:16])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OpenPodHostportsAndSync opens hostports for a new PodPortMapping, gathers all hostports on
0000000000000000000000000000000000000000;;	// node, sets up iptables rules enable them. And finally clean up stale hostports.
0000000000000000000000000000000000000000;;	// 'newPortMapping' must also be present in 'activePodPortMappings'.
0000000000000000000000000000000000000000;;	func (h *hostportSyncer) OpenPodHostportsAndSync(newPortMapping *PodPortMapping, natInterfaceName string, activePodPortMappings []*PodPortMapping) error {
0000000000000000000000000000000000000000;;		// try to open pod host port if specified
0000000000000000000000000000000000000000;;		if err := h.openHostports(newPortMapping); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the new pod to active pods if it's not present.
0000000000000000000000000000000000000000;;		var found bool
0000000000000000000000000000000000000000;;		for _, pm := range activePodPortMappings {
0000000000000000000000000000000000000000;;			if pm.Namespace == newPortMapping.Namespace && pm.Name == newPortMapping.Name {
0000000000000000000000000000000000000000;;				found = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			activePodPortMappings = append(activePodPortMappings, newPortMapping)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return h.SyncHostports(natInterfaceName, activePodPortMappings)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SyncHostports gathers all hostports on node and setup iptables rules enable them. And finally clean up stale hostports
0000000000000000000000000000000000000000;;	func (h *hostportSyncer) SyncHostports(natInterfaceName string, activePodPortMappings []*PodPortMapping) error {
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("syncHostportsRules took %v", time.Since(start))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostportPodMap, err := gatherAllHostports(activePodPortMappings)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure KUBE-HOSTPORTS chains
0000000000000000000000000000000000000000;;		ensureKubeHostportChains(h.iptables, natInterfaceName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get iptables-save output so we can check for existing chains and rules.
0000000000000000000000000000000000000000;;		// This will be a map of chain name to chain with rules as stored in iptables-save/iptables-restore
0000000000000000000000000000000000000000;;		existingNATChains := make(map[utiliptables.Chain]string)
0000000000000000000000000000000000000000;;		iptablesData := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;		err = h.iptables.SaveInto(utiliptables.TableNAT, iptablesData)
0000000000000000000000000000000000000000;;		if err != nil { // if we failed to get any rules
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to execute iptables-save, syncing all rules: %v", err)
0000000000000000000000000000000000000000;;		} else { // otherwise parse the output
0000000000000000000000000000000000000000;;			existingNATChains = utiliptables.GetChainLines(utiliptables.TableNAT, iptablesData.Bytes())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		natChains := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;		natRules := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;		writeLine(natChains, "*nat")
0000000000000000000000000000000000000000;;		// Make sure we keep stats for the top-level chains, if they existed
0000000000000000000000000000000000000000;;		// (which most should have because we created them above).
0000000000000000000000000000000000000000;;		if chain, ok := existingNATChains[kubeHostportsChain]; ok {
0000000000000000000000000000000000000000;;			writeLine(natChains, chain)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			writeLine(natChains, utiliptables.MakeChainLine(kubeHostportsChain))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Accumulate NAT chains to keep.
0000000000000000000000000000000000000000;;		activeNATChains := map[utiliptables.Chain]bool{} // use a map as a set
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for port, target := range hostportPodMap {
0000000000000000000000000000000000000000;;			protocol := strings.ToLower(string(port.Protocol))
0000000000000000000000000000000000000000;;			hostportChain := hostportChainName(port, target.podFullName)
0000000000000000000000000000000000000000;;			if chain, ok := existingNATChains[hostportChain]; ok {
0000000000000000000000000000000000000000;;				writeLine(natChains, chain)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				writeLine(natChains, utiliptables.MakeChainLine(hostportChain))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			activeNATChains[hostportChain] = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Redirect to hostport chain
0000000000000000000000000000000000000000;;			args := []string{
0000000000000000000000000000000000000000;;				"-A", string(kubeHostportsChain),
0000000000000000000000000000000000000000;;				"-m", "comment", "--comment", fmt.Sprintf(`"%s hostport %d"`, target.podFullName, port.HostPort),
0000000000000000000000000000000000000000;;				"-m", protocol, "-p", protocol,
0000000000000000000000000000000000000000;;				"--dport", fmt.Sprintf("%d", port.HostPort),
0000000000000000000000000000000000000000;;				"-j", string(hostportChain),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			writeLine(natRules, args...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Assuming kubelet is syncing iptables KUBE-MARK-MASQ chain
0000000000000000000000000000000000000000;;			// If the request comes from the pod that is serving the hostport, then SNAT
0000000000000000000000000000000000000000;;			args = []string{
0000000000000000000000000000000000000000;;				"-A", string(hostportChain),
0000000000000000000000000000000000000000;;				"-m", "comment", "--comment", fmt.Sprintf(`"%s hostport %d"`, target.podFullName, port.HostPort),
0000000000000000000000000000000000000000;;				"-s", target.podIP, "-j", string(iptablesproxy.KubeMarkMasqChain),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			writeLine(natRules, args...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create hostport chain to DNAT traffic to final destination
0000000000000000000000000000000000000000;;			// IPTables will maintained the stats for this chain
0000000000000000000000000000000000000000;;			args = []string{
0000000000000000000000000000000000000000;;				"-A", string(hostportChain),
0000000000000000000000000000000000000000;;				"-m", "comment", "--comment", fmt.Sprintf(`"%s hostport %d"`, target.podFullName, port.HostPort),
0000000000000000000000000000000000000000;;				"-m", protocol, "-p", protocol,
0000000000000000000000000000000000000000;;				"-j", "DNAT", fmt.Sprintf("--to-destination=%s:%d", target.podIP, port.ContainerPort),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			writeLine(natRules, args...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete chains no longer in use.
0000000000000000000000000000000000000000;;		for chain := range existingNATChains {
0000000000000000000000000000000000000000;;			if !activeNATChains[chain] {
0000000000000000000000000000000000000000;;				chainString := string(chain)
0000000000000000000000000000000000000000;;				if !strings.HasPrefix(chainString, kubeHostportChainPrefix) {
0000000000000000000000000000000000000000;;					// Ignore chains that aren't ours.
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// We must (as per iptables) write a chain-line for it, which has
0000000000000000000000000000000000000000;;				// the nice effect of flushing the chain.  Then we can remove the
0000000000000000000000000000000000000000;;				// chain.
0000000000000000000000000000000000000000;;				writeLine(natChains, existingNATChains[chain])
0000000000000000000000000000000000000000;;				writeLine(natRules, "-X", chainString)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		writeLine(natRules, "COMMIT")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		natLines := append(natChains.Bytes(), natRules.Bytes()...)
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Restoring iptables rules: %s", natLines)
0000000000000000000000000000000000000000;;		err = h.iptables.RestoreAll(natLines, utiliptables.NoFlushTables, utiliptables.RestoreCounters)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to execute iptables-restore: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h.cleanupHostportMap(hostportPodMap)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cleanupHostportMap closes obsolete hostports
0000000000000000000000000000000000000000;;	func (h *hostportSyncer) cleanupHostportMap(containerPortMap map[*PortMapping]targetPod) {
0000000000000000000000000000000000000000;;		// compute hostports that are supposed to be open
0000000000000000000000000000000000000000;;		currentHostports := make(map[hostport]bool)
0000000000000000000000000000000000000000;;		for containerPort := range containerPortMap {
0000000000000000000000000000000000000000;;			hp := hostport{
0000000000000000000000000000000000000000;;				port:     containerPort.HostPort,
0000000000000000000000000000000000000000;;				protocol: strings.ToLower(string(containerPort.Protocol)),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			currentHostports[hp] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// close and delete obsolete hostports
0000000000000000000000000000000000000000;;		for hp, socket := range h.hostPortMap {
0000000000000000000000000000000000000000;;			if _, ok := currentHostports[hp]; !ok {
0000000000000000000000000000000000000000;;				socket.Close()
0000000000000000000000000000000000000000;;				glog.V(3).Infof("Closed local port %s", hp.String())
0000000000000000000000000000000000000000;;				delete(h.hostPortMap, hp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
