0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
43d9087c77adc42644578adbe6a968d1b5b460fa;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package hostport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/sha256"
0000000000000000000000000000000000000000;;		"encoding/base32"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		iptablesproxy "k8s.io/kubernetes/pkg/proxy/iptables"
0000000000000000000000000000000000000000;;		utiliptables "k8s.io/kubernetes/pkg/util/iptables"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HostPortManager is an interface for adding and removing hostport for a given pod sandbox.
0000000000000000000000000000000000000000;;	type HostPortManager interface {
0000000000000000000000000000000000000000;;		// Add implements port mappings.
0000000000000000000000000000000000000000;;		// id should be a unique identifier for a pod, e.g. podSandboxID.
0000000000000000000000000000000000000000;;		// podPortMapping is the associated port mapping information for the pod.
0000000000000000000000000000000000000000;;		// natInterfaceName is the interface that localhost used to talk to the given pod.
0000000000000000000000000000000000000000;;		Add(id string, podPortMapping *PodPortMapping, natInterfaceName string) error
0000000000000000000000000000000000000000;;		// Remove cleans up matching port mappings
0000000000000000000000000000000000000000;;		// Remove must be able to clean up port mappings without pod IP
0000000000000000000000000000000000000000;;		Remove(id string, podPortMapping *PodPortMapping) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hostportManager struct {
0000000000000000000000000000000000000000;;		hostPortMap map[hostport]closeable
0000000000000000000000000000000000000000;;		iptables    utiliptables.Interface
0000000000000000000000000000000000000000;;		portOpener  hostportOpener
0000000000000000000000000000000000000000;;		mu          sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewHostportManager(iptables utiliptables.Interface) HostPortManager {
0000000000000000000000000000000000000000;;		return &hostportManager{
0000000000000000000000000000000000000000;;			hostPortMap: make(map[hostport]closeable),
0000000000000000000000000000000000000000;;			iptables:    iptables,
0000000000000000000000000000000000000000;;			portOpener:  openLocalPort,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (hm *hostportManager) Add(id string, podPortMapping *PodPortMapping, natInterfaceName string) (err error) {
0000000000000000000000000000000000000000;;		if podPortMapping == nil || podPortMapping.HostNetwork {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podFullName := getPodFullName(podPortMapping)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// skip if there is no hostport needed
0000000000000000000000000000000000000000;;		hostportMappings := gatherHostportMappings(podPortMapping)
0000000000000000000000000000000000000000;;		if len(hostportMappings) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if podPortMapping.IP.To4() == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid or missing IP of pod %s", podFullName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podIP := podPortMapping.IP.String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = ensureKubeHostportChains(hm.iptables, natInterfaceName); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure atomicity for port opening and iptables operations
0000000000000000000000000000000000000000;;		hm.mu.Lock()
0000000000000000000000000000000000000000;;		defer hm.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// try to open hostports
0000000000000000000000000000000000000000;;		ports, err := openHostports(hm.portOpener, podPortMapping)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for hostport, socket := range ports {
0000000000000000000000000000000000000000;;			hm.hostPortMap[hostport] = socket
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		natChains := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;		natRules := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;		writeLine(natChains, "*nat")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existingChains, existingRules, err := getExistingHostportIPTablesRules(hm.iptables)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// clean up opened host port if encounter any error
0000000000000000000000000000000000000000;;			return utilerrors.NewAggregate([]error{err, hm.closeHostports(hostportMappings)})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newChains := []utiliptables.Chain{}
0000000000000000000000000000000000000000;;		for _, pm := range hostportMappings {
0000000000000000000000000000000000000000;;			protocol := strings.ToLower(string(pm.Protocol))
0000000000000000000000000000000000000000;;			chain := getHostportChain(id, pm)
0000000000000000000000000000000000000000;;			newChains = append(newChains, chain)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add new hostport chain
0000000000000000000000000000000000000000;;			writeLine(natChains, utiliptables.MakeChainLine(chain))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Prepend the new chain to KUBE-HOSTPORTS
0000000000000000000000000000000000000000;;			// This avoids any leaking iptables rule that takes up the same port
0000000000000000000000000000000000000000;;			writeLine(natRules, "-I", string(kubeHostportsChain),
0000000000000000000000000000000000000000;;				"-m", "comment", "--comment", fmt.Sprintf(`"%s hostport %d"`, podFullName, pm.HostPort),
0000000000000000000000000000000000000000;;				"-m", protocol, "-p", protocol, "--dport", fmt.Sprintf("%d", pm.HostPort),
0000000000000000000000000000000000000000;;				"-j", string(chain),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// SNAT if the traffic comes from the pod itself
0000000000000000000000000000000000000000;;			writeLine(natRules, "-A", string(chain),
0000000000000000000000000000000000000000;;				"-m", "comment", "--comment", fmt.Sprintf(`"%s hostport %d"`, podFullName, pm.HostPort),
0000000000000000000000000000000000000000;;				"-s", podIP,
0000000000000000000000000000000000000000;;				"-j", string(iptablesproxy.KubeMarkMasqChain))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// DNAT to the podIP:containerPort
0000000000000000000000000000000000000000;;			writeLine(natRules, "-A", string(chain),
0000000000000000000000000000000000000000;;				"-m", "comment", "--comment", fmt.Sprintf(`"%s hostport %d"`, podFullName, pm.HostPort),
0000000000000000000000000000000000000000;;				"-m", protocol, "-p", protocol,
0000000000000000000000000000000000000000;;				"-j", "DNAT", fmt.Sprintf("--to-destination=%s:%d", podIP, pm.ContainerPort))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// getHostportChain should be able to provide unique hostport chain name using hash
0000000000000000000000000000000000000000;;		// if there is a chain conflict or multiple Adds have been triggered for a single pod,
0000000000000000000000000000000000000000;;		// filtering should be able to avoid further problem
0000000000000000000000000000000000000000;;		filterChains(existingChains, newChains)
0000000000000000000000000000000000000000;;		existingRules = filterRules(existingRules, newChains)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, chain := range existingChains {
0000000000000000000000000000000000000000;;			writeLine(natChains, chain)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rule := range existingRules {
0000000000000000000000000000000000000000;;			writeLine(natRules, rule)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		writeLine(natRules, "COMMIT")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = hm.syncIPTables(append(natChains.Bytes(), natRules.Bytes()...)); err != nil {
0000000000000000000000000000000000000000;;			// clean up opened host port if encounter any error
0000000000000000000000000000000000000000;;			return utilerrors.NewAggregate([]error{err, hm.closeHostports(hostportMappings)})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (hm *hostportManager) Remove(id string, podPortMapping *PodPortMapping) (err error) {
0000000000000000000000000000000000000000;;		if podPortMapping == nil || podPortMapping.HostNetwork {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostportMappings := gatherHostportMappings(podPortMapping)
0000000000000000000000000000000000000000;;		if len(hostportMappings) <= 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure atomicity for port closing and iptables operations
0000000000000000000000000000000000000000;;		hm.mu.Lock()
0000000000000000000000000000000000000000;;		defer hm.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var existingChains map[utiliptables.Chain]string
0000000000000000000000000000000000000000;;		var existingRules []string
0000000000000000000000000000000000000000;;		existingChains, existingRules, err = getExistingHostportIPTablesRules(hm.iptables)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Gather target hostport chains for removal
0000000000000000000000000000000000000000;;		chainsToRemove := []utiliptables.Chain{}
0000000000000000000000000000000000000000;;		for _, pm := range hostportMappings {
0000000000000000000000000000000000000000;;			chainsToRemove = append(chainsToRemove, getHostportChain(id, pm))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// To preserve backward compatibility for k8s 1.5 or earlier.
0000000000000000000000000000000000000000;;			// Need to remove hostport chains added by hostportSyncer if there is any
0000000000000000000000000000000000000000;;			// TODO: remove this in 1.7
0000000000000000000000000000000000000000;;			chainsToRemove = append(chainsToRemove, hostportChainName(pm, getPodFullName(podPortMapping)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// remove rules that consists of target chains
0000000000000000000000000000000000000000;;		remainingRules := filterRules(existingRules, chainsToRemove)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// gather target hostport chains that exists in iptables-save result
0000000000000000000000000000000000000000;;		existingChainsToRemove := []utiliptables.Chain{}
0000000000000000000000000000000000000000;;		for _, chain := range chainsToRemove {
0000000000000000000000000000000000000000;;			if _, ok := existingChains[chain]; ok {
0000000000000000000000000000000000000000;;				existingChainsToRemove = append(existingChainsToRemove, chain)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		natChains := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;		natRules := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;		writeLine(natChains, "*nat")
0000000000000000000000000000000000000000;;		for _, chain := range existingChains {
0000000000000000000000000000000000000000;;			writeLine(natChains, chain)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rule := range remainingRules {
0000000000000000000000000000000000000000;;			writeLine(natRules, rule)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, chain := range existingChainsToRemove {
0000000000000000000000000000000000000000;;			writeLine(natRules, "-X", string(chain))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		writeLine(natRules, "COMMIT")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = hm.syncIPTables(append(natChains.Bytes(), natRules.Bytes()...)); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// clean up opened pod host ports
0000000000000000000000000000000000000000;;		return hm.closeHostports(hostportMappings)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncIPTables executes iptables-restore with given lines
0000000000000000000000000000000000000000;;	func (hm *hostportManager) syncIPTables(lines []byte) error {
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Restoring iptables rules: %s", lines)
0000000000000000000000000000000000000000;;		err := hm.iptables.RestoreAll(lines, utiliptables.NoFlushTables, utiliptables.RestoreCounters)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to execute iptables-restore: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// closeHostports tries to close all the listed host ports
0000000000000000000000000000000000000000;;	// TODO: move closeHostports and openHostports into a common struct
0000000000000000000000000000000000000000;;	func (hm *hostportManager) closeHostports(hostportMappings []*PortMapping) error {
0000000000000000000000000000000000000000;;		errList := []error{}
0000000000000000000000000000000000000000;;		for _, pm := range hostportMappings {
0000000000000000000000000000000000000000;;			hp := portMappingToHostport(pm)
0000000000000000000000000000000000000000;;			if socket, ok := hm.hostPortMap[hp]; ok {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Closing host port %s", hp.String())
0000000000000000000000000000000000000000;;				if err := socket.Close(); err != nil {
0000000000000000000000000000000000000000;;					errList = append(errList, fmt.Errorf("failed to close host port %s: %v", hp.String(), err))
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				delete(hm.hostPortMap, hp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(errList)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getHostportChain takes id, hostport and protocol for a pod and returns associated iptables chain.
0000000000000000000000000000000000000000;;	// This is computed by hashing (sha256) then encoding to base32 and truncating with the prefix
0000000000000000000000000000000000000000;;	// "KUBE-HP-". We do this because IPTables Chain Names must be <= 28 chars long, and the longer
0000000000000000000000000000000000000000;;	// they are the harder they are to read.
0000000000000000000000000000000000000000;;	// WARNING: Please do not change this function. Otherwise, HostportManager may not be able to
0000000000000000000000000000000000000000;;	// identify existing iptables chains.
0000000000000000000000000000000000000000;;	func getHostportChain(id string, pm *PortMapping) utiliptables.Chain {
0000000000000000000000000000000000000000;;		hash := sha256.Sum256([]byte(id + string(pm.HostPort) + string(pm.Protocol)))
0000000000000000000000000000000000000000;;		encoded := base32.StdEncoding.EncodeToString(hash[:])
0000000000000000000000000000000000000000;;		return utiliptables.Chain(kubeHostportChainPrefix + encoded[:16])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// gatherHostportMappings returns all the PortMappings which has hostport for a pod
0000000000000000000000000000000000000000;;	func gatherHostportMappings(podPortMapping *PodPortMapping) []*PortMapping {
0000000000000000000000000000000000000000;;		mappings := []*PortMapping{}
0000000000000000000000000000000000000000;;		for _, pm := range podPortMapping.PortMappings {
0000000000000000000000000000000000000000;;			if pm.HostPort <= 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mappings = append(mappings, pm)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mappings
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getExistingHostportIPTablesRules retrieves raw data from iptables-save, parse it,
0000000000000000000000000000000000000000;;	// return all the hostport related chains and rules
0000000000000000000000000000000000000000;;	func getExistingHostportIPTablesRules(iptables utiliptables.Interface) (map[utiliptables.Chain]string, []string, error) {
0000000000000000000000000000000000000000;;		iptablesData := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;		err := iptables.SaveInto(utiliptables.TableNAT, iptablesData)
0000000000000000000000000000000000000000;;		if err != nil { // if we failed to get any rules
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("failed to execute iptables-save: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		existingNATChains := utiliptables.GetChainLines(utiliptables.TableNAT, iptablesData.Bytes())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existingHostportChains := make(map[utiliptables.Chain]string)
0000000000000000000000000000000000000000;;		existingHostportRules := []string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for chain := range existingNATChains {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(string(chain), string(kubeHostportsChain)) || strings.HasPrefix(string(chain), kubeHostportChainPrefix) {
0000000000000000000000000000000000000000;;				existingHostportChains[chain] = existingNATChains[chain]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, line := range strings.Split(string(iptablesData.Bytes()), "\n") {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(line, fmt.Sprintf("-A %s", kubeHostportChainPrefix)) ||
0000000000000000000000000000000000000000;;				strings.HasPrefix(line, fmt.Sprintf("-A %s", string(kubeHostportsChain))) {
0000000000000000000000000000000000000000;;				existingHostportRules = append(existingHostportRules, line)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return existingHostportChains, existingHostportRules, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// filterRules filters input rules with input chains. Rules that did not involve any filter chain will be returned.
0000000000000000000000000000000000000000;;	// The order of the input rules is important and is preserved.
0000000000000000000000000000000000000000;;	func filterRules(rules []string, filters []utiliptables.Chain) []string {
0000000000000000000000000000000000000000;;		filtered := []string{}
0000000000000000000000000000000000000000;;		for _, rule := range rules {
0000000000000000000000000000000000000000;;			skip := false
0000000000000000000000000000000000000000;;			for _, filter := range filters {
0000000000000000000000000000000000000000;;				if strings.Contains(rule, string(filter)) {
0000000000000000000000000000000000000000;;					skip = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !skip {
0000000000000000000000000000000000000000;;				filtered = append(filtered, rule)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filtered
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// filterChains deletes all entries of filter chains from chain map
0000000000000000000000000000000000000000;;	func filterChains(chains map[utiliptables.Chain]string, filterChains []utiliptables.Chain) {
0000000000000000000000000000000000000000;;		for _, chain := range filterChains {
0000000000000000000000000000000000000000;;			if _, ok := chains[chain]; ok {
0000000000000000000000000000000000000000;;				delete(chains, chain)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
