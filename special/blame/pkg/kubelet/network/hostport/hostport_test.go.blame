0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
6559bfae92e9ed2aae73fe75d17c9af35819ab20;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package hostport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		utiliptables "k8s.io/kubernetes/pkg/util/iptables"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeSocket struct {
0000000000000000000000000000000000000000;;		port     int32
0000000000000000000000000000000000000000;;		protocol string
0000000000000000000000000000000000000000;;		closed   bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeSocket) Close() error {
0000000000000000000000000000000000000000;;		if f.closed {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Socket %q.%s already closed!", f.port, f.protocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.closed = true
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakeSocketManager() *fakeSocketManager {
0000000000000000000000000000000000000000;;		return &fakeSocketManager{mem: make(map[hostport]*fakeSocket)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeSocketManager struct {
0000000000000000000000000000000000000000;;		mem map[hostport]*fakeSocket
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeSocketManager) openFakeSocket(hp *hostport) (closeable, error) {
0000000000000000000000000000000000000000;;		if socket, ok := f.mem[*hp]; ok && !socket.closed {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("hostport is occupied")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fs := &fakeSocket{hp.port, hp.protocol, false}
0000000000000000000000000000000000000000;;		f.mem[*hp] = fs
0000000000000000000000000000000000000000;;		return fs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOpenHostports(t *testing.T) {
0000000000000000000000000000000000000000;;		opener := NewFakeSocketManager()
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			podPortMapping *PodPortMapping
0000000000000000000000000000000000000000;;			expectError    bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&PodPortMapping{
0000000000000000000000000000000000000000;;					Namespace: "ns1",
0000000000000000000000000000000000000000;;					Name:      "n0",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&PodPortMapping{
0000000000000000000000000000000000000000;;					Namespace: "ns1",
0000000000000000000000000000000000000000;;					Name:      "n1",
0000000000000000000000000000000000000000;;					PortMappings: []*PortMapping{
0000000000000000000000000000000000000000;;						{HostPort: 80, Protocol: v1.Protocol("TCP")},
0000000000000000000000000000000000000000;;						{HostPort: 8080, Protocol: v1.Protocol("TCP")},
0000000000000000000000000000000000000000;;						{HostPort: 443, Protocol: v1.Protocol("TCP")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&PodPortMapping{
0000000000000000000000000000000000000000;;					Namespace: "ns1",
0000000000000000000000000000000000000000;;					Name:      "n2",
0000000000000000000000000000000000000000;;					PortMappings: []*PortMapping{
0000000000000000000000000000000000000000;;						{HostPort: 80, Protocol: v1.Protocol("TCP")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&PodPortMapping{
0000000000000000000000000000000000000000;;					Namespace: "ns1",
0000000000000000000000000000000000000000;;					Name:      "n3",
0000000000000000000000000000000000000000;;					PortMappings: []*PortMapping{
0000000000000000000000000000000000000000;;						{HostPort: 8081, Protocol: v1.Protocol("TCP")},
0000000000000000000000000000000000000000;;						{HostPort: 8080, Protocol: v1.Protocol("TCP")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&PodPortMapping{
0000000000000000000000000000000000000000;;					Namespace: "ns1",
0000000000000000000000000000000000000000;;					Name:      "n3",
0000000000000000000000000000000000000000;;					PortMappings: []*PortMapping{
0000000000000000000000000000000000000000;;						{HostPort: 8081, Protocol: v1.Protocol("TCP")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			mapping, err := openHostports(opener.openFakeSocket, tc.podPortMapping)
0000000000000000000000000000000000000000;;			if tc.expectError {
0000000000000000000000000000000000000000;;				assert.Error(t, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;			assert.EqualValues(t, len(mapping), len(tc.podPortMapping.PortMappings))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEnsureKubeHostportChains(t *testing.T) {
0000000000000000000000000000000000000000;;		interfaceName := "cbr0"
0000000000000000000000000000000000000000;;		builtinChains := []string{"PREROUTING", "OUTPUT"}
0000000000000000000000000000000000000000;;		jumpRule := "-m comment --comment \"kube hostport portals\" -m addrtype --dst-type LOCAL -j KUBE-HOSTPORTS"
0000000000000000000000000000000000000000;;		masqRule := "-m comment --comment \"SNAT for localhost access to hostports\" -o cbr0 -s 127.0.0.0/8 -j MASQUERADE"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeIPTables := NewFakeIPTables()
0000000000000000000000000000000000000000;;		assert.NoError(t, ensureKubeHostportChains(fakeIPTables, interfaceName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, _, err := fakeIPTables.getChain(utiliptables.TableNAT, utiliptables.Chain("KUBE-HOSTPORTS"))
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, chain, err := fakeIPTables.getChain(utiliptables.TableNAT, utiliptables.ChainPostrouting)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.EqualValues(t, len(chain.rules), 1)
0000000000000000000000000000000000000000;;		assert.Contains(t, chain.rules[0], masqRule)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, chainName := range builtinChains {
0000000000000000000000000000000000000000;;			_, chain, err := fakeIPTables.getChain(utiliptables.TableNAT, utiliptables.Chain(chainName))
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;			assert.EqualValues(t, len(chain.rules), 1)
0000000000000000000000000000000000000000;;			assert.Contains(t, chain.rules[0], jumpRule)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
