0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
9d54cc0e75b995ecc4de6d6bbd668df4bc2a3877;pkg/kubelet/runtime_hooks.go[pkg/kubelet/runtime_hooks.go][pkg/kubelet/images/image_manager.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package images
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockerref "github.com/docker/distribution/reference"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/flowcontrol"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/events"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/parsers"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// imageManager provides the functionalities for image pulling.
0000000000000000000000000000000000000000;;	type imageManager struct {
0000000000000000000000000000000000000000;;		recorder     record.EventRecorder
0000000000000000000000000000000000000000;;		imageService kubecontainer.ImageService
0000000000000000000000000000000000000000;;		backOff      *flowcontrol.Backoff
0000000000000000000000000000000000000000;;		// It will check the presence of the image, and report the 'image pulling', image pulled' events correspondingly.
0000000000000000000000000000000000000000;;		puller imagePuller
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ ImageManager = &imageManager{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewImageManager(recorder record.EventRecorder, imageService kubecontainer.ImageService, imageBackOff *flowcontrol.Backoff, serialized bool, qps float32, burst int) ImageManager {
0000000000000000000000000000000000000000;;		imageService = throttleImagePulling(imageService, qps, burst)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var puller imagePuller
0000000000000000000000000000000000000000;;		if serialized {
0000000000000000000000000000000000000000;;			puller = newSerialImagePuller(imageService)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			puller = newParallelImagePuller(imageService)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &imageManager{
0000000000000000000000000000000000000000;;			recorder:     recorder,
0000000000000000000000000000000000000000;;			imageService: imageService,
0000000000000000000000000000000000000000;;			backOff:      imageBackOff,
0000000000000000000000000000000000000000;;			puller:       puller,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shouldPullImage returns whether we should pull an image according to
0000000000000000000000000000000000000000;;	// the presence and pull policy of the image.
0000000000000000000000000000000000000000;;	func shouldPullImage(container *v1.Container, imagePresent bool) bool {
0000000000000000000000000000000000000000;;		if container.ImagePullPolicy == v1.PullNever {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if container.ImagePullPolicy == v1.PullAlways ||
0000000000000000000000000000000000000000;;			(container.ImagePullPolicy == v1.PullIfNotPresent && (!imagePresent)) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// records an event using ref, event msg.  log to glog using prefix, msg, logFn
0000000000000000000000000000000000000000;;	func (m *imageManager) logIt(ref *v1.ObjectReference, eventtype, event, prefix, msg string, logFn func(args ...interface{})) {
0000000000000000000000000000000000000000;;		if ref != nil {
0000000000000000000000000000000000000000;;			m.recorder.Event(events.ToObjectReference(ref), eventtype, event, msg)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			logFn(fmt.Sprint(prefix, " ", msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnsureImageExists pulls the image for the specified pod and container, and returns
0000000000000000000000000000000000000000;;	// (imageRef, error message, error).
0000000000000000000000000000000000000000;;	func (m *imageManager) EnsureImageExists(pod *v1.Pod, container *v1.Container, pullSecrets []v1.Secret) (string, string, error) {
0000000000000000000000000000000000000000;;		logPrefix := fmt.Sprintf("%s/%s", pod.Name, container.Image)
0000000000000000000000000000000000000000;;		ref, err := kubecontainer.GenerateContainerRef(pod, container)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Couldn't make a ref to pod %v, container %v: '%v'", pod.Name, container.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the image contains no tag or digest, a default tag should be applied.
0000000000000000000000000000000000000000;;		image, err := applyDefaultImageTag(container.Image)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("Failed to apply default image tag %q: %v", container.Image, err)
0000000000000000000000000000000000000000;;			m.logIt(ref, v1.EventTypeWarning, events.FailedToInspectImage, logPrefix, msg, glog.Warning)
0000000000000000000000000000000000000000;;			return "", msg, ErrInvalidImageName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spec := kubecontainer.ImageSpec{Image: image}
0000000000000000000000000000000000000000;;		imageRef, err := m.imageService.GetImageRef(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("Failed to inspect image %q: %v", container.Image, err)
0000000000000000000000000000000000000000;;			m.logIt(ref, v1.EventTypeWarning, events.FailedToInspectImage, logPrefix, msg, glog.Warning)
0000000000000000000000000000000000000000;;			return "", msg, ErrImageInspect
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		present := imageRef != ""
0000000000000000000000000000000000000000;;		if !shouldPullImage(container, present) {
0000000000000000000000000000000000000000;;			if present {
0000000000000000000000000000000000000000;;				msg := fmt.Sprintf("Container image %q already present on machine", container.Image)
0000000000000000000000000000000000000000;;				m.logIt(ref, v1.EventTypeNormal, events.PulledImage, logPrefix, msg, glog.Info)
0000000000000000000000000000000000000000;;				return imageRef, "", nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				msg := fmt.Sprintf("Container image %q is not present with pull policy of Never", container.Image)
0000000000000000000000000000000000000000;;				m.logIt(ref, v1.EventTypeWarning, events.ErrImageNeverPullPolicy, logPrefix, msg, glog.Warning)
0000000000000000000000000000000000000000;;				return "", msg, ErrImageNeverPull
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backOffKey := fmt.Sprintf("%s_%s", pod.UID, container.Image)
0000000000000000000000000000000000000000;;		if m.backOff.IsInBackOffSinceUpdate(backOffKey, m.backOff.Clock.Now()) {
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("Back-off pulling image %q", container.Image)
0000000000000000000000000000000000000000;;			m.logIt(ref, v1.EventTypeNormal, events.BackOffPullImage, logPrefix, msg, glog.Info)
0000000000000000000000000000000000000000;;			return "", msg, ErrImagePullBackOff
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.logIt(ref, v1.EventTypeNormal, events.PullingImage, logPrefix, fmt.Sprintf("pulling image %q", container.Image), glog.Info)
0000000000000000000000000000000000000000;;		pullChan := make(chan pullResult)
0000000000000000000000000000000000000000;;		m.puller.pullImage(spec, pullSecrets, pullChan)
0000000000000000000000000000000000000000;;		imagePullResult := <-pullChan
0000000000000000000000000000000000000000;;		if imagePullResult.err != nil {
0000000000000000000000000000000000000000;;			m.logIt(ref, v1.EventTypeWarning, events.FailedToPullImage, logPrefix, fmt.Sprintf("Failed to pull image %q: %v", container.Image, imagePullResult.err), glog.Warning)
0000000000000000000000000000000000000000;;			m.backOff.Next(backOffKey, m.backOff.Clock.Now())
0000000000000000000000000000000000000000;;			if imagePullResult.err == RegistryUnavailable {
0000000000000000000000000000000000000000;;				msg := fmt.Sprintf("image pull failed for %s because the registry is unavailable.", container.Image)
0000000000000000000000000000000000000000;;				return "", msg, imagePullResult.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return "", imagePullResult.err.Error(), ErrImagePull
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.logIt(ref, v1.EventTypeNormal, events.PulledImage, logPrefix, fmt.Sprintf("Successfully pulled image %q", container.Image), glog.Info)
0000000000000000000000000000000000000000;;		m.backOff.GC()
0000000000000000000000000000000000000000;;		return imagePullResult.imageRef, "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// applyDefaultImageTag parses a docker image string, if it doesn't contain any tag or digest,
0000000000000000000000000000000000000000;;	// a default tag will be applied.
0000000000000000000000000000000000000000;;	func applyDefaultImageTag(image string) (string, error) {
0000000000000000000000000000000000000000;;		named, err := dockerref.ParseNamed(image)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("couldn't parse image reference %q: %v", image, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, isTagged := named.(dockerref.Tagged)
0000000000000000000000000000000000000000;;		_, isDigested := named.(dockerref.Digested)
0000000000000000000000000000000000000000;;		if !isTagged && !isDigested {
0000000000000000000000000000000000000000;;			named, err := dockerref.WithTag(named, parsers.DefaultImageTag)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("failed to apply default image tag %q: %v", image, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			image = named.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return image, nil
0000000000000000000000000000000000000000;;	}
