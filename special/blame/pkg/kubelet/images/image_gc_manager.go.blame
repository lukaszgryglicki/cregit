0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f7ffd0c80e089aaccbfa97e611585b0b74301721;pkg/kubelet/image_manager.go[pkg/kubelet/image_manager.go][pkg/kubelet/images/image_gc_manager.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package images
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/cadvisor"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/events"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Manages lifecycle of all images.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Implementation is thread-safe.
0000000000000000000000000000000000000000;;	type ImageGCManager interface {
0000000000000000000000000000000000000000;;		// Applies the garbage collection policy. Errors include being unable to free
0000000000000000000000000000000000000000;;		// enough space as per the garbage collection policy.
0000000000000000000000000000000000000000;;		GarbageCollect() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start async garbage collection of images.
0000000000000000000000000000000000000000;;		Start()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		GetImageList() ([]kubecontainer.Image, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete all unused images and returns the number of bytes freed. The number of bytes freed is always returned.
0000000000000000000000000000000000000000;;		DeleteUnusedImages() (int64, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A policy for garbage collecting images. Policy defines an allowed band in
0000000000000000000000000000000000000000;;	// which garbage collection will be run.
0000000000000000000000000000000000000000;;	type ImageGCPolicy struct {
0000000000000000000000000000000000000000;;		// Any usage above this threshold will always trigger garbage collection.
0000000000000000000000000000000000000000;;		// This is the highest usage we will allow.
0000000000000000000000000000000000000000;;		HighThresholdPercent int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Any usage below this threshold will never trigger garbage collection.
0000000000000000000000000000000000000000;;		// This is the lowest threshold we will try to garbage collect to.
0000000000000000000000000000000000000000;;		LowThresholdPercent int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Minimum age at which an image can be garbage collected.
0000000000000000000000000000000000000000;;		MinAge time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type realImageGCManager struct {
0000000000000000000000000000000000000000;;		// Container runtime
0000000000000000000000000000000000000000;;		runtime container.Runtime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Records of images and their use.
0000000000000000000000000000000000000000;;		imageRecords     map[string]*imageRecord
0000000000000000000000000000000000000000;;		imageRecordsLock sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The image garbage collection policy in use.
0000000000000000000000000000000000000000;;		policy ImageGCPolicy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cAdvisor instance.
0000000000000000000000000000000000000000;;		cadvisor cadvisor.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Recorder for Kubernetes events.
0000000000000000000000000000000000000000;;		recorder record.EventRecorder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reference to this node.
0000000000000000000000000000000000000000;;		nodeRef *clientv1.ObjectReference
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Track initialization
0000000000000000000000000000000000000000;;		initialized bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// imageCache is the cache of latest image list.
0000000000000000000000000000000000000000;;		imageCache imageCache
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// imageCache caches latest result of ListImages.
0000000000000000000000000000000000000000;;	type imageCache struct {
0000000000000000000000000000000000000000;;		// sync.RWMutex is the mutex protects the image cache.
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;		// images is the image cache.
0000000000000000000000000000000000000000;;		images []kubecontainer.Image
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// set updates image cache.
0000000000000000000000000000000000000000;;	func (i *imageCache) set(images []kubecontainer.Image) {
0000000000000000000000000000000000000000;;		i.Lock()
0000000000000000000000000000000000000000;;		defer i.Unlock()
0000000000000000000000000000000000000000;;		i.images = images
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// get gets image list from image cache.
0000000000000000000000000000000000000000;;	func (i *imageCache) get() []kubecontainer.Image {
0000000000000000000000000000000000000000;;		i.RLock()
0000000000000000000000000000000000000000;;		defer i.RUnlock()
0000000000000000000000000000000000000000;;		return i.images
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Information about the images we track.
0000000000000000000000000000000000000000;;	type imageRecord struct {
0000000000000000000000000000000000000000;;		// Time when this image was first detected.
0000000000000000000000000000000000000000;;		firstDetected time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Time when we last saw this image being used.
0000000000000000000000000000000000000000;;		lastUsed time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Size of the image in bytes.
0000000000000000000000000000000000000000;;		size int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewImageGCManager(runtime container.Runtime, cadvisorInterface cadvisor.Interface, recorder record.EventRecorder, nodeRef *clientv1.ObjectReference, policy ImageGCPolicy) (ImageGCManager, error) {
0000000000000000000000000000000000000000;;		// Validate policy.
0000000000000000000000000000000000000000;;		if policy.HighThresholdPercent < 0 || policy.HighThresholdPercent > 100 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid HighThresholdPercent %d, must be in range [0-100]", policy.HighThresholdPercent)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if policy.LowThresholdPercent < 0 || policy.LowThresholdPercent > 100 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid LowThresholdPercent %d, must be in range [0-100]", policy.LowThresholdPercent)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if policy.LowThresholdPercent > policy.HighThresholdPercent {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("LowThresholdPercent %d can not be higher than HighThresholdPercent %d", policy.LowThresholdPercent, policy.HighThresholdPercent)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		im := &realImageGCManager{
0000000000000000000000000000000000000000;;			runtime:      runtime,
0000000000000000000000000000000000000000;;			policy:       policy,
0000000000000000000000000000000000000000;;			imageRecords: make(map[string]*imageRecord),
0000000000000000000000000000000000000000;;			cadvisor:     cadvisorInterface,
0000000000000000000000000000000000000000;;			recorder:     recorder,
0000000000000000000000000000000000000000;;			nodeRef:      nodeRef,
0000000000000000000000000000000000000000;;			initialized:  false,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return im, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (im *realImageGCManager) Start() {
0000000000000000000000000000000000000000;;		go wait.Until(func() {
0000000000000000000000000000000000000000;;			// Initial detection make detected time "unknown" in the past.
0000000000000000000000000000000000000000;;			var ts time.Time
0000000000000000000000000000000000000000;;			if im.initialized {
0000000000000000000000000000000000000000;;				ts = time.Now()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := im.detectImages(ts)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("[imageGCManager] Failed to monitor images: %v", err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				im.initialized = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}, 5*time.Minute, wait.NeverStop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start a goroutine periodically updates image cache.
0000000000000000000000000000000000000000;;		// TODO(random-liu): Merge this with the previous loop.
0000000000000000000000000000000000000000;;		go wait.Until(func() {
0000000000000000000000000000000000000000;;			images, err := im.runtime.ListImages()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("[imageGCManager] Failed to update image list: %v", err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				im.imageCache.set(images)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}, 30*time.Second, wait.NeverStop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get a list of images on this node
0000000000000000000000000000000000000000;;	func (im *realImageGCManager) GetImageList() ([]kubecontainer.Image, error) {
0000000000000000000000000000000000000000;;		return im.imageCache.get(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (im *realImageGCManager) detectImages(detectTime time.Time) error {
0000000000000000000000000000000000000000;;		images, err := im.runtime.ListImages()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pods, err := im.runtime.GetPods(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make a set of images in use by containers.
0000000000000000000000000000000000000000;;		imagesInUse := sets.NewString()
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			for _, container := range pod.Containers {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Pod %s/%s, container %s uses image %s(%s)", pod.Namespace, pod.Name, container.Name, container.Image, container.ImageID)
0000000000000000000000000000000000000000;;				imagesInUse.Insert(container.ImageID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add new images and record those being used.
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		currentImages := sets.NewString()
0000000000000000000000000000000000000000;;		im.imageRecordsLock.Lock()
0000000000000000000000000000000000000000;;		defer im.imageRecordsLock.Unlock()
0000000000000000000000000000000000000000;;		for _, image := range images {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("Adding image ID %s to currentImages", image.ID)
0000000000000000000000000000000000000000;;			currentImages.Insert(image.ID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// New image, set it as detected now.
0000000000000000000000000000000000000000;;			if _, ok := im.imageRecords[image.ID]; !ok {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Image ID %s is new", image.ID)
0000000000000000000000000000000000000000;;				im.imageRecords[image.ID] = &imageRecord{
0000000000000000000000000000000000000000;;					firstDetected: detectTime,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Set last used time to now if the image is being used.
0000000000000000000000000000000000000000;;			if isImageUsed(image, imagesInUse) {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Setting Image ID %s lastUsed to %v", image.ID, now)
0000000000000000000000000000000000000000;;				im.imageRecords[image.ID].lastUsed = now
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(5).Infof("Image ID %s has size %d", image.ID, image.Size)
0000000000000000000000000000000000000000;;			im.imageRecords[image.ID].size = image.Size
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove old images from our records.
0000000000000000000000000000000000000000;;		for image := range im.imageRecords {
0000000000000000000000000000000000000000;;			if !currentImages.Has(image) {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Image ID %s is no longer present; removing from imageRecords", image)
0000000000000000000000000000000000000000;;				delete(im.imageRecords, image)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (im *realImageGCManager) GarbageCollect() error {
0000000000000000000000000000000000000000;;		// Get disk usage on disk holding images.
0000000000000000000000000000000000000000;;		fsInfo, err := im.cadvisor.ImagesFsInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		capacity := int64(fsInfo.Capacity)
0000000000000000000000000000000000000000;;		available := int64(fsInfo.Available)
0000000000000000000000000000000000000000;;		if available > capacity {
0000000000000000000000000000000000000000;;			glog.Warningf("available %d is larger than capacity %d", available, capacity)
0000000000000000000000000000000000000000;;			available = capacity
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check valid capacity.
0000000000000000000000000000000000000000;;		if capacity == 0 {
0000000000000000000000000000000000000000;;			err := fmt.Errorf("invalid capacity %d on device %q at mount point %q", capacity, fsInfo.Device, fsInfo.Mountpoint)
0000000000000000000000000000000000000000;;			im.recorder.Eventf(im.nodeRef, v1.EventTypeWarning, events.InvalidDiskCapacity, err.Error())
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If over the max threshold, free enough to place us at the lower threshold.
0000000000000000000000000000000000000000;;		usagePercent := 100 - int(available*100/capacity)
0000000000000000000000000000000000000000;;		if usagePercent >= im.policy.HighThresholdPercent {
0000000000000000000000000000000000000000;;			amountToFree := capacity*int64(100-im.policy.LowThresholdPercent)/100 - available
0000000000000000000000000000000000000000;;			glog.Infof("[imageGCManager]: Disk usage on %q (%s) is at %d%% which is over the high threshold (%d%%). Trying to free %d bytes", fsInfo.Device, fsInfo.Mountpoint, usagePercent, im.policy.HighThresholdPercent, amountToFree)
0000000000000000000000000000000000000000;;			freed, err := im.freeSpace(amountToFree, time.Now())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if freed < amountToFree {
0000000000000000000000000000000000000000;;				err := fmt.Errorf("failed to garbage collect required amount of images. Wanted to free %d bytes, but freed %d bytes", amountToFree, freed)
0000000000000000000000000000000000000000;;				im.recorder.Eventf(im.nodeRef, v1.EventTypeWarning, events.FreeDiskSpaceFailed, err.Error())
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (im *realImageGCManager) DeleteUnusedImages() (int64, error) {
0000000000000000000000000000000000000000;;		return im.freeSpace(math.MaxInt64, time.Now())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tries to free bytesToFree worth of images on the disk.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns the number of bytes free and an error if any occurred. The number of
0000000000000000000000000000000000000000;;	// bytes freed is always returned.
0000000000000000000000000000000000000000;;	// Note that error may be nil and the number of bytes free may be less
0000000000000000000000000000000000000000;;	// than bytesToFree.
0000000000000000000000000000000000000000;;	func (im *realImageGCManager) freeSpace(bytesToFree int64, freeTime time.Time) (int64, error) {
0000000000000000000000000000000000000000;;		err := im.detectImages(freeTime)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		im.imageRecordsLock.Lock()
0000000000000000000000000000000000000000;;		defer im.imageRecordsLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get all images in eviction order.
0000000000000000000000000000000000000000;;		images := make([]evictionInfo, 0, len(im.imageRecords))
0000000000000000000000000000000000000000;;		for image, record := range im.imageRecords {
0000000000000000000000000000000000000000;;			images = append(images, evictionInfo{
0000000000000000000000000000000000000000;;				id:          image,
0000000000000000000000000000000000000000;;				imageRecord: *record,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(byLastUsedAndDetected(images))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete unused images until we've freed up enough space.
0000000000000000000000000000000000000000;;		var deletionErrors []error
0000000000000000000000000000000000000000;;		spaceFreed := int64(0)
0000000000000000000000000000000000000000;;		for _, image := range images {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("Evaluating image ID %s for possible garbage collection", image.id)
0000000000000000000000000000000000000000;;			// Images that are currently in used were given a newer lastUsed.
0000000000000000000000000000000000000000;;			if image.lastUsed.Equal(freeTime) || image.lastUsed.After(freeTime) {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Image ID %s has lastUsed=%v which is >= freeTime=%v, not eligible for garbage collection", image.id, image.lastUsed, freeTime)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Avoid garbage collect the image if the image is not old enough.
0000000000000000000000000000000000000000;;			// In such a case, the image may have just been pulled down, and will be used by a container right away.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if freeTime.Sub(image.firstDetected) < im.policy.MinAge {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Image ID %s has age %v which is less than the policy's minAge of %v, not eligible for garbage collection", image.id, freeTime.Sub(image.firstDetected), im.policy.MinAge)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Remove image. Continue despite errors.
0000000000000000000000000000000000000000;;			glog.Infof("[imageGCManager]: Removing image %q to free %d bytes", image.id, image.size)
0000000000000000000000000000000000000000;;			err := im.runtime.RemoveImage(container.ImageSpec{Image: image.id})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				deletionErrors = append(deletionErrors, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			delete(im.imageRecords, image.id)
0000000000000000000000000000000000000000;;			spaceFreed += image.size
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if spaceFreed >= bytesToFree {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(deletionErrors) > 0 {
0000000000000000000000000000000000000000;;			return spaceFreed, fmt.Errorf("wanted to free %d bytes, but freed %d bytes space with errors in image deletion: %v", bytesToFree, spaceFreed, errors.NewAggregate(deletionErrors))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return spaceFreed, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type evictionInfo struct {
0000000000000000000000000000000000000000;;		id string
0000000000000000000000000000000000000000;;		imageRecord
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type byLastUsedAndDetected []evictionInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ev byLastUsedAndDetected) Len() int      { return len(ev) }
0000000000000000000000000000000000000000;;	func (ev byLastUsedAndDetected) Swap(i, j int) { ev[i], ev[j] = ev[j], ev[i] }
0000000000000000000000000000000000000000;;	func (ev byLastUsedAndDetected) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		// Sort by last used, break ties by detected.
0000000000000000000000000000000000000000;;		if ev[i].lastUsed.Equal(ev[j].lastUsed) {
0000000000000000000000000000000000000000;;			return ev[i].firstDetected.Before(ev[j].firstDetected)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return ev[i].lastUsed.Before(ev[j].lastUsed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isImageUsed(image container.Image, imagesInUse sets.String) bool {
0000000000000000000000000000000000000000;;		// Check the image ID.
0000000000000000000000000000000000000000;;		if _, ok := imagesInUse[image.ID]; ok {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
