0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f7ffd0c80e089aaccbfa97e611585b0b74301721;pkg/kubelet/image_manager_test.go[pkg/kubelet/image_manager_test.go][pkg/kubelet/images/image_gc_manager_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package images
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cadvisorapiv2 "github.com/google/cadvisor/info/v2"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/require"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		cadvisortest "k8s.io/kubernetes/pkg/kubelet/cadvisor/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		containertest "k8s.io/kubernetes/pkg/kubelet/container/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var zero time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRealImageGCManager(policy ImageGCPolicy) (*realImageGCManager, *containertest.FakeRuntime, *cadvisortest.Mock) {
0000000000000000000000000000000000000000;;		fakeRuntime := &containertest.FakeRuntime{}
0000000000000000000000000000000000000000;;		mockCadvisor := new(cadvisortest.Mock)
0000000000000000000000000000000000000000;;		return &realImageGCManager{
0000000000000000000000000000000000000000;;			runtime:      fakeRuntime,
0000000000000000000000000000000000000000;;			policy:       policy,
0000000000000000000000000000000000000000;;			imageRecords: make(map[string]*imageRecord),
0000000000000000000000000000000000000000;;			cadvisor:     mockCadvisor,
0000000000000000000000000000000000000000;;			recorder:     &record.FakeRecorder{},
0000000000000000000000000000000000000000;;		}, fakeRuntime, mockCadvisor
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Accessors used for thread-safe testing.
0000000000000000000000000000000000000000;;	func (im *realImageGCManager) imageRecordsLen() int {
0000000000000000000000000000000000000000;;		im.imageRecordsLock.Lock()
0000000000000000000000000000000000000000;;		defer im.imageRecordsLock.Unlock()
0000000000000000000000000000000000000000;;		return len(im.imageRecords)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (im *realImageGCManager) getImageRecord(name string) (*imageRecord, bool) {
0000000000000000000000000000000000000000;;		im.imageRecordsLock.Lock()
0000000000000000000000000000000000000000;;		defer im.imageRecordsLock.Unlock()
0000000000000000000000000000000000000000;;		v, ok := im.imageRecords[name]
0000000000000000000000000000000000000000;;		vCopy := *v
0000000000000000000000000000000000000000;;		return &vCopy, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the id of the image with the given ID.
0000000000000000000000000000000000000000;;	func imageID(id int) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("image-%d", id)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the name of the image with the given ID.
0000000000000000000000000000000000000000;;	func imageName(id int) string {
0000000000000000000000000000000000000000;;		return imageID(id) + "-name"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Make an image with the specified ID.
0000000000000000000000000000000000000000;;	func makeImage(id int, size int64) container.Image {
0000000000000000000000000000000000000000;;		return container.Image{
0000000000000000000000000000000000000000;;			ID:   imageID(id),
0000000000000000000000000000000000000000;;			Size: size,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Make a container with the specified ID. It will use the image with the same ID.
0000000000000000000000000000000000000000;;	func makeContainer(id int) *container.Container {
0000000000000000000000000000000000000000;;		return &container.Container{
0000000000000000000000000000000000000000;;			ID:      container.ContainerID{Type: "test", ID: fmt.Sprintf("container-%d", id)},
0000000000000000000000000000000000000000;;			Image:   imageName(id),
0000000000000000000000000000000000000000;;			ImageID: imageID(id),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDetectImagesInitialDetect(t *testing.T) {
0000000000000000000000000000000000000000;;		manager, fakeRuntime, _ := newRealImageGCManager(ImageGCPolicy{})
0000000000000000000000000000000000000000;;		fakeRuntime.ImageList = []container.Image{
0000000000000000000000000000000000000000;;			makeImage(0, 1024),
0000000000000000000000000000000000000000;;			makeImage(1, 2048),
0000000000000000000000000000000000000000;;			makeImage(2, 2048),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeRuntime.AllPodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;			{Pod: &container.Pod{
0000000000000000000000000000000000000000;;				Containers: []*container.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ID:      container.ContainerID{Type: "test", ID: fmt.Sprintf("container-%d", 1)},
0000000000000000000000000000000000000000;;						ImageID: imageID(1),
0000000000000000000000000000000000000000;;						// The image filed is not set to simulate a no-name image
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ID:      container.ContainerID{Type: "test", ID: fmt.Sprintf("container-%d", 2)},
0000000000000000000000000000000000000000;;						Image:   imageName(2),
0000000000000000000000000000000000000000;;						ImageID: imageID(2),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		startTime := time.Now().Add(-time.Millisecond)
0000000000000000000000000000000000000000;;		err := manager.detectImages(zero)
0000000000000000000000000000000000000000;;		assert := assert.New(t)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(manager.imageRecordsLen(), 3)
0000000000000000000000000000000000000000;;		noContainer, ok := manager.getImageRecord(imageID(0))
0000000000000000000000000000000000000000;;		require.True(t, ok)
0000000000000000000000000000000000000000;;		assert.Equal(zero, noContainer.firstDetected)
0000000000000000000000000000000000000000;;		assert.Equal(zero, noContainer.lastUsed)
0000000000000000000000000000000000000000;;		withContainerUsingNoNameImage, ok := manager.getImageRecord(imageID(1))
0000000000000000000000000000000000000000;;		require.True(t, ok)
0000000000000000000000000000000000000000;;		assert.Equal(zero, withContainerUsingNoNameImage.firstDetected)
0000000000000000000000000000000000000000;;		assert.True(withContainerUsingNoNameImage.lastUsed.After(startTime))
0000000000000000000000000000000000000000;;		withContainer, ok := manager.getImageRecord(imageID(2))
0000000000000000000000000000000000000000;;		require.True(t, ok)
0000000000000000000000000000000000000000;;		assert.Equal(zero, withContainer.firstDetected)
0000000000000000000000000000000000000000;;		assert.True(withContainer.lastUsed.After(startTime))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDetectImagesWithNewImage(t *testing.T) {
0000000000000000000000000000000000000000;;		// Just one image initially.
0000000000000000000000000000000000000000;;		manager, fakeRuntime, _ := newRealImageGCManager(ImageGCPolicy{})
0000000000000000000000000000000000000000;;		fakeRuntime.ImageList = []container.Image{
0000000000000000000000000000000000000000;;			makeImage(0, 1024),
0000000000000000000000000000000000000000;;			makeImage(1, 2048),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeRuntime.AllPodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;			{Pod: &container.Pod{
0000000000000000000000000000000000000000;;				Containers: []*container.Container{
0000000000000000000000000000000000000000;;					makeContainer(1),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := manager.detectImages(zero)
0000000000000000000000000000000000000000;;		assert := assert.New(t)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(manager.imageRecordsLen(), 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add a new image.
0000000000000000000000000000000000000000;;		fakeRuntime.ImageList = []container.Image{
0000000000000000000000000000000000000000;;			makeImage(0, 1024),
0000000000000000000000000000000000000000;;			makeImage(1, 1024),
0000000000000000000000000000000000000000;;			makeImage(2, 1024),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		detectedTime := zero.Add(time.Second)
0000000000000000000000000000000000000000;;		startTime := time.Now().Add(-time.Millisecond)
0000000000000000000000000000000000000000;;		err = manager.detectImages(detectedTime)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(manager.imageRecordsLen(), 3)
0000000000000000000000000000000000000000;;		noContainer, ok := manager.getImageRecord(imageID(0))
0000000000000000000000000000000000000000;;		require.True(t, ok)
0000000000000000000000000000000000000000;;		assert.Equal(zero, noContainer.firstDetected)
0000000000000000000000000000000000000000;;		assert.Equal(zero, noContainer.lastUsed)
0000000000000000000000000000000000000000;;		withContainer, ok := manager.getImageRecord(imageID(1))
0000000000000000000000000000000000000000;;		require.True(t, ok)
0000000000000000000000000000000000000000;;		assert.Equal(zero, withContainer.firstDetected)
0000000000000000000000000000000000000000;;		assert.True(withContainer.lastUsed.After(startTime))
0000000000000000000000000000000000000000;;		newContainer, ok := manager.getImageRecord(imageID(2))
0000000000000000000000000000000000000000;;		require.True(t, ok)
0000000000000000000000000000000000000000;;		assert.Equal(detectedTime, newContainer.firstDetected)
0000000000000000000000000000000000000000;;		assert.Equal(zero, noContainer.lastUsed)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDetectImagesContainerStopped(t *testing.T) {
0000000000000000000000000000000000000000;;		manager, fakeRuntime, _ := newRealImageGCManager(ImageGCPolicy{})
0000000000000000000000000000000000000000;;		fakeRuntime.ImageList = []container.Image{
0000000000000000000000000000000000000000;;			makeImage(0, 1024),
0000000000000000000000000000000000000000;;			makeImage(1, 2048),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeRuntime.AllPodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;			{Pod: &container.Pod{
0000000000000000000000000000000000000000;;				Containers: []*container.Container{
0000000000000000000000000000000000000000;;					makeContainer(1),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := manager.detectImages(zero)
0000000000000000000000000000000000000000;;		assert := assert.New(t)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(manager.imageRecordsLen(), 2)
0000000000000000000000000000000000000000;;		withContainer, ok := manager.getImageRecord(imageID(1))
0000000000000000000000000000000000000000;;		require.True(t, ok)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Simulate container being stopped.
0000000000000000000000000000000000000000;;		fakeRuntime.AllPodList = []*containertest.FakePod{}
0000000000000000000000000000000000000000;;		err = manager.detectImages(time.Now())
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(manager.imageRecordsLen(), 2)
0000000000000000000000000000000000000000;;		container1, ok := manager.getImageRecord(imageID(0))
0000000000000000000000000000000000000000;;		require.True(t, ok)
0000000000000000000000000000000000000000;;		assert.Equal(zero, container1.firstDetected)
0000000000000000000000000000000000000000;;		assert.Equal(zero, container1.lastUsed)
0000000000000000000000000000000000000000;;		container2, ok := manager.getImageRecord(imageID(1))
0000000000000000000000000000000000000000;;		require.True(t, ok)
0000000000000000000000000000000000000000;;		assert.Equal(zero, container2.firstDetected)
0000000000000000000000000000000000000000;;		assert.True(container2.lastUsed.Equal(withContainer.lastUsed))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDetectImagesWithRemovedImages(t *testing.T) {
0000000000000000000000000000000000000000;;		manager, fakeRuntime, _ := newRealImageGCManager(ImageGCPolicy{})
0000000000000000000000000000000000000000;;		fakeRuntime.ImageList = []container.Image{
0000000000000000000000000000000000000000;;			makeImage(0, 1024),
0000000000000000000000000000000000000000;;			makeImage(1, 2048),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeRuntime.AllPodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;			{Pod: &container.Pod{
0000000000000000000000000000000000000000;;				Containers: []*container.Container{
0000000000000000000000000000000000000000;;					makeContainer(1),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := manager.detectImages(zero)
0000000000000000000000000000000000000000;;		assert := assert.New(t)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(manager.imageRecordsLen(), 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Simulate both images being removed.
0000000000000000000000000000000000000000;;		fakeRuntime.ImageList = []container.Image{}
0000000000000000000000000000000000000000;;		err = manager.detectImages(time.Now())
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(manager.imageRecordsLen(), 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFreeSpaceImagesInUseContainersAreIgnored(t *testing.T) {
0000000000000000000000000000000000000000;;		manager, fakeRuntime, _ := newRealImageGCManager(ImageGCPolicy{})
0000000000000000000000000000000000000000;;		fakeRuntime.ImageList = []container.Image{
0000000000000000000000000000000000000000;;			makeImage(0, 1024),
0000000000000000000000000000000000000000;;			makeImage(1, 2048),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeRuntime.AllPodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;			{Pod: &container.Pod{
0000000000000000000000000000000000000000;;				Containers: []*container.Container{
0000000000000000000000000000000000000000;;					makeContainer(1),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spaceFreed, err := manager.freeSpace(2048, time.Now())
0000000000000000000000000000000000000000;;		assert := assert.New(t)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.EqualValues(1024, spaceFreed)
0000000000000000000000000000000000000000;;		assert.Len(fakeRuntime.ImageList, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteUnusedImagesRemoveAllUnusedImages(t *testing.T) {
0000000000000000000000000000000000000000;;		manager, fakeRuntime, _ := newRealImageGCManager(ImageGCPolicy{})
0000000000000000000000000000000000000000;;		fakeRuntime.ImageList = []container.Image{
0000000000000000000000000000000000000000;;			makeImage(0, 1024),
0000000000000000000000000000000000000000;;			makeImage(1, 2048),
0000000000000000000000000000000000000000;;			makeImage(2, 2048),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeRuntime.AllPodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;			{Pod: &container.Pod{
0000000000000000000000000000000000000000;;				Containers: []*container.Container{
0000000000000000000000000000000000000000;;					makeContainer(2),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spaceFreed, err := manager.DeleteUnusedImages()
0000000000000000000000000000000000000000;;		assert := assert.New(t)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.EqualValues(3072, spaceFreed)
0000000000000000000000000000000000000000;;		assert.Len(fakeRuntime.ImageList, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFreeSpaceRemoveByLeastRecentlyUsed(t *testing.T) {
0000000000000000000000000000000000000000;;		manager, fakeRuntime, _ := newRealImageGCManager(ImageGCPolicy{})
0000000000000000000000000000000000000000;;		fakeRuntime.ImageList = []container.Image{
0000000000000000000000000000000000000000;;			makeImage(0, 1024),
0000000000000000000000000000000000000000;;			makeImage(1, 2048),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeRuntime.AllPodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;			{Pod: &container.Pod{
0000000000000000000000000000000000000000;;				Containers: []*container.Container{
0000000000000000000000000000000000000000;;					makeContainer(0),
0000000000000000000000000000000000000000;;					makeContainer(1),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make 1 be more recently used than 0.
0000000000000000000000000000000000000000;;		require.NoError(t, manager.detectImages(zero))
0000000000000000000000000000000000000000;;		fakeRuntime.AllPodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;			{Pod: &container.Pod{
0000000000000000000000000000000000000000;;				Containers: []*container.Container{
0000000000000000000000000000000000000000;;					makeContainer(1),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		require.NoError(t, manager.detectImages(time.Now()))
0000000000000000000000000000000000000000;;		fakeRuntime.AllPodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;			{Pod: &container.Pod{
0000000000000000000000000000000000000000;;				Containers: []*container.Container{},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		require.NoError(t, manager.detectImages(time.Now()))
0000000000000000000000000000000000000000;;		require.Equal(t, manager.imageRecordsLen(), 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spaceFreed, err := manager.freeSpace(1024, time.Now())
0000000000000000000000000000000000000000;;		assert := assert.New(t)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.EqualValues(1024, spaceFreed)
0000000000000000000000000000000000000000;;		assert.Len(fakeRuntime.ImageList, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFreeSpaceTiesBrokenByDetectedTime(t *testing.T) {
0000000000000000000000000000000000000000;;		manager, fakeRuntime, _ := newRealImageGCManager(ImageGCPolicy{})
0000000000000000000000000000000000000000;;		fakeRuntime.ImageList = []container.Image{
0000000000000000000000000000000000000000;;			makeImage(0, 1024),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeRuntime.AllPodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;			{Pod: &container.Pod{
0000000000000000000000000000000000000000;;				Containers: []*container.Container{
0000000000000000000000000000000000000000;;					makeContainer(0),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make 1 more recently detected but used at the same time as 0.
0000000000000000000000000000000000000000;;		require.NoError(t, manager.detectImages(zero))
0000000000000000000000000000000000000000;;		fakeRuntime.ImageList = []container.Image{
0000000000000000000000000000000000000000;;			makeImage(0, 1024),
0000000000000000000000000000000000000000;;			makeImage(1, 2048),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		require.NoError(t, manager.detectImages(time.Now()))
0000000000000000000000000000000000000000;;		fakeRuntime.AllPodList = []*containertest.FakePod{}
0000000000000000000000000000000000000000;;		require.NoError(t, manager.detectImages(time.Now()))
0000000000000000000000000000000000000000;;		require.Equal(t, manager.imageRecordsLen(), 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spaceFreed, err := manager.freeSpace(1024, time.Now())
0000000000000000000000000000000000000000;;		assert := assert.New(t)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.EqualValues(2048, spaceFreed)
0000000000000000000000000000000000000000;;		assert.Len(fakeRuntime.ImageList, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGarbageCollectBelowLowThreshold(t *testing.T) {
0000000000000000000000000000000000000000;;		policy := ImageGCPolicy{
0000000000000000000000000000000000000000;;			HighThresholdPercent: 90,
0000000000000000000000000000000000000000;;			LowThresholdPercent:  80,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager, _, mockCadvisor := newRealImageGCManager(policy)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Expect 40% usage.
0000000000000000000000000000000000000000;;		mockCadvisor.On("ImagesFsInfo").Return(cadvisorapiv2.FsInfo{
0000000000000000000000000000000000000000;;			Available: 600,
0000000000000000000000000000000000000000;;			Capacity:  1000,
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.NoError(t, manager.GarbageCollect())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGarbageCollectCadvisorFailure(t *testing.T) {
0000000000000000000000000000000000000000;;		policy := ImageGCPolicy{
0000000000000000000000000000000000000000;;			HighThresholdPercent: 90,
0000000000000000000000000000000000000000;;			LowThresholdPercent:  80,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager, _, mockCadvisor := newRealImageGCManager(policy)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mockCadvisor.On("ImagesFsInfo").Return(cadvisorapiv2.FsInfo{}, fmt.Errorf("error"))
0000000000000000000000000000000000000000;;		assert.NotNil(t, manager.GarbageCollect())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGarbageCollectBelowSuccess(t *testing.T) {
0000000000000000000000000000000000000000;;		policy := ImageGCPolicy{
0000000000000000000000000000000000000000;;			HighThresholdPercent: 90,
0000000000000000000000000000000000000000;;			LowThresholdPercent:  80,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager, fakeRuntime, mockCadvisor := newRealImageGCManager(policy)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Expect 95% usage and most of it gets freed.
0000000000000000000000000000000000000000;;		mockCadvisor.On("ImagesFsInfo").Return(cadvisorapiv2.FsInfo{
0000000000000000000000000000000000000000;;			Available: 50,
0000000000000000000000000000000000000000;;			Capacity:  1000,
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		fakeRuntime.ImageList = []container.Image{
0000000000000000000000000000000000000000;;			makeImage(0, 450),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.NoError(t, manager.GarbageCollect())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGarbageCollectNotEnoughFreed(t *testing.T) {
0000000000000000000000000000000000000000;;		policy := ImageGCPolicy{
0000000000000000000000000000000000000000;;			HighThresholdPercent: 90,
0000000000000000000000000000000000000000;;			LowThresholdPercent:  80,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager, fakeRuntime, mockCadvisor := newRealImageGCManager(policy)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Expect 95% usage and little of it gets freed.
0000000000000000000000000000000000000000;;		mockCadvisor.On("ImagesFsInfo").Return(cadvisorapiv2.FsInfo{
0000000000000000000000000000000000000000;;			Available: 50,
0000000000000000000000000000000000000000;;			Capacity:  1000,
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		fakeRuntime.ImageList = []container.Image{
0000000000000000000000000000000000000000;;			makeImage(0, 50),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.NotNil(t, manager.GarbageCollect())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGarbageCollectImageNotOldEnough(t *testing.T) {
0000000000000000000000000000000000000000;;		policy := ImageGCPolicy{
0000000000000000000000000000000000000000;;			HighThresholdPercent: 90,
0000000000000000000000000000000000000000;;			LowThresholdPercent:  80,
0000000000000000000000000000000000000000;;			MinAge:               time.Minute * 1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeRuntime := &containertest.FakeRuntime{}
0000000000000000000000000000000000000000;;		mockCadvisor := new(cadvisortest.Mock)
0000000000000000000000000000000000000000;;		manager := &realImageGCManager{
0000000000000000000000000000000000000000;;			runtime:      fakeRuntime,
0000000000000000000000000000000000000000;;			policy:       policy,
0000000000000000000000000000000000000000;;			imageRecords: make(map[string]*imageRecord),
0000000000000000000000000000000000000000;;			cadvisor:     mockCadvisor,
0000000000000000000000000000000000000000;;			recorder:     &record.FakeRecorder{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeRuntime.ImageList = []container.Image{
0000000000000000000000000000000000000000;;			makeImage(0, 1024),
0000000000000000000000000000000000000000;;			makeImage(1, 2048),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// 1 image is in use, and another one is not old enough
0000000000000000000000000000000000000000;;		fakeRuntime.AllPodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;			{Pod: &container.Pod{
0000000000000000000000000000000000000000;;				Containers: []*container.Container{
0000000000000000000000000000000000000000;;					makeContainer(1),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClock := clock.NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		t.Log(fakeClock.Now())
0000000000000000000000000000000000000000;;		require.NoError(t, manager.detectImages(fakeClock.Now()))
0000000000000000000000000000000000000000;;		require.Equal(t, manager.imageRecordsLen(), 2)
0000000000000000000000000000000000000000;;		// no space freed since one image is in used, and another one is not old enough
0000000000000000000000000000000000000000;;		spaceFreed, err := manager.freeSpace(1024, fakeClock.Now())
0000000000000000000000000000000000000000;;		assert := assert.New(t)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.EqualValues(0, spaceFreed)
0000000000000000000000000000000000000000;;		assert.Len(fakeRuntime.ImageList, 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// move clock by minAge duration, then 1 image will be garbage collected
0000000000000000000000000000000000000000;;		fakeClock.Step(policy.MinAge)
0000000000000000000000000000000000000000;;		spaceFreed, err = manager.freeSpace(1024, fakeClock.Now())
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.EqualValues(1024, spaceFreed)
0000000000000000000000000000000000000000;;		assert.Len(fakeRuntime.ImageList, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateImageGCPolicy(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			name          string
0000000000000000000000000000000000000000;;			imageGCPolicy ImageGCPolicy
0000000000000000000000000000000000000000;;			expectErr     string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Test for LowThresholdPercent < HighThresholdPercent",
0000000000000000000000000000000000000000;;				imageGCPolicy: ImageGCPolicy{
0000000000000000000000000000000000000000;;					HighThresholdPercent: 2,
0000000000000000000000000000000000000000;;					LowThresholdPercent:  1,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Test for HighThresholdPercent < 0,",
0000000000000000000000000000000000000000;;				imageGCPolicy: ImageGCPolicy{
0000000000000000000000000000000000000000;;					HighThresholdPercent: -1,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: "invalid HighThresholdPercent -1, must be in range [0-100]",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Test for HighThresholdPercent > 100",
0000000000000000000000000000000000000000;;				imageGCPolicy: ImageGCPolicy{
0000000000000000000000000000000000000000;;					HighThresholdPercent: 101,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: "invalid HighThresholdPercent 101, must be in range [0-100]",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Test for LowThresholdPercent < 0",
0000000000000000000000000000000000000000;;				imageGCPolicy: ImageGCPolicy{
0000000000000000000000000000000000000000;;					LowThresholdPercent: -1,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: "invalid LowThresholdPercent -1, must be in range [0-100]",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Test for LowThresholdPercent > 100",
0000000000000000000000000000000000000000;;				imageGCPolicy: ImageGCPolicy{
0000000000000000000000000000000000000000;;					LowThresholdPercent: 101,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: "invalid LowThresholdPercent 101, must be in range [0-100]",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Test for LowThresholdPercent > HighThresholdPercent",
0000000000000000000000000000000000000000;;				imageGCPolicy: ImageGCPolicy{
0000000000000000000000000000000000000000;;					HighThresholdPercent: 1,
0000000000000000000000000000000000000000;;					LowThresholdPercent:  2,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: "LowThresholdPercent 2 can not be higher than HighThresholdPercent 1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			if _, err := NewImageGCManager(nil, nil, nil, nil, tc.imageGCPolicy); err != nil {
0000000000000000000000000000000000000000;;				if err.Error() != tc.expectErr {
0000000000000000000000000000000000000000;;					t.Errorf("[%s:]Expected err:%v, but got:%v", tc.name, tc.expectErr, err.Error())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
