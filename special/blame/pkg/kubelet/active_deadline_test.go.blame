0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
055be32dc81877eed2716faf43dbbe5350599c51;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mockPodStatusProvider returns the status on the specified pod
0000000000000000000000000000000000000000;;	type mockPodStatusProvider struct {
0000000000000000000000000000000000000000;;		pods []*v1.Pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPodStatus returns the status on the associated pod with matching uid (if found)
0000000000000000000000000000000000000000;;	func (m *mockPodStatusProvider) GetPodStatus(uid types.UID) (v1.PodStatus, bool) {
0000000000000000000000000000000000000000;;		for _, pod := range m.pods {
0000000000000000000000000000000000000000;;			if pod.UID == uid {
0000000000000000000000000000000000000000;;				return pod.Status, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v1.PodStatus{}, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestActiveDeadlineHandler verifies the active deadline handler functions as expected.
0000000000000000000000000000000000000000;;	func TestActiveDeadlineHandler(t *testing.T) {
0000000000000000000000000000000000000000;;		pods := newTestPods(4)
0000000000000000000000000000000000000000;;		fakeClock := clock.NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		podStatusProvider := &mockPodStatusProvider{pods: pods}
0000000000000000000000000000000000000000;;		fakeRecorder := &record.FakeRecorder{}
0000000000000000000000000000000000000000;;		handler, err := newActiveDeadlineHandler(podStatusProvider, fakeRecorder, fakeClock)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		startTime := metav1.NewTime(now.Time.Add(-1 * time.Minute))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this pod has exceeded its active deadline
0000000000000000000000000000000000000000;;		exceededActiveDeadlineSeconds := int64(30)
0000000000000000000000000000000000000000;;		pods[0].Status.StartTime = &startTime
0000000000000000000000000000000000000000;;		pods[0].Spec.ActiveDeadlineSeconds = &exceededActiveDeadlineSeconds
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this pod has not exceeded its active deadline
0000000000000000000000000000000000000000;;		notYetActiveDeadlineSeconds := int64(120)
0000000000000000000000000000000000000000;;		pods[1].Status.StartTime = &startTime
0000000000000000000000000000000000000000;;		pods[1].Spec.ActiveDeadlineSeconds = &notYetActiveDeadlineSeconds
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this pod has no deadline
0000000000000000000000000000000000000000;;		pods[2].Status.StartTime = &startTime
0000000000000000000000000000000000000000;;		pods[2].Spec.ActiveDeadlineSeconds = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			pod      *v1.Pod
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{{pods[0], true}, {pods[1], false}, {pods[2], false}, {pods[3], false}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			if actual := handler.ShouldSync(testCase.pod); actual != testCase.expected {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] ShouldSync expected %#v, got %#v", i, testCase.expected, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			actual := handler.ShouldEvict(testCase.pod)
0000000000000000000000000000000000000000;;			if actual.Evict != testCase.expected {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] ShouldEvict.Evict expected %#v, got %#v", i, testCase.expected, actual.Evict)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if testCase.expected {
0000000000000000000000000000000000000000;;				if actual.Reason != reason {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] ShouldEvict.Reason expected %#v, got %#v", i, message, actual.Reason)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if actual.Message != message {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] ShouldEvict.Message expected %#v, got %#v", i, message, actual.Message)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
