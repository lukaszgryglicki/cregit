0000000000000000000000000000000000000000;;	// +build cgo
42a9e0db334cc54ce877d10c6f1476cf57a9ddf2;pkg/kubelet/eviction/threshold_notifier.go[pkg/kubelet/eviction/threshold_notifier.go][pkg/kubelet/eviction/threshold_notifier_linux.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package eviction
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	#include <sys/eventfd.h>
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	import "C"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type memcgThresholdNotifier struct {
0000000000000000000000000000000000000000;;		watchfd     int
0000000000000000000000000000000000000000;;		controlfd   int
0000000000000000000000000000000000000000;;		eventfd     int
0000000000000000000000000000000000000000;;		handler     thresholdNotifierHandlerFunc
0000000000000000000000000000000000000000;;		description string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ ThresholdNotifier = &memcgThresholdNotifier{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewMemCGThresholdNotifier sends notifications when a cgroup threshold
0000000000000000000000000000000000000000;;	// is crossed (in either direction) for a given cgroup attribute
0000000000000000000000000000000000000000;;	func NewMemCGThresholdNotifier(path, attribute, threshold, description string, handler thresholdNotifierHandlerFunc) (ThresholdNotifier, error) {
0000000000000000000000000000000000000000;;		watchfd, err := syscall.Open(fmt.Sprintf("%s/%s", path, attribute), syscall.O_RDONLY, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				syscall.Close(watchfd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		controlfd, err := syscall.Open(fmt.Sprintf("%s/cgroup.event_control", path), syscall.O_WRONLY, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				syscall.Close(controlfd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		efd, err := C.eventfd(0, C.EFD_CLOEXEC)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eventfd := int(efd)
0000000000000000000000000000000000000000;;		if eventfd < 0 {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("eventfd call failed")
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				syscall.Close(eventfd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		glog.V(2).Infof("eviction: setting notification threshold to %s", threshold)
0000000000000000000000000000000000000000;;		config := fmt.Sprintf("%d %d %s", eventfd, watchfd, threshold)
0000000000000000000000000000000000000000;;		_, err = syscall.Write(controlfd, []byte(config))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &memcgThresholdNotifier{
0000000000000000000000000000000000000000;;			watchfd:     watchfd,
0000000000000000000000000000000000000000;;			controlfd:   controlfd,
0000000000000000000000000000000000000000;;			eventfd:     eventfd,
0000000000000000000000000000000000000000;;			handler:     handler,
0000000000000000000000000000000000000000;;			description: description,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getThresholdEvents(eventfd int, eventCh chan<- struct{}, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			buf := make([]byte, 8)
0000000000000000000000000000000000000000;;			_, err := syscall.Read(eventfd, buf)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case eventCh <- struct{}{}:
0000000000000000000000000000000000000000;;			case <-stopCh:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *memcgThresholdNotifier) Start(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		eventCh := make(chan struct{})
0000000000000000000000000000000000000000;;		go getThresholdEvents(n.eventfd, eventCh, stopCh)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-stopCh:
0000000000000000000000000000000000000000;;				glog.V(2).Infof("eviction: stopping threshold notifier")
0000000000000000000000000000000000000000;;				syscall.Close(n.watchfd)
0000000000000000000000000000000000000000;;				syscall.Close(n.controlfd)
0000000000000000000000000000000000000000;;				syscall.Close(n.eventfd)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-eventCh:
0000000000000000000000000000000000000000;;				glog.V(2).Infof("eviction: threshold crossed")
0000000000000000000000000000000000000000;;				n.handler(n.description)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
