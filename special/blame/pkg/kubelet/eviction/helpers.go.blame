0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
20e2419ee209ff5ea436a2241a59408045607edc;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package eviction
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		v1qos "k8s.io/kubernetes/pkg/api/v1/helper/qos"
0000000000000000000000000000000000000000;;		statsapi "k8s.io/kubernetes/pkg/kubelet/apis/stats/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/cm"
0000000000000000000000000000000000000000;;		evictionapi "k8s.io/kubernetes/pkg/kubelet/eviction/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/server/stats"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/quota/evaluator/core"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		unsupportedEvictionSignal = "unsupported eviction signal %v"
0000000000000000000000000000000000000000;;		// the reason reported back in status.
0000000000000000000000000000000000000000;;		reason = "Evicted"
0000000000000000000000000000000000000000;;		// the message associated with the reason.
0000000000000000000000000000000000000000;;		message = "The node was low on resource: %v."
0000000000000000000000000000000000000000;;		// disk, in bytes.  internal to this module, used to account for local disk usage.
0000000000000000000000000000000000000000;;		resourceDisk v1.ResourceName = "disk"
0000000000000000000000000000000000000000;;		// inodes, number. internal to this module, used to account for local disk inode consumption.
0000000000000000000000000000000000000000;;		resourceInodes v1.ResourceName = "inodes"
0000000000000000000000000000000000000000;;		// imagefs, in bytes.  internal to this module, used to account for local image filesystem usage.
0000000000000000000000000000000000000000;;		resourceImageFs v1.ResourceName = "imagefs"
0000000000000000000000000000000000000000;;		// imagefs inodes, number.  internal to this module, used to account for local image filesystem inodes.
0000000000000000000000000000000000000000;;		resourceImageFsInodes v1.ResourceName = "imagefsInodes"
0000000000000000000000000000000000000000;;		// nodefs, in bytes.  internal to this module, used to account for local node root filesystem usage.
0000000000000000000000000000000000000000;;		resourceNodeFs v1.ResourceName = "nodefs"
0000000000000000000000000000000000000000;;		// nodefs inodes, number.  internal to this module, used to account for local node root filesystem inodes.
0000000000000000000000000000000000000000;;		resourceNodeFsInodes v1.ResourceName = "nodefsInodes"
0000000000000000000000000000000000000000;;		// container overlay storage, in bytes.  internal to this module, used to account for local disk usage for container overlay.
0000000000000000000000000000000000000000;;		resourceOverlay v1.ResourceName = "overlay"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// signalToNodeCondition maps a signal to the node condition to report if threshold is met.
0000000000000000000000000000000000000000;;		signalToNodeCondition map[evictionapi.Signal]v1.NodeConditionType
0000000000000000000000000000000000000000;;		// signalToResource maps a Signal to its associated Resource.
0000000000000000000000000000000000000000;;		signalToResource map[evictionapi.Signal]v1.ResourceName
0000000000000000000000000000000000000000;;		// resourceToSignal maps a Resource to its associated Signal
0000000000000000000000000000000000000000;;		resourceToSignal map[v1.ResourceName]evictionapi.Signal
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		// map eviction signals to node conditions
0000000000000000000000000000000000000000;;		signalToNodeCondition = map[evictionapi.Signal]v1.NodeConditionType{}
0000000000000000000000000000000000000000;;		signalToNodeCondition[evictionapi.SignalMemoryAvailable] = v1.NodeMemoryPressure
0000000000000000000000000000000000000000;;		signalToNodeCondition[evictionapi.SignalAllocatableMemoryAvailable] = v1.NodeMemoryPressure
0000000000000000000000000000000000000000;;		signalToNodeCondition[evictionapi.SignalImageFsAvailable] = v1.NodeDiskPressure
0000000000000000000000000000000000000000;;		signalToNodeCondition[evictionapi.SignalNodeFsAvailable] = v1.NodeDiskPressure
0000000000000000000000000000000000000000;;		signalToNodeCondition[evictionapi.SignalImageFsInodesFree] = v1.NodeDiskPressure
0000000000000000000000000000000000000000;;		signalToNodeCondition[evictionapi.SignalNodeFsInodesFree] = v1.NodeDiskPressure
0000000000000000000000000000000000000000;;		signalToNodeCondition[evictionapi.SignalAllocatableNodeFsAvailable] = v1.NodeDiskPressure
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// map signals to resources (and vice-versa)
0000000000000000000000000000000000000000;;		signalToResource = map[evictionapi.Signal]v1.ResourceName{}
0000000000000000000000000000000000000000;;		signalToResource[evictionapi.SignalMemoryAvailable] = v1.ResourceMemory
0000000000000000000000000000000000000000;;		signalToResource[evictionapi.SignalAllocatableMemoryAvailable] = v1.ResourceMemory
0000000000000000000000000000000000000000;;		signalToResource[evictionapi.SignalAllocatableNodeFsAvailable] = resourceNodeFs
0000000000000000000000000000000000000000;;		signalToResource[evictionapi.SignalImageFsAvailable] = resourceImageFs
0000000000000000000000000000000000000000;;		signalToResource[evictionapi.SignalImageFsInodesFree] = resourceImageFsInodes
0000000000000000000000000000000000000000;;		signalToResource[evictionapi.SignalNodeFsAvailable] = resourceNodeFs
0000000000000000000000000000000000000000;;		signalToResource[evictionapi.SignalNodeFsInodesFree] = resourceNodeFsInodes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resourceToSignal = map[v1.ResourceName]evictionapi.Signal{}
0000000000000000000000000000000000000000;;		for key, value := range signalToResource {
0000000000000000000000000000000000000000;;			resourceToSignal[value] = key
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Hard-code here to make sure resourceNodeFs maps to evictionapi.SignalNodeFsAvailable
0000000000000000000000000000000000000000;;		// (TODO) resourceToSignal is a map from resource name to a list of signals
0000000000000000000000000000000000000000;;		resourceToSignal[resourceNodeFs] = evictionapi.SignalNodeFsAvailable
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validSignal returns true if the signal is supported.
0000000000000000000000000000000000000000;;	func validSignal(signal evictionapi.Signal) bool {
0000000000000000000000000000000000000000;;		_, found := signalToResource[signal]
0000000000000000000000000000000000000000;;		return found
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseThresholdConfig parses the flags for thresholds.
0000000000000000000000000000000000000000;;	func ParseThresholdConfig(allocatableConfig []string, evictionHard, evictionSoft, evictionSoftGracePeriod, evictionMinimumReclaim string) ([]evictionapi.Threshold, error) {
0000000000000000000000000000000000000000;;		results := []evictionapi.Threshold{}
0000000000000000000000000000000000000000;;		allocatableThresholds := getAllocatableThreshold(allocatableConfig)
0000000000000000000000000000000000000000;;		results = append(results, allocatableThresholds...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hardThresholds, err := parseThresholdStatements(evictionHard)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		results = append(results, hardThresholds...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		softThresholds, err := parseThresholdStatements(evictionSoft)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gracePeriods, err := parseGracePeriods(evictionSoftGracePeriod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		minReclaims, err := parseMinimumReclaims(evictionMinimumReclaim)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range softThresholds {
0000000000000000000000000000000000000000;;			signal := softThresholds[i].Signal
0000000000000000000000000000000000000000;;			period, found := gracePeriods[signal]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("grace period must be specified for the soft eviction threshold %v", signal)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			softThresholds[i].GracePeriod = period
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		results = append(results, softThresholds...)
0000000000000000000000000000000000000000;;		for i := range results {
0000000000000000000000000000000000000000;;			for signal, minReclaim := range minReclaims {
0000000000000000000000000000000000000000;;				if results[i].Signal == signal {
0000000000000000000000000000000000000000;;					results[i].MinReclaim = &minReclaim
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return results, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseThresholdStatements parses the input statements into a list of Threshold objects.
0000000000000000000000000000000000000000;;	func parseThresholdStatements(expr string) ([]evictionapi.Threshold, error) {
0000000000000000000000000000000000000000;;		if len(expr) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		results := []evictionapi.Threshold{}
0000000000000000000000000000000000000000;;		statements := strings.Split(expr, ",")
0000000000000000000000000000000000000000;;		signalsFound := sets.NewString()
0000000000000000000000000000000000000000;;		for _, statement := range statements {
0000000000000000000000000000000000000000;;			result, err := parseThresholdStatement(statement)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if signalsFound.Has(string(result.Signal)) {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("found duplicate eviction threshold for signal %v", result.Signal)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			signalsFound.Insert(string(result.Signal))
0000000000000000000000000000000000000000;;			results = append(results, result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return results, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseThresholdStatement parses a threshold statement.
0000000000000000000000000000000000000000;;	func parseThresholdStatement(statement string) (evictionapi.Threshold, error) {
0000000000000000000000000000000000000000;;		tokens2Operator := map[string]evictionapi.ThresholdOperator{
0000000000000000000000000000000000000000;;			"<": evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			operator evictionapi.ThresholdOperator
0000000000000000000000000000000000000000;;			parts    []string
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		for token := range tokens2Operator {
0000000000000000000000000000000000000000;;			parts = strings.Split(statement, token)
0000000000000000000000000000000000000000;;			// if we got a token, we know this was the operator...
0000000000000000000000000000000000000000;;			if len(parts) > 1 {
0000000000000000000000000000000000000000;;				operator = tokens2Operator[token]
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(operator) == 0 || len(parts) != 2 {
0000000000000000000000000000000000000000;;			return evictionapi.Threshold{}, fmt.Errorf("invalid eviction threshold syntax %v, expected <signal><operator><value>", statement)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		signal := evictionapi.Signal(parts[0])
0000000000000000000000000000000000000000;;		if !validSignal(signal) {
0000000000000000000000000000000000000000;;			return evictionapi.Threshold{}, fmt.Errorf(unsupportedEvictionSignal, signal)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		quantityValue := parts[1]
0000000000000000000000000000000000000000;;		if strings.HasSuffix(quantityValue, "%") {
0000000000000000000000000000000000000000;;			percentage, err := parsePercentage(quantityValue)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return evictionapi.Threshold{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if percentage <= 0 {
0000000000000000000000000000000000000000;;				return evictionapi.Threshold{}, fmt.Errorf("eviction percentage threshold %v must be positive: %s", signal, quantityValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return evictionapi.Threshold{
0000000000000000000000000000000000000000;;				Signal:   signal,
0000000000000000000000000000000000000000;;				Operator: operator,
0000000000000000000000000000000000000000;;				Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;					Percentage: percentage,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		quantity, err := resource.ParseQuantity(quantityValue)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return evictionapi.Threshold{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if quantity.Sign() < 0 || quantity.IsZero() {
0000000000000000000000000000000000000000;;			return evictionapi.Threshold{}, fmt.Errorf("eviction threshold %v must be positive: %s", signal, &quantity)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return evictionapi.Threshold{
0000000000000000000000000000000000000000;;			Signal:   signal,
0000000000000000000000000000000000000000;;			Operator: operator,
0000000000000000000000000000000000000000;;			Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;				Quantity: &quantity,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getAllocatableThreshold returns the thresholds applicable for the allocatable configuration
0000000000000000000000000000000000000000;;	func getAllocatableThreshold(allocatableConfig []string) []evictionapi.Threshold {
0000000000000000000000000000000000000000;;		for _, key := range allocatableConfig {
0000000000000000000000000000000000000000;;			if key == cm.NodeAllocatableEnforcementKey {
0000000000000000000000000000000000000000;;				return []evictionapi.Threshold{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Signal:   evictionapi.SignalAllocatableMemoryAvailable,
0000000000000000000000000000000000000000;;						Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;						Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: resource.NewQuantity(int64(0), resource.BinarySI),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: resource.NewQuantity(int64(0), resource.BinarySI),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Signal:   evictionapi.SignalAllocatableNodeFsAvailable,
0000000000000000000000000000000000000000;;						Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;						Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: resource.NewQuantity(int64(0), resource.BinarySI),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: resource.NewQuantity(int64(0), resource.BinarySI),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []evictionapi.Threshold{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parsePercentage parses a string representing a percentage value
0000000000000000000000000000000000000000;;	func parsePercentage(input string) (float32, error) {
0000000000000000000000000000000000000000;;		value, err := strconv.ParseFloat(strings.TrimRight(input, "%"), 32)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return float32(value) / 100, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseGracePeriods parses the grace period statements
0000000000000000000000000000000000000000;;	func parseGracePeriods(expr string) (map[evictionapi.Signal]time.Duration, error) {
0000000000000000000000000000000000000000;;		if len(expr) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		results := map[evictionapi.Signal]time.Duration{}
0000000000000000000000000000000000000000;;		statements := strings.Split(expr, ",")
0000000000000000000000000000000000000000;;		for _, statement := range statements {
0000000000000000000000000000000000000000;;			parts := strings.Split(statement, "=")
0000000000000000000000000000000000000000;;			if len(parts) != 2 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid eviction grace period syntax %v, expected <signal>=<duration>", statement)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			signal := evictionapi.Signal(parts[0])
0000000000000000000000000000000000000000;;			if !validSignal(signal) {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf(unsupportedEvictionSignal, signal)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			gracePeriod, err := time.ParseDuration(parts[1])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if gracePeriod < 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid eviction grace period specified: %v, must be a positive value", parts[1])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// check against duplicate statements
0000000000000000000000000000000000000000;;			if _, found := results[signal]; found {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("duplicate eviction grace period specified for %v", signal)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			results[signal] = gracePeriod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return results, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseMinimumReclaims parses the minimum reclaim statements
0000000000000000000000000000000000000000;;	func parseMinimumReclaims(expr string) (map[evictionapi.Signal]evictionapi.ThresholdValue, error) {
0000000000000000000000000000000000000000;;		if len(expr) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		results := map[evictionapi.Signal]evictionapi.ThresholdValue{}
0000000000000000000000000000000000000000;;		statements := strings.Split(expr, ",")
0000000000000000000000000000000000000000;;		for _, statement := range statements {
0000000000000000000000000000000000000000;;			parts := strings.Split(statement, "=")
0000000000000000000000000000000000000000;;			if len(parts) != 2 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid eviction minimum reclaim syntax: %v, expected <signal>=<value>", statement)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			signal := evictionapi.Signal(parts[0])
0000000000000000000000000000000000000000;;			if !validSignal(signal) {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf(unsupportedEvictionSignal, signal)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			quantityValue := parts[1]
0000000000000000000000000000000000000000;;			if strings.HasSuffix(quantityValue, "%") {
0000000000000000000000000000000000000000;;				percentage, err := parsePercentage(quantityValue)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if percentage <= 0 {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("eviction percentage minimum reclaim %v must be positive: %s", signal, quantityValue)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check against duplicate statements
0000000000000000000000000000000000000000;;				if _, found := results[signal]; found {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("duplicate eviction minimum reclaim specified for %v", signal)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				results[signal] = evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;					Percentage: percentage,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// check against duplicate statements
0000000000000000000000000000000000000000;;			if _, found := results[signal]; found {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("duplicate eviction minimum reclaim specified for %v", signal)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			quantity, err := resource.ParseQuantity(parts[1])
0000000000000000000000000000000000000000;;			if quantity.Sign() < 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("negative eviction minimum reclaim specified for %v", signal)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			results[signal] = evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;				Quantity: &quantity,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return results, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// diskUsage converts used bytes into a resource quantity.
0000000000000000000000000000000000000000;;	func diskUsage(fsStats *statsapi.FsStats) *resource.Quantity {
0000000000000000000000000000000000000000;;		if fsStats == nil || fsStats.UsedBytes == nil {
0000000000000000000000000000000000000000;;			return &resource.Quantity{Format: resource.BinarySI}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		usage := int64(*fsStats.UsedBytes)
0000000000000000000000000000000000000000;;		return resource.NewQuantity(usage, resource.BinarySI)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// inodeUsage converts inodes consumed into a resource quantity.
0000000000000000000000000000000000000000;;	func inodeUsage(fsStats *statsapi.FsStats) *resource.Quantity {
0000000000000000000000000000000000000000;;		if fsStats == nil || fsStats.InodesUsed == nil {
0000000000000000000000000000000000000000;;			return &resource.Quantity{Format: resource.BinarySI}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		usage := int64(*fsStats.InodesUsed)
0000000000000000000000000000000000000000;;		return resource.NewQuantity(usage, resource.BinarySI)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// memoryUsage converts working set into a resource quantity.
0000000000000000000000000000000000000000;;	func memoryUsage(memStats *statsapi.MemoryStats) *resource.Quantity {
0000000000000000000000000000000000000000;;		if memStats == nil || memStats.WorkingSetBytes == nil {
0000000000000000000000000000000000000000;;			return &resource.Quantity{Format: resource.BinarySI}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		usage := int64(*memStats.WorkingSetBytes)
0000000000000000000000000000000000000000;;		return resource.NewQuantity(usage, resource.BinarySI)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// localVolumeNames returns the set of volumes for the pod that are local
0000000000000000000000000000000000000000;;	// TODO: sumamry API should report what volumes consume local storage rather than hard-code here.
0000000000000000000000000000000000000000;;	func localVolumeNames(pod *v1.Pod) []string {
0000000000000000000000000000000000000000;;		result := []string{}
0000000000000000000000000000000000000000;;		for _, volume := range pod.Spec.Volumes {
0000000000000000000000000000000000000000;;			if volume.HostPath != nil ||
0000000000000000000000000000000000000000;;				(volume.EmptyDir != nil && volume.EmptyDir.Medium != v1.StorageMediumMemory) ||
0000000000000000000000000000000000000000;;				volume.ConfigMap != nil ||
0000000000000000000000000000000000000000;;				volume.GitRepo != nil {
0000000000000000000000000000000000000000;;				result = append(result, volume.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// podDiskUsage aggregates pod disk usage and inode consumption for the specified stats to measure.
0000000000000000000000000000000000000000;;	func podDiskUsage(podStats statsapi.PodStats, pod *v1.Pod, statsToMeasure []fsStatsType) (v1.ResourceList, error) {
0000000000000000000000000000000000000000;;		disk := resource.Quantity{Format: resource.BinarySI}
0000000000000000000000000000000000000000;;		inodes := resource.Quantity{Format: resource.BinarySI}
0000000000000000000000000000000000000000;;		overlay := resource.Quantity{Format: resource.BinarySI}
0000000000000000000000000000000000000000;;		for _, container := range podStats.Containers {
0000000000000000000000000000000000000000;;			if hasFsStatsType(statsToMeasure, fsStatsRoot) {
0000000000000000000000000000000000000000;;				disk.Add(*diskUsage(container.Rootfs))
0000000000000000000000000000000000000000;;				inodes.Add(*inodeUsage(container.Rootfs))
0000000000000000000000000000000000000000;;				overlay.Add(*diskUsage(container.Rootfs))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hasFsStatsType(statsToMeasure, fsStatsLogs) {
0000000000000000000000000000000000000000;;				disk.Add(*diskUsage(container.Logs))
0000000000000000000000000000000000000000;;				inodes.Add(*inodeUsage(container.Logs))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasFsStatsType(statsToMeasure, fsStatsLocalVolumeSource) {
0000000000000000000000000000000000000000;;			volumeNames := localVolumeNames(pod)
0000000000000000000000000000000000000000;;			for _, volumeName := range volumeNames {
0000000000000000000000000000000000000000;;				for _, volumeStats := range podStats.VolumeStats {
0000000000000000000000000000000000000000;;					if volumeStats.Name == volumeName {
0000000000000000000000000000000000000000;;						disk.Add(*diskUsage(&volumeStats.FsStats))
0000000000000000000000000000000000000000;;						inodes.Add(*inodeUsage(&volumeStats.FsStats))
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v1.ResourceList{
0000000000000000000000000000000000000000;;			resourceDisk:    disk,
0000000000000000000000000000000000000000;;			resourceInodes:  inodes,
0000000000000000000000000000000000000000;;			resourceOverlay: overlay,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// podMemoryUsage aggregates pod memory usage.
0000000000000000000000000000000000000000;;	func podMemoryUsage(podStats statsapi.PodStats) (v1.ResourceList, error) {
0000000000000000000000000000000000000000;;		disk := resource.Quantity{Format: resource.BinarySI}
0000000000000000000000000000000000000000;;		memory := resource.Quantity{Format: resource.BinarySI}
0000000000000000000000000000000000000000;;		for _, container := range podStats.Containers {
0000000000000000000000000000000000000000;;			// disk usage (if known)
0000000000000000000000000000000000000000;;			for _, fsStats := range []*statsapi.FsStats{container.Rootfs, container.Logs} {
0000000000000000000000000000000000000000;;				disk.Add(*diskUsage(fsStats))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// memory usage (if known)
0000000000000000000000000000000000000000;;			memory.Add(*memoryUsage(container.Memory))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v1.ResourceList{
0000000000000000000000000000000000000000;;			v1.ResourceMemory: memory,
0000000000000000000000000000000000000000;;			resourceDisk:      disk,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// formatThreshold formats a threshold for logging.
0000000000000000000000000000000000000000;;	func formatThreshold(threshold evictionapi.Threshold) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("threshold(signal=%v, operator=%v, value=%v, gracePeriod=%v)", threshold.Signal, threshold.Operator, evictionapi.ThresholdValue(threshold.Value), threshold.GracePeriod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// formatevictionapi.ThresholdValue formats a thresholdValue for logging.
0000000000000000000000000000000000000000;;	func formatThresholdValue(value evictionapi.ThresholdValue) string {
0000000000000000000000000000000000000000;;		if value.Quantity != nil {
0000000000000000000000000000000000000000;;			return value.Quantity.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%f%%", value.Percentage*float32(100))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cachedStatsFunc returns a statsFunc based on the provided pod stats.
0000000000000000000000000000000000000000;;	func cachedStatsFunc(podStats []statsapi.PodStats) statsFunc {
0000000000000000000000000000000000000000;;		uid2PodStats := map[string]statsapi.PodStats{}
0000000000000000000000000000000000000000;;		for i := range podStats {
0000000000000000000000000000000000000000;;			uid2PodStats[podStats[i].PodRef.UID] = podStats[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return func(pod *v1.Pod) (statsapi.PodStats, bool) {
0000000000000000000000000000000000000000;;			stats, found := uid2PodStats[string(pod.UID)]
0000000000000000000000000000000000000000;;			return stats, found
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cmp compares p1 and p2 and returns:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   -1 if p1 <  p2
0000000000000000000000000000000000000000;;	//    0 if p1 == p2
0000000000000000000000000000000000000000;;	//   +1 if p1 >  p2
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	type cmpFunc func(p1, p2 *v1.Pod) int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// multiSorter implements the Sort interface, sorting changes within.
0000000000000000000000000000000000000000;;	type multiSorter struct {
0000000000000000000000000000000000000000;;		pods []*v1.Pod
0000000000000000000000000000000000000000;;		cmp  []cmpFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sort sorts the argument slice according to the less functions passed to OrderedBy.
0000000000000000000000000000000000000000;;	func (ms *multiSorter) Sort(pods []*v1.Pod) {
0000000000000000000000000000000000000000;;		ms.pods = pods
0000000000000000000000000000000000000000;;		sort.Sort(ms)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OrderedBy returns a Sorter that sorts using the cmp functions, in order.
0000000000000000000000000000000000000000;;	// Call its Sort method to sort the data.
0000000000000000000000000000000000000000;;	func orderedBy(cmp ...cmpFunc) *multiSorter {
0000000000000000000000000000000000000000;;		return &multiSorter{
0000000000000000000000000000000000000000;;			cmp: cmp,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len is part of sort.Interface.
0000000000000000000000000000000000000000;;	func (ms *multiSorter) Len() int {
0000000000000000000000000000000000000000;;		return len(ms.pods)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Swap is part of sort.Interface.
0000000000000000000000000000000000000000;;	func (ms *multiSorter) Swap(i, j int) {
0000000000000000000000000000000000000000;;		ms.pods[i], ms.pods[j] = ms.pods[j], ms.pods[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Less is part of sort.Interface.
0000000000000000000000000000000000000000;;	func (ms *multiSorter) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		p1, p2 := ms.pods[i], ms.pods[j]
0000000000000000000000000000000000000000;;		var k int
0000000000000000000000000000000000000000;;		for k = 0; k < len(ms.cmp)-1; k++ {
0000000000000000000000000000000000000000;;			cmpResult := ms.cmp[k](p1, p2)
0000000000000000000000000000000000000000;;			// p1 is less than p2
0000000000000000000000000000000000000000;;			if cmpResult < 0 {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// p1 is greater than p2
0000000000000000000000000000000000000000;;			if cmpResult > 0 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// we don't know yet
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// the last cmp func is the final decider
0000000000000000000000000000000000000000;;		return ms.cmp[k](p1, p2) < 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// qosComparator compares pods by QoS (BestEffort < Burstable < Guaranteed)
0000000000000000000000000000000000000000;;	func qosComparator(p1, p2 *v1.Pod) int {
0000000000000000000000000000000000000000;;		qosP1 := v1qos.GetPodQOS(p1)
0000000000000000000000000000000000000000;;		qosP2 := v1qos.GetPodQOS(p2)
0000000000000000000000000000000000000000;;		// its a tie
0000000000000000000000000000000000000000;;		if qosP1 == qosP2 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if p1 is best effort, we know p2 is burstable or guaranteed
0000000000000000000000000000000000000000;;		if qosP1 == v1.PodQOSBestEffort {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// we know p1 and p2 are not besteffort, so if p1 is burstable, p2 must be guaranteed
0000000000000000000000000000000000000000;;		if qosP1 == v1.PodQOSBurstable {
0000000000000000000000000000000000000000;;			if qosP2 == v1.PodQOSGuaranteed {
0000000000000000000000000000000000000000;;				return -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// ok, p1 must be guaranteed.
0000000000000000000000000000000000000000;;		return 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// memory compares pods by largest consumer of memory relative to request.
0000000000000000000000000000000000000000;;	func memory(stats statsFunc) cmpFunc {
0000000000000000000000000000000000000000;;		return func(p1, p2 *v1.Pod) int {
0000000000000000000000000000000000000000;;			p1Stats, found := stats(p1)
0000000000000000000000000000000000000000;;			// if we have no usage stats for p1, we want p2 first
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if we have no usage stats for p2, but p1 has usage, we want p1 first.
0000000000000000000000000000000000000000;;			p2Stats, found := stats(p2)
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if we cant get usage for p1 measured, we want p2 first
0000000000000000000000000000000000000000;;			p1Usage, err := podMemoryUsage(p1Stats)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if we cant get usage for p2 measured, we want p1 first
0000000000000000000000000000000000000000;;			p2Usage, err := podMemoryUsage(p2Stats)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// adjust p1, p2 usage relative to the request (if any)
0000000000000000000000000000000000000000;;			p1Memory := p1Usage[v1.ResourceMemory]
0000000000000000000000000000000000000000;;			p1Spec, err := core.PodUsageFunc(p1)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p1Request := p1Spec[api.ResourceRequestsMemory]
0000000000000000000000000000000000000000;;			p1Memory.Sub(p1Request)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			p2Memory := p2Usage[v1.ResourceMemory]
0000000000000000000000000000000000000000;;			p2Spec, err := core.PodUsageFunc(p2)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p2Request := p2Spec[api.ResourceRequestsMemory]
0000000000000000000000000000000000000000;;			p2Memory.Sub(p2Request)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if p2 is using more than p1, we want p2 first
0000000000000000000000000000000000000000;;			return p2Memory.Cmp(p1Memory)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// disk compares pods by largest consumer of disk relative to request for the specified disk resource.
0000000000000000000000000000000000000000;;	func disk(stats statsFunc, fsStatsToMeasure []fsStatsType, diskResource v1.ResourceName) cmpFunc {
0000000000000000000000000000000000000000;;		return func(p1, p2 *v1.Pod) int {
0000000000000000000000000000000000000000;;			p1Stats, found := stats(p1)
0000000000000000000000000000000000000000;;			// if we have no usage stats for p1, we want p2 first
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if we have no usage stats for p2, but p1 has usage, we want p1 first.
0000000000000000000000000000000000000000;;			p2Stats, found := stats(p2)
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if we cant get usage for p1 measured, we want p2 first
0000000000000000000000000000000000000000;;			p1Usage, err := podDiskUsage(p1Stats, p1, fsStatsToMeasure)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if we cant get usage for p2 measured, we want p1 first
0000000000000000000000000000000000000000;;			p2Usage, err := podDiskUsage(p2Stats, p2, fsStatsToMeasure)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// disk is best effort, so we don't measure relative to a request.
0000000000000000000000000000000000000000;;			// TODO: add disk as a guaranteed resource
0000000000000000000000000000000000000000;;			p1Disk := p1Usage[diskResource]
0000000000000000000000000000000000000000;;			p2Disk := p2Usage[diskResource]
0000000000000000000000000000000000000000;;			// if p2 is using more than p1, we want p2 first
0000000000000000000000000000000000000000;;			return p2Disk.Cmp(p1Disk)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rankMemoryPressure orders the input pods for eviction in response to memory pressure.
0000000000000000000000000000000000000000;;	func rankMemoryPressure(pods []*v1.Pod, stats statsFunc) {
0000000000000000000000000000000000000000;;		orderedBy(qosComparator, memory(stats)).Sort(pods)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rankDiskPressureFunc returns a rankFunc that measures the specified fs stats.
0000000000000000000000000000000000000000;;	func rankDiskPressureFunc(fsStatsToMeasure []fsStatsType, diskResource v1.ResourceName) rankFunc {
0000000000000000000000000000000000000000;;		return func(pods []*v1.Pod, stats statsFunc) {
0000000000000000000000000000000000000000;;			orderedBy(qosComparator, disk(stats, fsStatsToMeasure, diskResource)).Sort(pods)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// byEvictionPriority implements sort.Interface for []v1.ResourceName.
0000000000000000000000000000000000000000;;	type byEvictionPriority []v1.ResourceName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a byEvictionPriority) Len() int      { return len(a) }
0000000000000000000000000000000000000000;;	func (a byEvictionPriority) Swap(i, j int) { a[i], a[j] = a[j], a[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Less ranks memory before all other resources.
0000000000000000000000000000000000000000;;	func (a byEvictionPriority) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return a[i] == v1.ResourceMemory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeSignalObservations derives observations using the specified summary provider.
0000000000000000000000000000000000000000;;	func makeSignalObservations(summaryProvider stats.SummaryProvider, nodeProvider NodeProvider, pods []*v1.Pod, withImageFs bool) (signalObservations, statsFunc, error) {
0000000000000000000000000000000000000000;;		summary, err := summaryProvider.Get()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		node, err := nodeProvider.GetNode()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// build the function to work against for pod stats
0000000000000000000000000000000000000000;;		statsFunc := cachedStatsFunc(summary.Pods)
0000000000000000000000000000000000000000;;		// build an evaluation context for current eviction signals
0000000000000000000000000000000000000000;;		result := signalObservations{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if memory := summary.Node.Memory; memory != nil && memory.AvailableBytes != nil && memory.WorkingSetBytes != nil {
0000000000000000000000000000000000000000;;			result[evictionapi.SignalMemoryAvailable] = signalObservation{
0000000000000000000000000000000000000000;;				available: resource.NewQuantity(int64(*memory.AvailableBytes), resource.BinarySI),
0000000000000000000000000000000000000000;;				capacity:  resource.NewQuantity(int64(*memory.AvailableBytes+*memory.WorkingSetBytes), resource.BinarySI),
0000000000000000000000000000000000000000;;				time:      memory.Time,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if nodeFs := summary.Node.Fs; nodeFs != nil {
0000000000000000000000000000000000000000;;			if nodeFs.AvailableBytes != nil && nodeFs.CapacityBytes != nil {
0000000000000000000000000000000000000000;;				result[evictionapi.SignalNodeFsAvailable] = signalObservation{
0000000000000000000000000000000000000000;;					available: resource.NewQuantity(int64(*nodeFs.AvailableBytes), resource.BinarySI),
0000000000000000000000000000000000000000;;					capacity:  resource.NewQuantity(int64(*nodeFs.CapacityBytes), resource.BinarySI),
0000000000000000000000000000000000000000;;					time:      nodeFs.Time,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if nodeFs.InodesFree != nil && nodeFs.Inodes != nil {
0000000000000000000000000000000000000000;;				result[evictionapi.SignalNodeFsInodesFree] = signalObservation{
0000000000000000000000000000000000000000;;					available: resource.NewQuantity(int64(*nodeFs.InodesFree), resource.BinarySI),
0000000000000000000000000000000000000000;;					capacity:  resource.NewQuantity(int64(*nodeFs.Inodes), resource.BinarySI),
0000000000000000000000000000000000000000;;					time:      nodeFs.Time,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if summary.Node.Runtime != nil {
0000000000000000000000000000000000000000;;			if imageFs := summary.Node.Runtime.ImageFs; imageFs != nil {
0000000000000000000000000000000000000000;;				if imageFs.AvailableBytes != nil && imageFs.CapacityBytes != nil {
0000000000000000000000000000000000000000;;					result[evictionapi.SignalImageFsAvailable] = signalObservation{
0000000000000000000000000000000000000000;;						available: resource.NewQuantity(int64(*imageFs.AvailableBytes), resource.BinarySI),
0000000000000000000000000000000000000000;;						capacity:  resource.NewQuantity(int64(*imageFs.CapacityBytes), resource.BinarySI),
0000000000000000000000000000000000000000;;						time:      imageFs.Time,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if imageFs.InodesFree != nil && imageFs.Inodes != nil {
0000000000000000000000000000000000000000;;						result[evictionapi.SignalImageFsInodesFree] = signalObservation{
0000000000000000000000000000000000000000;;							available: resource.NewQuantity(int64(*imageFs.InodesFree), resource.BinarySI),
0000000000000000000000000000000000000000;;							capacity:  resource.NewQuantity(int64(*imageFs.Inodes), resource.BinarySI),
0000000000000000000000000000000000000000;;							time:      imageFs.Time,
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if memoryAllocatableCapacity, ok := node.Status.Allocatable[v1.ResourceMemory]; ok {
0000000000000000000000000000000000000000;;			memoryAllocatableAvailable := memoryAllocatableCapacity.Copy()
0000000000000000000000000000000000000000;;			for _, pod := range summary.Pods {
0000000000000000000000000000000000000000;;				mu, err := podMemoryUsage(pod)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					memoryAllocatableAvailable.Sub(mu[v1.ResourceMemory])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result[evictionapi.SignalAllocatableMemoryAvailable] = signalObservation{
0000000000000000000000000000000000000000;;				available: memoryAllocatableAvailable,
0000000000000000000000000000000000000000;;				capacity:  memoryAllocatableCapacity.Copy(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if storageScratchAllocatableCapacity, ok := node.Status.Allocatable[v1.ResourceStorage]; ok {
0000000000000000000000000000000000000000;;			storageScratchAllocatable := storageScratchAllocatableCapacity.Copy()
0000000000000000000000000000000000000000;;			for _, pod := range pods {
0000000000000000000000000000000000000000;;				podStat, ok := statsFunc(pod)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				usage, err := podDiskUsage(podStat, pod, []fsStatsType{fsStatsLogs, fsStatsLocalVolumeSource, fsStatsRoot})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Warningf("eviction manager: error getting pod disk usage %v", err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// If there is a seperate imagefs set up for container runtimes, the scratch disk usage from nodefs should exclude the overlay usage
0000000000000000000000000000000000000000;;				if withImageFs {
0000000000000000000000000000000000000000;;					diskUsage := usage[resourceDisk]
0000000000000000000000000000000000000000;;					diskUsageP := &diskUsage
0000000000000000000000000000000000000000;;					diskUsagep := diskUsageP.Copy()
0000000000000000000000000000000000000000;;					diskUsagep.Sub(usage[resourceOverlay])
0000000000000000000000000000000000000000;;					storageScratchAllocatable.Sub(*diskUsagep)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					storageScratchAllocatable.Sub(usage[resourceDisk])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result[evictionapi.SignalAllocatableNodeFsAvailable] = signalObservation{
0000000000000000000000000000000000000000;;				available: storageScratchAllocatable,
0000000000000000000000000000000000000000;;				capacity:  storageScratchAllocatableCapacity.Copy(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result, statsFunc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// thresholdsMet returns the set of thresholds that were met independent of grace period
0000000000000000000000000000000000000000;;	func thresholdsMet(thresholds []evictionapi.Threshold, observations signalObservations, enforceMinReclaim bool) []evictionapi.Threshold {
0000000000000000000000000000000000000000;;		results := []evictionapi.Threshold{}
0000000000000000000000000000000000000000;;		for i := range thresholds {
0000000000000000000000000000000000000000;;			threshold := thresholds[i]
0000000000000000000000000000000000000000;;			observed, found := observations[threshold.Signal]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				glog.Warningf("eviction manager: no observation found for eviction signal %v", threshold.Signal)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// determine if we have met the specified threshold
0000000000000000000000000000000000000000;;			thresholdMet := false
0000000000000000000000000000000000000000;;			quantity := evictionapi.GetThresholdQuantity(threshold.Value, observed.capacity)
0000000000000000000000000000000000000000;;			// if enforceMinReclaim is specified, we compare relative to value - minreclaim
0000000000000000000000000000000000000000;;			if enforceMinReclaim && threshold.MinReclaim != nil {
0000000000000000000000000000000000000000;;				quantity.Add(*evictionapi.GetThresholdQuantity(*threshold.MinReclaim, observed.capacity))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			thresholdResult := quantity.Cmp(*observed.available)
0000000000000000000000000000000000000000;;			switch threshold.Operator {
0000000000000000000000000000000000000000;;			case evictionapi.OpLessThan:
0000000000000000000000000000000000000000;;				thresholdMet = thresholdResult > 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if thresholdMet {
0000000000000000000000000000000000000000;;				results = append(results, threshold)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return results
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func debugLogObservations(logPrefix string, observations signalObservations) {
0000000000000000000000000000000000000000;;		if !glog.V(3) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range observations {
0000000000000000000000000000000000000000;;			if !v.time.IsZero() {
0000000000000000000000000000000000000000;;				glog.Infof("eviction manager: %v: signal=%v, available: %v, capacity: %v, time: %v", logPrefix, k, v.available, v.capacity, v.time)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Infof("eviction manager: %v: signal=%v, available: %v, capacity: %v", logPrefix, k, v.available, v.capacity)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func debugLogThresholdsWithObservation(logPrefix string, thresholds []evictionapi.Threshold, observations signalObservations) {
0000000000000000000000000000000000000000;;		if !glog.V(3) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range thresholds {
0000000000000000000000000000000000000000;;			threshold := thresholds[i]
0000000000000000000000000000000000000000;;			observed, found := observations[threshold.Signal]
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				quantity := evictionapi.GetThresholdQuantity(threshold.Value, observed.capacity)
0000000000000000000000000000000000000000;;				glog.Infof("eviction manager: %v: threshold [signal=%v, quantity=%v] observed %v", logPrefix, threshold.Signal, quantity, observed.available)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Infof("eviction manager: %v: threshold [signal=%v] had no observation", logPrefix, threshold.Signal)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func thresholdsUpdatedStats(thresholds []evictionapi.Threshold, observations, lastObservations signalObservations) []evictionapi.Threshold {
0000000000000000000000000000000000000000;;		results := []evictionapi.Threshold{}
0000000000000000000000000000000000000000;;		for i := range thresholds {
0000000000000000000000000000000000000000;;			threshold := thresholds[i]
0000000000000000000000000000000000000000;;			observed, found := observations[threshold.Signal]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				glog.Warningf("eviction manager: no observation found for eviction signal %v", threshold.Signal)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			last, found := lastObservations[threshold.Signal]
0000000000000000000000000000000000000000;;			if !found || observed.time.IsZero() || observed.time.After(last.time.Time) {
0000000000000000000000000000000000000000;;				results = append(results, threshold)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return results
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// thresholdsFirstObservedAt merges the input set of thresholds with the previous observation to determine when active set of thresholds were initially met.
0000000000000000000000000000000000000000;;	func thresholdsFirstObservedAt(thresholds []evictionapi.Threshold, lastObservedAt thresholdsObservedAt, now time.Time) thresholdsObservedAt {
0000000000000000000000000000000000000000;;		results := thresholdsObservedAt{}
0000000000000000000000000000000000000000;;		for i := range thresholds {
0000000000000000000000000000000000000000;;			observedAt, found := lastObservedAt[thresholds[i]]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				observedAt = now
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			results[thresholds[i]] = observedAt
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return results
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// thresholdsMetGracePeriod returns the set of thresholds that have satisfied associated grace period
0000000000000000000000000000000000000000;;	func thresholdsMetGracePeriod(observedAt thresholdsObservedAt, now time.Time) []evictionapi.Threshold {
0000000000000000000000000000000000000000;;		results := []evictionapi.Threshold{}
0000000000000000000000000000000000000000;;		for threshold, at := range observedAt {
0000000000000000000000000000000000000000;;			duration := now.Sub(at)
0000000000000000000000000000000000000000;;			if duration < threshold.GracePeriod {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("eviction manager: eviction criteria not yet met for %v, duration: %v", formatThreshold(threshold), duration)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			results = append(results, threshold)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return results
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nodeConditions returns the set of node conditions associated with a threshold
0000000000000000000000000000000000000000;;	func nodeConditions(thresholds []evictionapi.Threshold) []v1.NodeConditionType {
0000000000000000000000000000000000000000;;		results := []v1.NodeConditionType{}
0000000000000000000000000000000000000000;;		for _, threshold := range thresholds {
0000000000000000000000000000000000000000;;			if nodeCondition, found := signalToNodeCondition[threshold.Signal]; found {
0000000000000000000000000000000000000000;;				if !hasNodeCondition(results, nodeCondition) {
0000000000000000000000000000000000000000;;					results = append(results, nodeCondition)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return results
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nodeConditionsLastObservedAt merges the input with the previous observation to determine when a condition was most recently met.
0000000000000000000000000000000000000000;;	func nodeConditionsLastObservedAt(nodeConditions []v1.NodeConditionType, lastObservedAt nodeConditionsObservedAt, now time.Time) nodeConditionsObservedAt {
0000000000000000000000000000000000000000;;		results := nodeConditionsObservedAt{}
0000000000000000000000000000000000000000;;		// the input conditions were observed "now"
0000000000000000000000000000000000000000;;		for i := range nodeConditions {
0000000000000000000000000000000000000000;;			results[nodeConditions[i]] = now
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// the conditions that were not observed now are merged in with their old time
0000000000000000000000000000000000000000;;		for key, value := range lastObservedAt {
0000000000000000000000000000000000000000;;			_, found := results[key]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				results[key] = value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return results
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nodeConditionsObservedSince returns the set of conditions that have been observed within the specified period
0000000000000000000000000000000000000000;;	func nodeConditionsObservedSince(observedAt nodeConditionsObservedAt, period time.Duration, now time.Time) []v1.NodeConditionType {
0000000000000000000000000000000000000000;;		results := []v1.NodeConditionType{}
0000000000000000000000000000000000000000;;		for nodeCondition, at := range observedAt {
0000000000000000000000000000000000000000;;			duration := now.Sub(at)
0000000000000000000000000000000000000000;;			if duration < period {
0000000000000000000000000000000000000000;;				results = append(results, nodeCondition)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return results
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hasFsStatsType returns true if the fsStat is in the input list
0000000000000000000000000000000000000000;;	func hasFsStatsType(inputs []fsStatsType, item fsStatsType) bool {
0000000000000000000000000000000000000000;;		for _, input := range inputs {
0000000000000000000000000000000000000000;;			if input == item {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hasNodeCondition returns true if the node condition is in the input list
0000000000000000000000000000000000000000;;	func hasNodeCondition(inputs []v1.NodeConditionType, item v1.NodeConditionType) bool {
0000000000000000000000000000000000000000;;		for _, input := range inputs {
0000000000000000000000000000000000000000;;			if input == item {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mergeThresholds will merge both threshold lists eliminating duplicates.
0000000000000000000000000000000000000000;;	func mergeThresholds(inputsA []evictionapi.Threshold, inputsB []evictionapi.Threshold) []evictionapi.Threshold {
0000000000000000000000000000000000000000;;		results := inputsA
0000000000000000000000000000000000000000;;		for _, threshold := range inputsB {
0000000000000000000000000000000000000000;;			if !hasThreshold(results, threshold) {
0000000000000000000000000000000000000000;;				results = append(results, threshold)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return results
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hasThreshold returns true if the threshold is in the input list
0000000000000000000000000000000000000000;;	func hasThreshold(inputs []evictionapi.Threshold, item evictionapi.Threshold) bool {
0000000000000000000000000000000000000000;;		for _, input := range inputs {
0000000000000000000000000000000000000000;;			if input.GracePeriod == item.GracePeriod && input.Operator == item.Operator && input.Signal == item.Signal && compareThresholdValue(input.Value, item.Value) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// compareThresholdValue returns true if the two thresholdValue objects are logically the same
0000000000000000000000000000000000000000;;	func compareThresholdValue(a evictionapi.ThresholdValue, b evictionapi.ThresholdValue) bool {
0000000000000000000000000000000000000000;;		if a.Quantity != nil {
0000000000000000000000000000000000000000;;			if b.Quantity == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return a.Quantity.Cmp(*b.Quantity) == 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b.Quantity != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a.Percentage == b.Percentage
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getStarvedResources returns the set of resources that are starved based on thresholds met.
0000000000000000000000000000000000000000;;	func getStarvedResources(thresholds []evictionapi.Threshold) []v1.ResourceName {
0000000000000000000000000000000000000000;;		results := []v1.ResourceName{}
0000000000000000000000000000000000000000;;		for _, threshold := range thresholds {
0000000000000000000000000000000000000000;;			if starvedResource, found := signalToResource[threshold.Signal]; found {
0000000000000000000000000000000000000000;;				results = append(results, starvedResource)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return results
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isSoftEviction returns true if the thresholds met for the starved resource are only soft thresholds
0000000000000000000000000000000000000000;;	func isSoftEvictionThresholds(thresholds []evictionapi.Threshold, starvedResource v1.ResourceName) bool {
0000000000000000000000000000000000000000;;		for _, threshold := range thresholds {
0000000000000000000000000000000000000000;;			if resourceToCheck := signalToResource[threshold.Signal]; resourceToCheck != starvedResource {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isHardEvictionThreshold(threshold) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isHardEvictionThreshold returns true if eviction should immediately occur
0000000000000000000000000000000000000000;;	func isHardEvictionThreshold(threshold evictionapi.Threshold) bool {
0000000000000000000000000000000000000000;;		return threshold.GracePeriod == time.Duration(0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildResourceToRankFunc returns ranking functions associated with resources
0000000000000000000000000000000000000000;;	func buildResourceToRankFunc(withImageFs bool) map[v1.ResourceName]rankFunc {
0000000000000000000000000000000000000000;;		resourceToRankFunc := map[v1.ResourceName]rankFunc{
0000000000000000000000000000000000000000;;			v1.ResourceMemory: rankMemoryPressure,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// usage of an imagefs is optional
0000000000000000000000000000000000000000;;		if withImageFs {
0000000000000000000000000000000000000000;;			// with an imagefs, nodefs pod rank func for eviction only includes logs and local volumes
0000000000000000000000000000000000000000;;			resourceToRankFunc[resourceNodeFs] = rankDiskPressureFunc([]fsStatsType{fsStatsLogs, fsStatsLocalVolumeSource}, resourceDisk)
0000000000000000000000000000000000000000;;			resourceToRankFunc[resourceNodeFsInodes] = rankDiskPressureFunc([]fsStatsType{fsStatsLogs, fsStatsLocalVolumeSource}, resourceInodes)
0000000000000000000000000000000000000000;;			// with an imagefs, imagefs pod rank func for eviction only includes rootfs
0000000000000000000000000000000000000000;;			resourceToRankFunc[resourceImageFs] = rankDiskPressureFunc([]fsStatsType{fsStatsRoot}, resourceDisk)
0000000000000000000000000000000000000000;;			resourceToRankFunc[resourceImageFsInodes] = rankDiskPressureFunc([]fsStatsType{fsStatsRoot}, resourceInodes)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// without an imagefs, nodefs pod rank func for eviction looks at all fs stats.
0000000000000000000000000000000000000000;;			// since imagefs and nodefs share a common device, they share common ranking functions.
0000000000000000000000000000000000000000;;			resourceToRankFunc[resourceNodeFs] = rankDiskPressureFunc([]fsStatsType{fsStatsRoot, fsStatsLogs, fsStatsLocalVolumeSource}, resourceDisk)
0000000000000000000000000000000000000000;;			resourceToRankFunc[resourceNodeFsInodes] = rankDiskPressureFunc([]fsStatsType{fsStatsRoot, fsStatsLogs, fsStatsLocalVolumeSource}, resourceInodes)
0000000000000000000000000000000000000000;;			resourceToRankFunc[resourceImageFs] = rankDiskPressureFunc([]fsStatsType{fsStatsRoot, fsStatsLogs, fsStatsLocalVolumeSource}, resourceDisk)
0000000000000000000000000000000000000000;;			resourceToRankFunc[resourceImageFsInodes] = rankDiskPressureFunc([]fsStatsType{fsStatsRoot, fsStatsLogs, fsStatsLocalVolumeSource}, resourceInodes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resourceToRankFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodIsEvicted returns true if the reported pod status is due to an eviction.
0000000000000000000000000000000000000000;;	func PodIsEvicted(podStatus v1.PodStatus) bool {
0000000000000000000000000000000000000000;;		return podStatus.Phase == v1.PodFailed && podStatus.Reason == reason
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildResourceToNodeReclaimFuncs returns reclaim functions associated with resources.
0000000000000000000000000000000000000000;;	func buildResourceToNodeReclaimFuncs(imageGC ImageGC, containerGC ContainerGC, withImageFs bool) map[v1.ResourceName]nodeReclaimFuncs {
0000000000000000000000000000000000000000;;		resourceToReclaimFunc := map[v1.ResourceName]nodeReclaimFuncs{}
0000000000000000000000000000000000000000;;		// usage of an imagefs is optional
0000000000000000000000000000000000000000;;		if withImageFs {
0000000000000000000000000000000000000000;;			// with an imagefs, nodefs pressure should just delete logs
0000000000000000000000000000000000000000;;			resourceToReclaimFunc[resourceNodeFs] = nodeReclaimFuncs{}
0000000000000000000000000000000000000000;;			resourceToReclaimFunc[resourceNodeFsInodes] = nodeReclaimFuncs{}
0000000000000000000000000000000000000000;;			// with an imagefs, imagefs pressure should delete unused images
0000000000000000000000000000000000000000;;			resourceToReclaimFunc[resourceImageFs] = nodeReclaimFuncs{deleteTerminatedContainers(containerGC), deleteImages(imageGC, true)}
0000000000000000000000000000000000000000;;			resourceToReclaimFunc[resourceImageFsInodes] = nodeReclaimFuncs{deleteTerminatedContainers(containerGC), deleteImages(imageGC, false)}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// without an imagefs, nodefs pressure should delete logs, and unused images
0000000000000000000000000000000000000000;;			// since imagefs and nodefs share a common device, they share common reclaim functions
0000000000000000000000000000000000000000;;			resourceToReclaimFunc[resourceNodeFs] = nodeReclaimFuncs{deleteTerminatedContainers(containerGC), deleteImages(imageGC, true)}
0000000000000000000000000000000000000000;;			resourceToReclaimFunc[resourceNodeFsInodes] = nodeReclaimFuncs{deleteTerminatedContainers(containerGC), deleteImages(imageGC, false)}
0000000000000000000000000000000000000000;;			resourceToReclaimFunc[resourceImageFs] = nodeReclaimFuncs{deleteTerminatedContainers(containerGC), deleteImages(imageGC, true)}
0000000000000000000000000000000000000000;;			resourceToReclaimFunc[resourceImageFsInodes] = nodeReclaimFuncs{deleteTerminatedContainers(containerGC), deleteImages(imageGC, false)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resourceToReclaimFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteTerminatedContainers will delete terminated containers to free up disk pressure.
0000000000000000000000000000000000000000;;	func deleteTerminatedContainers(containerGC ContainerGC) nodeReclaimFunc {
0000000000000000000000000000000000000000;;		return func() (*resource.Quantity, error) {
0000000000000000000000000000000000000000;;			glog.Infof("eviction manager: attempting to delete unused containers")
0000000000000000000000000000000000000000;;			err := containerGC.DeleteAllUnusedContainers()
0000000000000000000000000000000000000000;;			// Calculating bytes freed is not yet supported.
0000000000000000000000000000000000000000;;			return resource.NewQuantity(int64(0), resource.BinarySI), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteImages will delete unused images to free up disk pressure.
0000000000000000000000000000000000000000;;	func deleteImages(imageGC ImageGC, reportBytesFreed bool) nodeReclaimFunc {
0000000000000000000000000000000000000000;;		return func() (*resource.Quantity, error) {
0000000000000000000000000000000000000000;;			glog.Infof("eviction manager: attempting to delete unused images")
0000000000000000000000000000000000000000;;			bytesFreed, err := imageGC.DeleteUnusedImages()
0000000000000000000000000000000000000000;;			reclaimed := int64(0)
0000000000000000000000000000000000000000;;			if reportBytesFreed {
0000000000000000000000000000000000000000;;				reclaimed = bytesFreed
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return resource.NewQuantity(reclaimed, resource.BinarySI), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
