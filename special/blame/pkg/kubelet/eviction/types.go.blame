0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
20e2419ee209ff5ea436a2241a59408045607edc;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package eviction
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		statsapi "k8s.io/kubernetes/pkg/kubelet/apis/stats/v1alpha1"
0000000000000000000000000000000000000000;;		evictionapi "k8s.io/kubernetes/pkg/kubelet/eviction/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fsStatsType defines the types of filesystem stats to collect.
0000000000000000000000000000000000000000;;	type fsStatsType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// fsStatsLocalVolumeSource identifies stats for pod local volume sources.
0000000000000000000000000000000000000000;;		fsStatsLocalVolumeSource fsStatsType = "localVolumeSource"
0000000000000000000000000000000000000000;;		// fsStatsLogs identifies stats for pod logs.
0000000000000000000000000000000000000000;;		fsStatsLogs fsStatsType = "logs"
0000000000000000000000000000000000000000;;		// fsStatsRoot identifies stats for pod container writable layers.
0000000000000000000000000000000000000000;;		fsStatsRoot fsStatsType = "root"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config holds information about how eviction is configured.
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		// PressureTransitionPeriod is duration the kubelet has to wait before transititioning out of a pressure condition.
0000000000000000000000000000000000000000;;		PressureTransitionPeriod time.Duration
0000000000000000000000000000000000000000;;		// Maximum allowed grace period (in seconds) to use when terminating pods in response to a soft eviction threshold being met.
0000000000000000000000000000000000000000;;		MaxPodGracePeriodSeconds int64
0000000000000000000000000000000000000000;;		// Thresholds define the set of conditions monitored to trigger eviction.
0000000000000000000000000000000000000000;;		Thresholds []evictionapi.Threshold
0000000000000000000000000000000000000000;;		// KernelMemcgNotification if true will integrate with the kernel memcg notification to determine if memory thresholds are crossed.
0000000000000000000000000000000000000000;;		KernelMemcgNotification bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Manager evaluates when an eviction threshold for node stability has been met on the node.
0000000000000000000000000000000000000000;;	type Manager interface {
0000000000000000000000000000000000000000;;		// Start starts the control loop to monitor eviction thresholds at specified interval.
0000000000000000000000000000000000000000;;		Start(diskInfoProvider DiskInfoProvider, podFunc ActivePodsFunc, podCleanedUpFunc PodCleanedUpFunc, nodeProvider NodeProvider, monitoringInterval time.Duration)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IsUnderMemoryPressure returns true if the node is under memory pressure.
0000000000000000000000000000000000000000;;		IsUnderMemoryPressure() bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IsUnderDiskPressure returns true if the node is under disk pressure.
0000000000000000000000000000000000000000;;		IsUnderDiskPressure() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DiskInfoProvider is responsible for informing the manager how disk is configured.
0000000000000000000000000000000000000000;;	type DiskInfoProvider interface {
0000000000000000000000000000000000000000;;		// HasDedicatedImageFs returns true if the imagefs is on a separate device from the rootfs.
0000000000000000000000000000000000000000;;		HasDedicatedImageFs() (bool, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeProvider is responsible for providing the node api object describing this node
0000000000000000000000000000000000000000;;	type NodeProvider interface {
0000000000000000000000000000000000000000;;		// GetNode returns the node info for this node
0000000000000000000000000000000000000000;;		GetNode() (*v1.Node, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ImageGC is responsible for performing garbage collection of unused images.
0000000000000000000000000000000000000000;;	type ImageGC interface {
0000000000000000000000000000000000000000;;		// DeleteUnusedImages deletes unused images and returns the number of bytes freed, and an error.
0000000000000000000000000000000000000000;;		// This returns the bytes freed even if an error is returned.
0000000000000000000000000000000000000000;;		DeleteUnusedImages() (int64, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerGC is responsible for performing garbage collection of unused containers.
0000000000000000000000000000000000000000;;	type ContainerGC interface {
0000000000000000000000000000000000000000;;		// DeleteAllUnusedContainers deletes all unused containers, even those that belong to pods that are terminated, but not deleted.
0000000000000000000000000000000000000000;;		// It returns an error if it is unsuccessful.
0000000000000000000000000000000000000000;;		DeleteAllUnusedContainers() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KillPodFunc kills a pod.
0000000000000000000000000000000000000000;;	// The pod status is updated, and then it is killed with the specified grace period.
0000000000000000000000000000000000000000;;	// This function must block until either the pod is killed or an error is encountered.
0000000000000000000000000000000000000000;;	// Arguments:
0000000000000000000000000000000000000000;;	// pod - the pod to kill
0000000000000000000000000000000000000000;;	// status - the desired status to associate with the pod (i.e. why its killed)
0000000000000000000000000000000000000000;;	// gracePeriodOverride - the grace period override to use instead of what is on the pod spec
0000000000000000000000000000000000000000;;	type KillPodFunc func(pod *v1.Pod, status v1.PodStatus, gracePeriodOverride *int64) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ActivePodsFunc returns pods bound to the kubelet that are active (i.e. non-terminal state)
0000000000000000000000000000000000000000;;	type ActivePodsFunc func() []*v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodCleanedUpFunc returns true if all resources associated with a pod have been reclaimed.
0000000000000000000000000000000000000000;;	type PodCleanedUpFunc func(*v1.Pod) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// statsFunc returns the usage stats if known for an input pod.
0000000000000000000000000000000000000000;;	type statsFunc func(pod *v1.Pod) (statsapi.PodStats, bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rankFunc sorts the pods in eviction order
0000000000000000000000000000000000000000;;	type rankFunc func(pods []*v1.Pod, stats statsFunc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// signalObservation is the observed resource usage
0000000000000000000000000000000000000000;;	type signalObservation struct {
0000000000000000000000000000000000000000;;		// The resource capacity
0000000000000000000000000000000000000000;;		capacity *resource.Quantity
0000000000000000000000000000000000000000;;		// The available resource
0000000000000000000000000000000000000000;;		available *resource.Quantity
0000000000000000000000000000000000000000;;		// Time at which the observation was taken
0000000000000000000000000000000000000000;;		time metav1.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// signalObservations maps a signal to an observed quantity
0000000000000000000000000000000000000000;;	type signalObservations map[evictionapi.Signal]signalObservation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// thresholdsObservedAt maps a threshold to a time that it was observed
0000000000000000000000000000000000000000;;	type thresholdsObservedAt map[evictionapi.Threshold]time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nodeConditionsObservedAt maps a node condition to a time that it was observed
0000000000000000000000000000000000000000;;	type nodeConditionsObservedAt map[v1.NodeConditionType]time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nodeReclaimFunc is a function that knows how to reclaim a resource from the node without impacting pods.
0000000000000000000000000000000000000000;;	// Returns the quantity of resources reclaimed and an error, if applicable.
0000000000000000000000000000000000000000;;	// nodeReclaimFunc return the resources reclaimed even if an error occurs.
0000000000000000000000000000000000000000;;	type nodeReclaimFunc func() (*resource.Quantity, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nodeReclaimFuncs is an ordered list of nodeReclaimFunc
0000000000000000000000000000000000000000;;	type nodeReclaimFuncs []nodeReclaimFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// thresholdNotifierHandlerFunc is a function that takes action in response to a crossed threshold
0000000000000000000000000000000000000000;;	type thresholdNotifierHandlerFunc func(thresholdDescription string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ThresholdNotifier notifies the user when an attribute crosses a threshold value
0000000000000000000000000000000000000000;;	type ThresholdNotifier interface {
0000000000000000000000000000000000000000;;		Start(stopCh <-chan struct{})
0000000000000000000000000000000000000000;;	}
