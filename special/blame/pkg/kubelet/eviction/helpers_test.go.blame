0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
20e2419ee209ff5ea436a2241a59408045607edc;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package eviction
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		statsapi "k8s.io/kubernetes/pkg/kubelet/apis/stats/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/cm"
0000000000000000000000000000000000000000;;		evictionapi "k8s.io/kubernetes/pkg/kubelet/eviction/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/quota"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func quantityMustParse(value string) *resource.Quantity {
0000000000000000000000000000000000000000;;		q := resource.MustParse(value)
0000000000000000000000000000000000000000;;		return &q
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestParseThresholdConfig(t *testing.T) {
0000000000000000000000000000000000000000;;		gracePeriod, _ := time.ParseDuration("30s")
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			allocatableConfig       []string
0000000000000000000000000000000000000000;;			evictionHard            string
0000000000000000000000000000000000000000;;			evictionSoft            string
0000000000000000000000000000000000000000;;			evictionSoftGracePeriod string
0000000000000000000000000000000000000000;;			evictionMinReclaim      string
0000000000000000000000000000000000000000;;			expectErr               bool
0000000000000000000000000000000000000000;;			expectThresholds        []evictionapi.Threshold
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"no values": {
0000000000000000000000000000000000000000;;				allocatableConfig:       []string{},
0000000000000000000000000000000000000000;;				evictionHard:            "",
0000000000000000000000000000000000000000;;				evictionSoft:            "",
0000000000000000000000000000000000000000;;				evictionSoftGracePeriod: "",
0000000000000000000000000000000000000000;;				evictionMinReclaim:      "",
0000000000000000000000000000000000000000;;				expectErr:               false,
0000000000000000000000000000000000000000;;				expectThresholds:        []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"all flag values": {
0000000000000000000000000000000000000000;;				allocatableConfig:       []string{cm.NodeAllocatableEnforcementKey},
0000000000000000000000000000000000000000;;				evictionHard:            "memory.available<150Mi",
0000000000000000000000000000000000000000;;				evictionSoft:            "memory.available<300Mi",
0000000000000000000000000000000000000000;;				evictionSoftGracePeriod: "memory.available=30s",
0000000000000000000000000000000000000000;;				evictionMinReclaim:      "memory.available=0",
0000000000000000000000000000000000000000;;				expectErr:               false,
0000000000000000000000000000000000000000;;				expectThresholds: []evictionapi.Threshold{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Signal:   evictionapi.SignalAllocatableMemoryAvailable,
0000000000000000000000000000000000000000;;						Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;						Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("0"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("0"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Signal:   evictionapi.SignalAllocatableNodeFsAvailable,
0000000000000000000000000000000000000000;;						Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;						Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("0"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("0"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Signal:   evictionapi.SignalMemoryAvailable,
0000000000000000000000000000000000000000;;						Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;						Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("150Mi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("0"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Signal:   evictionapi.SignalMemoryAvailable,
0000000000000000000000000000000000000000;;						Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;						Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("300Mi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						GracePeriod: gracePeriod,
0000000000000000000000000000000000000000;;						MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("0"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"all flag values in percentages": {
0000000000000000000000000000000000000000;;				allocatableConfig:       []string{},
0000000000000000000000000000000000000000;;				evictionHard:            "memory.available<10%",
0000000000000000000000000000000000000000;;				evictionSoft:            "memory.available<30%",
0000000000000000000000000000000000000000;;				evictionSoftGracePeriod: "memory.available=30s",
0000000000000000000000000000000000000000;;				evictionMinReclaim:      "memory.available=5%",
0000000000000000000000000000000000000000;;				expectErr:               false,
0000000000000000000000000000000000000000;;				expectThresholds: []evictionapi.Threshold{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Signal:   evictionapi.SignalMemoryAvailable,
0000000000000000000000000000000000000000;;						Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;						Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Percentage: 0.1,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Percentage: 0.05,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Signal:   evictionapi.SignalMemoryAvailable,
0000000000000000000000000000000000000000;;						Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;						Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Percentage: 0.3,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						GracePeriod: gracePeriod,
0000000000000000000000000000000000000000;;						MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Percentage: 0.05,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"disk flag values": {
0000000000000000000000000000000000000000;;				allocatableConfig:       []string{},
0000000000000000000000000000000000000000;;				evictionHard:            "imagefs.available<150Mi,nodefs.available<100Mi",
0000000000000000000000000000000000000000;;				evictionSoft:            "imagefs.available<300Mi,nodefs.available<200Mi",
0000000000000000000000000000000000000000;;				evictionSoftGracePeriod: "imagefs.available=30s,nodefs.available=30s",
0000000000000000000000000000000000000000;;				evictionMinReclaim:      "imagefs.available=2Gi,nodefs.available=1Gi",
0000000000000000000000000000000000000000;;				expectErr:               false,
0000000000000000000000000000000000000000;;				expectThresholds: []evictionapi.Threshold{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Signal:   evictionapi.SignalImageFsAvailable,
0000000000000000000000000000000000000000;;						Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;						Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("150Mi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("2Gi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Signal:   evictionapi.SignalNodeFsAvailable,
0000000000000000000000000000000000000000;;						Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;						Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("100Mi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("1Gi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Signal:   evictionapi.SignalImageFsAvailable,
0000000000000000000000000000000000000000;;						Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;						Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("300Mi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						GracePeriod: gracePeriod,
0000000000000000000000000000000000000000;;						MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("2Gi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Signal:   evictionapi.SignalNodeFsAvailable,
0000000000000000000000000000000000000000;;						Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;						Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("200Mi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						GracePeriod: gracePeriod,
0000000000000000000000000000000000000000;;						MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("1Gi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"disk flag values in percentages": {
0000000000000000000000000000000000000000;;				allocatableConfig:       []string{},
0000000000000000000000000000000000000000;;				evictionHard:            "imagefs.available<15%,nodefs.available<10.5%",
0000000000000000000000000000000000000000;;				evictionSoft:            "imagefs.available<30%,nodefs.available<20.5%",
0000000000000000000000000000000000000000;;				evictionSoftGracePeriod: "imagefs.available=30s,nodefs.available=30s",
0000000000000000000000000000000000000000;;				evictionMinReclaim:      "imagefs.available=10%,nodefs.available=5%",
0000000000000000000000000000000000000000;;				expectErr:               false,
0000000000000000000000000000000000000000;;				expectThresholds: []evictionapi.Threshold{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Signal:   evictionapi.SignalImageFsAvailable,
0000000000000000000000000000000000000000;;						Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;						Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Percentage: 0.15,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Percentage: 0.1,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Signal:   evictionapi.SignalNodeFsAvailable,
0000000000000000000000000000000000000000;;						Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;						Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Percentage: 0.105,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Percentage: 0.05,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Signal:   evictionapi.SignalImageFsAvailable,
0000000000000000000000000000000000000000;;						Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;						Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Percentage: 0.3,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						GracePeriod: gracePeriod,
0000000000000000000000000000000000000000;;						MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Percentage: 0.1,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Signal:   evictionapi.SignalNodeFsAvailable,
0000000000000000000000000000000000000000;;						Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;						Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Percentage: 0.205,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						GracePeriod: gracePeriod,
0000000000000000000000000000000000000000;;						MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Percentage: 0.05,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"inode flag values": {
0000000000000000000000000000000000000000;;				allocatableConfig:       []string{},
0000000000000000000000000000000000000000;;				evictionHard:            "imagefs.inodesFree<150Mi,nodefs.inodesFree<100Mi",
0000000000000000000000000000000000000000;;				evictionSoft:            "imagefs.inodesFree<300Mi,nodefs.inodesFree<200Mi",
0000000000000000000000000000000000000000;;				evictionSoftGracePeriod: "imagefs.inodesFree=30s,nodefs.inodesFree=30s",
0000000000000000000000000000000000000000;;				evictionMinReclaim:      "imagefs.inodesFree=2Gi,nodefs.inodesFree=1Gi",
0000000000000000000000000000000000000000;;				expectErr:               false,
0000000000000000000000000000000000000000;;				expectThresholds: []evictionapi.Threshold{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Signal:   evictionapi.SignalImageFsInodesFree,
0000000000000000000000000000000000000000;;						Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;						Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("150Mi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("2Gi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Signal:   evictionapi.SignalNodeFsInodesFree,
0000000000000000000000000000000000000000;;						Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;						Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("100Mi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("1Gi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Signal:   evictionapi.SignalImageFsInodesFree,
0000000000000000000000000000000000000000;;						Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;						Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("300Mi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						GracePeriod: gracePeriod,
0000000000000000000000000000000000000000;;						MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("2Gi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Signal:   evictionapi.SignalNodeFsInodesFree,
0000000000000000000000000000000000000000;;						Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;						Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("200Mi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						GracePeriod: gracePeriod,
0000000000000000000000000000000000000000;;						MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;							Quantity: quantityMustParse("1Gi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid-signal": {
0000000000000000000000000000000000000000;;				allocatableConfig:       []string{},
0000000000000000000000000000000000000000;;				evictionHard:            "mem.available<150Mi",
0000000000000000000000000000000000000000;;				evictionSoft:            "",
0000000000000000000000000000000000000000;;				evictionSoftGracePeriod: "",
0000000000000000000000000000000000000000;;				evictionMinReclaim:      "",
0000000000000000000000000000000000000000;;				expectErr:               true,
0000000000000000000000000000000000000000;;				expectThresholds:        []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"hard-signal-negative": {
0000000000000000000000000000000000000000;;				allocatableConfig:       []string{},
0000000000000000000000000000000000000000;;				evictionHard:            "memory.available<-150Mi",
0000000000000000000000000000000000000000;;				evictionSoft:            "",
0000000000000000000000000000000000000000;;				evictionSoftGracePeriod: "",
0000000000000000000000000000000000000000;;				evictionMinReclaim:      "",
0000000000000000000000000000000000000000;;				expectErr:               true,
0000000000000000000000000000000000000000;;				expectThresholds:        []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"hard-signal-negative-percentage": {
0000000000000000000000000000000000000000;;				allocatableConfig:       []string{},
0000000000000000000000000000000000000000;;				evictionHard:            "memory.available<-15%",
0000000000000000000000000000000000000000;;				evictionSoft:            "",
0000000000000000000000000000000000000000;;				evictionSoftGracePeriod: "",
0000000000000000000000000000000000000000;;				evictionMinReclaim:      "",
0000000000000000000000000000000000000000;;				expectErr:               true,
0000000000000000000000000000000000000000;;				expectThresholds:        []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"soft-signal-negative": {
0000000000000000000000000000000000000000;;				allocatableConfig:       []string{},
0000000000000000000000000000000000000000;;				evictionHard:            "",
0000000000000000000000000000000000000000;;				evictionSoft:            "memory.available<-150Mi",
0000000000000000000000000000000000000000;;				evictionSoftGracePeriod: "",
0000000000000000000000000000000000000000;;				evictionMinReclaim:      "",
0000000000000000000000000000000000000000;;				expectErr:               true,
0000000000000000000000000000000000000000;;				expectThresholds:        []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"duplicate-signal": {
0000000000000000000000000000000000000000;;				allocatableConfig:       []string{},
0000000000000000000000000000000000000000;;				evictionHard:            "memory.available<150Mi,memory.available<100Mi",
0000000000000000000000000000000000000000;;				evictionSoft:            "",
0000000000000000000000000000000000000000;;				evictionSoftGracePeriod: "",
0000000000000000000000000000000000000000;;				evictionMinReclaim:      "",
0000000000000000000000000000000000000000;;				expectErr:               true,
0000000000000000000000000000000000000000;;				expectThresholds:        []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"valid-and-invalid-signal": {
0000000000000000000000000000000000000000;;				allocatableConfig:       []string{},
0000000000000000000000000000000000000000;;				evictionHard:            "memory.available<150Mi,invalid.foo<150Mi",
0000000000000000000000000000000000000000;;				evictionSoft:            "",
0000000000000000000000000000000000000000;;				evictionSoftGracePeriod: "",
0000000000000000000000000000000000000000;;				evictionMinReclaim:      "",
0000000000000000000000000000000000000000;;				expectErr:               true,
0000000000000000000000000000000000000000;;				expectThresholds:        []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"soft-no-grace-period": {
0000000000000000000000000000000000000000;;				allocatableConfig:       []string{},
0000000000000000000000000000000000000000;;				evictionHard:            "",
0000000000000000000000000000000000000000;;				evictionSoft:            "memory.available<150Mi",
0000000000000000000000000000000000000000;;				evictionSoftGracePeriod: "",
0000000000000000000000000000000000000000;;				evictionMinReclaim:      "",
0000000000000000000000000000000000000000;;				expectErr:               true,
0000000000000000000000000000000000000000;;				expectThresholds:        []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"soft-neg-grace-period": {
0000000000000000000000000000000000000000;;				allocatableConfig:       []string{},
0000000000000000000000000000000000000000;;				evictionHard:            "",
0000000000000000000000000000000000000000;;				evictionSoft:            "memory.available<150Mi",
0000000000000000000000000000000000000000;;				evictionSoftGracePeriod: "memory.available=-30s",
0000000000000000000000000000000000000000;;				evictionMinReclaim:      "",
0000000000000000000000000000000000000000;;				expectErr:               true,
0000000000000000000000000000000000000000;;				expectThresholds:        []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"neg-reclaim": {
0000000000000000000000000000000000000000;;				allocatableConfig:       []string{},
0000000000000000000000000000000000000000;;				evictionHard:            "",
0000000000000000000000000000000000000000;;				evictionSoft:            "",
0000000000000000000000000000000000000000;;				evictionSoftGracePeriod: "",
0000000000000000000000000000000000000000;;				evictionMinReclaim:      "memory.available=-300Mi",
0000000000000000000000000000000000000000;;				expectErr:               true,
0000000000000000000000000000000000000000;;				expectThresholds:        []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"duplicate-reclaim": {
0000000000000000000000000000000000000000;;				allocatableConfig:       []string{},
0000000000000000000000000000000000000000;;				evictionHard:            "",
0000000000000000000000000000000000000000;;				evictionSoft:            "",
0000000000000000000000000000000000000000;;				evictionSoftGracePeriod: "",
0000000000000000000000000000000000000000;;				evictionMinReclaim:      "memory.available=-300Mi,memory.available=-100Mi",
0000000000000000000000000000000000000000;;				expectErr:               true,
0000000000000000000000000000000000000000;;				expectThresholds:        []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for testName, testCase := range testCases {
0000000000000000000000000000000000000000;;			thresholds, err := ParseThresholdConfig(testCase.allocatableConfig, testCase.evictionHard, testCase.evictionSoft, testCase.evictionSoftGracePeriod, testCase.evictionMinReclaim)
0000000000000000000000000000000000000000;;			if testCase.expectErr != (err != nil) {
0000000000000000000000000000000000000000;;				t.Errorf("Err not as expected, test: %v, error expected: %v, actual: %v", testName, testCase.expectErr, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !thresholdsEqual(testCase.expectThresholds, thresholds) {
0000000000000000000000000000000000000000;;				t.Errorf("thresholds not as expected, test: %v, expected: %v, actual: %v", testName, testCase.expectThresholds, thresholds)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func thresholdsEqual(expected []evictionapi.Threshold, actual []evictionapi.Threshold) bool {
0000000000000000000000000000000000000000;;		if len(expected) != len(actual) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, aThreshold := range expected {
0000000000000000000000000000000000000000;;			equal := false
0000000000000000000000000000000000000000;;			for _, bThreshold := range actual {
0000000000000000000000000000000000000000;;				if thresholdEqual(aThreshold, bThreshold) {
0000000000000000000000000000000000000000;;					equal = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !equal {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, aThreshold := range actual {
0000000000000000000000000000000000000000;;			equal := false
0000000000000000000000000000000000000000;;			for _, bThreshold := range expected {
0000000000000000000000000000000000000000;;				if thresholdEqual(aThreshold, bThreshold) {
0000000000000000000000000000000000000000;;					equal = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !equal {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func thresholdEqual(a evictionapi.Threshold, b evictionapi.Threshold) bool {
0000000000000000000000000000000000000000;;		return a.GracePeriod == b.GracePeriod &&
0000000000000000000000000000000000000000;;			a.Operator == b.Operator &&
0000000000000000000000000000000000000000;;			a.Signal == b.Signal &&
0000000000000000000000000000000000000000;;			compareThresholdValue(*a.MinReclaim, *b.MinReclaim) &&
0000000000000000000000000000000000000000;;			compareThresholdValue(a.Value, b.Value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestOrderedByQoS ensures we order BestEffort < Burstable < Guaranteed
0000000000000000000000000000000000000000;;	func TestOrderedByQoS(t *testing.T) {
0000000000000000000000000000000000000000;;		bestEffort := newPod("best-effort", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("best-effort", newResourceList("", ""), newResourceList("", "")),
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		burstable := newPod("burstable", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("burstable", newResourceList("100m", "100Mi"), newResourceList("200m", "200Mi")),
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		guaranteed := newPod("guaranteed", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("guaranteed", newResourceList("200m", "200Mi"), newResourceList("200m", "200Mi")),
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods := []*v1.Pod{guaranteed, burstable, bestEffort}
0000000000000000000000000000000000000000;;		orderedBy(qosComparator).Sort(pods)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected := []*v1.Pod{bestEffort, burstable, guaranteed}
0000000000000000000000000000000000000000;;		for i := range expected {
0000000000000000000000000000000000000000;;			if pods[i] != expected[i] {
0000000000000000000000000000000000000000;;				t.Errorf("Expected pod: %s, but got: %s", expected[i].Name, pods[i].Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOrderedbyDisk(t *testing.T) {
0000000000000000000000000000000000000000;;		testOrderedByResource(t, resourceDisk, newPodDiskStats)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOrderedbyInodes(t *testing.T) {
0000000000000000000000000000000000000000;;		testOrderedByResource(t, resourceInodes, newPodInodeStats)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testOrderedByDisk ensures we order pods by greediest resource consumer
0000000000000000000000000000000000000000;;	func testOrderedByResource(t *testing.T, orderedByResource v1.ResourceName,
0000000000000000000000000000000000000000;;		newPodStatsFunc func(pod *v1.Pod, rootFsUsed, logsUsed, perLocalVolumeUsed resource.Quantity) statsapi.PodStats) {
0000000000000000000000000000000000000000;;		pod1 := newPod("best-effort-high", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("best-effort-high", newResourceList("", ""), newResourceList("", "")),
0000000000000000000000000000000000000000;;		}, []v1.Volume{
0000000000000000000000000000000000000000;;			newVolume("local-volume", v1.VolumeSource{
0000000000000000000000000000000000000000;;				EmptyDir: &v1.EmptyDirVolumeSource{},
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		pod2 := newPod("best-effort-low", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("best-effort-low", newResourceList("", ""), newResourceList("", "")),
0000000000000000000000000000000000000000;;		}, []v1.Volume{
0000000000000000000000000000000000000000;;			newVolume("local-volume", v1.VolumeSource{
0000000000000000000000000000000000000000;;				EmptyDir: &v1.EmptyDirVolumeSource{},
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		pod3 := newPod("burstable-high", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("burstable-high", newResourceList("100m", "100Mi"), newResourceList("200m", "1Gi")),
0000000000000000000000000000000000000000;;		}, []v1.Volume{
0000000000000000000000000000000000000000;;			newVolume("local-volume", v1.VolumeSource{
0000000000000000000000000000000000000000;;				EmptyDir: &v1.EmptyDirVolumeSource{},
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		pod4 := newPod("burstable-low", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("burstable-low", newResourceList("100m", "100Mi"), newResourceList("200m", "1Gi")),
0000000000000000000000000000000000000000;;		}, []v1.Volume{
0000000000000000000000000000000000000000;;			newVolume("local-volume", v1.VolumeSource{
0000000000000000000000000000000000000000;;				EmptyDir: &v1.EmptyDirVolumeSource{},
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		pod5 := newPod("guaranteed-high", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("guaranteed-high", newResourceList("100m", "1Gi"), newResourceList("100m", "1Gi")),
0000000000000000000000000000000000000000;;		}, []v1.Volume{
0000000000000000000000000000000000000000;;			newVolume("local-volume", v1.VolumeSource{
0000000000000000000000000000000000000000;;				EmptyDir: &v1.EmptyDirVolumeSource{},
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		pod6 := newPod("guaranteed-low", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("guaranteed-low", newResourceList("100m", "1Gi"), newResourceList("100m", "1Gi")),
0000000000000000000000000000000000000000;;		}, []v1.Volume{
0000000000000000000000000000000000000000;;			newVolume("local-volume", v1.VolumeSource{
0000000000000000000000000000000000000000;;				EmptyDir: &v1.EmptyDirVolumeSource{},
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		stats := map[*v1.Pod]statsapi.PodStats{
0000000000000000000000000000000000000000;;			pod1: newPodStatsFunc(pod1, resource.MustParse("50Mi"), resource.MustParse("100Mi"), resource.MustParse("50Mi")),  // 200Mi
0000000000000000000000000000000000000000;;			pod2: newPodStatsFunc(pod2, resource.MustParse("100Mi"), resource.MustParse("150Mi"), resource.MustParse("50Mi")), // 300Mi
0000000000000000000000000000000000000000;;			pod3: newPodStatsFunc(pod3, resource.MustParse("200Mi"), resource.MustParse("150Mi"), resource.MustParse("50Mi")), // 400Mi
0000000000000000000000000000000000000000;;			pod4: newPodStatsFunc(pod4, resource.MustParse("300Mi"), resource.MustParse("100Mi"), resource.MustParse("50Mi")), // 450Mi
0000000000000000000000000000000000000000;;			pod5: newPodStatsFunc(pod5, resource.MustParse("400Mi"), resource.MustParse("100Mi"), resource.MustParse("50Mi")), // 550Mi
0000000000000000000000000000000000000000;;			pod6: newPodStatsFunc(pod6, resource.MustParse("500Mi"), resource.MustParse("100Mi"), resource.MustParse("50Mi")), // 650Mi
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		statsFn := func(pod *v1.Pod) (statsapi.PodStats, bool) {
0000000000000000000000000000000000000000;;			result, found := stats[pod]
0000000000000000000000000000000000000000;;			return result, found
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pods := []*v1.Pod{pod1, pod2, pod3, pod4, pod5, pod6}
0000000000000000000000000000000000000000;;		orderedBy(disk(statsFn, []fsStatsType{fsStatsRoot, fsStatsLogs, fsStatsLocalVolumeSource}, orderedByResource)).Sort(pods)
0000000000000000000000000000000000000000;;		expected := []*v1.Pod{pod6, pod5, pod4, pod3, pod2, pod1}
0000000000000000000000000000000000000000;;		for i := range expected {
0000000000000000000000000000000000000000;;			if pods[i] != expected[i] {
0000000000000000000000000000000000000000;;				t.Errorf("Expected pod[%d]: %s, but got: %s", i, expected[i].Name, pods[i].Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOrderedbyQoSDisk(t *testing.T) {
0000000000000000000000000000000000000000;;		testOrderedByQoSResource(t, resourceDisk, newPodDiskStats)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOrderedbyQoSInodes(t *testing.T) {
0000000000000000000000000000000000000000;;		testOrderedByQoSResource(t, resourceInodes, newPodInodeStats)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testOrderedByQoSDisk ensures we order pods by qos and then greediest resource consumer
0000000000000000000000000000000000000000;;	func testOrderedByQoSResource(t *testing.T, orderedByResource v1.ResourceName,
0000000000000000000000000000000000000000;;		newPodStatsFunc func(pod *v1.Pod, rootFsUsed, logsUsed, perLocalVolumeUsed resource.Quantity) statsapi.PodStats) {
0000000000000000000000000000000000000000;;		pod1 := newPod("best-effort-high", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("best-effort-high", newResourceList("", ""), newResourceList("", "")),
0000000000000000000000000000000000000000;;		}, []v1.Volume{
0000000000000000000000000000000000000000;;			newVolume("local-volume", v1.VolumeSource{
0000000000000000000000000000000000000000;;				EmptyDir: &v1.EmptyDirVolumeSource{},
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		pod2 := newPod("best-effort-low", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("best-effort-low", newResourceList("", ""), newResourceList("", "")),
0000000000000000000000000000000000000000;;		}, []v1.Volume{
0000000000000000000000000000000000000000;;			newVolume("local-volume", v1.VolumeSource{
0000000000000000000000000000000000000000;;				EmptyDir: &v1.EmptyDirVolumeSource{},
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		pod3 := newPod("burstable-high", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("burstable-high", newResourceList("100m", "100Mi"), newResourceList("200m", "1Gi")),
0000000000000000000000000000000000000000;;		}, []v1.Volume{
0000000000000000000000000000000000000000;;			newVolume("local-volume", v1.VolumeSource{
0000000000000000000000000000000000000000;;				EmptyDir: &v1.EmptyDirVolumeSource{},
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		pod4 := newPod("burstable-low", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("burstable-low", newResourceList("100m", "100Mi"), newResourceList("200m", "1Gi")),
0000000000000000000000000000000000000000;;		}, []v1.Volume{
0000000000000000000000000000000000000000;;			newVolume("local-volume", v1.VolumeSource{
0000000000000000000000000000000000000000;;				EmptyDir: &v1.EmptyDirVolumeSource{},
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		pod5 := newPod("guaranteed-high", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("guaranteed-high", newResourceList("100m", "1Gi"), newResourceList("100m", "1Gi")),
0000000000000000000000000000000000000000;;		}, []v1.Volume{
0000000000000000000000000000000000000000;;			newVolume("local-volume", v1.VolumeSource{
0000000000000000000000000000000000000000;;				EmptyDir: &v1.EmptyDirVolumeSource{},
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		pod6 := newPod("guaranteed-low", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("guaranteed-low", newResourceList("100m", "1Gi"), newResourceList("100m", "1Gi")),
0000000000000000000000000000000000000000;;		}, []v1.Volume{
0000000000000000000000000000000000000000;;			newVolume("local-volume", v1.VolumeSource{
0000000000000000000000000000000000000000;;				EmptyDir: &v1.EmptyDirVolumeSource{},
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		stats := map[*v1.Pod]statsapi.PodStats{
0000000000000000000000000000000000000000;;			pod1: newPodStatsFunc(pod1, resource.MustParse("50Mi"), resource.MustParse("100Mi"), resource.MustParse("50Mi")),  // 200Mi
0000000000000000000000000000000000000000;;			pod2: newPodStatsFunc(pod2, resource.MustParse("100Mi"), resource.MustParse("150Mi"), resource.MustParse("50Mi")), // 300Mi
0000000000000000000000000000000000000000;;			pod3: newPodStatsFunc(pod3, resource.MustParse("200Mi"), resource.MustParse("150Mi"), resource.MustParse("50Mi")), // 400Mi
0000000000000000000000000000000000000000;;			pod4: newPodStatsFunc(pod4, resource.MustParse("300Mi"), resource.MustParse("100Mi"), resource.MustParse("50Mi")), // 450Mi
0000000000000000000000000000000000000000;;			pod5: newPodStatsFunc(pod5, resource.MustParse("400Mi"), resource.MustParse("100Mi"), resource.MustParse("50Mi")), // 550Mi
0000000000000000000000000000000000000000;;			pod6: newPodStatsFunc(pod6, resource.MustParse("500Mi"), resource.MustParse("100Mi"), resource.MustParse("50Mi")), // 650Mi
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		statsFn := func(pod *v1.Pod) (statsapi.PodStats, bool) {
0000000000000000000000000000000000000000;;			result, found := stats[pod]
0000000000000000000000000000000000000000;;			return result, found
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pods := []*v1.Pod{pod1, pod2, pod3, pod4, pod5, pod6}
0000000000000000000000000000000000000000;;		orderedBy(qosComparator, disk(statsFn, []fsStatsType{fsStatsRoot, fsStatsLogs, fsStatsLocalVolumeSource}, orderedByResource)).Sort(pods)
0000000000000000000000000000000000000000;;		expected := []*v1.Pod{pod2, pod1, pod4, pod3, pod6, pod5}
0000000000000000000000000000000000000000;;		for i := range expected {
0000000000000000000000000000000000000000;;			if pods[i] != expected[i] {
0000000000000000000000000000000000000000;;				t.Errorf("Expected pod[%d]: %s, but got: %s", i, expected[i].Name, pods[i].Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestOrderedByMemory ensures we order pods by greediest memory consumer relative to request.
0000000000000000000000000000000000000000;;	func TestOrderedByMemory(t *testing.T) {
0000000000000000000000000000000000000000;;		pod1 := newPod("best-effort-high", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("best-effort-high", newResourceList("", ""), newResourceList("", "")),
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		pod2 := newPod("best-effort-low", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("best-effort-low", newResourceList("", ""), newResourceList("", "")),
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		pod3 := newPod("burstable-high", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("burstable-high", newResourceList("100m", "100Mi"), newResourceList("200m", "1Gi")),
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		pod4 := newPod("burstable-low", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("burstable-low", newResourceList("100m", "100Mi"), newResourceList("200m", "1Gi")),
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		pod5 := newPod("guaranteed-high", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("guaranteed-high", newResourceList("100m", "1Gi"), newResourceList("100m", "1Gi")),
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		pod6 := newPod("guaranteed-low", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("guaranteed-low", newResourceList("100m", "1Gi"), newResourceList("100m", "1Gi")),
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		stats := map[*v1.Pod]statsapi.PodStats{
0000000000000000000000000000000000000000;;			pod1: newPodMemoryStats(pod1, resource.MustParse("500Mi")), // 500 relative to request
0000000000000000000000000000000000000000;;			pod2: newPodMemoryStats(pod2, resource.MustParse("300Mi")), // 300 relative to request
0000000000000000000000000000000000000000;;			pod3: newPodMemoryStats(pod3, resource.MustParse("800Mi")), // 700 relative to request
0000000000000000000000000000000000000000;;			pod4: newPodMemoryStats(pod4, resource.MustParse("300Mi")), // 200 relative to request
0000000000000000000000000000000000000000;;			pod5: newPodMemoryStats(pod5, resource.MustParse("800Mi")), // -200 relative to request
0000000000000000000000000000000000000000;;			pod6: newPodMemoryStats(pod6, resource.MustParse("200Mi")), // -800 relative to request
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		statsFn := func(pod *v1.Pod) (statsapi.PodStats, bool) {
0000000000000000000000000000000000000000;;			result, found := stats[pod]
0000000000000000000000000000000000000000;;			return result, found
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pods := []*v1.Pod{pod1, pod2, pod3, pod4, pod5, pod6}
0000000000000000000000000000000000000000;;		orderedBy(memory(statsFn)).Sort(pods)
0000000000000000000000000000000000000000;;		expected := []*v1.Pod{pod3, pod1, pod2, pod4, pod5, pod6}
0000000000000000000000000000000000000000;;		for i := range expected {
0000000000000000000000000000000000000000;;			if pods[i] != expected[i] {
0000000000000000000000000000000000000000;;				t.Errorf("Expected pod[%d]: %s, but got: %s", i, expected[i].Name, pods[i].Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestOrderedByQoSMemory ensures we order by qosComparator and then memory consumption relative to request.
0000000000000000000000000000000000000000;;	func TestOrderedByQoSMemory(t *testing.T) {
0000000000000000000000000000000000000000;;		pod1 := newPod("best-effort-high", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("best-effort-high", newResourceList("", ""), newResourceList("", "")),
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		pod2 := newPod("best-effort-low", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("best-effort-low", newResourceList("", ""), newResourceList("", "")),
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		pod3 := newPod("burstable-high", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("burstable-high", newResourceList("100m", "100Mi"), newResourceList("200m", "1Gi")),
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		pod4 := newPod("burstable-low", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("burstable-low", newResourceList("100m", "100Mi"), newResourceList("200m", "1Gi")),
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		pod5 := newPod("guaranteed-high", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("guaranteed-high", newResourceList("100m", "1Gi"), newResourceList("100m", "1Gi")),
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		pod6 := newPod("guaranteed-low", []v1.Container{
0000000000000000000000000000000000000000;;			newContainer("guaranteed-low", newResourceList("100m", "1Gi"), newResourceList("100m", "1Gi")),
0000000000000000000000000000000000000000;;		}, nil)
0000000000000000000000000000000000000000;;		stats := map[*v1.Pod]statsapi.PodStats{
0000000000000000000000000000000000000000;;			pod1: newPodMemoryStats(pod1, resource.MustParse("500Mi")), // 500 relative to request
0000000000000000000000000000000000000000;;			pod2: newPodMemoryStats(pod2, resource.MustParse("50Mi")),  // 50 relative to request
0000000000000000000000000000000000000000;;			pod3: newPodMemoryStats(pod3, resource.MustParse("50Mi")),  // -50 relative to request
0000000000000000000000000000000000000000;;			pod4: newPodMemoryStats(pod4, resource.MustParse("300Mi")), // 200 relative to request
0000000000000000000000000000000000000000;;			pod5: newPodMemoryStats(pod5, resource.MustParse("800Mi")), // -200 relative to request
0000000000000000000000000000000000000000;;			pod6: newPodMemoryStats(pod6, resource.MustParse("200Mi")), // -800 relative to request
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		statsFn := func(pod *v1.Pod) (statsapi.PodStats, bool) {
0000000000000000000000000000000000000000;;			result, found := stats[pod]
0000000000000000000000000000000000000000;;			return result, found
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pods := []*v1.Pod{pod1, pod2, pod3, pod4, pod5, pod6}
0000000000000000000000000000000000000000;;		expected := []*v1.Pod{pod1, pod2, pod4, pod3, pod5, pod6}
0000000000000000000000000000000000000000;;		orderedBy(qosComparator, memory(statsFn)).Sort(pods)
0000000000000000000000000000000000000000;;		for i := range expected {
0000000000000000000000000000000000000000;;			if pods[i] != expected[i] {
0000000000000000000000000000000000000000;;				t.Errorf("Expected pod[%d]: %s, but got: %s", i, expected[i].Name, pods[i].Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeSummaryProvider struct {
0000000000000000000000000000000000000000;;		result *statsapi.Summary
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeSummaryProvider) Get() (*statsapi.Summary, error) {
0000000000000000000000000000000000000000;;		return f.result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newPodStats returns a pod stat where each container is using the specified working set
0000000000000000000000000000000000000000;;	// each pod must have a Name, UID, Namespace
0000000000000000000000000000000000000000;;	func newPodStats(pod *v1.Pod, containerWorkingSetBytes int64) statsapi.PodStats {
0000000000000000000000000000000000000000;;		result := statsapi.PodStats{
0000000000000000000000000000000000000000;;			PodRef: statsapi.PodReference{
0000000000000000000000000000000000000000;;				Name:      pod.Name,
0000000000000000000000000000000000000000;;				Namespace: pod.Namespace,
0000000000000000000000000000000000000000;;				UID:       string(pod.UID),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		val := uint64(containerWorkingSetBytes)
0000000000000000000000000000000000000000;;		for range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			result.Containers = append(result.Containers, statsapi.ContainerStats{
0000000000000000000000000000000000000000;;				Memory: &statsapi.MemoryStats{
0000000000000000000000000000000000000000;;					WorkingSetBytes: &val,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMakeSignalObservations(t *testing.T) {
0000000000000000000000000000000000000000;;		podMaker := func(name, namespace, uid string, numContainers int) *v1.Pod {
0000000000000000000000000000000000000000;;			pod := &v1.Pod{}
0000000000000000000000000000000000000000;;			pod.Name = name
0000000000000000000000000000000000000000;;			pod.Namespace = namespace
0000000000000000000000000000000000000000;;			pod.UID = types.UID(uid)
0000000000000000000000000000000000000000;;			pod.Spec = v1.PodSpec{}
0000000000000000000000000000000000000000;;			for i := 0; i < numContainers; i++ {
0000000000000000000000000000000000000000;;				pod.Spec.Containers = append(pod.Spec.Containers, v1.Container{
0000000000000000000000000000000000000000;;					Name: fmt.Sprintf("ctr%v", i),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeAvailableBytes := uint64(1024 * 1024 * 1024)
0000000000000000000000000000000000000000;;		nodeWorkingSetBytes := uint64(1024 * 1024 * 1024)
0000000000000000000000000000000000000000;;		allocatableMemoryCapacity := uint64(5 * 1024 * 1024 * 1024)
0000000000000000000000000000000000000000;;		imageFsAvailableBytes := uint64(1024 * 1024)
0000000000000000000000000000000000000000;;		imageFsCapacityBytes := uint64(1024 * 1024 * 2)
0000000000000000000000000000000000000000;;		nodeFsAvailableBytes := uint64(1024)
0000000000000000000000000000000000000000;;		nodeFsCapacityBytes := uint64(1024 * 2)
0000000000000000000000000000000000000000;;		imageFsInodesFree := uint64(1024)
0000000000000000000000000000000000000000;;		imageFsInodes := uint64(1024 * 1024)
0000000000000000000000000000000000000000;;		nodeFsInodesFree := uint64(1024)
0000000000000000000000000000000000000000;;		nodeFsInodes := uint64(1024 * 1024)
0000000000000000000000000000000000000000;;		fakeStats := &statsapi.Summary{
0000000000000000000000000000000000000000;;			Node: statsapi.NodeStats{
0000000000000000000000000000000000000000;;				Memory: &statsapi.MemoryStats{
0000000000000000000000000000000000000000;;					AvailableBytes:  &nodeAvailableBytes,
0000000000000000000000000000000000000000;;					WorkingSetBytes: &nodeWorkingSetBytes,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Runtime: &statsapi.RuntimeStats{
0000000000000000000000000000000000000000;;					ImageFs: &statsapi.FsStats{
0000000000000000000000000000000000000000;;						AvailableBytes: &imageFsAvailableBytes,
0000000000000000000000000000000000000000;;						CapacityBytes:  &imageFsCapacityBytes,
0000000000000000000000000000000000000000;;						InodesFree:     &imageFsInodesFree,
0000000000000000000000000000000000000000;;						Inodes:         &imageFsInodes,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Fs: &statsapi.FsStats{
0000000000000000000000000000000000000000;;					AvailableBytes: &nodeFsAvailableBytes,
0000000000000000000000000000000000000000;;					CapacityBytes:  &nodeFsCapacityBytes,
0000000000000000000000000000000000000000;;					InodesFree:     &nodeFsInodesFree,
0000000000000000000000000000000000000000;;					Inodes:         &nodeFsInodes,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Pods: []statsapi.PodStats{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		provider := &fakeSummaryProvider{
0000000000000000000000000000000000000000;;			result: fakeStats,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pods := []*v1.Pod{
0000000000000000000000000000000000000000;;			podMaker("pod1", "ns1", "uuid1", 1),
0000000000000000000000000000000000000000;;			podMaker("pod1", "ns2", "uuid2", 1),
0000000000000000000000000000000000000000;;			podMaker("pod3", "ns3", "uuid3", 1),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		containerWorkingSetBytes := int64(1024 * 1024 * 1024)
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			fakeStats.Pods = append(fakeStats.Pods, newPodStats(pod, containerWorkingSetBytes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		res := quantityMustParse("5Gi")
0000000000000000000000000000000000000000;;		nodeProvider := newMockNodeProvider(v1.ResourceList{v1.ResourceMemory: *res})
0000000000000000000000000000000000000000;;		// Allocatable thresholds are always 100%.  Verify that Threshold == Capacity.
0000000000000000000000000000000000000000;;		if res.CmpInt64(int64(allocatableMemoryCapacity)) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected Threshold %v to be equal to value %v", res.Value(), allocatableMemoryCapacity)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		actualObservations, statsFunc, err := makeSignalObservations(provider, nodeProvider, pods, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected err: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allocatableMemQuantity, found := actualObservations[evictionapi.SignalAllocatableMemoryAvailable]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			t.Errorf("Expected allocatable memory observation, but didnt find one")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if allocatableMemQuantity.available.Value() != 2*containerWorkingSetBytes {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, actual: %v", containerWorkingSetBytes, allocatableMemQuantity.available.Value())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if expectedBytes := int64(allocatableMemoryCapacity); allocatableMemQuantity.capacity.Value() != expectedBytes {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, actual: %v", expectedBytes, allocatableMemQuantity.capacity.Value())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		memQuantity, found := actualObservations[evictionapi.SignalMemoryAvailable]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			t.Errorf("Expected available memory observation: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if expectedBytes := int64(nodeAvailableBytes); memQuantity.available.Value() != expectedBytes {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, actual: %v", expectedBytes, memQuantity.available.Value())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if expectedBytes := int64(nodeWorkingSetBytes + nodeAvailableBytes); memQuantity.capacity.Value() != expectedBytes {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, actual: %v", expectedBytes, memQuantity.capacity.Value())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeFsQuantity, found := actualObservations[evictionapi.SignalNodeFsAvailable]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			t.Errorf("Expected available nodefs observation: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if expectedBytes := int64(nodeFsAvailableBytes); nodeFsQuantity.available.Value() != expectedBytes {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, actual: %v", expectedBytes, nodeFsQuantity.available.Value())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if expectedBytes := int64(nodeFsCapacityBytes); nodeFsQuantity.capacity.Value() != expectedBytes {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, actual: %v", expectedBytes, nodeFsQuantity.capacity.Value())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeFsInodesQuantity, found := actualObservations[evictionapi.SignalNodeFsInodesFree]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			t.Errorf("Expected inodes free nodefs observation: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if expected := int64(nodeFsInodesFree); nodeFsInodesQuantity.available.Value() != expected {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, actual: %v", expected, nodeFsInodesQuantity.available.Value())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if expected := int64(nodeFsInodes); nodeFsInodesQuantity.capacity.Value() != expected {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, actual: %v", expected, nodeFsInodesQuantity.capacity.Value())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		imageFsQuantity, found := actualObservations[evictionapi.SignalImageFsAvailable]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			t.Errorf("Expected available imagefs observation: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if expectedBytes := int64(imageFsAvailableBytes); imageFsQuantity.available.Value() != expectedBytes {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, actual: %v", expectedBytes, imageFsQuantity.available.Value())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if expectedBytes := int64(imageFsCapacityBytes); imageFsQuantity.capacity.Value() != expectedBytes {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, actual: %v", expectedBytes, imageFsQuantity.capacity.Value())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		imageFsInodesQuantity, found := actualObservations[evictionapi.SignalImageFsInodesFree]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			t.Errorf("Expected inodes free imagefs observation: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if expected := int64(imageFsInodesFree); imageFsInodesQuantity.available.Value() != expected {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, actual: %v", expected, imageFsInodesQuantity.available.Value())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if expected := int64(imageFsInodes); imageFsInodesQuantity.capacity.Value() != expected {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, actual: %v", expected, imageFsInodesQuantity.capacity.Value())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			podStats, found := statsFunc(pod)
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				t.Errorf("Pod stats were not found for pod %v", pod.UID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, container := range podStats.Containers {
0000000000000000000000000000000000000000;;				actual := int64(*container.Memory.WorkingSetBytes)
0000000000000000000000000000000000000000;;				if containerWorkingSetBytes != actual {
0000000000000000000000000000000000000000;;					t.Errorf("Container working set expected %v, actual: %v", containerWorkingSetBytes, actual)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestThresholdsMet(t *testing.T) {
0000000000000000000000000000000000000000;;		hardThreshold := evictionapi.Threshold{
0000000000000000000000000000000000000000;;			Signal:   evictionapi.SignalMemoryAvailable,
0000000000000000000000000000000000000000;;			Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;			Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;				Quantity: quantityMustParse("1Gi"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;				Quantity: quantityMustParse("500Mi"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			enforceMinReclaim bool
0000000000000000000000000000000000000000;;			thresholds        []evictionapi.Threshold
0000000000000000000000000000000000000000;;			observations      signalObservations
0000000000000000000000000000000000000000;;			result            []evictionapi.Threshold
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"empty": {
0000000000000000000000000000000000000000;;				enforceMinReclaim: false,
0000000000000000000000000000000000000000;;				thresholds:        []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;				observations:      signalObservations{},
0000000000000000000000000000000000000000;;				result:            []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"threshold-met-memory": {
0000000000000000000000000000000000000000;;				enforceMinReclaim: false,
0000000000000000000000000000000000000000;;				thresholds:        []evictionapi.Threshold{hardThreshold},
0000000000000000000000000000000000000000;;				observations: signalObservations{
0000000000000000000000000000000000000000;;					evictionapi.SignalMemoryAvailable: signalObservation{
0000000000000000000000000000000000000000;;						available: quantityMustParse("500Mi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: []evictionapi.Threshold{hardThreshold},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"threshold-not-met": {
0000000000000000000000000000000000000000;;				enforceMinReclaim: false,
0000000000000000000000000000000000000000;;				thresholds:        []evictionapi.Threshold{hardThreshold},
0000000000000000000000000000000000000000;;				observations: signalObservations{
0000000000000000000000000000000000000000;;					evictionapi.SignalMemoryAvailable: signalObservation{
0000000000000000000000000000000000000000;;						available: quantityMustParse("2Gi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"threshold-met-with-min-reclaim": {
0000000000000000000000000000000000000000;;				enforceMinReclaim: true,
0000000000000000000000000000000000000000;;				thresholds:        []evictionapi.Threshold{hardThreshold},
0000000000000000000000000000000000000000;;				observations: signalObservations{
0000000000000000000000000000000000000000;;					evictionapi.SignalMemoryAvailable: signalObservation{
0000000000000000000000000000000000000000;;						available: quantityMustParse("1.05Gi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: []evictionapi.Threshold{hardThreshold},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"threshold-not-met-with-min-reclaim": {
0000000000000000000000000000000000000000;;				enforceMinReclaim: true,
0000000000000000000000000000000000000000;;				thresholds:        []evictionapi.Threshold{hardThreshold},
0000000000000000000000000000000000000000;;				observations: signalObservations{
0000000000000000000000000000000000000000;;					evictionapi.SignalMemoryAvailable: signalObservation{
0000000000000000000000000000000000000000;;						available: quantityMustParse("2Gi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for testName, testCase := range testCases {
0000000000000000000000000000000000000000;;			actual := thresholdsMet(testCase.thresholds, testCase.observations, testCase.enforceMinReclaim)
0000000000000000000000000000000000000000;;			if !thresholdList(actual).Equal(thresholdList(testCase.result)) {
0000000000000000000000000000000000000000;;				t.Errorf("Test case: %s, expected: %v, actual: %v", testName, testCase.result, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestThresholdsUpdatedStats(t *testing.T) {
0000000000000000000000000000000000000000;;		updatedThreshold := evictionapi.Threshold{
0000000000000000000000000000000000000000;;			Signal: evictionapi.SignalMemoryAvailable,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		locationUTC, err := time.LoadLocation("UTC")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			thresholds   []evictionapi.Threshold
0000000000000000000000000000000000000000;;			observations signalObservations
0000000000000000000000000000000000000000;;			last         signalObservations
0000000000000000000000000000000000000000;;			result       []evictionapi.Threshold
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"empty": {
0000000000000000000000000000000000000000;;				thresholds:   []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;				observations: signalObservations{},
0000000000000000000000000000000000000000;;				last:         signalObservations{},
0000000000000000000000000000000000000000;;				result:       []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no-time": {
0000000000000000000000000000000000000000;;				thresholds: []evictionapi.Threshold{updatedThreshold},
0000000000000000000000000000000000000000;;				observations: signalObservations{
0000000000000000000000000000000000000000;;					evictionapi.SignalMemoryAvailable: signalObservation{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				last:   signalObservations{},
0000000000000000000000000000000000000000;;				result: []evictionapi.Threshold{updatedThreshold},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no-last-observation": {
0000000000000000000000000000000000000000;;				thresholds: []evictionapi.Threshold{updatedThreshold},
0000000000000000000000000000000000000000;;				observations: signalObservations{
0000000000000000000000000000000000000000;;					evictionapi.SignalMemoryAvailable: signalObservation{
0000000000000000000000000000000000000000;;						time: metav1.Date(2016, 1, 1, 0, 0, 0, 0, locationUTC),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				last:   signalObservations{},
0000000000000000000000000000000000000000;;				result: []evictionapi.Threshold{updatedThreshold},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"time-machine": {
0000000000000000000000000000000000000000;;				thresholds: []evictionapi.Threshold{updatedThreshold},
0000000000000000000000000000000000000000;;				observations: signalObservations{
0000000000000000000000000000000000000000;;					evictionapi.SignalMemoryAvailable: signalObservation{
0000000000000000000000000000000000000000;;						time: metav1.Date(2016, 1, 1, 0, 0, 0, 0, locationUTC),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				last: signalObservations{
0000000000000000000000000000000000000000;;					evictionapi.SignalMemoryAvailable: signalObservation{
0000000000000000000000000000000000000000;;						time: metav1.Date(2016, 1, 1, 0, 1, 0, 0, locationUTC),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"same-observation": {
0000000000000000000000000000000000000000;;				thresholds: []evictionapi.Threshold{updatedThreshold},
0000000000000000000000000000000000000000;;				observations: signalObservations{
0000000000000000000000000000000000000000;;					evictionapi.SignalMemoryAvailable: signalObservation{
0000000000000000000000000000000000000000;;						time: metav1.Date(2016, 1, 1, 0, 0, 0, 0, locationUTC),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				last: signalObservations{
0000000000000000000000000000000000000000;;					evictionapi.SignalMemoryAvailable: signalObservation{
0000000000000000000000000000000000000000;;						time: metav1.Date(2016, 1, 1, 0, 0, 0, 0, locationUTC),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"new-observation": {
0000000000000000000000000000000000000000;;				thresholds: []evictionapi.Threshold{updatedThreshold},
0000000000000000000000000000000000000000;;				observations: signalObservations{
0000000000000000000000000000000000000000;;					evictionapi.SignalMemoryAvailable: signalObservation{
0000000000000000000000000000000000000000;;						time: metav1.Date(2016, 1, 1, 0, 1, 0, 0, locationUTC),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				last: signalObservations{
0000000000000000000000000000000000000000;;					evictionapi.SignalMemoryAvailable: signalObservation{
0000000000000000000000000000000000000000;;						time: metav1.Date(2016, 1, 1, 0, 0, 0, 0, locationUTC),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: []evictionapi.Threshold{updatedThreshold},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for testName, testCase := range testCases {
0000000000000000000000000000000000000000;;			actual := thresholdsUpdatedStats(testCase.thresholds, testCase.observations, testCase.last)
0000000000000000000000000000000000000000;;			if !thresholdList(actual).Equal(thresholdList(testCase.result)) {
0000000000000000000000000000000000000000;;				t.Errorf("Test case: %s, expected: %v, actual: %v", testName, testCase.result, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPercentageThresholdsMet(t *testing.T) {
0000000000000000000000000000000000000000;;		specificThresholds := []evictionapi.Threshold{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Signal:   evictionapi.SignalMemoryAvailable,
0000000000000000000000000000000000000000;;				Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;				Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;					Percentage: 0.2,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				MinReclaim: &evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;					Percentage: 0.05,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Signal:   evictionapi.SignalNodeFsAvailable,
0000000000000000000000000000000000000000;;				Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;				Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;					Percentage: 0.3,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			enforceMinRelaim bool
0000000000000000000000000000000000000000;;			thresholds       []evictionapi.Threshold
0000000000000000000000000000000000000000;;			observations     signalObservations
0000000000000000000000000000000000000000;;			result           []evictionapi.Threshold
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"BothMet": {
0000000000000000000000000000000000000000;;				enforceMinRelaim: false,
0000000000000000000000000000000000000000;;				thresholds:       specificThresholds,
0000000000000000000000000000000000000000;;				observations: signalObservations{
0000000000000000000000000000000000000000;;					evictionapi.SignalMemoryAvailable: signalObservation{
0000000000000000000000000000000000000000;;						available: quantityMustParse("100Mi"),
0000000000000000000000000000000000000000;;						capacity:  quantityMustParse("1000Mi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					evictionapi.SignalNodeFsAvailable: signalObservation{
0000000000000000000000000000000000000000;;						available: quantityMustParse("100Gi"),
0000000000000000000000000000000000000000;;						capacity:  quantityMustParse("1000Gi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: specificThresholds,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"NoneMet": {
0000000000000000000000000000000000000000;;				enforceMinRelaim: false,
0000000000000000000000000000000000000000;;				thresholds:       specificThresholds,
0000000000000000000000000000000000000000;;				observations: signalObservations{
0000000000000000000000000000000000000000;;					evictionapi.SignalMemoryAvailable: signalObservation{
0000000000000000000000000000000000000000;;						available: quantityMustParse("300Mi"),
0000000000000000000000000000000000000000;;						capacity:  quantityMustParse("1000Mi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					evictionapi.SignalNodeFsAvailable: signalObservation{
0000000000000000000000000000000000000000;;						available: quantityMustParse("400Gi"),
0000000000000000000000000000000000000000;;						capacity:  quantityMustParse("1000Gi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"DiskMet": {
0000000000000000000000000000000000000000;;				enforceMinRelaim: false,
0000000000000000000000000000000000000000;;				thresholds:       specificThresholds,
0000000000000000000000000000000000000000;;				observations: signalObservations{
0000000000000000000000000000000000000000;;					evictionapi.SignalMemoryAvailable: signalObservation{
0000000000000000000000000000000000000000;;						available: quantityMustParse("300Mi"),
0000000000000000000000000000000000000000;;						capacity:  quantityMustParse("1000Mi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					evictionapi.SignalNodeFsAvailable: signalObservation{
0000000000000000000000000000000000000000;;						available: quantityMustParse("100Gi"),
0000000000000000000000000000000000000000;;						capacity:  quantityMustParse("1000Gi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: []evictionapi.Threshold{specificThresholds[1]},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"MemoryMet": {
0000000000000000000000000000000000000000;;				enforceMinRelaim: false,
0000000000000000000000000000000000000000;;				thresholds:       specificThresholds,
0000000000000000000000000000000000000000;;				observations: signalObservations{
0000000000000000000000000000000000000000;;					evictionapi.SignalMemoryAvailable: signalObservation{
0000000000000000000000000000000000000000;;						available: quantityMustParse("100Mi"),
0000000000000000000000000000000000000000;;						capacity:  quantityMustParse("1000Mi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					evictionapi.SignalNodeFsAvailable: signalObservation{
0000000000000000000000000000000000000000;;						available: quantityMustParse("400Gi"),
0000000000000000000000000000000000000000;;						capacity:  quantityMustParse("1000Gi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: []evictionapi.Threshold{specificThresholds[0]},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"MemoryMetWithMinReclaim": {
0000000000000000000000000000000000000000;;				enforceMinRelaim: true,
0000000000000000000000000000000000000000;;				thresholds:       specificThresholds,
0000000000000000000000000000000000000000;;				observations: signalObservations{
0000000000000000000000000000000000000000;;					evictionapi.SignalMemoryAvailable: signalObservation{
0000000000000000000000000000000000000000;;						available: quantityMustParse("225Mi"),
0000000000000000000000000000000000000000;;						capacity:  quantityMustParse("1000Mi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: []evictionapi.Threshold{specificThresholds[0]},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"MemoryNotMetWithMinReclaim": {
0000000000000000000000000000000000000000;;				enforceMinRelaim: true,
0000000000000000000000000000000000000000;;				thresholds:       specificThresholds,
0000000000000000000000000000000000000000;;				observations: signalObservations{
0000000000000000000000000000000000000000;;					evictionapi.SignalMemoryAvailable: signalObservation{
0000000000000000000000000000000000000000;;						available: quantityMustParse("300Mi"),
0000000000000000000000000000000000000000;;						capacity:  quantityMustParse("1000Mi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for testName, testCase := range testCases {
0000000000000000000000000000000000000000;;			actual := thresholdsMet(testCase.thresholds, testCase.observations, testCase.enforceMinRelaim)
0000000000000000000000000000000000000000;;			if !thresholdList(actual).Equal(thresholdList(testCase.result)) {
0000000000000000000000000000000000000000;;				t.Errorf("Test case: %s, expected: %v, actual: %v", testName, testCase.result, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestThresholdsFirstObservedAt(t *testing.T) {
0000000000000000000000000000000000000000;;		hardThreshold := evictionapi.Threshold{
0000000000000000000000000000000000000000;;			Signal:   evictionapi.SignalMemoryAvailable,
0000000000000000000000000000000000000000;;			Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;			Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;				Quantity: quantityMustParse("1Gi"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		oldTime := metav1.NewTime(now.Time.Add(-1 * time.Minute))
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			thresholds     []evictionapi.Threshold
0000000000000000000000000000000000000000;;			lastObservedAt thresholdsObservedAt
0000000000000000000000000000000000000000;;			now            time.Time
0000000000000000000000000000000000000000;;			result         thresholdsObservedAt
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"empty": {
0000000000000000000000000000000000000000;;				thresholds:     []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;				lastObservedAt: thresholdsObservedAt{},
0000000000000000000000000000000000000000;;				now:            now.Time,
0000000000000000000000000000000000000000;;				result:         thresholdsObservedAt{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no-previous-observation": {
0000000000000000000000000000000000000000;;				thresholds:     []evictionapi.Threshold{hardThreshold},
0000000000000000000000000000000000000000;;				lastObservedAt: thresholdsObservedAt{},
0000000000000000000000000000000000000000;;				now:            now.Time,
0000000000000000000000000000000000000000;;				result: thresholdsObservedAt{
0000000000000000000000000000000000000000;;					hardThreshold: now.Time,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"previous-observation": {
0000000000000000000000000000000000000000;;				thresholds: []evictionapi.Threshold{hardThreshold},
0000000000000000000000000000000000000000;;				lastObservedAt: thresholdsObservedAt{
0000000000000000000000000000000000000000;;					hardThreshold: oldTime.Time,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				now: now.Time,
0000000000000000000000000000000000000000;;				result: thresholdsObservedAt{
0000000000000000000000000000000000000000;;					hardThreshold: oldTime.Time,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for testName, testCase := range testCases {
0000000000000000000000000000000000000000;;			actual := thresholdsFirstObservedAt(testCase.thresholds, testCase.lastObservedAt, testCase.now)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(actual, testCase.result) {
0000000000000000000000000000000000000000;;				t.Errorf("Test case: %s, expected: %v, actual: %v", testName, testCase.result, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestThresholdsMetGracePeriod(t *testing.T) {
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		hardThreshold := evictionapi.Threshold{
0000000000000000000000000000000000000000;;			Signal:   evictionapi.SignalMemoryAvailable,
0000000000000000000000000000000000000000;;			Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;			Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;				Quantity: quantityMustParse("1Gi"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		softThreshold := evictionapi.Threshold{
0000000000000000000000000000000000000000;;			Signal:   evictionapi.SignalMemoryAvailable,
0000000000000000000000000000000000000000;;			Operator: evictionapi.OpLessThan,
0000000000000000000000000000000000000000;;			Value: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;				Quantity: quantityMustParse("2Gi"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			GracePeriod: 1 * time.Minute,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldTime := metav1.NewTime(now.Time.Add(-2 * time.Minute))
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			observedAt thresholdsObservedAt
0000000000000000000000000000000000000000;;			now        time.Time
0000000000000000000000000000000000000000;;			result     []evictionapi.Threshold
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"empty": {
0000000000000000000000000000000000000000;;				observedAt: thresholdsObservedAt{},
0000000000000000000000000000000000000000;;				now:        now.Time,
0000000000000000000000000000000000000000;;				result:     []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"hard-threshold-met": {
0000000000000000000000000000000000000000;;				observedAt: thresholdsObservedAt{
0000000000000000000000000000000000000000;;					hardThreshold: now.Time,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				now:    now.Time,
0000000000000000000000000000000000000000;;				result: []evictionapi.Threshold{hardThreshold},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"soft-threshold-not-met": {
0000000000000000000000000000000000000000;;				observedAt: thresholdsObservedAt{
0000000000000000000000000000000000000000;;					softThreshold: now.Time,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				now:    now.Time,
0000000000000000000000000000000000000000;;				result: []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"soft-threshold-met": {
0000000000000000000000000000000000000000;;				observedAt: thresholdsObservedAt{
0000000000000000000000000000000000000000;;					softThreshold: oldTime.Time,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				now:    now.Time,
0000000000000000000000000000000000000000;;				result: []evictionapi.Threshold{softThreshold},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for testName, testCase := range testCases {
0000000000000000000000000000000000000000;;			actual := thresholdsMetGracePeriod(testCase.observedAt, now.Time)
0000000000000000000000000000000000000000;;			if !thresholdList(actual).Equal(thresholdList(testCase.result)) {
0000000000000000000000000000000000000000;;				t.Errorf("Test case: %s, expected: %v, actual: %v", testName, testCase.result, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNodeConditions(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			inputs []evictionapi.Threshold
0000000000000000000000000000000000000000;;			result []v1.NodeConditionType
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"empty-list": {
0000000000000000000000000000000000000000;;				inputs: []evictionapi.Threshold{},
0000000000000000000000000000000000000000;;				result: []v1.NodeConditionType{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"memory.available": {
0000000000000000000000000000000000000000;;				inputs: []evictionapi.Threshold{
0000000000000000000000000000000000000000;;					{Signal: evictionapi.SignalMemoryAvailable},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: []v1.NodeConditionType{v1.NodeMemoryPressure},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for testName, testCase := range testCases {
0000000000000000000000000000000000000000;;			actual := nodeConditions(testCase.inputs)
0000000000000000000000000000000000000000;;			if !nodeConditionList(actual).Equal(nodeConditionList(testCase.result)) {
0000000000000000000000000000000000000000;;				t.Errorf("Test case: %s, expected: %v, actual: %v", testName, testCase.result, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNodeConditionsLastObservedAt(t *testing.T) {
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		oldTime := metav1.NewTime(now.Time.Add(-1 * time.Minute))
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			nodeConditions []v1.NodeConditionType
0000000000000000000000000000000000000000;;			lastObservedAt nodeConditionsObservedAt
0000000000000000000000000000000000000000;;			now            time.Time
0000000000000000000000000000000000000000;;			result         nodeConditionsObservedAt
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"no-previous-observation": {
0000000000000000000000000000000000000000;;				nodeConditions: []v1.NodeConditionType{v1.NodeMemoryPressure},
0000000000000000000000000000000000000000;;				lastObservedAt: nodeConditionsObservedAt{},
0000000000000000000000000000000000000000;;				now:            now.Time,
0000000000000000000000000000000000000000;;				result: nodeConditionsObservedAt{
0000000000000000000000000000000000000000;;					v1.NodeMemoryPressure: now.Time,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"previous-observation": {
0000000000000000000000000000000000000000;;				nodeConditions: []v1.NodeConditionType{v1.NodeMemoryPressure},
0000000000000000000000000000000000000000;;				lastObservedAt: nodeConditionsObservedAt{
0000000000000000000000000000000000000000;;					v1.NodeMemoryPressure: oldTime.Time,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				now: now.Time,
0000000000000000000000000000000000000000;;				result: nodeConditionsObservedAt{
0000000000000000000000000000000000000000;;					v1.NodeMemoryPressure: now.Time,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"old-observation": {
0000000000000000000000000000000000000000;;				nodeConditions: []v1.NodeConditionType{},
0000000000000000000000000000000000000000;;				lastObservedAt: nodeConditionsObservedAt{
0000000000000000000000000000000000000000;;					v1.NodeMemoryPressure: oldTime.Time,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				now: now.Time,
0000000000000000000000000000000000000000;;				result: nodeConditionsObservedAt{
0000000000000000000000000000000000000000;;					v1.NodeMemoryPressure: oldTime.Time,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for testName, testCase := range testCases {
0000000000000000000000000000000000000000;;			actual := nodeConditionsLastObservedAt(testCase.nodeConditions, testCase.lastObservedAt, testCase.now)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(actual, testCase.result) {
0000000000000000000000000000000000000000;;				t.Errorf("Test case: %s, expected: %v, actual: %v", testName, testCase.result, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNodeConditionsObservedSince(t *testing.T) {
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		observedTime := metav1.NewTime(now.Time.Add(-1 * time.Minute))
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			observedAt nodeConditionsObservedAt
0000000000000000000000000000000000000000;;			period     time.Duration
0000000000000000000000000000000000000000;;			now        time.Time
0000000000000000000000000000000000000000;;			result     []v1.NodeConditionType
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"in-period": {
0000000000000000000000000000000000000000;;				observedAt: nodeConditionsObservedAt{
0000000000000000000000000000000000000000;;					v1.NodeMemoryPressure: observedTime.Time,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				period: 2 * time.Minute,
0000000000000000000000000000000000000000;;				now:    now.Time,
0000000000000000000000000000000000000000;;				result: []v1.NodeConditionType{v1.NodeMemoryPressure},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"out-of-period": {
0000000000000000000000000000000000000000;;				observedAt: nodeConditionsObservedAt{
0000000000000000000000000000000000000000;;					v1.NodeMemoryPressure: observedTime.Time,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				period: 30 * time.Second,
0000000000000000000000000000000000000000;;				now:    now.Time,
0000000000000000000000000000000000000000;;				result: []v1.NodeConditionType{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for testName, testCase := range testCases {
0000000000000000000000000000000000000000;;			actual := nodeConditionsObservedSince(testCase.observedAt, testCase.period, testCase.now)
0000000000000000000000000000000000000000;;			if !nodeConditionList(actual).Equal(nodeConditionList(testCase.result)) {
0000000000000000000000000000000000000000;;				t.Errorf("Test case: %s, expected: %v, actual: %v", testName, testCase.result, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHasNodeConditions(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			inputs []v1.NodeConditionType
0000000000000000000000000000000000000000;;			item   v1.NodeConditionType
0000000000000000000000000000000000000000;;			result bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"has-condition": {
0000000000000000000000000000000000000000;;				inputs: []v1.NodeConditionType{v1.NodeReady, v1.NodeOutOfDisk, v1.NodeMemoryPressure},
0000000000000000000000000000000000000000;;				item:   v1.NodeMemoryPressure,
0000000000000000000000000000000000000000;;				result: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"does-not-have-condition": {
0000000000000000000000000000000000000000;;				inputs: []v1.NodeConditionType{v1.NodeReady, v1.NodeOutOfDisk},
0000000000000000000000000000000000000000;;				item:   v1.NodeMemoryPressure,
0000000000000000000000000000000000000000;;				result: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for testName, testCase := range testCases {
0000000000000000000000000000000000000000;;			if actual := hasNodeCondition(testCase.inputs, testCase.item); actual != testCase.result {
0000000000000000000000000000000000000000;;				t.Errorf("Test case: %s, expected: %v, actual: %v", testName, testCase.result, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetStarvedResources(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			inputs []evictionapi.Threshold
0000000000000000000000000000000000000000;;			result []v1.ResourceName
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"memory.available": {
0000000000000000000000000000000000000000;;				inputs: []evictionapi.Threshold{
0000000000000000000000000000000000000000;;					{Signal: evictionapi.SignalMemoryAvailable},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: []v1.ResourceName{v1.ResourceMemory},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"imagefs.available": {
0000000000000000000000000000000000000000;;				inputs: []evictionapi.Threshold{
0000000000000000000000000000000000000000;;					{Signal: evictionapi.SignalImageFsAvailable},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: []v1.ResourceName{resourceImageFs},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"nodefs.available": {
0000000000000000000000000000000000000000;;				inputs: []evictionapi.Threshold{
0000000000000000000000000000000000000000;;					{Signal: evictionapi.SignalNodeFsAvailable},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: []v1.ResourceName{resourceNodeFs},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var internalResourceNames = func(in []v1.ResourceName) []api.ResourceName {
0000000000000000000000000000000000000000;;			var out []api.ResourceName
0000000000000000000000000000000000000000;;			for _, name := range in {
0000000000000000000000000000000000000000;;				out = append(out, api.ResourceName(name))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for testName, testCase := range testCases {
0000000000000000000000000000000000000000;;			actual := getStarvedResources(testCase.inputs)
0000000000000000000000000000000000000000;;			actualSet := quota.ToSet(internalResourceNames(actual))
0000000000000000000000000000000000000000;;			expectedSet := quota.ToSet(internalResourceNames(testCase.result))
0000000000000000000000000000000000000000;;			if !actualSet.Equal(expectedSet) {
0000000000000000000000000000000000000000;;				t.Errorf("Test case: %s, expected: %v, actual: %v", testName, expectedSet, actualSet)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testParsePercentage(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			hasError bool
0000000000000000000000000000000000000000;;			value    float32
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"blah": {
0000000000000000000000000000000000000000;;				hasError: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"25.5%": {
0000000000000000000000000000000000000000;;				value: 0.255,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"foo%": {
0000000000000000000000000000000000000000;;				hasError: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"12%345": {
0000000000000000000000000000000000000000;;				hasError: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for input, expected := range testCases {
0000000000000000000000000000000000000000;;			value, err := parsePercentage(input)
0000000000000000000000000000000000000000;;			if (err != nil) != expected.hasError {
0000000000000000000000000000000000000000;;				t.Errorf("Test case: %s, expected: %v, actual: %v", input, expected.hasError, err != nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if value != expected.value {
0000000000000000000000000000000000000000;;				t.Errorf("Test case: %s, expected: %v, actual: %v", input, expected.value, value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testCompareThresholdValue(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			a, b  evictionapi.ThresholdValue
0000000000000000000000000000000000000000;;			equal bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				a: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;					Quantity: resource.NewQuantity(123, resource.BinarySI),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				b: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;					Quantity: resource.NewQuantity(123, resource.BinarySI),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				equal: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				a: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;					Quantity: resource.NewQuantity(123, resource.BinarySI),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				b: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;					Quantity: resource.NewQuantity(456, resource.BinarySI),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				equal: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				a: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;					Quantity: resource.NewQuantity(123, resource.BinarySI),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				b: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;					Percentage: 0.1,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				equal: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				a: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;					Percentage: 0.1,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				b: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;					Percentage: 0.1,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				equal: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				a: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;					Percentage: 0.2,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				b: evictionapi.ThresholdValue{
0000000000000000000000000000000000000000;;					Percentage: 0.1,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				equal: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			if compareThresholdValue(testCase.a, testCase.b) != testCase.equal ||
0000000000000000000000000000000000000000;;				compareThresholdValue(testCase.b, testCase.a) != testCase.equal {
0000000000000000000000000000000000000000;;				t.Errorf("Test case: %v failed", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newPodInodeStats returns stats with specified usage amounts.
0000000000000000000000000000000000000000;;	func newPodInodeStats(pod *v1.Pod, rootFsInodesUsed, logsInodesUsed, perLocalVolumeInodesUsed resource.Quantity) statsapi.PodStats {
0000000000000000000000000000000000000000;;		result := statsapi.PodStats{
0000000000000000000000000000000000000000;;			PodRef: statsapi.PodReference{
0000000000000000000000000000000000000000;;				Name: pod.Name, Namespace: pod.Namespace, UID: string(pod.UID),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rootFsUsed := uint64(rootFsInodesUsed.Value())
0000000000000000000000000000000000000000;;		logsUsed := uint64(logsInodesUsed.Value())
0000000000000000000000000000000000000000;;		for range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			result.Containers = append(result.Containers, statsapi.ContainerStats{
0000000000000000000000000000000000000000;;				Rootfs: &statsapi.FsStats{
0000000000000000000000000000000000000000;;					InodesUsed: &rootFsUsed,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Logs: &statsapi.FsStats{
0000000000000000000000000000000000000000;;					InodesUsed: &logsUsed,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		perLocalVolumeUsed := uint64(perLocalVolumeInodesUsed.Value())
0000000000000000000000000000000000000000;;		for _, volumeName := range localVolumeNames(pod) {
0000000000000000000000000000000000000000;;			result.VolumeStats = append(result.VolumeStats, statsapi.VolumeStats{
0000000000000000000000000000000000000000;;				Name: volumeName,
0000000000000000000000000000000000000000;;				FsStats: statsapi.FsStats{
0000000000000000000000000000000000000000;;					InodesUsed: &perLocalVolumeUsed,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newPodDiskStats returns stats with specified usage amounts.
0000000000000000000000000000000000000000;;	func newPodDiskStats(pod *v1.Pod, rootFsUsed, logsUsed, perLocalVolumeUsed resource.Quantity) statsapi.PodStats {
0000000000000000000000000000000000000000;;		result := statsapi.PodStats{
0000000000000000000000000000000000000000;;			PodRef: statsapi.PodReference{
0000000000000000000000000000000000000000;;				Name: pod.Name, Namespace: pod.Namespace, UID: string(pod.UID),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rootFsUsedBytes := uint64(rootFsUsed.Value())
0000000000000000000000000000000000000000;;		logsUsedBytes := uint64(logsUsed.Value())
0000000000000000000000000000000000000000;;		for range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			result.Containers = append(result.Containers, statsapi.ContainerStats{
0000000000000000000000000000000000000000;;				Rootfs: &statsapi.FsStats{
0000000000000000000000000000000000000000;;					UsedBytes: &rootFsUsedBytes,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Logs: &statsapi.FsStats{
0000000000000000000000000000000000000000;;					UsedBytes: &logsUsedBytes,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		perLocalVolumeUsedBytes := uint64(perLocalVolumeUsed.Value())
0000000000000000000000000000000000000000;;		for _, volumeName := range localVolumeNames(pod) {
0000000000000000000000000000000000000000;;			result.VolumeStats = append(result.VolumeStats, statsapi.VolumeStats{
0000000000000000000000000000000000000000;;				Name: volumeName,
0000000000000000000000000000000000000000;;				FsStats: statsapi.FsStats{
0000000000000000000000000000000000000000;;					UsedBytes: &perLocalVolumeUsedBytes,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPodMemoryStats(pod *v1.Pod, workingSet resource.Quantity) statsapi.PodStats {
0000000000000000000000000000000000000000;;		result := statsapi.PodStats{
0000000000000000000000000000000000000000;;			PodRef: statsapi.PodReference{
0000000000000000000000000000000000000000;;				Name: pod.Name, Namespace: pod.Namespace, UID: string(pod.UID),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			workingSetBytes := uint64(workingSet.Value())
0000000000000000000000000000000000000000;;			result.Containers = append(result.Containers, statsapi.ContainerStats{
0000000000000000000000000000000000000000;;				Memory: &statsapi.MemoryStats{
0000000000000000000000000000000000000000;;					WorkingSetBytes: &workingSetBytes,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newResourceList(cpu, memory string) v1.ResourceList {
0000000000000000000000000000000000000000;;		res := v1.ResourceList{}
0000000000000000000000000000000000000000;;		if cpu != "" {
0000000000000000000000000000000000000000;;			res[v1.ResourceCPU] = resource.MustParse(cpu)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if memory != "" {
0000000000000000000000000000000000000000;;			res[v1.ResourceMemory] = resource.MustParse(memory)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newResourceRequirements(requests, limits v1.ResourceList) v1.ResourceRequirements {
0000000000000000000000000000000000000000;;		res := v1.ResourceRequirements{}
0000000000000000000000000000000000000000;;		res.Requests = requests
0000000000000000000000000000000000000000;;		res.Limits = limits
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newContainer(name string, requests v1.ResourceList, limits v1.ResourceList) v1.Container {
0000000000000000000000000000000000000000;;		return v1.Container{
0000000000000000000000000000000000000000;;			Name:      name,
0000000000000000000000000000000000000000;;			Resources: newResourceRequirements(requests, limits),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newVolume(name string, volumeSource v1.VolumeSource) v1.Volume {
0000000000000000000000000000000000000000;;		return v1.Volume{
0000000000000000000000000000000000000000;;			Name:         name,
0000000000000000000000000000000000000000;;			VolumeSource: volumeSource,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newPod uses the name as the uid.  Make names unique for testing.
0000000000000000000000000000000000000000;;	func newPod(name string, containers []v1.Container, volumes []v1.Volume) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;				UID:  types.UID(name),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: containers,
0000000000000000000000000000000000000000;;				Volumes:    volumes,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nodeConditionList is a simple alias to support equality checking independent of order
0000000000000000000000000000000000000000;;	type nodeConditionList []v1.NodeConditionType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal adds the ability to check equality between two lists of node conditions.
0000000000000000000000000000000000000000;;	func (s1 nodeConditionList) Equal(s2 nodeConditionList) bool {
0000000000000000000000000000000000000000;;		if len(s1) != len(s2) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range s1 {
0000000000000000000000000000000000000000;;			if !hasNodeCondition(s2, item) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// thresholdList is a simple alias to support equality checking independent of order
0000000000000000000000000000000000000000;;	type thresholdList []evictionapi.Threshold
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal adds the ability to check equality between two lists of node conditions.
0000000000000000000000000000000000000000;;	func (s1 thresholdList) Equal(s2 thresholdList) bool {
0000000000000000000000000000000000000000;;		if len(s1) != len(s2) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range s1 {
0000000000000000000000000000000000000000;;			if !hasThreshold(s2, item) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
