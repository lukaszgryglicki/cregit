0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
96cc0858fcb19dd6e42f142f0a581e167be1fab0;pkg/kubelet/api/testing/fake_image_service.go[pkg/kubelet/api/testing/fake_image_service.go][pkg/kubelet/apis/cri/testing/fake_image_service.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package testing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/sliceutils"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeImageService struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		FakeImageSize uint64
0000000000000000000000000000000000000000;;		Called        []string
0000000000000000000000000000000000000000;;		Images        map[string]*runtimeapi.Image
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pulledImages []*pulledImage
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *FakeImageService) SetFakeImages(images []string) {
0000000000000000000000000000000000000000;;		r.Lock()
0000000000000000000000000000000000000000;;		defer r.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.Images = make(map[string]*runtimeapi.Image)
0000000000000000000000000000000000000000;;		for _, image := range images {
0000000000000000000000000000000000000000;;			r.Images[image] = r.makeFakeImage(image)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *FakeImageService) SetFakeImageSize(size uint64) {
0000000000000000000000000000000000000000;;		r.Lock()
0000000000000000000000000000000000000000;;		defer r.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.FakeImageSize = size
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakeImageService() *FakeImageService {
0000000000000000000000000000000000000000;;		return &FakeImageService{
0000000000000000000000000000000000000000;;			Called: make([]string, 0),
0000000000000000000000000000000000000000;;			Images: make(map[string]*runtimeapi.Image),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *FakeImageService) makeFakeImage(image string) *runtimeapi.Image {
0000000000000000000000000000000000000000;;		return &runtimeapi.Image{
0000000000000000000000000000000000000000;;			Id:       image,
0000000000000000000000000000000000000000;;			Size_:    r.FakeImageSize,
0000000000000000000000000000000000000000;;			RepoTags: []string{image},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *FakeImageService) ListImages(filter *runtimeapi.ImageFilter) ([]*runtimeapi.Image, error) {
0000000000000000000000000000000000000000;;		r.Lock()
0000000000000000000000000000000000000000;;		defer r.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.Called = append(r.Called, "ListImages")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		images := make([]*runtimeapi.Image, 0)
0000000000000000000000000000000000000000;;		for _, img := range r.Images {
0000000000000000000000000000000000000000;;			if filter != nil && filter.Image != nil {
0000000000000000000000000000000000000000;;				if !sliceutils.StringInSlice(filter.Image.Image, img.RepoTags) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			images = append(images, img)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return images, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *FakeImageService) ImageStatus(image *runtimeapi.ImageSpec) (*runtimeapi.Image, error) {
0000000000000000000000000000000000000000;;		r.Lock()
0000000000000000000000000000000000000000;;		defer r.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.Called = append(r.Called, "ImageStatus")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.Images[image.Image], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *FakeImageService) PullImage(image *runtimeapi.ImageSpec, auth *runtimeapi.AuthConfig) (string, error) {
0000000000000000000000000000000000000000;;		r.Lock()
0000000000000000000000000000000000000000;;		defer r.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.Called = append(r.Called, "PullImage")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.pulledImages = append(r.pulledImages, &pulledImage{imageSpec: image, authConfig: auth})
0000000000000000000000000000000000000000;;		// ImageID should be randomized for real container runtime, but here just use
0000000000000000000000000000000000000000;;		// image's name for easily making fake images.
0000000000000000000000000000000000000000;;		imageID := image.Image
0000000000000000000000000000000000000000;;		if _, ok := r.Images[imageID]; !ok {
0000000000000000000000000000000000000000;;			r.Images[imageID] = r.makeFakeImage(image.Image)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return imageID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *FakeImageService) RemoveImage(image *runtimeapi.ImageSpec) error {
0000000000000000000000000000000000000000;;		r.Lock()
0000000000000000000000000000000000000000;;		defer r.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.Called = append(r.Called, "RemoveImage")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove the image
0000000000000000000000000000000000000000;;		delete(r.Images, image.Image)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ImageFsInfo returns information of the filesystem that is used to store images.
0000000000000000000000000000000000000000;;	func (r *FakeImageService) ImageFsInfo(req *runtimeapi.ImageFsInfoRequest) (*runtimeapi.ImageFsInfoResponse, error) {
0000000000000000000000000000000000000000;;		r.Lock()
0000000000000000000000000000000000000000;;		defer r.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.Called = append(r.Called, "ImageFsInfo")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *FakeImageService) AssertImagePulledWithAuth(t *testing.T, image *runtimeapi.ImageSpec, auth *runtimeapi.AuthConfig, failMsg string) {
0000000000000000000000000000000000000000;;		r.Lock()
0000000000000000000000000000000000000000;;		defer r.Unlock()
0000000000000000000000000000000000000000;;		expected := &pulledImage{imageSpec: image, authConfig: auth}
0000000000000000000000000000000000000000;;		assert.Contains(t, r.pulledImages, expected, failMsg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pulledImage struct {
0000000000000000000000000000000000000000;;		imageSpec  *runtimeapi.ImageSpec
0000000000000000000000000000000000000000;;		authConfig *runtimeapi.AuthConfig
0000000000000000000000000000000000000000;;	}
