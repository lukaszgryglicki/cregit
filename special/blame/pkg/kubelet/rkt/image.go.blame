0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
d57e7433a4b25fbceb4c79b5ca151fab535a0289;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file contains all image related functions for rkt runtime.
0000000000000000000000000000000000000000;;	package rkt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		appcschema "github.com/appc/spec/schema"
0000000000000000000000000000000000000000;;		appctypes "github.com/appc/spec/schema/types"
0000000000000000000000000000000000000000;;		rktapi "github.com/coreos/rkt/api/v1alpha"
0000000000000000000000000000000000000000;;		dockertypes "github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/credentialprovider"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/parsers"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PullImage invokes 'rkt fetch' to download an aci.
0000000000000000000000000000000000000000;;	// TODO(yifan): Now we only support docker images, this should be changed
0000000000000000000000000000000000000000;;	// once the format of image is landed, see:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://issue.k8s.io/7203
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (r *Runtime) PullImage(image kubecontainer.ImageSpec, pullSecrets []v1.Secret) (string, error) {
0000000000000000000000000000000000000000;;		img := image.Image
0000000000000000000000000000000000000000;;		// TODO(yifan): The credential operation is a copy from dockertools package,
0000000000000000000000000000000000000000;;		// Need to resolve the code duplication.
0000000000000000000000000000000000000000;;		repoToPull, _, _, err := parsers.ParseImageName(img)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyring, err := credentialprovider.MakeDockerKeyring(pullSecrets, r.dockerKeyring)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		creds, ok := keyring.Lookup(repoToPull)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.V(1).Infof("Pulling image %s without credentials", img)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		userConfigDir, err := ioutil.TempDir("", "rktnetes-user-config-dir-")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("rkt: Cannot create a temporary user-config directory: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(userConfigDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := *r.config
0000000000000000000000000000000000000000;;		config.UserConfigDir = userConfigDir
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := r.writeDockerAuthConfig(img, creds, userConfigDir); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Today, `--no-store` will fetch the remote image regardless of whether the content of the image
0000000000000000000000000000000000000000;;		// has changed or not. This causes performance downgrades when the image tag is ':latest' and
0000000000000000000000000000000000000000;;		// the image pull policy is 'always'. The issue is tracked in https://github.com/coreos/rkt/issues/2937.
0000000000000000000000000000000000000000;;		if _, err := r.cli.RunCommand(&config, "fetch", "--no-store", dockerPrefix+img); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to fetch: %v", err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.getImageID(img)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Runtime) GetImageRef(image kubecontainer.ImageSpec) (string, error) {
0000000000000000000000000000000000000000;;		images, err := r.listImages(image.Image, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(images) == 0 {
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return images[0].Id, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListImages lists all the available appc images on the machine by invoking 'rkt image list'.
0000000000000000000000000000000000000000;;	func (r *Runtime) ListImages() ([]kubecontainer.Image, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithTimeout(context.Background(), r.requestTimeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		listResp, err := r.apisvc.ListImages(ctx, &rktapi.ListImagesRequest{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't list images: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		images := make([]kubecontainer.Image, len(listResp.Images))
0000000000000000000000000000000000000000;;		for i, image := range listResp.Images {
0000000000000000000000000000000000000000;;			images[i] = kubecontainer.Image{
0000000000000000000000000000000000000000;;				ID:       image.Id,
0000000000000000000000000000000000000000;;				RepoTags: []string{buildImageName(image)},
0000000000000000000000000000000000000000;;				Size:     image.Size,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return images, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveImage removes an on-disk image using 'rkt image rm'.
0000000000000000000000000000000000000000;;	func (r *Runtime) RemoveImage(image kubecontainer.ImageSpec) error {
0000000000000000000000000000000000000000;;		imageID, err := r.getImageID(image.Image)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := r.cli.RunCommand(nil, "image", "rm", imageID); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildImageName constructs the image name for kubecontainer.Image.
0000000000000000000000000000000000000000;;	// If the annotations contain the docker2aci metadata for this image, those are
0000000000000000000000000000000000000000;;	// used instead as they may be more accurate in some cases, namely if a
0000000000000000000000000000000000000000;;	// non-appc valid character is present
0000000000000000000000000000000000000000;;	func buildImageName(img *rktapi.Image) string {
0000000000000000000000000000000000000000;;		registry := ""
0000000000000000000000000000000000000000;;		repository := ""
0000000000000000000000000000000000000000;;		for _, anno := range img.Annotations {
0000000000000000000000000000000000000000;;			if anno.Key == appcDockerRegistryURL {
0000000000000000000000000000000000000000;;				registry = anno.Value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if anno.Key == appcDockerRepository {
0000000000000000000000000000000000000000;;				repository = anno.Value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if registry != "" && repository != "" {
0000000000000000000000000000000000000000;;			// TODO(euank): This could do the special casing for dockerhub and library images
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%s/%s:%s", registry, repository, img.Version)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s:%s", img.Name, img.Version)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getImageID tries to find the image ID for the given image name.
0000000000000000000000000000000000000000;;	// imageName should be in the form of 'name[:version]', e.g., 'example.com/app:latest'.
0000000000000000000000000000000000000000;;	// The name should matches the result of 'rkt image list'. If the version is empty,
0000000000000000000000000000000000000000;;	// then 'latest' is assumed.
0000000000000000000000000000000000000000;;	func (r *Runtime) getImageID(imageName string) (string, error) {
0000000000000000000000000000000000000000;;		images, err := r.listImages(imageName, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(images) == 0 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("cannot find the image %q", imageName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return images[0].Id, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sortByImportTime []*rktapi.Image
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s sortByImportTime) Len() int           { return len(s) }
0000000000000000000000000000000000000000;;	func (s sortByImportTime) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }
0000000000000000000000000000000000000000;;	func (s sortByImportTime) Less(i, j int) bool { return s[i].ImportTimestamp < s[j].ImportTimestamp }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// listImages lists the images that have the given name. If detail is true,
0000000000000000000000000000000000000000;;	// then image manifest is also included in the result.
0000000000000000000000000000000000000000;;	// Note that there could be more than one images that have the given name, we
0000000000000000000000000000000000000000;;	// will return the result reversely sorted by the import time, so that the latest
0000000000000000000000000000000000000000;;	// image comes first.
0000000000000000000000000000000000000000;;	func (r *Runtime) listImages(image string, detail bool) ([]*rktapi.Image, error) {
0000000000000000000000000000000000000000;;		repoToPull, tag, _, err := parsers.ParseImageName(image)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		imageFilters := []*rktapi.ImageFilter{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// TODO(yifan): Add a field in the ImageFilter to match the whole name,
0000000000000000000000000000000000000000;;				// not just keywords.
0000000000000000000000000000000000000000;;				// https://github.com/coreos/rkt/issues/1872#issuecomment-166456938
0000000000000000000000000000000000000000;;				Keywords: []string{repoToPull},
0000000000000000000000000000000000000000;;				Labels:   []*rktapi.KeyValue{{Key: "version", Value: tag}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the repo name is not a valid ACIdentifier (namely if it has a port),
0000000000000000000000000000000000000000;;		// then it will have a different name in the store. Search for both the
0000000000000000000000000000000000000000;;		// original name and this modified name in case we choose to also change the
0000000000000000000000000000000000000000;;		// api-service to do this un-conversion on its end.
0000000000000000000000000000000000000000;;		if appcRepoToPull, err := appctypes.SanitizeACIdentifier(repoToPull); err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("could not convert %v to an aci identifier: %v", err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			imageFilters = append(imageFilters, &rktapi.ImageFilter{
0000000000000000000000000000000000000000;;				Keywords: []string{appcRepoToPull},
0000000000000000000000000000000000000000;;				Labels:   []*rktapi.KeyValue{{Key: "version", Value: tag}},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithTimeout(context.Background(), r.requestTimeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		listResp, err := r.apisvc.ListImages(ctx, &rktapi.ListImagesRequest{
0000000000000000000000000000000000000000;;			Detail:  detail,
0000000000000000000000000000000000000000;;			Filters: imageFilters,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't list images: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(yifan): Let the API service to sort the result:
0000000000000000000000000000000000000000;;		// See https://github.com/coreos/rkt/issues/1911.
0000000000000000000000000000000000000000;;		sort.Sort(sort.Reverse(sortByImportTime(listResp.Images)))
0000000000000000000000000000000000000000;;		return listResp.Images, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getImageManifest retrieves the image manifest for the given image.
0000000000000000000000000000000000000000;;	func (r *Runtime) getImageManifest(image string) (*appcschema.ImageManifest, error) {
0000000000000000000000000000000000000000;;		var manifest appcschema.ImageManifest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		images, err := r.listImages(image, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(images) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cannot find the image %q", image)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &manifest, json.Unmarshal(images[0].Manifest, &manifest)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(yifan): This is very racy, inefficient, and unsafe, we need to provide
0000000000000000000000000000000000000000;;	// different namespaces. See: https://github.com/coreos/rkt/issues/836.
0000000000000000000000000000000000000000;;	func (r *Runtime) writeDockerAuthConfig(image string, credsSlice []credentialprovider.LazyAuthConfiguration, userConfigDir string) error {
0000000000000000000000000000000000000000;;		if len(credsSlice) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		creds := dockertypes.AuthConfig{}
0000000000000000000000000000000000000000;;		// TODO handle multiple creds
0000000000000000000000000000000000000000;;		if len(credsSlice) >= 1 {
0000000000000000000000000000000000000000;;			creds = credentialprovider.LazyProvide(credsSlice[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		registry := "index.docker.io"
0000000000000000000000000000000000000000;;		// Image spec: [<registry>/]<repository>/<image>[:<version]
0000000000000000000000000000000000000000;;		explicitRegistry := (strings.Count(image, "/") == 2)
0000000000000000000000000000000000000000;;		if explicitRegistry {
0000000000000000000000000000000000000000;;			registry = strings.Split(image, "/")[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authDir := filepath.Join(userConfigDir, "auth.d")
0000000000000000000000000000000000000000;;		if _, err := os.Stat(authDir); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			if err := os.MkdirAll(authDir, 0600); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("rkt: Cannot create auth dir: %v", err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := fmt.Sprintf(dockerAuthTemplate, registry, creds.Username, creds.Password)
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(path.Join(authDir, registry+".json"), []byte(config), 0600); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("rkt: Cannot write docker auth config file: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ImageStats returns the image stat (total storage bytes).
0000000000000000000000000000000000000000;;	func (r *Runtime) ImageStats() (*kubecontainer.ImageStats, error) {
0000000000000000000000000000000000000000;;		var imageStat kubecontainer.ImageStats
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithTimeout(context.Background(), r.requestTimeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		listResp, err := r.apisvc.ListImages(ctx, &rktapi.ListImagesRequest{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't list images: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, image := range listResp.Images {
0000000000000000000000000000000000000000;;			imageStat.TotalStorageBytes = imageStat.TotalStorageBytes + uint64(image.Size)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &imageStat, nil
0000000000000000000000000000000000000000;;	}
