0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
28a401c581e2c5c431c895d1186f9cd05186d445;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package pleg
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		containertest "k8s.io/kubernetes/pkg/kubelet/container/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		testContainerRuntimeType = "fooRuntime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TestGenericPLEG struct {
0000000000000000000000000000000000000000;;		pleg    *GenericPLEG
0000000000000000000000000000000000000000;;		runtime *containertest.FakeRuntime
0000000000000000000000000000000000000000;;		clock   *clock.FakeClock
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestGenericPLEG() *TestGenericPLEG {
0000000000000000000000000000000000000000;;		fakeRuntime := &containertest.FakeRuntime{}
0000000000000000000000000000000000000000;;		clock := clock.NewFakeClock(time.Time{})
0000000000000000000000000000000000000000;;		// The channel capacity should be large enough to hold all events in a
0000000000000000000000000000000000000000;;		// single test.
0000000000000000000000000000000000000000;;		pleg := &GenericPLEG{
0000000000000000000000000000000000000000;;			relistPeriod: time.Hour,
0000000000000000000000000000000000000000;;			runtime:      fakeRuntime,
0000000000000000000000000000000000000000;;			eventChannel: make(chan *PodLifecycleEvent, 100),
0000000000000000000000000000000000000000;;			podRecords:   make(podRecords),
0000000000000000000000000000000000000000;;			clock:        clock,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &TestGenericPLEG{pleg: pleg, runtime: fakeRuntime, clock: clock}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getEventsFromChannel(ch <-chan *PodLifecycleEvent) []*PodLifecycleEvent {
0000000000000000000000000000000000000000;;		events := []*PodLifecycleEvent{}
0000000000000000000000000000000000000000;;		for len(ch) > 0 {
0000000000000000000000000000000000000000;;			e := <-ch
0000000000000000000000000000000000000000;;			events = append(events, e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return events
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createTestContainer(ID string, state kubecontainer.ContainerState) *kubecontainer.Container {
0000000000000000000000000000000000000000;;		return &kubecontainer.Container{
0000000000000000000000000000000000000000;;			ID:    kubecontainer.ContainerID{Type: testContainerRuntimeType, ID: ID},
0000000000000000000000000000000000000000;;			State: state,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sortableEvents []*PodLifecycleEvent
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a sortableEvents) Len() int      { return len(a) }
0000000000000000000000000000000000000000;;	func (a sortableEvents) Swap(i, j int) { a[i], a[j] = a[j], a[i] }
0000000000000000000000000000000000000000;;	func (a sortableEvents) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		if a[i].ID != a[j].ID {
0000000000000000000000000000000000000000;;			return a[i].ID < a[j].ID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a[i].Data.(string) < a[j].Data.(string)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyEvents(t *testing.T, expected, actual []*PodLifecycleEvent) {
0000000000000000000000000000000000000000;;		sort.Sort(sortableEvents(expected))
0000000000000000000000000000000000000000;;		sort.Sort(sortableEvents(actual))
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(expected, actual) {
0000000000000000000000000000000000000000;;			t.Errorf("Actual events differ from the expected; diff:\n %v", diff.ObjectDiff(expected, actual))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRelisting(t *testing.T) {
0000000000000000000000000000000000000000;;		testPleg := newTestGenericPLEG()
0000000000000000000000000000000000000000;;		pleg, runtime := testPleg.pleg, testPleg.runtime
0000000000000000000000000000000000000000;;		ch := pleg.Watch()
0000000000000000000000000000000000000000;;		// The first relist should send a PodSync event to each pod.
0000000000000000000000000000000000000000;;		runtime.AllPodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;			{Pod: &kubecontainer.Pod{
0000000000000000000000000000000000000000;;				ID: "1234",
0000000000000000000000000000000000000000;;				Containers: []*kubecontainer.Container{
0000000000000000000000000000000000000000;;					createTestContainer("c1", kubecontainer.ContainerStateExited),
0000000000000000000000000000000000000000;;					createTestContainer("c2", kubecontainer.ContainerStateRunning),
0000000000000000000000000000000000000000;;					createTestContainer("c3", kubecontainer.ContainerStateUnknown),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			{Pod: &kubecontainer.Pod{
0000000000000000000000000000000000000000;;				ID: "4567",
0000000000000000000000000000000000000000;;				Containers: []*kubecontainer.Container{
0000000000000000000000000000000000000000;;					createTestContainer("c1", kubecontainer.ContainerStateExited),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pleg.relist()
0000000000000000000000000000000000000000;;		// Report every running/exited container if we see them for the first time.
0000000000000000000000000000000000000000;;		expected := []*PodLifecycleEvent{
0000000000000000000000000000000000000000;;			{ID: "1234", Type: ContainerStarted, Data: "c2"},
0000000000000000000000000000000000000000;;			{ID: "4567", Type: ContainerDied, Data: "c1"},
0000000000000000000000000000000000000000;;			{ID: "1234", Type: ContainerDied, Data: "c1"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		actual := getEventsFromChannel(ch)
0000000000000000000000000000000000000000;;		verifyEvents(t, expected, actual)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The second relist should not send out any event because no container has
0000000000000000000000000000000000000000;;		// changed.
0000000000000000000000000000000000000000;;		pleg.relist()
0000000000000000000000000000000000000000;;		verifyEvents(t, expected, actual)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runtime.AllPodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;			{Pod: &kubecontainer.Pod{
0000000000000000000000000000000000000000;;				ID: "1234",
0000000000000000000000000000000000000000;;				Containers: []*kubecontainer.Container{
0000000000000000000000000000000000000000;;					createTestContainer("c2", kubecontainer.ContainerStateExited),
0000000000000000000000000000000000000000;;					createTestContainer("c3", kubecontainer.ContainerStateRunning),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			{Pod: &kubecontainer.Pod{
0000000000000000000000000000000000000000;;				ID: "4567",
0000000000000000000000000000000000000000;;				Containers: []*kubecontainer.Container{
0000000000000000000000000000000000000000;;					createTestContainer("c4", kubecontainer.ContainerStateRunning),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pleg.relist()
0000000000000000000000000000000000000000;;		// Only report containers that transitioned to running or exited status.
0000000000000000000000000000000000000000;;		expected = []*PodLifecycleEvent{
0000000000000000000000000000000000000000;;			{ID: "1234", Type: ContainerRemoved, Data: "c1"},
0000000000000000000000000000000000000000;;			{ID: "1234", Type: ContainerDied, Data: "c2"},
0000000000000000000000000000000000000000;;			{ID: "1234", Type: ContainerStarted, Data: "c3"},
0000000000000000000000000000000000000000;;			{ID: "4567", Type: ContainerRemoved, Data: "c1"},
0000000000000000000000000000000000000000;;			{ID: "4567", Type: ContainerStarted, Data: "c4"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actual = getEventsFromChannel(ch)
0000000000000000000000000000000000000000;;		verifyEvents(t, expected, actual)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDetectingContainerDeaths(t *testing.T) {
0000000000000000000000000000000000000000;;		// Vary the number of relists after the container started and before the
0000000000000000000000000000000000000000;;		// container died to account for the changes in pleg's internal states.
0000000000000000000000000000000000000000;;		testReportMissingContainers(t, 1)
0000000000000000000000000000000000000000;;		testReportMissingPods(t, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testReportMissingContainers(t, 3)
0000000000000000000000000000000000000000;;		testReportMissingPods(t, 3)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testReportMissingContainers(t *testing.T, numRelists int) {
0000000000000000000000000000000000000000;;		testPleg := newTestGenericPLEG()
0000000000000000000000000000000000000000;;		pleg, runtime := testPleg.pleg, testPleg.runtime
0000000000000000000000000000000000000000;;		ch := pleg.Watch()
0000000000000000000000000000000000000000;;		runtime.AllPodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;			{Pod: &kubecontainer.Pod{
0000000000000000000000000000000000000000;;				ID: "1234",
0000000000000000000000000000000000000000;;				Containers: []*kubecontainer.Container{
0000000000000000000000000000000000000000;;					createTestContainer("c1", kubecontainer.ContainerStateRunning),
0000000000000000000000000000000000000000;;					createTestContainer("c2", kubecontainer.ContainerStateRunning),
0000000000000000000000000000000000000000;;					createTestContainer("c3", kubecontainer.ContainerStateExited),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Relist and drain the events from the channel.
0000000000000000000000000000000000000000;;		for i := 0; i < numRelists; i++ {
0000000000000000000000000000000000000000;;			pleg.relist()
0000000000000000000000000000000000000000;;			getEventsFromChannel(ch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Container c2 was stopped and removed between relists. We should report
0000000000000000000000000000000000000000;;		// the event. The exited container c3 was garbage collected (i.e., removed)
0000000000000000000000000000000000000000;;		// between relists. We should ignore that event.
0000000000000000000000000000000000000000;;		runtime.AllPodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;			{Pod: &kubecontainer.Pod{
0000000000000000000000000000000000000000;;				ID: "1234",
0000000000000000000000000000000000000000;;				Containers: []*kubecontainer.Container{
0000000000000000000000000000000000000000;;					createTestContainer("c1", kubecontainer.ContainerStateRunning),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pleg.relist()
0000000000000000000000000000000000000000;;		expected := []*PodLifecycleEvent{
0000000000000000000000000000000000000000;;			{ID: "1234", Type: ContainerDied, Data: "c2"},
0000000000000000000000000000000000000000;;			{ID: "1234", Type: ContainerRemoved, Data: "c2"},
0000000000000000000000000000000000000000;;			{ID: "1234", Type: ContainerRemoved, Data: "c3"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		actual := getEventsFromChannel(ch)
0000000000000000000000000000000000000000;;		verifyEvents(t, expected, actual)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testReportMissingPods(t *testing.T, numRelists int) {
0000000000000000000000000000000000000000;;		testPleg := newTestGenericPLEG()
0000000000000000000000000000000000000000;;		pleg, runtime := testPleg.pleg, testPleg.runtime
0000000000000000000000000000000000000000;;		ch := pleg.Watch()
0000000000000000000000000000000000000000;;		runtime.AllPodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;			{Pod: &kubecontainer.Pod{
0000000000000000000000000000000000000000;;				ID: "1234",
0000000000000000000000000000000000000000;;				Containers: []*kubecontainer.Container{
0000000000000000000000000000000000000000;;					createTestContainer("c2", kubecontainer.ContainerStateRunning),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Relist and drain the events from the channel.
0000000000000000000000000000000000000000;;		for i := 0; i < numRelists; i++ {
0000000000000000000000000000000000000000;;			pleg.relist()
0000000000000000000000000000000000000000;;			getEventsFromChannel(ch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Container c2 was stopped and removed between relists. We should report
0000000000000000000000000000000000000000;;		// the event.
0000000000000000000000000000000000000000;;		runtime.AllPodList = []*containertest.FakePod{}
0000000000000000000000000000000000000000;;		pleg.relist()
0000000000000000000000000000000000000000;;		expected := []*PodLifecycleEvent{
0000000000000000000000000000000000000000;;			{ID: "1234", Type: ContainerDied, Data: "c2"},
0000000000000000000000000000000000000000;;			{ID: "1234", Type: ContainerRemoved, Data: "c2"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		actual := getEventsFromChannel(ch)
0000000000000000000000000000000000000000;;		verifyEvents(t, expected, actual)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestGenericPLEGWithRuntimeMock() (*GenericPLEG, *containertest.Mock) {
0000000000000000000000000000000000000000;;		runtimeMock := &containertest.Mock{}
0000000000000000000000000000000000000000;;		pleg := &GenericPLEG{
0000000000000000000000000000000000000000;;			relistPeriod: time.Hour,
0000000000000000000000000000000000000000;;			runtime:      runtimeMock,
0000000000000000000000000000000000000000;;			eventChannel: make(chan *PodLifecycleEvent, 100),
0000000000000000000000000000000000000000;;			podRecords:   make(podRecords),
0000000000000000000000000000000000000000;;			cache:        kubecontainer.NewCache(),
0000000000000000000000000000000000000000;;			clock:        clock.RealClock{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pleg, runtimeMock
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createTestPodsStatusesAndEvents(num int) ([]*kubecontainer.Pod, []*kubecontainer.PodStatus, []*PodLifecycleEvent) {
0000000000000000000000000000000000000000;;		var pods []*kubecontainer.Pod
0000000000000000000000000000000000000000;;		var statuses []*kubecontainer.PodStatus
0000000000000000000000000000000000000000;;		var events []*PodLifecycleEvent
0000000000000000000000000000000000000000;;		for i := 0; i < num; i++ {
0000000000000000000000000000000000000000;;			id := types.UID(fmt.Sprintf("test-pod-%d", i))
0000000000000000000000000000000000000000;;			cState := kubecontainer.ContainerStateRunning
0000000000000000000000000000000000000000;;			container := createTestContainer(fmt.Sprintf("c%d", i), cState)
0000000000000000000000000000000000000000;;			pod := &kubecontainer.Pod{
0000000000000000000000000000000000000000;;				ID:         id,
0000000000000000000000000000000000000000;;				Containers: []*kubecontainer.Container{container},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			status := &kubecontainer.PodStatus{
0000000000000000000000000000000000000000;;				ID:                id,
0000000000000000000000000000000000000000;;				ContainerStatuses: []*kubecontainer.ContainerStatus{{ID: container.ID, State: cState}},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			event := &PodLifecycleEvent{ID: pod.ID, Type: ContainerStarted, Data: container.ID.ID}
0000000000000000000000000000000000000000;;			pods = append(pods, pod)
0000000000000000000000000000000000000000;;			statuses = append(statuses, status)
0000000000000000000000000000000000000000;;			events = append(events, event)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pods, statuses, events
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRelistWithCache(t *testing.T) {
0000000000000000000000000000000000000000;;		pleg, runtimeMock := newTestGenericPLEGWithRuntimeMock()
0000000000000000000000000000000000000000;;		ch := pleg.Watch()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods, statuses, events := createTestPodsStatusesAndEvents(2)
0000000000000000000000000000000000000000;;		runtimeMock.On("GetPods", true).Return(pods, nil)
0000000000000000000000000000000000000000;;		runtimeMock.On("GetPodStatus", pods[0].ID, "", "").Return(statuses[0], nil).Once()
0000000000000000000000000000000000000000;;		// Inject an error when querying runtime for the pod status for pods[1].
0000000000000000000000000000000000000000;;		statusErr := fmt.Errorf("unable to get status")
0000000000000000000000000000000000000000;;		runtimeMock.On("GetPodStatus", pods[1].ID, "", "").Return(&kubecontainer.PodStatus{}, statusErr).Once()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pleg.relist()
0000000000000000000000000000000000000000;;		actualEvents := getEventsFromChannel(ch)
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			pod    *kubecontainer.Pod
0000000000000000000000000000000000000000;;			status *kubecontainer.PodStatus
0000000000000000000000000000000000000000;;			error  error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{pod: pods[0], status: statuses[0], error: nil},
0000000000000000000000000000000000000000;;			{pod: pods[1], status: &kubecontainer.PodStatus{}, error: statusErr},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, c := range cases {
0000000000000000000000000000000000000000;;			testStr := fmt.Sprintf("test[%d]", i)
0000000000000000000000000000000000000000;;			actualStatus, actualErr := pleg.cache.Get(c.pod.ID)
0000000000000000000000000000000000000000;;			assert.Equal(t, c.status, actualStatus, testStr)
0000000000000000000000000000000000000000;;			assert.Equal(t, c.error, actualErr, testStr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// pleg should not generate any event for pods[1] because of the error.
0000000000000000000000000000000000000000;;		assert.Exactly(t, []*PodLifecycleEvent{events[0]}, actualEvents)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return normal status for pods[1].
0000000000000000000000000000000000000000;;		runtimeMock.On("GetPodStatus", pods[1].ID, "", "").Return(statuses[1], nil).Once()
0000000000000000000000000000000000000000;;		pleg.relist()
0000000000000000000000000000000000000000;;		actualEvents = getEventsFromChannel(ch)
0000000000000000000000000000000000000000;;		cases = []struct {
0000000000000000000000000000000000000000;;			pod    *kubecontainer.Pod
0000000000000000000000000000000000000000;;			status *kubecontainer.PodStatus
0000000000000000000000000000000000000000;;			error  error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{pod: pods[0], status: statuses[0], error: nil},
0000000000000000000000000000000000000000;;			{pod: pods[1], status: statuses[1], error: nil},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, c := range cases {
0000000000000000000000000000000000000000;;			testStr := fmt.Sprintf("test[%d]", i)
0000000000000000000000000000000000000000;;			actualStatus, actualErr := pleg.cache.Get(c.pod.ID)
0000000000000000000000000000000000000000;;			assert.Equal(t, c.status, actualStatus, testStr)
0000000000000000000000000000000000000000;;			assert.Equal(t, c.error, actualErr, testStr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Now that we are able to query status for pods[1], pleg should generate an event.
0000000000000000000000000000000000000000;;		assert.Exactly(t, []*PodLifecycleEvent{events[1]}, actualEvents)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRemoveCacheEntry(t *testing.T) {
0000000000000000000000000000000000000000;;		pleg, runtimeMock := newTestGenericPLEGWithRuntimeMock()
0000000000000000000000000000000000000000;;		pods, statuses, _ := createTestPodsStatusesAndEvents(1)
0000000000000000000000000000000000000000;;		runtimeMock.On("GetPods", true).Return(pods, nil).Once()
0000000000000000000000000000000000000000;;		runtimeMock.On("GetPodStatus", pods[0].ID, "", "").Return(statuses[0], nil).Once()
0000000000000000000000000000000000000000;;		// Does a relist to populate the cache.
0000000000000000000000000000000000000000;;		pleg.relist()
0000000000000000000000000000000000000000;;		// Delete the pod from runtime. Verify that the cache entry has been
0000000000000000000000000000000000000000;;		// removed after relisting.
0000000000000000000000000000000000000000;;		runtimeMock.On("GetPods", true).Return([]*kubecontainer.Pod{}, nil).Once()
0000000000000000000000000000000000000000;;		pleg.relist()
0000000000000000000000000000000000000000;;		actualStatus, actualErr := pleg.cache.Get(pods[0].ID)
0000000000000000000000000000000000000000;;		assert.Equal(t, &kubecontainer.PodStatus{ID: pods[0].ID}, actualStatus)
0000000000000000000000000000000000000000;;		assert.Equal(t, nil, actualErr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHealthy(t *testing.T) {
0000000000000000000000000000000000000000;;		testPleg := newTestGenericPLEG()
0000000000000000000000000000000000000000;;		pleg, _, clock := testPleg.pleg, testPleg.runtime, testPleg.clock
0000000000000000000000000000000000000000;;		ok, _ := pleg.Healthy()
0000000000000000000000000000000000000000;;		assert.True(t, ok, "pleg should be healthy")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Advance the clock without any relisting.
0000000000000000000000000000000000000000;;		clock.Step(time.Minute * 10)
0000000000000000000000000000000000000000;;		ok, _ = pleg.Healthy()
0000000000000000000000000000000000000000;;		assert.False(t, ok, "pleg should be unhealthy")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Relist and than advance the time by 1 minute. pleg should be healthy
0000000000000000000000000000000000000000;;		// because this is within the allowed limit.
0000000000000000000000000000000000000000;;		pleg.relist()
0000000000000000000000000000000000000000;;		clock.Step(time.Minute * 1)
0000000000000000000000000000000000000000;;		ok, _ = pleg.Healthy()
0000000000000000000000000000000000000000;;		assert.True(t, ok, "pleg should be healthy")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRelistWithReinspection(t *testing.T) {
0000000000000000000000000000000000000000;;		pleg, runtimeMock := newTestGenericPLEGWithRuntimeMock()
0000000000000000000000000000000000000000;;		ch := pleg.Watch()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		infraContainer := createTestContainer("infra", kubecontainer.ContainerStateRunning)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podID := types.UID("test-pod")
0000000000000000000000000000000000000000;;		pods := []*kubecontainer.Pod{{
0000000000000000000000000000000000000000;;			ID:         podID,
0000000000000000000000000000000000000000;;			Containers: []*kubecontainer.Container{infraContainer},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;		runtimeMock.On("GetPods", true).Return(pods, nil).Once()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		goodStatus := &kubecontainer.PodStatus{
0000000000000000000000000000000000000000;;			ID:                podID,
0000000000000000000000000000000000000000;;			ContainerStatuses: []*kubecontainer.ContainerStatus{{ID: infraContainer.ID, State: infraContainer.State}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runtimeMock.On("GetPodStatus", podID, "", "").Return(goodStatus, nil).Once()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		goodEvent := &PodLifecycleEvent{ID: podID, Type: ContainerStarted, Data: infraContainer.ID.ID}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// listing 1 - everything ok, infra container set up for pod
0000000000000000000000000000000000000000;;		pleg.relist()
0000000000000000000000000000000000000000;;		actualEvents := getEventsFromChannel(ch)
0000000000000000000000000000000000000000;;		actualStatus, actualErr := pleg.cache.Get(podID)
0000000000000000000000000000000000000000;;		assert.Equal(t, goodStatus, actualStatus)
0000000000000000000000000000000000000000;;		assert.Equal(t, nil, actualErr)
0000000000000000000000000000000000000000;;		assert.Exactly(t, []*PodLifecycleEvent{goodEvent}, actualEvents)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// listing 2 - pretend runtime was in the middle of creating the non-infra container for the pod
0000000000000000000000000000000000000000;;		// and return an error during inspection
0000000000000000000000000000000000000000;;		transientContainer := createTestContainer("transient", kubecontainer.ContainerStateUnknown)
0000000000000000000000000000000000000000;;		podsWithTransientContainer := []*kubecontainer.Pod{{
0000000000000000000000000000000000000000;;			ID:         podID,
0000000000000000000000000000000000000000;;			Containers: []*kubecontainer.Container{infraContainer, transientContainer},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;		runtimeMock.On("GetPods", true).Return(podsWithTransientContainer, nil).Once()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		badStatus := &kubecontainer.PodStatus{
0000000000000000000000000000000000000000;;			ID:                podID,
0000000000000000000000000000000000000000;;			ContainerStatuses: []*kubecontainer.ContainerStatus{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runtimeMock.On("GetPodStatus", podID, "", "").Return(badStatus, errors.New("inspection error")).Once()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pleg.relist()
0000000000000000000000000000000000000000;;		actualEvents = getEventsFromChannel(ch)
0000000000000000000000000000000000000000;;		actualStatus, actualErr = pleg.cache.Get(podID)
0000000000000000000000000000000000000000;;		assert.Equal(t, badStatus, actualStatus)
0000000000000000000000000000000000000000;;		assert.Equal(t, errors.New("inspection error"), actualErr)
0000000000000000000000000000000000000000;;		assert.Exactly(t, []*PodLifecycleEvent{}, actualEvents)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// listing 3 - pretend the transient container has now disappeared, leaving just the infra
0000000000000000000000000000000000000000;;		// container. Make sure the pod is reinspected for its status and the cache is updated.
0000000000000000000000000000000000000000;;		runtimeMock.On("GetPods", true).Return(pods, nil).Once()
0000000000000000000000000000000000000000;;		runtimeMock.On("GetPodStatus", podID, "", "").Return(goodStatus, nil).Once()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pleg.relist()
0000000000000000000000000000000000000000;;		actualEvents = getEventsFromChannel(ch)
0000000000000000000000000000000000000000;;		actualStatus, actualErr = pleg.cache.Get(podID)
0000000000000000000000000000000000000000;;		assert.Equal(t, goodStatus, actualStatus)
0000000000000000000000000000000000000000;;		assert.Equal(t, nil, actualErr)
0000000000000000000000000000000000000000;;		// no events are expected because relist #1 set the old pod record which has the infra container
0000000000000000000000000000000000000000;;		// running. relist #2 had the inspection error and therefore didn't modify either old or new.
0000000000000000000000000000000000000000;;		// relist #3 forced the reinspection of the pod to retrieve its status, but because the list of
0000000000000000000000000000000000000000;;		// containers was the same as relist #1, nothing "changed", so there are no new events.
0000000000000000000000000000000000000000;;		assert.Exactly(t, []*PodLifecycleEvent{}, actualEvents)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test detecting sandbox state changes.
0000000000000000000000000000000000000000;;	func TestRelistingWithSandboxes(t *testing.T) {
0000000000000000000000000000000000000000;;		testPleg := newTestGenericPLEG()
0000000000000000000000000000000000000000;;		pleg, runtime := testPleg.pleg, testPleg.runtime
0000000000000000000000000000000000000000;;		ch := pleg.Watch()
0000000000000000000000000000000000000000;;		// The first relist should send a PodSync event to each pod.
0000000000000000000000000000000000000000;;		runtime.AllPodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;			{Pod: &kubecontainer.Pod{
0000000000000000000000000000000000000000;;				ID: "1234",
0000000000000000000000000000000000000000;;				Sandboxes: []*kubecontainer.Container{
0000000000000000000000000000000000000000;;					createTestContainer("c1", kubecontainer.ContainerStateExited),
0000000000000000000000000000000000000000;;					createTestContainer("c2", kubecontainer.ContainerStateRunning),
0000000000000000000000000000000000000000;;					createTestContainer("c3", kubecontainer.ContainerStateUnknown),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			{Pod: &kubecontainer.Pod{
0000000000000000000000000000000000000000;;				ID: "4567",
0000000000000000000000000000000000000000;;				Sandboxes: []*kubecontainer.Container{
0000000000000000000000000000000000000000;;					createTestContainer("c1", kubecontainer.ContainerStateExited),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pleg.relist()
0000000000000000000000000000000000000000;;		// Report every running/exited container if we see them for the first time.
0000000000000000000000000000000000000000;;		expected := []*PodLifecycleEvent{
0000000000000000000000000000000000000000;;			{ID: "1234", Type: ContainerStarted, Data: "c2"},
0000000000000000000000000000000000000000;;			{ID: "4567", Type: ContainerDied, Data: "c1"},
0000000000000000000000000000000000000000;;			{ID: "1234", Type: ContainerDied, Data: "c1"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		actual := getEventsFromChannel(ch)
0000000000000000000000000000000000000000;;		verifyEvents(t, expected, actual)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The second relist should not send out any event because no container has
0000000000000000000000000000000000000000;;		// changed.
0000000000000000000000000000000000000000;;		pleg.relist()
0000000000000000000000000000000000000000;;		verifyEvents(t, expected, actual)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runtime.AllPodList = []*containertest.FakePod{
0000000000000000000000000000000000000000;;			{Pod: &kubecontainer.Pod{
0000000000000000000000000000000000000000;;				ID: "1234",
0000000000000000000000000000000000000000;;				Sandboxes: []*kubecontainer.Container{
0000000000000000000000000000000000000000;;					createTestContainer("c2", kubecontainer.ContainerStateExited),
0000000000000000000000000000000000000000;;					createTestContainer("c3", kubecontainer.ContainerStateRunning),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			{Pod: &kubecontainer.Pod{
0000000000000000000000000000000000000000;;				ID: "4567",
0000000000000000000000000000000000000000;;				Sandboxes: []*kubecontainer.Container{
0000000000000000000000000000000000000000;;					createTestContainer("c4", kubecontainer.ContainerStateRunning),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pleg.relist()
0000000000000000000000000000000000000000;;		// Only report containers that transitioned to running or exited status.
0000000000000000000000000000000000000000;;		expected = []*PodLifecycleEvent{
0000000000000000000000000000000000000000;;			{ID: "1234", Type: ContainerRemoved, Data: "c1"},
0000000000000000000000000000000000000000;;			{ID: "1234", Type: ContainerDied, Data: "c2"},
0000000000000000000000000000000000000000;;			{ID: "1234", Type: ContainerStarted, Data: "c3"},
0000000000000000000000000000000000000000;;			{ID: "4567", Type: ContainerRemoved, Data: "c1"},
0000000000000000000000000000000000000000;;			{ID: "4567", Type: ContainerStarted, Data: "c4"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actual = getEventsFromChannel(ch)
0000000000000000000000000000000000000000;;		verifyEvents(t, expected, actual)
0000000000000000000000000000000000000000;;	}
