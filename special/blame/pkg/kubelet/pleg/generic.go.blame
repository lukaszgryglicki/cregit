0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
28a401c581e2c5c431c895d1186f9cd05186d445;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package pleg
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/metrics"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenericPLEG is an extremely simple generic PLEG that relies solely on
0000000000000000000000000000000000000000;;	// periodic listing to discover container changes. It should be used
0000000000000000000000000000000000000000;;	// as temporary replacement for container runtimes do not support a proper
0000000000000000000000000000000000000000;;	// event generator yet.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that GenericPLEG assumes that a container would not be created,
0000000000000000000000000000000000000000;;	// terminated, and garbage collected within one relist period. If such an
0000000000000000000000000000000000000000;;	// incident happens, GenenricPLEG would miss all events regarding this
0000000000000000000000000000000000000000;;	// container. In the case of relisting failure, the window may become longer.
0000000000000000000000000000000000000000;;	// Note that this assumption is not unique -- many kubelet internal components
0000000000000000000000000000000000000000;;	// rely on terminated containers as tombstones for bookkeeping purposes. The
0000000000000000000000000000000000000000;;	// garbage collector is implemented to work with such situations. However, to
0000000000000000000000000000000000000000;;	// guarantee that kubelet can handle missing container events, it is
0000000000000000000000000000000000000000;;	// recommended to set the relist period short and have an auxiliary, longer
0000000000000000000000000000000000000000;;	// periodic sync in kubelet as the safety net.
0000000000000000000000000000000000000000;;	type GenericPLEG struct {
0000000000000000000000000000000000000000;;		// The period for relisting.
0000000000000000000000000000000000000000;;		relistPeriod time.Duration
0000000000000000000000000000000000000000;;		// The container runtime.
0000000000000000000000000000000000000000;;		runtime kubecontainer.Runtime
0000000000000000000000000000000000000000;;		// The channel from which the subscriber listens events.
0000000000000000000000000000000000000000;;		eventChannel chan *PodLifecycleEvent
0000000000000000000000000000000000000000;;		// The internal cache for pod/container information.
0000000000000000000000000000000000000000;;		podRecords podRecords
0000000000000000000000000000000000000000;;		// Time of the last relisting.
0000000000000000000000000000000000000000;;		relistTime atomic.Value
0000000000000000000000000000000000000000;;		// Cache for storing the runtime states required for syncing pods.
0000000000000000000000000000000000000000;;		cache kubecontainer.Cache
0000000000000000000000000000000000000000;;		// For testability.
0000000000000000000000000000000000000000;;		clock clock.Clock
0000000000000000000000000000000000000000;;		// Pods that failed to have their status retrieved during a relist. These pods will be
0000000000000000000000000000000000000000;;		// retried during the next relisting.
0000000000000000000000000000000000000000;;		podsToReinspect map[types.UID]*kubecontainer.Pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// plegContainerState has a one-to-one mapping to the
0000000000000000000000000000000000000000;;	// kubecontainer.ContainerState except for the non-existent state. This state
0000000000000000000000000000000000000000;;	// is introduced here to complete the state transition scenarios.
0000000000000000000000000000000000000000;;	type plegContainerState string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		plegContainerRunning     plegContainerState = "running"
0000000000000000000000000000000000000000;;		plegContainerExited      plegContainerState = "exited"
0000000000000000000000000000000000000000;;		plegContainerUnknown     plegContainerState = "unknown"
0000000000000000000000000000000000000000;;		plegContainerNonExistent plegContainerState = "non-existent"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The threshold needs to be greater than the relisting period + the
0000000000000000000000000000000000000000;;		// relisting time, which can vary significantly. Set a conservative
0000000000000000000000000000000000000000;;		// threshold to avoid flipping between healthy and unhealthy.
0000000000000000000000000000000000000000;;		relistThreshold = 3 * time.Minute
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func convertState(state kubecontainer.ContainerState) plegContainerState {
0000000000000000000000000000000000000000;;		switch state {
0000000000000000000000000000000000000000;;		case kubecontainer.ContainerStateCreated:
0000000000000000000000000000000000000000;;			// kubelet doesn't use the "created" state yet, hence convert it to "unknown".
0000000000000000000000000000000000000000;;			return plegContainerUnknown
0000000000000000000000000000000000000000;;		case kubecontainer.ContainerStateRunning:
0000000000000000000000000000000000000000;;			return plegContainerRunning
0000000000000000000000000000000000000000;;		case kubecontainer.ContainerStateExited:
0000000000000000000000000000000000000000;;			return plegContainerExited
0000000000000000000000000000000000000000;;		case kubecontainer.ContainerStateUnknown:
0000000000000000000000000000000000000000;;			return plegContainerUnknown
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("unrecognized container state: %v", state))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type podRecord struct {
0000000000000000000000000000000000000000;;		old     *kubecontainer.Pod
0000000000000000000000000000000000000000;;		current *kubecontainer.Pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type podRecords map[types.UID]*podRecord
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewGenericPLEG(runtime kubecontainer.Runtime, channelCapacity int,
0000000000000000000000000000000000000000;;		relistPeriod time.Duration, cache kubecontainer.Cache, clock clock.Clock) PodLifecycleEventGenerator {
0000000000000000000000000000000000000000;;		return &GenericPLEG{
0000000000000000000000000000000000000000;;			relistPeriod: relistPeriod,
0000000000000000000000000000000000000000;;			runtime:      runtime,
0000000000000000000000000000000000000000;;			eventChannel: make(chan *PodLifecycleEvent, channelCapacity),
0000000000000000000000000000000000000000;;			podRecords:   make(podRecords),
0000000000000000000000000000000000000000;;			cache:        cache,
0000000000000000000000000000000000000000;;			clock:        clock,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a channel from which the subscriber can receive PodLifecycleEvent
0000000000000000000000000000000000000000;;	// events.
0000000000000000000000000000000000000000;;	// TODO: support multiple subscribers.
0000000000000000000000000000000000000000;;	func (g *GenericPLEG) Watch() chan *PodLifecycleEvent {
0000000000000000000000000000000000000000;;		return g.eventChannel
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Start spawns a goroutine to relist periodically.
0000000000000000000000000000000000000000;;	func (g *GenericPLEG) Start() {
0000000000000000000000000000000000000000;;		go wait.Until(g.relist, g.relistPeriod, wait.NeverStop)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *GenericPLEG) Healthy() (bool, error) {
0000000000000000000000000000000000000000;;		relistTime := g.getRelistTime()
0000000000000000000000000000000000000000;;		elapsed := g.clock.Since(relistTime)
0000000000000000000000000000000000000000;;		if elapsed > relistThreshold {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("pleg was last seen active %v ago; threshold is %v", elapsed, relistThreshold)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateEvents(podID types.UID, cid string, oldState, newState plegContainerState) []*PodLifecycleEvent {
0000000000000000000000000000000000000000;;		if newState == oldState {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("GenericPLEG: %v/%v: %v -> %v", podID, cid, oldState, newState)
0000000000000000000000000000000000000000;;		switch newState {
0000000000000000000000000000000000000000;;		case plegContainerRunning:
0000000000000000000000000000000000000000;;			return []*PodLifecycleEvent{{ID: podID, Type: ContainerStarted, Data: cid}}
0000000000000000000000000000000000000000;;		case plegContainerExited:
0000000000000000000000000000000000000000;;			return []*PodLifecycleEvent{{ID: podID, Type: ContainerDied, Data: cid}}
0000000000000000000000000000000000000000;;		case plegContainerUnknown:
0000000000000000000000000000000000000000;;			return []*PodLifecycleEvent{{ID: podID, Type: ContainerChanged, Data: cid}}
0000000000000000000000000000000000000000;;		case plegContainerNonExistent:
0000000000000000000000000000000000000000;;			switch oldState {
0000000000000000000000000000000000000000;;			case plegContainerExited:
0000000000000000000000000000000000000000;;				// We already reported that the container died before.
0000000000000000000000000000000000000000;;				return []*PodLifecycleEvent{{ID: podID, Type: ContainerRemoved, Data: cid}}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return []*PodLifecycleEvent{{ID: podID, Type: ContainerDied, Data: cid}, {ID: podID, Type: ContainerRemoved, Data: cid}}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("unrecognized container state: %v", newState))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *GenericPLEG) getRelistTime() time.Time {
0000000000000000000000000000000000000000;;		val := g.relistTime.Load()
0000000000000000000000000000000000000000;;		if val == nil {
0000000000000000000000000000000000000000;;			return time.Time{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val.(time.Time)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *GenericPLEG) updateRelisTime(timestamp time.Time) {
0000000000000000000000000000000000000000;;		g.relistTime.Store(timestamp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// relist queries the container runtime for list of pods/containers, compare
0000000000000000000000000000000000000000;;	// with the internal pods/containers, and generats events accordingly.
0000000000000000000000000000000000000000;;	func (g *GenericPLEG) relist() {
0000000000000000000000000000000000000000;;		glog.V(5).Infof("GenericPLEG: Relisting")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lastRelistTime := g.getRelistTime(); !lastRelistTime.IsZero() {
0000000000000000000000000000000000000000;;			metrics.PLEGRelistInterval.Observe(metrics.SinceInMicroseconds(lastRelistTime))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timestamp := g.clock.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			metrics.PLEGRelistLatency.Observe(metrics.SinceInMicroseconds(timestamp))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get all the pods.
0000000000000000000000000000000000000000;;		podList, err := g.runtime.GetPods(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("GenericPLEG: Unable to retrieve pods: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update the relist time.
0000000000000000000000000000000000000000;;		g.updateRelisTime(timestamp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods := kubecontainer.Pods(podList)
0000000000000000000000000000000000000000;;		g.podRecords.setCurrent(pods)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Compare the old and the current pods, and generate events.
0000000000000000000000000000000000000000;;		eventsByPodID := map[types.UID][]*PodLifecycleEvent{}
0000000000000000000000000000000000000000;;		for pid := range g.podRecords {
0000000000000000000000000000000000000000;;			oldPod := g.podRecords.getOld(pid)
0000000000000000000000000000000000000000;;			pod := g.podRecords.getCurrent(pid)
0000000000000000000000000000000000000000;;			// Get all containers in the old and the new pod.
0000000000000000000000000000000000000000;;			allContainers := getContainersFromPods(oldPod, pod)
0000000000000000000000000000000000000000;;			for _, container := range allContainers {
0000000000000000000000000000000000000000;;				events := computeEvents(oldPod, pod, &container.ID)
0000000000000000000000000000000000000000;;				for _, e := range events {
0000000000000000000000000000000000000000;;					updateEvents(eventsByPodID, e)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var needsReinspection map[types.UID]*kubecontainer.Pod
0000000000000000000000000000000000000000;;		if g.cacheEnabled() {
0000000000000000000000000000000000000000;;			needsReinspection = make(map[types.UID]*kubecontainer.Pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If there are events associated with a pod, we should update the
0000000000000000000000000000000000000000;;		// podCache.
0000000000000000000000000000000000000000;;		for pid, events := range eventsByPodID {
0000000000000000000000000000000000000000;;			pod := g.podRecords.getCurrent(pid)
0000000000000000000000000000000000000000;;			if g.cacheEnabled() {
0000000000000000000000000000000000000000;;				// updateCache() will inspect the pod and update the cache. If an
0000000000000000000000000000000000000000;;				// error occurs during the inspection, we want PLEG to retry again
0000000000000000000000000000000000000000;;				// in the next relist. To achieve this, we do not update the
0000000000000000000000000000000000000000;;				// associated podRecord of the pod, so that the change will be
0000000000000000000000000000000000000000;;				// detect again in the next relist.
0000000000000000000000000000000000000000;;				// TODO: If many pods changed during the same relist period,
0000000000000000000000000000000000000000;;				// inspecting the pod and getting the PodStatus to update the cache
0000000000000000000000000000000000000000;;				// serially may take a while. We should be aware of this and
0000000000000000000000000000000000000000;;				// parallelize if needed.
0000000000000000000000000000000000000000;;				if err := g.updateCache(pod, pid); err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("PLEG: Ignoring events for pod %s/%s: %v", pod.Name, pod.Namespace, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// make sure we try to reinspect the pod during the next relisting
0000000000000000000000000000000000000000;;					needsReinspection[pid] = pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				} else if _, found := g.podsToReinspect[pid]; found {
0000000000000000000000000000000000000000;;					// this pod was in the list to reinspect and we did so because it had events, so remove it
0000000000000000000000000000000000000000;;					// from the list (we don't want the reinspection code below to inspect it a second time in
0000000000000000000000000000000000000000;;					// this relist execution)
0000000000000000000000000000000000000000;;					delete(g.podsToReinspect, pid)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Update the internal storage and send out the events.
0000000000000000000000000000000000000000;;			g.podRecords.update(pid)
0000000000000000000000000000000000000000;;			for i := range events {
0000000000000000000000000000000000000000;;				// Filter out events that are not reliable and no other components use yet.
0000000000000000000000000000000000000000;;				if events[i].Type == ContainerChanged {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				g.eventChannel <- events[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if g.cacheEnabled() {
0000000000000000000000000000000000000000;;			// reinspect any pods that failed inspection during the previous relist
0000000000000000000000000000000000000000;;			if len(g.podsToReinspect) > 0 {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("GenericPLEG: Reinspecting pods that previously failed inspection")
0000000000000000000000000000000000000000;;				for pid, pod := range g.podsToReinspect {
0000000000000000000000000000000000000000;;					if err := g.updateCache(pod, pid); err != nil {
0000000000000000000000000000000000000000;;						glog.Errorf("PLEG: pod %s/%s failed reinspection: %v", pod.Name, pod.Namespace, err)
0000000000000000000000000000000000000000;;						needsReinspection[pid] = pod
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Update the cache timestamp.  This needs to happen *after*
0000000000000000000000000000000000000000;;			// all pods have been properly updated in the cache.
0000000000000000000000000000000000000000;;			g.cache.UpdateTime(timestamp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// make sure we retain the list of pods that need reinspecting the next time relist is called
0000000000000000000000000000000000000000;;		g.podsToReinspect = needsReinspection
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getContainersFromPods(pods ...*kubecontainer.Pod) []*kubecontainer.Container {
0000000000000000000000000000000000000000;;		cidSet := sets.NewString()
0000000000000000000000000000000000000000;;		var containers []*kubecontainer.Container
0000000000000000000000000000000000000000;;		for _, p := range pods {
0000000000000000000000000000000000000000;;			if p == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, c := range p.Containers {
0000000000000000000000000000000000000000;;				cid := string(c.ID.ID)
0000000000000000000000000000000000000000;;				if cidSet.Has(cid) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cidSet.Insert(cid)
0000000000000000000000000000000000000000;;				containers = append(containers, c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Update sandboxes as containers
0000000000000000000000000000000000000000;;			// TODO: keep track of sandboxes explicitly.
0000000000000000000000000000000000000000;;			for _, c := range p.Sandboxes {
0000000000000000000000000000000000000000;;				cid := string(c.ID.ID)
0000000000000000000000000000000000000000;;				if cidSet.Has(cid) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cidSet.Insert(cid)
0000000000000000000000000000000000000000;;				containers = append(containers, c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return containers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func computeEvents(oldPod, newPod *kubecontainer.Pod, cid *kubecontainer.ContainerID) []*PodLifecycleEvent {
0000000000000000000000000000000000000000;;		var pid types.UID
0000000000000000000000000000000000000000;;		if oldPod != nil {
0000000000000000000000000000000000000000;;			pid = oldPod.ID
0000000000000000000000000000000000000000;;		} else if newPod != nil {
0000000000000000000000000000000000000000;;			pid = newPod.ID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldState := getContainerState(oldPod, cid)
0000000000000000000000000000000000000000;;		newState := getContainerState(newPod, cid)
0000000000000000000000000000000000000000;;		return generateEvents(pid, cid.ID, oldState, newState)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *GenericPLEG) cacheEnabled() bool {
0000000000000000000000000000000000000000;;		return g.cache != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *GenericPLEG) updateCache(pod *kubecontainer.Pod, pid types.UID) error {
0000000000000000000000000000000000000000;;		if pod == nil {
0000000000000000000000000000000000000000;;			// The pod is missing in the current relist. This means that
0000000000000000000000000000000000000000;;			// the pod has no visible (active or inactive) containers.
0000000000000000000000000000000000000000;;			glog.V(4).Infof("PLEG: Delete status for pod %q", string(pid))
0000000000000000000000000000000000000000;;			g.cache.Delete(pid)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		timestamp := g.clock.Now()
0000000000000000000000000000000000000000;;		// TODO: Consider adding a new runtime method
0000000000000000000000000000000000000000;;		// GetPodStatus(pod *kubecontainer.Pod) so that Docker can avoid listing
0000000000000000000000000000000000000000;;		// all containers again.
0000000000000000000000000000000000000000;;		status, err := g.runtime.GetPodStatus(pod.ID, pod.Name, pod.Namespace)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("PLEG: Write status for %s/%s: %#v (err: %v)", pod.Name, pod.Namespace, status, err)
0000000000000000000000000000000000000000;;		g.cache.Set(pod.ID, status, err, timestamp)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updateEvents(eventsByPodID map[types.UID][]*PodLifecycleEvent, e *PodLifecycleEvent) {
0000000000000000000000000000000000000000;;		if e == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eventsByPodID[e.ID] = append(eventsByPodID[e.ID], e)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getContainerState(pod *kubecontainer.Pod, cid *kubecontainer.ContainerID) plegContainerState {
0000000000000000000000000000000000000000;;		// Default to the non-existent state.
0000000000000000000000000000000000000000;;		state := plegContainerNonExistent
0000000000000000000000000000000000000000;;		if pod == nil {
0000000000000000000000000000000000000000;;			return state
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := pod.FindContainerByID(*cid)
0000000000000000000000000000000000000000;;		if c != nil {
0000000000000000000000000000000000000000;;			return convertState(c.State)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Search through sandboxes too.
0000000000000000000000000000000000000000;;		c = pod.FindSandboxByID(*cid)
0000000000000000000000000000000000000000;;		if c != nil {
0000000000000000000000000000000000000000;;			return convertState(c.State)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return state
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pr podRecords) getOld(id types.UID) *kubecontainer.Pod {
0000000000000000000000000000000000000000;;		r, ok := pr[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.old
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pr podRecords) getCurrent(id types.UID) *kubecontainer.Pod {
0000000000000000000000000000000000000000;;		r, ok := pr[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.current
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pr podRecords) setCurrent(pods []*kubecontainer.Pod) {
0000000000000000000000000000000000000000;;		for i := range pr {
0000000000000000000000000000000000000000;;			pr[i].current = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			if r, ok := pr[pod.ID]; ok {
0000000000000000000000000000000000000000;;				r.current = pod
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				pr[pod.ID] = &podRecord{current: pod}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pr podRecords) update(id types.UID) {
0000000000000000000000000000000000000000;;		r, ok := pr[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pr.updateInternal(id, r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pr podRecords) updateInternal(id types.UID, r *podRecord) {
0000000000000000000000000000000000000000;;		if r.current == nil {
0000000000000000000000000000000000000000;;			// Pod no longer exists; delete the entry.
0000000000000000000000000000000000000000;;			delete(pr, id)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.old = r.current
0000000000000000000000000000000000000000;;		r.current = nil
0000000000000000000000000000000000000000;;	}
