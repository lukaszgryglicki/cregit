0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f37e8d7605f26ab00dd5d58e7b1225475d7a741a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		k8s_api_v1 "k8s.io/kubernetes/pkg/api/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;		kubetypes "k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestURLErrorNotExistNoUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		ch := make(chan interface{})
0000000000000000000000000000000000000000;;		NewSourceURL("http://localhost:49575/_not_found_", http.Header{}, "localhost", time.Millisecond, ch)
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case got := <-ch:
0000000000000000000000000000000000000000;;			t.Errorf("Expected no update, Got %#v", got)
0000000000000000000000000000000000000000;;		case <-time.After(2 * time.Millisecond):
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestExtractFromHttpBadness(t *testing.T) {
0000000000000000000000000000000000000000;;		ch := make(chan interface{}, 1)
0000000000000000000000000000000000000000;;		c := sourceURL{"http://localhost:49575/_not_found_", http.Header{}, "other", ch, nil, 0, http.DefaultClient}
0000000000000000000000000000000000000000;;		if err := c.extractFromURL(); err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectEmptyChannel(t, ch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestExtractInvalidPods(t *testing.T) {
0000000000000000000000000000000000000000;;		var testCases = []struct {
0000000000000000000000000000000000000000;;			desc string
0000000000000000000000000000000000000000;;			pod  *v1.Pod
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				desc: "No version",
0000000000000000000000000000000000000000;;				pod:  &v1.Pod{TypeMeta: metav1.TypeMeta{APIVersion: ""}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				desc: "Invalid version",
0000000000000000000000000000000000000000;;				pod:  &v1.Pod{TypeMeta: metav1.TypeMeta{APIVersion: "v1betta2"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				desc: "Invalid volume name",
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					TypeMeta: metav1.TypeMeta{APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String()},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Volumes: []v1.Volume{{Name: "_INVALID_"}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				desc: "Duplicate volume names",
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					TypeMeta: metav1.TypeMeta{APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String()},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Volumes: []v1.Volume{{Name: "repeated"}, {Name: "repeated"}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				desc: "Unspecified container name",
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					TypeMeta: metav1.TypeMeta{APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String()},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{{Name: ""}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				desc: "Invalid container name",
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					TypeMeta: metav1.TypeMeta{APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String()},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{{Name: "_INVALID_"}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, testCase := range testCases {
0000000000000000000000000000000000000000;;			data, err := json.Marshal(testCase.pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: Some weird json problem: %v", testCase.desc, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fakeHandler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;				StatusCode:   200,
0000000000000000000000000000000000000000;;				ResponseBody: string(data),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			testServer := httptest.NewServer(&fakeHandler)
0000000000000000000000000000000000000000;;			defer testServer.Close()
0000000000000000000000000000000000000000;;			ch := make(chan interface{}, 1)
0000000000000000000000000000000000000000;;			c := sourceURL{testServer.URL, http.Header{}, "localhost", ch, nil, 0, http.DefaultClient}
0000000000000000000000000000000000000000;;			if err := c.extractFromURL(); err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Expected error", testCase.desc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestExtractPodsFromHTTP(t *testing.T) {
0000000000000000000000000000000000000000;;		nodeName := "different-value"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		grace := int64(30)
0000000000000000000000000000000000000000;;		var testCases = []struct {
0000000000000000000000000000000000000000;;			desc     string
0000000000000000000000000000000000000000;;			pods     runtime.Object
0000000000000000000000000000000000000000;;			expected kubetypes.PodUpdate
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				desc: "Single pod",
0000000000000000000000000000000000000000;;				pods: &v1.Pod{
0000000000000000000000000000000000000000;;					TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;						Kind:       "Pod",
0000000000000000000000000000000000000000;;						APIVersion: "",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						UID:       "111",
0000000000000000000000000000000000000000;;						Namespace: "mynamespace",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						NodeName:        string(nodeName),
0000000000000000000000000000000000000000;;						Containers:      []v1.Container{{Name: "1", Image: "foo", ImagePullPolicy: v1.PullAlways, TerminationMessagePolicy: v1.TerminationMessageReadFile}},
0000000000000000000000000000000000000000;;						SecurityContext: &v1.PodSecurityContext{},
0000000000000000000000000000000000000000;;						SchedulerName:   api.DefaultSchedulerName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						Phase: v1.PodPending,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: CreatePodUpdate(kubetypes.SET,
0000000000000000000000000000000000000000;;					kubetypes.HTTPSource,
0000000000000000000000000000000000000000;;					&v1.Pod{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							UID:         "111",
0000000000000000000000000000000000000000;;							Name:        "foo" + "-" + nodeName,
0000000000000000000000000000000000000000;;							Namespace:   "mynamespace",
0000000000000000000000000000000000000000;;							Annotations: map[string]string{kubetypes.ConfigHashAnnotationKey: "111"},
0000000000000000000000000000000000000000;;							SelfLink:    getSelfLink("foo-"+nodeName, "mynamespace"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;							NodeName:                      nodeName,
0000000000000000000000000000000000000000;;							RestartPolicy:                 v1.RestartPolicyAlways,
0000000000000000000000000000000000000000;;							DNSPolicy:                     v1.DNSClusterFirst,
0000000000000000000000000000000000000000;;							SecurityContext:               &v1.PodSecurityContext{},
0000000000000000000000000000000000000000;;							TerminationGracePeriodSeconds: &grace,
0000000000000000000000000000000000000000;;							SchedulerName:                 api.DefaultSchedulerName,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;							Containers: []v1.Container{{
0000000000000000000000000000000000000000;;								Name:  "1",
0000000000000000000000000000000000000000;;								Image: "foo",
0000000000000000000000000000000000000000;;								TerminationMessagePath:   "/dev/termination-log",
0000000000000000000000000000000000000000;;								ImagePullPolicy:          "Always",
0000000000000000000000000000000000000000;;								TerminationMessagePolicy: v1.TerminationMessageReadFile,
0000000000000000000000000000000000000000;;							}},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.PodStatus{
0000000000000000000000000000000000000000;;							Phase: v1.PodPending,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				desc: "Multiple pods",
0000000000000000000000000000000000000000;;				pods: &v1.PodList{
0000000000000000000000000000000000000000;;					TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;						Kind:       "PodList",
0000000000000000000000000000000000000000;;						APIVersion: "",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Items: []v1.Pod{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name: "foo",
0000000000000000000000000000000000000000;;								UID:  "111",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;								NodeName:        nodeName,
0000000000000000000000000000000000000000;;								Containers:      []v1.Container{{Name: "1", Image: "foo", ImagePullPolicy: v1.PullAlways, TerminationMessagePolicy: v1.TerminationMessageReadFile}},
0000000000000000000000000000000000000000;;								SecurityContext: &v1.PodSecurityContext{},
0000000000000000000000000000000000000000;;								SchedulerName:   api.DefaultSchedulerName,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.PodStatus{
0000000000000000000000000000000000000000;;								Phase: v1.PodPending,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name: "bar",
0000000000000000000000000000000000000000;;								UID:  "222",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;								NodeName:        nodeName,
0000000000000000000000000000000000000000;;								Containers:      []v1.Container{{Name: "2", Image: "bar:bartag", ImagePullPolicy: "", TerminationMessagePolicy: v1.TerminationMessageReadFile}},
0000000000000000000000000000000000000000;;								SecurityContext: &v1.PodSecurityContext{},
0000000000000000000000000000000000000000;;								SchedulerName:   api.DefaultSchedulerName,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.PodStatus{
0000000000000000000000000000000000000000;;								Phase: v1.PodPending,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: CreatePodUpdate(kubetypes.SET,
0000000000000000000000000000000000000000;;					kubetypes.HTTPSource,
0000000000000000000000000000000000000000;;					&v1.Pod{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							UID:         "111",
0000000000000000000000000000000000000000;;							Name:        "foo" + "-" + nodeName,
0000000000000000000000000000000000000000;;							Namespace:   "default",
0000000000000000000000000000000000000000;;							Annotations: map[string]string{kubetypes.ConfigHashAnnotationKey: "111"},
0000000000000000000000000000000000000000;;							SelfLink:    getSelfLink("foo-"+nodeName, metav1.NamespaceDefault),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;							NodeName:                      nodeName,
0000000000000000000000000000000000000000;;							RestartPolicy:                 v1.RestartPolicyAlways,
0000000000000000000000000000000000000000;;							DNSPolicy:                     v1.DNSClusterFirst,
0000000000000000000000000000000000000000;;							TerminationGracePeriodSeconds: &grace,
0000000000000000000000000000000000000000;;							SecurityContext:               &v1.PodSecurityContext{},
0000000000000000000000000000000000000000;;							SchedulerName:                 api.DefaultSchedulerName,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;							Containers: []v1.Container{{
0000000000000000000000000000000000000000;;								Name:  "1",
0000000000000000000000000000000000000000;;								Image: "foo",
0000000000000000000000000000000000000000;;								TerminationMessagePath:   "/dev/termination-log",
0000000000000000000000000000000000000000;;								ImagePullPolicy:          "Always",
0000000000000000000000000000000000000000;;								TerminationMessagePolicy: v1.TerminationMessageReadFile,
0000000000000000000000000000000000000000;;							}},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.PodStatus{
0000000000000000000000000000000000000000;;							Phase: v1.PodPending,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					&v1.Pod{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							UID:         "222",
0000000000000000000000000000000000000000;;							Name:        "bar" + "-" + nodeName,
0000000000000000000000000000000000000000;;							Namespace:   "default",
0000000000000000000000000000000000000000;;							Annotations: map[string]string{kubetypes.ConfigHashAnnotationKey: "222"},
0000000000000000000000000000000000000000;;							SelfLink:    getSelfLink("bar-"+nodeName, metav1.NamespaceDefault),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;							NodeName:                      nodeName,
0000000000000000000000000000000000000000;;							RestartPolicy:                 v1.RestartPolicyAlways,
0000000000000000000000000000000000000000;;							DNSPolicy:                     v1.DNSClusterFirst,
0000000000000000000000000000000000000000;;							TerminationGracePeriodSeconds: &grace,
0000000000000000000000000000000000000000;;							SecurityContext:               &v1.PodSecurityContext{},
0000000000000000000000000000000000000000;;							SchedulerName:                 api.DefaultSchedulerName,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;							Containers: []v1.Container{{
0000000000000000000000000000000000000000;;								Name:  "2",
0000000000000000000000000000000000000000;;								Image: "bar:bartag",
0000000000000000000000000000000000000000;;								TerminationMessagePath:   "/dev/termination-log",
0000000000000000000000000000000000000000;;								ImagePullPolicy:          "IfNotPresent",
0000000000000000000000000000000000000000;;								TerminationMessagePolicy: v1.TerminationMessageReadFile,
0000000000000000000000000000000000000000;;							}},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.PodStatus{
0000000000000000000000000000000000000000;;							Phase: v1.PodPending,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, testCase := range testCases {
0000000000000000000000000000000000000000;;			var versionedPods runtime.Object
0000000000000000000000000000000000000000;;			err := testapi.Default.Converter().Convert(&testCase.pods, &versionedPods, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: error in versioning the pods: %s", testCase.desc, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			data, err := runtime.Encode(testapi.Default.Codec(), versionedPods)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: error in encoding the pod: %v", testCase.desc, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fakeHandler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;				StatusCode:   200,
0000000000000000000000000000000000000000;;				ResponseBody: string(data),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			testServer := httptest.NewServer(&fakeHandler)
0000000000000000000000000000000000000000;;			defer testServer.Close()
0000000000000000000000000000000000000000;;			ch := make(chan interface{}, 1)
0000000000000000000000000000000000000000;;			c := sourceURL{testServer.URL, http.Header{}, types.NodeName(nodeName), ch, nil, 0, http.DefaultClient}
0000000000000000000000000000000000000000;;			if err := c.extractFromURL(); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Unexpected error: %v", testCase.desc, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			update := (<-ch).(kubetypes.PodUpdate)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !apiequality.Semantic.DeepEqual(testCase.expected, update) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Expected: %#v, Got: %#v", testCase.desc, testCase.expected, update)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, pod := range update.Pods {
0000000000000000000000000000000000000000;;				// TODO: remove the conversion when validation is performed on versioned objects.
0000000000000000000000000000000000000000;;				internalPod := &api.Pod{}
0000000000000000000000000000000000000000;;				if err := k8s_api_v1.Convert_v1_Pod_To_api_Pod(pod, internalPod, nil); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%s: Cannot convert pod %#v, %#v", testCase.desc, pod, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if errs := validation.ValidatePod(internalPod); len(errs) != 0 {
0000000000000000000000000000000000000000;;					t.Errorf("%s: Expected no validation errors on %#v, Got %v", testCase.desc, pod, errs.ToAggregate())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestURLWithHeader(t *testing.T) {
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String(),
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				UID:       "111",
0000000000000000000000000000000000000000;;				Namespace: "mynamespace",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				NodeName:   "localhost",
0000000000000000000000000000000000000000;;				Containers: []v1.Container{{Name: "1", Image: "foo", ImagePullPolicy: v1.PullAlways}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data, err := json.Marshal(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected json marshalling error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeHandler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode:   200,
0000000000000000000000000000000000000000;;			ResponseBody: string(data),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testServer := httptest.NewServer(&fakeHandler)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		ch := make(chan interface{}, 1)
0000000000000000000000000000000000000000;;		header := make(http.Header)
0000000000000000000000000000000000000000;;		header.Set("Metadata-Flavor", "Google")
0000000000000000000000000000000000000000;;		c := sourceURL{testServer.URL, header, "localhost", ch, nil, 0, http.DefaultClient}
0000000000000000000000000000000000000000;;		if err := c.extractFromURL(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error extracting from URL: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		update := (<-ch).(kubetypes.PodUpdate)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headerVal := fakeHandler.RequestReceived.Header["Metadata-Flavor"]
0000000000000000000000000000000000000000;;		if len(headerVal) != 1 || headerVal[0] != "Google" {
0000000000000000000000000000000000000000;;			t.Errorf("Header missing expected entry %v. Got %v", header, fakeHandler.RequestReceived.Header)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(update.Pods) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Received wrong number of pods, expected one: %v", update.Pods)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
