0000000000000000000000000000000000000000;;	// +build linux
c854f6ad1fdaf846f54ba81d7af8c30505dadd0d;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		k8s_api_v1 "k8s.io/kubernetes/pkg/api/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;		kubetypes "k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/securitycontext"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestExtractFromNonExistentFile(t *testing.T) {
0000000000000000000000000000000000000000;;		ch := make(chan interface{}, 1)
0000000000000000000000000000000000000000;;		c := new("/some/fake/file", "localhost", time.Millisecond, ch)
0000000000000000000000000000000000000000;;		err := c.watch()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateOnNonExistentFile(t *testing.T) {
0000000000000000000000000000000000000000;;		ch := make(chan interface{})
0000000000000000000000000000000000000000;;		NewSourceFile("random_non_existent_path", "localhost", time.Millisecond, ch)
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case got := <-ch:
0000000000000000000000000000000000000000;;			update := got.(kubetypes.PodUpdate)
0000000000000000000000000000000000000000;;			expected := CreatePodUpdate(kubetypes.SET, kubetypes.FileSource)
0000000000000000000000000000000000000000;;			if !apiequality.Semantic.DeepDerivative(expected, update) {
0000000000000000000000000000000000000000;;				t.Fatalf("expected %#v, Got %#v", expected, update)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Fatalf("expected update, timeout instead")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReadPodsFromFileExistAlready(t *testing.T) {
0000000000000000000000000000000000000000;;		hostname := types.NodeName("random-test-hostname")
0000000000000000000000000000000000000000;;		var testCases = getTestCases(hostname)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, testCase := range testCases {
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				dirName, err := utiltesting.MkTmpdir("file-test")
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("unable to create temp dir: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer os.RemoveAll(dirName)
0000000000000000000000000000000000000000;;				file := testCase.writeToFile(dirName, "test_pod_config", t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ch := make(chan interface{})
0000000000000000000000000000000000000000;;				NewSourceFile(file, hostname, time.Millisecond, ch)
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case got := <-ch:
0000000000000000000000000000000000000000;;					update := got.(kubetypes.PodUpdate)
0000000000000000000000000000000000000000;;					for _, pod := range update.Pods {
0000000000000000000000000000000000000000;;						// TODO: remove the conversion when validation is performed on versioned objects.
0000000000000000000000000000000000000000;;						internalPod := &api.Pod{}
0000000000000000000000000000000000000000;;						if err := k8s_api_v1.Convert_v1_Pod_To_api_Pod(pod, internalPod, nil); err != nil {
0000000000000000000000000000000000000000;;							t.Fatalf("%s: Cannot convert pod %#v, %#v", testCase.desc, pod, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if errs := validation.ValidatePod(internalPod); len(errs) > 0 {
0000000000000000000000000000000000000000;;							t.Fatalf("%s: Invalid pod %#v, %#v", testCase.desc, internalPod, errs)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !apiequality.Semantic.DeepEqual(testCase.expected, update) {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: Expected %#v, Got %#v", testCase.desc, testCase.expected, update)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;					t.Fatalf("%s: Expected update, timeout instead", testCase.desc)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReadPodsFromFileExistLater(t *testing.T) {
0000000000000000000000000000000000000000;;		watchFileAdded(false, t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReadPodsFromFileChanged(t *testing.T) {
0000000000000000000000000000000000000000;;		watchFileChanged(false, t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReadPodsFromFileInDirAdded(t *testing.T) {
0000000000000000000000000000000000000000;;		watchFileAdded(true, t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReadPodsFromFileInDirChanged(t *testing.T) {
0000000000000000000000000000000000000000;;		watchFileChanged(true, t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestExtractFromBadDataFile(t *testing.T) {
0000000000000000000000000000000000000000;;		dirName, err := utiltesting.MkTmpdir("file-test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unable to create temp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(dirName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fileName := filepath.Join(dirName, "test_pod_config")
0000000000000000000000000000000000000000;;		err = ioutil.WriteFile(fileName, []byte{1, 2, 3}, 0555)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unable to write test file %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ch := make(chan interface{}, 1)
0000000000000000000000000000000000000000;;		c := new(fileName, "localhost", time.Millisecond, ch)
0000000000000000000000000000000000000000;;		err = c.resetStoreFromPath()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expected error, got nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectEmptyChannel(t, ch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestExtractFromEmptyDir(t *testing.T) {
0000000000000000000000000000000000000000;;		dirName, err := utiltesting.MkTmpdir("file-test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(dirName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ch := make(chan interface{}, 1)
0000000000000000000000000000000000000000;;		c := new(dirName, "localhost", time.Millisecond, ch)
0000000000000000000000000000000000000000;;		err = c.resetStoreFromPath()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		update := (<-ch).(kubetypes.PodUpdate)
0000000000000000000000000000000000000000;;		expected := CreatePodUpdate(kubetypes.SET, kubetypes.FileSource)
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(expected, update) {
0000000000000000000000000000000000000000;;			t.Fatalf("expected %#v, Got %#v", expected, update)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testCase struct {
0000000000000000000000000000000000000000;;		desc     string
0000000000000000000000000000000000000000;;		pod      runtime.Object
0000000000000000000000000000000000000000;;		expected kubetypes.PodUpdate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTestCases(hostname types.NodeName) []*testCase {
0000000000000000000000000000000000000000;;		grace := int64(30)
0000000000000000000000000000000000000000;;		return []*testCase{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				desc: "Simple pod",
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;						Kind:       "Pod",
0000000000000000000000000000000000000000;;						APIVersion: "",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "test",
0000000000000000000000000000000000000000;;						UID:       "12345",
0000000000000000000000000000000000000000;;						Namespace: "mynamespace",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers:      []v1.Container{{Name: "image", Image: "test/image", SecurityContext: securitycontext.ValidSecurityContextWithContainerDefaults()}},
0000000000000000000000000000000000000000;;						SecurityContext: &v1.PodSecurityContext{},
0000000000000000000000000000000000000000;;						SchedulerName:   api.DefaultSchedulerName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						Phase: v1.PodPending,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: CreatePodUpdate(kubetypes.SET, kubetypes.FileSource, &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:        "test-" + string(hostname),
0000000000000000000000000000000000000000;;						UID:         "12345",
0000000000000000000000000000000000000000;;						Namespace:   "mynamespace",
0000000000000000000000000000000000000000;;						Annotations: map[string]string{kubetypes.ConfigHashAnnotationKey: "12345"},
0000000000000000000000000000000000000000;;						SelfLink:    getSelfLink("test-"+string(hostname), "mynamespace"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						NodeName:                      string(hostname),
0000000000000000000000000000000000000000;;						RestartPolicy:                 v1.RestartPolicyAlways,
0000000000000000000000000000000000000000;;						DNSPolicy:                     v1.DNSClusterFirst,
0000000000000000000000000000000000000000;;						TerminationGracePeriodSeconds: &grace,
0000000000000000000000000000000000000000;;						Tolerations: []v1.Toleration{{
0000000000000000000000000000000000000000;;							Operator: "Exists",
0000000000000000000000000000000000000000;;							Effect:   "NoExecute",
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;						Containers: []v1.Container{{
0000000000000000000000000000000000000000;;							Name:  "image",
0000000000000000000000000000000000000000;;							Image: "test/image",
0000000000000000000000000000000000000000;;							TerminationMessagePath:   "/dev/termination-log",
0000000000000000000000000000000000000000;;							ImagePullPolicy:          "Always",
0000000000000000000000000000000000000000;;							SecurityContext:          securitycontext.ValidSecurityContextWithContainerDefaults(),
0000000000000000000000000000000000000000;;							TerminationMessagePolicy: v1.TerminationMessageReadFile,
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;						SecurityContext: &v1.PodSecurityContext{},
0000000000000000000000000000000000000000;;						SchedulerName:   api.DefaultSchedulerName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						Phase: v1.PodPending,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *testCase) writeToFile(dir, name string, t *testing.T) string {
0000000000000000000000000000000000000000;;		var versionedPod runtime.Object
0000000000000000000000000000000000000000;;		err := testapi.Default.Converter().Convert(&tc.pod, &versionedPod, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("%s: error in versioning the pod: %v", tc.desc, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fileContents, err := runtime.Encode(testapi.Default.Codec(), versionedPod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("%s: error in encoding the pod: %v", tc.desc, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fileName := filepath.Join(dir, name)
0000000000000000000000000000000000000000;;		if err := writeFile(fileName, []byte(fileContents)); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unable to write test file %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fileName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func watchFileAdded(watchDir bool, t *testing.T) {
0000000000000000000000000000000000000000;;		hostname := types.NodeName("random-test-hostname")
0000000000000000000000000000000000000000;;		var testCases = getTestCases(hostname)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fileNamePre := "test_pod_config"
0000000000000000000000000000000000000000;;		for index, testCase := range testCases {
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				dirName, err := utiltesting.MkTmpdir("dir-test")
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("unable to create temp dir: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer os.RemoveAll(dirName)
0000000000000000000000000000000000000000;;				fileName := fmt.Sprintf("%s_%d", fileNamePre, index)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ch := make(chan interface{})
0000000000000000000000000000000000000000;;				if watchDir {
0000000000000000000000000000000000000000;;					NewSourceFile(dirName, hostname, 100*time.Millisecond, ch)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					NewSourceFile(filepath.Join(dirName, fileName), hostname, 100*time.Millisecond, ch)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				expectEmptyUpdate(t, ch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				addFile := func() {
0000000000000000000000000000000000000000;;					// Add a file
0000000000000000000000000000000000000000;;					testCase.writeToFile(dirName, fileName, t)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				go addFile()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// For !watchDir: expect an update by SourceFile.resetStoreFromPath().
0000000000000000000000000000000000000000;;				// For watchDir: expect at least one update from CREATE & MODIFY inotify event.
0000000000000000000000000000000000000000;;				// Shouldn't expect two updates from CREATE & MODIFY because CREATE doesn't guarantee file written.
0000000000000000000000000000000000000000;;				// In that case no update will be sent from CREATE event.
0000000000000000000000000000000000000000;;				expectUpdate(t, ch, testCase)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func watchFileChanged(watchDir bool, t *testing.T) {
0000000000000000000000000000000000000000;;		hostname := types.NodeName("random-test-hostname")
0000000000000000000000000000000000000000;;		var testCases = getTestCases(hostname)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fileNamePre := "test_pod_config"
0000000000000000000000000000000000000000;;		for index, testCase := range testCases {
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				dirName, err := utiltesting.MkTmpdir("dir-test")
0000000000000000000000000000000000000000;;				fileName := fmt.Sprintf("%s_%d", fileNamePre, index)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("unable to create temp dir: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer os.RemoveAll(dirName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var file string
0000000000000000000000000000000000000000;;				lock := &sync.Mutex{}
0000000000000000000000000000000000000000;;				ch := make(chan interface{})
0000000000000000000000000000000000000000;;				func() {
0000000000000000000000000000000000000000;;					lock.Lock()
0000000000000000000000000000000000000000;;					defer lock.Unlock()
0000000000000000000000000000000000000000;;					file = testCase.writeToFile(dirName, fileName, t)
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if watchDir {
0000000000000000000000000000000000000000;;					NewSourceFile(dirName, hostname, 100*time.Millisecond, ch)
0000000000000000000000000000000000000000;;					defer func() {
0000000000000000000000000000000000000000;;						// Remove the file
0000000000000000000000000000000000000000;;						deleteFile(dirName, fileName, ch, t)
0000000000000000000000000000000000000000;;					}()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					NewSourceFile(file, hostname, 100*time.Millisecond, ch)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// expect an update by SourceFile.resetStoreFromPath()
0000000000000000000000000000000000000000;;				expectUpdate(t, ch, testCase)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				changeFile := func() {
0000000000000000000000000000000000000000;;					// Edit the file content
0000000000000000000000000000000000000000;;					lock.Lock()
0000000000000000000000000000000000000000;;					defer lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					pod := testCase.pod.(*v1.Pod)
0000000000000000000000000000000000000000;;					pod.Spec.Containers[0].Name = "image2"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					testCase.expected.Pods[0].Spec.Containers[0].Name = "image2"
0000000000000000000000000000000000000000;;					testCase.writeToFile(dirName, fileName, t)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				go changeFile()
0000000000000000000000000000000000000000;;				// expect an update by MODIFY inotify event
0000000000000000000000000000000000000000;;				expectUpdate(t, ch, testCase)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if watchDir {
0000000000000000000000000000000000000000;;					from := fileName
0000000000000000000000000000000000000000;;					fileName = fileName + "_ch"
0000000000000000000000000000000000000000;;					go changeFileName(dirName, from, fileName, t)
0000000000000000000000000000000000000000;;					// expect an update by MOVED_FROM inotify event cause changing file name
0000000000000000000000000000000000000000;;					expectEmptyUpdate(t, ch)
0000000000000000000000000000000000000000;;					// expect an update by MOVED_TO inotify event cause changing file name
0000000000000000000000000000000000000000;;					expectUpdate(t, ch, testCase)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deleteFile(dir, file string, ch chan interface{}, t *testing.T) {
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			path := filepath.Join(dir, file)
0000000000000000000000000000000000000000;;			err := os.Remove(path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unable to remove test file %s: %s", path, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectEmptyUpdate(t, ch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectUpdate(t *testing.T, ch chan interface{}, testCase *testCase) {
0000000000000000000000000000000000000000;;		timer := time.After(5 * time.Second)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case got := <-ch:
0000000000000000000000000000000000000000;;				update := got.(kubetypes.PodUpdate)
0000000000000000000000000000000000000000;;				for _, pod := range update.Pods {
0000000000000000000000000000000000000000;;					// TODO: remove the conversion when validation is performed on versioned objects.
0000000000000000000000000000000000000000;;					internalPod := &api.Pod{}
0000000000000000000000000000000000000000;;					if err := k8s_api_v1.Convert_v1_Pod_To_api_Pod(pod, internalPod, nil); err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: Cannot convert pod %#v, %#v", testCase.desc, pod, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if errs := validation.ValidatePod(internalPod); len(errs) > 0 {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: Invalid pod %#v, %#v", testCase.desc, internalPod, errs)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !apiequality.Semantic.DeepEqual(testCase.expected, update) {
0000000000000000000000000000000000000000;;					t.Fatalf("%s: Expected: %#v, Got: %#v", testCase.desc, testCase.expected, update)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-timer:
0000000000000000000000000000000000000000;;				t.Fatalf("%s: Expected update, timeout instead", testCase.desc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectEmptyUpdate(t *testing.T, ch chan interface{}) {
0000000000000000000000000000000000000000;;		timer := time.After(5 * time.Second)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case got := <-ch:
0000000000000000000000000000000000000000;;				update := got.(kubetypes.PodUpdate)
0000000000000000000000000000000000000000;;				if len(update.Pods) != 0 {
0000000000000000000000000000000000000000;;					t.Fatalf("expected empty update, got %#v", update)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-timer:
0000000000000000000000000000000000000000;;				t.Fatalf("expected empty update, timeout instead")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeFile(filename string, data []byte) error {
0000000000000000000000000000000000000000;;		f, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE, 0666)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err := f.Write(data)
0000000000000000000000000000000000000000;;		if err == nil && n < len(data) {
0000000000000000000000000000000000000000;;			err = io.ErrShortWrite
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err1 := f.Close(); err == nil {
0000000000000000000000000000000000000000;;			err = err1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func changeFileName(dir, from, to string, t *testing.T) {
0000000000000000000000000000000000000000;;		fromPath := filepath.Join(dir, from)
0000000000000000000000000000000000000000;;		toPath := filepath.Join(dir, to)
0000000000000000000000000000000000000000;;		if err := exec.Command("mv", fromPath, toPath).Run(); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Fail to change file name: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
