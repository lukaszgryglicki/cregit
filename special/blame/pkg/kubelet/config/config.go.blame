0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f37e8d7605f26ab00dd5d58e7b1225475d7a741a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		k8s_api_v1 "k8s.io/kubernetes/pkg/api/v1"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/events"
0000000000000000000000000000000000000000;;		kubetypes "k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/format"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/config"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodConfigNotificationMode describes how changes are sent to the update channel.
0000000000000000000000000000000000000000;;	type PodConfigNotificationMode int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// PodConfigNotificationUnknown is the default value for
0000000000000000000000000000000000000000;;		// PodConfigNotificationMode when uninitialized.
0000000000000000000000000000000000000000;;		PodConfigNotificationUnknown = iota
0000000000000000000000000000000000000000;;		// PodConfigNotificationSnapshot delivers the full configuration as a SET whenever
0000000000000000000000000000000000000000;;		// any change occurs.
0000000000000000000000000000000000000000;;		PodConfigNotificationSnapshot
0000000000000000000000000000000000000000;;		// PodConfigNotificationSnapshotAndUpdates delivers an UPDATE and DELETE message whenever pods are
0000000000000000000000000000000000000000;;		// changed, and a SET message if there are any additions or removals.
0000000000000000000000000000000000000000;;		PodConfigNotificationSnapshotAndUpdates
0000000000000000000000000000000000000000;;		// PodConfigNotificationIncremental delivers ADD, UPDATE, DELETE, REMOVE, RECONCILE to the update channel.
0000000000000000000000000000000000000000;;		PodConfigNotificationIncremental
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodConfig is a configuration mux that merges many sources of pod configuration into a single
0000000000000000000000000000000000000000;;	// consistent structure, and then delivers incremental change notifications to listeners
0000000000000000000000000000000000000000;;	// in order.
0000000000000000000000000000000000000000;;	type PodConfig struct {
0000000000000000000000000000000000000000;;		pods *podStorage
0000000000000000000000000000000000000000;;		mux  *config.Mux
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the channel of denormalized changes passed to listeners
0000000000000000000000000000000000000000;;		updates chan kubetypes.PodUpdate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// contains the list of all configured sources
0000000000000000000000000000000000000000;;		sourcesLock sync.Mutex
0000000000000000000000000000000000000000;;		sources     sets.String
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPodConfig creates an object that can merge many configuration sources into a stream
0000000000000000000000000000000000000000;;	// of normalized updates to a pod configuration.
0000000000000000000000000000000000000000;;	func NewPodConfig(mode PodConfigNotificationMode, recorder record.EventRecorder) *PodConfig {
0000000000000000000000000000000000000000;;		updates := make(chan kubetypes.PodUpdate, 50)
0000000000000000000000000000000000000000;;		storage := newPodStorage(updates, mode, recorder)
0000000000000000000000000000000000000000;;		podConfig := &PodConfig{
0000000000000000000000000000000000000000;;			pods:    storage,
0000000000000000000000000000000000000000;;			mux:     config.NewMux(storage),
0000000000000000000000000000000000000000;;			updates: updates,
0000000000000000000000000000000000000000;;			sources: sets.String{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return podConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Channel creates or returns a config source channel.  The channel
0000000000000000000000000000000000000000;;	// only accepts PodUpdates
0000000000000000000000000000000000000000;;	func (c *PodConfig) Channel(source string) chan<- interface{} {
0000000000000000000000000000000000000000;;		c.sourcesLock.Lock()
0000000000000000000000000000000000000000;;		defer c.sourcesLock.Unlock()
0000000000000000000000000000000000000000;;		c.sources.Insert(source)
0000000000000000000000000000000000000000;;		return c.mux.Channel(source)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SeenAllSources returns true if seenSources contains all sources in the
0000000000000000000000000000000000000000;;	// config, and also this config has received a SET message from each source.
0000000000000000000000000000000000000000;;	func (c *PodConfig) SeenAllSources(seenSources sets.String) bool {
0000000000000000000000000000000000000000;;		if c.pods == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(6).Infof("Looking for %v, have seen %v", c.sources.List(), seenSources)
0000000000000000000000000000000000000000;;		return seenSources.HasAll(c.sources.List()...) && c.pods.seenSources(c.sources.List()...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Updates returns a channel of updates to the configuration, properly denormalized.
0000000000000000000000000000000000000000;;	func (c *PodConfig) Updates() <-chan kubetypes.PodUpdate {
0000000000000000000000000000000000000000;;		return c.updates
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sync requests the full configuration be delivered to the update channel.
0000000000000000000000000000000000000000;;	func (c *PodConfig) Sync() {
0000000000000000000000000000000000000000;;		c.pods.Sync()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// podStorage manages the current pod state at any point in time and ensures updates
0000000000000000000000000000000000000000;;	// to the channel are delivered in order.  Note that this object is an in-memory source of
0000000000000000000000000000000000000000;;	// "truth" and on creation contains zero entries.  Once all previously read sources are
0000000000000000000000000000000000000000;;	// available, then this object should be considered authoritative.
0000000000000000000000000000000000000000;;	type podStorage struct {
0000000000000000000000000000000000000000;;		podLock sync.RWMutex
0000000000000000000000000000000000000000;;		// map of source name to pod uid to pod reference
0000000000000000000000000000000000000000;;		pods map[string]map[types.UID]*v1.Pod
0000000000000000000000000000000000000000;;		mode PodConfigNotificationMode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensures that updates are delivered in strict order
0000000000000000000000000000000000000000;;		// on the updates channel
0000000000000000000000000000000000000000;;		updateLock sync.Mutex
0000000000000000000000000000000000000000;;		updates    chan<- kubetypes.PodUpdate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// contains the set of all sources that have sent at least one SET
0000000000000000000000000000000000000000;;		sourcesSeenLock sync.RWMutex
0000000000000000000000000000000000000000;;		sourcesSeen     sets.String
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the EventRecorder to use
0000000000000000000000000000000000000000;;		recorder record.EventRecorder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: PodConfigNotificationMode could be handled by a listener to the updates channel
0000000000000000000000000000000000000000;;	// in the future, especially with multiple listeners.
0000000000000000000000000000000000000000;;	// TODO: allow initialization of the current state of the store with snapshotted version.
0000000000000000000000000000000000000000;;	func newPodStorage(updates chan<- kubetypes.PodUpdate, mode PodConfigNotificationMode, recorder record.EventRecorder) *podStorage {
0000000000000000000000000000000000000000;;		return &podStorage{
0000000000000000000000000000000000000000;;			pods:        make(map[string]map[types.UID]*v1.Pod),
0000000000000000000000000000000000000000;;			mode:        mode,
0000000000000000000000000000000000000000;;			updates:     updates,
0000000000000000000000000000000000000000;;			sourcesSeen: sets.String{},
0000000000000000000000000000000000000000;;			recorder:    recorder,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Merge normalizes a set of incoming changes from different sources into a map of all Pods
0000000000000000000000000000000000000000;;	// and ensures that redundant changes are filtered out, and then pushes zero or more minimal
0000000000000000000000000000000000000000;;	// updates onto the update channel.  Ensures that updates are delivered in order.
0000000000000000000000000000000000000000;;	func (s *podStorage) Merge(source string, change interface{}) error {
0000000000000000000000000000000000000000;;		s.updateLock.Lock()
0000000000000000000000000000000000000000;;		defer s.updateLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		seenBefore := s.sourcesSeen.Has(source)
0000000000000000000000000000000000000000;;		adds, updates, deletes, removes, reconciles := s.merge(source, change)
0000000000000000000000000000000000000000;;		firstSet := !seenBefore && s.sourcesSeen.Has(source)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// deliver update notifications
0000000000000000000000000000000000000000;;		switch s.mode {
0000000000000000000000000000000000000000;;		case PodConfigNotificationIncremental:
0000000000000000000000000000000000000000;;			if len(removes.Pods) > 0 {
0000000000000000000000000000000000000000;;				s.updates <- *removes
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(adds.Pods) > 0 {
0000000000000000000000000000000000000000;;				s.updates <- *adds
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(updates.Pods) > 0 {
0000000000000000000000000000000000000000;;				s.updates <- *updates
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(deletes.Pods) > 0 {
0000000000000000000000000000000000000000;;				s.updates <- *deletes
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if firstSet && len(adds.Pods) == 0 && len(updates.Pods) == 0 && len(deletes.Pods) == 0 {
0000000000000000000000000000000000000000;;				// Send an empty update when first seeing the source and there are
0000000000000000000000000000000000000000;;				// no ADD or UPDATE or DELETE pods from the source. This signals kubelet that
0000000000000000000000000000000000000000;;				// the source is ready.
0000000000000000000000000000000000000000;;				s.updates <- *adds
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Only add reconcile support here, because kubelet doesn't support Snapshot update now.
0000000000000000000000000000000000000000;;			if len(reconciles.Pods) > 0 {
0000000000000000000000000000000000000000;;				s.updates <- *reconciles
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case PodConfigNotificationSnapshotAndUpdates:
0000000000000000000000000000000000000000;;			if len(removes.Pods) > 0 || len(adds.Pods) > 0 || firstSet {
0000000000000000000000000000000000000000;;				s.updates <- kubetypes.PodUpdate{Pods: s.MergedState().([]*v1.Pod), Op: kubetypes.SET, Source: source}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(updates.Pods) > 0 {
0000000000000000000000000000000000000000;;				s.updates <- *updates
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(deletes.Pods) > 0 {
0000000000000000000000000000000000000000;;				s.updates <- *deletes
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case PodConfigNotificationSnapshot:
0000000000000000000000000000000000000000;;			if len(updates.Pods) > 0 || len(deletes.Pods) > 0 || len(adds.Pods) > 0 || len(removes.Pods) > 0 || firstSet {
0000000000000000000000000000000000000000;;				s.updates <- kubetypes.PodUpdate{Pods: s.MergedState().([]*v1.Pod), Op: kubetypes.SET, Source: source}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case PodConfigNotificationUnknown:
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("unsupported PodConfigNotificationMode: %#v", s.mode))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *podStorage) merge(source string, change interface{}) (adds, updates, deletes, removes, reconciles *kubetypes.PodUpdate) {
0000000000000000000000000000000000000000;;		s.podLock.Lock()
0000000000000000000000000000000000000000;;		defer s.podLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addPods := []*v1.Pod{}
0000000000000000000000000000000000000000;;		updatePods := []*v1.Pod{}
0000000000000000000000000000000000000000;;		deletePods := []*v1.Pod{}
0000000000000000000000000000000000000000;;		removePods := []*v1.Pod{}
0000000000000000000000000000000000000000;;		reconcilePods := []*v1.Pod{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods := s.pods[source]
0000000000000000000000000000000000000000;;		if pods == nil {
0000000000000000000000000000000000000000;;			pods = make(map[types.UID]*v1.Pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// updatePodFunc is the local function which updates the pod cache *oldPods* with new pods *newPods*.
0000000000000000000000000000000000000000;;		// After updated, new pod will be stored in the pod cache *pods*.
0000000000000000000000000000000000000000;;		// Notice that *pods* and *oldPods* could be the same cache.
0000000000000000000000000000000000000000;;		updatePodsFunc := func(newPods []*v1.Pod, oldPods, pods map[types.UID]*v1.Pod) {
0000000000000000000000000000000000000000;;			filtered := filterInvalidPods(newPods, source, s.recorder)
0000000000000000000000000000000000000000;;			for _, ref := range filtered {
0000000000000000000000000000000000000000;;				// Annotate the pod with the source before any comparison.
0000000000000000000000000000000000000000;;				if ref.Annotations == nil {
0000000000000000000000000000000000000000;;					ref.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ref.Annotations[kubetypes.ConfigSourceAnnotationKey] = source
0000000000000000000000000000000000000000;;				if existing, found := oldPods[ref.UID]; found {
0000000000000000000000000000000000000000;;					pods[ref.UID] = existing
0000000000000000000000000000000000000000;;					needUpdate, needReconcile, needGracefulDelete := checkAndUpdatePod(existing, ref)
0000000000000000000000000000000000000000;;					if needUpdate {
0000000000000000000000000000000000000000;;						updatePods = append(updatePods, existing)
0000000000000000000000000000000000000000;;					} else if needReconcile {
0000000000000000000000000000000000000000;;						reconcilePods = append(reconcilePods, existing)
0000000000000000000000000000000000000000;;					} else if needGracefulDelete {
0000000000000000000000000000000000000000;;						deletePods = append(deletePods, existing)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				recordFirstSeenTime(ref)
0000000000000000000000000000000000000000;;				pods[ref.UID] = ref
0000000000000000000000000000000000000000;;				addPods = append(addPods, ref)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		update := change.(kubetypes.PodUpdate)
0000000000000000000000000000000000000000;;		// The InitContainers and InitContainerStatuses fields are lost during
0000000000000000000000000000000000000000;;		// serialization and deserialization. They are conveyed via Annotations.
0000000000000000000000000000000000000000;;		// Setting these fields here so that kubelet doesn't have to check for
0000000000000000000000000000000000000000;;		// annotations.
0000000000000000000000000000000000000000;;		if source == kubetypes.ApiserverSource {
0000000000000000000000000000000000000000;;			for _, pod := range update.Pods {
0000000000000000000000000000000000000000;;				if err := podutil.SetInitContainersAndStatuses(pod); err != nil {
0000000000000000000000000000000000000000;;					glog.Error(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch update.Op {
0000000000000000000000000000000000000000;;		case kubetypes.ADD, kubetypes.UPDATE, kubetypes.DELETE:
0000000000000000000000000000000000000000;;			if update.Op == kubetypes.ADD {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Adding new pods from source %s : %v", source, update.Pods)
0000000000000000000000000000000000000000;;			} else if update.Op == kubetypes.DELETE {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Graceful deleting pods from source %s : %v", source, update.Pods)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Updating pods from source %s : %v", source, update.Pods)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			updatePodsFunc(update.Pods, pods, pods)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case kubetypes.REMOVE:
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Removing pods from source %s : %v", source, update.Pods)
0000000000000000000000000000000000000000;;			for _, value := range update.Pods {
0000000000000000000000000000000000000000;;				if existing, found := pods[value.UID]; found {
0000000000000000000000000000000000000000;;					// this is a delete
0000000000000000000000000000000000000000;;					delete(pods, value.UID)
0000000000000000000000000000000000000000;;					removePods = append(removePods, existing)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// this is a no-op
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case kubetypes.SET:
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Setting pods for source %s", source)
0000000000000000000000000000000000000000;;			s.markSourceSet(source)
0000000000000000000000000000000000000000;;			// Clear the old map entries by just creating a new map
0000000000000000000000000000000000000000;;			oldPods := pods
0000000000000000000000000000000000000000;;			pods = make(map[types.UID]*v1.Pod)
0000000000000000000000000000000000000000;;			updatePodsFunc(update.Pods, oldPods, pods)
0000000000000000000000000000000000000000;;			for uid, existing := range oldPods {
0000000000000000000000000000000000000000;;				if _, found := pods[uid]; !found {
0000000000000000000000000000000000000000;;					// this is a delete
0000000000000000000000000000000000000000;;					removePods = append(removePods, existing)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			glog.Warningf("Received invalid update type: %v", update)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.pods[source] = pods
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		adds = &kubetypes.PodUpdate{Op: kubetypes.ADD, Pods: copyPods(addPods), Source: source}
0000000000000000000000000000000000000000;;		updates = &kubetypes.PodUpdate{Op: kubetypes.UPDATE, Pods: copyPods(updatePods), Source: source}
0000000000000000000000000000000000000000;;		deletes = &kubetypes.PodUpdate{Op: kubetypes.DELETE, Pods: copyPods(deletePods), Source: source}
0000000000000000000000000000000000000000;;		removes = &kubetypes.PodUpdate{Op: kubetypes.REMOVE, Pods: copyPods(removePods), Source: source}
0000000000000000000000000000000000000000;;		reconciles = &kubetypes.PodUpdate{Op: kubetypes.RECONCILE, Pods: copyPods(reconcilePods), Source: source}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return adds, updates, deletes, removes, reconciles
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *podStorage) markSourceSet(source string) {
0000000000000000000000000000000000000000;;		s.sourcesSeenLock.Lock()
0000000000000000000000000000000000000000;;		defer s.sourcesSeenLock.Unlock()
0000000000000000000000000000000000000000;;		s.sourcesSeen.Insert(source)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *podStorage) seenSources(sources ...string) bool {
0000000000000000000000000000000000000000;;		s.sourcesSeenLock.RLock()
0000000000000000000000000000000000000000;;		defer s.sourcesSeenLock.RUnlock()
0000000000000000000000000000000000000000;;		return s.sourcesSeen.HasAll(sources...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func filterInvalidPods(pods []*v1.Pod, source string, recorder record.EventRecorder) (filtered []*v1.Pod) {
0000000000000000000000000000000000000000;;		names := sets.String{}
0000000000000000000000000000000000000000;;		for i, pod := range pods {
0000000000000000000000000000000000000000;;			var errlist field.ErrorList
0000000000000000000000000000000000000000;;			// TODO: remove the conversion when validation is performed on versioned objects.
0000000000000000000000000000000000000000;;			internalPod := &api.Pod{}
0000000000000000000000000000000000000000;;			if err := k8s_api_v1.Convert_v1_Pod_To_api_Pod(pod, internalPod, nil); err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Pod[%d] (%s) from %s failed to convert to v1, ignoring: %v", i+1, format.Pod(pod), source, err)
0000000000000000000000000000000000000000;;				recorder.Eventf(pod, v1.EventTypeWarning, "FailedConversion", "Error converting pod %s from %s, ignoring: %v", format.Pod(pod), source, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if errs := validation.ValidatePod(internalPod); len(errs) != 0 {
0000000000000000000000000000000000000000;;				errlist = append(errlist, errs...)
0000000000000000000000000000000000000000;;				// If validation fails, don't trust it any further -
0000000000000000000000000000000000000000;;				// even Name could be bad.
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				name := kubecontainer.GetPodFullName(pod)
0000000000000000000000000000000000000000;;				if names.Has(name) {
0000000000000000000000000000000000000000;;					// TODO: when validation becomes versioned, this gets a bit
0000000000000000000000000000000000000000;;					// more complicated.
0000000000000000000000000000000000000000;;					errlist = append(errlist, field.Duplicate(field.NewPath("metadata", "name"), pod.Name))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					names.Insert(name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(errlist) > 0 {
0000000000000000000000000000000000000000;;				err := errlist.ToAggregate()
0000000000000000000000000000000000000000;;				glog.Warningf("Pod[%d] (%s) from %s failed validation, ignoring: %v", i+1, format.Pod(pod), source, err)
0000000000000000000000000000000000000000;;				recorder.Eventf(pod, v1.EventTypeWarning, events.FailedValidation, "Error validating pod %s from %s, ignoring: %v", format.Pod(pod), source, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			filtered = append(filtered, pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Annotations that the kubelet adds to the pod.
0000000000000000000000000000000000000000;;	var localAnnotations = []string{
0000000000000000000000000000000000000000;;		kubetypes.ConfigSourceAnnotationKey,
0000000000000000000000000000000000000000;;		kubetypes.ConfigMirrorAnnotationKey,
0000000000000000000000000000000000000000;;		kubetypes.ConfigFirstSeenAnnotationKey,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isLocalAnnotationKey(key string) bool {
0000000000000000000000000000000000000000;;		for _, localKey := range localAnnotations {
0000000000000000000000000000000000000000;;			if key == localKey {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isAnnotationMapEqual returns true if the existing annotation Map is equal to candidate except
0000000000000000000000000000000000000000;;	// for local annotations.
0000000000000000000000000000000000000000;;	func isAnnotationMapEqual(existingMap, candidateMap map[string]string) bool {
0000000000000000000000000000000000000000;;		if candidateMap == nil {
0000000000000000000000000000000000000000;;			candidateMap = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range candidateMap {
0000000000000000000000000000000000000000;;			if isLocalAnnotationKey(k) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if existingValue, ok := existingMap[k]; ok && existingValue == v {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k := range existingMap {
0000000000000000000000000000000000000000;;			if isLocalAnnotationKey(k) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// stale entry in existing map.
0000000000000000000000000000000000000000;;			if _, exists := candidateMap[k]; !exists {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recordFirstSeenTime records the first seen time of this pod.
0000000000000000000000000000000000000000;;	func recordFirstSeenTime(pod *v1.Pod) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Receiving a new pod %q", format.Pod(pod))
0000000000000000000000000000000000000000;;		pod.Annotations[kubetypes.ConfigFirstSeenAnnotationKey] = kubetypes.NewTimestamp().GetString()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateAnnotations returns an Annotation map containing the api annotation map plus
0000000000000000000000000000000000000000;;	// locally managed annotations
0000000000000000000000000000000000000000;;	func updateAnnotations(existing, ref *v1.Pod) {
0000000000000000000000000000000000000000;;		annotations := make(map[string]string, len(ref.Annotations)+len(localAnnotations))
0000000000000000000000000000000000000000;;		for k, v := range ref.Annotations {
0000000000000000000000000000000000000000;;			annotations[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, k := range localAnnotations {
0000000000000000000000000000000000000000;;			if v, ok := existing.Annotations[k]; ok {
0000000000000000000000000000000000000000;;				annotations[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		existing.Annotations = annotations
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func podsDifferSemantically(existing, ref *v1.Pod) bool {
0000000000000000000000000000000000000000;;		if reflect.DeepEqual(existing.Spec, ref.Spec) &&
0000000000000000000000000000000000000000;;			reflect.DeepEqual(existing.Labels, ref.Labels) &&
0000000000000000000000000000000000000000;;			reflect.DeepEqual(existing.DeletionTimestamp, ref.DeletionTimestamp) &&
0000000000000000000000000000000000000000;;			reflect.DeepEqual(existing.DeletionGracePeriodSeconds, ref.DeletionGracePeriodSeconds) &&
0000000000000000000000000000000000000000;;			isAnnotationMapEqual(existing.Annotations, ref.Annotations) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkAndUpdatePod updates existing, and:
0000000000000000000000000000000000000000;;	//   * if ref makes a meaningful change, returns needUpdate=true
0000000000000000000000000000000000000000;;	//   * if ref makes a meaningful change, and this change is graceful deletion, returns needGracefulDelete=true
0000000000000000000000000000000000000000;;	//   * if ref makes no meaningful change, but changes the pod status, returns needReconcile=true
0000000000000000000000000000000000000000;;	//   * else return all false
0000000000000000000000000000000000000000;;	//   Now, needUpdate, needGracefulDelete and needReconcile should never be both true
0000000000000000000000000000000000000000;;	func checkAndUpdatePod(existing, ref *v1.Pod) (needUpdate, needReconcile, needGracefulDelete bool) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 1. this is a reconcile
0000000000000000000000000000000000000000;;		// TODO: it would be better to update the whole object and only preserve certain things
0000000000000000000000000000000000000000;;		//       like the source annotation or the UID (to ensure safety)
0000000000000000000000000000000000000000;;		if !podsDifferSemantically(existing, ref) {
0000000000000000000000000000000000000000;;			// this is not an update
0000000000000000000000000000000000000000;;			// Only check reconcile when it is not an update, because if the pod is going to
0000000000000000000000000000000000000000;;			// be updated, an extra reconcile is unnecessary
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(existing.Status, ref.Status) {
0000000000000000000000000000000000000000;;				// Pod with changed pod status needs reconcile, because kubelet should
0000000000000000000000000000000000000000;;				// be the source of truth of pod status.
0000000000000000000000000000000000000000;;				existing.Status = ref.Status
0000000000000000000000000000000000000000;;				needReconcile = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Overwrite the first-seen time with the existing one. This is our own
0000000000000000000000000000000000000000;;		// internal annotation, there is no need to update.
0000000000000000000000000000000000000000;;		ref.Annotations[kubetypes.ConfigFirstSeenAnnotationKey] = existing.Annotations[kubetypes.ConfigFirstSeenAnnotationKey]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existing.Spec = ref.Spec
0000000000000000000000000000000000000000;;		existing.Labels = ref.Labels
0000000000000000000000000000000000000000;;		existing.DeletionTimestamp = ref.DeletionTimestamp
0000000000000000000000000000000000000000;;		existing.DeletionGracePeriodSeconds = ref.DeletionGracePeriodSeconds
0000000000000000000000000000000000000000;;		existing.Status = ref.Status
0000000000000000000000000000000000000000;;		updateAnnotations(existing, ref)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 2. this is an graceful delete
0000000000000000000000000000000000000000;;		if ref.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;			needGracefulDelete = true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// 3. this is an update
0000000000000000000000000000000000000000;;			needUpdate = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sync sends a copy of the current state through the update channel.
0000000000000000000000000000000000000000;;	func (s *podStorage) Sync() {
0000000000000000000000000000000000000000;;		s.updateLock.Lock()
0000000000000000000000000000000000000000;;		defer s.updateLock.Unlock()
0000000000000000000000000000000000000000;;		s.updates <- kubetypes.PodUpdate{Pods: s.MergedState().([]*v1.Pod), Op: kubetypes.SET, Source: kubetypes.AllSource}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Object implements config.Accessor
0000000000000000000000000000000000000000;;	func (s *podStorage) MergedState() interface{} {
0000000000000000000000000000000000000000;;		s.podLock.RLock()
0000000000000000000000000000000000000000;;		defer s.podLock.RUnlock()
0000000000000000000000000000000000000000;;		pods := make([]*v1.Pod, 0)
0000000000000000000000000000000000000000;;		for _, sourcePods := range s.pods {
0000000000000000000000000000000000000000;;			for _, podRef := range sourcePods {
0000000000000000000000000000000000000000;;				pod, err := api.Scheme.Copy(podRef)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("unable to copy pod: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pods = append(pods, pod.(*v1.Pod))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func copyPods(sourcePods []*v1.Pod) []*v1.Pod {
0000000000000000000000000000000000000000;;		pods := []*v1.Pod{}
0000000000000000000000000000000000000000;;		for _, source := range sourcePods {
0000000000000000000000000000000000000000;;			// Use a deep copy here just in case
0000000000000000000000000000000000000000;;			pod, err := api.Scheme.Copy(source)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("unable to copy pod: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pods = append(pods, pod.(*v1.Pod))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pods
0000000000000000000000000000000000000000;;	}
