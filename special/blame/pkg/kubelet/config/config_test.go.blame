0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f37e8d7605f26ab00dd5d58e7b1225475d7a741a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		kubetypes "k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/securitycontext"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		TestSource = "test"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectEmptyChannel(t *testing.T, ch <-chan interface{}) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case update := <-ch:
0000000000000000000000000000000000000000;;			t.Errorf("Expected no update in channel, Got %v", update)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sortedPods []*v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s sortedPods) Len() int {
0000000000000000000000000000000000000000;;		return len(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (s sortedPods) Swap(i, j int) {
0000000000000000000000000000000000000000;;		s[i], s[j] = s[j], s[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (s sortedPods) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return s[i].Namespace < s[j].Namespace
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreateValidPod(name, namespace string) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       types.UID(name + namespace), // for the purpose of testing, this is unique enough
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyAlways,
0000000000000000000000000000000000000000;;				DNSPolicy:     v1.DNSClusterFirst,
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:                     "ctr",
0000000000000000000000000000000000000000;;						Image:                    "image",
0000000000000000000000000000000000000000;;						ImagePullPolicy:          "IfNotPresent",
0000000000000000000000000000000000000000;;						SecurityContext:          securitycontext.ValidSecurityContextWithContainerDefaults(),
0000000000000000000000000000000000000000;;						TerminationMessagePolicy: v1.TerminationMessageReadFile,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreatePodUpdate(op kubetypes.PodOperation, source string, pods ...*v1.Pod) kubetypes.PodUpdate {
0000000000000000000000000000000000000000;;		return kubetypes.PodUpdate{Pods: pods, Op: op, Source: source}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPodConfigTester(mode PodConfigNotificationMode) (chan<- interface{}, <-chan kubetypes.PodUpdate, *PodConfig) {
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		config := NewPodConfig(mode, eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "kubelet"}))
0000000000000000000000000000000000000000;;		channel := config.Channel(TestSource)
0000000000000000000000000000000000000000;;		ch := config.Updates()
0000000000000000000000000000000000000000;;		return channel, ch, config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectPodUpdate(t *testing.T, ch <-chan kubetypes.PodUpdate, expected ...kubetypes.PodUpdate) {
0000000000000000000000000000000000000000;;		for i := range expected {
0000000000000000000000000000000000000000;;			update := <-ch
0000000000000000000000000000000000000000;;			sort.Sort(sortedPods(update.Pods))
0000000000000000000000000000000000000000;;			sort.Sort(sortedPods(expected[i].Pods))
0000000000000000000000000000000000000000;;			// Make copies of the expected/actual update to compare all fields
0000000000000000000000000000000000000000;;			// except for "Pods", which are compared separately below.
0000000000000000000000000000000000000000;;			expectedCopy, updateCopy := expected[i], update
0000000000000000000000000000000000000000;;			expectedCopy.Pods, updateCopy.Pods = nil, nil
0000000000000000000000000000000000000000;;			if !apiequality.Semantic.DeepEqual(expectedCopy, updateCopy) {
0000000000000000000000000000000000000000;;				t.Fatalf("Expected %#v, Got %#v", expectedCopy, updateCopy)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(expected[i].Pods) != len(update.Pods) {
0000000000000000000000000000000000000000;;				t.Fatalf("Expected %#v, Got %#v", expected[i], update)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Compare pods one by one. This is necessary because we don't want to
0000000000000000000000000000000000000000;;			// compare local annotations.
0000000000000000000000000000000000000000;;			for j := range expected[i].Pods {
0000000000000000000000000000000000000000;;				if podsDifferSemantically(expected[i].Pods[j], update.Pods[j]) || !reflect.DeepEqual(expected[i].Pods[j].Status, update.Pods[j].Status) {
0000000000000000000000000000000000000000;;					t.Fatalf("Expected %#v, Got %#v", expected[i].Pods[j], update.Pods[j])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectNoPodUpdate(t, ch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectNoPodUpdate(t *testing.T, ch <-chan kubetypes.PodUpdate) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case update := <-ch:
0000000000000000000000000000000000000000;;			t.Errorf("Expected no update in channel, Got %#v", update)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewPodAdded(t *testing.T) {
0000000000000000000000000000000000000000;;		channel, ch, config := createPodConfigTester(PodConfigNotificationIncremental)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// see an update
0000000000000000000000000000000000000000;;		podUpdate := CreatePodUpdate(kubetypes.ADD, TestSource, CreateValidPod("foo", "new"))
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.ADD, TestSource, CreateValidPod("foo", "new")))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.Sync()
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.SET, kubetypes.AllSource, CreateValidPod("foo", "new")))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewPodAddedInvalidNamespace(t *testing.T) {
0000000000000000000000000000000000000000;;		channel, ch, config := createPodConfigTester(PodConfigNotificationIncremental)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// see an update
0000000000000000000000000000000000000000;;		podUpdate := CreatePodUpdate(kubetypes.ADD, TestSource, CreateValidPod("foo", ""))
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		config.Sync()
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.SET, kubetypes.AllSource))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewPodAddedDefaultNamespace(t *testing.T) {
0000000000000000000000000000000000000000;;		channel, ch, config := createPodConfigTester(PodConfigNotificationIncremental)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// see an update
0000000000000000000000000000000000000000;;		podUpdate := CreatePodUpdate(kubetypes.ADD, TestSource, CreateValidPod("foo", "default"))
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.ADD, TestSource, CreateValidPod("foo", "default")))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.Sync()
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.SET, kubetypes.AllSource, CreateValidPod("foo", "default")))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewPodAddedDifferentNamespaces(t *testing.T) {
0000000000000000000000000000000000000000;;		channel, ch, config := createPodConfigTester(PodConfigNotificationIncremental)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// see an update
0000000000000000000000000000000000000000;;		podUpdate := CreatePodUpdate(kubetypes.ADD, TestSource, CreateValidPod("foo", "default"))
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.ADD, TestSource, CreateValidPod("foo", "default")))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// see an update in another namespace
0000000000000000000000000000000000000000;;		podUpdate = CreatePodUpdate(kubetypes.ADD, TestSource, CreateValidPod("foo", "new"))
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.ADD, TestSource, CreateValidPod("foo", "new")))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.Sync()
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.SET, kubetypes.AllSource, CreateValidPod("foo", "default"), CreateValidPod("foo", "new")))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInvalidPodFiltered(t *testing.T) {
0000000000000000000000000000000000000000;;		channel, ch, _ := createPodConfigTester(PodConfigNotificationIncremental)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// see an update
0000000000000000000000000000000000000000;;		podUpdate := CreatePodUpdate(kubetypes.ADD, TestSource, CreateValidPod("foo", "new"))
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.ADD, TestSource, CreateValidPod("foo", "new")))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// add an invalid update
0000000000000000000000000000000000000000;;		podUpdate = CreatePodUpdate(kubetypes.UPDATE, TestSource, &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}})
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		expectNoPodUpdate(t, ch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewPodAddedSnapshotAndUpdates(t *testing.T) {
0000000000000000000000000000000000000000;;		channel, ch, config := createPodConfigTester(PodConfigNotificationSnapshotAndUpdates)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// see an set
0000000000000000000000000000000000000000;;		podUpdate := CreatePodUpdate(kubetypes.ADD, TestSource, CreateValidPod("foo", "new"))
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.SET, TestSource, CreateValidPod("foo", "new")))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.Sync()
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.SET, kubetypes.AllSource, CreateValidPod("foo", "new")))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// container updates are separated as UPDATE
0000000000000000000000000000000000000000;;		pod := *podUpdate.Pods[0]
0000000000000000000000000000000000000000;;		pod.Spec.Containers = []v1.Container{{Name: "bar", Image: "test", ImagePullPolicy: v1.PullIfNotPresent, TerminationMessagePolicy: v1.TerminationMessageReadFile}}
0000000000000000000000000000000000000000;;		channel <- CreatePodUpdate(kubetypes.ADD, TestSource, &pod)
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.UPDATE, TestSource, &pod))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewPodAddedSnapshot(t *testing.T) {
0000000000000000000000000000000000000000;;		channel, ch, config := createPodConfigTester(PodConfigNotificationSnapshot)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// see an set
0000000000000000000000000000000000000000;;		podUpdate := CreatePodUpdate(kubetypes.ADD, TestSource, CreateValidPod("foo", "new"))
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.SET, TestSource, CreateValidPod("foo", "new")))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.Sync()
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.SET, kubetypes.AllSource, CreateValidPod("foo", "new")))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// container updates are separated as UPDATE
0000000000000000000000000000000000000000;;		pod := *podUpdate.Pods[0]
0000000000000000000000000000000000000000;;		pod.Spec.Containers = []v1.Container{{Name: "bar", Image: "test", ImagePullPolicy: v1.PullIfNotPresent, TerminationMessagePolicy: v1.TerminationMessageReadFile}}
0000000000000000000000000000000000000000;;		channel <- CreatePodUpdate(kubetypes.ADD, TestSource, &pod)
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.SET, TestSource, &pod))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewPodAddedUpdatedRemoved(t *testing.T) {
0000000000000000000000000000000000000000;;		channel, ch, _ := createPodConfigTester(PodConfigNotificationIncremental)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// should register an add
0000000000000000000000000000000000000000;;		podUpdate := CreatePodUpdate(kubetypes.ADD, TestSource, CreateValidPod("foo", "new"))
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.ADD, TestSource, CreateValidPod("foo", "new")))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// should ignore ADDs that are identical
0000000000000000000000000000000000000000;;		expectNoPodUpdate(t, ch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// an kubetypes.ADD should be converted to kubetypes.UPDATE
0000000000000000000000000000000000000000;;		pod := CreateValidPod("foo", "new")
0000000000000000000000000000000000000000;;		pod.Spec.Containers = []v1.Container{{Name: "bar", Image: "test", ImagePullPolicy: v1.PullIfNotPresent, TerminationMessagePolicy: v1.TerminationMessageReadFile}}
0000000000000000000000000000000000000000;;		podUpdate = CreatePodUpdate(kubetypes.ADD, TestSource, pod)
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.UPDATE, TestSource, pod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podUpdate = CreatePodUpdate(kubetypes.REMOVE, TestSource, CreateValidPod("foo", "new"))
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.REMOVE, TestSource, pod))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewPodAddedDelete(t *testing.T) {
0000000000000000000000000000000000000000;;		channel, ch, _ := createPodConfigTester(PodConfigNotificationIncremental)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// should register an add
0000000000000000000000000000000000000000;;		addedPod := CreateValidPod("foo", "new")
0000000000000000000000000000000000000000;;		podUpdate := CreatePodUpdate(kubetypes.ADD, TestSource, addedPod)
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.ADD, TestSource, addedPod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// mark this pod as deleted
0000000000000000000000000000000000000000;;		timestamp := metav1.NewTime(time.Now())
0000000000000000000000000000000000000000;;		deletedPod := CreateValidPod("foo", "new")
0000000000000000000000000000000000000000;;		deletedPod.ObjectMeta.DeletionTimestamp = &timestamp
0000000000000000000000000000000000000000;;		podUpdate = CreatePodUpdate(kubetypes.DELETE, TestSource, deletedPod)
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		// the existing pod should be gracefully deleted
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.DELETE, TestSource, addedPod))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewPodAddedUpdatedSet(t *testing.T) {
0000000000000000000000000000000000000000;;		channel, ch, _ := createPodConfigTester(PodConfigNotificationIncremental)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// should register an add
0000000000000000000000000000000000000000;;		podUpdate := CreatePodUpdate(kubetypes.ADD, TestSource, CreateValidPod("foo", "new"), CreateValidPod("foo2", "new"), CreateValidPod("foo3", "new"))
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.ADD, TestSource, CreateValidPod("foo", "new"), CreateValidPod("foo2", "new"), CreateValidPod("foo3", "new")))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// should ignore ADDs that are identical
0000000000000000000000000000000000000000;;		expectNoPodUpdate(t, ch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// should be converted to an kubetypes.ADD, kubetypes.REMOVE, and kubetypes.UPDATE
0000000000000000000000000000000000000000;;		pod := CreateValidPod("foo2", "new")
0000000000000000000000000000000000000000;;		pod.Spec.Containers = []v1.Container{{Name: "bar", Image: "test", ImagePullPolicy: v1.PullIfNotPresent, TerminationMessagePolicy: v1.TerminationMessageReadFile}}
0000000000000000000000000000000000000000;;		podUpdate = CreatePodUpdate(kubetypes.SET, TestSource, pod, CreateValidPod("foo3", "new"), CreateValidPod("foo4", "new"))
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch,
0000000000000000000000000000000000000000;;			CreatePodUpdate(kubetypes.REMOVE, TestSource, CreateValidPod("foo", "new")),
0000000000000000000000000000000000000000;;			CreatePodUpdate(kubetypes.ADD, TestSource, CreateValidPod("foo4", "new")),
0000000000000000000000000000000000000000;;			CreatePodUpdate(kubetypes.UPDATE, TestSource, pod))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewPodAddedSetReconciled(t *testing.T) {
0000000000000000000000000000000000000000;;		// Create and touch new test pods, return the new pods and touched pod. We should create new pod list
0000000000000000000000000000000000000000;;		// before touching to avoid data race.
0000000000000000000000000000000000000000;;		newTestPods := func(touchStatus, touchSpec bool) ([]*v1.Pod, *v1.Pod) {
0000000000000000000000000000000000000000;;			pods := []*v1.Pod{
0000000000000000000000000000000000000000;;				CreateValidPod("changeable-pod-0", "new"),
0000000000000000000000000000000000000000;;				CreateValidPod("constant-pod-1", "new"),
0000000000000000000000000000000000000000;;				CreateValidPod("constant-pod-2", "new"),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if touchStatus {
0000000000000000000000000000000000000000;;				pods[0].Status = v1.PodStatus{Message: strconv.Itoa(rand.Int())}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if touchSpec {
0000000000000000000000000000000000000000;;				pods[0].Spec.Containers[0].Name = strconv.Itoa(rand.Int())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return pods, pods[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, op := range []kubetypes.PodOperation{
0000000000000000000000000000000000000000;;			kubetypes.ADD,
0000000000000000000000000000000000000000;;			kubetypes.SET,
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			var podWithStatusChange *v1.Pod
0000000000000000000000000000000000000000;;			pods, _ := newTestPods(false, false)
0000000000000000000000000000000000000000;;			channel, ch, _ := createPodConfigTester(PodConfigNotificationIncremental)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Use SET to initialize the config, especially initialize the source set
0000000000000000000000000000000000000000;;			channel <- CreatePodUpdate(kubetypes.SET, TestSource, pods...)
0000000000000000000000000000000000000000;;			expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.ADD, TestSource, pods...))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If status is not changed, no reconcile should be triggered
0000000000000000000000000000000000000000;;			channel <- CreatePodUpdate(op, TestSource, pods...)
0000000000000000000000000000000000000000;;			expectNoPodUpdate(t, ch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If the pod status is changed and not updated, a reconcile should be triggered
0000000000000000000000000000000000000000;;			pods, podWithStatusChange = newTestPods(true, false)
0000000000000000000000000000000000000000;;			channel <- CreatePodUpdate(op, TestSource, pods...)
0000000000000000000000000000000000000000;;			expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.RECONCILE, TestSource, podWithStatusChange))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If the pod status is changed, but the pod is also updated, no reconcile should be triggered
0000000000000000000000000000000000000000;;			pods, podWithStatusChange = newTestPods(true, true)
0000000000000000000000000000000000000000;;			channel <- CreatePodUpdate(op, TestSource, pods...)
0000000000000000000000000000000000000000;;			expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.UPDATE, TestSource, podWithStatusChange))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInitialEmptySet(t *testing.T) {
0000000000000000000000000000000000000000;;		for _, test := range []struct {
0000000000000000000000000000000000000000;;			mode PodConfigNotificationMode
0000000000000000000000000000000000000000;;			op   kubetypes.PodOperation
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{PodConfigNotificationIncremental, kubetypes.ADD},
0000000000000000000000000000000000000000;;			{PodConfigNotificationSnapshot, kubetypes.SET},
0000000000000000000000000000000000000000;;			{PodConfigNotificationSnapshotAndUpdates, kubetypes.SET},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			channel, ch, _ := createPodConfigTester(test.mode)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// should register an empty PodUpdate operation
0000000000000000000000000000000000000000;;			podUpdate := CreatePodUpdate(kubetypes.SET, TestSource)
0000000000000000000000000000000000000000;;			channel <- podUpdate
0000000000000000000000000000000000000000;;			expectPodUpdate(t, ch, CreatePodUpdate(test.op, TestSource))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// should ignore following empty sets
0000000000000000000000000000000000000000;;			podUpdate = CreatePodUpdate(kubetypes.SET, TestSource)
0000000000000000000000000000000000000000;;			channel <- podUpdate
0000000000000000000000000000000000000000;;			podUpdate = CreatePodUpdate(kubetypes.ADD, TestSource, CreateValidPod("foo", "new"))
0000000000000000000000000000000000000000;;			channel <- podUpdate
0000000000000000000000000000000000000000;;			expectPodUpdate(t, ch, CreatePodUpdate(test.op, TestSource, CreateValidPod("foo", "new")))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodUpdateAnnotations(t *testing.T) {
0000000000000000000000000000000000000000;;		channel, ch, _ := createPodConfigTester(PodConfigNotificationIncremental)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := CreateValidPod("foo2", "new")
0000000000000000000000000000000000000000;;		pod.Annotations = make(map[string]string, 0)
0000000000000000000000000000000000000000;;		pod.Annotations["kubernetes.io/blah"] = "blah"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clone, err := api.Scheme.DeepCopy(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podUpdate := CreatePodUpdate(kubetypes.SET, TestSource, CreateValidPod("foo1", "new"), clone.(*v1.Pod), CreateValidPod("foo3", "new"))
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.ADD, TestSource, CreateValidPod("foo1", "new"), pod, CreateValidPod("foo3", "new")))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod.Annotations["kubenetes.io/blah"] = "superblah"
0000000000000000000000000000000000000000;;		podUpdate = CreatePodUpdate(kubetypes.SET, TestSource, CreateValidPod("foo1", "new"), pod, CreateValidPod("foo3", "new"))
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.UPDATE, TestSource, pod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod.Annotations["kubernetes.io/otherblah"] = "doh"
0000000000000000000000000000000000000000;;		podUpdate = CreatePodUpdate(kubetypes.SET, TestSource, CreateValidPod("foo1", "new"), pod, CreateValidPod("foo3", "new"))
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.UPDATE, TestSource, pod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete(pod.Annotations, "kubernetes.io/blah")
0000000000000000000000000000000000000000;;		podUpdate = CreatePodUpdate(kubetypes.SET, TestSource, CreateValidPod("foo1", "new"), pod, CreateValidPod("foo3", "new"))
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.UPDATE, TestSource, pod))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodUpdateLabels(t *testing.T) {
0000000000000000000000000000000000000000;;		channel, ch, _ := createPodConfigTester(PodConfigNotificationIncremental)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := CreateValidPod("foo2", "new")
0000000000000000000000000000000000000000;;		pod.Labels = make(map[string]string, 0)
0000000000000000000000000000000000000000;;		pod.Labels["key"] = "value"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clone, err := api.Scheme.DeepCopy(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podUpdate := CreatePodUpdate(kubetypes.SET, TestSource, clone.(*v1.Pod))
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.ADD, TestSource, pod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod.Labels["key"] = "newValue"
0000000000000000000000000000000000000000;;		podUpdate = CreatePodUpdate(kubetypes.SET, TestSource, pod)
0000000000000000000000000000000000000000;;		channel <- podUpdate
0000000000000000000000000000000000000000;;		expectPodUpdate(t, ch, CreatePodUpdate(kubetypes.UPDATE, TestSource, pod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
