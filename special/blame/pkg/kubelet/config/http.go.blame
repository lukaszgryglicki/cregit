0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f37e8d7605f26ab00dd5d58e7b1225475d7a741a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reads the pod configuration from an HTTP GET response.
0000000000000000000000000000000000000000;;	package config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		kubetypes "k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sourceURL struct {
0000000000000000000000000000000000000000;;		url         string
0000000000000000000000000000000000000000;;		header      http.Header
0000000000000000000000000000000000000000;;		nodeName    types.NodeName
0000000000000000000000000000000000000000;;		updates     chan<- interface{}
0000000000000000000000000000000000000000;;		data        []byte
0000000000000000000000000000000000000000;;		failureLogs int
0000000000000000000000000000000000000000;;		client      *http.Client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSourceURL(url string, header http.Header, nodeName types.NodeName, period time.Duration, updates chan<- interface{}) {
0000000000000000000000000000000000000000;;		config := &sourceURL{
0000000000000000000000000000000000000000;;			url:      url,
0000000000000000000000000000000000000000;;			header:   header,
0000000000000000000000000000000000000000;;			nodeName: nodeName,
0000000000000000000000000000000000000000;;			updates:  updates,
0000000000000000000000000000000000000000;;			data:     nil,
0000000000000000000000000000000000000000;;			// Timing out requests leads to retries. This client is only used to
0000000000000000000000000000000000000000;;			// read the manifest URL passed to kubelet.
0000000000000000000000000000000000000000;;			client: &http.Client{Timeout: 10 * time.Second},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(1).Infof("Watching URL %s", url)
0000000000000000000000000000000000000000;;		go wait.Until(config.run, period, wait.NeverStop)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sourceURL) run() {
0000000000000000000000000000000000000000;;		if err := s.extractFromURL(); err != nil {
0000000000000000000000000000000000000000;;			// Don't log this multiple times per minute. The first few entries should be
0000000000000000000000000000000000000000;;			// enough to get the point across.
0000000000000000000000000000000000000000;;			if s.failureLogs < 3 {
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to read pods from URL: %v", err)
0000000000000000000000000000000000000000;;			} else if s.failureLogs == 3 {
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to read pods from URL. Dropping verbosity of this message to V(4): %v", err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Failed to read pods from URL: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.failureLogs++
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if s.failureLogs > 0 {
0000000000000000000000000000000000000000;;				glog.Info("Successfully read pods from URL.")
0000000000000000000000000000000000000000;;				s.failureLogs = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sourceURL) applyDefaults(pod *api.Pod) error {
0000000000000000000000000000000000000000;;		return applyDefaults(pod, s.url, false, s.nodeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sourceURL) extractFromURL() error {
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("GET", s.url, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header = s.header
0000000000000000000000000000000000000000;;		resp, err := s.client.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%v: %v", s.url, resp.Status)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(data) == 0 {
0000000000000000000000000000000000000000;;			// Emit an update with an empty PodList to allow HTTPSource to be marked as seen
0000000000000000000000000000000000000000;;			s.updates <- kubetypes.PodUpdate{Pods: []*v1.Pod{}, Op: kubetypes.SET, Source: kubetypes.HTTPSource}
0000000000000000000000000000000000000000;;			return fmt.Errorf("zero-length data received from %v", s.url)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Short circuit if the data has not changed since the last time it was read.
0000000000000000000000000000000000000000;;		if bytes.Compare(data, s.data) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.data = data
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// First try as it is a single pod.
0000000000000000000000000000000000000000;;		parsed, pod, singlePodErr := tryDecodeSinglePod(data, s.applyDefaults)
0000000000000000000000000000000000000000;;		if parsed {
0000000000000000000000000000000000000000;;			if singlePodErr != nil {
0000000000000000000000000000000000000000;;				// It parsed but could not be used.
0000000000000000000000000000000000000000;;				return singlePodErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.updates <- kubetypes.PodUpdate{Pods: []*v1.Pod{pod}, Op: kubetypes.SET, Source: kubetypes.HTTPSource}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// That didn't work, so try a list of pods.
0000000000000000000000000000000000000000;;		parsed, podList, multiPodErr := tryDecodePodList(data, s.applyDefaults)
0000000000000000000000000000000000000000;;		if parsed {
0000000000000000000000000000000000000000;;			if multiPodErr != nil {
0000000000000000000000000000000000000000;;				// It parsed but could not be used.
0000000000000000000000000000000000000000;;				return multiPodErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pods := make([]*v1.Pod, 0)
0000000000000000000000000000000000000000;;			for i := range podList.Items {
0000000000000000000000000000000000000000;;				pods = append(pods, &podList.Items[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.updates <- kubetypes.PodUpdate{Pods: pods, Op: kubetypes.SET, Source: kubetypes.HTTPSource}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Errorf("%v: received '%v', but couldn't parse as "+
0000000000000000000000000000000000000000;;			"single (%v) or multiple pods (%v).\n",
0000000000000000000000000000000000000000;;			s.url, string(data), singlePodErr, multiPodErr)
0000000000000000000000000000000000000000;;	}
