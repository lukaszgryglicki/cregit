0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
d1082e6af7aa568f9d4d275ed184a1dead0ee780;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		kubetypes "k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakePodLW struct {
0000000000000000000000000000000000000000;;		listResp  runtime.Object
0000000000000000000000000000000000000000;;		watchResp watch.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lw fakePodLW) List(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		return lw.listResp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lw fakePodLW) Watch(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		return lw.watchResp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ cache.ListerWatcher = fakePodLW{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewSourceApiserver_UpdatesAndMultiplePods(t *testing.T) {
0000000000000000000000000000000000000000;;		pod1v1 := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "p"},
0000000000000000000000000000000000000000;;			Spec:       v1.PodSpec{Containers: []v1.Container{{Image: "image/one"}}}}
0000000000000000000000000000000000000000;;		pod1v2 := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "p"},
0000000000000000000000000000000000000000;;			Spec:       v1.PodSpec{Containers: []v1.Container{{Image: "image/two"}}}}
0000000000000000000000000000000000000000;;		pod2 := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "q"},
0000000000000000000000000000000000000000;;			Spec:       v1.PodSpec{Containers: []v1.Container{{Image: "image/blah"}}}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup fake api client.
0000000000000000000000000000000000000000;;		fakeWatch := watch.NewFake()
0000000000000000000000000000000000000000;;		lw := fakePodLW{
0000000000000000000000000000000000000000;;			listResp:  &v1.PodList{Items: []v1.Pod{*pod1v1}},
0000000000000000000000000000000000000000;;			watchResp: fakeWatch,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ch := make(chan interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newSourceApiserverFromLW(lw, ch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		got, ok := <-ch
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Unable to read from channel when expected")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		update := got.(kubetypes.PodUpdate)
0000000000000000000000000000000000000000;;		expected := CreatePodUpdate(kubetypes.SET, kubetypes.ApiserverSource, pod1v1)
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(expected, update) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %#v; Got %#v", expected, update)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add another pod
0000000000000000000000000000000000000000;;		fakeWatch.Add(pod2)
0000000000000000000000000000000000000000;;		got, ok = <-ch
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Unable to read from channel when expected")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		update = got.(kubetypes.PodUpdate)
0000000000000000000000000000000000000000;;		// Could be sorted either of these two ways:
0000000000000000000000000000000000000000;;		expectedA := CreatePodUpdate(kubetypes.SET, kubetypes.ApiserverSource, pod1v1, pod2)
0000000000000000000000000000000000000000;;		expectedB := CreatePodUpdate(kubetypes.SET, kubetypes.ApiserverSource, pod2, pod1v1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(expectedA, update) && !apiequality.Semantic.DeepEqual(expectedB, update) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %#v or %#v, Got %#v", expectedA, expectedB, update)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Modify pod1
0000000000000000000000000000000000000000;;		fakeWatch.Modify(pod1v2)
0000000000000000000000000000000000000000;;		got, ok = <-ch
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Unable to read from channel when expected")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		update = got.(kubetypes.PodUpdate)
0000000000000000000000000000000000000000;;		expectedA = CreatePodUpdate(kubetypes.SET, kubetypes.ApiserverSource, pod1v2, pod2)
0000000000000000000000000000000000000000;;		expectedB = CreatePodUpdate(kubetypes.SET, kubetypes.ApiserverSource, pod2, pod1v2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(expectedA, update) && !apiequality.Semantic.DeepEqual(expectedB, update) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %#v or %#v, Got %#v", expectedA, expectedB, update)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete pod1
0000000000000000000000000000000000000000;;		fakeWatch.Delete(pod1v2)
0000000000000000000000000000000000000000;;		got, ok = <-ch
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Unable to read from channel when expected")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		update = got.(kubetypes.PodUpdate)
0000000000000000000000000000000000000000;;		expected = CreatePodUpdate(kubetypes.SET, kubetypes.ApiserverSource, pod2)
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(expected, update) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %#v, Got %#v", expected, update)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete pod2
0000000000000000000000000000000000000000;;		fakeWatch.Delete(pod2)
0000000000000000000000000000000000000000;;		got, ok = <-ch
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Unable to read from channel when expected")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		update = got.(kubetypes.PodUpdate)
0000000000000000000000000000000000000000;;		expected = CreatePodUpdate(kubetypes.SET, kubetypes.ApiserverSource)
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(expected, update) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %#v, Got %#v", expected, update)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewSourceApiserver_TwoNamespacesSameName(t *testing.T) {
0000000000000000000000000000000000000000;;		pod1 := v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "p", Namespace: "one"},
0000000000000000000000000000000000000000;;			Spec:       v1.PodSpec{Containers: []v1.Container{{Image: "image/one"}}}}
0000000000000000000000000000000000000000;;		pod2 := v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "p", Namespace: "two"},
0000000000000000000000000000000000000000;;			Spec:       v1.PodSpec{Containers: []v1.Container{{Image: "image/blah"}}}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup fake api client.
0000000000000000000000000000000000000000;;		fakeWatch := watch.NewFake()
0000000000000000000000000000000000000000;;		lw := fakePodLW{
0000000000000000000000000000000000000000;;			listResp:  &v1.PodList{Items: []v1.Pod{pod1, pod2}},
0000000000000000000000000000000000000000;;			watchResp: fakeWatch,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ch := make(chan interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newSourceApiserverFromLW(lw, ch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		got, ok := <-ch
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Unable to read from channel when expected")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		update := got.(kubetypes.PodUpdate)
0000000000000000000000000000000000000000;;		// Make sure that we get both pods.  Catches bug #2294.
0000000000000000000000000000000000000000;;		if !(len(update.Pods) == 2) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %d, Got %d", 2, len(update.Pods))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete pod1
0000000000000000000000000000000000000000;;		fakeWatch.Delete(&pod1)
0000000000000000000000000000000000000000;;		got, ok = <-ch
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Unable to read from channel when expected")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		update = got.(kubetypes.PodUpdate)
0000000000000000000000000000000000000000;;		if !(len(update.Pods) == 1) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %d, Got %d", 1, len(update.Pods))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewSourceApiserverInitialEmptySendsEmptyPodUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		// Setup fake api client.
0000000000000000000000000000000000000000;;		fakeWatch := watch.NewFake()
0000000000000000000000000000000000000000;;		lw := fakePodLW{
0000000000000000000000000000000000000000;;			listResp:  &v1.PodList{Items: []v1.Pod{}},
0000000000000000000000000000000000000000;;			watchResp: fakeWatch,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ch := make(chan interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newSourceApiserverFromLW(lw, ch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		got, ok := <-ch
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Unable to read from channel when expected")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		update := got.(kubetypes.PodUpdate)
0000000000000000000000000000000000000000;;		expected := CreatePodUpdate(kubetypes.SET, kubetypes.ApiserverSource)
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(expected, update) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %#v; Got %#v", expected, update)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
