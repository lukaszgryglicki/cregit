0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1b884dfb46a2a0f38404a185c725698821878ad1;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package secret
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		storageetcd "k8s.io/apiserver/pkg/storage/etcd"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		clientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		defaultTTL = time.Minute
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Manager interface {
0000000000000000000000000000000000000000;;		// Get secret by secret namespace and name.
0000000000000000000000000000000000000000;;		GetSecret(namespace, name string) (*v1.Secret, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WARNING: Register/UnregisterPod functions should be efficient,
0000000000000000000000000000000000000000;;		// i.e. should not block on network operations.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RegisterPod registers all secrets from a given pod.
0000000000000000000000000000000000000000;;		RegisterPod(pod *v1.Pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UnregisterPod unregisters secrets from a given pod that are not
0000000000000000000000000000000000000000;;		// used by any other registered pod.
0000000000000000000000000000000000000000;;		UnregisterPod(pod *v1.Pod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// simpleSecretManager implements SecretManager interfaces with
0000000000000000000000000000000000000000;;	// simple operations to apiserver.
0000000000000000000000000000000000000000;;	type simpleSecretManager struct {
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSimpleSecretManager(kubeClient clientset.Interface) Manager {
0000000000000000000000000000000000000000;;		return &simpleSecretManager{kubeClient: kubeClient}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *simpleSecretManager) GetSecret(namespace, name string) (*v1.Secret, error) {
0000000000000000000000000000000000000000;;		return s.kubeClient.Core().Secrets(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *simpleSecretManager) RegisterPod(pod *v1.Pod) {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *simpleSecretManager) UnregisterPod(pod *v1.Pod) {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type GetObjectTTLFunc func() (time.Duration, bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type objectKey struct {
0000000000000000000000000000000000000000;;		namespace string
0000000000000000000000000000000000000000;;		name      string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// secretStoreItems is a single item stored in secretStore.
0000000000000000000000000000000000000000;;	type secretStoreItem struct {
0000000000000000000000000000000000000000;;		refCount int
0000000000000000000000000000000000000000;;		secret   *secretData
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type secretData struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secret         *v1.Secret
0000000000000000000000000000000000000000;;		err            error
0000000000000000000000000000000000000000;;		lastUpdateTime time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// secretStore is a local cache of secrets.
0000000000000000000000000000000000000000;;	type secretStore struct {
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface
0000000000000000000000000000000000000000;;		clock      clock.Clock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lock  sync.Mutex
0000000000000000000000000000000000000000;;		items map[objectKey]*secretStoreItem
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaultTTL time.Duration
0000000000000000000000000000000000000000;;		getTTL     GetObjectTTLFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSecretStore(kubeClient clientset.Interface, clock clock.Clock, getTTL GetObjectTTLFunc, ttl time.Duration) *secretStore {
0000000000000000000000000000000000000000;;		return &secretStore{
0000000000000000000000000000000000000000;;			kubeClient: kubeClient,
0000000000000000000000000000000000000000;;			clock:      clock,
0000000000000000000000000000000000000000;;			items:      make(map[objectKey]*secretStoreItem),
0000000000000000000000000000000000000000;;			defaultTTL: ttl,
0000000000000000000000000000000000000000;;			getTTL:     getTTL,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isSecretOlder(newSecret, oldSecret *v1.Secret) bool {
0000000000000000000000000000000000000000;;		if newSecret == nil || oldSecret == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newVersion, _ := storageetcd.Versioner.ObjectResourceVersion(newSecret)
0000000000000000000000000000000000000000;;		oldVersion, _ := storageetcd.Versioner.ObjectResourceVersion(oldSecret)
0000000000000000000000000000000000000000;;		return newVersion < oldVersion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *secretStore) Add(namespace, name string) {
0000000000000000000000000000000000000000;;		key := objectKey{namespace: namespace, name: name}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add is called from RegisterPod, thus it needs to be efficient.
0000000000000000000000000000000000000000;;		// Thus Add() is only increasing refCount and generation of a given secret.
0000000000000000000000000000000000000000;;		// Then Get() is responsible for fetching if needed.
0000000000000000000000000000000000000000;;		s.lock.Lock()
0000000000000000000000000000000000000000;;		defer s.lock.Unlock()
0000000000000000000000000000000000000000;;		item, exists := s.items[key]
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			item = &secretStoreItem{
0000000000000000000000000000000000000000;;				refCount: 0,
0000000000000000000000000000000000000000;;				secret:   &secretData{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.items[key] = item
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		item.refCount++
0000000000000000000000000000000000000000;;		// This will trigger fetch on the next Get() operation.
0000000000000000000000000000000000000000;;		item.secret = nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *secretStore) Delete(namespace, name string) {
0000000000000000000000000000000000000000;;		key := objectKey{namespace: namespace, name: name}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.lock.Lock()
0000000000000000000000000000000000000000;;		defer s.lock.Unlock()
0000000000000000000000000000000000000000;;		if item, ok := s.items[key]; ok {
0000000000000000000000000000000000000000;;			item.refCount--
0000000000000000000000000000000000000000;;			if item.refCount == 0 {
0000000000000000000000000000000000000000;;				delete(s.items, key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetObjectTTLFromNodeFunc(getNode func() (*v1.Node, error)) GetObjectTTLFunc {
0000000000000000000000000000000000000000;;		return func() (time.Duration, bool) {
0000000000000000000000000000000000000000;;			node, err := getNode()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return time.Duration(0), false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if node != nil && node.Annotations != nil {
0000000000000000000000000000000000000000;;				if value, ok := node.Annotations[v1.ObjectTTLAnnotationKey]; ok {
0000000000000000000000000000000000000000;;					if intValue, err := strconv.Atoi(value); err == nil {
0000000000000000000000000000000000000000;;						return time.Duration(intValue) * time.Second, true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return time.Duration(0), false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *secretStore) isSecretFresh(data *secretData) bool {
0000000000000000000000000000000000000000;;		secretTTL := s.defaultTTL
0000000000000000000000000000000000000000;;		if ttl, ok := s.getTTL(); ok {
0000000000000000000000000000000000000000;;			secretTTL = ttl
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.clock.Now().Before(data.lastUpdateTime.Add(secretTTL))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *secretStore) Get(namespace, name string) (*v1.Secret, error) {
0000000000000000000000000000000000000000;;		key := objectKey{namespace: namespace, name: name}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := func() *secretData {
0000000000000000000000000000000000000000;;			s.lock.Lock()
0000000000000000000000000000000000000000;;			defer s.lock.Unlock()
0000000000000000000000000000000000000000;;			item, exists := s.items[key]
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if item.secret == nil {
0000000000000000000000000000000000000000;;				item.secret = &secretData{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return item.secret
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if data == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("secret %q/%q not registered", namespace, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// After updating data in secretStore, lock the data, fetch secret if
0000000000000000000000000000000000000000;;		// needed and return data.
0000000000000000000000000000000000000000;;		data.Lock()
0000000000000000000000000000000000000000;;		defer data.Unlock()
0000000000000000000000000000000000000000;;		if data.err != nil || !s.isSecretFresh(data) {
0000000000000000000000000000000000000000;;			opts := metav1.GetOptions{}
0000000000000000000000000000000000000000;;			if data.secret != nil && data.err == nil {
0000000000000000000000000000000000000000;;				// This is just a periodic refresh of a secret we successfully fetched previously.
0000000000000000000000000000000000000000;;				// In this case, server data from apiserver cache to reduce the load on both
0000000000000000000000000000000000000000;;				// etcd and apiserver (the cache is eventually consistent).
0000000000000000000000000000000000000000;;				util.FromApiserverCache(&opts)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			secret, err := s.kubeClient.Core().Secrets(namespace).Get(name, opts)
0000000000000000000000000000000000000000;;			if err != nil && !apierrors.IsNotFound(err) && data.secret == nil && data.err == nil {
0000000000000000000000000000000000000000;;				// Couldn't fetch the latest secret, but there is no cached data to return.
0000000000000000000000000000000000000000;;				// Return the fetch result instead.
0000000000000000000000000000000000000000;;				return secret, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if (err == nil && !isSecretOlder(secret, data.secret)) || apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				// If the fetch succeeded with a newer version of the secret, or if the
0000000000000000000000000000000000000000;;				// secret could not be found in the apiserver, update the cached data to
0000000000000000000000000000000000000000;;				// reflect the current status.
0000000000000000000000000000000000000000;;				data.secret = secret
0000000000000000000000000000000000000000;;				data.err = err
0000000000000000000000000000000000000000;;				data.lastUpdateTime = s.clock.Now()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return data.secret, data.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cachingSecretManager keeps a cache of all secrets necessary for registered pods.
0000000000000000000000000000000000000000;;	// It implements the following logic:
0000000000000000000000000000000000000000;;	// - whenever a pod is created or updated, the cached versions of all its secrets
0000000000000000000000000000000000000000;;	//   are invalidated
0000000000000000000000000000000000000000;;	// - every GetSecret() call tries to fetch the value from local cache; if it is
0000000000000000000000000000000000000000;;	//   not there, invalidated or too old, we fetch it from apiserver and refresh the
0000000000000000000000000000000000000000;;	//   value in cache; otherwise it is just fetched from cache
0000000000000000000000000000000000000000;;	type cachingSecretManager struct {
0000000000000000000000000000000000000000;;		secretStore *secretStore
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lock           sync.Mutex
0000000000000000000000000000000000000000;;		registeredPods map[objectKey]*v1.Pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCachingSecretManager(kubeClient clientset.Interface, getTTL GetObjectTTLFunc) Manager {
0000000000000000000000000000000000000000;;		csm := &cachingSecretManager{
0000000000000000000000000000000000000000;;			secretStore:    newSecretStore(kubeClient, clock.RealClock{}, getTTL, defaultTTL),
0000000000000000000000000000000000000000;;			registeredPods: make(map[objectKey]*v1.Pod),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return csm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cachingSecretManager) GetSecret(namespace, name string) (*v1.Secret, error) {
0000000000000000000000000000000000000000;;		return c.secretStore.Get(namespace, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSecretNames(pod *v1.Pod) sets.String {
0000000000000000000000000000000000000000;;		result := sets.NewString()
0000000000000000000000000000000000000000;;		podutil.VisitPodSecretNames(pod, func(name string) bool {
0000000000000000000000000000000000000000;;			result.Insert(name)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cachingSecretManager) RegisterPod(pod *v1.Pod) {
0000000000000000000000000000000000000000;;		names := getSecretNames(pod)
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		for name := range names {
0000000000000000000000000000000000000000;;			c.secretStore.Add(pod.Namespace, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var prev *v1.Pod
0000000000000000000000000000000000000000;;		key := objectKey{namespace: pod.Namespace, name: pod.Name}
0000000000000000000000000000000000000000;;		prev = c.registeredPods[key]
0000000000000000000000000000000000000000;;		c.registeredPods[key] = pod
0000000000000000000000000000000000000000;;		if prev != nil {
0000000000000000000000000000000000000000;;			for name := range getSecretNames(prev) {
0000000000000000000000000000000000000000;;				c.secretStore.Delete(prev.Namespace, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cachingSecretManager) UnregisterPod(pod *v1.Pod) {
0000000000000000000000000000000000000000;;		var prev *v1.Pod
0000000000000000000000000000000000000000;;		key := objectKey{namespace: pod.Namespace, name: pod.Name}
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		prev = c.registeredPods[key]
0000000000000000000000000000000000000000;;		delete(c.registeredPods, key)
0000000000000000000000000000000000000000;;		if prev != nil {
0000000000000000000000000000000000000000;;			for name := range getSecretNames(prev) {
0000000000000000000000000000000000000000;;				c.secretStore.Delete(prev.Namespace, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
