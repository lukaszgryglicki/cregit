0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1b884dfb46a2a0f38404a185c725698821878ad1;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package secret
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkSecret(t *testing.T, store *secretStore, ns, name string, shouldExist bool) {
0000000000000000000000000000000000000000;;		_, err := store.Get(ns, name)
0000000000000000000000000000000000000000;;		if shouldExist && err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected actions: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !shouldExist && (err == nil || !strings.Contains(err.Error(), fmt.Sprintf("secret %q/%q not registered", ns, name))) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected actions: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func noObjectTTL() (time.Duration, bool) {
0000000000000000000000000000000000000000;;		return time.Duration(0), false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSecretStore(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		store := newSecretStore(fakeClient, clock.RealClock{}, noObjectTTL, 0)
0000000000000000000000000000000000000000;;		store.Add("ns1", "name1")
0000000000000000000000000000000000000000;;		store.Add("ns2", "name2")
0000000000000000000000000000000000000000;;		store.Add("ns1", "name1")
0000000000000000000000000000000000000000;;		store.Add("ns1", "name1")
0000000000000000000000000000000000000000;;		store.Delete("ns1", "name1")
0000000000000000000000000000000000000000;;		store.Delete("ns2", "name2")
0000000000000000000000000000000000000000;;		store.Add("ns3", "name3")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Adds don't issue Get requests.
0000000000000000000000000000000000000000;;		actions := fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 0, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;		// Should issue Get request
0000000000000000000000000000000000000000;;		store.Get("ns1", "name1")
0000000000000000000000000000000000000000;;		// Shouldn't issue Get request, as secret is not registered
0000000000000000000000000000000000000000;;		store.Get("ns2", "name2")
0000000000000000000000000000000000000000;;		// Should issue Get request
0000000000000000000000000000000000000000;;		store.Get("ns3", "name3")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actions = fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 2, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, a := range actions {
0000000000000000000000000000000000000000;;			assert.True(t, a.Matches("get", "secrets"), "unexpected actions: %#v", a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		checkSecret(t, store, "ns1", "name1", true)
0000000000000000000000000000000000000000;;		checkSecret(t, store, "ns2", "name2", false)
0000000000000000000000000000000000000000;;		checkSecret(t, store, "ns3", "name3", true)
0000000000000000000000000000000000000000;;		checkSecret(t, store, "ns4", "name4", false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSecretStoreDeletingSecret(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		store := newSecretStore(fakeClient, clock.RealClock{}, noObjectTTL, 0)
0000000000000000000000000000000000000000;;		store.Add("ns", "name")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := &v1.Secret{ObjectMeta: metav1.ObjectMeta{Namespace: "ns", Name: "name", ResourceVersion: "10"}}
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("get", "secrets", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			return true, result, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		secret, err := store.Get("ns", "name")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(secret, result) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected secret: %v", secret)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.PrependReactor("get", "secrets", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			return true, &v1.Secret{}, apierrors.NewNotFound(v1.Resource("secret"), "name")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		secret, err = store.Get("ns", "name")
0000000000000000000000000000000000000000;;		if err == nil || !apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(secret, &v1.Secret{}) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected secret: %v", secret)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSecretStoreGetAlwaysRefresh(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		fakeClock := clock.NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		store := newSecretStore(fakeClient, fakeClock, noObjectTTL, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;			store.Add(fmt.Sprintf("ns-%d", i), fmt.Sprintf("name-%d", i))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeClient.ClearActions()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(100)
0000000000000000000000000000000000000000;;		for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;			go func(i int) {
0000000000000000000000000000000000000000;;				store.Get(fmt.Sprintf("ns-%d", i%10), fmt.Sprintf("name-%d", i%10))
0000000000000000000000000000000000000000;;				wg.Done()
0000000000000000000000000000000000000000;;			}(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		actions := fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 100, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, a := range actions {
0000000000000000000000000000000000000000;;			assert.True(t, a.Matches("get", "secrets"), "unexpected actions: %#v", a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSecretStoreGetNeverRefresh(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		fakeClock := clock.NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		store := newSecretStore(fakeClient, fakeClock, noObjectTTL, time.Minute)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;			store.Add(fmt.Sprintf("ns-%d", i), fmt.Sprintf("name-%d", i))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeClient.ClearActions()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(100)
0000000000000000000000000000000000000000;;		for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;			go func(i int) {
0000000000000000000000000000000000000000;;				store.Get(fmt.Sprintf("ns-%d", i%10), fmt.Sprintf("name-%d", i%10))
0000000000000000000000000000000000000000;;				wg.Done()
0000000000000000000000000000000000000000;;			}(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		actions := fakeClient.Actions()
0000000000000000000000000000000000000000;;		// Only first Get, should forward the Get request.
0000000000000000000000000000000000000000;;		assert.Equal(t, 10, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCustomTTL(t *testing.T) {
0000000000000000000000000000000000000000;;		ttl := time.Duration(0)
0000000000000000000000000000000000000000;;		ttlExists := false
0000000000000000000000000000000000000000;;		customTTL := func() (time.Duration, bool) {
0000000000000000000000000000000000000000;;			return ttl, ttlExists
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		fakeClock := clock.NewFakeClock(time.Time{})
0000000000000000000000000000000000000000;;		store := newSecretStore(fakeClient, fakeClock, customTTL, time.Minute)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		store.Add("ns", "name")
0000000000000000000000000000000000000000;;		store.Get("ns", "name")
0000000000000000000000000000000000000000;;		fakeClient.ClearActions()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set 0-ttl and see if that works.
0000000000000000000000000000000000000000;;		ttl = time.Duration(0)
0000000000000000000000000000000000000000;;		ttlExists = true
0000000000000000000000000000000000000000;;		store.Get("ns", "name")
0000000000000000000000000000000000000000;;		actions := fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 1, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;		fakeClient.ClearActions()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set 5-minute ttl and see if this works.
0000000000000000000000000000000000000000;;		ttl = time.Duration(5) * time.Minute
0000000000000000000000000000000000000000;;		store.Get("ns", "name")
0000000000000000000000000000000000000000;;		actions = fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 0, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;		// Still no effect after 4 minutes.
0000000000000000000000000000000000000000;;		fakeClock.Step(4 * time.Minute)
0000000000000000000000000000000000000000;;		store.Get("ns", "name")
0000000000000000000000000000000000000000;;		actions = fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 0, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;		// Now it should have an effect.
0000000000000000000000000000000000000000;;		fakeClock.Step(time.Minute)
0000000000000000000000000000000000000000;;		store.Get("ns", "name")
0000000000000000000000000000000000000000;;		actions = fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 1, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;		fakeClient.ClearActions()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now remove the custom ttl and see if that works.
0000000000000000000000000000000000000000;;		ttlExists = false
0000000000000000000000000000000000000000;;		fakeClock.Step(55 * time.Second)
0000000000000000000000000000000000000000;;		store.Get("ns", "name")
0000000000000000000000000000000000000000;;		actions = fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 0, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;		// Pass the minute and it should be triggered now.
0000000000000000000000000000000000000000;;		fakeClock.Step(5 * time.Second)
0000000000000000000000000000000000000000;;		store.Get("ns", "name")
0000000000000000000000000000000000000000;;		actions = fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 1, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestParseNodeAnnotation(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			node   *v1.Node
0000000000000000000000000000000000000000;;			err    error
0000000000000000000000000000000000000000;;			exists bool
0000000000000000000000000000000000000000;;			ttl    time.Duration
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node:   nil,
0000000000000000000000000000000000000000;;				err:    fmt.Errorf("error"),
0000000000000000000000000000000000000000;;				exists: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "node",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				exists: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:        "node",
0000000000000000000000000000000000000000;;						Annotations: map[string]string{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				exists: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:        "node",
0000000000000000000000000000000000000000;;						Annotations: map[string]string{v1.ObjectTTLAnnotationKey: "bad"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				exists: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:        "node",
0000000000000000000000000000000000000000;;						Annotations: map[string]string{v1.ObjectTTLAnnotationKey: "0"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				exists: true,
0000000000000000000000000000000000000000;;				ttl:    time.Duration(0),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:        "node",
0000000000000000000000000000000000000000;;						Annotations: map[string]string{v1.ObjectTTLAnnotationKey: "60"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				exists: true,
0000000000000000000000000000000000000000;;				ttl:    time.Minute,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			getNode := func() (*v1.Node, error) { return testCase.node, testCase.err }
0000000000000000000000000000000000000000;;			ttl, exists := GetObjectTTLFromNodeFunc(getNode)()
0000000000000000000000000000000000000000;;			if exists != testCase.exists {
0000000000000000000000000000000000000000;;				t.Errorf("%d: incorrect parsing: %t", i, exists)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if exists && ttl != testCase.ttl {
0000000000000000000000000000000000000000;;				t.Errorf("%d: incorrect ttl: %v", i, ttl)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type envSecrets struct {
0000000000000000000000000000000000000000;;		envVarNames  []string
0000000000000000000000000000000000000000;;		envFromNames []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type secretsToAttach struct {
0000000000000000000000000000000000000000;;		imagePullSecretNames []string
0000000000000000000000000000000000000000;;		containerEnvSecrets  []envSecrets
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func podWithSecrets(ns, name string, toAttach secretsToAttach) *v1.Pod {
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, name := range toAttach.imagePullSecretNames {
0000000000000000000000000000000000000000;;			pod.Spec.ImagePullSecrets = append(
0000000000000000000000000000000000000000;;				pod.Spec.ImagePullSecrets, v1.LocalObjectReference{Name: name})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, secrets := range toAttach.containerEnvSecrets {
0000000000000000000000000000000000000000;;			container := v1.Container{
0000000000000000000000000000000000000000;;				Name: fmt.Sprintf("container-%d", i),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, name := range secrets.envFromNames {
0000000000000000000000000000000000000000;;				envFrom := v1.EnvFromSource{
0000000000000000000000000000000000000000;;					SecretRef: &v1.SecretEnvSource{
0000000000000000000000000000000000000000;;						LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;							Name: name,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				container.EnvFrom = append(container.EnvFrom, envFrom)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, name := range secrets.envVarNames {
0000000000000000000000000000000000000000;;				envSource := &v1.EnvVarSource{
0000000000000000000000000000000000000000;;					SecretKeyRef: &v1.SecretKeySelector{
0000000000000000000000000000000000000000;;						LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;							Name: name,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				container.Env = append(container.Env, v1.EnvVar{ValueFrom: envSource})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod.Spec.Containers = append(pod.Spec.Containers, container)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCacheInvalidation(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		fakeClock := clock.NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		store := newSecretStore(fakeClient, fakeClock, noObjectTTL, time.Minute)
0000000000000000000000000000000000000000;;		manager := &cachingSecretManager{
0000000000000000000000000000000000000000;;			secretStore:    store,
0000000000000000000000000000000000000000;;			registeredPods: make(map[objectKey]*v1.Pod),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a pod with some secrets.
0000000000000000000000000000000000000000;;		s1 := secretsToAttach{
0000000000000000000000000000000000000000;;			imagePullSecretNames: []string{"s1"},
0000000000000000000000000000000000000000;;			containerEnvSecrets: []envSecrets{
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s1"}, envFromNames: []string{"s10"}},
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s2"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithSecrets("ns1", "name1", s1))
0000000000000000000000000000000000000000;;		// Fetch both secrets - this should triggger get operations.
0000000000000000000000000000000000000000;;		store.Get("ns1", "s1")
0000000000000000000000000000000000000000;;		store.Get("ns1", "s10")
0000000000000000000000000000000000000000;;		store.Get("ns1", "s2")
0000000000000000000000000000000000000000;;		actions := fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 3, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;		fakeClient.ClearActions()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update a pod with a new secret.
0000000000000000000000000000000000000000;;		s2 := secretsToAttach{
0000000000000000000000000000000000000000;;			imagePullSecretNames: []string{"s1"},
0000000000000000000000000000000000000000;;			containerEnvSecrets: []envSecrets{
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s1"}},
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s2"}, envFromNames: []string{"s20"}},
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s3"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithSecrets("ns1", "name1", s2))
0000000000000000000000000000000000000000;;		// All secrets should be invalidated - this should trigger get operations.
0000000000000000000000000000000000000000;;		store.Get("ns1", "s1")
0000000000000000000000000000000000000000;;		store.Get("ns1", "s2")
0000000000000000000000000000000000000000;;		store.Get("ns1", "s20")
0000000000000000000000000000000000000000;;		store.Get("ns1", "s3")
0000000000000000000000000000000000000000;;		actions = fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 4, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;		fakeClient.ClearActions()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a new pod that is refencing the first three secrets - those should
0000000000000000000000000000000000000000;;		// be invalidated.
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithSecrets("ns1", "name2", s1))
0000000000000000000000000000000000000000;;		store.Get("ns1", "s1")
0000000000000000000000000000000000000000;;		store.Get("ns1", "s10")
0000000000000000000000000000000000000000;;		store.Get("ns1", "s2")
0000000000000000000000000000000000000000;;		store.Get("ns1", "s20")
0000000000000000000000000000000000000000;;		store.Get("ns1", "s3")
0000000000000000000000000000000000000000;;		actions = fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 3, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;		fakeClient.ClearActions()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCacheRefcounts(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		fakeClock := clock.NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		store := newSecretStore(fakeClient, fakeClock, noObjectTTL, time.Minute)
0000000000000000000000000000000000000000;;		manager := &cachingSecretManager{
0000000000000000000000000000000000000000;;			secretStore:    store,
0000000000000000000000000000000000000000;;			registeredPods: make(map[objectKey]*v1.Pod),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s1 := secretsToAttach{
0000000000000000000000000000000000000000;;			imagePullSecretNames: []string{"s1"},
0000000000000000000000000000000000000000;;			containerEnvSecrets: []envSecrets{
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s1"}, envFromNames: []string{"s10"}},
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s2"}},
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s3"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithSecrets("ns1", "name1", s1))
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithSecrets("ns1", "name2", s1))
0000000000000000000000000000000000000000;;		s2 := secretsToAttach{
0000000000000000000000000000000000000000;;			imagePullSecretNames: []string{"s2"},
0000000000000000000000000000000000000000;;			containerEnvSecrets: []envSecrets{
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s4"}},
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s5"}, envFromNames: []string{"s50"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithSecrets("ns1", "name2", s2))
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithSecrets("ns1", "name3", s2))
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithSecrets("ns1", "name4", s2))
0000000000000000000000000000000000000000;;		manager.UnregisterPod(podWithSecrets("ns1", "name3", s2))
0000000000000000000000000000000000000000;;		s3 := secretsToAttach{
0000000000000000000000000000000000000000;;			imagePullSecretNames: []string{"s1"},
0000000000000000000000000000000000000000;;			containerEnvSecrets: []envSecrets{
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s3"}, envFromNames: []string{"s30"}},
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s5"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithSecrets("ns1", "name5", s3))
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithSecrets("ns1", "name6", s3))
0000000000000000000000000000000000000000;;		s4 := secretsToAttach{
0000000000000000000000000000000000000000;;			imagePullSecretNames: []string{"s3"},
0000000000000000000000000000000000000000;;			containerEnvSecrets: []envSecrets{
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s6"}},
0000000000000000000000000000000000000000;;				{envFromNames: []string{"s60"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithSecrets("ns1", "name7", s4))
0000000000000000000000000000000000000000;;		manager.UnregisterPod(podWithSecrets("ns1", "name7", s4))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Also check the Add + Update + Remove scenario.
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithSecrets("ns1", "other-name", s1))
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithSecrets("ns1", "other-name", s2))
0000000000000000000000000000000000000000;;		manager.UnregisterPod(podWithSecrets("ns1", "other-name", s2))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now we have: 3 pods with s1, 2 pods with s2 and 2 pods with s3, 0 pods with s4.
0000000000000000000000000000000000000000;;		verify := func(ns, name string, count int) bool {
0000000000000000000000000000000000000000;;			store.lock.Lock()
0000000000000000000000000000000000000000;;			defer store.lock.Unlock()
0000000000000000000000000000000000000000;;			item, ok := store.items[objectKey{ns, name}]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return count == 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return item.refCount == count
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		assert.True(t, verify("ns1", "s1", 3))
0000000000000000000000000000000000000000;;		assert.True(t, verify("ns1", "s10", 1))
0000000000000000000000000000000000000000;;		assert.True(t, verify("ns1", "s2", 3))
0000000000000000000000000000000000000000;;		assert.True(t, verify("ns1", "s3", 3))
0000000000000000000000000000000000000000;;		assert.True(t, verify("ns1", "s30", 2))
0000000000000000000000000000000000000000;;		assert.True(t, verify("ns1", "s4", 2))
0000000000000000000000000000000000000000;;		assert.True(t, verify("ns1", "s5", 4))
0000000000000000000000000000000000000000;;		assert.True(t, verify("ns1", "s50", 2))
0000000000000000000000000000000000000000;;		assert.True(t, verify("ns1", "s6", 0))
0000000000000000000000000000000000000000;;		assert.True(t, verify("ns1", "s60", 0))
0000000000000000000000000000000000000000;;		assert.True(t, verify("ns1", "s7", 0))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCachingSecretManager(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		secretStore := newSecretStore(fakeClient, clock.RealClock{}, noObjectTTL, 0)
0000000000000000000000000000000000000000;;		manager := &cachingSecretManager{
0000000000000000000000000000000000000000;;			secretStore:    secretStore,
0000000000000000000000000000000000000000;;			registeredPods: make(map[objectKey]*v1.Pod),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a pod with some secrets.
0000000000000000000000000000000000000000;;		s1 := secretsToAttach{
0000000000000000000000000000000000000000;;			imagePullSecretNames: []string{"s1"},
0000000000000000000000000000000000000000;;			containerEnvSecrets: []envSecrets{
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s1"}},
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s2"}},
0000000000000000000000000000000000000000;;				{envFromNames: []string{"s20"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithSecrets("ns1", "name1", s1))
0000000000000000000000000000000000000000;;		// Update the pod with a different secrets.
0000000000000000000000000000000000000000;;		s2 := secretsToAttach{
0000000000000000000000000000000000000000;;			imagePullSecretNames: []string{"s1"},
0000000000000000000000000000000000000000;;			containerEnvSecrets: []envSecrets{
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s3"}},
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s4"}},
0000000000000000000000000000000000000000;;				{envFromNames: []string{"s40"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithSecrets("ns1", "name1", s2))
0000000000000000000000000000000000000000;;		// Create another pod, but with same secrets in different namespace.
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithSecrets("ns2", "name2", s2))
0000000000000000000000000000000000000000;;		// Create and delete a pod with some other secrets.
0000000000000000000000000000000000000000;;		s3 := secretsToAttach{
0000000000000000000000000000000000000000;;			imagePullSecretNames: []string{"s5"},
0000000000000000000000000000000000000000;;			containerEnvSecrets: []envSecrets{
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s6"}},
0000000000000000000000000000000000000000;;				{envFromNames: []string{"s60"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithSecrets("ns3", "name", s3))
0000000000000000000000000000000000000000;;		manager.UnregisterPod(podWithSecrets("ns3", "name", s3))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We should have only: s1, s3 and s4 secrets in namespaces: ns1 and ns2.
0000000000000000000000000000000000000000;;		for _, ns := range []string{"ns1", "ns2", "ns3"} {
0000000000000000000000000000000000000000;;			for _, secret := range []string{"s1", "s2", "s3", "s4", "s5", "s6", "s20", "s40", "s50"} {
0000000000000000000000000000000000000000;;				shouldExist :=
0000000000000000000000000000000000000000;;					(secret == "s1" || secret == "s3" || secret == "s4" || secret == "s40") && (ns == "ns1" || ns == "ns2")
0000000000000000000000000000000000000000;;				checkSecret(t, secretStore, ns, secret, shouldExist)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
