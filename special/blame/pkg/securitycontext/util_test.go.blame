0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
6406f55c577d7113ba250b2fc90613490895bc12;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package securitycontext
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestParseSELinuxOptions(t *testing.T) {
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			name     string
0000000000000000000000000000000000000000;;			input    string
0000000000000000000000000000000000000000;;			expected *v1.SELinuxOptions
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "simple",
0000000000000000000000000000000000000000;;				input: "user_t:role_t:type_t:s0",
0000000000000000000000000000000000000000;;				expected: &v1.SELinuxOptions{
0000000000000000000000000000000000000000;;					User:  "user_t",
0000000000000000000000000000000000000000;;					Role:  "role_t",
0000000000000000000000000000000000000000;;					Type:  "type_t",
0000000000000000000000000000000000000000;;					Level: "s0",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "simple + categories",
0000000000000000000000000000000000000000;;				input: "user_t:role_t:type_t:s0:c0",
0000000000000000000000000000000000000000;;				expected: &v1.SELinuxOptions{
0000000000000000000000000000000000000000;;					User:  "user_t",
0000000000000000000000000000000000000000;;					Role:  "role_t",
0000000000000000000000000000000000000000;;					Type:  "type_t",
0000000000000000000000000000000000000000;;					Level: "s0:c0",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "not enough fields",
0000000000000000000000000000000000000000;;				input: "type_t:s0:c0",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range cases {
0000000000000000000000000000000000000000;;			result, err := ParseSELinuxOptions(tc.input)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if tc.expected == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					t.Errorf("%v: unexpected error: %v", tc.name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			compareContexts(tc.name, tc.expected, result, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func compareContexts(name string, ex, ac *v1.SELinuxOptions, t *testing.T) {
0000000000000000000000000000000000000000;;		if e, a := ex.User, ac.User; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("%v: expected user: %v, got: %v", name, e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := ex.Role, ac.Role; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("%v: expected role: %v, got: %v", name, e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := ex.Type, ac.Type; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("%v: expected type: %v, got: %v", name, e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := ex.Level, ac.Level; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("%v: expected level: %v, got: %v", name, e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func containerWithUser(ptr *int64) *v1.Container {
0000000000000000000000000000000000000000;;		return &v1.Container{SecurityContext: &v1.SecurityContext{RunAsUser: ptr}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHaRootUID(t *testing.T) {
0000000000000000000000000000000000000000;;		nonRoot := int64(1)
0000000000000000000000000000000000000000;;		root := int64(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			container *v1.Container
0000000000000000000000000000000000000000;;			expect    bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"nil sc": {
0000000000000000000000000000000000000000;;				container: &v1.Container{SecurityContext: nil},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"nil runAsuser": {
0000000000000000000000000000000000000000;;				container: containerWithUser(nil),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"runAsUser non-root": {
0000000000000000000000000000000000000000;;				container: containerWithUser(&nonRoot),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"runAsUser root": {
0000000000000000000000000000000000000000;;				container: containerWithUser(&root),
0000000000000000000000000000000000000000;;				expect:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			actual := HasRootUID(v.container)
0000000000000000000000000000000000000000;;			if actual != v.expect {
0000000000000000000000000000000000000000;;				t.Errorf("%s failed, expected %t but received %t", k, v.expect, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHasRunAsUser(t *testing.T) {
0000000000000000000000000000000000000000;;		runAsUser := int64(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			container *v1.Container
0000000000000000000000000000000000000000;;			expect    bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"nil sc": {
0000000000000000000000000000000000000000;;				container: &v1.Container{SecurityContext: nil},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"nil runAsUser": {
0000000000000000000000000000000000000000;;				container: containerWithUser(nil),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"valid runAsUser": {
0000000000000000000000000000000000000000;;				container: containerWithUser(&runAsUser),
0000000000000000000000000000000000000000;;				expect:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			actual := HasRunAsUser(v.container)
0000000000000000000000000000000000000000;;			if actual != v.expect {
0000000000000000000000000000000000000000;;				t.Errorf("%s failed, expected %t but received %t", k, v.expect, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHasRootRunAsUser(t *testing.T) {
0000000000000000000000000000000000000000;;		nonRoot := int64(1)
0000000000000000000000000000000000000000;;		root := int64(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			container *v1.Container
0000000000000000000000000000000000000000;;			expect    bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"nil sc": {
0000000000000000000000000000000000000000;;				container: &v1.Container{SecurityContext: nil},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"nil runAsuser": {
0000000000000000000000000000000000000000;;				container: containerWithUser(nil),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"runAsUser non-root": {
0000000000000000000000000000000000000000;;				container: containerWithUser(&nonRoot),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"runAsUser root": {
0000000000000000000000000000000000000000;;				container: containerWithUser(&root),
0000000000000000000000000000000000000000;;				expect:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			actual := HasRootRunAsUser(v.container)
0000000000000000000000000000000000000000;;			if actual != v.expect {
0000000000000000000000000000000000000000;;				t.Errorf("%s failed, expected %t but received %t", k, v.expect, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
