0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f16ae5b932f488fd79e14adc7f322afe6a3d6ebf;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package securitycontext
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasPrivilegedRequest returns the value of SecurityContext.Privileged, taking into account
0000000000000000000000000000000000000000;;	// the possibility of nils
0000000000000000000000000000000000000000;;	func HasPrivilegedRequest(container *v1.Container) bool {
0000000000000000000000000000000000000000;;		if container.SecurityContext == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if container.SecurityContext.Privileged == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *container.SecurityContext.Privileged
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasCapabilitiesRequest returns true if Adds or Drops are defined in the security context
0000000000000000000000000000000000000000;;	// capabilities, taking into account nils
0000000000000000000000000000000000000000;;	func HasCapabilitiesRequest(container *v1.Container) bool {
0000000000000000000000000000000000000000;;		if container.SecurityContext == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if container.SecurityContext.Capabilities == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(container.SecurityContext.Capabilities.Add) > 0 || len(container.SecurityContext.Capabilities.Drop) > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const expectedSELinuxFields = 4
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseSELinuxOptions parses a string containing a full SELinux context
0000000000000000000000000000000000000000;;	// (user, role, type, and level) into an SELinuxOptions object.  If the
0000000000000000000000000000000000000000;;	// context is malformed, an error is returned.
0000000000000000000000000000000000000000;;	func ParseSELinuxOptions(context string) (*v1.SELinuxOptions, error) {
0000000000000000000000000000000000000000;;		fields := strings.SplitN(context, ":", expectedSELinuxFields)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(fields) != expectedSELinuxFields {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("expected %v fields in selinux; got %v (context: %v)", expectedSELinuxFields, len(fields), context)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &v1.SELinuxOptions{
0000000000000000000000000000000000000000;;			User:  fields[0],
0000000000000000000000000000000000000000;;			Role:  fields[1],
0000000000000000000000000000000000000000;;			Type:  fields[2],
0000000000000000000000000000000000000000;;			Level: fields[3],
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasNonRootUID returns true if the runAsUser is set and is greater than 0.
0000000000000000000000000000000000000000;;	func HasRootUID(container *v1.Container) bool {
0000000000000000000000000000000000000000;;		if container.SecurityContext == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if container.SecurityContext.RunAsUser == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *container.SecurityContext.RunAsUser == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasRunAsUser determines if the sc's runAsUser field is set.
0000000000000000000000000000000000000000;;	func HasRunAsUser(container *v1.Container) bool {
0000000000000000000000000000000000000000;;		return container.SecurityContext != nil && container.SecurityContext.RunAsUser != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasRootRunAsUser returns true if the run as user is set and it is set to 0.
0000000000000000000000000000000000000000;;	func HasRootRunAsUser(container *v1.Container) bool {
0000000000000000000000000000000000000000;;		return HasRunAsUser(container) && HasRootUID(container)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DetermineEffectiveSecurityContext(pod *v1.Pod, container *v1.Container) *v1.SecurityContext {
0000000000000000000000000000000000000000;;		effectiveSc := securityContextFromPodSecurityContext(pod)
0000000000000000000000000000000000000000;;		containerSc := container.SecurityContext
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if effectiveSc == nil && containerSc == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if effectiveSc != nil && containerSc == nil {
0000000000000000000000000000000000000000;;			return effectiveSc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if effectiveSc == nil && containerSc != nil {
0000000000000000000000000000000000000000;;			return containerSc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if containerSc.SELinuxOptions != nil {
0000000000000000000000000000000000000000;;			effectiveSc.SELinuxOptions = new(v1.SELinuxOptions)
0000000000000000000000000000000000000000;;			*effectiveSc.SELinuxOptions = *containerSc.SELinuxOptions
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if containerSc.Capabilities != nil {
0000000000000000000000000000000000000000;;			effectiveSc.Capabilities = new(v1.Capabilities)
0000000000000000000000000000000000000000;;			*effectiveSc.Capabilities = *containerSc.Capabilities
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if containerSc.Privileged != nil {
0000000000000000000000000000000000000000;;			effectiveSc.Privileged = new(bool)
0000000000000000000000000000000000000000;;			*effectiveSc.Privileged = *containerSc.Privileged
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if containerSc.RunAsUser != nil {
0000000000000000000000000000000000000000;;			effectiveSc.RunAsUser = new(int64)
0000000000000000000000000000000000000000;;			*effectiveSc.RunAsUser = *containerSc.RunAsUser
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if containerSc.RunAsNonRoot != nil {
0000000000000000000000000000000000000000;;			effectiveSc.RunAsNonRoot = new(bool)
0000000000000000000000000000000000000000;;			*effectiveSc.RunAsNonRoot = *containerSc.RunAsNonRoot
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if containerSc.ReadOnlyRootFilesystem != nil {
0000000000000000000000000000000000000000;;			effectiveSc.ReadOnlyRootFilesystem = new(bool)
0000000000000000000000000000000000000000;;			*effectiveSc.ReadOnlyRootFilesystem = *containerSc.ReadOnlyRootFilesystem
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return effectiveSc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func securityContextFromPodSecurityContext(pod *v1.Pod) *v1.SecurityContext {
0000000000000000000000000000000000000000;;		if pod.Spec.SecurityContext == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		synthesized := &v1.SecurityContext{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pod.Spec.SecurityContext.SELinuxOptions != nil {
0000000000000000000000000000000000000000;;			synthesized.SELinuxOptions = &v1.SELinuxOptions{}
0000000000000000000000000000000000000000;;			*synthesized.SELinuxOptions = *pod.Spec.SecurityContext.SELinuxOptions
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pod.Spec.SecurityContext.RunAsUser != nil {
0000000000000000000000000000000000000000;;			synthesized.RunAsUser = new(int64)
0000000000000000000000000000000000000000;;			*synthesized.RunAsUser = *pod.Spec.SecurityContext.RunAsUser
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pod.Spec.SecurityContext.RunAsNonRoot != nil {
0000000000000000000000000000000000000000;;			synthesized.RunAsNonRoot = new(bool)
0000000000000000000000000000000000000000;;			*synthesized.RunAsNonRoot = *pod.Spec.SecurityContext.RunAsNonRoot
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return synthesized
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: remove the duplicate code
0000000000000000000000000000000000000000;;	func InternalDetermineEffectiveSecurityContext(pod *api.Pod, container *api.Container) *api.SecurityContext {
0000000000000000000000000000000000000000;;		effectiveSc := internalSecurityContextFromPodSecurityContext(pod)
0000000000000000000000000000000000000000;;		containerSc := container.SecurityContext
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if effectiveSc == nil && containerSc == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if effectiveSc != nil && containerSc == nil {
0000000000000000000000000000000000000000;;			return effectiveSc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if effectiveSc == nil && containerSc != nil {
0000000000000000000000000000000000000000;;			return containerSc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if containerSc.SELinuxOptions != nil {
0000000000000000000000000000000000000000;;			effectiveSc.SELinuxOptions = new(api.SELinuxOptions)
0000000000000000000000000000000000000000;;			*effectiveSc.SELinuxOptions = *containerSc.SELinuxOptions
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if containerSc.Capabilities != nil {
0000000000000000000000000000000000000000;;			effectiveSc.Capabilities = new(api.Capabilities)
0000000000000000000000000000000000000000;;			*effectiveSc.Capabilities = *containerSc.Capabilities
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if containerSc.Privileged != nil {
0000000000000000000000000000000000000000;;			effectiveSc.Privileged = new(bool)
0000000000000000000000000000000000000000;;			*effectiveSc.Privileged = *containerSc.Privileged
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if containerSc.RunAsUser != nil {
0000000000000000000000000000000000000000;;			effectiveSc.RunAsUser = new(int64)
0000000000000000000000000000000000000000;;			*effectiveSc.RunAsUser = *containerSc.RunAsUser
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if containerSc.RunAsNonRoot != nil {
0000000000000000000000000000000000000000;;			effectiveSc.RunAsNonRoot = new(bool)
0000000000000000000000000000000000000000;;			*effectiveSc.RunAsNonRoot = *containerSc.RunAsNonRoot
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if containerSc.ReadOnlyRootFilesystem != nil {
0000000000000000000000000000000000000000;;			effectiveSc.ReadOnlyRootFilesystem = new(bool)
0000000000000000000000000000000000000000;;			*effectiveSc.ReadOnlyRootFilesystem = *containerSc.ReadOnlyRootFilesystem
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return effectiveSc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func internalSecurityContextFromPodSecurityContext(pod *api.Pod) *api.SecurityContext {
0000000000000000000000000000000000000000;;		if pod.Spec.SecurityContext == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		synthesized := &api.SecurityContext{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pod.Spec.SecurityContext.SELinuxOptions != nil {
0000000000000000000000000000000000000000;;			synthesized.SELinuxOptions = &api.SELinuxOptions{}
0000000000000000000000000000000000000000;;			*synthesized.SELinuxOptions = *pod.Spec.SecurityContext.SELinuxOptions
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pod.Spec.SecurityContext.RunAsUser != nil {
0000000000000000000000000000000000000000;;			synthesized.RunAsUser = new(int64)
0000000000000000000000000000000000000000;;			*synthesized.RunAsUser = *pod.Spec.SecurityContext.RunAsUser
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pod.Spec.SecurityContext.RunAsNonRoot != nil {
0000000000000000000000000000000000000000;;			synthesized.RunAsNonRoot = new(bool)
0000000000000000000000000000000000000000;;			*synthesized.RunAsNonRoot = *pod.Spec.SecurityContext.RunAsNonRoot
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return synthesized
0000000000000000000000000000000000000000;;	}
