0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
582e49e90422e842d5b2268c4c15f4d2d1a14d73;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package limitranger
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lru "github.com/hashicorp/golang-lru"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/internalversion"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/internalversion"
0000000000000000000000000000000000000000;;		kubeapiserveradmission "k8s.io/kubernetes/pkg/kubeapiserver/admission"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		limitRangerAnnotation = "kubernetes.io/limit-ranger"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register registers a plugin
0000000000000000000000000000000000000000;;	func Register(plugins *admission.Plugins) {
0000000000000000000000000000000000000000;;		plugins.Register("LimitRanger", func(config io.Reader) (admission.Interface, error) {
0000000000000000000000000000000000000000;;			return NewLimitRanger(&DefaultLimitRangerActions{})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// limitRanger enforces usage limits on a per resource basis in the namespace
0000000000000000000000000000000000000000;;	type limitRanger struct {
0000000000000000000000000000000000000000;;		*admission.Handler
0000000000000000000000000000000000000000;;		client  internalclientset.Interface
0000000000000000000000000000000000000000;;		actions LimitRangerActions
0000000000000000000000000000000000000000;;		lister  corelisters.LimitRangeLister
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// liveLookups holds the last few live lookups we've done to help ammortize cost on repeated lookup failures.
0000000000000000000000000000000000000000;;		// This let's us handle the case of latent caches, by looking up actual results for a namespace on cache miss/no results.
0000000000000000000000000000000000000000;;		// We track the lookup result here so that for repeated requests, we don't look it up very often.
0000000000000000000000000000000000000000;;		liveLookupCache *lru.Cache
0000000000000000000000000000000000000000;;		liveTTL         time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type liveLookupEntry struct {
0000000000000000000000000000000000000000;;		expiry time.Time
0000000000000000000000000000000000000000;;		items  []*api.LimitRange
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *limitRanger) SetInternalKubeInformerFactory(f informers.SharedInformerFactory) {
0000000000000000000000000000000000000000;;		limitRangeInformer := f.Core().InternalVersion().LimitRanges()
0000000000000000000000000000000000000000;;		l.SetReadyFunc(limitRangeInformer.Informer().HasSynced)
0000000000000000000000000000000000000000;;		l.lister = limitRangeInformer.Lister()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *limitRanger) Validate() error {
0000000000000000000000000000000000000000;;		if l.lister == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing limitRange lister")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.client == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing client")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Admit admits resources into cluster that do not violate any defined LimitRange in the namespace
0000000000000000000000000000000000000000;;	func (l *limitRanger) Admit(a admission.Attributes) (err error) {
0000000000000000000000000000000000000000;;		if !l.actions.SupportsAttributes(a) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj := a.GetObject()
0000000000000000000000000000000000000000;;		name := "Unknown"
0000000000000000000000000000000000000000;;		if obj != nil {
0000000000000000000000000000000000000000;;			name, _ = meta.NewAccessor().Name(obj)
0000000000000000000000000000000000000000;;			if len(name) == 0 {
0000000000000000000000000000000000000000;;				name, _ = meta.NewAccessor().GenerateName(obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		items, err := l.lister.LimitRanges(a.GetNamespace()).List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return admission.NewForbidden(a, fmt.Errorf("unable to %s %v at this time because there was an error enforcing limit ranges", a.GetOperation(), a.GetResource()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if there are no items held in our indexer, check our live-lookup LRU, if that misses, do the live lookup to prime it.
0000000000000000000000000000000000000000;;		if len(items) == 0 {
0000000000000000000000000000000000000000;;			lruItemObj, ok := l.liveLookupCache.Get(a.GetNamespace())
0000000000000000000000000000000000000000;;			if !ok || lruItemObj.(liveLookupEntry).expiry.Before(time.Now()) {
0000000000000000000000000000000000000000;;				// TODO: If there are multiple operations at the same time and cache has just expired,
0000000000000000000000000000000000000000;;				// this may cause multiple List operations being issued at the same time.
0000000000000000000000000000000000000000;;				// If there is already in-flight List() for a given namespace, we should wait until
0000000000000000000000000000000000000000;;				// it is finished and cache is updated instead of doing the same, also to avoid
0000000000000000000000000000000000000000;;				// throttling - see #22422 for details.
0000000000000000000000000000000000000000;;				liveList, err := l.client.Core().LimitRanges(a.GetNamespace()).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return admission.NewForbidden(a, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newEntry := liveLookupEntry{expiry: time.Now().Add(l.liveTTL)}
0000000000000000000000000000000000000000;;				for i := range liveList.Items {
0000000000000000000000000000000000000000;;					newEntry.items = append(newEntry.items, &liveList.Items[i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				l.liveLookupCache.Add(a.GetNamespace(), newEntry)
0000000000000000000000000000000000000000;;				lruItemObj = newEntry
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lruEntry := lruItemObj.(liveLookupEntry)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i := range lruEntry.items {
0000000000000000000000000000000000000000;;				items = append(items, lruEntry.items[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure it meets each prescribed min/max
0000000000000000000000000000000000000000;;		for i := range items {
0000000000000000000000000000000000000000;;			limitRange := items[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !l.actions.SupportsLimit(limitRange) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = l.actions.Limit(limitRange, a.GetResource().Resource, a.GetObject())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return admission.NewForbidden(a, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewLimitRanger returns an object that enforces limits based on the supplied limit function
0000000000000000000000000000000000000000;;	func NewLimitRanger(actions LimitRangerActions) (admission.Interface, error) {
0000000000000000000000000000000000000000;;		liveLookupCache, err := lru.New(10000)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if actions == nil {
0000000000000000000000000000000000000000;;			actions = &DefaultLimitRangerActions{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &limitRanger{
0000000000000000000000000000000000000000;;			Handler:         admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			actions:         actions,
0000000000000000000000000000000000000000;;			liveLookupCache: liveLookupCache,
0000000000000000000000000000000000000000;;			liveTTL:         time.Duration(30 * time.Second),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = kubeapiserveradmission.WantsInternalKubeInformerFactory(&limitRanger{})
0000000000000000000000000000000000000000;;	var _ = kubeapiserveradmission.WantsInternalKubeClientSet(&limitRanger{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *limitRanger) SetInternalKubeClientSet(client internalclientset.Interface) {
0000000000000000000000000000000000000000;;		a.client = client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaultContainerResourceRequirements returns the default requirements for a container
0000000000000000000000000000000000000000;;	// the requirement.Limits are taken from the LimitRange defaults (if specified)
0000000000000000000000000000000000000000;;	// the requirement.Requests are taken from the LimitRange default request (if specified)
0000000000000000000000000000000000000000;;	func defaultContainerResourceRequirements(limitRange *api.LimitRange) api.ResourceRequirements {
0000000000000000000000000000000000000000;;		requirements := api.ResourceRequirements{}
0000000000000000000000000000000000000000;;		requirements.Requests = api.ResourceList{}
0000000000000000000000000000000000000000;;		requirements.Limits = api.ResourceList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range limitRange.Spec.Limits {
0000000000000000000000000000000000000000;;			limit := limitRange.Spec.Limits[i]
0000000000000000000000000000000000000000;;			if limit.Type == api.LimitTypeContainer {
0000000000000000000000000000000000000000;;				for k, v := range limit.DefaultRequest {
0000000000000000000000000000000000000000;;					value := v.Copy()
0000000000000000000000000000000000000000;;					requirements.Requests[k] = *value
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for k, v := range limit.Default {
0000000000000000000000000000000000000000;;					value := v.Copy()
0000000000000000000000000000000000000000;;					requirements.Limits[k] = *value
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return requirements
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mergeContainerResources handles defaulting all of the resources on a container.
0000000000000000000000000000000000000000;;	func mergeContainerResources(container *api.Container, defaultRequirements *api.ResourceRequirements, annotationPrefix string, annotations []string) []string {
0000000000000000000000000000000000000000;;		setRequests := []string{}
0000000000000000000000000000000000000000;;		setLimits := []string{}
0000000000000000000000000000000000000000;;		if container.Resources.Limits == nil {
0000000000000000000000000000000000000000;;			container.Resources.Limits = api.ResourceList{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if container.Resources.Requests == nil {
0000000000000000000000000000000000000000;;			container.Resources.Requests = api.ResourceList{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range defaultRequirements.Limits {
0000000000000000000000000000000000000000;;			_, found := container.Resources.Limits[k]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				container.Resources.Limits[k] = *v.Copy()
0000000000000000000000000000000000000000;;				setLimits = append(setLimits, string(k))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range defaultRequirements.Requests {
0000000000000000000000000000000000000000;;			_, found := container.Resources.Requests[k]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				container.Resources.Requests[k] = *v.Copy()
0000000000000000000000000000000000000000;;				setRequests = append(setRequests, string(k))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(setRequests) > 0 {
0000000000000000000000000000000000000000;;			sort.Strings(setRequests)
0000000000000000000000000000000000000000;;			a := strings.Join(setRequests, ", ") + fmt.Sprintf(" request for %s %s", annotationPrefix, container.Name)
0000000000000000000000000000000000000000;;			annotations = append(annotations, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(setLimits) > 0 {
0000000000000000000000000000000000000000;;			sort.Strings(setLimits)
0000000000000000000000000000000000000000;;			a := strings.Join(setLimits, ", ") + fmt.Sprintf(" limit for %s %s", annotationPrefix, container.Name)
0000000000000000000000000000000000000000;;			annotations = append(annotations, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return annotations
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mergePodResourceRequirements merges enumerated requirements with default requirements
0000000000000000000000000000000000000000;;	// it annotates the pod with information about what requirements were modified
0000000000000000000000000000000000000000;;	func mergePodResourceRequirements(pod *api.Pod, defaultRequirements *api.ResourceRequirements) {
0000000000000000000000000000000000000000;;		annotations := []string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			annotations = mergeContainerResources(&pod.Spec.Containers[i], defaultRequirements, "container", annotations)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;			annotations = mergeContainerResources(&pod.Spec.InitContainers[i], defaultRequirements, "init container", annotations)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(annotations) > 0 {
0000000000000000000000000000000000000000;;			if pod.ObjectMeta.Annotations == nil {
0000000000000000000000000000000000000000;;				pod.ObjectMeta.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val := "LimitRanger plugin set: " + strings.Join(annotations, "; ")
0000000000000000000000000000000000000000;;			pod.ObjectMeta.Annotations[limitRangerAnnotation] = val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// requestLimitEnforcedValues returns the specified values at a common precision to support comparability
0000000000000000000000000000000000000000;;	func requestLimitEnforcedValues(requestQuantity, limitQuantity, enforcedQuantity resource.Quantity) (request, limit, enforced int64) {
0000000000000000000000000000000000000000;;		request = requestQuantity.Value()
0000000000000000000000000000000000000000;;		limit = limitQuantity.Value()
0000000000000000000000000000000000000000;;		enforced = enforcedQuantity.Value()
0000000000000000000000000000000000000000;;		// do a more precise comparison if possible (if the value won't overflow)
0000000000000000000000000000000000000000;;		if request <= resource.MaxMilliValue && limit <= resource.MaxMilliValue && enforced <= resource.MaxMilliValue {
0000000000000000000000000000000000000000;;			request = requestQuantity.MilliValue()
0000000000000000000000000000000000000000;;			limit = limitQuantity.MilliValue()
0000000000000000000000000000000000000000;;			enforced = enforcedQuantity.MilliValue()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// minConstraint enforces the min constraint over the specified resource
0000000000000000000000000000000000000000;;	func minConstraint(limitType api.LimitType, resourceName api.ResourceName, enforced resource.Quantity, request api.ResourceList, limit api.ResourceList) error {
0000000000000000000000000000000000000000;;		req, reqExists := request[resourceName]
0000000000000000000000000000000000000000;;		lim, limExists := limit[resourceName]
0000000000000000000000000000000000000000;;		observedReqValue, observedLimValue, enforcedValue := requestLimitEnforcedValues(req, lim, enforced)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reqExists {
0000000000000000000000000000000000000000;;			return fmt.Errorf("minimum %s usage per %s is %s.  No request is specified.", resourceName, limitType, enforced.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if observedReqValue < enforcedValue {
0000000000000000000000000000000000000000;;			return fmt.Errorf("minimum %s usage per %s is %s, but request is %s.", resourceName, limitType, enforced.String(), req.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if limExists && (observedLimValue < enforcedValue) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("minimum %s usage per %s is %s, but limit is %s.", resourceName, limitType, enforced.String(), lim.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maxRequestConstraint enforces the max constraint over the specified resource
0000000000000000000000000000000000000000;;	// use when specify LimitType resource doesn't recognize limit values
0000000000000000000000000000000000000000;;	func maxRequestConstraint(limitType api.LimitType, resourceName api.ResourceName, enforced resource.Quantity, request api.ResourceList) error {
0000000000000000000000000000000000000000;;		req, reqExists := request[resourceName]
0000000000000000000000000000000000000000;;		observedReqValue, _, enforcedValue := requestLimitEnforcedValues(req, resource.Quantity{}, enforced)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reqExists {
0000000000000000000000000000000000000000;;			return fmt.Errorf("maximum %s usage per %s is %s.  No request is specified.", resourceName, limitType, enforced.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if observedReqValue > enforcedValue {
0000000000000000000000000000000000000000;;			return fmt.Errorf("maximum %s usage per %s is %s, but request is %s.", resourceName, limitType, enforced.String(), req.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maxConstraint enforces the max constraint over the specified resource
0000000000000000000000000000000000000000;;	func maxConstraint(limitType api.LimitType, resourceName api.ResourceName, enforced resource.Quantity, request api.ResourceList, limit api.ResourceList) error {
0000000000000000000000000000000000000000;;		req, reqExists := request[resourceName]
0000000000000000000000000000000000000000;;		lim, limExists := limit[resourceName]
0000000000000000000000000000000000000000;;		observedReqValue, observedLimValue, enforcedValue := requestLimitEnforcedValues(req, lim, enforced)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !limExists {
0000000000000000000000000000000000000000;;			return fmt.Errorf("maximum %s usage per %s is %s.  No limit is specified.", resourceName, limitType, enforced.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if observedLimValue > enforcedValue {
0000000000000000000000000000000000000000;;			return fmt.Errorf("maximum %s usage per %s is %s, but limit is %s.", resourceName, limitType, enforced.String(), lim.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if reqExists && (observedReqValue > enforcedValue) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("maximum %s usage per %s is %s, but request is %s.", resourceName, limitType, enforced.String(), req.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// limitRequestRatioConstraint enforces the limit to request ratio over the specified resource
0000000000000000000000000000000000000000;;	func limitRequestRatioConstraint(limitType api.LimitType, resourceName api.ResourceName, enforced resource.Quantity, request api.ResourceList, limit api.ResourceList) error {
0000000000000000000000000000000000000000;;		req, reqExists := request[resourceName]
0000000000000000000000000000000000000000;;		lim, limExists := limit[resourceName]
0000000000000000000000000000000000000000;;		observedReqValue, observedLimValue, _ := requestLimitEnforcedValues(req, lim, enforced)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reqExists || (observedReqValue == int64(0)) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%s max limit to request ratio per %s is %s, but no request is specified or request is 0.", resourceName, limitType, enforced.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !limExists || (observedLimValue == int64(0)) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%s max limit to request ratio per %s is %s, but no limit is specified or limit is 0.", resourceName, limitType, enforced.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		observedRatio := float64(observedLimValue) / float64(observedReqValue)
0000000000000000000000000000000000000000;;		displayObservedRatio := observedRatio
0000000000000000000000000000000000000000;;		maxLimitRequestRatio := float64(enforced.Value())
0000000000000000000000000000000000000000;;		if enforced.Value() <= resource.MaxMilliValue {
0000000000000000000000000000000000000000;;			observedRatio = observedRatio * 1000
0000000000000000000000000000000000000000;;			maxLimitRequestRatio = float64(enforced.MilliValue())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if observedRatio > maxLimitRequestRatio {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%s max limit to request ratio per %s is %s, but provided ratio is %f.", resourceName, limitType, enforced.String(), displayObservedRatio)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sum takes the total of each named resource across all inputs
0000000000000000000000000000000000000000;;	// if a key is not in each input, then the output resource list will omit the key
0000000000000000000000000000000000000000;;	func sum(inputs []api.ResourceList) api.ResourceList {
0000000000000000000000000000000000000000;;		result := api.ResourceList{}
0000000000000000000000000000000000000000;;		keys := []api.ResourceName{}
0000000000000000000000000000000000000000;;		for i := range inputs {
0000000000000000000000000000000000000000;;			for k := range inputs[i] {
0000000000000000000000000000000000000000;;				keys = append(keys, k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, key := range keys {
0000000000000000000000000000000000000000;;			total, isSet := int64(0), true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i := range inputs {
0000000000000000000000000000000000000000;;				input := inputs[i]
0000000000000000000000000000000000000000;;				v, exists := input[key]
0000000000000000000000000000000000000000;;				if exists {
0000000000000000000000000000000000000000;;					if key == api.ResourceCPU {
0000000000000000000000000000000000000000;;						total = total + v.MilliValue()
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						total = total + v.Value()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					isSet = false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if isSet {
0000000000000000000000000000000000000000;;				if key == api.ResourceCPU {
0000000000000000000000000000000000000000;;					result[key] = *(resource.NewMilliQuantity(total, resource.DecimalSI))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					result[key] = *(resource.NewQuantity(total, resource.DecimalSI))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultLimitRangerActions is the default implementation of LimitRangerActions.
0000000000000000000000000000000000000000;;	type DefaultLimitRangerActions struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ensure DefaultLimitRangerActions implements the LimitRangerActions interface.
0000000000000000000000000000000000000000;;	var _ LimitRangerActions = &DefaultLimitRangerActions{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Limit enforces resource requirements of incoming resources against enumerated constraints
0000000000000000000000000000000000000000;;	// on the LimitRange.  It may modify the incoming object to apply default resource requirements
0000000000000000000000000000000000000000;;	// if not specified, and enumerated on the LimitRange
0000000000000000000000000000000000000000;;	func (d *DefaultLimitRangerActions) Limit(limitRange *api.LimitRange, resourceName string, obj runtime.Object) error {
0000000000000000000000000000000000000000;;		switch resourceName {
0000000000000000000000000000000000000000;;		case "pods":
0000000000000000000000000000000000000000;;			return PodLimitFunc(limitRange, obj.(*api.Pod))
0000000000000000000000000000000000000000;;		case "persistentvolumeclaims":
0000000000000000000000000000000000000000;;			return PersistentVolumeClaimLimitFunc(limitRange, obj.(*api.PersistentVolumeClaim))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SupportsAttributes ignores all calls that do not deal with pod resources or storage requests (PVCs).
0000000000000000000000000000000000000000;;	// Also ignores any call that has a subresource defined.
0000000000000000000000000000000000000000;;	func (d *DefaultLimitRangerActions) SupportsAttributes(a admission.Attributes) bool {
0000000000000000000000000000000000000000;;		if a.GetSubresource() != "" {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return a.GetKind().GroupKind() == api.Kind("Pod") || a.GetKind().GroupKind() == api.Kind("PersistentVolumeClaim")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SupportsLimit always returns true.
0000000000000000000000000000000000000000;;	func (d *DefaultLimitRangerActions) SupportsLimit(limitRange *api.LimitRange) bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumeClaimLimitFunc enforces storage limits for PVCs.
0000000000000000000000000000000000000000;;	// Users request storage via pvc.Spec.Resources.Requests.  Min/Max is enforced by an admin with LimitRange.
0000000000000000000000000000000000000000;;	// Claims will not be modified with default values because storage is a required part of pvc.Spec.
0000000000000000000000000000000000000000;;	// All storage enforced values *only* apply to pvc.Spec.Resources.Requests.
0000000000000000000000000000000000000000;;	func PersistentVolumeClaimLimitFunc(limitRange *api.LimitRange, pvc *api.PersistentVolumeClaim) error {
0000000000000000000000000000000000000000;;		var errs []error
0000000000000000000000000000000000000000;;		for i := range limitRange.Spec.Limits {
0000000000000000000000000000000000000000;;			limit := limitRange.Spec.Limits[i]
0000000000000000000000000000000000000000;;			limitType := limit.Type
0000000000000000000000000000000000000000;;			if limitType == api.LimitTypePersistentVolumeClaim {
0000000000000000000000000000000000000000;;				for k, v := range limit.Min {
0000000000000000000000000000000000000000;;					// normal usage of minConstraint. pvc.Spec.Resources.Limits is not recognized as user input
0000000000000000000000000000000000000000;;					if err := minConstraint(limitType, k, v, pvc.Spec.Resources.Requests, api.ResourceList{}); err != nil {
0000000000000000000000000000000000000000;;						errs = append(errs, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for k, v := range limit.Max {
0000000000000000000000000000000000000000;;					// We want to enforce the max of the LimitRange against what
0000000000000000000000000000000000000000;;					// the user requested.
0000000000000000000000000000000000000000;;					if err := maxRequestConstraint(limitType, k, v, pvc.Spec.Resources.Requests); err != nil {
0000000000000000000000000000000000000000;;						errs = append(errs, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(errs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodLimitFunc enforces resource requirements enumerated by the pod against
0000000000000000000000000000000000000000;;	// the specified LimitRange.  The pod may be modified to apply default resource
0000000000000000000000000000000000000000;;	// requirements if not specified, and enumerated on the LimitRange
0000000000000000000000000000000000000000;;	func PodLimitFunc(limitRange *api.LimitRange, pod *api.Pod) error {
0000000000000000000000000000000000000000;;		var errs []error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaultResources := defaultContainerResourceRequirements(limitRange)
0000000000000000000000000000000000000000;;		mergePodResourceRequirements(pod, &defaultResources)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range limitRange.Spec.Limits {
0000000000000000000000000000000000000000;;			limit := limitRange.Spec.Limits[i]
0000000000000000000000000000000000000000;;			limitType := limit.Type
0000000000000000000000000000000000000000;;			// enforce container limits
0000000000000000000000000000000000000000;;			if limitType == api.LimitTypeContainer {
0000000000000000000000000000000000000000;;				for j := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;					container := &pod.Spec.Containers[j]
0000000000000000000000000000000000000000;;					for k, v := range limit.Min {
0000000000000000000000000000000000000000;;						if err := minConstraint(limitType, k, v, container.Resources.Requests, container.Resources.Limits); err != nil {
0000000000000000000000000000000000000000;;							errs = append(errs, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for k, v := range limit.Max {
0000000000000000000000000000000000000000;;						if err := maxConstraint(limitType, k, v, container.Resources.Requests, container.Resources.Limits); err != nil {
0000000000000000000000000000000000000000;;							errs = append(errs, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for k, v := range limit.MaxLimitRequestRatio {
0000000000000000000000000000000000000000;;						if err := limitRequestRatioConstraint(limitType, k, v, container.Resources.Requests, container.Resources.Limits); err != nil {
0000000000000000000000000000000000000000;;							errs = append(errs, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for j := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;					container := &pod.Spec.InitContainers[j]
0000000000000000000000000000000000000000;;					for k, v := range limit.Min {
0000000000000000000000000000000000000000;;						if err := minConstraint(limitType, k, v, container.Resources.Requests, container.Resources.Limits); err != nil {
0000000000000000000000000000000000000000;;							errs = append(errs, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for k, v := range limit.Max {
0000000000000000000000000000000000000000;;						if err := maxConstraint(limitType, k, v, container.Resources.Requests, container.Resources.Limits); err != nil {
0000000000000000000000000000000000000000;;							errs = append(errs, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for k, v := range limit.MaxLimitRequestRatio {
0000000000000000000000000000000000000000;;						if err := limitRequestRatioConstraint(limitType, k, v, container.Resources.Requests, container.Resources.Limits); err != nil {
0000000000000000000000000000000000000000;;							errs = append(errs, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// enforce pod limits on init containers
0000000000000000000000000000000000000000;;			if limitType == api.LimitTypePod {
0000000000000000000000000000000000000000;;				containerRequests, containerLimits := []api.ResourceList{}, []api.ResourceList{}
0000000000000000000000000000000000000000;;				for j := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;					container := &pod.Spec.Containers[j]
0000000000000000000000000000000000000000;;					containerRequests = append(containerRequests, container.Resources.Requests)
0000000000000000000000000000000000000000;;					containerLimits = append(containerLimits, container.Resources.Limits)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				podRequests := sum(containerRequests)
0000000000000000000000000000000000000000;;				podLimits := sum(containerLimits)
0000000000000000000000000000000000000000;;				for j := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;					container := &pod.Spec.InitContainers[j]
0000000000000000000000000000000000000000;;					// take max(sum_containers, any_init_container)
0000000000000000000000000000000000000000;;					for k, v := range container.Resources.Requests {
0000000000000000000000000000000000000000;;						if v2, ok := podRequests[k]; ok {
0000000000000000000000000000000000000000;;							if v.Cmp(v2) > 0 {
0000000000000000000000000000000000000000;;								podRequests[k] = v
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							podRequests[k] = v
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for k, v := range container.Resources.Limits {
0000000000000000000000000000000000000000;;						if v2, ok := podLimits[k]; ok {
0000000000000000000000000000000000000000;;							if v.Cmp(v2) > 0 {
0000000000000000000000000000000000000000;;								podLimits[k] = v
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							podLimits[k] = v
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for k, v := range limit.Min {
0000000000000000000000000000000000000000;;					if err := minConstraint(limitType, k, v, podRequests, podLimits); err != nil {
0000000000000000000000000000000000000000;;						errs = append(errs, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for k, v := range limit.Max {
0000000000000000000000000000000000000000;;					if err := maxConstraint(limitType, k, v, podRequests, podLimits); err != nil {
0000000000000000000000000000000000000000;;						errs = append(errs, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for k, v := range limit.MaxLimitRequestRatio {
0000000000000000000000000000000000000000;;					if err := limitRequestRatioConstraint(limitType, k, v, podRequests, podLimits); err != nil {
0000000000000000000000000000000000000000;;						errs = append(errs, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(errs)
0000000000000000000000000000000000000000;;	}
