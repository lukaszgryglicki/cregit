0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
4ffe7b2058cf640850fcfbca70b345991ae00376;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package initialization
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/admissionregistration/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/validation"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubeapiserver/admission/configuration"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register registers a plugin
0000000000000000000000000000000000000000;;	func Register(plugins *admission.Plugins) {
0000000000000000000000000000000000000000;;		plugins.Register("Initializers", func(config io.Reader) (admission.Interface, error) {
0000000000000000000000000000000000000000;;			return NewInitializer(), nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type initializerOptions struct {
0000000000000000000000000000000000000000;;		Initializers []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type InitializationConfig interface {
0000000000000000000000000000000000000000;;		Run(stopCh <-chan struct{})
0000000000000000000000000000000000000000;;		Initializers() (*v1alpha1.InitializerConfiguration, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type initializer struct {
0000000000000000000000000000000000000000;;		config     InitializationConfig
0000000000000000000000000000000000000000;;		authorizer authorizer.Authorizer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewInitializer creates a new initializer plugin which assigns newly created resources initializers
0000000000000000000000000000000000000000;;	// based on configuration loaded from the admission API group.
0000000000000000000000000000000000000000;;	// FUTURE: this may be moved to the storage layer of the apiserver, but for now this is an alpha feature
0000000000000000000000000000000000000000;;	//   that can be disabled.
0000000000000000000000000000000000000000;;	func NewInitializer() admission.Interface {
0000000000000000000000000000000000000000;;		return &initializer{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *initializer) Validate() error {
0000000000000000000000000000000000000000;;		if i.config == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("the Initializer admission plugin requires a Kubernetes client to be provided")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i.config.Run(wait.NeverStop)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *initializer) SetExternalKubeClientSet(client clientset.Interface) {
0000000000000000000000000000000000000000;;		i.config = configuration.NewInitializerConfigurationManager(client.Admissionregistration().InitializerConfigurations())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *initializer) SetAuthorizer(a authorizer.Authorizer) {
0000000000000000000000000000000000000000;;		i.authorizer = a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var initializerFieldPath = field.NewPath("metadata", "initializers")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readConfig holds requests instead of failing them if the server is not yet initialized
0000000000000000000000000000000000000000;;	// or is unresponsive. It formats the returned error for client use if necessary.
0000000000000000000000000000000000000000;;	func (i *initializer) readConfig(a admission.Attributes) (*v1alpha1.InitializerConfiguration, error) {
0000000000000000000000000000000000000000;;		// read initializers from config
0000000000000000000000000000000000000000;;		config, err := i.config.Initializers()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return config, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if initializer configuration is disabled, fail open
0000000000000000000000000000000000000000;;		if err == configuration.ErrDisabled {
0000000000000000000000000000000000000000;;			return &v1alpha1.InitializerConfiguration{}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e := errors.NewServerTimeout(a.GetResource().GroupResource(), "create", 1)
0000000000000000000000000000000000000000;;		if err == configuration.ErrNotReady {
0000000000000000000000000000000000000000;;			e.ErrStatus.Message = fmt.Sprintf("Waiting for initialization configuration to load: %v", err)
0000000000000000000000000000000000000000;;			e.ErrStatus.Reason = "LoadingConfiguration"
0000000000000000000000000000000000000000;;			e.ErrStatus.Details.Causes = append(e.ErrStatus.Details.Causes, metav1.StatusCause{
0000000000000000000000000000000000000000;;				Type:    "InitializerConfigurationPending",
0000000000000000000000000000000000000000;;				Message: "The server is waiting for the initializer configuration to be loaded.",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.ErrStatus.Message = fmt.Sprintf("Unable to refresh the initializer configuration: %v", err)
0000000000000000000000000000000000000000;;			e.ErrStatus.Reason = "LoadingConfiguration"
0000000000000000000000000000000000000000;;			e.ErrStatus.Details.Causes = append(e.ErrStatus.Details.Causes, metav1.StatusCause{
0000000000000000000000000000000000000000;;				Type:    "InitializerConfigurationFailure",
0000000000000000000000000000000000000000;;				Message: "An error has occurred while refreshing the initializer configuration, no resources can be created until a refresh succeeds.",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Admit checks for create requests to add initializers, or update request to enforce invariants.
0000000000000000000000000000000000000000;;	// The admission controller fails open if the object doesn't have ObjectMeta (can't be initialized).
0000000000000000000000000000000000000000;;	// A client with sufficient permission ("initialize" verb on resource) can specify its own initializers
0000000000000000000000000000000000000000;;	// or an empty initializers struct (which bypasses initialization). Only clients with the initialize verb
0000000000000000000000000000000000000000;;	// can update objects that have not completed initialization. Sub resources can still be modified on
0000000000000000000000000000000000000000;;	// resources that are undergoing initialization.
0000000000000000000000000000000000000000;;	// TODO: once this logic is ready for beta, move it into the REST storage layer.
0000000000000000000000000000000000000000;;	func (i *initializer) Admit(a admission.Attributes) (err error) {
0000000000000000000000000000000000000000;;		switch a.GetOperation() {
0000000000000000000000000000000000000000;;		case admission.Create, admission.Update:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: should sub-resource action should be denied until the object is initialized?
0000000000000000000000000000000000000000;;		if len(a.GetSubresource()) > 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch a.GetOperation() {
0000000000000000000000000000000000000000;;		case admission.Create:
0000000000000000000000000000000000000000;;			accessor, err := meta.Accessor(a.GetObject())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// objects without meta accessor cannot be checked for initialization, and it is possible to make calls
0000000000000000000000000000000000000000;;				// via our API that don't have ObjectMeta
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			existing := accessor.GetInitializers()
0000000000000000000000000000000000000000;;			if existing != nil {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Admin bypassing initialization for %s", a.GetResource())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// it must be possible for some users to bypass initialization - for now, check the initialize operation
0000000000000000000000000000000000000000;;				if err := i.canInitialize(a, "create with initializers denied"); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// allow administrators to bypass initialization by setting an empty initializers struct
0000000000000000000000000000000000000000;;				if len(existing.Pending) == 0 && existing.Result == nil {
0000000000000000000000000000000000000000;;					accessor.SetInitializers(nil)
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Checking initialization for %s", a.GetResource())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				config, err := i.readConfig(a)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Mirror pods are exempt from initialization because they are created and initialized
0000000000000000000000000000000000000000;;				// on the Kubelet before they appear in the API.
0000000000000000000000000000000000000000;;				// TODO: once this moves to REST storage layer, this becomes a pod specific concern
0000000000000000000000000000000000000000;;				if pod, ok := a.GetObject().(*api.Pod); ok && pod != nil {
0000000000000000000000000000000000000000;;					if _, isMirror := pod.Annotations[api.MirrorPodAnnotationKey]; isMirror {
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				names := findInitializers(config, a.GetResource())
0000000000000000000000000000000000000000;;				if len(names) == 0 {
0000000000000000000000000000000000000000;;					glog.V(5).Infof("No initializers needed")
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Found initializers for %s: %v", a.GetResource(), names)
0000000000000000000000000000000000000000;;				accessor.SetInitializers(newInitializers(names))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case admission.Update:
0000000000000000000000000000000000000000;;			accessor, err := meta.Accessor(a.GetObject())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// objects without meta accessor cannot be checked for initialization, and it is possible to make calls
0000000000000000000000000000000000000000;;				// via our API that don't have ObjectMeta
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			updated := accessor.GetInitializers()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			existingAccessor, err := meta.Accessor(a.GetOldObject())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// if the old object does not have an accessor, but the new one does, error out
0000000000000000000000000000000000000000;;				return fmt.Errorf("initialized resources must be able to set initializers (%T): %v", a.GetOldObject(), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			existing := existingAccessor.GetInitializers()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// updates on initialized resources are allowed
0000000000000000000000000000000000000000;;			if updated == nil && existing == nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(5).Infof("Modifying uninitialized resource %s", a.GetResource())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// because we are called before validation, we need to ensure the update transition is valid.
0000000000000000000000000000000000000000;;			if errs := validation.ValidateInitializersUpdate(updated, existing, initializerFieldPath); len(errs) > 0 {
0000000000000000000000000000000000000000;;				return errors.NewInvalid(a.GetKind().GroupKind(), a.GetName(), errs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// caller must have the ability to mutate un-initialized resources
0000000000000000000000000000000000000000;;			if err := i.canInitialize(a, "update to uninitialized resource denied"); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: restrict initialization list changes to specific clients?
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *initializer) canInitialize(a admission.Attributes, message string) error {
0000000000000000000000000000000000000000;;		// if no authorizer is present, the initializer plugin allows modification of uninitialized resources
0000000000000000000000000000000000000000;;		if i.authorizer == nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("No authorizer provided to initialization admission control, unable to check permissions")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// caller must have the ability to mutate un-initialized resources
0000000000000000000000000000000000000000;;		authorized, reason, err := i.authorizer.Authorize(authorizer.AttributesRecord{
0000000000000000000000000000000000000000;;			Name:            a.GetName(),
0000000000000000000000000000000000000000;;			ResourceRequest: true,
0000000000000000000000000000000000000000;;			User:            a.GetUserInfo(),
0000000000000000000000000000000000000000;;			Verb:            "initialize",
0000000000000000000000000000000000000000;;			Namespace:       a.GetNamespace(),
0000000000000000000000000000000000000000;;			APIGroup:        a.GetResource().Group,
0000000000000000000000000000000000000000;;			APIVersion:      a.GetResource().Version,
0000000000000000000000000000000000000000;;			Resource:        a.GetResource().Resource,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !authorized {
0000000000000000000000000000000000000000;;			return errors.NewForbidden(a.GetResource().GroupResource(), a.GetName(), fmt.Errorf("%s: %s", message, reason))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *initializer) Handles(op admission.Operation) bool {
0000000000000000000000000000000000000000;;		return op == admission.Create || op == admission.Update
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newInitializers populates an Initializers struct.
0000000000000000000000000000000000000000;;	func newInitializers(names []string) *metav1.Initializers {
0000000000000000000000000000000000000000;;		if len(names) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var init []metav1.Initializer
0000000000000000000000000000000000000000;;		for _, name := range names {
0000000000000000000000000000000000000000;;			init = append(init, metav1.Initializer{Name: name})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &metav1.Initializers{
0000000000000000000000000000000000000000;;			Pending: init,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findInitializers returns the list of initializer names that apply to a config. It returns an empty list
0000000000000000000000000000000000000000;;	// if no initializers apply.
0000000000000000000000000000000000000000;;	func findInitializers(initializers *v1alpha1.InitializerConfiguration, gvr schema.GroupVersionResource) []string {
0000000000000000000000000000000000000000;;		var names []string
0000000000000000000000000000000000000000;;		for _, init := range initializers.Initializers {
0000000000000000000000000000000000000000;;			if !matchRule(init.Rules, gvr) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			names = append(names, init.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return names
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// matchRule returns true if any rule matches the provided group version resource.
0000000000000000000000000000000000000000;;	func matchRule(rules []v1alpha1.Rule, gvr schema.GroupVersionResource) bool {
0000000000000000000000000000000000000000;;		for _, rule := range rules {
0000000000000000000000000000000000000000;;			if !hasGroup(rule.APIGroups, gvr.Group) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !hasVersion(rule.APIVersions, gvr.Version) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !hasResource(rule.Resources, gvr.Resource) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(rules) > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasGroup(groups []string, group string) bool {
0000000000000000000000000000000000000000;;		if groups[0] == "*" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, g := range groups {
0000000000000000000000000000000000000000;;			if g == group {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasVersion(versions []string, version string) bool {
0000000000000000000000000000000000000000;;		if versions[0] == "*" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range versions {
0000000000000000000000000000000000000000;;			if v == version {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasResource(resources []string, resource string) bool {
0000000000000000000000000000000000000000;;		if resources[0] == "*" || resources[0] == "*/*" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, r := range resources {
0000000000000000000000000000000000000000;;			if strings.Contains(r, "/") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if r == resource {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
