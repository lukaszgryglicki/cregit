0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f78000f784fcc6cc55f5354883f47fa55cf943c5;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package gc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register registers a plugin
0000000000000000000000000000000000000000;;	func Register(plugins *admission.Plugins) {
0000000000000000000000000000000000000000;;		plugins.Register("OwnerReferencesPermissionEnforcement", func(config io.Reader) (admission.Interface, error) {
0000000000000000000000000000000000000000;;			// the pods/status endpoint is ignored by this plugin since old kubelets
0000000000000000000000000000000000000000;;			// corrupt them.  the pod status strategy ensures status updates cannot mutate
0000000000000000000000000000000000000000;;			// ownerRef.
0000000000000000000000000000000000000000;;			whiteList := []whiteListItem{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					groupResource: schema.GroupResource{Resource: "pods"},
0000000000000000000000000000000000000000;;					subresource:   "status",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &gcPermissionsEnforcement{
0000000000000000000000000000000000000000;;				Handler:   admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;				whiteList: whiteList,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// gcPermissionsEnforcement is an implementation of admission.Interface.
0000000000000000000000000000000000000000;;	type gcPermissionsEnforcement struct {
0000000000000000000000000000000000000000;;		*admission.Handler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authorizer authorizer.Authorizer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restMapper meta.RESTMapper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// items in this whitelist are ignored upon admission.
0000000000000000000000000000000000000000;;		// any item in this list must protect against ownerRef mutations
0000000000000000000000000000000000000000;;		// via strategy enforcement.
0000000000000000000000000000000000000000;;		whiteList []whiteListItem
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// whiteListItem describes an entry in a whitelist ignored by gc permission enforcement.
0000000000000000000000000000000000000000;;	type whiteListItem struct {
0000000000000000000000000000000000000000;;		groupResource schema.GroupResource
0000000000000000000000000000000000000000;;		subresource   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isWhiteListed returns true if the specified item is in the whitelist.
0000000000000000000000000000000000000000;;	func (a *gcPermissionsEnforcement) isWhiteListed(groupResource schema.GroupResource, subresource string) bool {
0000000000000000000000000000000000000000;;		for _, item := range a.whiteList {
0000000000000000000000000000000000000000;;			if item.groupResource == groupResource && item.subresource == subresource {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *gcPermissionsEnforcement) Admit(attributes admission.Attributes) (err error) {
0000000000000000000000000000000000000000;;		// // if the request is in the whitelist, we skip mutation checks for this resource.
0000000000000000000000000000000000000000;;		if a.isWhiteListed(attributes.GetResource().GroupResource(), attributes.GetSubresource()) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we aren't changing owner references, then the edit is always allowed
0000000000000000000000000000000000000000;;		if !isChangingOwnerReference(attributes.GetObject(), attributes.GetOldObject()) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deleteAttributes := authorizer.AttributesRecord{
0000000000000000000000000000000000000000;;			User:            attributes.GetUserInfo(),
0000000000000000000000000000000000000000;;			Verb:            "delete",
0000000000000000000000000000000000000000;;			Namespace:       attributes.GetNamespace(),
0000000000000000000000000000000000000000;;			APIGroup:        attributes.GetResource().Group,
0000000000000000000000000000000000000000;;			APIVersion:      attributes.GetResource().Version,
0000000000000000000000000000000000000000;;			Resource:        attributes.GetResource().Resource,
0000000000000000000000000000000000000000;;			Subresource:     attributes.GetSubresource(),
0000000000000000000000000000000000000000;;			Name:            attributes.GetName(),
0000000000000000000000000000000000000000;;			ResourceRequest: true,
0000000000000000000000000000000000000000;;			Path:            "",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allowed, reason, err := a.authorizer.Authorize(deleteAttributes)
0000000000000000000000000000000000000000;;		if !allowed {
0000000000000000000000000000000000000000;;			return admission.NewForbidden(attributes, fmt.Errorf("cannot set an ownerRef on a resource you can't delete: %v, %v", reason, err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Further check if the user is setting ownerReference.blockOwnerDeletion to
0000000000000000000000000000000000000000;;		// true. If so, only allows the change if the user has delete permission of
0000000000000000000000000000000000000000;;		// the _OWNER_
0000000000000000000000000000000000000000;;		newBlockingRefs := newBlockingOwnerDeletionRefs(attributes.GetObject(), attributes.GetOldObject())
0000000000000000000000000000000000000000;;		for _, ref := range newBlockingRefs {
0000000000000000000000000000000000000000;;			records, err := a.ownerRefToDeleteAttributeRecords(ref, attributes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return admission.NewForbidden(attributes, fmt.Errorf("cannot set blockOwnerDeletion in this case because cannot find RESTMapping for APIVersion %s Kind %s: %v, %v", ref.APIVersion, ref.Kind, reason, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Multiple records are returned if ref.Kind could map to multiple
0000000000000000000000000000000000000000;;			// resources. User needs to have delete permission on all the
0000000000000000000000000000000000000000;;			// matched Resources.
0000000000000000000000000000000000000000;;			for _, record := range records {
0000000000000000000000000000000000000000;;				allowed, reason, err := a.authorizer.Authorize(record)
0000000000000000000000000000000000000000;;				if !allowed {
0000000000000000000000000000000000000000;;					return admission.NewForbidden(attributes, fmt.Errorf("cannot set blockOwnerDeletion if an ownerReference refers to a resource you can't delete: %v, %v", reason, err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isChangingOwnerReference(newObj, oldObj runtime.Object) bool {
0000000000000000000000000000000000000000;;		newMeta, err := meta.Accessor(newObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// if we don't have objectmeta, we don't have the object reference
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if oldObj == nil {
0000000000000000000000000000000000000000;;			return len(newMeta.GetOwnerReferences()) > 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldMeta, err := meta.Accessor(oldObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// if we don't have objectmeta, we don't have the object reference
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// compare the old and new.  If they aren't the same, then we're trying to change an ownerRef
0000000000000000000000000000000000000000;;		oldOwners := oldMeta.GetOwnerReferences()
0000000000000000000000000000000000000000;;		newOwners := newMeta.GetOwnerReferences()
0000000000000000000000000000000000000000;;		if len(oldOwners) != len(newOwners) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range oldOwners {
0000000000000000000000000000000000000000;;			if !apiequality.Semantic.DeepEqual(oldOwners[i], newOwners[i]) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Translates ref to a DeleteAttribute deleting the object referred by the ref.
0000000000000000000000000000000000000000;;	// OwnerReference only records the object kind, which might map to multiple
0000000000000000000000000000000000000000;;	// resources, so multiple DeleteAttribute might be returned.
0000000000000000000000000000000000000000;;	func (a *gcPermissionsEnforcement) ownerRefToDeleteAttributeRecords(ref metav1.OwnerReference, attributes admission.Attributes) ([]authorizer.AttributesRecord, error) {
0000000000000000000000000000000000000000;;		var ret []authorizer.AttributesRecord
0000000000000000000000000000000000000000;;		groupVersion, err := schema.ParseGroupVersion(ref.APIVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ret, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mappings, err := a.restMapper.RESTMappings(schema.GroupKind{Group: groupVersion.Group, Kind: ref.Kind}, groupVersion.Version)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ret, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, mapping := range mappings {
0000000000000000000000000000000000000000;;			ret = append(ret, authorizer.AttributesRecord{
0000000000000000000000000000000000000000;;				User: attributes.GetUserInfo(),
0000000000000000000000000000000000000000;;				Verb: "delete",
0000000000000000000000000000000000000000;;				// ownerReference can only refer to an object in the same namespace, so attributes.GetNamespace() equals to the owner's namespace
0000000000000000000000000000000000000000;;				Namespace:       attributes.GetNamespace(),
0000000000000000000000000000000000000000;;				APIGroup:        groupVersion.Group,
0000000000000000000000000000000000000000;;				APIVersion:      groupVersion.Version,
0000000000000000000000000000000000000000;;				Resource:        mapping.Resource,
0000000000000000000000000000000000000000;;				Name:            ref.Name,
0000000000000000000000000000000000000000;;				ResourceRequest: true,
0000000000000000000000000000000000000000;;				Path:            "",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// only keeps the blocking refs
0000000000000000000000000000000000000000;;	func blockingOwnerRefs(refs []metav1.OwnerReference) []metav1.OwnerReference {
0000000000000000000000000000000000000000;;		var ret []metav1.OwnerReference
0000000000000000000000000000000000000000;;		for _, ref := range refs {
0000000000000000000000000000000000000000;;			if ref.BlockOwnerDeletion != nil && *ref.BlockOwnerDeletion == true {
0000000000000000000000000000000000000000;;				ret = append(ret, ref)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func indexByUID(refs []metav1.OwnerReference) map[types.UID]metav1.OwnerReference {
0000000000000000000000000000000000000000;;		ret := make(map[types.UID]metav1.OwnerReference)
0000000000000000000000000000000000000000;;		for _, ref := range refs {
0000000000000000000000000000000000000000;;			ret[ref.UID] = ref
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns new blocking ownerReferences, and references whose blockOwnerDeletion
0000000000000000000000000000000000000000;;	// field is changed from nil or false to true.
0000000000000000000000000000000000000000;;	func newBlockingOwnerDeletionRefs(newObj, oldObj runtime.Object) []metav1.OwnerReference {
0000000000000000000000000000000000000000;;		newMeta, err := meta.Accessor(newObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// if we don't have objectmeta, we don't have the object reference
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newRefs := newMeta.GetOwnerReferences()
0000000000000000000000000000000000000000;;		blockingNewRefs := blockingOwnerRefs(newRefs)
0000000000000000000000000000000000000000;;		if len(blockingNewRefs) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if oldObj == nil {
0000000000000000000000000000000000000000;;			return blockingNewRefs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldMeta, err := meta.Accessor(oldObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// if we don't have objectmeta, treat it as if all the ownerReference are newly created
0000000000000000000000000000000000000000;;			return blockingNewRefs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ret []metav1.OwnerReference
0000000000000000000000000000000000000000;;		indexedOldRefs := indexByUID(oldMeta.GetOwnerReferences())
0000000000000000000000000000000000000000;;		for _, ref := range blockingNewRefs {
0000000000000000000000000000000000000000;;			oldRef, ok := indexedOldRefs[ref.UID]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// if ref is newly added, and it's blocking, then returns it.
0000000000000000000000000000000000000000;;				ret = append(ret, ref)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wasNotBlocking := oldRef.BlockOwnerDeletion == nil || *oldRef.BlockOwnerDeletion == false
0000000000000000000000000000000000000000;;			if wasNotBlocking {
0000000000000000000000000000000000000000;;				ret = append(ret, ref)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *gcPermissionsEnforcement) SetAuthorizer(authorizer authorizer.Authorizer) {
0000000000000000000000000000000000000000;;		a.authorizer = authorizer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *gcPermissionsEnforcement) SetRESTMapper(restMapper meta.RESTMapper) {
0000000000000000000000000000000000000000;;		a.restMapper = restMapper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *gcPermissionsEnforcement) Validate() error {
0000000000000000000000000000000000000000;;		if a.authorizer == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing authorizer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.restMapper == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing restMapper")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
