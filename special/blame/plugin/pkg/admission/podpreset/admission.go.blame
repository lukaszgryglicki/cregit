0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
4f464f4f557a394d8000d8a173a77452fc579f35;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package podpreset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/ref"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/settings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/internalversion"
0000000000000000000000000000000000000000;;		settingslisters "k8s.io/kubernetes/pkg/client/listers/settings/internalversion"
0000000000000000000000000000000000000000;;		kubeapiserveradmission "k8s.io/kubernetes/pkg/kubeapiserver/admission"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		annotationPrefix = "podpreset.admission.kubernetes.io"
0000000000000000000000000000000000000000;;		pluginName       = "PodPreset"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register registers a plugin
0000000000000000000000000000000000000000;;	func Register(plugins *admission.Plugins) {
0000000000000000000000000000000000000000;;		plugins.Register(pluginName, func(config io.Reader) (admission.Interface, error) {
0000000000000000000000000000000000000000;;			return NewPlugin(), nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// podPresetPlugin is an implementation of admission.Interface.
0000000000000000000000000000000000000000;;	type podPresetPlugin struct {
0000000000000000000000000000000000000000;;		*admission.Handler
0000000000000000000000000000000000000000;;		client internalclientset.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lister settingslisters.PodPresetLister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = kubeapiserveradmission.WantsInternalKubeInformerFactory(&podPresetPlugin{})
0000000000000000000000000000000000000000;;	var _ = kubeapiserveradmission.WantsInternalKubeClientSet(&podPresetPlugin{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPlugin creates a new pod preset admission plugin.
0000000000000000000000000000000000000000;;	func NewPlugin() *podPresetPlugin {
0000000000000000000000000000000000000000;;		return &podPresetPlugin{
0000000000000000000000000000000000000000;;			Handler: admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *podPresetPlugin) Validate() error {
0000000000000000000000000000000000000000;;		if plugin.client == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%s requires a client", pluginName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plugin.lister == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%s requires a lister", pluginName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *podPresetPlugin) SetInternalKubeClientSet(client internalclientset.Interface) {
0000000000000000000000000000000000000000;;		a.client = client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *podPresetPlugin) SetInternalKubeInformerFactory(f informers.SharedInformerFactory) {
0000000000000000000000000000000000000000;;		podPresetInformer := f.Settings().InternalVersion().PodPresets()
0000000000000000000000000000000000000000;;		a.lister = podPresetInformer.Lister()
0000000000000000000000000000000000000000;;		a.SetReadyFunc(podPresetInformer.Informer().HasSynced)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Admit injects a pod with the specific fields for each pod preset it matches.
0000000000000000000000000000000000000000;;	func (c *podPresetPlugin) Admit(a admission.Attributes) error {
0000000000000000000000000000000000000000;;		// Ignore all calls to subresources or resources other than pods.
0000000000000000000000000000000000000000;;		// Ignore all operations other than CREATE.
0000000000000000000000000000000000000000;;		if len(a.GetSubresource()) != 0 || a.GetResource().GroupResource() != api.Resource("pods") || a.GetOperation() != admission.Create {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod, ok := a.GetObject().(*api.Pod)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.NewBadRequest("Resource was marked with kind Pod but was unable to be converted")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, isMirrorPod := pod.Annotations[api.MirrorPodAnnotationKey]; isMirrorPod {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		list, err := c.lister.PodPresets(pod.GetNamespace()).List(labels.Everything())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ignore if exclusion annotation is present
0000000000000000000000000000000000000000;;		if podAnnotations := pod.GetAnnotations(); podAnnotations != nil {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("Looking at pod annotations, found: %v", podAnnotations)
0000000000000000000000000000000000000000;;			if podAnnotations[api.PodPresetOptOutAnnotationKey] == "true" {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("listing pod presets failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get the pod presets and iterate over them
0000000000000000000000000000000000000000;;		for _, pip := range list {
0000000000000000000000000000000000000000;;			selector, err := metav1.LabelSelectorAsSelector(&pip.Spec.Selector)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("listing pod presets for namespace:%s failed: %v", pod.GetNamespace(), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// check if the pod labels match the selector
0000000000000000000000000000000000000000;;			if !selector.Matches(labels.Set(pod.Labels)) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(4).Infof("PodPreset %s matches pod %s labels", pip.GetName(), pod.GetName())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// merge in policy for Env
0000000000000000000000000000000000000000;;			if pip.Spec.Env != nil {
0000000000000000000000000000000000000000;;				for i, ctr := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;					r, err := mergeEnv(pip, ctr.Env)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						// add event to pod
0000000000000000000000000000000000000000;;						c.addEvent(pod, pip, err.Error())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					pod.Spec.Containers[i].Env = r
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// merge in policy for EnvFrom
0000000000000000000000000000000000000000;;			if pip.Spec.EnvFrom != nil {
0000000000000000000000000000000000000000;;				for i, ctr := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;					r, err := mergeEnvFrom(pip, ctr.EnvFrom)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						// add event to pod
0000000000000000000000000000000000000000;;						c.addEvent(pod, pip, err.Error())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					pod.Spec.Containers[i].EnvFrom = r
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// merge in policy for VolumeMounts
0000000000000000000000000000000000000000;;			if pip.Spec.VolumeMounts != nil {
0000000000000000000000000000000000000000;;				for i, ctr := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;					r, err := mergeVolumeMounts(pip, ctr.VolumeMounts)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						// add event to pod
0000000000000000000000000000000000000000;;						c.addEvent(pod, pip, err.Error())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					pod.Spec.Containers[i].VolumeMounts = r
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// merge in policy for Volumes
0000000000000000000000000000000000000000;;			if pip.Spec.Volumes != nil {
0000000000000000000000000000000000000000;;				r, err := mergeVolumes(pip, pod.Spec.Volumes)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// add event to pod
0000000000000000000000000000000000000000;;					c.addEvent(pod, pip, err.Error())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pod.Spec.Volumes = r
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(4).Infof("PodPreset %s merged with pod %s successfully", pip.GetName(), pod.GetName())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// add annotation
0000000000000000000000000000000000000000;;			if pod.ObjectMeta.Annotations == nil {
0000000000000000000000000000000000000000;;				pod.ObjectMeta.Annotations = map[string]string{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod.ObjectMeta.Annotations[fmt.Sprintf("%s/podpreset-%s", annotationPrefix, pip.GetName())] = pip.GetResourceVersion()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mergeEnv(pip *settings.PodPreset, original []api.EnvVar) ([]api.EnvVar, error) {
0000000000000000000000000000000000000000;;		// if there were no original envvar just return the pip envvar
0000000000000000000000000000000000000000;;		if original == nil {
0000000000000000000000000000000000000000;;			return pip.Spec.Env, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		orig := map[string]interface{}{}
0000000000000000000000000000000000000000;;		for _, v := range original {
0000000000000000000000000000000000000000;;			orig[v.Name] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check for conflicts.
0000000000000000000000000000000000000000;;		for _, v := range pip.Spec.Env {
0000000000000000000000000000000000000000;;			found, ok := orig[v.Name]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// if we don't already have it append it and continue
0000000000000000000000000000000000000000;;				original = append(original, v)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// make sure they are identical or throw an error
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(found, v) {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("merging env for %s has a conflict on %s: \n%#v\ndoes not match\n%#v\n in container", pip.GetName(), v.Name, v, found)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return original, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mergeEnvFrom(pip *settings.PodPreset, original []api.EnvFromSource) ([]api.EnvFromSource, error) {
0000000000000000000000000000000000000000;;		// if there were no original envfrom just return the pip envfrom
0000000000000000000000000000000000000000;;		if original == nil {
0000000000000000000000000000000000000000;;			return pip.Spec.EnvFrom, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return append(original, pip.Spec.EnvFrom...), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mergeVolumeMounts(pip *settings.PodPreset, original []api.VolumeMount) ([]api.VolumeMount, error) {
0000000000000000000000000000000000000000;;		// if there were no original volume mount just return the pip volume mount
0000000000000000000000000000000000000000;;		if original == nil {
0000000000000000000000000000000000000000;;			return pip.Spec.VolumeMounts, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// first key by name
0000000000000000000000000000000000000000;;		orig := map[string]interface{}{}
0000000000000000000000000000000000000000;;		for _, v := range original {
0000000000000000000000000000000000000000;;			orig[v.Name] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check for conflicts.
0000000000000000000000000000000000000000;;		for _, v := range pip.Spec.VolumeMounts {
0000000000000000000000000000000000000000;;			found, ok := orig[v.Name]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// if we don't already have it continue
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// make sure they are identical or throw an error
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(found, v) {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("merging volume mounts for %s has a conflict on %s: \n%#v\ndoes not match\n%#v\n in container", pip.GetName(), v.Name, v, found)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// key by mount path
0000000000000000000000000000000000000000;;		orig = map[string]interface{}{}
0000000000000000000000000000000000000000;;		for _, v := range original {
0000000000000000000000000000000000000000;;			orig[v.MountPath] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check for conflicts.
0000000000000000000000000000000000000000;;		for _, v := range pip.Spec.VolumeMounts {
0000000000000000000000000000000000000000;;			found, ok := orig[v.MountPath]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// if we don't already have it append it and continue
0000000000000000000000000000000000000000;;				original = append(original, v)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// make sure they are identical or throw an error
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(found, v) {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("merging volume mounts for %s has a conflict on mount path %s: \n%#v\ndoes not match\n%#v\n in container", pip.GetName(), v.MountPath, v, found)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return original, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mergeVolumes(pip *settings.PodPreset, original []api.Volume) ([]api.Volume, error) {
0000000000000000000000000000000000000000;;		// if there were no original volumes just return the pip volumes
0000000000000000000000000000000000000000;;		if original == nil {
0000000000000000000000000000000000000000;;			return pip.Spec.Volumes, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		orig := map[string]api.Volume{}
0000000000000000000000000000000000000000;;		for _, v := range original {
0000000000000000000000000000000000000000;;			orig[v.Name] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check for conflicts.
0000000000000000000000000000000000000000;;		for _, v := range pip.Spec.Volumes {
0000000000000000000000000000000000000000;;			found, ok := orig[v.Name]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// if we don't already have it append it and continue
0000000000000000000000000000000000000000;;				original = append(original, v)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(found, v) {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("merging volumes for %s has a conflict on %s: \n%#v\ndoes not match\n%#v\nin pod spec", pip.GetName(), v.Name, v, found)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return original, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *podPresetPlugin) addEvent(pod *api.Pod, pip *settings.PodPreset, message string) {
0000000000000000000000000000000000000000;;		ref, err := ref.GetReference(api.Scheme, pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("pip %s: get reference for pod %s failed: %v", pip.GetName(), pod.GetName(), err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e := &api.Event{
0000000000000000000000000000000000000000;;			InvolvedObject: *ref,
0000000000000000000000000000000000000000;;			Message:        message,
0000000000000000000000000000000000000000;;			Source: api.EventSource{
0000000000000000000000000000000000000000;;				Component: fmt.Sprintf("pip %s", pip.GetName()),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Type: "Warning",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := c.client.Core().Events(pod.GetNamespace()).Create(e); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("pip %s: creating pod event failed: %v", pip.GetName(), err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
