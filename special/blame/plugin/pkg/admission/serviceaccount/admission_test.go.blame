0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
154cb79702b6fc1117233b8825b6a51dac3c197a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package serviceaccount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/fake"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/internalversion"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		kubelet "k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIgnoresNonCreate(t *testing.T) {
0000000000000000000000000000000000000000;;		pod := &api.Pod{}
0000000000000000000000000000000000000000;;		for _, op := range []admission.Operation{admission.Update, admission.Delete, admission.Connect} {
0000000000000000000000000000000000000000;;			attrs := admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), "myns", "myname", api.Resource("pods").WithVersion("version"), "", op, nil)
0000000000000000000000000000000000000000;;			handler := admission.NewChainHandler(NewServiceAccount())
0000000000000000000000000000000000000000;;			err := handler.Admit(attrs)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %s operation allowed, got err: %v", op, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIgnoresNonPodResource(t *testing.T) {
0000000000000000000000000000000000000000;;		pod := &api.Pod{}
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), "myns", "myname", api.Resource("CustomResource").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		err := NewServiceAccount().Admit(attrs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected non-pod resource allowed, got err: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIgnoresNilObject(t *testing.T) {
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(nil, nil, api.Kind("Pod").WithVersion("version"), "myns", "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		err := NewServiceAccount().Admit(attrs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected nil object allowed allowed, got err: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIgnoresNonPodObject(t *testing.T) {
0000000000000000000000000000000000000000;;		obj := &api.Namespace{}
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(obj, nil, api.Kind("Pod").WithVersion("version"), "myns", "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		err := NewServiceAccount().Admit(attrs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected non pod object allowed, got err: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIgnoresMirrorPod(t *testing.T) {
0000000000000000000000000000000000000000;;		pod := &api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					kubelet.ConfigMirrorAnnotationKey: "true",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []api.Volume{
0000000000000000000000000000000000000000;;					{VolumeSource: api.VolumeSource{}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), "myns", "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		err := NewServiceAccount().Admit(attrs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected mirror pod without service account or secrets allowed, got err: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRejectsMirrorPodWithServiceAccount(t *testing.T) {
0000000000000000000000000000000000000000;;		pod := &api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					kubelet.ConfigMirrorAnnotationKey: "true",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				ServiceAccountName: "default",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), "myns", "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		err := NewServiceAccount().Admit(attrs)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected a mirror pod to be prevented from referencing a service account")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRejectsMirrorPodWithSecretVolumes(t *testing.T) {
0000000000000000000000000000000000000000;;		pod := &api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					kubelet.ConfigMirrorAnnotationKey: "true",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []api.Volume{
0000000000000000000000000000000000000000;;					{VolumeSource: api.VolumeSource{Secret: &api.SecretVolumeSource{}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), "myns", "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		err := NewServiceAccount().Admit(attrs)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected a mirror pod to be prevented from referencing a secret volume")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAssignsDefaultServiceAccountAndToleratesMissingAPIToken(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "myns"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		admit := NewServiceAccount()
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(nil, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		admit.SetInternalKubeInformerFactory(informerFactory)
0000000000000000000000000000000000000000;;		admit.MountServiceAccountToken = true
0000000000000000000000000000000000000000;;		admit.RequireAPIToken = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the default service account for the ns into the cache
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ServiceAccounts().Informer().GetStore().Add(&api.ServiceAccount{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      DefaultServiceAccountName,
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &api.Pod{}
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), ns, "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		err := admit.Admit(attrs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pod.Spec.ServiceAccountName != DefaultServiceAccountName {
0000000000000000000000000000000000000000;;			t.Errorf("Expected service account %s assigned, got %s", DefaultServiceAccountName, pod.Spec.ServiceAccountName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAssignsDefaultServiceAccountAndRejectsMissingAPIToken(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "myns"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		admit := NewServiceAccount()
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(nil, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		admit.SetInternalKubeInformerFactory(informerFactory)
0000000000000000000000000000000000000000;;		admit.MountServiceAccountToken = true
0000000000000000000000000000000000000000;;		admit.RequireAPIToken = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the default service account for the ns into the cache
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ServiceAccounts().Informer().GetStore().Add(&api.ServiceAccount{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      DefaultServiceAccountName,
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &api.Pod{}
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), ns, "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		err := admit.Admit(attrs)
0000000000000000000000000000000000000000;;		if err == nil || !errors.IsServerTimeout(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected server timeout error for missing API token: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFetchesUncachedServiceAccount(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "myns"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Build a test client that the admission plugin can use to look up the service account missing from its cache
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset(&api.ServiceAccount{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      DefaultServiceAccountName,
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		admit := NewServiceAccount()
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(nil, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		admit.SetInternalKubeInformerFactory(informerFactory)
0000000000000000000000000000000000000000;;		admit.client = client
0000000000000000000000000000000000000000;;		admit.RequireAPIToken = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &api.Pod{}
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), ns, "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		err := admit.Admit(attrs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pod.Spec.ServiceAccountName != DefaultServiceAccountName {
0000000000000000000000000000000000000000;;			t.Errorf("Expected service account %s assigned, got %s", DefaultServiceAccountName, pod.Spec.ServiceAccountName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeniesInvalidServiceAccount(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "myns"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Build a test client that the admission plugin can use to look up the service account missing from its cache
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		admit := NewServiceAccount()
0000000000000000000000000000000000000000;;		admit.SetInternalKubeClientSet(client)
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(nil, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		admit.SetInternalKubeInformerFactory(informerFactory)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &api.Pod{}
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), ns, "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		err := admit.Admit(attrs)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected error for missing service account, got none")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAutomountsAPIToken(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "myns"
0000000000000000000000000000000000000000;;		tokenName := "token-name"
0000000000000000000000000000000000000000;;		serviceAccountName := DefaultServiceAccountName
0000000000000000000000000000000000000000;;		serviceAccountUID := "12345"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedVolume := api.Volume{
0000000000000000000000000000000000000000;;			Name: tokenName,
0000000000000000000000000000000000000000;;			VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;				Secret: &api.SecretVolumeSource{SecretName: tokenName},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedVolumeMount := api.VolumeMount{
0000000000000000000000000000000000000000;;			Name:      tokenName,
0000000000000000000000000000000000000000;;			ReadOnly:  true,
0000000000000000000000000000000000000000;;			MountPath: DefaultAPITokenMountPath,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		admit := NewServiceAccount()
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(nil, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		admit.SetInternalKubeInformerFactory(informerFactory)
0000000000000000000000000000000000000000;;		admit.MountServiceAccountToken = true
0000000000000000000000000000000000000000;;		admit.RequireAPIToken = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the default service account for the ns with a token into the cache
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ServiceAccounts().Informer().GetStore().Add(&api.ServiceAccount{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      serviceAccountName,
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;				UID:       types.UID(serviceAccountUID),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Secrets: []api.ObjectReference{
0000000000000000000000000000000000000000;;				{Name: tokenName},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		// Add a token for the service account into the cache
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().Secrets().Informer().GetStore().Add(&api.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      tokenName,
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					api.ServiceAccountNameKey: serviceAccountName,
0000000000000000000000000000000000000000;;					api.ServiceAccountUIDKey:  serviceAccountUID,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Type: api.SecretTypeServiceAccountToken,
0000000000000000000000000000000000000000;;			Data: map[string][]byte{
0000000000000000000000000000000000000000;;				api.ServiceAccountTokenKey: []byte("token-data"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &api.Pod{
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []api.Container{
0000000000000000000000000000000000000000;;					{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), ns, "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		err := admit.Admit(attrs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pod.Spec.ServiceAccountName != DefaultServiceAccountName {
0000000000000000000000000000000000000000;;			t.Errorf("Expected service account %s assigned, got %s", DefaultServiceAccountName, pod.Spec.ServiceAccountName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pod.Spec.Volumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected 1 volume, got %d", len(pod.Spec.Volumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(expectedVolume, pod.Spec.Volumes[0]) {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected\n\t%#v\ngot\n\t%#v", expectedVolume, pod.Spec.Volumes[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pod.Spec.Containers[0].VolumeMounts) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected 1 volume mount, got %d", len(pod.Spec.Containers[0].VolumeMounts))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(expectedVolumeMount, pod.Spec.Containers[0].VolumeMounts[0]) {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected\n\t%#v\ngot\n\t%#v", expectedVolumeMount, pod.Spec.Containers[0].VolumeMounts[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod = &api.Pod{
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				InitContainers: []api.Container{
0000000000000000000000000000000000000000;;					{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrs = admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), ns, "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		if err := admit.Admit(attrs); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pod.Spec.ServiceAccountName != DefaultServiceAccountName {
0000000000000000000000000000000000000000;;			t.Errorf("Expected service account %s assigned, got %s", DefaultServiceAccountName, pod.Spec.ServiceAccountName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pod.Spec.Volumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected 1 volume, got %d", len(pod.Spec.Volumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(expectedVolume, pod.Spec.Volumes[0]) {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected\n\t%#v\ngot\n\t%#v", expectedVolume, pod.Spec.Volumes[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pod.Spec.InitContainers[0].VolumeMounts) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected 1 volume mount, got %d", len(pod.Spec.InitContainers[0].VolumeMounts))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(expectedVolumeMount, pod.Spec.InitContainers[0].VolumeMounts[0]) {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected\n\t%#v\ngot\n\t%#v", expectedVolumeMount, pod.Spec.InitContainers[0].VolumeMounts[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRespectsExistingMount(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "myns"
0000000000000000000000000000000000000000;;		tokenName := "token-name"
0000000000000000000000000000000000000000;;		serviceAccountName := DefaultServiceAccountName
0000000000000000000000000000000000000000;;		serviceAccountUID := "12345"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedVolumeMount := api.VolumeMount{
0000000000000000000000000000000000000000;;			Name:      "my-custom-mount",
0000000000000000000000000000000000000000;;			ReadOnly:  false,
0000000000000000000000000000000000000000;;			MountPath: DefaultAPITokenMountPath,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		admit := NewServiceAccount()
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(nil, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		admit.SetInternalKubeInformerFactory(informerFactory)
0000000000000000000000000000000000000000;;		admit.MountServiceAccountToken = true
0000000000000000000000000000000000000000;;		admit.RequireAPIToken = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the default service account for the ns with a token into the cache
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ServiceAccounts().Informer().GetStore().Add(&api.ServiceAccount{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      serviceAccountName,
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;				UID:       types.UID(serviceAccountUID),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Secrets: []api.ObjectReference{
0000000000000000000000000000000000000000;;				{Name: tokenName},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		// Add a token for the service account into the cache
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().Secrets().Informer().GetStore().Add(&api.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      tokenName,
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					api.ServiceAccountNameKey: serviceAccountName,
0000000000000000000000000000000000000000;;					api.ServiceAccountUIDKey:  serviceAccountUID,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Type: api.SecretTypeServiceAccountToken,
0000000000000000000000000000000000000000;;			Data: map[string][]byte{
0000000000000000000000000000000000000000;;				api.ServiceAccountTokenKey: []byte("token-data"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Define a pod with a container that already mounts a volume at the API token path
0000000000000000000000000000000000000000;;		// Admission should respect that
0000000000000000000000000000000000000000;;		// Additionally, no volume should be created if no container is going to use it
0000000000000000000000000000000000000000;;		pod := &api.Pod{
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []api.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						VolumeMounts: []api.VolumeMount{
0000000000000000000000000000000000000000;;							expectedVolumeMount,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), ns, "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		err := admit.Admit(attrs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pod.Spec.ServiceAccountName != DefaultServiceAccountName {
0000000000000000000000000000000000000000;;			t.Errorf("Expected service account %s assigned, got %s", DefaultServiceAccountName, pod.Spec.ServiceAccountName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pod.Spec.Volumes) != 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected 0 volumes (shouldn't create a volume for a secret we don't need), got %d", len(pod.Spec.Volumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pod.Spec.Containers[0].VolumeMounts) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected 1 volume mount, got %d", len(pod.Spec.Containers[0].VolumeMounts))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(expectedVolumeMount, pod.Spec.Containers[0].VolumeMounts[0]) {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected\n\t%#v\ngot\n\t%#v", expectedVolumeMount, pod.Spec.Containers[0].VolumeMounts[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check init containers
0000000000000000000000000000000000000000;;		pod = &api.Pod{
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				InitContainers: []api.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						VolumeMounts: []api.VolumeMount{
0000000000000000000000000000000000000000;;							expectedVolumeMount,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrs = admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), ns, "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		if err := admit.Admit(attrs); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pod.Spec.ServiceAccountName != DefaultServiceAccountName {
0000000000000000000000000000000000000000;;			t.Errorf("Expected service account %s assigned, got %s", DefaultServiceAccountName, pod.Spec.ServiceAccountName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pod.Spec.Volumes) != 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected 0 volumes (shouldn't create a volume for a secret we don't need), got %d", len(pod.Spec.Volumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pod.Spec.InitContainers[0].VolumeMounts) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected 1 volume mount, got %d", len(pod.Spec.InitContainers[0].VolumeMounts))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(expectedVolumeMount, pod.Spec.InitContainers[0].VolumeMounts[0]) {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected\n\t%#v\ngot\n\t%#v", expectedVolumeMount, pod.Spec.InitContainers[0].VolumeMounts[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllowsReferencedSecret(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "myns"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		admit := NewServiceAccount()
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(nil, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		admit.SetInternalKubeInformerFactory(informerFactory)
0000000000000000000000000000000000000000;;		admit.LimitSecretReferences = true
0000000000000000000000000000000000000000;;		admit.RequireAPIToken = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the default service account for the ns with a secret reference into the cache
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ServiceAccounts().Informer().GetStore().Add(&api.ServiceAccount{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      DefaultServiceAccountName,
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Secrets: []api.ObjectReference{
0000000000000000000000000000000000000000;;				{Name: "foo"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod1 := &api.Pod{
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []api.Volume{
0000000000000000000000000000000000000000;;					{VolumeSource: api.VolumeSource{Secret: &api.SecretVolumeSource{SecretName: "foo"}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(pod1, nil, api.Kind("Pod").WithVersion("version"), ns, "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		if err := admit.Admit(attrs); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod2 := &api.Pod{
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []api.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "container-1",
0000000000000000000000000000000000000000;;						Env: []api.EnvVar{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: "env-1",
0000000000000000000000000000000000000000;;								ValueFrom: &api.EnvVarSource{
0000000000000000000000000000000000000000;;									SecretKeyRef: &api.SecretKeySelector{
0000000000000000000000000000000000000000;;										LocalObjectReference: api.LocalObjectReference{Name: "foo"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrs = admission.NewAttributesRecord(pod2, nil, api.Kind("Pod").WithVersion("version"), ns, "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		if err := admit.Admit(attrs); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod2 = &api.Pod{
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				InitContainers: []api.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "container-1",
0000000000000000000000000000000000000000;;						Env: []api.EnvVar{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: "env-1",
0000000000000000000000000000000000000000;;								ValueFrom: &api.EnvVarSource{
0000000000000000000000000000000000000000;;									SecretKeyRef: &api.SecretKeySelector{
0000000000000000000000000000000000000000;;										LocalObjectReference: api.LocalObjectReference{Name: "foo"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrs = admission.NewAttributesRecord(pod2, nil, api.Kind("Pod").WithVersion("version"), ns, "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		if err := admit.Admit(attrs); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRejectsUnreferencedSecretVolumes(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "myns"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		admit := NewServiceAccount()
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(nil, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		admit.SetInternalKubeInformerFactory(informerFactory)
0000000000000000000000000000000000000000;;		admit.LimitSecretReferences = true
0000000000000000000000000000000000000000;;		admit.RequireAPIToken = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the default service account for the ns into the cache
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ServiceAccounts().Informer().GetStore().Add(&api.ServiceAccount{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      DefaultServiceAccountName,
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod1 := &api.Pod{
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []api.Volume{
0000000000000000000000000000000000000000;;					{VolumeSource: api.VolumeSource{Secret: &api.SecretVolumeSource{SecretName: "foo"}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(pod1, nil, api.Kind("Pod").WithVersion("version"), ns, "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		if err := admit.Admit(attrs); err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected rejection for using a secret the service account does not reference")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod2 := &api.Pod{
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []api.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "container-1",
0000000000000000000000000000000000000000;;						Env: []api.EnvVar{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: "env-1",
0000000000000000000000000000000000000000;;								ValueFrom: &api.EnvVarSource{
0000000000000000000000000000000000000000;;									SecretKeyRef: &api.SecretKeySelector{
0000000000000000000000000000000000000000;;										LocalObjectReference: api.LocalObjectReference{Name: "foo"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrs = admission.NewAttributesRecord(pod2, nil, api.Kind("Pod").WithVersion("version"), ns, "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		if err := admit.Admit(attrs); err == nil || !strings.Contains(err.Error(), "with envVar") {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod2 = &api.Pod{
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				InitContainers: []api.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "container-1",
0000000000000000000000000000000000000000;;						Env: []api.EnvVar{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: "env-1",
0000000000000000000000000000000000000000;;								ValueFrom: &api.EnvVarSource{
0000000000000000000000000000000000000000;;									SecretKeyRef: &api.SecretKeySelector{
0000000000000000000000000000000000000000;;										LocalObjectReference: api.LocalObjectReference{Name: "foo"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrs = admission.NewAttributesRecord(pod2, nil, api.Kind("Pod").WithVersion("version"), ns, "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		if err := admit.Admit(attrs); err == nil || !strings.Contains(err.Error(), "with envVar") {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllowUnreferencedSecretVolumesForPermissiveSAs(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "myns"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		admit := NewServiceAccount()
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(nil, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		admit.SetInternalKubeInformerFactory(informerFactory)
0000000000000000000000000000000000000000;;		admit.LimitSecretReferences = false
0000000000000000000000000000000000000000;;		admit.RequireAPIToken = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the default service account for the ns into the cache
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ServiceAccounts().Informer().GetStore().Add(&api.ServiceAccount{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        DefaultServiceAccountName,
0000000000000000000000000000000000000000;;				Namespace:   ns,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{EnforceMountableSecretsAnnotation: "true"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &api.Pod{
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []api.Volume{
0000000000000000000000000000000000000000;;					{VolumeSource: api.VolumeSource{Secret: &api.SecretVolumeSource{SecretName: "foo"}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), ns, "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		err := admit.Admit(attrs)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected rejection for using a secret the service account does not reference")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllowsReferencedImagePullSecrets(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "myns"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		admit := NewServiceAccount()
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(nil, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		admit.SetInternalKubeInformerFactory(informerFactory)
0000000000000000000000000000000000000000;;		admit.LimitSecretReferences = true
0000000000000000000000000000000000000000;;		admit.RequireAPIToken = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the default service account for the ns with a secret reference into the cache
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ServiceAccounts().Informer().GetStore().Add(&api.ServiceAccount{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      DefaultServiceAccountName,
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ImagePullSecrets: []api.LocalObjectReference{
0000000000000000000000000000000000000000;;				{Name: "foo"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &api.Pod{
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				ImagePullSecrets: []api.LocalObjectReference{{Name: "foo"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), ns, "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		err := admit.Admit(attrs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRejectsUnreferencedImagePullSecrets(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "myns"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		admit := NewServiceAccount()
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(nil, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		admit.SetInternalKubeInformerFactory(informerFactory)
0000000000000000000000000000000000000000;;		admit.LimitSecretReferences = true
0000000000000000000000000000000000000000;;		admit.RequireAPIToken = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the default service account for the ns into the cache
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ServiceAccounts().Informer().GetStore().Add(&api.ServiceAccount{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      DefaultServiceAccountName,
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &api.Pod{
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				ImagePullSecrets: []api.LocalObjectReference{{Name: "foo"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), ns, "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		err := admit.Admit(attrs)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected rejection for using a secret the service account does not reference")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDoNotAddImagePullSecrets(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "myns"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		admit := NewServiceAccount()
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(nil, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		admit.SetInternalKubeInformerFactory(informerFactory)
0000000000000000000000000000000000000000;;		admit.LimitSecretReferences = true
0000000000000000000000000000000000000000;;		admit.RequireAPIToken = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the default service account for the ns with a secret reference into the cache
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ServiceAccounts().Informer().GetStore().Add(&api.ServiceAccount{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      DefaultServiceAccountName,
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ImagePullSecrets: []api.LocalObjectReference{
0000000000000000000000000000000000000000;;				{Name: "foo"},
0000000000000000000000000000000000000000;;				{Name: "bar"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &api.Pod{
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				ImagePullSecrets: []api.LocalObjectReference{{Name: "foo"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), ns, "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		err := admit.Admit(attrs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(pod.Spec.ImagePullSecrets) != 1 || pod.Spec.ImagePullSecrets[0].Name != "foo" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected image pull secrets: %v", pod.Spec.ImagePullSecrets)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAddImagePullSecrets(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "myns"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		admit := NewServiceAccount()
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(nil, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		admit.SetInternalKubeInformerFactory(informerFactory)
0000000000000000000000000000000000000000;;		admit.LimitSecretReferences = true
0000000000000000000000000000000000000000;;		admit.RequireAPIToken = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sa := &api.ServiceAccount{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      DefaultServiceAccountName,
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ImagePullSecrets: []api.LocalObjectReference{
0000000000000000000000000000000000000000;;				{Name: "foo"},
0000000000000000000000000000000000000000;;				{Name: "bar"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Add the default service account for the ns with a secret reference into the cache
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ServiceAccounts().Informer().GetStore().Add(sa)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &api.Pod{}
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), ns, "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		err := admit.Admit(attrs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(pod.Spec.ImagePullSecrets) != 2 || !reflect.DeepEqual(sa.ImagePullSecrets, pod.Spec.ImagePullSecrets) {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", sa.ImagePullSecrets, pod.Spec.ImagePullSecrets)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod.Spec.ImagePullSecrets[1] = api.LocalObjectReference{Name: "baz"}
0000000000000000000000000000000000000000;;		if reflect.DeepEqual(sa.ImagePullSecrets, pod.Spec.ImagePullSecrets) {
0000000000000000000000000000000000000000;;			t.Errorf("accidentally mutated the ServiceAccount.ImagePullSecrets: %v", sa.ImagePullSecrets)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMultipleReferencedSecrets(t *testing.T) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			ns                 = "myns"
0000000000000000000000000000000000000000;;			serviceAccountName = "mysa"
0000000000000000000000000000000000000000;;			serviceAccountUID  = "mysauid"
0000000000000000000000000000000000000000;;			token1             = "token1"
0000000000000000000000000000000000000000;;			token2             = "token2"
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		admit := NewServiceAccount()
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(nil, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		admit.SetInternalKubeInformerFactory(informerFactory)
0000000000000000000000000000000000000000;;		admit.MountServiceAccountToken = true
0000000000000000000000000000000000000000;;		admit.RequireAPIToken = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sa := &api.ServiceAccount{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      serviceAccountName,
0000000000000000000000000000000000000000;;				UID:       types.UID(serviceAccountUID),
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Secrets: []api.ObjectReference{
0000000000000000000000000000000000000000;;				{Name: token1},
0000000000000000000000000000000000000000;;				{Name: token2},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ServiceAccounts().Informer().GetStore().Add(sa)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add two tokens for the service account into the cache.
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().Secrets().Informer().GetStore().Add(&api.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      token2,
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					api.ServiceAccountNameKey: serviceAccountName,
0000000000000000000000000000000000000000;;					api.ServiceAccountUIDKey:  serviceAccountUID,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Type: api.SecretTypeServiceAccountToken,
0000000000000000000000000000000000000000;;			Data: map[string][]byte{
0000000000000000000000000000000000000000;;				api.ServiceAccountTokenKey: []byte("token-data"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().Secrets().Informer().GetStore().Add(&api.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      token1,
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					api.ServiceAccountNameKey: serviceAccountName,
0000000000000000000000000000000000000000;;					api.ServiceAccountUIDKey:  serviceAccountUID,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Type: api.SecretTypeServiceAccountToken,
0000000000000000000000000000000000000000;;			Data: map[string][]byte{
0000000000000000000000000000000000000000;;				api.ServiceAccountTokenKey: []byte("token-data"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &api.Pod{
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				ServiceAccountName: serviceAccountName,
0000000000000000000000000000000000000000;;				Containers: []api.Container{
0000000000000000000000000000000000000000;;					{Name: "container-1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), ns, "myname", api.Resource("pods").WithVersion("version"), "", admission.Create, nil)
0000000000000000000000000000000000000000;;		if err := admit.Admit(attrs); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if n := len(pod.Spec.Volumes); n != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("expected 1 volume mount, got %d", n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if name := pod.Spec.Volumes[0].Name; name != token1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected first referenced secret to be mounted, got %q", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSecret(secretType api.SecretType, namespace, name, serviceAccountName, serviceAccountUID string) *api.Secret {
0000000000000000000000000000000000000000;;		return &api.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					api.ServiceAccountNameKey: serviceAccountName,
0000000000000000000000000000000000000000;;					api.ServiceAccountUIDKey:  serviceAccountUID,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Type: secretType,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetServiceAccountTokens(t *testing.T) {
0000000000000000000000000000000000000000;;		admit := NewServiceAccount()
0000000000000000000000000000000000000000;;		indexer := cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers{})
0000000000000000000000000000000000000000;;		admit.secretLister = corelisters.NewSecretLister(indexer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := "namespace"
0000000000000000000000000000000000000000;;		serviceAccountUID := "12345"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sa := &api.ServiceAccount{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      DefaultServiceAccountName,
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;				UID:       types.UID(serviceAccountUID),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nonSATokenSecret := newSecret(api.SecretTypeDockercfg, ns, "nonSATokenSecret", DefaultServiceAccountName, serviceAccountUID)
0000000000000000000000000000000000000000;;		indexer.Add(nonSATokenSecret)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		differentSAToken := newSecret(api.SecretTypeServiceAccountToken, ns, "differentSAToken", "someOtherSA", "someOtherUID")
0000000000000000000000000000000000000000;;		indexer.Add(differentSAToken)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		matchingSAToken := newSecret(api.SecretTypeServiceAccountToken, ns, "matchingSAToken", DefaultServiceAccountName, serviceAccountUID)
0000000000000000000000000000000000000000;;		indexer.Add(matchingSAToken)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokens, err := admit.getServiceAccountTokens(sa)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(tokens) != 1 {
0000000000000000000000000000000000000000;;			names := make([]string, 0, len(tokens))
0000000000000000000000000000000000000000;;			for _, token := range tokens {
0000000000000000000000000000000000000000;;				names = append(names, token.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Fatalf("expected only 1 token, got %v", names)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := matchingSAToken.Name, tokens[0].Name; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected token %s, got %s", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
