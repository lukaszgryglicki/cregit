0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
154cb79702b6fc1117233b8825b6a51dac3c197a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package serviceaccount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/names"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/internalversion"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/internalversion"
0000000000000000000000000000000000000000;;		kubeapiserveradmission "k8s.io/kubernetes/pkg/kubeapiserver/admission"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/serviceaccount"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultServiceAccountName is the name of the default service account to set on pods which do not specify a service account
0000000000000000000000000000000000000000;;	const DefaultServiceAccountName = "default"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnforceMountableSecretsAnnotation is a default annotation that indicates that a service account should enforce mountable secrets.
0000000000000000000000000000000000000000;;	// The value must be true to have this annotation take effect
0000000000000000000000000000000000000000;;	const EnforceMountableSecretsAnnotation = "kubernetes.io/enforce-mountable-secrets"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultAPITokenMountPath is the path that ServiceAccountToken secrets are automounted to.
0000000000000000000000000000000000000000;;	// The token file would then be accessible at /var/run/secrets/kubernetes.io/serviceaccount
0000000000000000000000000000000000000000;;	const DefaultAPITokenMountPath = "/var/run/secrets/kubernetes.io/serviceaccount"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PluginName is the name of this admission plugin
0000000000000000000000000000000000000000;;	const PluginName = "ServiceAccount"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register registers a plugin
0000000000000000000000000000000000000000;;	func Register(plugins *admission.Plugins) {
0000000000000000000000000000000000000000;;		plugins.Register(PluginName, func(config io.Reader) (admission.Interface, error) {
0000000000000000000000000000000000000000;;			serviceAccountAdmission := NewServiceAccount()
0000000000000000000000000000000000000000;;			return serviceAccountAdmission, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = admission.Interface(&serviceAccount{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type serviceAccount struct {
0000000000000000000000000000000000000000;;		*admission.Handler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// LimitSecretReferences rejects pods that reference secrets their service accounts do not reference
0000000000000000000000000000000000000000;;		LimitSecretReferences bool
0000000000000000000000000000000000000000;;		// RequireAPIToken determines whether pod creation attempts are rejected if no API token exists for the pod's service account
0000000000000000000000000000000000000000;;		RequireAPIToken bool
0000000000000000000000000000000000000000;;		// MountServiceAccountToken creates Volume and VolumeMounts for the first referenced ServiceAccountToken for the pod's service account
0000000000000000000000000000000000000000;;		MountServiceAccountToken bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client internalclientset.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serviceAccountLister corelisters.ServiceAccountLister
0000000000000000000000000000000000000000;;		secretLister         corelisters.SecretLister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = kubeapiserveradmission.WantsInternalKubeClientSet(&serviceAccount{})
0000000000000000000000000000000000000000;;	var _ = kubeapiserveradmission.WantsInternalKubeInformerFactory(&serviceAccount{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServiceAccount returns an admission.Interface implementation which limits admission of Pod CREATE requests based on the pod's ServiceAccount:
0000000000000000000000000000000000000000;;	// 1. If the pod does not specify a ServiceAccount, it sets the pod's ServiceAccount to "default"
0000000000000000000000000000000000000000;;	// 2. It ensures the ServiceAccount referenced by the pod exists
0000000000000000000000000000000000000000;;	// 3. If LimitSecretReferences is true, it rejects the pod if the pod references Secret objects which the pod's ServiceAccount does not reference
0000000000000000000000000000000000000000;;	// 4. If the pod does not contain any ImagePullSecrets, the ImagePullSecrets of the service account are added.
0000000000000000000000000000000000000000;;	// 5. If MountServiceAccountToken is true, it adds a VolumeMount with the pod's ServiceAccount's api token secret to containers
0000000000000000000000000000000000000000;;	func NewServiceAccount() *serviceAccount {
0000000000000000000000000000000000000000;;		return &serviceAccount{
0000000000000000000000000000000000000000;;			Handler: admission.NewHandler(admission.Create),
0000000000000000000000000000000000000000;;			// TODO: enable this once we've swept secret usage to account for adding secret references to service accounts
0000000000000000000000000000000000000000;;			LimitSecretReferences: false,
0000000000000000000000000000000000000000;;			// Auto mount service account API token secrets
0000000000000000000000000000000000000000;;			MountServiceAccountToken: true,
0000000000000000000000000000000000000000;;			// Reject pod creation until a service account token is available
0000000000000000000000000000000000000000;;			RequireAPIToken: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *serviceAccount) SetInternalKubeClientSet(cl internalclientset.Interface) {
0000000000000000000000000000000000000000;;		a.client = cl
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *serviceAccount) SetInternalKubeInformerFactory(f informers.SharedInformerFactory) {
0000000000000000000000000000000000000000;;		serviceAccountInformer := f.Core().InternalVersion().ServiceAccounts()
0000000000000000000000000000000000000000;;		a.serviceAccountLister = serviceAccountInformer.Lister()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secretInformer := f.Core().InternalVersion().Secrets()
0000000000000000000000000000000000000000;;		a.secretLister = secretInformer.Lister()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a.SetReadyFunc(func() bool {
0000000000000000000000000000000000000000;;			return serviceAccountInformer.Informer().HasSynced() && secretInformer.Informer().HasSynced()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate ensures an authorizer is set.
0000000000000000000000000000000000000000;;	func (a *serviceAccount) Validate() error {
0000000000000000000000000000000000000000;;		if a.client == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing client")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.secretLister == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing secretLister")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.serviceAccountLister == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing serviceAccountLister")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *serviceAccount) Admit(a admission.Attributes) (err error) {
0000000000000000000000000000000000000000;;		if a.GetResource().GroupResource() != api.Resource("pods") {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj := a.GetObject()
0000000000000000000000000000000000000000;;		if obj == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod, ok := obj.(*api.Pod)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Don't modify the spec of mirror pods.
0000000000000000000000000000000000000000;;		// That makes the kubelet very angry and confused, and it immediately deletes the pod (because the spec doesn't match)
0000000000000000000000000000000000000000;;		// That said, don't allow mirror pods to reference ServiceAccounts or SecretVolumeSources either
0000000000000000000000000000000000000000;;		if _, isMirrorPod := pod.Annotations[api.MirrorPodAnnotationKey]; isMirrorPod {
0000000000000000000000000000000000000000;;			if len(pod.Spec.ServiceAccountName) != 0 {
0000000000000000000000000000000000000000;;				return admission.NewForbidden(a, fmt.Errorf("a mirror pod may not reference service accounts"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hasSecrets := false
0000000000000000000000000000000000000000;;			podutil.VisitPodSecretNames(pod, func(name string) bool {
0000000000000000000000000000000000000000;;				hasSecrets = true
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if hasSecrets {
0000000000000000000000000000000000000000;;				return admission.NewForbidden(a, fmt.Errorf("a mirror pod may not reference secrets"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set the default service account if needed
0000000000000000000000000000000000000000;;		if len(pod.Spec.ServiceAccountName) == 0 {
0000000000000000000000000000000000000000;;			pod.Spec.ServiceAccountName = DefaultServiceAccountName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure the referenced service account exists
0000000000000000000000000000000000000000;;		serviceAccount, err := s.getServiceAccount(a.GetNamespace(), pod.Spec.ServiceAccountName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return admission.NewForbidden(a, fmt.Errorf("error looking up service account %s/%s: %v", a.GetNamespace(), pod.Spec.ServiceAccountName, err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if serviceAccount == nil {
0000000000000000000000000000000000000000;;			// TODO: convert to a ServerTimeout error (or other error that sends a Retry-After header)
0000000000000000000000000000000000000000;;			return admission.NewForbidden(a, fmt.Errorf("service account %s/%s was not found, retry after the service account is created", a.GetNamespace(), pod.Spec.ServiceAccountName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.enforceMountableSecrets(serviceAccount) {
0000000000000000000000000000000000000000;;			if err := s.limitSecretReferences(serviceAccount, pod); err != nil {
0000000000000000000000000000000000000000;;				return admission.NewForbidden(a, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.MountServiceAccountToken && shouldAutomount(serviceAccount, pod) {
0000000000000000000000000000000000000000;;			if err := s.mountServiceAccountToken(serviceAccount, pod); err != nil {
0000000000000000000000000000000000000000;;				if _, ok := err.(errors.APIStatus); ok {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return admission.NewForbidden(a, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(pod.Spec.ImagePullSecrets) == 0 {
0000000000000000000000000000000000000000;;			pod.Spec.ImagePullSecrets = make([]api.LocalObjectReference, len(serviceAccount.ImagePullSecrets))
0000000000000000000000000000000000000000;;			copy(pod.Spec.ImagePullSecrets, serviceAccount.ImagePullSecrets)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func shouldAutomount(sa *api.ServiceAccount, pod *api.Pod) bool {
0000000000000000000000000000000000000000;;		// Pod's preference wins
0000000000000000000000000000000000000000;;		if pod.Spec.AutomountServiceAccountToken != nil {
0000000000000000000000000000000000000000;;			return *pod.Spec.AutomountServiceAccountToken
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Then service account's
0000000000000000000000000000000000000000;;		if sa.AutomountServiceAccountToken != nil {
0000000000000000000000000000000000000000;;			return *sa.AutomountServiceAccountToken
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Default to true for backwards compatibility
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// enforceMountableSecrets indicates whether mountable secrets should be enforced for a particular service account
0000000000000000000000000000000000000000;;	// A global setting of true will override any flag set on the individual service account
0000000000000000000000000000000000000000;;	func (s *serviceAccount) enforceMountableSecrets(serviceAccount *api.ServiceAccount) bool {
0000000000000000000000000000000000000000;;		if s.LimitSecretReferences {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if value, ok := serviceAccount.Annotations[EnforceMountableSecretsAnnotation]; ok {
0000000000000000000000000000000000000000;;			enforceMountableSecretCheck, _ := strconv.ParseBool(value)
0000000000000000000000000000000000000000;;			return enforceMountableSecretCheck
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getServiceAccount returns the ServiceAccount for the given namespace and name if it exists
0000000000000000000000000000000000000000;;	func (s *serviceAccount) getServiceAccount(namespace string, name string) (*api.ServiceAccount, error) {
0000000000000000000000000000000000000000;;		serviceAccount, err := s.serviceAccountLister.ServiceAccounts(namespace).Get(name)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return serviceAccount, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Could not find in cache, attempt to look up directly
0000000000000000000000000000000000000000;;		numAttempts := 1
0000000000000000000000000000000000000000;;		if name == DefaultServiceAccountName {
0000000000000000000000000000000000000000;;			// If this is the default serviceaccount, attempt more times, since it should be auto-created by the controller
0000000000000000000000000000000000000000;;			numAttempts = 10
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		retryInterval := time.Duration(rand.Int63n(100)+int64(100)) * time.Millisecond
0000000000000000000000000000000000000000;;		for i := 0; i < numAttempts; i++ {
0000000000000000000000000000000000000000;;			if i != 0 {
0000000000000000000000000000000000000000;;				time.Sleep(retryInterval)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			serviceAccount, err := s.client.Core().ServiceAccounts(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return serviceAccount, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getReferencedServiceAccountToken returns the name of the first referenced secret which is a ServiceAccountToken for the service account
0000000000000000000000000000000000000000;;	func (s *serviceAccount) getReferencedServiceAccountToken(serviceAccount *api.ServiceAccount) (string, error) {
0000000000000000000000000000000000000000;;		if len(serviceAccount.Secrets) == 0 {
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokens, err := s.getServiceAccountTokens(serviceAccount)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		accountTokens := sets.NewString()
0000000000000000000000000000000000000000;;		for _, token := range tokens {
0000000000000000000000000000000000000000;;			accountTokens.Insert(token.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Prefer secrets in the order they're referenced.
0000000000000000000000000000000000000000;;		for _, secret := range serviceAccount.Secrets {
0000000000000000000000000000000000000000;;			if accountTokens.Has(secret.Name) {
0000000000000000000000000000000000000000;;				return secret.Name, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getServiceAccountTokens returns all ServiceAccountToken secrets for the given ServiceAccount
0000000000000000000000000000000000000000;;	func (s *serviceAccount) getServiceAccountTokens(serviceAccount *api.ServiceAccount) ([]*api.Secret, error) {
0000000000000000000000000000000000000000;;		secrets, err := s.secretLister.Secrets(serviceAccount.Namespace).List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokens := []*api.Secret{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, secret := range secrets {
0000000000000000000000000000000000000000;;			if secret.Type != api.SecretTypeServiceAccountToken {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if serviceaccount.InternalIsServiceAccountToken(secret, serviceAccount) {
0000000000000000000000000000000000000000;;				tokens = append(tokens, secret)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tokens, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *serviceAccount) limitSecretReferences(serviceAccount *api.ServiceAccount, pod *api.Pod) error {
0000000000000000000000000000000000000000;;		// Ensure all secrets the pod references are allowed by the service account
0000000000000000000000000000000000000000;;		mountableSecrets := sets.NewString()
0000000000000000000000000000000000000000;;		for _, s := range serviceAccount.Secrets {
0000000000000000000000000000000000000000;;			mountableSecrets.Insert(s.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, volume := range pod.Spec.Volumes {
0000000000000000000000000000000000000000;;			source := volume.VolumeSource
0000000000000000000000000000000000000000;;			if source.Secret == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			secretName := source.Secret.SecretName
0000000000000000000000000000000000000000;;			if !mountableSecrets.Has(secretName) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("volume with secret.secretName=\"%s\" is not allowed because service account %s does not reference that secret", secretName, serviceAccount.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, container := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;			for _, env := range container.Env {
0000000000000000000000000000000000000000;;				if env.ValueFrom != nil && env.ValueFrom.SecretKeyRef != nil {
0000000000000000000000000000000000000000;;					if !mountableSecrets.Has(env.ValueFrom.SecretKeyRef.Name) {
0000000000000000000000000000000000000000;;						return fmt.Errorf("init container %s with envVar %s referencing secret.secretName=\"%s\" is not allowed because service account %s does not reference that secret", container.Name, env.Name, env.ValueFrom.SecretKeyRef.Name, serviceAccount.Name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, container := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			for _, env := range container.Env {
0000000000000000000000000000000000000000;;				if env.ValueFrom != nil && env.ValueFrom.SecretKeyRef != nil {
0000000000000000000000000000000000000000;;					if !mountableSecrets.Has(env.ValueFrom.SecretKeyRef.Name) {
0000000000000000000000000000000000000000;;						return fmt.Errorf("container %s with envVar %s referencing secret.secretName=\"%s\" is not allowed because service account %s does not reference that secret", container.Name, env.Name, env.ValueFrom.SecretKeyRef.Name, serviceAccount.Name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// limit pull secret references as well
0000000000000000000000000000000000000000;;		pullSecrets := sets.NewString()
0000000000000000000000000000000000000000;;		for _, s := range serviceAccount.ImagePullSecrets {
0000000000000000000000000000000000000000;;			pullSecrets.Insert(s.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, pullSecretRef := range pod.Spec.ImagePullSecrets {
0000000000000000000000000000000000000000;;			if !pullSecrets.Has(pullSecretRef.Name) {
0000000000000000000000000000000000000000;;				return fmt.Errorf(`imagePullSecrets[%d].name="%s" is not allowed because service account %s does not reference that imagePullSecret`, i, pullSecretRef.Name, serviceAccount.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *serviceAccount) mountServiceAccountToken(serviceAccount *api.ServiceAccount, pod *api.Pod) error {
0000000000000000000000000000000000000000;;		// Find the name of a referenced ServiceAccountToken secret we can mount
0000000000000000000000000000000000000000;;		serviceAccountToken, err := s.getReferencedServiceAccountToken(serviceAccount)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error looking up service account token for %s/%s: %v", serviceAccount.Namespace, serviceAccount.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(serviceAccountToken) == 0 {
0000000000000000000000000000000000000000;;			// We don't have an API token to mount, so return
0000000000000000000000000000000000000000;;			if s.RequireAPIToken {
0000000000000000000000000000000000000000;;				// If a token is required, this is considered an error
0000000000000000000000000000000000000000;;				err := errors.NewServerTimeout(schema.GroupResource{Resource: "serviceaccounts"}, "create pod", 1)
0000000000000000000000000000000000000000;;				err.ErrStatus.Message = fmt.Sprintf("No API token found for service account %q, retry after the token is automatically created and added to the service account", serviceAccount.Name)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find the volume and volume name for the ServiceAccountTokenSecret if it already exists
0000000000000000000000000000000000000000;;		tokenVolumeName := ""
0000000000000000000000000000000000000000;;		hasTokenVolume := false
0000000000000000000000000000000000000000;;		allVolumeNames := sets.NewString()
0000000000000000000000000000000000000000;;		for _, volume := range pod.Spec.Volumes {
0000000000000000000000000000000000000000;;			allVolumeNames.Insert(volume.Name)
0000000000000000000000000000000000000000;;			if volume.Secret != nil && volume.Secret.SecretName == serviceAccountToken {
0000000000000000000000000000000000000000;;				tokenVolumeName = volume.Name
0000000000000000000000000000000000000000;;				hasTokenVolume = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine a volume name for the ServiceAccountTokenSecret in case we need it
0000000000000000000000000000000000000000;;		if len(tokenVolumeName) == 0 {
0000000000000000000000000000000000000000;;			// Try naming the volume the same as the serviceAccountToken, and uniquify if needed
0000000000000000000000000000000000000000;;			tokenVolumeName = serviceAccountToken
0000000000000000000000000000000000000000;;			if allVolumeNames.Has(tokenVolumeName) {
0000000000000000000000000000000000000000;;				tokenVolumeName = names.SimpleNameGenerator.GenerateName(fmt.Sprintf("%s-", serviceAccountToken))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the prototypical VolumeMount
0000000000000000000000000000000000000000;;		volumeMount := api.VolumeMount{
0000000000000000000000000000000000000000;;			Name:      tokenVolumeName,
0000000000000000000000000000000000000000;;			ReadOnly:  true,
0000000000000000000000000000000000000000;;			MountPath: DefaultAPITokenMountPath,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure every container mounts the APISecret volume
0000000000000000000000000000000000000000;;		needsTokenVolume := false
0000000000000000000000000000000000000000;;		for i, container := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;			existingContainerMount := false
0000000000000000000000000000000000000000;;			for _, volumeMount := range container.VolumeMounts {
0000000000000000000000000000000000000000;;				// Existing mounts at the default mount path prevent mounting of the API token
0000000000000000000000000000000000000000;;				if volumeMount.MountPath == DefaultAPITokenMountPath {
0000000000000000000000000000000000000000;;					existingContainerMount = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !existingContainerMount {
0000000000000000000000000000000000000000;;				pod.Spec.InitContainers[i].VolumeMounts = append(pod.Spec.InitContainers[i].VolumeMounts, volumeMount)
0000000000000000000000000000000000000000;;				needsTokenVolume = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, container := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			existingContainerMount := false
0000000000000000000000000000000000000000;;			for _, volumeMount := range container.VolumeMounts {
0000000000000000000000000000000000000000;;				// Existing mounts at the default mount path prevent mounting of the API token
0000000000000000000000000000000000000000;;				if volumeMount.MountPath == DefaultAPITokenMountPath {
0000000000000000000000000000000000000000;;					existingContainerMount = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !existingContainerMount {
0000000000000000000000000000000000000000;;				pod.Spec.Containers[i].VolumeMounts = append(pod.Spec.Containers[i].VolumeMounts, volumeMount)
0000000000000000000000000000000000000000;;				needsTokenVolume = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the volume if a container needs it
0000000000000000000000000000000000000000;;		if !hasTokenVolume && needsTokenVolume {
0000000000000000000000000000000000000000;;			volume := api.Volume{
0000000000000000000000000000000000000000;;				Name: tokenVolumeName,
0000000000000000000000000000000000000000;;				VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;					Secret: &api.SecretVolumeSource{
0000000000000000000000000000000000000000;;						SecretName: serviceAccountToken,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod.Spec.Volumes = append(pod.Spec.Volumes, volume)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
