0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
7b839e94246ce301157d7720c7f7db67bf0dd9bb;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package noderestriction
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/auth/nodeidentifier"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		coreinternalversion "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/core/internalversion"
0000000000000000000000000000000000000000;;		kubeapiserveradmission "k8s.io/kubernetes/pkg/kubeapiserver/admission"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		PluginName = "NodeRestriction"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register registers a plugin
0000000000000000000000000000000000000000;;	func Register(plugins *admission.Plugins) {
0000000000000000000000000000000000000000;;		plugins.Register(PluginName, func(config io.Reader) (admission.Interface, error) {
0000000000000000000000000000000000000000;;			return NewPlugin(nodeidentifier.NewDefaultNodeIdentifier()), nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPlugin creates a new NodeRestriction admission plugin.
0000000000000000000000000000000000000000;;	// This plugin identifies requests from nodes
0000000000000000000000000000000000000000;;	func NewPlugin(nodeIdentifier nodeidentifier.NodeIdentifier) *nodePlugin {
0000000000000000000000000000000000000000;;		return &nodePlugin{
0000000000000000000000000000000000000000;;			Handler:        admission.NewHandler(admission.Create, admission.Update, admission.Delete),
0000000000000000000000000000000000000000;;			nodeIdentifier: nodeIdentifier,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nodePlugin holds state for and implements the admission plugin.
0000000000000000000000000000000000000000;;	type nodePlugin struct {
0000000000000000000000000000000000000000;;		*admission.Handler
0000000000000000000000000000000000000000;;		nodeIdentifier nodeidentifier.NodeIdentifier
0000000000000000000000000000000000000000;;		podsGetter     coreinternalversion.PodsGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		_ = admission.Interface(&nodePlugin{})
0000000000000000000000000000000000000000;;		_ = kubeapiserveradmission.WantsInternalKubeClientSet(&nodePlugin{})
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *nodePlugin) SetInternalKubeClientSet(f internalclientset.Interface) {
0000000000000000000000000000000000000000;;		p.podsGetter = f.Core()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *nodePlugin) Validate() error {
0000000000000000000000000000000000000000;;		if p.nodeIdentifier == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%s requires a node identifier", PluginName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.podsGetter == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%s requires a pod getter", PluginName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		podResource  = api.Resource("pods")
0000000000000000000000000000000000000000;;		nodeResource = api.Resource("nodes")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *nodePlugin) Admit(a admission.Attributes) error {
0000000000000000000000000000000000000000;;		nodeName, isNode := c.nodeIdentifier.NodeIdentity(a.GetUserInfo())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Our job is just to restrict nodes
0000000000000000000000000000000000000000;;		if !isNode {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(nodeName) == 0 {
0000000000000000000000000000000000000000;;			// disallow requests we cannot match to a particular node
0000000000000000000000000000000000000000;;			return admission.NewForbidden(a, fmt.Errorf("could not determine node from user %q", a.GetUserInfo().GetName()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch a.GetResource().GroupResource() {
0000000000000000000000000000000000000000;;		case podResource:
0000000000000000000000000000000000000000;;			switch a.GetSubresource() {
0000000000000000000000000000000000000000;;			case "":
0000000000000000000000000000000000000000;;				return c.admitPod(nodeName, a)
0000000000000000000000000000000000000000;;			case "status":
0000000000000000000000000000000000000000;;				return c.admitPodStatus(nodeName, a)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return admission.NewForbidden(a, fmt.Errorf("unexpected pod subresource %q", a.GetSubresource()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case nodeResource:
0000000000000000000000000000000000000000;;			return c.admitNode(nodeName, a)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *nodePlugin) admitPod(nodeName string, a admission.Attributes) error {
0000000000000000000000000000000000000000;;		switch a.GetOperation() {
0000000000000000000000000000000000000000;;		case admission.Create:
0000000000000000000000000000000000000000;;			// require a pod object
0000000000000000000000000000000000000000;;			pod, ok := a.GetObject().(*api.Pod)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return admission.NewForbidden(a, fmt.Errorf("unexpected type %T", a.GetObject()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// only allow nodes to create mirror pods
0000000000000000000000000000000000000000;;			if _, isMirrorPod := pod.Annotations[api.MirrorPodAnnotationKey]; !isMirrorPod {
0000000000000000000000000000000000000000;;				return admission.NewForbidden(a, fmt.Errorf("pod does not have %q annotation, node %q can only create mirror pods", api.MirrorPodAnnotationKey, nodeName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// only allow nodes to create a pod bound to itself
0000000000000000000000000000000000000000;;			if pod.Spec.NodeName != nodeName {
0000000000000000000000000000000000000000;;				return admission.NewForbidden(a, fmt.Errorf("node %q can only create pods with spec.nodeName set to itself", nodeName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// don't allow a node to create a pod that references any other API objects
0000000000000000000000000000000000000000;;			if pod.Spec.ServiceAccountName != "" {
0000000000000000000000000000000000000000;;				return admission.NewForbidden(a, fmt.Errorf("node %q can not create pods that reference a service account", nodeName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hasSecrets := false
0000000000000000000000000000000000000000;;			podutil.VisitPodSecretNames(pod, func(name string) (shouldContinue bool) { hasSecrets = true; return false })
0000000000000000000000000000000000000000;;			if hasSecrets {
0000000000000000000000000000000000000000;;				return admission.NewForbidden(a, fmt.Errorf("node %q can not create pods that reference secrets", nodeName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hasConfigMaps := false
0000000000000000000000000000000000000000;;			podutil.VisitPodConfigmapNames(pod, func(name string) (shouldContinue bool) { hasConfigMaps = true; return false })
0000000000000000000000000000000000000000;;			if hasConfigMaps {
0000000000000000000000000000000000000000;;				return admission.NewForbidden(a, fmt.Errorf("node %q can not create pods that reference configmaps", nodeName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, v := range pod.Spec.Volumes {
0000000000000000000000000000000000000000;;				if v.PersistentVolumeClaim != nil {
0000000000000000000000000000000000000000;;					return admission.NewForbidden(a, fmt.Errorf("node %q can not create pods that reference persistentvolumeclaims", nodeName))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case admission.Delete:
0000000000000000000000000000000000000000;;			// get the existing pod from the server cache
0000000000000000000000000000000000000000;;			existingPod, err := c.podsGetter.Pods(a.GetNamespace()).Get(a.GetName(), v1.GetOptions{ResourceVersion: "0"})
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				// wasn't found in the server cache, do a live lookup before forbidding
0000000000000000000000000000000000000000;;				existingPod, err = c.podsGetter.Pods(a.GetNamespace()).Get(a.GetName(), v1.GetOptions{})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return admission.NewForbidden(a, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// only allow a node to delete a pod bound to itself
0000000000000000000000000000000000000000;;			if existingPod.Spec.NodeName != nodeName {
0000000000000000000000000000000000000000;;				return admission.NewForbidden(a, fmt.Errorf("node %q can only delete pods with spec.nodeName set to itself", nodeName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return admission.NewForbidden(a, fmt.Errorf("unexpected operation %q", a.GetOperation()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *nodePlugin) admitPodStatus(nodeName string, a admission.Attributes) error {
0000000000000000000000000000000000000000;;		switch a.GetOperation() {
0000000000000000000000000000000000000000;;		case admission.Update:
0000000000000000000000000000000000000000;;			// require an existing pod
0000000000000000000000000000000000000000;;			pod, ok := a.GetOldObject().(*api.Pod)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return admission.NewForbidden(a, fmt.Errorf("unexpected type %T", a.GetObject()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// only allow a node to update status of a pod bound to itself
0000000000000000000000000000000000000000;;			if pod.Spec.NodeName != nodeName {
0000000000000000000000000000000000000000;;				return admission.NewForbidden(a, fmt.Errorf("node %q can only update pod status for pods with spec.nodeName set to itself", nodeName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return admission.NewForbidden(a, fmt.Errorf("unexpected operation %q", a.GetOperation()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *nodePlugin) admitNode(nodeName string, a admission.Attributes) error {
0000000000000000000000000000000000000000;;		requestedName := a.GetName()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// On create, get name from new object if unset in admission
0000000000000000000000000000000000000000;;		if len(requestedName) == 0 && a.GetOperation() == admission.Create {
0000000000000000000000000000000000000000;;			node, ok := a.GetObject().(*api.Node)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return admission.NewForbidden(a, fmt.Errorf("unexpected type %T", a.GetObject()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			requestedName = node.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if requestedName != nodeName {
0000000000000000000000000000000000000000;;			return admission.NewForbidden(a, fmt.Errorf("node %q cannot modify node %q", nodeName, requestedName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
