0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
7f21ae1b8b538e23a474bbcdec7748da6f5afe2f;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package webhook
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		registrationv1alpha1 "k8s.io/api/admissionregistration/v1alpha1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/admission/v1alpha1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/admission/install"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeHookSource struct {
0000000000000000000000000000000000000000;;		hooks []registrationv1alpha1.ExternalAdmissionHook
0000000000000000000000000000000000000000;;		err   error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeHookSource) ExternalAdmissionHooks() (*registrationv1alpha1.ExternalAdmissionHookConfiguration, error) {
0000000000000000000000000000000000000000;;		if f.err != nil {
0000000000000000000000000000000000000000;;			return nil, f.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &registrationv1alpha1.ExternalAdmissionHookConfiguration{ExternalAdmissionHooks: f.hooks}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeHookSource) Run(stopCh <-chan struct{}) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeServiceResolver struct {
0000000000000000000000000000000000000000;;		base url.URL
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f fakeServiceResolver) ResolveEndpoint(namespace, name string) (*url.URL, error) {
0000000000000000000000000000000000000000;;		if namespace == "failResolve" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't resolve service location")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u := f.base
0000000000000000000000000000000000000000;;		u.Path = name
0000000000000000000000000000000000000000;;		return &u, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmit tests that GenericAdmissionWebhook#Admit works as expected
0000000000000000000000000000000000000000;;	func TestAdmit(t *testing.T) {
0000000000000000000000000000000000000000;;		// Create the test webhook server
0000000000000000000000000000000000000000;;		sCert, err := tls.X509KeyPair(serverCert, serverKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rootCAs := x509.NewCertPool()
0000000000000000000000000000000000000000;;		rootCAs.AppendCertsFromPEM(caCert)
0000000000000000000000000000000000000000;;		testServer := httptest.NewUnstartedServer(http.HandlerFunc(webhookHandler))
0000000000000000000000000000000000000000;;		testServer.TLS = &tls.Config{
0000000000000000000000000000000000000000;;			Certificates: []tls.Certificate{sCert},
0000000000000000000000000000000000000000;;			ClientCAs:    rootCAs,
0000000000000000000000000000000000000000;;			ClientAuth:   tls.RequireAndVerifyClientCert,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testServer.StartTLS()
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		serverURL, err := url.ParseRequestURI(testServer.URL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("this should never happen? %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wh, err := NewGenericAdmissionWebhook()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wh.serviceResolver = fakeServiceResolver{*serverURL}
0000000000000000000000000000000000000000;;		wh.clientCert = clientCert
0000000000000000000000000000000000000000;;		wh.clientKey = clientKey
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up a test object for the call
0000000000000000000000000000000000000000;;		kind := api.Kind("Pod").WithVersion("v1")
0000000000000000000000000000000000000000;;		name := "my-pod"
0000000000000000000000000000000000000000;;		namespace := "webhook-test"
0000000000000000000000000000000000000000;;		object := api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"pod.name": name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldObject := api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: name, Namespace: namespace},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		operation := admission.Update
0000000000000000000000000000000000000000;;		resource := api.Resource("pods").WithVersion("v1")
0000000000000000000000000000000000000000;;		subResource := ""
0000000000000000000000000000000000000000;;		userInfo := user.DefaultInfo{
0000000000000000000000000000000000000000;;			Name: "webhook-test",
0000000000000000000000000000000000000000;;			UID:  "webhook-test",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type test struct {
0000000000000000000000000000000000000000;;			hookSource    fakeHookSource
0000000000000000000000000000000000000000;;			expectAllow   bool
0000000000000000000000000000000000000000;;			errorContains string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ccfg := func(result string) registrationv1alpha1.AdmissionHookClientConfig {
0000000000000000000000000000000000000000;;			return registrationv1alpha1.AdmissionHookClientConfig{
0000000000000000000000000000000000000000;;				Service: registrationv1alpha1.ServiceReference{
0000000000000000000000000000000000000000;;					Name: result,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				CABundle: caCert,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		matchEverythingRules := []registrationv1alpha1.RuleWithOperations{{
0000000000000000000000000000000000000000;;			Operations: []registrationv1alpha1.OperationType{registrationv1alpha1.OperationAll},
0000000000000000000000000000000000000000;;			Rule: registrationv1alpha1.Rule{
0000000000000000000000000000000000000000;;				APIGroups:   []string{"*"},
0000000000000000000000000000000000000000;;				APIVersions: []string{"*"},
0000000000000000000000000000000000000000;;				Resources:   []string{"*/*"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table := map[string]test{
0000000000000000000000000000000000000000;;			"no match": {
0000000000000000000000000000000000000000;;				hookSource: fakeHookSource{
0000000000000000000000000000000000000000;;					hooks: []registrationv1alpha1.ExternalAdmissionHook{{
0000000000000000000000000000000000000000;;						Name:         "nomatch",
0000000000000000000000000000000000000000;;						ClientConfig: ccfg("disallow"),
0000000000000000000000000000000000000000;;						Rules: []registrationv1alpha1.RuleWithOperations{{
0000000000000000000000000000000000000000;;							Operations: []registrationv1alpha1.OperationType{registrationv1alpha1.Create},
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectAllow: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"match & allow": {
0000000000000000000000000000000000000000;;				hookSource: fakeHookSource{
0000000000000000000000000000000000000000;;					hooks: []registrationv1alpha1.ExternalAdmissionHook{{
0000000000000000000000000000000000000000;;						Name:         "allow",
0000000000000000000000000000000000000000;;						ClientConfig: ccfg("allow"),
0000000000000000000000000000000000000000;;						Rules:        matchEverythingRules,
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectAllow: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"match & disallow": {
0000000000000000000000000000000000000000;;				hookSource: fakeHookSource{
0000000000000000000000000000000000000000;;					hooks: []registrationv1alpha1.ExternalAdmissionHook{{
0000000000000000000000000000000000000000;;						Name:         "disallow",
0000000000000000000000000000000000000000;;						ClientConfig: ccfg("disallow"),
0000000000000000000000000000000000000000;;						Rules:        matchEverythingRules,
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				errorContains: "without explanation",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"match & disallow ii": {
0000000000000000000000000000000000000000;;				hookSource: fakeHookSource{
0000000000000000000000000000000000000000;;					hooks: []registrationv1alpha1.ExternalAdmissionHook{{
0000000000000000000000000000000000000000;;						Name:         "disallowReason",
0000000000000000000000000000000000000000;;						ClientConfig: ccfg("disallowReason"),
0000000000000000000000000000000000000000;;						Rules:        matchEverythingRules,
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				errorContains: "you shall not pass",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"match & fail (but allow because fail open)": {
0000000000000000000000000000000000000000;;				hookSource: fakeHookSource{
0000000000000000000000000000000000000000;;					hooks: []registrationv1alpha1.ExternalAdmissionHook{{
0000000000000000000000000000000000000000;;						Name:         "internalErr A",
0000000000000000000000000000000000000000;;						ClientConfig: ccfg("internalErr"),
0000000000000000000000000000000000000000;;						Rules:        matchEverythingRules,
0000000000000000000000000000000000000000;;					}, {
0000000000000000000000000000000000000000;;						Name:         "invalidReq B",
0000000000000000000000000000000000000000;;						ClientConfig: ccfg("invalidReq"),
0000000000000000000000000000000000000000;;						Rules:        matchEverythingRules,
0000000000000000000000000000000000000000;;					}, {
0000000000000000000000000000000000000000;;						Name:         "invalidResp C",
0000000000000000000000000000000000000000;;						ClientConfig: ccfg("invalidResp"),
0000000000000000000000000000000000000000;;						Rules:        matchEverythingRules,
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectAllow: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, tt := range table {
0000000000000000000000000000000000000000;;			wh.hookSource = &tt.hookSource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = wh.Admit(admission.NewAttributesRecord(&object, &oldObject, kind, namespace, name, resource, subResource, operation, &userInfo))
0000000000000000000000000000000000000000;;			if tt.expectAllow != (err == nil) {
0000000000000000000000000000000000000000;;				t.Errorf("%q: expected allowed=%v, but got err=%v", name, tt.expectAllow, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// ErrWebhookRejected is not an error for our purposes
0000000000000000000000000000000000000000;;			if tt.errorContains != "" {
0000000000000000000000000000000000000000;;				if err == nil || !strings.Contains(err.Error(), tt.errorContains) {
0000000000000000000000000000000000000000;;					t.Errorf("%q: expected an error saying %q, but got %v", name, tt.errorContains, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func webhookHandler(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		fmt.Printf("got req: %v\n", r.URL.Path)
0000000000000000000000000000000000000000;;		switch r.URL.Path {
0000000000000000000000000000000000000000;;		case "/internalErr":
0000000000000000000000000000000000000000;;			http.Error(w, "webhook internal server error", http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case "/invalidReq":
0000000000000000000000000000000000000000;;			w.WriteHeader(http.StatusSwitchingProtocols)
0000000000000000000000000000000000000000;;			w.Write([]byte("webhook invalid request"))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case "/invalidResp":
0000000000000000000000000000000000000000;;			w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;			w.Write([]byte("webhook invalid response"))
0000000000000000000000000000000000000000;;		case "/disallow":
0000000000000000000000000000000000000000;;			w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;			json.NewEncoder(w).Encode(&v1alpha1.AdmissionReview{
0000000000000000000000000000000000000000;;				Status: v1alpha1.AdmissionReviewStatus{
0000000000000000000000000000000000000000;;					Allowed: false,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		case "/disallowReason":
0000000000000000000000000000000000000000;;			w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;			json.NewEncoder(w).Encode(&v1alpha1.AdmissionReview{
0000000000000000000000000000000000000000;;				Status: v1alpha1.AdmissionReviewStatus{
0000000000000000000000000000000000000000;;					Allowed: false,
0000000000000000000000000000000000000000;;					Result: &metav1.Status{
0000000000000000000000000000000000000000;;						Message: "you shall not pass",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		case "/allow":
0000000000000000000000000000000000000000;;			w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;			json.NewEncoder(w).Encode(&v1alpha1.AdmissionReview{
0000000000000000000000000000000000000000;;				Status: v1alpha1.AdmissionReviewStatus{
0000000000000000000000000000000000000000;;					Allowed: true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			http.NotFound(w, r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
