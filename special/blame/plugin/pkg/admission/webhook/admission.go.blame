0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
7f21ae1b8b538e23a474bbcdec7748da6f5afe2f;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package webhook delegates admission checks to dynamically configured webhooks.
0000000000000000000000000000000000000000;;	package webhook
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/admissionregistration/v1alpha1"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		admissionv1alpha1 "k8s.io/kubernetes/pkg/apis/admission/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		admissioninit "k8s.io/kubernetes/pkg/kubeapiserver/admission"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubeapiserver/admission/configuration"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// install the clientgo admission API for use with api registry
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/admission/install"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		groupVersions = []schema.GroupVersion{
0000000000000000000000000000000000000000;;			admissionv1alpha1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ErrCallingWebhook struct {
0000000000000000000000000000000000000000;;		WebhookName string
0000000000000000000000000000000000000000;;		Reason      error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *ErrCallingWebhook) Error() string {
0000000000000000000000000000000000000000;;		if e.Reason != nil {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("failed calling admission webhook %q: %v", e.WebhookName, e.Reason)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("failed calling admission webhook %q; no further details available", e.WebhookName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register registers a plugin
0000000000000000000000000000000000000000;;	func Register(plugins *admission.Plugins) {
0000000000000000000000000000000000000000;;		plugins.Register("GenericAdmissionWebhook", func(configFile io.Reader) (admission.Interface, error) {
0000000000000000000000000000000000000000;;			plugin, err := NewGenericAdmissionWebhook()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return plugin, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WebhookSource can list dynamic webhook plugins.
0000000000000000000000000000000000000000;;	type WebhookSource interface {
0000000000000000000000000000000000000000;;		Run(stopCh <-chan struct{})
0000000000000000000000000000000000000000;;		ExternalAdmissionHooks() (*v1alpha1.ExternalAdmissionHookConfiguration, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewGenericAdmissionWebhook returns a generic admission webhook plugin.
0000000000000000000000000000000000000000;;	func NewGenericAdmissionWebhook() (*GenericAdmissionWebhook, error) {
0000000000000000000000000000000000000000;;		return &GenericAdmissionWebhook{
0000000000000000000000000000000000000000;;			Handler: admission.NewHandler(
0000000000000000000000000000000000000000;;				admission.Connect,
0000000000000000000000000000000000000000;;				admission.Create,
0000000000000000000000000000000000000000;;				admission.Delete,
0000000000000000000000000000000000000000;;				admission.Update,
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;			negotiatedSerializer: serializer.NegotiatedSerializerWrapper(runtime.SerializerInfo{
0000000000000000000000000000000000000000;;				Serializer: api.Codecs.LegacyCodec(admissionv1alpha1.SchemeGroupVersion),
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenericAdmissionWebhook is an implementation of admission.Interface.
0000000000000000000000000000000000000000;;	type GenericAdmissionWebhook struct {
0000000000000000000000000000000000000000;;		*admission.Handler
0000000000000000000000000000000000000000;;		hookSource           WebhookSource
0000000000000000000000000000000000000000;;		serviceResolver      admissioninit.ServiceResolver
0000000000000000000000000000000000000000;;		negotiatedSerializer runtime.NegotiatedSerializer
0000000000000000000000000000000000000000;;		clientCert           []byte
0000000000000000000000000000000000000000;;		clientKey            []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		_ = admissioninit.WantsServiceResolver(&GenericAdmissionWebhook{})
0000000000000000000000000000000000000000;;		_ = admissioninit.WantsClientCert(&GenericAdmissionWebhook{})
0000000000000000000000000000000000000000;;		_ = admissioninit.WantsExternalKubeClientSet(&GenericAdmissionWebhook{})
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *GenericAdmissionWebhook) SetServiceResolver(sr admissioninit.ServiceResolver) {
0000000000000000000000000000000000000000;;		a.serviceResolver = sr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *GenericAdmissionWebhook) SetClientCert(cert, key []byte) {
0000000000000000000000000000000000000000;;		a.clientCert = cert
0000000000000000000000000000000000000000;;		a.clientKey = key
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *GenericAdmissionWebhook) SetExternalKubeClientSet(client clientset.Interface) {
0000000000000000000000000000000000000000;;		a.hookSource = configuration.NewExternalAdmissionHookConfigurationManager(client.Admissionregistration().ExternalAdmissionHookConfigurations())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *GenericAdmissionWebhook) Validate() error {
0000000000000000000000000000000000000000;;		if a.hookSource == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("the GenericAdmissionWebhook admission plugin requires a Kubernetes client to be provided")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go a.hookSource.Run(wait.NeverStop)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *GenericAdmissionWebhook) loadConfiguration(attr admission.Attributes) (*v1alpha1.ExternalAdmissionHookConfiguration, error) {
0000000000000000000000000000000000000000;;		hookConfig, err := a.hookSource.ExternalAdmissionHooks()
0000000000000000000000000000000000000000;;		// if ExternalAdmissionHook configuration is disabled, fail open
0000000000000000000000000000000000000000;;		if err == configuration.ErrDisabled {
0000000000000000000000000000000000000000;;			return &v1alpha1.ExternalAdmissionHookConfiguration{}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			e := apierrors.NewServerTimeout(attr.GetResource().GroupResource(), string(attr.GetOperation()), 1)
0000000000000000000000000000000000000000;;			e.ErrStatus.Message = fmt.Sprintf("Unable to refresh the ExternalAdmissionHook configuration: %v", err)
0000000000000000000000000000000000000000;;			e.ErrStatus.Reason = "LoadingConfiguration"
0000000000000000000000000000000000000000;;			e.ErrStatus.Details.Causes = append(e.ErrStatus.Details.Causes, metav1.StatusCause{
0000000000000000000000000000000000000000;;				Type:    "ExternalAdmissionHookConfigurationFailure",
0000000000000000000000000000000000000000;;				Message: "An error has occurred while refreshing the externalAdmissionHook configuration, no resources can be created/updated/deleted/connected until a refresh succeeds.",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			return nil, e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hookConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Admit makes an admission decision based on the request attributes.
0000000000000000000000000000000000000000;;	func (a *GenericAdmissionWebhook) Admit(attr admission.Attributes) error {
0000000000000000000000000000000000000000;;		hookConfig, err := a.loadConfiguration(attr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hooks := hookConfig.ExternalAdmissionHooks
0000000000000000000000000000000000000000;;		ctx := context.TODO()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errCh := make(chan error, len(hooks))
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(len(hooks))
0000000000000000000000000000000000000000;;		for i := range hooks {
0000000000000000000000000000000000000000;;			go func(hook *v1alpha1.ExternalAdmissionHook) {
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;				if err := a.callHook(ctx, hook, attr); err == nil {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				} else if callErr, ok := err.(*ErrCallingWebhook); ok {
0000000000000000000000000000000000000000;;					glog.Warningf("Failed calling webhook %v: %v", hook.Name, callErr)
0000000000000000000000000000000000000000;;					utilruntime.HandleError(callErr)
0000000000000000000000000000000000000000;;					// Since we are failing open to begin with, we do not send an error down the channel
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					glog.Warningf("rejected by webhook %v %t: %v", hook.Name, err, err)
0000000000000000000000000000000000000000;;					errCh <- err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}(&hooks[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		close(errCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var errs []error
0000000000000000000000000000000000000000;;		for e := range errCh {
0000000000000000000000000000000000000000;;			errs = append(errs, e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(errs) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(errs) > 1 {
0000000000000000000000000000000000000000;;			for i := 1; i < len(errs); i++ {
0000000000000000000000000000000000000000;;				// TODO: merge status errors; until then, just return the first one.
0000000000000000000000000000000000000000;;				utilruntime.HandleError(errs[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errs[0]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *GenericAdmissionWebhook) callHook(ctx context.Context, h *v1alpha1.ExternalAdmissionHook, attr admission.Attributes) error {
0000000000000000000000000000000000000000;;		matches := false
0000000000000000000000000000000000000000;;		for _, r := range h.Rules {
0000000000000000000000000000000000000000;;			m := RuleMatcher{Rule: r, Attr: attr}
0000000000000000000000000000000000000000;;			if m.Matches() {
0000000000000000000000000000000000000000;;				matches = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !matches {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make the webhook request
0000000000000000000000000000000000000000;;		request := admissionv1alpha1.NewAdmissionReview(attr)
0000000000000000000000000000000000000000;;		client, err := a.hookClient(h)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return &ErrCallingWebhook{WebhookName: h.Name, Reason: err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := client.Post().Context(ctx).Body(&request).Do().Into(&request); err != nil {
0000000000000000000000000000000000000000;;			return &ErrCallingWebhook{WebhookName: h.Name, Reason: err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if request.Status.Allowed {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if request.Status.Result == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("admission webhook %q denied the request without explanation", h.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &apierrors.StatusError{
0000000000000000000000000000000000000000;;			ErrStatus: *request.Status.Result,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *GenericAdmissionWebhook) hookClient(h *v1alpha1.ExternalAdmissionHook) (*rest.RESTClient, error) {
0000000000000000000000000000000000000000;;		u, err := a.serviceResolver.ResolveEndpoint(h.ClientConfig.Service.Namespace, h.ClientConfig.Service.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: cache these instead of constructing one each time
0000000000000000000000000000000000000000;;		cfg := &rest.Config{
0000000000000000000000000000000000000000;;			Host:    u.Host,
0000000000000000000000000000000000000000;;			APIPath: u.Path,
0000000000000000000000000000000000000000;;			TLSClientConfig: rest.TLSClientConfig{
0000000000000000000000000000000000000000;;				CAData:   h.ClientConfig.CABundle,
0000000000000000000000000000000000000000;;				CertData: a.clientCert,
0000000000000000000000000000000000000000;;				KeyData:  a.clientKey,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			UserAgent: "kube-apiserver-admission",
0000000000000000000000000000000000000000;;			Timeout:   30 * time.Second,
0000000000000000000000000000000000000000;;			ContentConfig: rest.ContentConfig{
0000000000000000000000000000000000000000;;				NegotiatedSerializer: a.negotiatedSerializer,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rest.UnversionedRESTClientFor(cfg)
0000000000000000000000000000000000000000;;	}
