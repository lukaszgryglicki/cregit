0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
7f21ae1b8b538e23a474bbcdec7748da6f5afe2f;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package webhook
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		adreg "k8s.io/api/admissionregistration/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ruleTest struct {
0000000000000000000000000000000000000000;;		rule    adreg.RuleWithOperations
0000000000000000000000000000000000000000;;		match   []admission.Attributes
0000000000000000000000000000000000000000;;		noMatch []admission.Attributes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	type tests map[string]ruleTest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func a(group, version, resource, subresource, name string, operation admission.Operation) admission.Attributes {
0000000000000000000000000000000000000000;;		return admission.NewAttributesRecord(
0000000000000000000000000000000000000000;;			nil, nil,
0000000000000000000000000000000000000000;;			schema.GroupVersionKind{Group: group, Version: version, Kind: "k" + resource},
0000000000000000000000000000000000000000;;			"ns", name,
0000000000000000000000000000000000000000;;			schema.GroupVersionResource{Group: group, Version: version, Resource: resource}, subresource,
0000000000000000000000000000000000000000;;			operation,
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func attrList(a ...admission.Attributes) []admission.Attributes {
0000000000000000000000000000000000000000;;		return a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGroup(t *testing.T) {
0000000000000000000000000000000000000000;;		table := tests{
0000000000000000000000000000000000000000;;			"wildcard": {
0000000000000000000000000000000000000000;;				rule: adreg.RuleWithOperations{
0000000000000000000000000000000000000000;;					Rule: adreg.Rule{
0000000000000000000000000000000000000000;;						APIGroups: []string{"*"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				match: attrList(
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Create),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"exact": {
0000000000000000000000000000000000000000;;				rule: adreg.RuleWithOperations{
0000000000000000000000000000000000000000;;					Rule: adreg.Rule{
0000000000000000000000000000000000000000;;						APIGroups: []string{"g1", "g2"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				match: attrList(
0000000000000000000000000000000000000000;;					a("g1", "v", "r", "", "name", admission.Create),
0000000000000000000000000000000000000000;;					a("g2", "v2", "r3", "", "name", admission.Create),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;				noMatch: attrList(
0000000000000000000000000000000000000000;;					a("g3", "v", "r", "", "name", admission.Create),
0000000000000000000000000000000000000000;;					a("g4", "v", "r", "", "name", admission.Create),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, tt := range table {
0000000000000000000000000000000000000000;;			for _, m := range tt.match {
0000000000000000000000000000000000000000;;				r := RuleMatcher{tt.rule, m}
0000000000000000000000000000000000000000;;				if !r.group() {
0000000000000000000000000000000000000000;;					t.Errorf("%v: expected match %#v", name, m)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, m := range tt.noMatch {
0000000000000000000000000000000000000000;;				r := RuleMatcher{tt.rule, m}
0000000000000000000000000000000000000000;;				if r.group() {
0000000000000000000000000000000000000000;;					t.Errorf("%v: expected no match %#v", name, m)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestVersion(t *testing.T) {
0000000000000000000000000000000000000000;;		table := tests{
0000000000000000000000000000000000000000;;			"wildcard": {
0000000000000000000000000000000000000000;;				rule: adreg.RuleWithOperations{
0000000000000000000000000000000000000000;;					Rule: adreg.Rule{
0000000000000000000000000000000000000000;;						APIVersions: []string{"*"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				match: attrList(
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Create),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"exact": {
0000000000000000000000000000000000000000;;				rule: adreg.RuleWithOperations{
0000000000000000000000000000000000000000;;					Rule: adreg.Rule{
0000000000000000000000000000000000000000;;						APIVersions: []string{"v1", "v2"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				match: attrList(
0000000000000000000000000000000000000000;;					a("g1", "v1", "r", "", "name", admission.Create),
0000000000000000000000000000000000000000;;					a("g2", "v2", "r", "", "name", admission.Create),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;				noMatch: attrList(
0000000000000000000000000000000000000000;;					a("g1", "v3", "r", "", "name", admission.Create),
0000000000000000000000000000000000000000;;					a("g2", "v4", "r", "", "name", admission.Create),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for name, tt := range table {
0000000000000000000000000000000000000000;;			for _, m := range tt.match {
0000000000000000000000000000000000000000;;				r := RuleMatcher{tt.rule, m}
0000000000000000000000000000000000000000;;				if !r.version() {
0000000000000000000000000000000000000000;;					t.Errorf("%v: expected match %#v", name, m)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, m := range tt.noMatch {
0000000000000000000000000000000000000000;;				r := RuleMatcher{tt.rule, m}
0000000000000000000000000000000000000000;;				if r.version() {
0000000000000000000000000000000000000000;;					t.Errorf("%v: expected no match %#v", name, m)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOperation(t *testing.T) {
0000000000000000000000000000000000000000;;		table := tests{
0000000000000000000000000000000000000000;;			"wildcard": {
0000000000000000000000000000000000000000;;				rule: adreg.RuleWithOperations{Operations: []adreg.OperationType{adreg.OperationAll}},
0000000000000000000000000000000000000000;;				match: attrList(
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Create),
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Update),
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Delete),
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Connect),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"create": {
0000000000000000000000000000000000000000;;				rule: adreg.RuleWithOperations{Operations: []adreg.OperationType{adreg.Create}},
0000000000000000000000000000000000000000;;				match: attrList(
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Create),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;				noMatch: attrList(
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Update),
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Delete),
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Connect),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"update": {
0000000000000000000000000000000000000000;;				rule: adreg.RuleWithOperations{Operations: []adreg.OperationType{adreg.Update}},
0000000000000000000000000000000000000000;;				match: attrList(
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Update),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;				noMatch: attrList(
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Create),
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Delete),
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Connect),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"delete": {
0000000000000000000000000000000000000000;;				rule: adreg.RuleWithOperations{Operations: []adreg.OperationType{adreg.Delete}},
0000000000000000000000000000000000000000;;				match: attrList(
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Delete),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;				noMatch: attrList(
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Create),
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Update),
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Connect),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"connect": {
0000000000000000000000000000000000000000;;				rule: adreg.RuleWithOperations{Operations: []adreg.OperationType{adreg.Connect}},
0000000000000000000000000000000000000000;;				match: attrList(
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Connect),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;				noMatch: attrList(
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Create),
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Update),
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Delete),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"multiple": {
0000000000000000000000000000000000000000;;				rule: adreg.RuleWithOperations{Operations: []adreg.OperationType{adreg.Update, adreg.Delete}},
0000000000000000000000000000000000000000;;				match: attrList(
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Update),
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Delete),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;				noMatch: attrList(
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Create),
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Connect),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for name, tt := range table {
0000000000000000000000000000000000000000;;			for _, m := range tt.match {
0000000000000000000000000000000000000000;;				r := RuleMatcher{tt.rule, m}
0000000000000000000000000000000000000000;;				if !r.operation() {
0000000000000000000000000000000000000000;;					t.Errorf("%v: expected match %#v", name, m)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, m := range tt.noMatch {
0000000000000000000000000000000000000000;;				r := RuleMatcher{tt.rule, m}
0000000000000000000000000000000000000000;;				if r.operation() {
0000000000000000000000000000000000000000;;					t.Errorf("%v: expected no match %#v", name, m)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestResource(t *testing.T) {
0000000000000000000000000000000000000000;;		table := tests{
0000000000000000000000000000000000000000;;			"no subresources": {
0000000000000000000000000000000000000000;;				rule: adreg.RuleWithOperations{
0000000000000000000000000000000000000000;;					Rule: adreg.Rule{
0000000000000000000000000000000000000000;;						Resources: []string{"*"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				match: attrList(
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Create),
0000000000000000000000000000000000000000;;					a("2", "v", "r2", "", "name", admission.Create),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;				noMatch: attrList(
0000000000000000000000000000000000000000;;					a("g", "v", "r", "exec", "name", admission.Create),
0000000000000000000000000000000000000000;;					a("2", "v", "r2", "proxy", "name", admission.Create),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"r & subresources": {
0000000000000000000000000000000000000000;;				rule: adreg.RuleWithOperations{
0000000000000000000000000000000000000000;;					Rule: adreg.Rule{
0000000000000000000000000000000000000000;;						Resources: []string{"r/*"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				match: attrList(
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Create),
0000000000000000000000000000000000000000;;					a("g", "v", "r", "exec", "name", admission.Create),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;				noMatch: attrList(
0000000000000000000000000000000000000000;;					a("2", "v", "r2", "", "name", admission.Create),
0000000000000000000000000000000000000000;;					a("2", "v", "r2", "proxy", "name", admission.Create),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"r & subresources or r2": {
0000000000000000000000000000000000000000;;				rule: adreg.RuleWithOperations{
0000000000000000000000000000000000000000;;					Rule: adreg.Rule{
0000000000000000000000000000000000000000;;						Resources: []string{"r/*", "r2"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				match: attrList(
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Create),
0000000000000000000000000000000000000000;;					a("g", "v", "r", "exec", "name", admission.Create),
0000000000000000000000000000000000000000;;					a("2", "v", "r2", "", "name", admission.Create),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;				noMatch: attrList(
0000000000000000000000000000000000000000;;					a("2", "v", "r2", "proxy", "name", admission.Create),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"proxy or exec": {
0000000000000000000000000000000000000000;;				rule: adreg.RuleWithOperations{
0000000000000000000000000000000000000000;;					Rule: adreg.Rule{
0000000000000000000000000000000000000000;;						Resources: []string{"*/proxy", "*/exec"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				match: attrList(
0000000000000000000000000000000000000000;;					a("g", "v", "r", "exec", "name", admission.Create),
0000000000000000000000000000000000000000;;					a("2", "v", "r2", "proxy", "name", admission.Create),
0000000000000000000000000000000000000000;;					a("2", "v", "r3", "proxy", "name", admission.Create),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;				noMatch: attrList(
0000000000000000000000000000000000000000;;					a("g", "v", "r", "", "name", admission.Create),
0000000000000000000000000000000000000000;;					a("2", "v", "r2", "", "name", admission.Create),
0000000000000000000000000000000000000000;;					a("2", "v", "r4", "scale", "name", admission.Create),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for name, tt := range table {
0000000000000000000000000000000000000000;;			for _, m := range tt.match {
0000000000000000000000000000000000000000;;				r := RuleMatcher{tt.rule, m}
0000000000000000000000000000000000000000;;				if !r.resource() {
0000000000000000000000000000000000000000;;					t.Errorf("%v: expected match %#v", name, m)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, m := range tt.noMatch {
0000000000000000000000000000000000000000;;				r := RuleMatcher{tt.rule, m}
0000000000000000000000000000000000000000;;				if r.resource() {
0000000000000000000000000000000000000000;;					t.Errorf("%v: expected no match %#v", name, m)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
