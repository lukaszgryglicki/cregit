0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
3b06cf288046874117f039532276be415780809c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package podtolerationrestriction
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		k8s_api_v1 "k8s.io/kubernetes/pkg/api/v1"
0000000000000000000000000000000000000000;;		clientset "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/internalversion"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/internalversion"
0000000000000000000000000000000000000000;;		kubeapiserveradmission "k8s.io/kubernetes/pkg/kubeapiserver/admission"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/tolerations"
0000000000000000000000000000000000000000;;		pluginapi "k8s.io/kubernetes/plugin/pkg/admission/podtolerationrestriction/apis/podtolerationrestriction"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register registers a plugin
0000000000000000000000000000000000000000;;	func Register(plugins *admission.Plugins) {
0000000000000000000000000000000000000000;;		plugins.Register("PodTolerationRestriction", func(config io.Reader) (admission.Interface, error) {
0000000000000000000000000000000000000000;;			pluginConfig, err := loadConfiguration(config)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return NewPodTolerationsPlugin(pluginConfig), nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The annotation keys for default and whitelist of tolerations
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		NSDefaultTolerations string = "scheduler.alpha.kubernetes.io/defaultTolerations"
0000000000000000000000000000000000000000;;		NSWLTolerations      string = "scheduler.alpha.kubernetes.io/tolerationsWhitelist"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = kubeapiserveradmission.WantsInternalKubeInformerFactory(&podTolerationsPlugin{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type podTolerationsPlugin struct {
0000000000000000000000000000000000000000;;		*admission.Handler
0000000000000000000000000000000000000000;;		client          clientset.Interface
0000000000000000000000000000000000000000;;		namespaceLister corelisters.NamespaceLister
0000000000000000000000000000000000000000;;		pluginConfig    *pluginapi.Configuration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This plugin first verifies any conflict between a pod's tolerations and
0000000000000000000000000000000000000000;;	// its namespace's tolerations, and rejects the pod if there's a conflict.
0000000000000000000000000000000000000000;;	// If there's no conflict, the pod's tolerations are merged with its namespace's
0000000000000000000000000000000000000000;;	// toleration. Resulting pod's tolerations are verified against its namespace's
0000000000000000000000000000000000000000;;	// whitelist of tolerations. If the verification is successful, the pod is admitted
0000000000000000000000000000000000000000;;	// otherwise rejected. If a namespace does not have associated default or whitelist
0000000000000000000000000000000000000000;;	// of tolerations, then cluster level default or whitelist of tolerations are used
0000000000000000000000000000000000000000;;	// instead if specified. Tolerations to a namespace are assigned via
0000000000000000000000000000000000000000;;	// scheduler.alpha.kubernetes.io/defaultTolerations and scheduler.alpha.kubernetes.io/tolerationsWhitelist
0000000000000000000000000000000000000000;;	// annotations keys.
0000000000000000000000000000000000000000;;	func (p *podTolerationsPlugin) Admit(a admission.Attributes) error {
0000000000000000000000000000000000000000;;		resource := a.GetResource().GroupResource()
0000000000000000000000000000000000000000;;		if resource != api.Resource("pods") {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.GetSubresource() != "" {
0000000000000000000000000000000000000000;;			// only run the checks below on pods proper and not subresources
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj := a.GetObject()
0000000000000000000000000000000000000000;;		pod, ok := obj.(*api.Pod)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.Errorf("expected pod but got %s", a.GetKind().Kind)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !p.WaitForReady() {
0000000000000000000000000000000000000000;;			return admission.NewForbidden(a, fmt.Errorf("not yet ready to handle request"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nsName := a.GetNamespace()
0000000000000000000000000000000000000000;;		namespace, err := p.namespaceLister.Get(nsName)
0000000000000000000000000000000000000000;;		if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			// in case of latency in our caches, make a call direct to storage to verify that it truly exists or not
0000000000000000000000000000000000000000;;			namespace, err = p.client.Core().Namespaces().Get(nsName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return errors.NewInternalError(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			return errors.NewInternalError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var finalTolerations []api.Toleration
0000000000000000000000000000000000000000;;		if a.GetOperation() == admission.Create {
0000000000000000000000000000000000000000;;			ts, err := p.getNamespaceDefaultTolerations(namespace)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If the namespace has not specified its default tolerations,
0000000000000000000000000000000000000000;;			// fall back to cluster's default tolerations.
0000000000000000000000000000000000000000;;			if len(ts) == 0 {
0000000000000000000000000000000000000000;;				ts = p.pluginConfig.Default
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(ts) > 0 {
0000000000000000000000000000000000000000;;				if len(pod.Spec.Tolerations) > 0 {
0000000000000000000000000000000000000000;;					if tolerations.IsConflict(ts, pod.Spec.Tolerations) {
0000000000000000000000000000000000000000;;						return fmt.Errorf("namespace tolerations and pod tolerations conflict")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// modified pod tolerations = namespace tolerations + current pod tolerations
0000000000000000000000000000000000000000;;					finalTolerations = tolerations.MergeTolerations(ts, pod.Spec.Tolerations)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					finalTolerations = ts
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				finalTolerations = pod.Spec.Tolerations
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			finalTolerations = pod.Spec.Tolerations
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// whitelist verification.
0000000000000000000000000000000000000000;;		if len(finalTolerations) > 0 {
0000000000000000000000000000000000000000;;			whitelist, err := p.getNamespaceTolerationsWhitelist(namespace)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If the namespace has not specified its tolerations whitelist,
0000000000000000000000000000000000000000;;			// fall back to cluster's whitelist of tolerations.
0000000000000000000000000000000000000000;;			if len(whitelist) == 0 {
0000000000000000000000000000000000000000;;				whitelist = p.pluginConfig.Whitelist
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(whitelist) > 0 {
0000000000000000000000000000000000000000;;				// check if the merged pod tolerations satisfy its namespace whitelist
0000000000000000000000000000000000000000;;				if !tolerations.VerifyAgainstWhitelist(finalTolerations, whitelist) {
0000000000000000000000000000000000000000;;					return fmt.Errorf("pod tolerations (possibly merged with namespace default tolerations) conflict with its namespace whitelist")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod.Spec.Tolerations = finalTolerations
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewPodTolerationsPlugin(pluginConfig *pluginapi.Configuration) *podTolerationsPlugin {
0000000000000000000000000000000000000000;;		return &podTolerationsPlugin{
0000000000000000000000000000000000000000;;			Handler:      admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			pluginConfig: pluginConfig,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *podTolerationsPlugin) SetInternalKubeClientSet(client clientset.Interface) {
0000000000000000000000000000000000000000;;		a.client = client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *podTolerationsPlugin) SetInternalKubeInformerFactory(f informers.SharedInformerFactory) {
0000000000000000000000000000000000000000;;		namespaceInformer := f.Core().InternalVersion().Namespaces()
0000000000000000000000000000000000000000;;		p.namespaceLister = namespaceInformer.Lister()
0000000000000000000000000000000000000000;;		p.SetReadyFunc(namespaceInformer.Informer().HasSynced)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *podTolerationsPlugin) Validate() error {
0000000000000000000000000000000000000000;;		if p.namespaceLister == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing namespaceLister")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.client == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing client")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *podTolerationsPlugin) getNamespaceDefaultTolerations(ns *api.Namespace) ([]api.Toleration, error) {
0000000000000000000000000000000000000000;;		return extractNSTolerations(ns, NSDefaultTolerations)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *podTolerationsPlugin) getNamespaceTolerationsWhitelist(ns *api.Namespace) ([]api.Toleration, error) {
0000000000000000000000000000000000000000;;		return extractNSTolerations(ns, NSWLTolerations)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractNSTolerations(ns *api.Namespace, key string) ([]api.Toleration, error) {
0000000000000000000000000000000000000000;;		var v1Tolerations []v1.Toleration
0000000000000000000000000000000000000000;;		if len(ns.Annotations) > 0 && ns.Annotations[key] != "" {
0000000000000000000000000000000000000000;;			err := json.Unmarshal([]byte(ns.Annotations[key]), &v1Tolerations)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ts := make([]api.Toleration, len(v1Tolerations))
0000000000000000000000000000000000000000;;		for i := range v1Tolerations {
0000000000000000000000000000000000000000;;			if err := k8s_api_v1.Convert_v1_Toleration_To_api_Toleration(&v1Tolerations[i], &ts[i], nil); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ts, nil
0000000000000000000000000000000000000000;;	}
