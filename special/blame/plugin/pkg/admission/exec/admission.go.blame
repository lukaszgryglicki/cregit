0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
82b46ba1eb31edbbff37154756af83f8291996ab;plugin/pkg/admission/exec/denyprivileged/admission.go[plugin/pkg/admission/exec/denyprivileged/admission.go][plugin/pkg/admission/exec/admission.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package exec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		kubeapiserveradmission "k8s.io/kubernetes/pkg/kubeapiserver/admission"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register registers a plugin
0000000000000000000000000000000000000000;;	func Register(plugins *admission.Plugins) {
0000000000000000000000000000000000000000;;		plugins.Register("DenyEscalatingExec", func(config io.Reader) (admission.Interface, error) {
0000000000000000000000000000000000000000;;			return NewDenyEscalatingExec(), nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This is for legacy support of the DenyExecOnPrivileged admission controller.  Most
0000000000000000000000000000000000000000;;		// of the time DenyEscalatingExec should be preferred.
0000000000000000000000000000000000000000;;		plugins.Register("DenyExecOnPrivileged", func(config io.Reader) (admission.Interface, error) {
0000000000000000000000000000000000000000;;			return NewDenyExecOnPrivileged(), nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// denyExec is an implementation of admission.Interface which says no to a pod/exec on
0000000000000000000000000000000000000000;;	// a pod using host based configurations.
0000000000000000000000000000000000000000;;	type denyExec struct {
0000000000000000000000000000000000000000;;		*admission.Handler
0000000000000000000000000000000000000000;;		client internalclientset.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// these flags control which items will be checked to deny exec/attach
0000000000000000000000000000000000000000;;		hostIPC    bool
0000000000000000000000000000000000000000;;		hostPID    bool
0000000000000000000000000000000000000000;;		privileged bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = kubeapiserveradmission.WantsInternalKubeClientSet(&denyExec{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDenyEscalatingExec creates a new admission controller that denies an exec operation on a pod
0000000000000000000000000000000000000000;;	// using host based configurations.
0000000000000000000000000000000000000000;;	func NewDenyEscalatingExec() admission.Interface {
0000000000000000000000000000000000000000;;		return &denyExec{
0000000000000000000000000000000000000000;;			Handler:    admission.NewHandler(admission.Connect),
0000000000000000000000000000000000000000;;			hostIPC:    true,
0000000000000000000000000000000000000000;;			hostPID:    true,
0000000000000000000000000000000000000000;;			privileged: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDenyExecOnPrivileged creates a new admission controller that is only checking the privileged
0000000000000000000000000000000000000000;;	// option.  This is for legacy support of the DenyExecOnPrivileged admission controller.  Most
0000000000000000000000000000000000000000;;	// of the time NewDenyEscalatingExec should be preferred.
0000000000000000000000000000000000000000;;	func NewDenyExecOnPrivileged() admission.Interface {
0000000000000000000000000000000000000000;;		return &denyExec{
0000000000000000000000000000000000000000;;			Handler:    admission.NewHandler(admission.Connect),
0000000000000000000000000000000000000000;;			hostIPC:    false,
0000000000000000000000000000000000000000;;			hostPID:    false,
0000000000000000000000000000000000000000;;			privileged: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *denyExec) Admit(a admission.Attributes) (err error) {
0000000000000000000000000000000000000000;;		connectRequest, ok := a.GetObject().(*rest.ConnectRequest)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.NewBadRequest("a connect request was received, but could not convert the request object.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Only handle exec or attach requests on pods
0000000000000000000000000000000000000000;;		if connectRequest.ResourcePath != "pods/exec" && connectRequest.ResourcePath != "pods/attach" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod, err := d.client.Core().Pods(a.GetNamespace()).Get(connectRequest.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return admission.NewForbidden(a, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if d.hostPID && pod.Spec.SecurityContext != nil && pod.Spec.SecurityContext.HostPID {
0000000000000000000000000000000000000000;;			return admission.NewForbidden(a, fmt.Errorf("cannot exec into or attach to a container using host pid"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if d.hostIPC && pod.Spec.SecurityContext != nil && pod.Spec.SecurityContext.HostIPC {
0000000000000000000000000000000000000000;;			return admission.NewForbidden(a, fmt.Errorf("cannot exec into or attach to a container using host ipc"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if d.privileged && isPrivileged(pod) {
0000000000000000000000000000000000000000;;			return admission.NewForbidden(a, fmt.Errorf("cannot exec into or attach to a privileged container"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isPrivileged will return true a pod has any privileged containers
0000000000000000000000000000000000000000;;	func isPrivileged(pod *api.Pod) bool {
0000000000000000000000000000000000000000;;		for _, c := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;			if c.SecurityContext == nil || c.SecurityContext.Privileged == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if *c.SecurityContext.Privileged {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			if c.SecurityContext == nil || c.SecurityContext.Privileged == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if *c.SecurityContext.Privileged {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *denyExec) SetInternalKubeClientSet(client internalclientset.Interface) {
0000000000000000000000000000000000000000;;		d.client = client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *denyExec) Validate() error {
0000000000000000000000000000000000000000;;		if d.client == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing client")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
