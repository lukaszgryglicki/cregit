0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
82b46ba1eb31edbbff37154756af83f8291996ab;plugin/pkg/admission/exec/denyprivileged/admission_test.go[plugin/pkg/admission/exec/denyprivileged/admission_test.go][plugin/pkg/admission/exec/admission_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package exec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/fake"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newAllowEscalatingExec returns `admission.Interface` that allows execution on
0000000000000000000000000000000000000000;;	// "hostIPC", "hostPID" and "privileged".
0000000000000000000000000000000000000000;;	func newAllowEscalatingExec() admission.Interface {
0000000000000000000000000000000000000000;;		return &denyExec{
0000000000000000000000000000000000000000;;			Handler:    admission.NewHandler(admission.Connect),
0000000000000000000000000000000000000000;;			hostIPC:    false,
0000000000000000000000000000000000000000;;			hostPID:    false,
0000000000000000000000000000000000000000;;			privileged: false,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmission(t *testing.T) {
0000000000000000000000000000000000000000;;		privPod := validPod("privileged")
0000000000000000000000000000000000000000;;		priv := true
0000000000000000000000000000000000000000;;		privPod.Spec.Containers[0].SecurityContext = &api.SecurityContext{
0000000000000000000000000000000000000000;;			Privileged: &priv,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostPIDPod := validPod("hostPID")
0000000000000000000000000000000000000000;;		hostPIDPod.Spec.SecurityContext = &api.PodSecurityContext{}
0000000000000000000000000000000000000000;;		hostPIDPod.Spec.SecurityContext.HostPID = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostIPCPod := validPod("hostIPC")
0000000000000000000000000000000000000000;;		hostIPCPod.Spec.SecurityContext = &api.PodSecurityContext{}
0000000000000000000000000000000000000000;;		hostIPCPod.Spec.SecurityContext.HostIPC = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			pod          *api.Pod
0000000000000000000000000000000000000000;;			shouldAccept bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"priv": {
0000000000000000000000000000000000000000;;				shouldAccept: false,
0000000000000000000000000000000000000000;;				pod:          privPod,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"hostPID": {
0000000000000000000000000000000000000000;;				shouldAccept: false,
0000000000000000000000000000000000000000;;				pod:          hostPIDPod,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"hostIPC": {
0000000000000000000000000000000000000000;;				shouldAccept: false,
0000000000000000000000000000000000000000;;				pod:          hostIPCPod,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"non privileged": {
0000000000000000000000000000000000000000;;				shouldAccept: true,
0000000000000000000000000000000000000000;;				pod:          validPod("nonPrivileged"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the direct object though to allow testAdmission to inject the client
0000000000000000000000000000000000000000;;		handler := NewDenyEscalatingExec().(*denyExec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			testAdmission(t, tc.pod, handler, tc.shouldAccept)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// run with a permissive config and all cases should pass
0000000000000000000000000000000000000000;;		handler = newAllowEscalatingExec().(*denyExec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			testAdmission(t, tc.pod, handler, true)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// run against an init container
0000000000000000000000000000000000000000;;		handler = NewDenyEscalatingExec().(*denyExec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			tc.pod.Spec.InitContainers = tc.pod.Spec.Containers
0000000000000000000000000000000000000000;;			tc.pod.Spec.Containers = nil
0000000000000000000000000000000000000000;;			testAdmission(t, tc.pod, handler, tc.shouldAccept)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// run with a permissive config and all cases should pass
0000000000000000000000000000000000000000;;		handler = newAllowEscalatingExec().(*denyExec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			testAdmission(t, tc.pod, handler, true)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testAdmission(t *testing.T, pod *api.Pod, handler *denyExec, shouldAccept bool) {
0000000000000000000000000000000000000000;;		mockClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		mockClient.AddReactor("get", "pods", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			if action.(core.GetAction).GetName() == pod.Name {
0000000000000000000000000000000000000000;;				return true, pod, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected API call: %#v", action)
0000000000000000000000000000000000000000;;			return true, nil, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler.SetInternalKubeClientSet(mockClient)
0000000000000000000000000000000000000000;;		admission.Validate(handler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pods/exec
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			req := &rest.ConnectRequest{Name: pod.Name, ResourcePath: "pods/exec"}
0000000000000000000000000000000000000000;;			err := handler.Admit(admission.NewAttributesRecord(req, nil, api.Kind("Pod").WithVersion("version"), "test", "name", api.Resource("pods").WithVersion("version"), "exec", admission.Connect, nil))
0000000000000000000000000000000000000000;;			if shouldAccept && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error returned from admission handler: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !shouldAccept && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("An error was expected from the admission handler. Received nil")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pods/attach
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			req := &rest.ConnectRequest{Name: pod.Name, ResourcePath: "pods/attach"}
0000000000000000000000000000000000000000;;			err := handler.Admit(admission.NewAttributesRecord(req, nil, api.Kind("Pod").WithVersion("version"), "test", "name", api.Resource("pods").WithVersion("version"), "attach", admission.Connect, nil))
0000000000000000000000000000000000000000;;			if shouldAccept && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error returned from admission handler: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !shouldAccept && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("An error was expected from the admission handler. Received nil")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test to ensure legacy admission controller works as expected.
0000000000000000000000000000000000000000;;	func TestDenyExecOnPrivileged(t *testing.T) {
0000000000000000000000000000000000000000;;		privPod := validPod("privileged")
0000000000000000000000000000000000000000;;		priv := true
0000000000000000000000000000000000000000;;		privPod.Spec.Containers[0].SecurityContext = &api.SecurityContext{
0000000000000000000000000000000000000000;;			Privileged: &priv,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostPIDPod := validPod("hostPID")
0000000000000000000000000000000000000000;;		hostPIDPod.Spec.SecurityContext = &api.PodSecurityContext{}
0000000000000000000000000000000000000000;;		hostPIDPod.Spec.SecurityContext.HostPID = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostIPCPod := validPod("hostIPC")
0000000000000000000000000000000000000000;;		hostIPCPod.Spec.SecurityContext = &api.PodSecurityContext{}
0000000000000000000000000000000000000000;;		hostIPCPod.Spec.SecurityContext.HostIPC = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			pod          *api.Pod
0000000000000000000000000000000000000000;;			shouldAccept bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"priv": {
0000000000000000000000000000000000000000;;				shouldAccept: false,
0000000000000000000000000000000000000000;;				pod:          privPod,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"hostPID": {
0000000000000000000000000000000000000000;;				shouldAccept: true,
0000000000000000000000000000000000000000;;				pod:          hostPIDPod,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"hostIPC": {
0000000000000000000000000000000000000000;;				shouldAccept: true,
0000000000000000000000000000000000000000;;				pod:          hostIPCPod,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"non privileged": {
0000000000000000000000000000000000000000;;				shouldAccept: true,
0000000000000000000000000000000000000000;;				pod:          validPod("nonPrivileged"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the direct object though to allow testAdmission to inject the client
0000000000000000000000000000000000000000;;		handler := NewDenyExecOnPrivileged().(*denyExec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			testAdmission(t, tc.pod, handler, tc.shouldAccept)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// test init containers
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			tc.pod.Spec.InitContainers = tc.pod.Spec.Containers
0000000000000000000000000000000000000000;;			tc.pod.Spec.Containers = nil
0000000000000000000000000000000000000000;;			testAdmission(t, tc.pod, handler, tc.shouldAccept)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validPod(name string) *api.Pod {
0000000000000000000000000000000000000000;;		return &api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: name, Namespace: "test"},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []api.Container{
0000000000000000000000000000000000000000;;					{Name: "ctr1", Image: "image"},
0000000000000000000000000000000000000000;;					{Name: "ctr2", Image: "image2"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
