0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
c1fcc18efe25e919338e800712f943d41fb63544;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package initialresources
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		source     = flag.String("ir-data-source", "influxdb", "Data source used by InitialResources. Supported options: influxdb, gcm.")
0000000000000000000000000000000000000000;;		percentile = flag.Int64("ir-percentile", 90, "Which percentile of samples should InitialResources use when estimating resources. For experiment purposes.")
0000000000000000000000000000000000000000;;		nsOnly     = flag.Bool("ir-namespace-only", false, "Whether the estimation should be made only based on data from the same namespace.")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		initialResourcesAnnotation = "kubernetes.io/initial-resources"
0000000000000000000000000000000000000000;;		samplesThreshold           = 30
0000000000000000000000000000000000000000;;		week                       = 7 * 24 * time.Hour
0000000000000000000000000000000000000000;;		month                      = 30 * 24 * time.Hour
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register registers a plugin
0000000000000000000000000000000000000000;;	// WARNING: this feature is experimental and will definitely change.
0000000000000000000000000000000000000000;;	func Register(plugins *admission.Plugins) {
0000000000000000000000000000000000000000;;		plugins.Register("InitialResources", func(config io.Reader) (admission.Interface, error) {
0000000000000000000000000000000000000000;;			// TODO: remove the usage of flags in favor of reading versioned configuration
0000000000000000000000000000000000000000;;			s, err := newDataSource(*source)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return newInitialResources(s, *percentile, *nsOnly), nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type initialResources struct {
0000000000000000000000000000000000000000;;		*admission.Handler
0000000000000000000000000000000000000000;;		source     dataSource
0000000000000000000000000000000000000000;;		percentile int64
0000000000000000000000000000000000000000;;		nsOnly     bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newInitialResources(source dataSource, percentile int64, nsOnly bool) admission.Interface {
0000000000000000000000000000000000000000;;		return &initialResources{
0000000000000000000000000000000000000000;;			Handler:    admission.NewHandler(admission.Create),
0000000000000000000000000000000000000000;;			source:     source,
0000000000000000000000000000000000000000;;			percentile: percentile,
0000000000000000000000000000000000000000;;			nsOnly:     nsOnly,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ir initialResources) Admit(a admission.Attributes) (err error) {
0000000000000000000000000000000000000000;;		// Ignore all calls to subresources or resources other than pods.
0000000000000000000000000000000000000000;;		if a.GetSubresource() != "" || a.GetResource().GroupResource() != api.Resource("pods") {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod, ok := a.GetObject().(*api.Pod)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return apierrors.NewBadRequest("Resource was marked with kind Pod but was unable to be converted")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ir.estimateAndFillResourcesIfNotSet(pod)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The method veryfies whether resources should be set for the given pod and
0000000000000000000000000000000000000000;;	// if there is estimation available the method fills Request field.
0000000000000000000000000000000000000000;;	func (ir initialResources) estimateAndFillResourcesIfNotSet(pod *api.Pod) {
0000000000000000000000000000000000000000;;		var annotations []string
0000000000000000000000000000000000000000;;		for i := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;			annotations = append(annotations, ir.estimateContainer(pod, &pod.Spec.InitContainers[i], "init container")...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			annotations = append(annotations, ir.estimateContainer(pod, &pod.Spec.Containers[i], "container")...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(annotations) > 0 {
0000000000000000000000000000000000000000;;			if pod.ObjectMeta.Annotations == nil {
0000000000000000000000000000000000000000;;				pod.ObjectMeta.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val := "Initial Resources plugin set: " + strings.Join(annotations, "; ")
0000000000000000000000000000000000000000;;			pod.ObjectMeta.Annotations[initialResourcesAnnotation] = val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ir initialResources) estimateContainer(pod *api.Pod, c *api.Container, message string) []string {
0000000000000000000000000000000000000000;;		var annotations []string
0000000000000000000000000000000000000000;;		req := c.Resources.Requests
0000000000000000000000000000000000000000;;		cpu := ir.getEstimationIfNeeded(api.ResourceCPU, c, pod.ObjectMeta.Namespace)
0000000000000000000000000000000000000000;;		mem := ir.getEstimationIfNeeded(api.ResourceMemory, c, pod.ObjectMeta.Namespace)
0000000000000000000000000000000000000000;;		// If Requests doesn't exits and an estimation was made, create Requests.
0000000000000000000000000000000000000000;;		if req == nil && (cpu != nil || mem != nil) {
0000000000000000000000000000000000000000;;			c.Resources.Requests = api.ResourceList{}
0000000000000000000000000000000000000000;;			req = c.Resources.Requests
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		setRes := []string{}
0000000000000000000000000000000000000000;;		if cpu != nil {
0000000000000000000000000000000000000000;;			glog.Infof("CPU estimation for %s %v in pod %v/%v is %v", message, c.Name, pod.ObjectMeta.Namespace, pod.ObjectMeta.Name, cpu.String())
0000000000000000000000000000000000000000;;			setRes = append(setRes, string(api.ResourceCPU))
0000000000000000000000000000000000000000;;			req[api.ResourceCPU] = *cpu
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mem != nil {
0000000000000000000000000000000000000000;;			glog.Infof("Memory estimation for %s %v in pod %v/%v is %v", message, c.Name, pod.ObjectMeta.Namespace, pod.ObjectMeta.Name, mem.String())
0000000000000000000000000000000000000000;;			setRes = append(setRes, string(api.ResourceMemory))
0000000000000000000000000000000000000000;;			req[api.ResourceMemory] = *mem
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(setRes) > 0 {
0000000000000000000000000000000000000000;;			sort.Strings(setRes)
0000000000000000000000000000000000000000;;			a := strings.Join(setRes, ", ") + fmt.Sprintf(" request for %s %s", message, c.Name)
0000000000000000000000000000000000000000;;			annotations = append(annotations, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return annotations
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getEstimationIfNeeded estimates compute resource for container if its corresponding
0000000000000000000000000000000000000000;;	// Request(min amount) and Limit(max amount) both are not specified.
0000000000000000000000000000000000000000;;	func (ir initialResources) getEstimationIfNeeded(kind api.ResourceName, c *api.Container, ns string) *resource.Quantity {
0000000000000000000000000000000000000000;;		requests := c.Resources.Requests
0000000000000000000000000000000000000000;;		limits := c.Resources.Limits
0000000000000000000000000000000000000000;;		var quantity *resource.Quantity
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if _, requestFound := requests[kind]; !requestFound {
0000000000000000000000000000000000000000;;			if _, limitFound := limits[kind]; !limitFound {
0000000000000000000000000000000000000000;;				quantity, err = ir.getEstimation(kind, c, ns)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Error while trying to estimate resources: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return quantity
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (ir initialResources) getEstimation(kind api.ResourceName, c *api.Container, ns string) (*resource.Quantity, error) {
0000000000000000000000000000000000000000;;		end := time.Now()
0000000000000000000000000000000000000000;;		start := end.Add(-week)
0000000000000000000000000000000000000000;;		var usage, samples int64
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Historical data from last 7 days for the same image:tag within the same namespace.
0000000000000000000000000000000000000000;;		if usage, samples, err = ir.source.GetUsagePercentile(kind, ir.percentile, c.Image, ns, true, start, end); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if samples < samplesThreshold {
0000000000000000000000000000000000000000;;			// Historical data from last 30 days for the same image:tag within the same namespace.
0000000000000000000000000000000000000000;;			start := end.Add(-month)
0000000000000000000000000000000000000000;;			if usage, samples, err = ir.source.GetUsagePercentile(kind, ir.percentile, c.Image, ns, true, start, end); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we are allowed to estimate only based on data from the same namespace.
0000000000000000000000000000000000000000;;		if ir.nsOnly {
0000000000000000000000000000000000000000;;			if samples < samplesThreshold {
0000000000000000000000000000000000000000;;				// Historical data from last 30 days for the same image within the same namespace.
0000000000000000000000000000000000000000;;				start := end.Add(-month)
0000000000000000000000000000000000000000;;				image := strings.Split(c.Image, ":")[0]
0000000000000000000000000000000000000000;;				if usage, samples, err = ir.source.GetUsagePercentile(kind, ir.percentile, image, ns, false, start, end); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if samples < samplesThreshold {
0000000000000000000000000000000000000000;;				// Historical data from last 7 days for the same image:tag within all namespaces.
0000000000000000000000000000000000000000;;				start := end.Add(-week)
0000000000000000000000000000000000000000;;				if usage, samples, err = ir.source.GetUsagePercentile(kind, ir.percentile, c.Image, "", true, start, end); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if samples < samplesThreshold {
0000000000000000000000000000000000000000;;				// Historical data from last 30 days for the same image:tag within all namespaces.
0000000000000000000000000000000000000000;;				start := end.Add(-month)
0000000000000000000000000000000000000000;;				if usage, samples, err = ir.source.GetUsagePercentile(kind, ir.percentile, c.Image, "", true, start, end); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if samples < samplesThreshold {
0000000000000000000000000000000000000000;;				// Historical data from last 30 days for the same image within all namespaces.
0000000000000000000000000000000000000000;;				start := end.Add(-month)
0000000000000000000000000000000000000000;;				image := strings.Split(c.Image, ":")[0]
0000000000000000000000000000000000000000;;				if usage, samples, err = ir.source.GetUsagePercentile(kind, ir.percentile, image, "", false, start, end); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if samples > 0 && kind == api.ResourceCPU {
0000000000000000000000000000000000000000;;			return resource.NewMilliQuantity(usage, resource.DecimalSI), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if samples > 0 && kind == api.ResourceMemory {
0000000000000000000000000000000000000000;;			return resource.NewQuantity(usage, resource.DecimalSI), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
