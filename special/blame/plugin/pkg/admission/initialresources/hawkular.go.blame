0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
5536d66a1341cfc5a5fe01682242d8b96121b69f;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package initialresources
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/hawkular/hawkular-client-go/metrics"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hawkularSource struct {
0000000000000000000000000000000000000000;;		client       *metrics.Client
0000000000000000000000000000000000000000;;		uri          *url.URL
0000000000000000000000000000000000000000;;		useNamespace bool
0000000000000000000000000000000000000000;;		modifiers    []metrics.Modifier
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		containerImageTag string = "container_base_image"
0000000000000000000000000000000000000000;;		descriptorTag     string = "descriptor_name"
0000000000000000000000000000000000000000;;		separator         string = "/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaultServiceAccountFile = "/var/run/secrets/kubernetes.io/serviceaccount/token"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// heapsterName gets the equivalent MetricDescriptor.Name used in the Heapster
0000000000000000000000000000000000000000;;	func heapsterName(kind api.ResourceName) string {
0000000000000000000000000000000000000000;;		switch kind {
0000000000000000000000000000000000000000;;		case api.ResourceCPU:
0000000000000000000000000000000000000000;;			return "cpu/usage"
0000000000000000000000000000000000000000;;		case api.ResourceMemory:
0000000000000000000000000000000000000000;;			return "memory/usage"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tagQuery creates tagFilter query for Hawkular
0000000000000000000000000000000000000000;;	func tagQuery(kind api.ResourceName, image string, exactMatch bool) map[string]string {
0000000000000000000000000000000000000000;;		q := make(map[string]string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add here the descriptor_tag..
0000000000000000000000000000000000000000;;		q[descriptorTag] = heapsterName(kind)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if exactMatch {
0000000000000000000000000000000000000000;;			q[containerImageTag] = image
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			split := strings.Index(image, "@")
0000000000000000000000000000000000000000;;			if split < 0 {
0000000000000000000000000000000000000000;;				split = strings.Index(image, ":")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			q[containerImageTag] = fmt.Sprintf("%s:*", image[:split])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return q
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dataSource API
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (hs *hawkularSource) GetUsagePercentile(kind api.ResourceName, perc int64, image, namespace string, exactMatch bool, start, end time.Time) (int64, int64, error) {
0000000000000000000000000000000000000000;;		q := tagQuery(kind, image, exactMatch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := make([]metrics.Modifier, len(hs.modifiers), 2+len(hs.modifiers))
0000000000000000000000000000000000000000;;		copy(m, hs.modifiers)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if namespace != metav1.NamespaceAll {
0000000000000000000000000000000000000000;;			m = append(m, metrics.Tenant(namespace))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := float64(perc)
0000000000000000000000000000000000000000;;		m = append(m, metrics.Filters(metrics.TagsFilter(q), metrics.BucketsFilter(1), metrics.StartTimeFilter(start), metrics.EndTimeFilter(end), metrics.PercentilesFilter([]float64{p})))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bp, err := hs.client.ReadBuckets(metrics.Counter, m...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(bp) > 0 && len(bp[0].Percentiles) > 0 {
0000000000000000000000000000000000000000;;			return int64(bp[0].Percentiles[0].Value), int64(bp[0].Samples), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, 0, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newHawkularSource creates a new Hawkular Source. The uri follows the scheme from Heapster
0000000000000000000000000000000000000000;;	func newHawkularSource(uri string) (dataSource, error) {
0000000000000000000000000000000000000000;;		u, err := url.Parse(uri)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d := &hawkularSource{
0000000000000000000000000000000000000000;;			uri: u,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = d.init(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// init initializes the Hawkular dataSource. Almost equal to the Heapster initialization
0000000000000000000000000000000000000000;;	func (hs *hawkularSource) init() error {
0000000000000000000000000000000000000000;;		hs.modifiers = make([]metrics.Modifier, 0)
0000000000000000000000000000000000000000;;		p := metrics.Parameters{
0000000000000000000000000000000000000000;;			Tenant: "heapster", // This data is stored by the heapster - for no-namespace hits
0000000000000000000000000000000000000000;;			Url:    hs.uri.String(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts := hs.uri.Query()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if v, found := opts["tenant"]; found {
0000000000000000000000000000000000000000;;			p.Tenant = v[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if v, found := opts["useServiceAccount"]; found {
0000000000000000000000000000000000000000;;			if b, _ := strconv.ParseBool(v[0]); b {
0000000000000000000000000000000000000000;;				accountFile := defaultServiceAccountFile
0000000000000000000000000000000000000000;;				if file, f := opts["serviceAccountFile"]; f {
0000000000000000000000000000000000000000;;					accountFile = file[0]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// If a readable service account token exists, then use it
0000000000000000000000000000000000000000;;				if contents, err := ioutil.ReadFile(accountFile); err == nil {
0000000000000000000000000000000000000000;;					p.Token = string(contents)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					glog.Errorf("Could not read contents of %s, no token authentication is used\n", defaultServiceAccountFile)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Authentication / Authorization parameters
0000000000000000000000000000000000000000;;		tC := &tls.Config{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if v, found := opts["auth"]; found {
0000000000000000000000000000000000000000;;			if _, f := opts["caCert"]; f {
0000000000000000000000000000000000000000;;				return fmt.Errorf("both auth and caCert files provided, combination is not supported")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(v[0]) > 0 {
0000000000000000000000000000000000000000;;				// Authfile
0000000000000000000000000000000000000000;;				kubeConfig, err := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(&clientcmd.ClientConfigLoadingRules{
0000000000000000000000000000000000000000;;					ExplicitPath: v[0]},
0000000000000000000000000000000000000000;;					&clientcmd.ConfigOverrides{}).ClientConfig()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				tC, err = restclient.TLSConfigFor(kubeConfig)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if u, found := opts["user"]; found {
0000000000000000000000000000000000000000;;			if _, wrong := opts["useServiceAccount"]; wrong {
0000000000000000000000000000000000000000;;				return fmt.Errorf("if user and password are used, serviceAccount cannot be used")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p, f := opts["pass"]; f {
0000000000000000000000000000000000000000;;				hs.modifiers = append(hs.modifiers, func(req *http.Request) error {
0000000000000000000000000000000000000000;;					req.SetBasicAuth(u[0], p[0])
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if v, found := opts["caCert"]; found {
0000000000000000000000000000000000000000;;			caCert, err := ioutil.ReadFile(v[0])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			caCertPool := x509.NewCertPool()
0000000000000000000000000000000000000000;;			caCertPool.AppendCertsFromPEM(caCert)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tC.RootCAs = caCertPool
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if v, found := opts["insecure"]; found {
0000000000000000000000000000000000000000;;			insecure, err := strconv.ParseBool(v[0])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tC.InsecureSkipVerify = insecure
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.TLSConfig = tC
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, err := metrics.NewHawkularClient(p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hs.client = c
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Initialised Hawkular Source with parameters %v", p)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
