0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
98af5114332c592b32703f0e6eb660deb96ae2ab;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package imagepolicy contains an admission controller that configures a webhook to which policy
0000000000000000000000000000000000000000;;	// decisions are delegated.
0000000000000000000000000000000000000000;;	package imagepolicy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		kubeschema "k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/cache"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/yaml"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/webhook"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/imagepolicy/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// install the clientgo image policy API for use with api registry
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/imagepolicy/install"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		groupVersions = []schema.GroupVersion{v1alpha1.SchemeGroupVersion}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register registers a plugin
0000000000000000000000000000000000000000;;	func Register(plugins *admission.Plugins) {
0000000000000000000000000000000000000000;;		plugins.Register("ImagePolicyWebhook", func(config io.Reader) (admission.Interface, error) {
0000000000000000000000000000000000000000;;			newImagePolicyWebhook, err := NewImagePolicyWebhook(config)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return newImagePolicyWebhook, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// imagePolicyWebhook is an implementation of admission.Interface.
0000000000000000000000000000000000000000;;	type imagePolicyWebhook struct {
0000000000000000000000000000000000000000;;		*admission.Handler
0000000000000000000000000000000000000000;;		webhook       *webhook.GenericWebhook
0000000000000000000000000000000000000000;;		responseCache *cache.LRUExpireCache
0000000000000000000000000000000000000000;;		allowTTL      time.Duration
0000000000000000000000000000000000000000;;		denyTTL       time.Duration
0000000000000000000000000000000000000000;;		retryBackoff  time.Duration
0000000000000000000000000000000000000000;;		defaultAllow  bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *imagePolicyWebhook) statusTTL(status v1alpha1.ImageReviewStatus) time.Duration {
0000000000000000000000000000000000000000;;		if status.Allowed {
0000000000000000000000000000000000000000;;			return a.allowTTL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a.denyTTL
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Filter out annotations that don't match *.image-policy.k8s.io/*
0000000000000000000000000000000000000000;;	func (a *imagePolicyWebhook) filterAnnotations(allAnnotations map[string]string) map[string]string {
0000000000000000000000000000000000000000;;		annotations := make(map[string]string)
0000000000000000000000000000000000000000;;		for k, v := range allAnnotations {
0000000000000000000000000000000000000000;;			if strings.Contains(k, ".image-policy.k8s.io/") {
0000000000000000000000000000000000000000;;				annotations[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return annotations
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Function to call on webhook failure; behavior determined by defaultAllow flag
0000000000000000000000000000000000000000;;	func (a *imagePolicyWebhook) webhookError(pod *api.Pod, attributes admission.Attributes, err error) error {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("error contacting webhook backend: %s", err)
0000000000000000000000000000000000000000;;			if a.defaultAllow {
0000000000000000000000000000000000000000;;				annotations := pod.GetAnnotations()
0000000000000000000000000000000000000000;;				if annotations == nil {
0000000000000000000000000000000000000000;;					annotations = make(map[string]string)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				annotations[api.ImagePolicyFailedOpenKey] = "true"
0000000000000000000000000000000000000000;;				pod.ObjectMeta.SetAnnotations(annotations)
0000000000000000000000000000000000000000;;				glog.V(2).Infof("resource allowed in spite of webhook backend failure")
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("resource not allowed due to webhook backend failure ")
0000000000000000000000000000000000000000;;			return admission.NewForbidden(attributes, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *imagePolicyWebhook) Admit(attributes admission.Attributes) (err error) {
0000000000000000000000000000000000000000;;		// Ignore all calls to subresources or resources other than pods.
0000000000000000000000000000000000000000;;		allowedResources := map[kubeschema.GroupResource]bool{
0000000000000000000000000000000000000000;;			api.Resource("pods"): true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(attributes.GetSubresource()) != 0 || !allowedResources[attributes.GetResource().GroupResource()] {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod, ok := attributes.GetObject().(*api.Pod)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return apierrors.NewBadRequest("Resource was marked with kind Pod but was unable to be converted")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Build list of ImageReviewContainerSpec
0000000000000000000000000000000000000000;;		var imageReviewContainerSpecs []v1alpha1.ImageReviewContainerSpec
0000000000000000000000000000000000000000;;		containers := make([]api.Container, 0, len(pod.Spec.Containers)+len(pod.Spec.InitContainers))
0000000000000000000000000000000000000000;;		containers = append(containers, pod.Spec.Containers...)
0000000000000000000000000000000000000000;;		containers = append(containers, pod.Spec.InitContainers...)
0000000000000000000000000000000000000000;;		for _, c := range containers {
0000000000000000000000000000000000000000;;			imageReviewContainerSpecs = append(imageReviewContainerSpecs, v1alpha1.ImageReviewContainerSpec{
0000000000000000000000000000000000000000;;				Image: c.Image,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		imageReview := v1alpha1.ImageReview{
0000000000000000000000000000000000000000;;			Spec: v1alpha1.ImageReviewSpec{
0000000000000000000000000000000000000000;;				Containers:  imageReviewContainerSpecs,
0000000000000000000000000000000000000000;;				Annotations: a.filterAnnotations(pod.Annotations),
0000000000000000000000000000000000000000;;				Namespace:   attributes.GetNamespace(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := a.admitPod(pod, attributes, &imageReview); err != nil {
0000000000000000000000000000000000000000;;			return admission.NewForbidden(attributes, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *imagePolicyWebhook) admitPod(pod *api.Pod, attributes admission.Attributes, review *v1alpha1.ImageReview) error {
0000000000000000000000000000000000000000;;		cacheKey, err := json.Marshal(review.Spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if entry, ok := a.responseCache.Get(string(cacheKey)); ok {
0000000000000000000000000000000000000000;;			review.Status = entry.(v1alpha1.ImageReviewStatus)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			result := a.webhook.WithExponentialBackoff(func() rest.Result {
0000000000000000000000000000000000000000;;				return a.webhook.RestClient.Post().Body(review).Do()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := result.Error(); err != nil {
0000000000000000000000000000000000000000;;				return a.webhookError(pod, attributes, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var statusCode int
0000000000000000000000000000000000000000;;			if result.StatusCode(&statusCode); statusCode < 200 || statusCode >= 300 {
0000000000000000000000000000000000000000;;				return a.webhookError(pod, attributes, fmt.Errorf("Error contacting webhook: %d", statusCode))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := result.Into(review); err != nil {
0000000000000000000000000000000000000000;;				return a.webhookError(pod, attributes, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			a.responseCache.Add(string(cacheKey), review.Status, a.statusTTL(review.Status))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !review.Status.Allowed {
0000000000000000000000000000000000000000;;			if len(review.Status.Reason) > 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("image policy webhook backend denied one or more images: %s", review.Status.Reason)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return errors.New("one or more images rejected by webhook backend")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewImagePolicyWebhook a new imagePolicyWebhook from the provided config file.
0000000000000000000000000000000000000000;;	// The config file is specified by --admission-controller-config-file and has the
0000000000000000000000000000000000000000;;	// following format for a webhook:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   {
0000000000000000000000000000000000000000;;	//     "imagePolicy": {
0000000000000000000000000000000000000000;;	//        "kubeConfigFile": "path/to/kubeconfig/for/backend",
0000000000000000000000000000000000000000;;	//        "allowTTL": 30,           # time in s to cache approval
0000000000000000000000000000000000000000;;	//        "denyTTL": 30,            # time in s to cache denial
0000000000000000000000000000000000000000;;	//        "retryBackoff": 500,      # time in ms to wait between retries
0000000000000000000000000000000000000000;;	//        "defaultAllow": true      # determines behavior if the webhook backend fails
0000000000000000000000000000000000000000;;	//     }
0000000000000000000000000000000000000000;;	//   }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The config file may be json or yaml.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The kubeconfig property refers to another file in the kubeconfig format which
0000000000000000000000000000000000000000;;	// specifies how to connect to the webhook backend.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The kubeconfig's cluster field is used to refer to the remote service, user refers to the returned authorizer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     # clusters refers to the remote service.
0000000000000000000000000000000000000000;;	//     clusters:
0000000000000000000000000000000000000000;;	//     - name: name-of-remote-imagepolicy-service
0000000000000000000000000000000000000000;;	//       cluster:
0000000000000000000000000000000000000000;;	//         certificate-authority: /path/to/ca.pem      # CA for verifying the remote service.
0000000000000000000000000000000000000000;;	//         server: https://images.example.com/policy # URL of remote service to query. Must use 'https'.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     # users refers to the API server's webhook configuration.
0000000000000000000000000000000000000000;;	//     users:
0000000000000000000000000000000000000000;;	//     - name: name-of-api-server
0000000000000000000000000000000000000000;;	//       user:
0000000000000000000000000000000000000000;;	//         client-certificate: /path/to/cert.pem # cert for the webhook plugin to use
0000000000000000000000000000000000000000;;	//         client-key: /path/to/key.pem          # key matching the cert
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For additional HTTP configuration, refer to the kubeconfig documentation
0000000000000000000000000000000000000000;;	// http://kubernetes.io/v1.1/docs/user-guide/kubeconfig-file.html.
0000000000000000000000000000000000000000;;	func NewImagePolicyWebhook(configFile io.Reader) (admission.Interface, error) {
0000000000000000000000000000000000000000;;		// TODO: move this to a versioned configuration file format
0000000000000000000000000000000000000000;;		var config AdmissionConfig
0000000000000000000000000000000000000000;;		d := yaml.NewYAMLOrJSONDecoder(configFile, 4096)
0000000000000000000000000000000000000000;;		err := d.Decode(&config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		whConfig := config.ImagePolicyWebhook
0000000000000000000000000000000000000000;;		if err := normalizeWebhookConfig(&whConfig); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gw, err := webhook.NewGenericWebhook(api.Registry, api.Codecs, whConfig.KubeConfigFile, groupVersions, whConfig.RetryBackoff)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &imagePolicyWebhook{
0000000000000000000000000000000000000000;;			Handler:       admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			webhook:       gw,
0000000000000000000000000000000000000000;;			responseCache: cache.NewLRUExpireCache(1024),
0000000000000000000000000000000000000000;;			allowTTL:      whConfig.AllowTTL,
0000000000000000000000000000000000000000;;			denyTTL:       whConfig.DenyTTL,
0000000000000000000000000000000000000000;;			defaultAllow:  whConfig.DefaultAllow,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
