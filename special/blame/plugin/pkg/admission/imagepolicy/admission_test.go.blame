0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
98af5114332c592b32703f0e6eb660deb96ae2ab;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package imagepolicy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/imagepolicy/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd/api/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"text/template"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/imagepolicy/install"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const defaultConfigTmplJSON = `
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	"imagePolicy": {
0000000000000000000000000000000000000000;;		"kubeConfigFile": "{{ .KubeConfig }}",
0000000000000000000000000000000000000000;;		"allowTTL": {{ .AllowTTL }},
0000000000000000000000000000000000000000;;		"denyTTL": {{ .DenyTTL }},
0000000000000000000000000000000000000000;;		"retryBackoff": {{ .RetryBackoff }},
0000000000000000000000000000000000000000;;		"defaultAllow": {{ .DefaultAllow }}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const defaultConfigTmplYAML = `
0000000000000000000000000000000000000000;;	imagePolicy:
0000000000000000000000000000000000000000;;	  kubeConfigFile: "{{ .KubeConfig }}"
0000000000000000000000000000000000000000;;	  allowTTL: {{ .AllowTTL }}
0000000000000000000000000000000000000000;;	  denyTTL: {{ .DenyTTL }}
0000000000000000000000000000000000000000;;	  retryBackoff: {{ .RetryBackoff }}
0000000000000000000000000000000000000000;;	  defaultAllow: {{ .DefaultAllow }}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewFromConfig(t *testing.T) {
0000000000000000000000000000000000000000;;		dir, err := ioutil.TempDir("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := struct {
0000000000000000000000000000000000000000;;			CA   string
0000000000000000000000000000000000000000;;			Cert string
0000000000000000000000000000000000000000;;			Key  string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			CA:   filepath.Join(dir, "ca.pem"),
0000000000000000000000000000000000000000;;			Cert: filepath.Join(dir, "clientcert.pem"),
0000000000000000000000000000000000000000;;			Key:  filepath.Join(dir, "clientkey.pem"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		files := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;			data []byte
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{data.CA, caCert},
0000000000000000000000000000000000000000;;			{data.Cert, clientCert},
0000000000000000000000000000000000000000;;			{data.Key, clientKey},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, file := range files {
0000000000000000000000000000000000000000;;			if err := ioutil.WriteFile(file.name, file.data, 0400); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			msg            string
0000000000000000000000000000000000000000;;			kubeConfigTmpl string
0000000000000000000000000000000000000000;;			wantErr        bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				msg: "a single cluster and single user",
0000000000000000000000000000000000000000;;				kubeConfigTmpl: `
0000000000000000000000000000000000000000;;	clusters:
0000000000000000000000000000000000000000;;	- cluster:
0000000000000000000000000000000000000000;;	    certificate-authority: {{ .CA }}
0000000000000000000000000000000000000000;;	    server: https://admission.example.com
0000000000000000000000000000000000000000;;	  name: foobar
0000000000000000000000000000000000000000;;	users:
0000000000000000000000000000000000000000;;	- name: a cluster
0000000000000000000000000000000000000000;;	  user:
0000000000000000000000000000000000000000;;	    client-certificate: {{ .Cert }}
0000000000000000000000000000000000000000;;	    client-key: {{ .Key }}
0000000000000000000000000000000000000000;;	`,
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				msg: "multiple clusters with no context",
0000000000000000000000000000000000000000;;				kubeConfigTmpl: `
0000000000000000000000000000000000000000;;	clusters:
0000000000000000000000000000000000000000;;	- cluster:
0000000000000000000000000000000000000000;;	    certificate-authority: {{ .CA }}
0000000000000000000000000000000000000000;;	    server: https://admission.example.com
0000000000000000000000000000000000000000;;	  name: foobar
0000000000000000000000000000000000000000;;	- cluster:
0000000000000000000000000000000000000000;;	    certificate-authority: a bad certificate path
0000000000000000000000000000000000000000;;	    server: https://admission.example.com
0000000000000000000000000000000000000000;;	  name: barfoo
0000000000000000000000000000000000000000;;	users:
0000000000000000000000000000000000000000;;	- name: a name
0000000000000000000000000000000000000000;;	  user:
0000000000000000000000000000000000000000;;	    client-certificate: {{ .Cert }}
0000000000000000000000000000000000000000;;	    client-key: {{ .Key }}
0000000000000000000000000000000000000000;;	`,
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				msg: "multiple clusters with a context",
0000000000000000000000000000000000000000;;				kubeConfigTmpl: `
0000000000000000000000000000000000000000;;	clusters:
0000000000000000000000000000000000000000;;	- cluster:
0000000000000000000000000000000000000000;;	    certificate-authority: a bad certificate path
0000000000000000000000000000000000000000;;	    server: https://admission.example.com
0000000000000000000000000000000000000000;;	  name: foobar
0000000000000000000000000000000000000000;;	- cluster:
0000000000000000000000000000000000000000;;	    certificate-authority: {{ .CA }}
0000000000000000000000000000000000000000;;	    server: https://admission.example.com
0000000000000000000000000000000000000000;;	  name: barfoo
0000000000000000000000000000000000000000;;	users:
0000000000000000000000000000000000000000;;	- name: a name
0000000000000000000000000000000000000000;;	  user:
0000000000000000000000000000000000000000;;	    client-certificate: {{ .Cert }}
0000000000000000000000000000000000000000;;	    client-key: {{ .Key }}
0000000000000000000000000000000000000000;;	contexts:
0000000000000000000000000000000000000000;;	- name: default
0000000000000000000000000000000000000000;;	  context:
0000000000000000000000000000000000000000;;	    cluster: barfoo
0000000000000000000000000000000000000000;;	    user: a name
0000000000000000000000000000000000000000;;	current-context: default
0000000000000000000000000000000000000000;;	`,
0000000000000000000000000000000000000000;;				wantErr: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				msg: "cluster with bad certificate path specified",
0000000000000000000000000000000000000000;;				kubeConfigTmpl: `
0000000000000000000000000000000000000000;;	clusters:
0000000000000000000000000000000000000000;;	- cluster:
0000000000000000000000000000000000000000;;	    certificate-authority: a bad certificate path
0000000000000000000000000000000000000000;;	    server: https://admission.example.com
0000000000000000000000000000000000000000;;	  name: foobar
0000000000000000000000000000000000000000;;	- cluster:
0000000000000000000000000000000000000000;;	    certificate-authority: {{ .CA }}
0000000000000000000000000000000000000000;;	    server: https://admission.example.com
0000000000000000000000000000000000000000;;	  name: barfoo
0000000000000000000000000000000000000000;;	users:
0000000000000000000000000000000000000000;;	- name: a name
0000000000000000000000000000000000000000;;	  user:
0000000000000000000000000000000000000000;;	    client-certificate: {{ .Cert }}
0000000000000000000000000000000000000000;;	    client-key: {{ .Key }}
0000000000000000000000000000000000000000;;	contexts:
0000000000000000000000000000000000000000;;	- name: default
0000000000000000000000000000000000000000;;	  context:
0000000000000000000000000000000000000000;;	    cluster: foobar
0000000000000000000000000000000000000000;;	    user: a name
0000000000000000000000000000000000000000;;	current-context: default
0000000000000000000000000000000000000000;;	`,
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tt := range tests {
0000000000000000000000000000000000000000;;			// Use a closure so defer statements trigger between loop iterations.
0000000000000000000000000000000000000000;;			err := func() error {
0000000000000000000000000000000000000000;;				tempfile, err := ioutil.TempFile("", "")
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p := tempfile.Name()
0000000000000000000000000000000000000000;;				defer os.Remove(p)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				tmpl, err := template.New("test").Parse(tt.kubeConfigTmpl)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("failed to parse test template: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := tmpl.Execute(tempfile, data); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("failed to execute test template: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				tempconfigfile, err := ioutil.TempFile("", "")
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pc := tempconfigfile.Name()
0000000000000000000000000000000000000000;;				defer os.Remove(pc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				configTmpl, err := template.New("testconfig").Parse(defaultConfigTmplJSON)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("failed to parse test template: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dataConfig := struct {
0000000000000000000000000000000000000000;;					KubeConfig   string
0000000000000000000000000000000000000000;;					AllowTTL     int
0000000000000000000000000000000000000000;;					DenyTTL      int
0000000000000000000000000000000000000000;;					RetryBackoff int
0000000000000000000000000000000000000000;;					DefaultAllow bool
0000000000000000000000000000000000000000;;				}{
0000000000000000000000000000000000000000;;					KubeConfig:   p,
0000000000000000000000000000000000000000;;					AllowTTL:     500,
0000000000000000000000000000000000000000;;					DenyTTL:      500,
0000000000000000000000000000000000000000;;					RetryBackoff: 500,
0000000000000000000000000000000000000000;;					DefaultAllow: true,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := configTmpl.Execute(tempconfigfile, dataConfig); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("failed to execute test template: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Create a new admission controller
0000000000000000000000000000000000000000;;				configFile, err := os.Open(pc)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("failed to read test config: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer configFile.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				_, err = NewImagePolicyWebhook(configFile)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			if err != nil && !tt.wantErr {
0000000000000000000000000000000000000000;;				t.Errorf("failed to load plugin from config %q: %v", tt.msg, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil && tt.wantErr {
0000000000000000000000000000000000000000;;				t.Errorf("wanted an error when loading config, did not get one: %q", tt.msg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Service mocks a remote service.
0000000000000000000000000000000000000000;;	type Service interface {
0000000000000000000000000000000000000000;;		Review(*v1alpha1.ImageReview)
0000000000000000000000000000000000000000;;		HTTPStatusCode() int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTestServer wraps a Service as an httptest.Server.
0000000000000000000000000000000000000000;;	func NewTestServer(s Service, cert, key, caCert []byte) (*httptest.Server, error) {
0000000000000000000000000000000000000000;;		var tlsConfig *tls.Config
0000000000000000000000000000000000000000;;		if cert != nil {
0000000000000000000000000000000000000000;;			cert, err := tls.X509KeyPair(cert, key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tlsConfig = &tls.Config{Certificates: []tls.Certificate{cert}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if caCert != nil {
0000000000000000000000000000000000000000;;			rootCAs := x509.NewCertPool()
0000000000000000000000000000000000000000;;			rootCAs.AppendCertsFromPEM(caCert)
0000000000000000000000000000000000000000;;			if tlsConfig == nil {
0000000000000000000000000000000000000000;;				tlsConfig = &tls.Config{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tlsConfig.ClientCAs = rootCAs
0000000000000000000000000000000000000000;;			tlsConfig.ClientAuth = tls.RequireAndVerifyClientCert
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serveHTTP := func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			var review v1alpha1.ImageReview
0000000000000000000000000000000000000000;;			if err := json.NewDecoder(r.Body).Decode(&review); err != nil {
0000000000000000000000000000000000000000;;				http.Error(w, fmt.Sprintf("failed to decode body: %v", err), http.StatusBadRequest)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s.HTTPStatusCode() < 200 || s.HTTPStatusCode() >= 300 {
0000000000000000000000000000000000000000;;				http.Error(w, "HTTP Error", s.HTTPStatusCode())
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.Review(&review)
0000000000000000000000000000000000000000;;			type status struct {
0000000000000000000000000000000000000000;;				Allowed bool   `json:"allowed"`
0000000000000000000000000000000000000000;;				Reason  string `json:"reason"`
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resp := struct {
0000000000000000000000000000000000000000;;				APIVersion string `json:"apiVersion"`
0000000000000000000000000000000000000000;;				Kind       string `json:"kind"`
0000000000000000000000000000000000000000;;				Status     status `json:"status"`
0000000000000000000000000000000000000000;;			}{
0000000000000000000000000000000000000000;;				APIVersion: v1alpha1.SchemeGroupVersion.String(),
0000000000000000000000000000000000000000;;				Kind:       "ImageReview",
0000000000000000000000000000000000000000;;				Status:     status{review.Status.Allowed, review.Status.Reason},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;			json.NewEncoder(w).Encode(resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server := httptest.NewUnstartedServer(http.HandlerFunc(serveHTTP))
0000000000000000000000000000000000000000;;		server.TLS = tlsConfig
0000000000000000000000000000000000000000;;		server.StartTLS()
0000000000000000000000000000000000000000;;		return server, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A service that can be set to allow all or deny all authorization requests.
0000000000000000000000000000000000000000;;	type mockService struct {
0000000000000000000000000000000000000000;;		allow      bool
0000000000000000000000000000000000000000;;		statusCode int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *mockService) Review(r *v1alpha1.ImageReview) {
0000000000000000000000000000000000000000;;		r.Status.Allowed = m.allow
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// hardcoded overrides
0000000000000000000000000000000000000000;;		if r.Spec.Containers[0].Image == "good" {
0000000000000000000000000000000000000000;;			r.Status.Allowed = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, c := range r.Spec.Containers {
0000000000000000000000000000000000000000;;			if c.Image == "bad" {
0000000000000000000000000000000000000000;;				r.Status.Allowed = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !r.Status.Allowed {
0000000000000000000000000000000000000000;;			r.Status.Reason = "not allowed"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (m *mockService) Allow()              { m.allow = true }
0000000000000000000000000000000000000000;;	func (m *mockService) Deny()               { m.allow = false }
0000000000000000000000000000000000000000;;	func (m *mockService) HTTPStatusCode() int { return m.statusCode }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newImagePolicyWebhook creates a temporary kubeconfig file from the provided arguments and attempts to load
0000000000000000000000000000000000000000;;	// a new newImagePolicyWebhook from it.
0000000000000000000000000000000000000000;;	func newImagePolicyWebhook(callbackURL string, clientCert, clientKey, ca []byte, cacheTime time.Duration, defaultAllow bool) (*imagePolicyWebhook, error) {
0000000000000000000000000000000000000000;;		tempfile, err := ioutil.TempFile("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := tempfile.Name()
0000000000000000000000000000000000000000;;		defer os.Remove(p)
0000000000000000000000000000000000000000;;		config := v1.Config{
0000000000000000000000000000000000000000;;			Clusters: []v1.NamedCluster{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Cluster: v1.Cluster{Server: callbackURL, CertificateAuthorityData: ca},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			AuthInfos: []v1.NamedAuthInfo{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					AuthInfo: v1.AuthInfo{ClientCertificateData: clientCert, ClientKeyData: clientKey},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := json.NewEncoder(tempfile).Encode(config); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tempconfigfile, err := ioutil.TempFile("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pc := tempconfigfile.Name()
0000000000000000000000000000000000000000;;		defer os.Remove(pc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configTmpl, err := template.New("testconfig").Parse(defaultConfigTmplYAML)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to parse test template: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dataConfig := struct {
0000000000000000000000000000000000000000;;			KubeConfig   string
0000000000000000000000000000000000000000;;			AllowTTL     int64
0000000000000000000000000000000000000000;;			DenyTTL      int64
0000000000000000000000000000000000000000;;			RetryBackoff int64
0000000000000000000000000000000000000000;;			DefaultAllow bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			KubeConfig:   p,
0000000000000000000000000000000000000000;;			AllowTTL:     cacheTime.Nanoseconds(),
0000000000000000000000000000000000000000;;			DenyTTL:      cacheTime.Nanoseconds(),
0000000000000000000000000000000000000000;;			RetryBackoff: 0,
0000000000000000000000000000000000000000;;			DefaultAllow: defaultAllow,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := configTmpl.Execute(tempconfigfile, dataConfig); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to execute test template: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a new admission controller
0000000000000000000000000000000000000000;;		configFile, err := os.Open(pc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to read test config: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer configFile.Close()
0000000000000000000000000000000000000000;;		wh, err := NewImagePolicyWebhook(configFile)
0000000000000000000000000000000000000000;;		return wh.(*imagePolicyWebhook), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTLSConfig(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			test                            string
0000000000000000000000000000000000000000;;			clientCert, clientKey, clientCA []byte
0000000000000000000000000000000000000000;;			serverCert, serverKey, serverCA []byte
0000000000000000000000000000000000000000;;			wantAllowed, wantErr            bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "TLS setup between client and server",
0000000000000000000000000000000000000000;;				clientCert: clientCert, clientKey: clientKey, clientCA: caCert,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey, serverCA: caCert,
0000000000000000000000000000000000000000;;				wantAllowed: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "Server does not require client auth",
0000000000000000000000000000000000000000;;				clientCA:   caCert,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey,
0000000000000000000000000000000000000000;;				wantAllowed: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "Server does not require client auth, client provides it",
0000000000000000000000000000000000000000;;				clientCert: clientCert, clientKey: clientKey, clientCA: caCert,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey,
0000000000000000000000000000000000000000;;				wantAllowed: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "Client does not trust server",
0000000000000000000000000000000000000000;;				clientCert: clientCert, clientKey: clientKey,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey,
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "Server does not trust client",
0000000000000000000000000000000000000000;;				clientCert: clientCert, clientKey: clientKey, clientCA: caCert,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey, serverCA: badCACert,
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Plugin does not support insecure configurations.
0000000000000000000000000000000000000000;;				test:    "Server is using insecure connection",
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tt := range tests {
0000000000000000000000000000000000000000;;			// Use a closure so defer statements trigger between loop iterations.
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				service := new(mockService)
0000000000000000000000000000000000000000;;				service.statusCode = 200
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				server, err := NewTestServer(service, tt.serverCert, tt.serverKey, tt.serverCA)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: failed to create server: %v", tt.test, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				wh, err := newImagePolicyWebhook(server.URL, tt.clientCert, tt.clientKey, tt.clientCA, -1, false)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: failed to create client: %v", tt.test, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pod := goodPod(strconv.Itoa(rand.Intn(1000)))
0000000000000000000000000000000000000000;;				attr := admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), "namespace", "", api.Resource("pods").WithVersion("version"), "", admission.Create, &user.DefaultInfo{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Allow all and see if we get an error.
0000000000000000000000000000000000000000;;				service.Allow()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = wh.Admit(attr)
0000000000000000000000000000000000000000;;				if tt.wantAllowed {
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("expected successful admission")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						t.Errorf("expected failed admission")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if tt.wantErr {
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						t.Errorf("expected error making admission request: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: failed to admit with AllowAll policy: %v", tt.test, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				service.Deny()
0000000000000000000000000000000000000000;;				if err := wh.Admit(attr); err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: incorrectly admitted with DenyAll policy", tt.test)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type webhookCacheTestCase struct {
0000000000000000000000000000000000000000;;		statusCode         int
0000000000000000000000000000000000000000;;		expectedErr        bool
0000000000000000000000000000000000000000;;		expectedAuthorized bool
0000000000000000000000000000000000000000;;		expectedCached     bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testWebhookCacheCases(t *testing.T, serv *mockService, wh *imagePolicyWebhook, attr admission.Attributes, tests []webhookCacheTestCase) {
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			serv.statusCode = test.statusCode
0000000000000000000000000000000000000000;;			err := wh.Admit(attr)
0000000000000000000000000000000000000000;;			authorized := err == nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.expectedErr && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("Expected error")
0000000000000000000000000000000000000000;;			} else if !test.expectedErr && err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.expectedAuthorized && !authorized {
0000000000000000000000000000000000000000;;				if test.expectedCached {
0000000000000000000000000000000000000000;;					t.Errorf("Webhook should have successful response cached, but authorizer reported unauthorized.")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					t.Errorf("Webhook returned HTTP %d, but authorizer reported unauthorized.", test.statusCode)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if !test.expectedAuthorized && authorized {
0000000000000000000000000000000000000000;;				t.Errorf("Webhook returned HTTP %d, but authorizer reported success.", test.statusCode)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestWebhookCache verifies that error responses from the server are not
0000000000000000000000000000000000000000;;	// cached, but successful responses are.
0000000000000000000000000000000000000000;;	func TestWebhookCache(t *testing.T) {
0000000000000000000000000000000000000000;;		serv := new(mockService)
0000000000000000000000000000000000000000;;		s, err := NewTestServer(serv, serverCert, serverKey, caCert)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create an admission controller that caches successful responses.
0000000000000000000000000000000000000000;;		wh, err := newImagePolicyWebhook(s.URL, clientCert, clientKey, caCert, 200, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []webhookCacheTestCase{
0000000000000000000000000000000000000000;;			{statusCode: 500, expectedErr: true, expectedAuthorized: false, expectedCached: false},
0000000000000000000000000000000000000000;;			{statusCode: 404, expectedErr: true, expectedAuthorized: false, expectedCached: false},
0000000000000000000000000000000000000000;;			{statusCode: 403, expectedErr: true, expectedAuthorized: false, expectedCached: false},
0000000000000000000000000000000000000000;;			{statusCode: 401, expectedErr: true, expectedAuthorized: false, expectedCached: false},
0000000000000000000000000000000000000000;;			{statusCode: 200, expectedErr: false, expectedAuthorized: true, expectedCached: false},
0000000000000000000000000000000000000000;;			{statusCode: 500, expectedErr: false, expectedAuthorized: true, expectedCached: true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attr := admission.NewAttributesRecord(goodPod("test"), nil, api.Kind("Pod").WithVersion("version"), "namespace", "", api.Resource("pods").WithVersion("version"), "", admission.Create, &user.DefaultInfo{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serv.allow = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testWebhookCacheCases(t, serv, wh, attr, tests)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For a different request, webhook should be called again.
0000000000000000000000000000000000000000;;		tests = []webhookCacheTestCase{
0000000000000000000000000000000000000000;;			{statusCode: 500, expectedErr: true, expectedAuthorized: false, expectedCached: false},
0000000000000000000000000000000000000000;;			{statusCode: 200, expectedErr: false, expectedAuthorized: true, expectedCached: false},
0000000000000000000000000000000000000000;;			{statusCode: 500, expectedErr: false, expectedAuthorized: true, expectedCached: true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attr = admission.NewAttributesRecord(goodPod("test2"), nil, api.Kind("Pod").WithVersion("version"), "namespace", "", api.Resource("pods").WithVersion("version"), "", admission.Create, &user.DefaultInfo{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testWebhookCacheCases(t, serv, wh, attr, tests)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestContainerCombinations(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			test                 string
0000000000000000000000000000000000000000;;			pod                  *api.Pod
0000000000000000000000000000000000000000;;			wantAllowed, wantErr bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:        "Single container allowed",
0000000000000000000000000000000000000000;;				pod:         goodPod("good"),
0000000000000000000000000000000000000000;;				wantAllowed: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:        "Single container denied",
0000000000000000000000000000000000000000;;				pod:         goodPod("bad"),
0000000000000000000000000000000000000000;;				wantAllowed: false,
0000000000000000000000000000000000000000;;				wantErr:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test: "One good container, one bad",
0000000000000000000000000000000000000000;;				pod: &api.Pod{
0000000000000000000000000000000000000000;;					Spec: api.PodSpec{
0000000000000000000000000000000000000000;;						ServiceAccountName: "default",
0000000000000000000000000000000000000000;;						SecurityContext:    &api.PodSecurityContext{},
0000000000000000000000000000000000000000;;						Containers: []api.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image:           "bad",
0000000000000000000000000000000000000000;;								SecurityContext: &api.SecurityContext{},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image:           "good",
0000000000000000000000000000000000000000;;								SecurityContext: &api.SecurityContext{},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				wantAllowed: false,
0000000000000000000000000000000000000000;;				wantErr:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test: "Multiple good containers",
0000000000000000000000000000000000000000;;				pod: &api.Pod{
0000000000000000000000000000000000000000;;					Spec: api.PodSpec{
0000000000000000000000000000000000000000;;						ServiceAccountName: "default",
0000000000000000000000000000000000000000;;						SecurityContext:    &api.PodSecurityContext{},
0000000000000000000000000000000000000000;;						Containers: []api.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image:           "good",
0000000000000000000000000000000000000000;;								SecurityContext: &api.SecurityContext{},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image:           "good",
0000000000000000000000000000000000000000;;								SecurityContext: &api.SecurityContext{},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				wantAllowed: true,
0000000000000000000000000000000000000000;;				wantErr:     false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test: "Multiple bad containers",
0000000000000000000000000000000000000000;;				pod: &api.Pod{
0000000000000000000000000000000000000000;;					Spec: api.PodSpec{
0000000000000000000000000000000000000000;;						ServiceAccountName: "default",
0000000000000000000000000000000000000000;;						SecurityContext:    &api.PodSecurityContext{},
0000000000000000000000000000000000000000;;						Containers: []api.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image:           "bad",
0000000000000000000000000000000000000000;;								SecurityContext: &api.SecurityContext{},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image:           "bad",
0000000000000000000000000000000000000000;;								SecurityContext: &api.SecurityContext{},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				wantAllowed: false,
0000000000000000000000000000000000000000;;				wantErr:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test: "Good container, bad init container",
0000000000000000000000000000000000000000;;				pod: &api.Pod{
0000000000000000000000000000000000000000;;					Spec: api.PodSpec{
0000000000000000000000000000000000000000;;						ServiceAccountName: "default",
0000000000000000000000000000000000000000;;						SecurityContext:    &api.PodSecurityContext{},
0000000000000000000000000000000000000000;;						Containers: []api.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image:           "good",
0000000000000000000000000000000000000000;;								SecurityContext: &api.SecurityContext{},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						InitContainers: []api.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image:           "bad",
0000000000000000000000000000000000000000;;								SecurityContext: &api.SecurityContext{},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				wantAllowed: false,
0000000000000000000000000000000000000000;;				wantErr:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test: "Bad container, good init container",
0000000000000000000000000000000000000000;;				pod: &api.Pod{
0000000000000000000000000000000000000000;;					Spec: api.PodSpec{
0000000000000000000000000000000000000000;;						ServiceAccountName: "default",
0000000000000000000000000000000000000000;;						SecurityContext:    &api.PodSecurityContext{},
0000000000000000000000000000000000000000;;						Containers: []api.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image:           "bad",
0000000000000000000000000000000000000000;;								SecurityContext: &api.SecurityContext{},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						InitContainers: []api.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image:           "good",
0000000000000000000000000000000000000000;;								SecurityContext: &api.SecurityContext{},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				wantAllowed: false,
0000000000000000000000000000000000000000;;				wantErr:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test: "Good container, good init container",
0000000000000000000000000000000000000000;;				pod: &api.Pod{
0000000000000000000000000000000000000000;;					Spec: api.PodSpec{
0000000000000000000000000000000000000000;;						ServiceAccountName: "default",
0000000000000000000000000000000000000000;;						SecurityContext:    &api.PodSecurityContext{},
0000000000000000000000000000000000000000;;						Containers: []api.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image:           "good",
0000000000000000000000000000000000000000;;								SecurityContext: &api.SecurityContext{},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						InitContainers: []api.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image:           "good",
0000000000000000000000000000000000000000;;								SecurityContext: &api.SecurityContext{},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				wantAllowed: true,
0000000000000000000000000000000000000000;;				wantErr:     false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tt := range tests {
0000000000000000000000000000000000000000;;			// Use a closure so defer statements trigger between loop iterations.
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				service := new(mockService)
0000000000000000000000000000000000000000;;				service.statusCode = 200
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				server, err := NewTestServer(service, serverCert, serverKey, caCert)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: failed to create server: %v", tt.test, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				wh, err := newImagePolicyWebhook(server.URL, clientCert, clientKey, caCert, 0, false)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: failed to create client: %v", tt.test, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				attr := admission.NewAttributesRecord(tt.pod, nil, api.Kind("Pod").WithVersion("version"), "namespace", "", api.Resource("pods").WithVersion("version"), "", admission.Create, &user.DefaultInfo{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = wh.Admit(attr)
0000000000000000000000000000000000000000;;				if tt.wantAllowed {
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("expected successful admission: %s", tt.test)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						t.Errorf("expected failed admission: %s", tt.test)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if tt.wantErr {
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						t.Errorf("expected error making admission request: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: failed to admit: %v", tt.test, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDefaultAllow(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			test                               string
0000000000000000000000000000000000000000;;			pod                                *api.Pod
0000000000000000000000000000000000000000;;			wantAllowed, wantErr, defaultAllow bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:         "DefaultAllow = true, backend unreachable, bad image",
0000000000000000000000000000000000000000;;				pod:          goodPod("bad"),
0000000000000000000000000000000000000000;;				defaultAllow: true,
0000000000000000000000000000000000000000;;				wantAllowed:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:         "DefaultAllow = true, backend unreachable, good image",
0000000000000000000000000000000000000000;;				pod:          goodPod("good"),
0000000000000000000000000000000000000000;;				defaultAllow: true,
0000000000000000000000000000000000000000;;				wantAllowed:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:         "DefaultAllow = false, backend unreachable, good image",
0000000000000000000000000000000000000000;;				pod:          goodPod("good"),
0000000000000000000000000000000000000000;;				defaultAllow: false,
0000000000000000000000000000000000000000;;				wantAllowed:  false,
0000000000000000000000000000000000000000;;				wantErr:      true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:         "DefaultAllow = false, backend unreachable, bad image",
0000000000000000000000000000000000000000;;				pod:          goodPod("bad"),
0000000000000000000000000000000000000000;;				defaultAllow: false,
0000000000000000000000000000000000000000;;				wantAllowed:  false,
0000000000000000000000000000000000000000;;				wantErr:      true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tt := range tests {
0000000000000000000000000000000000000000;;			// Use a closure so defer statements trigger between loop iterations.
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				service := new(mockService)
0000000000000000000000000000000000000000;;				service.statusCode = 500
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				server, err := NewTestServer(service, serverCert, serverKey, caCert)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: failed to create server: %v", tt.test, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				wh, err := newImagePolicyWebhook(server.URL, clientCert, clientKey, caCert, 0, tt.defaultAllow)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: failed to create client: %v", tt.test, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				attr := admission.NewAttributesRecord(tt.pod, nil, api.Kind("Pod").WithVersion("version"), "namespace", "", api.Resource("pods").WithVersion("version"), "", admission.Create, &user.DefaultInfo{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = wh.Admit(attr)
0000000000000000000000000000000000000000;;				if tt.wantAllowed {
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("expected successful admission")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						t.Errorf("expected failed admission")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if tt.wantErr {
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						t.Errorf("expected error making admission request: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: failed to admit: %v", tt.test, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A service that can record annotations sent to it
0000000000000000000000000000000000000000;;	type annotationService struct {
0000000000000000000000000000000000000000;;		annotations map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *annotationService) Review(r *v1alpha1.ImageReview) {
0000000000000000000000000000000000000000;;		a.annotations = make(map[string]string)
0000000000000000000000000000000000000000;;		for k, v := range r.Spec.Annotations {
0000000000000000000000000000000000000000;;			a.annotations[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.Status.Allowed = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (a *annotationService) HTTPStatusCode() int            { return 200 }
0000000000000000000000000000000000000000;;	func (a *annotationService) Annotations() map[string]string { return a.annotations }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAnnotationFiltering(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			test           string
0000000000000000000000000000000000000000;;			annotations    map[string]string
0000000000000000000000000000000000000000;;			outAnnotations map[string]string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test: "all annotations filtered out",
0000000000000000000000000000000000000000;;				annotations: map[string]string{
0000000000000000000000000000000000000000;;					"test":    "test",
0000000000000000000000000000000000000000;;					"another": "annotation",
0000000000000000000000000000000000000000;;					"":        "",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				outAnnotations: map[string]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test: "image-policy annotations allowed",
0000000000000000000000000000000000000000;;				annotations: map[string]string{
0000000000000000000000000000000000000000;;					"my.image-policy.k8s.io/test":     "test",
0000000000000000000000000000000000000000;;					"other.image-policy.k8s.io/test2": "annotation",
0000000000000000000000000000000000000000;;					"test":    "test",
0000000000000000000000000000000000000000;;					"another": "another",
0000000000000000000000000000000000000000;;					"":        "",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				outAnnotations: map[string]string{
0000000000000000000000000000000000000000;;					"my.image-policy.k8s.io/test":     "test",
0000000000000000000000000000000000000000;;					"other.image-policy.k8s.io/test2": "annotation",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tt := range tests {
0000000000000000000000000000000000000000;;			// Use a closure so defer statements trigger between loop iterations.
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				service := new(annotationService)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				server, err := NewTestServer(service, serverCert, serverKey, caCert)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: failed to create server: %v", tt.test, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				wh, err := newImagePolicyWebhook(server.URL, clientCert, clientKey, caCert, 0, true)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: failed to create client: %v", tt.test, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				pod := goodPod("test")
0000000000000000000000000000000000000000;;				pod.Annotations = tt.annotations
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				attr := admission.NewAttributesRecord(pod, nil, api.Kind("Pod").WithVersion("version"), "namespace", "", api.Resource("pods").WithVersion("version"), "", admission.Create, &user.DefaultInfo{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = wh.Admit(attr)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("expected successful admission")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(tt.outAnnotations, service.Annotations()) {
0000000000000000000000000000000000000000;;					t.Errorf("expected annotations sent to webhook: %v to match expected: %v", service.Annotations(), tt.outAnnotations)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func goodPod(containerID string) *api.Pod {
0000000000000000000000000000000000000000;;		return &api.Pod{
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				ServiceAccountName: "default",
0000000000000000000000000000000000000000;;				SecurityContext:    &api.PodSecurityContext{},
0000000000000000000000000000000000000000;;				Containers: []api.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Image:           containerID,
0000000000000000000000000000000000000000;;						SecurityContext: &api.SecurityContext{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
