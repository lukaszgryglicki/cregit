0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
b4459401c908d3e5c104880a7fcd871960992add;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resourcequota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/internalversion"
0000000000000000000000000000000000000000;;		kubeapiserveradmission "k8s.io/kubernetes/pkg/kubeapiserver/admission"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/quota"
0000000000000000000000000000000000000000;;		resourcequotaapi "k8s.io/kubernetes/plugin/pkg/admission/resourcequota/apis/resourcequota"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/admission/resourcequota/apis/resourcequota/validation"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register registers a plugin
0000000000000000000000000000000000000000;;	func Register(plugins *admission.Plugins) {
0000000000000000000000000000000000000000;;		plugins.Register("ResourceQuota",
0000000000000000000000000000000000000000;;			func(config io.Reader) (admission.Interface, error) {
0000000000000000000000000000000000000000;;				// load the configuration provided (if any)
0000000000000000000000000000000000000000;;				configuration, err := LoadConfiguration(config)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// validate the configuration (if any)
0000000000000000000000000000000000000000;;				if configuration != nil {
0000000000000000000000000000000000000000;;					if errs := validation.ValidateConfiguration(configuration); len(errs) != 0 {
0000000000000000000000000000000000000000;;						return nil, errs.ToAggregate()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return NewResourceQuota(configuration, 5, make(chan struct{}))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// quotaAdmission implements an admission controller that can enforce quota constraints
0000000000000000000000000000000000000000;;	type quotaAdmission struct {
0000000000000000000000000000000000000000;;		*admission.Handler
0000000000000000000000000000000000000000;;		config        *resourcequotaapi.Configuration
0000000000000000000000000000000000000000;;		stopCh        <-chan struct{}
0000000000000000000000000000000000000000;;		registry      quota.Registry
0000000000000000000000000000000000000000;;		numEvaluators int
0000000000000000000000000000000000000000;;		quotaAccessor *quotaAccessor
0000000000000000000000000000000000000000;;		evaluator     Evaluator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = kubeapiserveradmission.WantsInternalKubeClientSet(&quotaAdmission{})
0000000000000000000000000000000000000000;;	var _ = kubeapiserveradmission.WantsQuotaRegistry(&quotaAdmission{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type liveLookupEntry struct {
0000000000000000000000000000000000000000;;		expiry time.Time
0000000000000000000000000000000000000000;;		items  []*api.ResourceQuota
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewResourceQuota configures an admission controller that can enforce quota constraints
0000000000000000000000000000000000000000;;	// using the provided registry.  The registry must have the capability to handle group/kinds that
0000000000000000000000000000000000000000;;	// are persisted by the server this admission controller is intercepting
0000000000000000000000000000000000000000;;	func NewResourceQuota(config *resourcequotaapi.Configuration, numEvaluators int, stopCh <-chan struct{}) (admission.Interface, error) {
0000000000000000000000000000000000000000;;		quotaAccessor, err := newQuotaAccessor()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &quotaAdmission{
0000000000000000000000000000000000000000;;			Handler:       admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			stopCh:        stopCh,
0000000000000000000000000000000000000000;;			numEvaluators: numEvaluators,
0000000000000000000000000000000000000000;;			config:        config,
0000000000000000000000000000000000000000;;			quotaAccessor: quotaAccessor,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *quotaAdmission) SetInternalKubeClientSet(client internalclientset.Interface) {
0000000000000000000000000000000000000000;;		a.quotaAccessor.client = client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *quotaAdmission) SetInternalKubeInformerFactory(f informers.SharedInformerFactory) {
0000000000000000000000000000000000000000;;		a.quotaAccessor.lister = f.Core().InternalVersion().ResourceQuotas().Lister()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *quotaAdmission) SetQuotaRegistry(r quota.Registry) {
0000000000000000000000000000000000000000;;		a.registry = r
0000000000000000000000000000000000000000;;		a.evaluator = NewQuotaEvaluator(a.quotaAccessor, a.registry, nil, a.config, a.numEvaluators, a.stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate ensures an authorizer is set.
0000000000000000000000000000000000000000;;	func (a *quotaAdmission) Validate() error {
0000000000000000000000000000000000000000;;		if a.quotaAccessor == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing quotaAccessor")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.quotaAccessor.client == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing quotaAccessor.client")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.quotaAccessor.lister == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing quotaAccessor.lister")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.registry == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing registry")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.evaluator == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing evaluator")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Admit makes admission decisions while enforcing quota
0000000000000000000000000000000000000000;;	func (a *quotaAdmission) Admit(attr admission.Attributes) (err error) {
0000000000000000000000000000000000000000;;		// ignore all operations that correspond to sub-resource actions
0000000000000000000000000000000000000000;;		if attr.GetSubresource() != "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a.evaluator.Evaluate(attr)
0000000000000000000000000000000000000000;;	}
