0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1235c082585357ece58374d0bbe98308109a6d9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resourcequota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/quota"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/util/workqueue/prometheus" // for workqueue metric registration
0000000000000000000000000000000000000000;;		resourcequotaapi "k8s.io/kubernetes/plugin/pkg/admission/resourcequota/apis/resourcequota"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Evaluator is used to see if quota constraints are satisfied.
0000000000000000000000000000000000000000;;	type Evaluator interface {
0000000000000000000000000000000000000000;;		// Evaluate takes an operation and checks to see if quota constraints are satisfied.  It returns an error if they are not.
0000000000000000000000000000000000000000;;		// The default implementation process related operations in chunks when possible.
0000000000000000000000000000000000000000;;		Evaluate(a admission.Attributes) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type quotaEvaluator struct {
0000000000000000000000000000000000000000;;		quotaAccessor QuotaAccessor
0000000000000000000000000000000000000000;;		// lockAcquisitionFunc acquires any required locks and returns a cleanup method to defer
0000000000000000000000000000000000000000;;		lockAcquisitionFunc func([]api.ResourceQuota) func()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// registry that knows how to measure usage for objects
0000000000000000000000000000000000000000;;		registry quota.Registry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO these are used together to bucket items by namespace and then batch them up for processing.
0000000000000000000000000000000000000000;;		// The technique is valuable for rollup activities to avoid fanout and reduce resource contention.
0000000000000000000000000000000000000000;;		// We could move this into a library if another component needed it.
0000000000000000000000000000000000000000;;		// queue is indexed by namespace, so that we bundle up on a per-namespace basis
0000000000000000000000000000000000000000;;		queue      *workqueue.Type
0000000000000000000000000000000000000000;;		workLock   sync.Mutex
0000000000000000000000000000000000000000;;		work       map[string][]*admissionWaiter
0000000000000000000000000000000000000000;;		dirtyWork  map[string][]*admissionWaiter
0000000000000000000000000000000000000000;;		inProgress sets.String
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// controls the run method so that we can cleanly conform to the Evaluator interface
0000000000000000000000000000000000000000;;		workers int
0000000000000000000000000000000000000000;;		stopCh  <-chan struct{}
0000000000000000000000000000000000000000;;		init    sync.Once
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// lets us know what resources are limited by default
0000000000000000000000000000000000000000;;		config *resourcequotaapi.Configuration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type admissionWaiter struct {
0000000000000000000000000000000000000000;;		attributes admission.Attributes
0000000000000000000000000000000000000000;;		finished   chan struct{}
0000000000000000000000000000000000000000;;		result     error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type defaultDeny struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (defaultDeny) Error() string {
0000000000000000000000000000000000000000;;		return "DEFAULT DENY"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsDefaultDeny returns true if the error is defaultDeny
0000000000000000000000000000000000000000;;	func IsDefaultDeny(err error) bool {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, ok := err.(defaultDeny)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newAdmissionWaiter(a admission.Attributes) *admissionWaiter {
0000000000000000000000000000000000000000;;		return &admissionWaiter{
0000000000000000000000000000000000000000;;			attributes: a,
0000000000000000000000000000000000000000;;			finished:   make(chan struct{}),
0000000000000000000000000000000000000000;;			result:     defaultDeny{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewQuotaEvaluator configures an admission controller that can enforce quota constraints
0000000000000000000000000000000000000000;;	// using the provided registry.  The registry must have the capability to handle group/kinds that
0000000000000000000000000000000000000000;;	// are persisted by the server this admission controller is intercepting
0000000000000000000000000000000000000000;;	func NewQuotaEvaluator(quotaAccessor QuotaAccessor, registry quota.Registry, lockAcquisitionFunc func([]api.ResourceQuota) func(), config *resourcequotaapi.Configuration, workers int, stopCh <-chan struct{}) Evaluator {
0000000000000000000000000000000000000000;;		// if we get a nil config, just create an empty default.
0000000000000000000000000000000000000000;;		if config == nil {
0000000000000000000000000000000000000000;;			config = &resourcequotaapi.Configuration{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &quotaEvaluator{
0000000000000000000000000000000000000000;;			quotaAccessor:       quotaAccessor,
0000000000000000000000000000000000000000;;			lockAcquisitionFunc: lockAcquisitionFunc,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			registry: registry,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			queue:      workqueue.NewNamed("admission_quota_controller"),
0000000000000000000000000000000000000000;;			work:       map[string][]*admissionWaiter{},
0000000000000000000000000000000000000000;;			dirtyWork:  map[string][]*admissionWaiter{},
0000000000000000000000000000000000000000;;			inProgress: sets.String{},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			workers: workers,
0000000000000000000000000000000000000000;;			stopCh:  stopCh,
0000000000000000000000000000000000000000;;			config:  config,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run begins watching and syncing.
0000000000000000000000000000000000000000;;	func (e *quotaEvaluator) run() {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < e.workers; i++ {
0000000000000000000000000000000000000000;;			go wait.Until(e.doWork, time.Second, e.stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-e.stopCh
0000000000000000000000000000000000000000;;		glog.Infof("Shutting down quota evaluator")
0000000000000000000000000000000000000000;;		e.queue.ShutDown()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *quotaEvaluator) doWork() {
0000000000000000000000000000000000000000;;		workFunc := func() bool {
0000000000000000000000000000000000000000;;			ns, admissionAttributes, quit := e.getWork()
0000000000000000000000000000000000000000;;			if quit {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer e.completeWork(ns)
0000000000000000000000000000000000000000;;			if len(admissionAttributes) == 0 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			e.checkAttributes(ns, admissionAttributes)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if quit := workFunc(); quit {
0000000000000000000000000000000000000000;;				glog.Infof("quota evaluator worker shutdown")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkAttributes iterates evaluates all the waiting admissionAttributes.  It will always notify all waiters
0000000000000000000000000000000000000000;;	// before returning.  The default is to deny.
0000000000000000000000000000000000000000;;	func (e *quotaEvaluator) checkAttributes(ns string, admissionAttributes []*admissionWaiter) {
0000000000000000000000000000000000000000;;		// notify all on exit
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			for _, admissionAttribute := range admissionAttributes {
0000000000000000000000000000000000000000;;				close(admissionAttribute.finished)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		quotas, err := e.quotaAccessor.GetQuotas(ns)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			for _, admissionAttribute := range admissionAttributes {
0000000000000000000000000000000000000000;;				admissionAttribute.result = err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if limited resources are disabled, we can just return safely when there are no quotas.
0000000000000000000000000000000000000000;;		limitedResourcesDisabled := len(e.config.LimitedResources) == 0
0000000000000000000000000000000000000000;;		if len(quotas) == 0 && limitedResourcesDisabled {
0000000000000000000000000000000000000000;;			for _, admissionAttribute := range admissionAttributes {
0000000000000000000000000000000000000000;;				admissionAttribute.result = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e.lockAcquisitionFunc != nil {
0000000000000000000000000000000000000000;;			releaseLocks := e.lockAcquisitionFunc(quotas)
0000000000000000000000000000000000000000;;			defer releaseLocks()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e.checkQuotas(quotas, admissionAttributes, 3)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkQuotas checks the admission attributes against the passed quotas.  If a quota applies, it will attempt to update it
0000000000000000000000000000000000000000;;	// AFTER it has checked all the admissionAttributes.  The method breaks down into phase like this:
0000000000000000000000000000000000000000;;	// 0. make a copy of the quotas to act as a "running" quota so we know what we need to update and can still compare against the
0000000000000000000000000000000000000000;;	//    originals
0000000000000000000000000000000000000000;;	// 1. check each admission attribute to see if it fits within *all* the quotas.  If it doesn't fit, mark the waiter as failed
0000000000000000000000000000000000000000;;	//    and the running quota don't change.  If it did fit, check to see if any quota was changed.  It there was no quota change
0000000000000000000000000000000000000000;;	//    mark the waiter as succeeded.  If some quota did change, update the running quotas
0000000000000000000000000000000000000000;;	// 2. If no running quota was changed, return now since no updates are needed.
0000000000000000000000000000000000000000;;	// 3. for each quota that has changed, attempt an update.  If all updates succeeded, update all unset waiters to success status and return.  If the some
0000000000000000000000000000000000000000;;	//    updates failed on conflict errors and we have retries left, re-get the failed quota from our cache for the latest version
0000000000000000000000000000000000000000;;	//    and recurse into this method with the subset.  It's safe for us to evaluate ONLY the subset, because the other quota
0000000000000000000000000000000000000000;;	//    documents for these waiters have already been evaluated.  Step 1, will mark all the ones that should already have succeeded.
0000000000000000000000000000000000000000;;	func (e *quotaEvaluator) checkQuotas(quotas []api.ResourceQuota, admissionAttributes []*admissionWaiter, remainingRetries int) {
0000000000000000000000000000000000000000;;		// yet another copy to compare against originals to see if we actually have deltas
0000000000000000000000000000000000000000;;		originalQuotas, err := copyQuotas(quotas)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		atLeastOneChanged := false
0000000000000000000000000000000000000000;;		for i := range admissionAttributes {
0000000000000000000000000000000000000000;;			admissionAttribute := admissionAttributes[i]
0000000000000000000000000000000000000000;;			newQuotas, err := e.checkRequest(quotas, admissionAttribute.attributes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				admissionAttribute.result = err
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if the new quotas are the same as the old quotas, then this particular one doesn't issue any updates
0000000000000000000000000000000000000000;;			// that means that no quota docs applied, so it can get a pass
0000000000000000000000000000000000000000;;			atLeastOneChangeForThisWaiter := false
0000000000000000000000000000000000000000;;			for j := range newQuotas {
0000000000000000000000000000000000000000;;				if !quota.Equals(quotas[j].Status.Used, newQuotas[j].Status.Used) {
0000000000000000000000000000000000000000;;					atLeastOneChanged = true
0000000000000000000000000000000000000000;;					atLeastOneChangeForThisWaiter = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !atLeastOneChangeForThisWaiter {
0000000000000000000000000000000000000000;;				admissionAttribute.result = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			quotas = newQuotas
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if none of the requests changed anything, there's no reason to issue an update, just fail them all now
0000000000000000000000000000000000000000;;		if !atLeastOneChanged {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// now go through and try to issue updates.  Things get a little weird here:
0000000000000000000000000000000000000000;;		// 1. check to see if the quota changed.  If not, skip.
0000000000000000000000000000000000000000;;		// 2. if the quota changed and the update passes, be happy
0000000000000000000000000000000000000000;;		// 3. if the quota changed and the update fails, add the original to a retry list
0000000000000000000000000000000000000000;;		var updatedFailedQuotas []api.ResourceQuota
0000000000000000000000000000000000000000;;		var lastErr error
0000000000000000000000000000000000000000;;		for i := range quotas {
0000000000000000000000000000000000000000;;			newQuota := quotas[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if this quota didn't have its status changed, skip it
0000000000000000000000000000000000000000;;			if quota.Equals(originalQuotas[i].Status.Used, newQuota.Status.Used) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := e.quotaAccessor.UpdateQuotaStatus(&newQuota); err != nil {
0000000000000000000000000000000000000000;;				updatedFailedQuotas = append(updatedFailedQuotas, newQuota)
0000000000000000000000000000000000000000;;				lastErr = err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(updatedFailedQuotas) == 0 {
0000000000000000000000000000000000000000;;			// all the updates succeeded.  At this point, anything with the default deny error was just waiting to
0000000000000000000000000000000000000000;;			// get a successful update, so we can mark and notify
0000000000000000000000000000000000000000;;			for _, admissionAttribute := range admissionAttributes {
0000000000000000000000000000000000000000;;				if IsDefaultDeny(admissionAttribute.result) {
0000000000000000000000000000000000000000;;					admissionAttribute.result = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// at this point, errors are fatal.  Update all waiters without status to failed and return
0000000000000000000000000000000000000000;;		if remainingRetries <= 0 {
0000000000000000000000000000000000000000;;			for _, admissionAttribute := range admissionAttributes {
0000000000000000000000000000000000000000;;				if IsDefaultDeny(admissionAttribute.result) {
0000000000000000000000000000000000000000;;					admissionAttribute.result = lastErr
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this retry logic has the same bug that its possible to be checking against quota in a state that never actually exists where
0000000000000000000000000000000000000000;;		// you've added a new documented, then updated an old one, your resource matches both and you're only checking one
0000000000000000000000000000000000000000;;		// updates for these quota names failed.  Get the current quotas in the namespace, compare by name, check to see if the
0000000000000000000000000000000000000000;;		// resource versions have changed.  If not, we're going to fall through an fail everything.  If they all have, then we can try again
0000000000000000000000000000000000000000;;		newQuotas, err := e.quotaAccessor.GetQuotas(quotas[0].Namespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// this means that updates failed.  Anything with a default deny error has failed and we need to let them know
0000000000000000000000000000000000000000;;			for _, admissionAttribute := range admissionAttributes {
0000000000000000000000000000000000000000;;				if IsDefaultDeny(admissionAttribute.result) {
0000000000000000000000000000000000000000;;					admissionAttribute.result = lastErr
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this logic goes through our cache to find the new version of all quotas that failed update.  If something has been removed
0000000000000000000000000000000000000000;;		// it is skipped on this retry.  After all, you removed it.
0000000000000000000000000000000000000000;;		quotasToCheck := []api.ResourceQuota{}
0000000000000000000000000000000000000000;;		for _, newQuota := range newQuotas {
0000000000000000000000000000000000000000;;			for _, oldQuota := range updatedFailedQuotas {
0000000000000000000000000000000000000000;;				if newQuota.Name == oldQuota.Name {
0000000000000000000000000000000000000000;;					quotasToCheck = append(quotasToCheck, newQuota)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.checkQuotas(quotasToCheck, admissionAttributes, remainingRetries-1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func copyQuotas(in []api.ResourceQuota) ([]api.ResourceQuota, error) {
0000000000000000000000000000000000000000;;		out := make([]api.ResourceQuota, 0, len(in))
0000000000000000000000000000000000000000;;		for _, quota := range in {
0000000000000000000000000000000000000000;;			copied, err := api.Scheme.Copy(&quota)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out = append(out, *copied.(*api.ResourceQuota))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// filterLimitedResourcesByGroupResource filters the input that match the specified groupResource
0000000000000000000000000000000000000000;;	func filterLimitedResourcesByGroupResource(input []resourcequotaapi.LimitedResource, groupResource schema.GroupResource) []resourcequotaapi.LimitedResource {
0000000000000000000000000000000000000000;;		result := []resourcequotaapi.LimitedResource{}
0000000000000000000000000000000000000000;;		for i := range input {
0000000000000000000000000000000000000000;;			limitedResource := input[i]
0000000000000000000000000000000000000000;;			limitedGroupResource := schema.GroupResource{Group: limitedResource.APIGroup, Resource: limitedResource.Resource}
0000000000000000000000000000000000000000;;			if limitedGroupResource == groupResource {
0000000000000000000000000000000000000000;;				result = append(result, limitedResource)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// limitedByDefault determines from the specified usage and limitedResources the set of resources names
0000000000000000000000000000000000000000;;	// that must be present in a covering quota.  It returns empty set if it was unable to determine if
0000000000000000000000000000000000000000;;	// a resource was not limited by default.
0000000000000000000000000000000000000000;;	func limitedByDefault(usage api.ResourceList, limitedResources []resourcequotaapi.LimitedResource) []api.ResourceName {
0000000000000000000000000000000000000000;;		result := []api.ResourceName{}
0000000000000000000000000000000000000000;;		for _, limitedResource := range limitedResources {
0000000000000000000000000000000000000000;;			for k, v := range usage {
0000000000000000000000000000000000000000;;				// if a resource is consumed, we need to check if it matches on the limited resource list.
0000000000000000000000000000000000000000;;				if v.Sign() == 1 {
0000000000000000000000000000000000000000;;					// if we get a match, we add it to limited set
0000000000000000000000000000000000000000;;					for _, matchContain := range limitedResource.MatchContains {
0000000000000000000000000000000000000000;;						if strings.Contains(string(k), matchContain) {
0000000000000000000000000000000000000000;;							result = append(result, k)
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkRequest verifies that the request does not exceed any quota constraint. it returns a copy of quotas not yet persisted
0000000000000000000000000000000000000000;;	// that capture what the usage would be if the request succeeded.  It return an error if there is insufficient quota to satisfy the request
0000000000000000000000000000000000000000;;	func (e *quotaEvaluator) checkRequest(quotas []api.ResourceQuota, a admission.Attributes) ([]api.ResourceQuota, error) {
0000000000000000000000000000000000000000;;		namespace := a.GetNamespace()
0000000000000000000000000000000000000000;;		evaluators := e.registry.Evaluators()
0000000000000000000000000000000000000000;;		evaluator, found := evaluators[a.GetKind().GroupKind()]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return quotas, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		op := a.GetOperation()
0000000000000000000000000000000000000000;;		if !evaluator.Handles(op) {
0000000000000000000000000000000000000000;;			return quotas, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we have limited resources enabled for this resource, always calculate usage
0000000000000000000000000000000000000000;;		inputObject := a.GetObject()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// determine the set of resource names that must exist in a covering quota
0000000000000000000000000000000000000000;;		limitedResourceNames := []api.ResourceName{}
0000000000000000000000000000000000000000;;		limitedResources := filterLimitedResourcesByGroupResource(e.config.LimitedResources, a.GetResource().GroupResource())
0000000000000000000000000000000000000000;;		if len(limitedResources) > 0 {
0000000000000000000000000000000000000000;;			deltaUsage, err := evaluator.Usage(inputObject)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return quotas, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			limitedResourceNames = limitedByDefault(deltaUsage, limitedResources)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		limitedResourceNamesSet := quota.ToSet(limitedResourceNames)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// find the set of quotas that are pertinent to this request
0000000000000000000000000000000000000000;;		// reject if we match the quota, but usage is not calculated yet
0000000000000000000000000000000000000000;;		// reject if the input object does not satisfy quota constraints
0000000000000000000000000000000000000000;;		// if there are no pertinent quotas, we can just return
0000000000000000000000000000000000000000;;		interestingQuotaIndexes := []int{}
0000000000000000000000000000000000000000;;		// track the cumulative set of resources that were required across all quotas
0000000000000000000000000000000000000000;;		// this is needed to know if we have satisfied any constraints where consumption
0000000000000000000000000000000000000000;;		// was limited by default.
0000000000000000000000000000000000000000;;		restrictedResourcesSet := sets.String{}
0000000000000000000000000000000000000000;;		for i := range quotas {
0000000000000000000000000000000000000000;;			resourceQuota := quotas[i]
0000000000000000000000000000000000000000;;			match, err := evaluator.Matches(&resourceQuota, inputObject)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return quotas, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !match {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			hardResources := quota.ResourceNames(resourceQuota.Status.Hard)
0000000000000000000000000000000000000000;;			restrictedResources := evaluator.MatchingResources(hardResources)
0000000000000000000000000000000000000000;;			if err := evaluator.Constraints(restrictedResources, inputObject); err != nil {
0000000000000000000000000000000000000000;;				return nil, admission.NewForbidden(a, fmt.Errorf("failed quota: %s: %v", resourceQuota.Name, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !hasUsageStats(&resourceQuota) {
0000000000000000000000000000000000000000;;				return nil, admission.NewForbidden(a, fmt.Errorf("status unknown for quota: %s", resourceQuota.Name))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			interestingQuotaIndexes = append(interestingQuotaIndexes, i)
0000000000000000000000000000000000000000;;			localRestrictedResourcesSet := quota.ToSet(restrictedResources)
0000000000000000000000000000000000000000;;			restrictedResourcesSet.Insert(localRestrictedResourcesSet.List()...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify that for every resource that had limited by default consumption
0000000000000000000000000000000000000000;;		// enabled that there was a corresponding quota that covered its use.
0000000000000000000000000000000000000000;;		// if not, we reject the request.
0000000000000000000000000000000000000000;;		hasNoCoveringQuota := limitedResourceNamesSet.Difference(restrictedResourcesSet)
0000000000000000000000000000000000000000;;		if len(hasNoCoveringQuota) > 0 {
0000000000000000000000000000000000000000;;			return quotas, fmt.Errorf("insufficient quota to consume: %v", strings.Join(hasNoCoveringQuota.List(), ","))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(interestingQuotaIndexes) == 0 {
0000000000000000000000000000000000000000;;			return quotas, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Usage of some resources cannot be counted in isolation. For example, when
0000000000000000000000000000000000000000;;		// the resource represents a number of unique references to external
0000000000000000000000000000000000000000;;		// resource. In such a case an evaluator needs to process other objects in
0000000000000000000000000000000000000000;;		// the same namespace which needs to be known.
0000000000000000000000000000000000000000;;		if accessor, err := meta.Accessor(inputObject); namespace != "" && err == nil {
0000000000000000000000000000000000000000;;			if accessor.GetNamespace() == "" {
0000000000000000000000000000000000000000;;				accessor.SetNamespace(namespace)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// there is at least one quota that definitely matches our object
0000000000000000000000000000000000000000;;		// as a result, we need to measure the usage of this object for quota
0000000000000000000000000000000000000000;;		// on updates, we need to subtract the previous measured usage
0000000000000000000000000000000000000000;;		// if usage shows no change, just return since it has no impact on quota
0000000000000000000000000000000000000000;;		deltaUsage, err := evaluator.Usage(inputObject)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return quotas, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure that usage for input object is never negative (this would mean a resource made a negative resource requirement)
0000000000000000000000000000000000000000;;		if negativeUsage := quota.IsNegative(deltaUsage); len(negativeUsage) > 0 {
0000000000000000000000000000000000000000;;			return nil, admission.NewForbidden(a, fmt.Errorf("quota usage is negative for resource(s): %s", prettyPrintResourceNames(negativeUsage)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if admission.Update == op {
0000000000000000000000000000000000000000;;			prevItem := a.GetOldObject()
0000000000000000000000000000000000000000;;			if prevItem == nil {
0000000000000000000000000000000000000000;;				return nil, admission.NewForbidden(a, fmt.Errorf("unable to get previous usage since prior version of object was not found"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if we can definitively determine that this is not a case of "create on update",
0000000000000000000000000000000000000000;;			// then charge based on the delta.  Otherwise, bill the maximum
0000000000000000000000000000000000000000;;			metadata, err := meta.Accessor(prevItem)
0000000000000000000000000000000000000000;;			if err == nil && len(metadata.GetResourceVersion()) > 0 {
0000000000000000000000000000000000000000;;				prevUsage, innerErr := evaluator.Usage(prevItem)
0000000000000000000000000000000000000000;;				if innerErr != nil {
0000000000000000000000000000000000000000;;					return quotas, innerErr
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				deltaUsage = quota.Subtract(deltaUsage, prevUsage)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if quota.IsZero(deltaUsage) {
0000000000000000000000000000000000000000;;			return quotas, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		outQuotas, err := copyQuotas(quotas)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, index := range interestingQuotaIndexes {
0000000000000000000000000000000000000000;;			resourceQuota := outQuotas[index]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			hardResources := quota.ResourceNames(resourceQuota.Status.Hard)
0000000000000000000000000000000000000000;;			requestedUsage := quota.Mask(deltaUsage, hardResources)
0000000000000000000000000000000000000000;;			newUsage := quota.Add(resourceQuota.Status.Used, requestedUsage)
0000000000000000000000000000000000000000;;			maskedNewUsage := quota.Mask(newUsage, quota.ResourceNames(requestedUsage))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if allowed, exceeded := quota.LessThanOrEqual(maskedNewUsage, resourceQuota.Status.Hard); !allowed {
0000000000000000000000000000000000000000;;				failedRequestedUsage := quota.Mask(requestedUsage, exceeded)
0000000000000000000000000000000000000000;;				failedUsed := quota.Mask(resourceQuota.Status.Used, exceeded)
0000000000000000000000000000000000000000;;				failedHard := quota.Mask(resourceQuota.Status.Hard, exceeded)
0000000000000000000000000000000000000000;;				return nil, admission.NewForbidden(a,
0000000000000000000000000000000000000000;;					fmt.Errorf("exceeded quota: %s, requested: %s, used: %s, limited: %s",
0000000000000000000000000000000000000000;;						resourceQuota.Name,
0000000000000000000000000000000000000000;;						prettyPrint(failedRequestedUsage),
0000000000000000000000000000000000000000;;						prettyPrint(failedUsed),
0000000000000000000000000000000000000000;;						prettyPrint(failedHard)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// update to the new usage number
0000000000000000000000000000000000000000;;			outQuotas[index].Status.Used = newUsage
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return outQuotas, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *quotaEvaluator) Evaluate(a admission.Attributes) error {
0000000000000000000000000000000000000000;;		e.init.Do(func() {
0000000000000000000000000000000000000000;;			go e.run()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we do not know how to evaluate use for this kind, just ignore
0000000000000000000000000000000000000000;;		evaluators := e.registry.Evaluators()
0000000000000000000000000000000000000000;;		evaluator, found := evaluators[a.GetKind().GroupKind()]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// for this kind, check if the operation could mutate any quota resources
0000000000000000000000000000000000000000;;		// if no resources tracked by quota are impacted, then just return
0000000000000000000000000000000000000000;;		op := a.GetOperation()
0000000000000000000000000000000000000000;;		if !evaluator.Handles(op) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waiter := newAdmissionWaiter(a)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e.addWork(waiter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait for completion or timeout
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-waiter.finished:
0000000000000000000000000000000000000000;;		case <-time.After(10 * time.Second):
0000000000000000000000000000000000000000;;			return fmt.Errorf("timeout")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return waiter.result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *quotaEvaluator) addWork(a *admissionWaiter) {
0000000000000000000000000000000000000000;;		e.workLock.Lock()
0000000000000000000000000000000000000000;;		defer e.workLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := a.attributes.GetNamespace()
0000000000000000000000000000000000000000;;		// this Add can trigger a Get BEFORE the work is added to a list, but this is ok because the getWork routine
0000000000000000000000000000000000000000;;		// waits the worklock before retrieving the work to do, so the writes in this method will be observed
0000000000000000000000000000000000000000;;		e.queue.Add(ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e.inProgress.Has(ns) {
0000000000000000000000000000000000000000;;			e.dirtyWork[ns] = append(e.dirtyWork[ns], a)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e.work[ns] = append(e.work[ns], a)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *quotaEvaluator) completeWork(ns string) {
0000000000000000000000000000000000000000;;		e.workLock.Lock()
0000000000000000000000000000000000000000;;		defer e.workLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e.queue.Done(ns)
0000000000000000000000000000000000000000;;		e.work[ns] = e.dirtyWork[ns]
0000000000000000000000000000000000000000;;		delete(e.dirtyWork, ns)
0000000000000000000000000000000000000000;;		e.inProgress.Delete(ns)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *quotaEvaluator) getWork() (string, []*admissionWaiter, bool) {
0000000000000000000000000000000000000000;;		uncastNS, shutdown := e.queue.Get()
0000000000000000000000000000000000000000;;		if shutdown {
0000000000000000000000000000000000000000;;			return "", []*admissionWaiter{}, shutdown
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ns := uncastNS.(string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e.workLock.Lock()
0000000000000000000000000000000000000000;;		defer e.workLock.Unlock()
0000000000000000000000000000000000000000;;		// at this point, we know we have a coherent view of e.work.  It is entirely possible
0000000000000000000000000000000000000000;;		// that our workqueue has another item requeued to it, but we'll pick it up early.  This ok
0000000000000000000000000000000000000000;;		// because the next time will go into our dirty list
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		work := e.work[ns]
0000000000000000000000000000000000000000;;		delete(e.work, ns)
0000000000000000000000000000000000000000;;		delete(e.dirtyWork, ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(work) != 0 {
0000000000000000000000000000000000000000;;			e.inProgress.Insert(ns)
0000000000000000000000000000000000000000;;			return ns, work, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e.queue.Done(ns)
0000000000000000000000000000000000000000;;		e.inProgress.Delete(ns)
0000000000000000000000000000000000000000;;		return ns, []*admissionWaiter{}, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// prettyPrint formats a resource list for usage in errors
0000000000000000000000000000000000000000;;	// it outputs resources sorted in increasing order
0000000000000000000000000000000000000000;;	func prettyPrint(item api.ResourceList) string {
0000000000000000000000000000000000000000;;		parts := []string{}
0000000000000000000000000000000000000000;;		keys := []string{}
0000000000000000000000000000000000000000;;		for key := range item {
0000000000000000000000000000000000000000;;			keys = append(keys, string(key))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(keys)
0000000000000000000000000000000000000000;;		for _, key := range keys {
0000000000000000000000000000000000000000;;			value := item[api.ResourceName(key)]
0000000000000000000000000000000000000000;;			constraint := key + "=" + value.String()
0000000000000000000000000000000000000000;;			parts = append(parts, constraint)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(parts, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func prettyPrintResourceNames(a []api.ResourceName) string {
0000000000000000000000000000000000000000;;		values := []string{}
0000000000000000000000000000000000000000;;		for _, value := range a {
0000000000000000000000000000000000000000;;			values = append(values, string(value))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(values)
0000000000000000000000000000000000000000;;		return strings.Join(values, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hasUsageStats returns true if for each hard constraint there is a value for its current usage
0000000000000000000000000000000000000000;;	func hasUsageStats(resourceQuota *api.ResourceQuota) bool {
0000000000000000000000000000000000000000;;		for resourceName := range resourceQuota.Status.Hard {
0000000000000000000000000000000000000000;;			if _, found := resourceQuota.Status.Used[resourceName]; !found {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
