0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f131d529e1c375a6eb7dcd831325d5d6724102ee;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resourcequota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lru "github.com/hashicorp/golang-lru"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/etcd"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		clientset "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/internalversion"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QuotaAccessor abstracts the get/set logic from the rest of the Evaluator.  This could be a test stub, a straight passthrough,
0000000000000000000000000000000000000000;;	// or most commonly a series of deconflicting caches.
0000000000000000000000000000000000000000;;	type QuotaAccessor interface {
0000000000000000000000000000000000000000;;		// UpdateQuotaStatus is called to persist final status.  This method should write to persistent storage.
0000000000000000000000000000000000000000;;		// An error indicates that write didn't complete successfully.
0000000000000000000000000000000000000000;;		UpdateQuotaStatus(newQuota *api.ResourceQuota) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetQuotas gets all possible quotas for a given namespace
0000000000000000000000000000000000000000;;		GetQuotas(namespace string) ([]api.ResourceQuota, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type quotaAccessor struct {
0000000000000000000000000000000000000000;;		client clientset.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// lister can list/get quota objects from a shared informer's cache
0000000000000000000000000000000000000000;;		lister corelisters.ResourceQuotaLister
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// liveLookups holds the last few live lookups we've done to help ammortize cost on repeated lookup failures.
0000000000000000000000000000000000000000;;		// This let's us handle the case of latent caches, by looking up actual results for a namespace on cache miss/no results.
0000000000000000000000000000000000000000;;		// We track the lookup result here so that for repeated requests, we don't look it up very often.
0000000000000000000000000000000000000000;;		liveLookupCache *lru.Cache
0000000000000000000000000000000000000000;;		liveTTL         time.Duration
0000000000000000000000000000000000000000;;		// updatedQuotas holds a cache of quotas that we've updated.  This is used to pull the "really latest" during back to
0000000000000000000000000000000000000000;;		// back quota evaluations that touch the same quota doc.  This only works because we can compare etcd resourceVersions
0000000000000000000000000000000000000000;;		// for the same resource as integers.  Before this change: 22 updates with 12 conflicts.  after this change: 15 updates with 0 conflicts
0000000000000000000000000000000000000000;;		updatedQuotas *lru.Cache
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newQuotaAccessor creates an object that conforms to the QuotaAccessor interface to be used to retrieve quota objects.
0000000000000000000000000000000000000000;;	func newQuotaAccessor() (*quotaAccessor, error) {
0000000000000000000000000000000000000000;;		liveLookupCache, err := lru.New(100)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		updatedCache, err := lru.New(100)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// client and lister will be set when SetInternalKubeClientSet and SetInternalKubeInformerFactory are invoked
0000000000000000000000000000000000000000;;		return &quotaAccessor{
0000000000000000000000000000000000000000;;			liveLookupCache: liveLookupCache,
0000000000000000000000000000000000000000;;			liveTTL:         time.Duration(30 * time.Second),
0000000000000000000000000000000000000000;;			updatedQuotas:   updatedCache,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *quotaAccessor) UpdateQuotaStatus(newQuota *api.ResourceQuota) error {
0000000000000000000000000000000000000000;;		updatedQuota, err := e.client.Core().ResourceQuotas(newQuota.Namespace).UpdateStatus(newQuota)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := newQuota.Namespace + "/" + newQuota.Name
0000000000000000000000000000000000000000;;		e.updatedQuotas.Add(key, updatedQuota)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var etcdVersioner = etcd.APIObjectVersioner{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkCache compares the passed quota against the value in the look-aside cache and returns the newer
0000000000000000000000000000000000000000;;	// if the cache is out of date, it deletes the stale entry.  This only works because of etcd resourceVersions
0000000000000000000000000000000000000000;;	// being monotonically increasing integers
0000000000000000000000000000000000000000;;	func (e *quotaAccessor) checkCache(quota *api.ResourceQuota) *api.ResourceQuota {
0000000000000000000000000000000000000000;;		key := quota.Namespace + "/" + quota.Name
0000000000000000000000000000000000000000;;		uncastCachedQuota, ok := e.updatedQuotas.Get(key)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return quota
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cachedQuota := uncastCachedQuota.(*api.ResourceQuota)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if etcdVersioner.CompareResourceVersion(quota, cachedQuota) >= 0 {
0000000000000000000000000000000000000000;;			e.updatedQuotas.Remove(key)
0000000000000000000000000000000000000000;;			return quota
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cachedQuota
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *quotaAccessor) GetQuotas(namespace string) ([]api.ResourceQuota, error) {
0000000000000000000000000000000000000000;;		// determine if there are any quotas in this namespace
0000000000000000000000000000000000000000;;		// if there are no quotas, we don't need to do anything
0000000000000000000000000000000000000000;;		items, err := e.lister.ResourceQuotas(namespace).List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error resolving quota: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if there are no items held in our indexer, check our live-lookup LRU, if that misses, do the live lookup to prime it.
0000000000000000000000000000000000000000;;		if len(items) == 0 {
0000000000000000000000000000000000000000;;			lruItemObj, ok := e.liveLookupCache.Get(namespace)
0000000000000000000000000000000000000000;;			if !ok || lruItemObj.(liveLookupEntry).expiry.Before(time.Now()) {
0000000000000000000000000000000000000000;;				// TODO: If there are multiple operations at the same time and cache has just expired,
0000000000000000000000000000000000000000;;				// this may cause multiple List operations being issued at the same time.
0000000000000000000000000000000000000000;;				// If there is already in-flight List() for a given namespace, we should wait until
0000000000000000000000000000000000000000;;				// it is finished and cache is updated instead of doing the same, also to avoid
0000000000000000000000000000000000000000;;				// throttling - see #22422 for details.
0000000000000000000000000000000000000000;;				liveList, err := e.client.Core().ResourceQuotas(namespace).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newEntry := liveLookupEntry{expiry: time.Now().Add(e.liveTTL)}
0000000000000000000000000000000000000000;;				for i := range liveList.Items {
0000000000000000000000000000000000000000;;					newEntry.items = append(newEntry.items, &liveList.Items[i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				e.liveLookupCache.Add(namespace, newEntry)
0000000000000000000000000000000000000000;;				lruItemObj = newEntry
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lruEntry := lruItemObj.(liveLookupEntry)
0000000000000000000000000000000000000000;;			for i := range lruEntry.items {
0000000000000000000000000000000000000000;;				items = append(items, lruEntry.items[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resourceQuotas := []api.ResourceQuota{}
0000000000000000000000000000000000000000;;		for i := range items {
0000000000000000000000000000000000000000;;			quota := items[i]
0000000000000000000000000000000000000000;;			quota = e.checkCache(quota)
0000000000000000000000000000000000000000;;			// always make a copy.  We're going to muck around with this and we should never mutate the originals
0000000000000000000000000000000000000000;;			resourceQuotas = append(resourceQuotas, *quota)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resourceQuotas, nil
0000000000000000000000000000000000000000;;	}
