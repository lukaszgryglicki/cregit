0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
b4459401c908d3e5c104880a7fcd871960992add;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resourcequota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lru "github.com/hashicorp/golang-lru"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		testcore "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/fake"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/quota"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/quota/generic"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/quota/install"
0000000000000000000000000000000000000000;;		resourcequotaapi "k8s.io/kubernetes/plugin/pkg/admission/resourcequota/apis/resourcequota"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getResourceList(cpu, memory string) api.ResourceList {
0000000000000000000000000000000000000000;;		res := api.ResourceList{}
0000000000000000000000000000000000000000;;		if cpu != "" {
0000000000000000000000000000000000000000;;			res[api.ResourceCPU] = resource.MustParse(cpu)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if memory != "" {
0000000000000000000000000000000000000000;;			res[api.ResourceMemory] = resource.MustParse(memory)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getResourceRequirements(requests, limits api.ResourceList) api.ResourceRequirements {
0000000000000000000000000000000000000000;;		res := api.ResourceRequirements{}
0000000000000000000000000000000000000000;;		res.Requests = requests
0000000000000000000000000000000000000000;;		res.Limits = limits
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validPod(name string, numContainers int, resources api.ResourceRequirements) *api.Pod {
0000000000000000000000000000000000000000;;		pod := &api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: name, Namespace: "test"},
0000000000000000000000000000000000000000;;			Spec:       api.PodSpec{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod.Spec.Containers = make([]api.Container, 0, numContainers)
0000000000000000000000000000000000000000;;		for i := 0; i < numContainers; i++ {
0000000000000000000000000000000000000000;;			pod.Spec.Containers = append(pod.Spec.Containers, api.Container{
0000000000000000000000000000000000000000;;				Image:     "foo:V" + strconv.Itoa(i),
0000000000000000000000000000000000000000;;				Resources: resources,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validPersistentVolumeClaim(name string, resources api.ResourceRequirements) *api.PersistentVolumeClaim {
0000000000000000000000000000000000000000;;		return &api.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: name, Namespace: "test"},
0000000000000000000000000000000000000000;;			Spec: api.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				Resources: resources,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPrettyPrint(t *testing.T) {
0000000000000000000000000000000000000000;;		toResourceList := func(resources map[api.ResourceName]string) api.ResourceList {
0000000000000000000000000000000000000000;;			resourceList := api.ResourceList{}
0000000000000000000000000000000000000000;;			for key, value := range resources {
0000000000000000000000000000000000000000;;				resourceList[key] = resource.MustParse(value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return resourceList
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			input    api.ResourceList
0000000000000000000000000000000000000000;;			expected string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input: toResourceList(map[api.ResourceName]string{
0000000000000000000000000000000000000000;;					api.ResourceCPU: "100m",
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;				expected: "cpu=100m",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input: toResourceList(map[api.ResourceName]string{
0000000000000000000000000000000000000000;;					api.ResourcePods:                   "10",
0000000000000000000000000000000000000000;;					api.ResourceServices:               "10",
0000000000000000000000000000000000000000;;					api.ResourceReplicationControllers: "10",
0000000000000000000000000000000000000000;;					api.ResourceServicesNodePorts:      "10",
0000000000000000000000000000000000000000;;					api.ResourceRequestsCPU:            "100m",
0000000000000000000000000000000000000000;;					api.ResourceRequestsMemory:         "100Mi",
0000000000000000000000000000000000000000;;					api.ResourceLimitsCPU:              "100m",
0000000000000000000000000000000000000000;;					api.ResourceLimitsMemory:           "100Mi",
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;				expected: "limits.cpu=100m,limits.memory=100Mi,pods=10,replicationcontrollers=10,requests.cpu=100m,requests.memory=100Mi,services=10,services.nodeports=10",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			result := prettyPrint(testCase.input)
0000000000000000000000000000000000000000;;			if result != testCase.expected {
0000000000000000000000000000000000000000;;				t.Errorf("Pretty print did not give stable sorted output[%d], expected %v, but got %v", i, testCase.expected, result)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmissionIgnoresDelete verifies that the admission controller ignores delete operations
0000000000000000000000000000000000000000;;	func TestAdmissionIgnoresDelete(t *testing.T) {
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		quotaAccessor, _ := newQuotaAccessor()
0000000000000000000000000000000000000000;;		quotaAccessor.client = kubeClient
0000000000000000000000000000000000000000;;		quotaAccessor.lister = informerFactory.Core().InternalVersion().ResourceQuotas().Lister()
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{}
0000000000000000000000000000000000000000;;		evaluator := NewQuotaEvaluator(quotaAccessor, install.NewRegistry(nil, nil), nil, config, 5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := &quotaAdmission{
0000000000000000000000000000000000000000;;			Handler:   admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			evaluator: evaluator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		namespace := "default"
0000000000000000000000000000000000000000;;		err := handler.Admit(admission.NewAttributesRecord(nil, nil, api.Kind("Pod").WithVersion("version"), namespace, "name", api.Resource("pods").WithVersion("version"), "", admission.Delete, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("ResourceQuota should admit all deletes: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmissionIgnoresSubresources verifies that the admission controller ignores subresources
0000000000000000000000000000000000000000;;	// It verifies that creation of a pod that would have exceeded quota is properly failed
0000000000000000000000000000000000000000;;	// It verifies that create operations to a subresource that would have exceeded quota would succeed
0000000000000000000000000000000000000000;;	func TestAdmissionIgnoresSubresources(t *testing.T) {
0000000000000000000000000000000000000000;;		resourceQuota := &api.ResourceQuota{}
0000000000000000000000000000000000000000;;		resourceQuota.Name = "quota"
0000000000000000000000000000000000000000;;		resourceQuota.Namespace = "test"
0000000000000000000000000000000000000000;;		resourceQuota.Status = api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;			Hard: api.ResourceList{},
0000000000000000000000000000000000000000;;			Used: api.ResourceList{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceQuota.Status.Hard[api.ResourceMemory] = resource.MustParse("2Gi")
0000000000000000000000000000000000000000;;		resourceQuota.Status.Used[api.ResourceMemory] = resource.MustParse("1Gi")
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		quotaAccessor, _ := newQuotaAccessor()
0000000000000000000000000000000000000000;;		quotaAccessor.client = kubeClient
0000000000000000000000000000000000000000;;		quotaAccessor.lister = informerFactory.Core().InternalVersion().ResourceQuotas().Lister()
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{}
0000000000000000000000000000000000000000;;		evaluator := NewQuotaEvaluator(quotaAccessor, install.NewRegistry(nil, nil), nil, config, 5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := &quotaAdmission{
0000000000000000000000000000000000000000;;			Handler:   admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			evaluator: evaluator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ResourceQuotas().Informer().GetIndexer().Add(resourceQuota)
0000000000000000000000000000000000000000;;		newPod := validPod("123", 1, getResourceRequirements(getResourceList("100m", "2Gi"), getResourceList("", "")))
0000000000000000000000000000000000000000;;		err := handler.Admit(admission.NewAttributesRecord(newPod, nil, api.Kind("Pod").WithVersion("version"), newPod.Namespace, newPod.Name, api.Resource("pods").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected an error because the pod exceeded allowed quota")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = handler.Admit(admission.NewAttributesRecord(newPod, nil, api.Kind("Pod").WithVersion("version"), newPod.Namespace, newPod.Name, api.Resource("pods").WithVersion("version"), "subresource", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Did not expect an error because the action went to a subresource: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmitBelowQuotaLimit verifies that a pod when created has its usage reflected on the quota
0000000000000000000000000000000000000000;;	func TestAdmitBelowQuotaLimit(t *testing.T) {
0000000000000000000000000000000000000000;;		resourceQuota := &api.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "quota", Namespace: "test", ResourceVersion: "124"},
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceCPU:    resource.MustParse("3"),
0000000000000000000000000000000000000000;;					api.ResourceMemory: resource.MustParse("100Gi"),
0000000000000000000000000000000000000000;;					api.ResourcePods:   resource.MustParse("5"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceCPU:    resource.MustParse("1"),
0000000000000000000000000000000000000000;;					api.ResourceMemory: resource.MustParse("50Gi"),
0000000000000000000000000000000000000000;;					api.ResourcePods:   resource.MustParse("3"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset(resourceQuota)
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		quotaAccessor, _ := newQuotaAccessor()
0000000000000000000000000000000000000000;;		quotaAccessor.client = kubeClient
0000000000000000000000000000000000000000;;		quotaAccessor.lister = informerFactory.Core().InternalVersion().ResourceQuotas().Lister()
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{}
0000000000000000000000000000000000000000;;		evaluator := NewQuotaEvaluator(quotaAccessor, install.NewRegistry(nil, nil), nil, config, 5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := &quotaAdmission{
0000000000000000000000000000000000000000;;			Handler:   admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			evaluator: evaluator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ResourceQuotas().Informer().GetIndexer().Add(resourceQuota)
0000000000000000000000000000000000000000;;		newPod := validPod("allowed-pod", 1, getResourceRequirements(getResourceList("100m", "2Gi"), getResourceList("", "")))
0000000000000000000000000000000000000000;;		err := handler.Admit(admission.NewAttributesRecord(newPod, nil, api.Kind("Pod").WithVersion("version"), newPod.Namespace, newPod.Name, api.Resource("pods").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(kubeClient.Actions()) == 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected a client action")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedActionSet := sets.NewString(
0000000000000000000000000000000000000000;;			strings.Join([]string{"update", "resourcequotas", "status"}, "-"),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		actionSet := sets.NewString()
0000000000000000000000000000000000000000;;		for _, action := range kubeClient.Actions() {
0000000000000000000000000000000000000000;;			actionSet.Insert(strings.Join([]string{action.GetVerb(), action.GetResource().Resource, action.GetSubresource()}, "-"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !actionSet.HasAll(expectedActionSet.List()...) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected actions:\n%v\n but got:\n%v\nDifference:\n%v", expectedActionSet, actionSet, expectedActionSet.Difference(actionSet))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decimatedActions := removeListWatch(kubeClient.Actions())
0000000000000000000000000000000000000000;;		lastActionIndex := len(decimatedActions) - 1
0000000000000000000000000000000000000000;;		usage := decimatedActions[lastActionIndex].(testcore.UpdateAction).GetObject().(*api.ResourceQuota)
0000000000000000000000000000000000000000;;		expectedUsage := api.ResourceQuota{
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceCPU:    resource.MustParse("3"),
0000000000000000000000000000000000000000;;					api.ResourceMemory: resource.MustParse("100Gi"),
0000000000000000000000000000000000000000;;					api.ResourcePods:   resource.MustParse("5"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceCPU:    resource.MustParse("1100m"),
0000000000000000000000000000000000000000;;					api.ResourceMemory: resource.MustParse("52Gi"),
0000000000000000000000000000000000000000;;					api.ResourcePods:   resource.MustParse("4"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range expectedUsage.Status.Used {
0000000000000000000000000000000000000000;;			actual := usage.Status.Used[k]
0000000000000000000000000000000000000000;;			actualValue := actual.String()
0000000000000000000000000000000000000000;;			expectedValue := v.String()
0000000000000000000000000000000000000000;;			if expectedValue != actualValue {
0000000000000000000000000000000000000000;;				t.Errorf("Usage Used: Key: %v, Expected: %v, Actual: %v", k, expectedValue, actualValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmitHandlesOldObjects verifies that admit handles updates correctly with old objects
0000000000000000000000000000000000000000;;	func TestAdmitHandlesOldObjects(t *testing.T) {
0000000000000000000000000000000000000000;;		// in this scenario, the old quota was based on a service type=loadbalancer
0000000000000000000000000000000000000000;;		resourceQuota := &api.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "quota", Namespace: "test", ResourceVersion: "124"},
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceServices:              resource.MustParse("10"),
0000000000000000000000000000000000000000;;					api.ResourceServicesLoadBalancers: resource.MustParse("10"),
0000000000000000000000000000000000000000;;					api.ResourceServicesNodePorts:     resource.MustParse("10"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceServices:              resource.MustParse("1"),
0000000000000000000000000000000000000000;;					api.ResourceServicesLoadBalancers: resource.MustParse("1"),
0000000000000000000000000000000000000000;;					api.ResourceServicesNodePorts:     resource.MustParse("0"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// start up quota system
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset(resourceQuota)
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		quotaAccessor, _ := newQuotaAccessor()
0000000000000000000000000000000000000000;;		quotaAccessor.client = kubeClient
0000000000000000000000000000000000000000;;		quotaAccessor.lister = informerFactory.Core().InternalVersion().ResourceQuotas().Lister()
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{}
0000000000000000000000000000000000000000;;		evaluator := NewQuotaEvaluator(quotaAccessor, install.NewRegistry(nil, nil), nil, config, 5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := &quotaAdmission{
0000000000000000000000000000000000000000;;			Handler:   admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			evaluator: evaluator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ResourceQuotas().Informer().GetIndexer().Add(resourceQuota)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// old service was a load balancer, but updated version is a node port.
0000000000000000000000000000000000000000;;		existingService := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "service", Namespace: "test", ResourceVersion: "1"},
0000000000000000000000000000000000000000;;			Spec:       api.ServiceSpec{Type: api.ServiceTypeLoadBalancer},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newService := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "service", Namespace: "test"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type:  api.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{Port: 1234}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := handler.Admit(admission.NewAttributesRecord(newService, existingService, api.Kind("Service").WithVersion("version"), newService.Namespace, newService.Name, api.Resource("services").WithVersion("version"), "", admission.Update, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(kubeClient.Actions()) == 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected a client action")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the only action should have been to update the quota (since we should not have fetched the previous item)
0000000000000000000000000000000000000000;;		expectedActionSet := sets.NewString(
0000000000000000000000000000000000000000;;			strings.Join([]string{"update", "resourcequotas", "status"}, "-"),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		actionSet := sets.NewString()
0000000000000000000000000000000000000000;;		for _, action := range kubeClient.Actions() {
0000000000000000000000000000000000000000;;			actionSet.Insert(strings.Join([]string{action.GetVerb(), action.GetResource().Resource, action.GetSubresource()}, "-"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !actionSet.HasAll(expectedActionSet.List()...) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected actions:\n%v\n but got:\n%v\nDifference:\n%v", expectedActionSet, actionSet, expectedActionSet.Difference(actionSet))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify usage decremented the loadbalancer, and incremented the nodeport, but kept the service the same.
0000000000000000000000000000000000000000;;		decimatedActions := removeListWatch(kubeClient.Actions())
0000000000000000000000000000000000000000;;		lastActionIndex := len(decimatedActions) - 1
0000000000000000000000000000000000000000;;		usage := decimatedActions[lastActionIndex].(testcore.UpdateAction).GetObject().(*api.ResourceQuota)
0000000000000000000000000000000000000000;;		expectedUsage := api.ResourceQuota{
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceServices:              resource.MustParse("10"),
0000000000000000000000000000000000000000;;					api.ResourceServicesLoadBalancers: resource.MustParse("10"),
0000000000000000000000000000000000000000;;					api.ResourceServicesNodePorts:     resource.MustParse("10"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceServices:              resource.MustParse("1"),
0000000000000000000000000000000000000000;;					api.ResourceServicesLoadBalancers: resource.MustParse("0"),
0000000000000000000000000000000000000000;;					api.ResourceServicesNodePorts:     resource.MustParse("1"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range expectedUsage.Status.Used {
0000000000000000000000000000000000000000;;			actual := usage.Status.Used[k]
0000000000000000000000000000000000000000;;			actualValue := actual.String()
0000000000000000000000000000000000000000;;			expectedValue := v.String()
0000000000000000000000000000000000000000;;			if expectedValue != actualValue {
0000000000000000000000000000000000000000;;				t.Errorf("Usage Used: Key: %v, Expected: %v, Actual: %v", k, expectedValue, actualValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmitHandlesCreatingUpdates verifies that admit handles updates which behave as creates
0000000000000000000000000000000000000000;;	func TestAdmitHandlesCreatingUpdates(t *testing.T) {
0000000000000000000000000000000000000000;;		// in this scenario, there is an existing service
0000000000000000000000000000000000000000;;		resourceQuota := &api.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "quota", Namespace: "test", ResourceVersion: "124"},
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceServices:              resource.MustParse("10"),
0000000000000000000000000000000000000000;;					api.ResourceServicesLoadBalancers: resource.MustParse("10"),
0000000000000000000000000000000000000000;;					api.ResourceServicesNodePorts:     resource.MustParse("10"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceServices:              resource.MustParse("1"),
0000000000000000000000000000000000000000;;					api.ResourceServicesLoadBalancers: resource.MustParse("1"),
0000000000000000000000000000000000000000;;					api.ResourceServicesNodePorts:     resource.MustParse("0"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// start up quota system
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset(resourceQuota)
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		quotaAccessor, _ := newQuotaAccessor()
0000000000000000000000000000000000000000;;		quotaAccessor.client = kubeClient
0000000000000000000000000000000000000000;;		quotaAccessor.lister = informerFactory.Core().InternalVersion().ResourceQuotas().Lister()
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{}
0000000000000000000000000000000000000000;;		evaluator := NewQuotaEvaluator(quotaAccessor, install.NewRegistry(nil, nil), nil, config, 5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := &quotaAdmission{
0000000000000000000000000000000000000000;;			Handler:   admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			evaluator: evaluator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ResourceQuotas().Informer().GetIndexer().Add(resourceQuota)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// old service didn't exist, so this update is actually a create
0000000000000000000000000000000000000000;;		oldService := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "service", Namespace: "test", ResourceVersion: ""},
0000000000000000000000000000000000000000;;			Spec:       api.ServiceSpec{Type: api.ServiceTypeLoadBalancer},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newService := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "service", Namespace: "test"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type:  api.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{Port: 1234}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := handler.Admit(admission.NewAttributesRecord(newService, oldService, api.Kind("Service").WithVersion("version"), newService.Namespace, newService.Name, api.Resource("services").WithVersion("version"), "", admission.Update, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(kubeClient.Actions()) == 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected a client action")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the only action should have been to update the quota (since we should not have fetched the previous item)
0000000000000000000000000000000000000000;;		expectedActionSet := sets.NewString(
0000000000000000000000000000000000000000;;			strings.Join([]string{"update", "resourcequotas", "status"}, "-"),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		actionSet := sets.NewString()
0000000000000000000000000000000000000000;;		for _, action := range kubeClient.Actions() {
0000000000000000000000000000000000000000;;			actionSet.Insert(strings.Join([]string{action.GetVerb(), action.GetResource().Resource, action.GetSubresource()}, "-"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !actionSet.HasAll(expectedActionSet.List()...) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected actions:\n%v\n but got:\n%v\nDifference:\n%v", expectedActionSet, actionSet, expectedActionSet.Difference(actionSet))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify that the "old" object was ignored for calculating the new usage
0000000000000000000000000000000000000000;;		decimatedActions := removeListWatch(kubeClient.Actions())
0000000000000000000000000000000000000000;;		lastActionIndex := len(decimatedActions) - 1
0000000000000000000000000000000000000000;;		usage := decimatedActions[lastActionIndex].(testcore.UpdateAction).GetObject().(*api.ResourceQuota)
0000000000000000000000000000000000000000;;		expectedUsage := api.ResourceQuota{
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceServices:              resource.MustParse("10"),
0000000000000000000000000000000000000000;;					api.ResourceServicesLoadBalancers: resource.MustParse("10"),
0000000000000000000000000000000000000000;;					api.ResourceServicesNodePorts:     resource.MustParse("10"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceServices:              resource.MustParse("2"),
0000000000000000000000000000000000000000;;					api.ResourceServicesLoadBalancers: resource.MustParse("1"),
0000000000000000000000000000000000000000;;					api.ResourceServicesNodePorts:     resource.MustParse("1"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range expectedUsage.Status.Used {
0000000000000000000000000000000000000000;;			actual := usage.Status.Used[k]
0000000000000000000000000000000000000000;;			actualValue := actual.String()
0000000000000000000000000000000000000000;;			expectedValue := v.String()
0000000000000000000000000000000000000000;;			if expectedValue != actualValue {
0000000000000000000000000000000000000000;;				t.Errorf("Usage Used: Key: %v, Expected: %v, Actual: %v", k, expectedValue, actualValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmitExceedQuotaLimit verifies that if a pod exceeded allowed usage that its rejected during admission.
0000000000000000000000000000000000000000;;	func TestAdmitExceedQuotaLimit(t *testing.T) {
0000000000000000000000000000000000000000;;		resourceQuota := &api.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "quota", Namespace: "test", ResourceVersion: "124"},
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceCPU:    resource.MustParse("3"),
0000000000000000000000000000000000000000;;					api.ResourceMemory: resource.MustParse("100Gi"),
0000000000000000000000000000000000000000;;					api.ResourcePods:   resource.MustParse("5"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceCPU:    resource.MustParse("1"),
0000000000000000000000000000000000000000;;					api.ResourceMemory: resource.MustParse("50Gi"),
0000000000000000000000000000000000000000;;					api.ResourcePods:   resource.MustParse("3"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset(resourceQuota)
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		quotaAccessor, _ := newQuotaAccessor()
0000000000000000000000000000000000000000;;		quotaAccessor.client = kubeClient
0000000000000000000000000000000000000000;;		quotaAccessor.lister = informerFactory.Core().InternalVersion().ResourceQuotas().Lister()
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{}
0000000000000000000000000000000000000000;;		evaluator := NewQuotaEvaluator(quotaAccessor, install.NewRegistry(nil, nil), nil, config, 5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := &quotaAdmission{
0000000000000000000000000000000000000000;;			Handler:   admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			evaluator: evaluator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ResourceQuotas().Informer().GetIndexer().Add(resourceQuota)
0000000000000000000000000000000000000000;;		newPod := validPod("not-allowed-pod", 1, getResourceRequirements(getResourceList("3", "2Gi"), getResourceList("", "")))
0000000000000000000000000000000000000000;;		err := handler.Admit(admission.NewAttributesRecord(newPod, nil, api.Kind("Pod").WithVersion("version"), newPod.Namespace, newPod.Name, api.Resource("pods").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected an error exceeding quota")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmitEnforceQuotaConstraints verifies that if a quota tracks a particular resource that that resource is
0000000000000000000000000000000000000000;;	// specified on the pod.  In this case, we create a quota that tracks cpu request, memory request, and memory limit.
0000000000000000000000000000000000000000;;	// We ensure that a pod that does not specify a memory limit that it fails in admission.
0000000000000000000000000000000000000000;;	func TestAdmitEnforceQuotaConstraints(t *testing.T) {
0000000000000000000000000000000000000000;;		resourceQuota := &api.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "quota", Namespace: "test", ResourceVersion: "124"},
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceCPU:          resource.MustParse("3"),
0000000000000000000000000000000000000000;;					api.ResourceMemory:       resource.MustParse("100Gi"),
0000000000000000000000000000000000000000;;					api.ResourceLimitsMemory: resource.MustParse("200Gi"),
0000000000000000000000000000000000000000;;					api.ResourcePods:         resource.MustParse("5"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceCPU:          resource.MustParse("1"),
0000000000000000000000000000000000000000;;					api.ResourceMemory:       resource.MustParse("50Gi"),
0000000000000000000000000000000000000000;;					api.ResourceLimitsMemory: resource.MustParse("100Gi"),
0000000000000000000000000000000000000000;;					api.ResourcePods:         resource.MustParse("3"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset(resourceQuota)
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		quotaAccessor, _ := newQuotaAccessor()
0000000000000000000000000000000000000000;;		quotaAccessor.client = kubeClient
0000000000000000000000000000000000000000;;		quotaAccessor.lister = informerFactory.Core().InternalVersion().ResourceQuotas().Lister()
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{}
0000000000000000000000000000000000000000;;		evaluator := NewQuotaEvaluator(quotaAccessor, install.NewRegistry(nil, nil), nil, config, 5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := &quotaAdmission{
0000000000000000000000000000000000000000;;			Handler:   admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			evaluator: evaluator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ResourceQuotas().Informer().GetIndexer().Add(resourceQuota)
0000000000000000000000000000000000000000;;		// verify all values are specified as required on the quota
0000000000000000000000000000000000000000;;		newPod := validPod("not-allowed-pod", 1, getResourceRequirements(getResourceList("100m", "2Gi"), getResourceList("200m", "")))
0000000000000000000000000000000000000000;;		err := handler.Admit(admission.NewAttributesRecord(newPod, nil, api.Kind("Pod").WithVersion("version"), newPod.Namespace, newPod.Name, api.Resource("pods").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected an error because the pod does not specify a memory limit")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// verify the requests and limits are actually valid (in this case, we fail because the limits < requests)
0000000000000000000000000000000000000000;;		newPod = validPod("not-allowed-pod", 1, getResourceRequirements(getResourceList("200m", "2Gi"), getResourceList("100m", "1Gi")))
0000000000000000000000000000000000000000;;		err = handler.Admit(admission.NewAttributesRecord(newPod, nil, api.Kind("Pod").WithVersion("version"), newPod.Namespace, newPod.Name, api.Resource("pods").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected an error because the pod does not specify a memory limit")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmitPodInNamespaceWithoutQuota ensures that if a namespace has no quota, that a pod can get in
0000000000000000000000000000000000000000;;	func TestAdmitPodInNamespaceWithoutQuota(t *testing.T) {
0000000000000000000000000000000000000000;;		resourceQuota := &api.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "quota", Namespace: "other", ResourceVersion: "124"},
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceCPU:          resource.MustParse("3"),
0000000000000000000000000000000000000000;;					api.ResourceMemory:       resource.MustParse("100Gi"),
0000000000000000000000000000000000000000;;					api.ResourceLimitsMemory: resource.MustParse("200Gi"),
0000000000000000000000000000000000000000;;					api.ResourcePods:         resource.MustParse("5"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceCPU:          resource.MustParse("1"),
0000000000000000000000000000000000000000;;					api.ResourceMemory:       resource.MustParse("50Gi"),
0000000000000000000000000000000000000000;;					api.ResourceLimitsMemory: resource.MustParse("100Gi"),
0000000000000000000000000000000000000000;;					api.ResourcePods:         resource.MustParse("3"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		liveLookupCache, err := lru.New(100)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset(resourceQuota)
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		quotaAccessor, _ := newQuotaAccessor()
0000000000000000000000000000000000000000;;		quotaAccessor.client = kubeClient
0000000000000000000000000000000000000000;;		quotaAccessor.lister = informerFactory.Core().InternalVersion().ResourceQuotas().Lister()
0000000000000000000000000000000000000000;;		quotaAccessor.liveLookupCache = liveLookupCache
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{}
0000000000000000000000000000000000000000;;		evaluator := NewQuotaEvaluator(quotaAccessor, install.NewRegistry(nil, nil), nil, config, 5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := &quotaAdmission{
0000000000000000000000000000000000000000;;			Handler:   admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			evaluator: evaluator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Add to the index
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ResourceQuotas().Informer().GetIndexer().Add(resourceQuota)
0000000000000000000000000000000000000000;;		newPod := validPod("not-allowed-pod", 1, getResourceRequirements(getResourceList("100m", "2Gi"), getResourceList("200m", "")))
0000000000000000000000000000000000000000;;		// Add to the lru cache so we do not do a live client lookup
0000000000000000000000000000000000000000;;		liveLookupCache.Add(newPod.Namespace, liveLookupEntry{expiry: time.Now().Add(time.Duration(30 * time.Second)), items: []*api.ResourceQuota{}})
0000000000000000000000000000000000000000;;		err = handler.Admit(admission.NewAttributesRecord(newPod, nil, api.Kind("Pod").WithVersion("version"), newPod.Namespace, newPod.Name, api.Resource("pods").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Did not expect an error because the pod is in a different namespace than the quota")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmitBelowTerminatingQuotaLimit ensures that terminating pods are charged to the right quota.
0000000000000000000000000000000000000000;;	// It creates a terminating and non-terminating quota, and creates a terminating pod.
0000000000000000000000000000000000000000;;	// It ensures that the terminating quota is incremented, and the non-terminating quota is not.
0000000000000000000000000000000000000000;;	func TestAdmitBelowTerminatingQuotaLimit(t *testing.T) {
0000000000000000000000000000000000000000;;		resourceQuotaNonTerminating := &api.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "quota-non-terminating", Namespace: "test", ResourceVersion: "124"},
0000000000000000000000000000000000000000;;			Spec: api.ResourceQuotaSpec{
0000000000000000000000000000000000000000;;				Scopes: []api.ResourceQuotaScope{api.ResourceQuotaScopeNotTerminating},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceCPU:    resource.MustParse("3"),
0000000000000000000000000000000000000000;;					api.ResourceMemory: resource.MustParse("100Gi"),
0000000000000000000000000000000000000000;;					api.ResourcePods:   resource.MustParse("5"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceCPU:    resource.MustParse("1"),
0000000000000000000000000000000000000000;;					api.ResourceMemory: resource.MustParse("50Gi"),
0000000000000000000000000000000000000000;;					api.ResourcePods:   resource.MustParse("3"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceQuotaTerminating := &api.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "quota-terminating", Namespace: "test", ResourceVersion: "124"},
0000000000000000000000000000000000000000;;			Spec: api.ResourceQuotaSpec{
0000000000000000000000000000000000000000;;				Scopes: []api.ResourceQuotaScope{api.ResourceQuotaScopeTerminating},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceCPU:    resource.MustParse("3"),
0000000000000000000000000000000000000000;;					api.ResourceMemory: resource.MustParse("100Gi"),
0000000000000000000000000000000000000000;;					api.ResourcePods:   resource.MustParse("5"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceCPU:    resource.MustParse("1"),
0000000000000000000000000000000000000000;;					api.ResourceMemory: resource.MustParse("50Gi"),
0000000000000000000000000000000000000000;;					api.ResourcePods:   resource.MustParse("3"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset(resourceQuotaTerminating, resourceQuotaNonTerminating)
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		quotaAccessor, _ := newQuotaAccessor()
0000000000000000000000000000000000000000;;		quotaAccessor.client = kubeClient
0000000000000000000000000000000000000000;;		quotaAccessor.lister = informerFactory.Core().InternalVersion().ResourceQuotas().Lister()
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{}
0000000000000000000000000000000000000000;;		evaluator := NewQuotaEvaluator(quotaAccessor, install.NewRegistry(nil, nil), nil, config, 5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := &quotaAdmission{
0000000000000000000000000000000000000000;;			Handler:   admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			evaluator: evaluator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ResourceQuotas().Informer().GetIndexer().Add(resourceQuotaNonTerminating)
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ResourceQuotas().Informer().GetIndexer().Add(resourceQuotaTerminating)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create a pod that has an active deadline
0000000000000000000000000000000000000000;;		newPod := validPod("allowed-pod", 1, getResourceRequirements(getResourceList("100m", "2Gi"), getResourceList("", "")))
0000000000000000000000000000000000000000;;		activeDeadlineSeconds := int64(30)
0000000000000000000000000000000000000000;;		newPod.Spec.ActiveDeadlineSeconds = &activeDeadlineSeconds
0000000000000000000000000000000000000000;;		err := handler.Admit(admission.NewAttributesRecord(newPod, nil, api.Kind("Pod").WithVersion("version"), newPod.Namespace, newPod.Name, api.Resource("pods").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(kubeClient.Actions()) == 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected a client action")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedActionSet := sets.NewString(
0000000000000000000000000000000000000000;;			strings.Join([]string{"update", "resourcequotas", "status"}, "-"),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		actionSet := sets.NewString()
0000000000000000000000000000000000000000;;		for _, action := range kubeClient.Actions() {
0000000000000000000000000000000000000000;;			actionSet.Insert(strings.Join([]string{action.GetVerb(), action.GetResource().Resource, action.GetSubresource()}, "-"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !actionSet.HasAll(expectedActionSet.List()...) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected actions:\n%v\n but got:\n%v\nDifference:\n%v", expectedActionSet, actionSet, expectedActionSet.Difference(actionSet))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decimatedActions := removeListWatch(kubeClient.Actions())
0000000000000000000000000000000000000000;;		lastActionIndex := len(decimatedActions) - 1
0000000000000000000000000000000000000000;;		usage := decimatedActions[lastActionIndex].(testcore.UpdateAction).GetObject().(*api.ResourceQuota)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure only the quota-terminating was updated
0000000000000000000000000000000000000000;;		if usage.Name != resourceQuotaTerminating.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Incremented the wrong quota, expected %v, actual %v", resourceQuotaTerminating.Name, usage.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedUsage := api.ResourceQuota{
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceCPU:    resource.MustParse("3"),
0000000000000000000000000000000000000000;;					api.ResourceMemory: resource.MustParse("100Gi"),
0000000000000000000000000000000000000000;;					api.ResourcePods:   resource.MustParse("5"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceCPU:    resource.MustParse("1100m"),
0000000000000000000000000000000000000000;;					api.ResourceMemory: resource.MustParse("52Gi"),
0000000000000000000000000000000000000000;;					api.ResourcePods:   resource.MustParse("4"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range expectedUsage.Status.Used {
0000000000000000000000000000000000000000;;			actual := usage.Status.Used[k]
0000000000000000000000000000000000000000;;			actualValue := actual.String()
0000000000000000000000000000000000000000;;			expectedValue := v.String()
0000000000000000000000000000000000000000;;			if expectedValue != actualValue {
0000000000000000000000000000000000000000;;				t.Errorf("Usage Used: Key: %v, Expected: %v, Actual: %v", k, expectedValue, actualValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmitBelowBestEffortQuotaLimit creates a best effort and non-best effort quota.
0000000000000000000000000000000000000000;;	// It verifies that best effort pods are properly scoped to the best effort quota document.
0000000000000000000000000000000000000000;;	func TestAdmitBelowBestEffortQuotaLimit(t *testing.T) {
0000000000000000000000000000000000000000;;		resourceQuotaBestEffort := &api.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "quota-besteffort", Namespace: "test", ResourceVersion: "124"},
0000000000000000000000000000000000000000;;			Spec: api.ResourceQuotaSpec{
0000000000000000000000000000000000000000;;				Scopes: []api.ResourceQuotaScope{api.ResourceQuotaScopeBestEffort},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourcePods: resource.MustParse("5"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourcePods: resource.MustParse("3"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceQuotaNotBestEffort := &api.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "quota-not-besteffort", Namespace: "test", ResourceVersion: "124"},
0000000000000000000000000000000000000000;;			Spec: api.ResourceQuotaSpec{
0000000000000000000000000000000000000000;;				Scopes: []api.ResourceQuotaScope{api.ResourceQuotaScopeNotBestEffort},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourcePods: resource.MustParse("5"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourcePods: resource.MustParse("3"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset(resourceQuotaBestEffort, resourceQuotaNotBestEffort)
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		quotaAccessor, _ := newQuotaAccessor()
0000000000000000000000000000000000000000;;		quotaAccessor.client = kubeClient
0000000000000000000000000000000000000000;;		quotaAccessor.lister = informerFactory.Core().InternalVersion().ResourceQuotas().Lister()
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{}
0000000000000000000000000000000000000000;;		evaluator := NewQuotaEvaluator(quotaAccessor, install.NewRegistry(nil, nil), nil, config, 5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := &quotaAdmission{
0000000000000000000000000000000000000000;;			Handler:   admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			evaluator: evaluator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ResourceQuotas().Informer().GetIndexer().Add(resourceQuotaBestEffort)
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ResourceQuotas().Informer().GetIndexer().Add(resourceQuotaNotBestEffort)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create a pod that is best effort because it does not make a request for anything
0000000000000000000000000000000000000000;;		newPod := validPod("allowed-pod", 1, getResourceRequirements(getResourceList("", ""), getResourceList("", "")))
0000000000000000000000000000000000000000;;		err := handler.Admit(admission.NewAttributesRecord(newPod, nil, api.Kind("Pod").WithVersion("version"), newPod.Namespace, newPod.Name, api.Resource("pods").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedActionSet := sets.NewString(
0000000000000000000000000000000000000000;;			strings.Join([]string{"update", "resourcequotas", "status"}, "-"),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		actionSet := sets.NewString()
0000000000000000000000000000000000000000;;		for _, action := range kubeClient.Actions() {
0000000000000000000000000000000000000000;;			actionSet.Insert(strings.Join([]string{action.GetVerb(), action.GetResource().Resource, action.GetSubresource()}, "-"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !actionSet.HasAll(expectedActionSet.List()...) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected actions:\n%v\n but got:\n%v\nDifference:\n%v", expectedActionSet, actionSet, expectedActionSet.Difference(actionSet))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		decimatedActions := removeListWatch(kubeClient.Actions())
0000000000000000000000000000000000000000;;		lastActionIndex := len(decimatedActions) - 1
0000000000000000000000000000000000000000;;		usage := decimatedActions[lastActionIndex].(testcore.UpdateAction).GetObject().(*api.ResourceQuota)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if usage.Name != resourceQuotaBestEffort.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Incremented the wrong quota, expected %v, actual %v", resourceQuotaBestEffort.Name, usage.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedUsage := api.ResourceQuota{
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourcePods: resource.MustParse("5"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourcePods: resource.MustParse("4"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range expectedUsage.Status.Used {
0000000000000000000000000000000000000000;;			actual := usage.Status.Used[k]
0000000000000000000000000000000000000000;;			actualValue := actual.String()
0000000000000000000000000000000000000000;;			expectedValue := v.String()
0000000000000000000000000000000000000000;;			if expectedValue != actualValue {
0000000000000000000000000000000000000000;;				t.Errorf("Usage Used: Key: %v, Expected: %v, Actual: %v", k, expectedValue, actualValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func removeListWatch(in []testcore.Action) []testcore.Action {
0000000000000000000000000000000000000000;;		decimatedActions := []testcore.Action{}
0000000000000000000000000000000000000000;;		// list and watch resource quota is done to maintain our cache, so that's expected.  Remove them from results
0000000000000000000000000000000000000000;;		for i := range in {
0000000000000000000000000000000000000000;;			if in[i].Matches("list", "resourcequotas") || in[i].Matches("watch", "resourcequotas") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			decimatedActions = append(decimatedActions, in[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return decimatedActions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmitBestEffortQuotaLimitIgnoresBurstable validates that a besteffort quota does not match a resource
0000000000000000000000000000000000000000;;	// guaranteed pod.
0000000000000000000000000000000000000000;;	func TestAdmitBestEffortQuotaLimitIgnoresBurstable(t *testing.T) {
0000000000000000000000000000000000000000;;		resourceQuota := &api.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "quota-besteffort", Namespace: "test", ResourceVersion: "124"},
0000000000000000000000000000000000000000;;			Spec: api.ResourceQuotaSpec{
0000000000000000000000000000000000000000;;				Scopes: []api.ResourceQuotaScope{api.ResourceQuotaScopeBestEffort},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourcePods: resource.MustParse("5"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourcePods: resource.MustParse("3"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset(resourceQuota)
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		quotaAccessor, _ := newQuotaAccessor()
0000000000000000000000000000000000000000;;		quotaAccessor.client = kubeClient
0000000000000000000000000000000000000000;;		quotaAccessor.lister = informerFactory.Core().InternalVersion().ResourceQuotas().Lister()
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{}
0000000000000000000000000000000000000000;;		evaluator := NewQuotaEvaluator(quotaAccessor, install.NewRegistry(nil, nil), nil, config, 5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := &quotaAdmission{
0000000000000000000000000000000000000000;;			Handler:   admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			evaluator: evaluator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ResourceQuotas().Informer().GetIndexer().Add(resourceQuota)
0000000000000000000000000000000000000000;;		newPod := validPod("allowed-pod", 1, getResourceRequirements(getResourceList("100m", "1Gi"), getResourceList("", "")))
0000000000000000000000000000000000000000;;		err := handler.Admit(admission.NewAttributesRecord(newPod, nil, api.Kind("Pod").WithVersion("version"), newPod.Namespace, newPod.Name, api.Resource("pods").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decimatedActions := removeListWatch(kubeClient.Actions())
0000000000000000000000000000000000000000;;		if len(decimatedActions) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected no client actions because the incoming pod did not match best effort quota: %v", kubeClient.Actions())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHasUsageStats(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			a        api.ResourceQuota
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"empty": {
0000000000000000000000000000000000000000;;				a:        api.ResourceQuota{Status: api.ResourceQuotaStatus{Hard: api.ResourceList{}}},
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"hard-only": {
0000000000000000000000000000000000000000;;				a: api.ResourceQuota{
0000000000000000000000000000000000000000;;					Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;						Hard: api.ResourceList{
0000000000000000000000000000000000000000;;							api.ResourceMemory: resource.MustParse("1Gi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Used: api.ResourceList{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"hard-used": {
0000000000000000000000000000000000000000;;				a: api.ResourceQuota{
0000000000000000000000000000000000000000;;					Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;						Hard: api.ResourceList{
0000000000000000000000000000000000000000;;							api.ResourceMemory: resource.MustParse("1Gi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Used: api.ResourceList{
0000000000000000000000000000000000000000;;							api.ResourceMemory: resource.MustParse("500Mi"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for testName, testCase := range testCases {
0000000000000000000000000000000000000000;;			if result := hasUsageStats(&testCase.a); result != testCase.expected {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected: %v, actual: %v", testName, testCase.expected, result)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmissionSetsMissingNamespace verifies that if an object lacks a
0000000000000000000000000000000000000000;;	// namespace, it will be set.
0000000000000000000000000000000000000000;;	func TestAdmissionSetsMissingNamespace(t *testing.T) {
0000000000000000000000000000000000000000;;		namespace := "test"
0000000000000000000000000000000000000000;;		resourceQuota := &api.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "quota", Namespace: namespace, ResourceVersion: "124"},
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourcePods: resource.MustParse("3"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourcePods: resource.MustParse("1"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create a dummy evaluator so we can trigger quota
0000000000000000000000000000000000000000;;		podEvaluator := &generic.ObjectCountEvaluator{
0000000000000000000000000000000000000000;;			AllowCreateOnUpdate: false,
0000000000000000000000000000000000000000;;			InternalGroupKind:   api.Kind("Pod"),
0000000000000000000000000000000000000000;;			ResourceName:        api.ResourcePods,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		registry := &generic.GenericRegistry{
0000000000000000000000000000000000000000;;			InternalEvaluators: map[schema.GroupKind]quota.Evaluator{
0000000000000000000000000000000000000000;;				podEvaluator.GroupKind(): podEvaluator,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset(resourceQuota)
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		quotaAccessor, _ := newQuotaAccessor()
0000000000000000000000000000000000000000;;		quotaAccessor.client = kubeClient
0000000000000000000000000000000000000000;;		quotaAccessor.lister = informerFactory.Core().InternalVersion().ResourceQuotas().Lister()
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{}
0000000000000000000000000000000000000000;;		evaluator := NewQuotaEvaluator(quotaAccessor, install.NewRegistry(nil, nil), nil, config, 5, stopCh)
0000000000000000000000000000000000000000;;		evaluator.(*quotaEvaluator).registry = registry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := &quotaAdmission{
0000000000000000000000000000000000000000;;			Handler:   admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			evaluator: evaluator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ResourceQuotas().Informer().GetIndexer().Add(resourceQuota)
0000000000000000000000000000000000000000;;		newPod := validPod("pod-without-namespace", 1, getResourceRequirements(getResourceList("1", "2Gi"), getResourceList("", "")))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// unset the namespace
0000000000000000000000000000000000000000;;		newPod.ObjectMeta.Namespace = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := handler.Admit(admission.NewAttributesRecord(newPod, nil, api.Kind("Pod").WithVersion("version"), namespace, newPod.Name, api.Resource("pods").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if newPod.Namespace != namespace {
0000000000000000000000000000000000000000;;			t.Errorf("Got unexpected pod namespace: %q != %q", newPod.Namespace, namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmitRejectsNegativeUsage verifies that usage for any measured resource cannot be negative.
0000000000000000000000000000000000000000;;	func TestAdmitRejectsNegativeUsage(t *testing.T) {
0000000000000000000000000000000000000000;;		resourceQuota := &api.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "quota", Namespace: "test", ResourceVersion: "124"},
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourcePersistentVolumeClaims: resource.MustParse("3"),
0000000000000000000000000000000000000000;;					api.ResourceRequestsStorage:        resource.MustParse("100Gi"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourcePersistentVolumeClaims: resource.MustParse("1"),
0000000000000000000000000000000000000000;;					api.ResourceRequestsStorage:        resource.MustParse("10Gi"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset(resourceQuota)
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		quotaAccessor, _ := newQuotaAccessor()
0000000000000000000000000000000000000000;;		quotaAccessor.client = kubeClient
0000000000000000000000000000000000000000;;		quotaAccessor.lister = informerFactory.Core().InternalVersion().ResourceQuotas().Lister()
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{}
0000000000000000000000000000000000000000;;		evaluator := NewQuotaEvaluator(quotaAccessor, install.NewRegistry(nil, nil), nil, config, 5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := &quotaAdmission{
0000000000000000000000000000000000000000;;			Handler:   admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			evaluator: evaluator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ResourceQuotas().Informer().GetIndexer().Add(resourceQuota)
0000000000000000000000000000000000000000;;		// verify quota rejects negative pvc storage requests
0000000000000000000000000000000000000000;;		newPvc := validPersistentVolumeClaim("not-allowed-pvc", getResourceRequirements(api.ResourceList{api.ResourceStorage: resource.MustParse("-1Gi")}, api.ResourceList{}))
0000000000000000000000000000000000000000;;		err := handler.Admit(admission.NewAttributesRecord(newPvc, nil, api.Kind("PersistentVolumeClaim").WithVersion("version"), newPvc.Namespace, newPvc.Name, api.Resource("persistentvolumeclaims").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected an error because the pvc has negative storage usage")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify quota accepts non-negative pvc storage requests
0000000000000000000000000000000000000000;;		newPvc = validPersistentVolumeClaim("not-allowed-pvc", getResourceRequirements(api.ResourceList{api.ResourceStorage: resource.MustParse("1Gi")}, api.ResourceList{}))
0000000000000000000000000000000000000000;;		err = handler.Admit(admission.NewAttributesRecord(newPvc, nil, api.Kind("PersistentVolumeClaim").WithVersion("version"), newPvc.Namespace, newPvc.Name, api.Resource("persistentvolumeclaims").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmitWhenUnrelatedResourceExceedsQuota verifies that if resource X exceeds quota, it does not prohibit resource Y from admission.
0000000000000000000000000000000000000000;;	func TestAdmitWhenUnrelatedResourceExceedsQuota(t *testing.T) {
0000000000000000000000000000000000000000;;		resourceQuota := &api.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "quota", Namespace: "test", ResourceVersion: "124"},
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceServices: resource.MustParse("3"),
0000000000000000000000000000000000000000;;					api.ResourcePods:     resource.MustParse("4"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceServices: resource.MustParse("4"),
0000000000000000000000000000000000000000;;					api.ResourcePods:     resource.MustParse("1"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset(resourceQuota)
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		quotaAccessor, _ := newQuotaAccessor()
0000000000000000000000000000000000000000;;		quotaAccessor.client = kubeClient
0000000000000000000000000000000000000000;;		quotaAccessor.lister = informerFactory.Core().InternalVersion().ResourceQuotas().Lister()
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{}
0000000000000000000000000000000000000000;;		evaluator := NewQuotaEvaluator(quotaAccessor, install.NewRegistry(nil, nil), nil, config, 5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := &quotaAdmission{
0000000000000000000000000000000000000000;;			Handler:   admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			evaluator: evaluator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		informerFactory.Core().InternalVersion().ResourceQuotas().Informer().GetIndexer().Add(resourceQuota)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create a pod that should pass existing quota
0000000000000000000000000000000000000000;;		newPod := validPod("allowed-pod", 1, getResourceRequirements(getResourceList("", ""), getResourceList("", "")))
0000000000000000000000000000000000000000;;		err := handler.Admit(admission.NewAttributesRecord(newPod, nil, api.Kind("Pod").WithVersion("version"), newPod.Namespace, newPod.Name, api.Resource("pods").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmitLimitedResourceNoQuota verifies if a limited resource is configured with no quota, it cannot be consumed.
0000000000000000000000000000000000000000;;	func TestAdmitLimitedResourceNoQuota(t *testing.T) {
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		quotaAccessor, _ := newQuotaAccessor()
0000000000000000000000000000000000000000;;		quotaAccessor.client = kubeClient
0000000000000000000000000000000000000000;;		quotaAccessor.lister = informerFactory.Core().InternalVersion().ResourceQuotas().Lister()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// disable consumption of cpu unless there is a covering quota.
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{
0000000000000000000000000000000000000000;;			LimitedResources: []resourcequotaapi.LimitedResource{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Resource:      "pods",
0000000000000000000000000000000000000000;;					MatchContains: []string{"cpu"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		evaluator := NewQuotaEvaluator(quotaAccessor, install.NewRegistry(nil, nil), nil, config, 5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := &quotaAdmission{
0000000000000000000000000000000000000000;;			Handler:   admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			evaluator: evaluator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newPod := validPod("not-allowed-pod", 1, getResourceRequirements(getResourceList("3", "2Gi"), getResourceList("", "")))
0000000000000000000000000000000000000000;;		err := handler.Admit(admission.NewAttributesRecord(newPod, nil, api.Kind("Pod").WithVersion("version"), newPod.Namespace, newPod.Name, api.Resource("pods").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected an error for consuming a limited resource without quota.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmitLimitedResourceNoQuotaIgnoresNonMatchingResources shows it ignores non matching resources in config.
0000000000000000000000000000000000000000;;	func TestAdmitLimitedResourceNoQuotaIgnoresNonMatchingResources(t *testing.T) {
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		quotaAccessor, _ := newQuotaAccessor()
0000000000000000000000000000000000000000;;		quotaAccessor.client = kubeClient
0000000000000000000000000000000000000000;;		quotaAccessor.lister = informerFactory.Core().InternalVersion().ResourceQuotas().Lister()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// disable consumption of cpu unless there is a covering quota.
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{
0000000000000000000000000000000000000000;;			LimitedResources: []resourcequotaapi.LimitedResource{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Resource:      "services",
0000000000000000000000000000000000000000;;					MatchContains: []string{"services"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		evaluator := NewQuotaEvaluator(quotaAccessor, install.NewRegistry(nil, nil), nil, config, 5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := &quotaAdmission{
0000000000000000000000000000000000000000;;			Handler:   admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			evaluator: evaluator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newPod := validPod("allowed-pod", 1, getResourceRequirements(getResourceList("3", "2Gi"), getResourceList("", "")))
0000000000000000000000000000000000000000;;		err := handler.Admit(admission.NewAttributesRecord(newPod, nil, api.Kind("Pod").WithVersion("version"), newPod.Namespace, newPod.Name, api.Resource("pods").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmitLimitedResourceWithQuota verifies if a limited resource is configured with quota, it can be consumed.
0000000000000000000000000000000000000000;;	func TestAdmitLimitedResourceWithQuota(t *testing.T) {
0000000000000000000000000000000000000000;;		resourceQuota := &api.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "quota", Namespace: "test", ResourceVersion: "124"},
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceRequestsCPU: resource.MustParse("10"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceRequestsCPU: resource.MustParse("1"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset(resourceQuota)
0000000000000000000000000000000000000000;;		indexer := cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers{"namespace": cache.MetaNamespaceIndexFunc})
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		quotaAccessor, _ := newQuotaAccessor()
0000000000000000000000000000000000000000;;		quotaAccessor.client = kubeClient
0000000000000000000000000000000000000000;;		quotaAccessor.lister = informerFactory.Core().InternalVersion().ResourceQuotas().Lister()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// disable consumption of cpu unless there is a covering quota.
0000000000000000000000000000000000000000;;		// disable consumption of cpu unless there is a covering quota.
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{
0000000000000000000000000000000000000000;;			LimitedResources: []resourcequotaapi.LimitedResource{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Resource:      "pods",
0000000000000000000000000000000000000000;;					MatchContains: []string{"requests.cpu"}, // match on "requests.cpu" only
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		evaluator := NewQuotaEvaluator(quotaAccessor, install.NewRegistry(nil, nil), nil, config, 5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := &quotaAdmission{
0000000000000000000000000000000000000000;;			Handler:   admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			evaluator: evaluator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		indexer.Add(resourceQuota)
0000000000000000000000000000000000000000;;		newPod := validPod("allowed-pod", 1, getResourceRequirements(getResourceList("3", "2Gi"), getResourceList("", "")))
0000000000000000000000000000000000000000;;		err := handler.Admit(admission.NewAttributesRecord(newPod, nil, api.Kind("Pod").WithVersion("version"), newPod.Namespace, newPod.Name, api.Resource("pods").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmitLimitedResourceWithMultipleQuota verifies if a limited resource is configured with quota, it can be consumed if one matches.
0000000000000000000000000000000000000000;;	func TestAdmitLimitedResourceWithMultipleQuota(t *testing.T) {
0000000000000000000000000000000000000000;;		resourceQuota1 := &api.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "quota1", Namespace: "test", ResourceVersion: "124"},
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceRequestsCPU: resource.MustParse("10"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceRequestsCPU: resource.MustParse("1"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceQuota2 := &api.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "quota2", Namespace: "test", ResourceVersion: "124"},
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceMemory: resource.MustParse("10Gi"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceMemory: resource.MustParse("1Gi"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset(resourceQuota1, resourceQuota2)
0000000000000000000000000000000000000000;;		indexer := cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers{"namespace": cache.MetaNamespaceIndexFunc})
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		quotaAccessor, _ := newQuotaAccessor()
0000000000000000000000000000000000000000;;		quotaAccessor.client = kubeClient
0000000000000000000000000000000000000000;;		quotaAccessor.lister = informerFactory.Core().InternalVersion().ResourceQuotas().Lister()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// disable consumption of cpu unless there is a covering quota.
0000000000000000000000000000000000000000;;		// disable consumption of cpu unless there is a covering quota.
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{
0000000000000000000000000000000000000000;;			LimitedResources: []resourcequotaapi.LimitedResource{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Resource:      "pods",
0000000000000000000000000000000000000000;;					MatchContains: []string{"requests.cpu"}, // match on "requests.cpu" only
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		evaluator := NewQuotaEvaluator(quotaAccessor, install.NewRegistry(nil, nil), nil, config, 5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := &quotaAdmission{
0000000000000000000000000000000000000000;;			Handler:   admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			evaluator: evaluator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		indexer.Add(resourceQuota1)
0000000000000000000000000000000000000000;;		indexer.Add(resourceQuota2)
0000000000000000000000000000000000000000;;		newPod := validPod("allowed-pod", 1, getResourceRequirements(getResourceList("3", "2Gi"), getResourceList("", "")))
0000000000000000000000000000000000000000;;		err := handler.Admit(admission.NewAttributesRecord(newPod, nil, api.Kind("Pod").WithVersion("version"), newPod.Namespace, newPod.Name, api.Resource("pods").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmitLimitedResourceWithQuotaThatDoesNotCover verifies if a limited resource is configured the quota must cover the resource.
0000000000000000000000000000000000000000;;	func TestAdmitLimitedResourceWithQuotaThatDoesNotCover(t *testing.T) {
0000000000000000000000000000000000000000;;		resourceQuota := &api.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "quota", Namespace: "test", ResourceVersion: "124"},
0000000000000000000000000000000000000000;;			Status: api.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceMemory: resource.MustParse("10Gi"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceMemory: resource.MustParse("1Gi"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset(resourceQuota)
0000000000000000000000000000000000000000;;		indexer := cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers{"namespace": cache.MetaNamespaceIndexFunc})
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		quotaAccessor, _ := newQuotaAccessor()
0000000000000000000000000000000000000000;;		quotaAccessor.client = kubeClient
0000000000000000000000000000000000000000;;		quotaAccessor.lister = informerFactory.Core().InternalVersion().ResourceQuotas().Lister()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// disable consumption of cpu unless there is a covering quota.
0000000000000000000000000000000000000000;;		// disable consumption of cpu unless there is a covering quota.
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{
0000000000000000000000000000000000000000;;			LimitedResources: []resourcequotaapi.LimitedResource{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Resource:      "pods",
0000000000000000000000000000000000000000;;					MatchContains: []string{"cpu"}, // match on "cpu" only
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		evaluator := NewQuotaEvaluator(quotaAccessor, install.NewRegistry(nil, nil), nil, config, 5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := &quotaAdmission{
0000000000000000000000000000000000000000;;			Handler:   admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			evaluator: evaluator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		indexer.Add(resourceQuota)
0000000000000000000000000000000000000000;;		newPod := validPod("not-allowed-pod", 1, getResourceRequirements(getResourceList("3", "2Gi"), getResourceList("", "")))
0000000000000000000000000000000000000000;;		err := handler.Admit(admission.NewAttributesRecord(newPod, nil, api.Kind("Pod").WithVersion("version"), newPod.Namespace, newPod.Name, api.Resource("pods").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected an error since the quota did not cover cpu")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
