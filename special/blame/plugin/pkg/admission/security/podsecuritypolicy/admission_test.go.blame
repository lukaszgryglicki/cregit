0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
de836c63d05770a43e1f2178fd4d1427d5da1111;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package podsecuritypolicy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		kadmission "k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		kapi "k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/helper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/internalversion"
0000000000000000000000000000000000000000;;		extensionslisters "k8s.io/kubernetes/pkg/client/listers/extensions/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/security/apparmor"
0000000000000000000000000000000000000000;;		kpsp "k8s.io/kubernetes/pkg/security/podsecuritypolicy"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/security/podsecuritypolicy/seccomp"
0000000000000000000000000000000000000000;;		psputil "k8s.io/kubernetes/pkg/security/podsecuritypolicy/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const defaultContainerName = "test-c"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTestAdmission provides an admission plugin with test implementations of internal structs.  It uses
0000000000000000000000000000000000000000;;	// an authorizer that always returns true.
0000000000000000000000000000000000000000;;	func NewTestAdmission(lister extensionslisters.PodSecurityPolicyLister) kadmission.Interface {
0000000000000000000000000000000000000000;;		return &podSecurityPolicyPlugin{
0000000000000000000000000000000000000000;;			Handler:         kadmission.NewHandler(kadmission.Create),
0000000000000000000000000000000000000000;;			strategyFactory: kpsp.NewSimpleStrategyFactory(),
0000000000000000000000000000000000000000;;			pspMatcher:      getMatchingPolicies,
0000000000000000000000000000000000000000;;			authz:           &TestAuthorizer{},
0000000000000000000000000000000000000000;;			lister:          lister,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAlwaysAllowedAuthorizer is a testing struct for testing that fulfills the authorizer interface.
0000000000000000000000000000000000000000;;	type TestAuthorizer struct {
0000000000000000000000000000000000000000;;		// usernameToNamespaceToAllowedPSPs contains the map of allowed PSPs.
0000000000000000000000000000000000000000;;		// if nil, all PSPs are allowed.
0000000000000000000000000000000000000000;;		usernameToNamespaceToAllowedPSPs map[string]map[string]map[string]bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *TestAuthorizer) Authorize(a authorizer.Attributes) (authorized bool, reason string, err error) {
0000000000000000000000000000000000000000;;		if t.usernameToNamespaceToAllowedPSPs == nil {
0000000000000000000000000000000000000000;;			return true, "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allowedInNamespace := t.usernameToNamespaceToAllowedPSPs[a.GetUser().GetName()][a.GetNamespace()][a.GetName()]
0000000000000000000000000000000000000000;;		allowedClusterWide := t.usernameToNamespaceToAllowedPSPs[a.GetUser().GetName()][""][a.GetName()]
0000000000000000000000000000000000000000;;		return (allowedInNamespace || allowedClusterWide), "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ authorizer.Authorizer = &TestAuthorizer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func useInitContainers(pod *kapi.Pod) *kapi.Pod {
0000000000000000000000000000000000000000;;		pod.Spec.InitContainers = pod.Spec.Containers
0000000000000000000000000000000000000000;;		pod.Spec.Containers = []kapi.Container{}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitSeccomp(t *testing.T) {
0000000000000000000000000000000000000000;;		containerName := "container"
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			pspAnnotations map[string]string
0000000000000000000000000000000000000000;;			podAnnotations map[string]string
0000000000000000000000000000000000000000;;			shouldAdmit    bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"no seccomp, no pod annotations": {
0000000000000000000000000000000000000000;;				pspAnnotations: nil,
0000000000000000000000000000000000000000;;				podAnnotations: nil,
0000000000000000000000000000000000000000;;				shouldAdmit:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no seccomp, pod annotations": {
0000000000000000000000000000000000000000;;				pspAnnotations: nil,
0000000000000000000000000000000000000000;;				podAnnotations: map[string]string{
0000000000000000000000000000000000000000;;					kapi.SeccompPodAnnotationKey: "foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldAdmit: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no seccomp, container annotations": {
0000000000000000000000000000000000000000;;				pspAnnotations: nil,
0000000000000000000000000000000000000000;;				podAnnotations: map[string]string{
0000000000000000000000000000000000000000;;					kapi.SeccompContainerAnnotationKeyPrefix + containerName: "foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldAdmit: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"seccomp, allow any no pod annotation": {
0000000000000000000000000000000000000000;;				pspAnnotations: map[string]string{
0000000000000000000000000000000000000000;;					seccomp.AllowedProfilesAnnotationKey: seccomp.AllowAny,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				podAnnotations: nil,
0000000000000000000000000000000000000000;;				shouldAdmit:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"seccomp, allow any pod annotation": {
0000000000000000000000000000000000000000;;				pspAnnotations: map[string]string{
0000000000000000000000000000000000000000;;					seccomp.AllowedProfilesAnnotationKey: seccomp.AllowAny,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				podAnnotations: map[string]string{
0000000000000000000000000000000000000000;;					kapi.SeccompPodAnnotationKey: "foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldAdmit: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"seccomp, allow any container annotation": {
0000000000000000000000000000000000000000;;				pspAnnotations: map[string]string{
0000000000000000000000000000000000000000;;					seccomp.AllowedProfilesAnnotationKey: seccomp.AllowAny,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				podAnnotations: map[string]string{
0000000000000000000000000000000000000000;;					kapi.SeccompContainerAnnotationKeyPrefix + containerName: "foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldAdmit: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"seccomp, allow specific pod annotation failure": {
0000000000000000000000000000000000000000;;				pspAnnotations: map[string]string{
0000000000000000000000000000000000000000;;					seccomp.AllowedProfilesAnnotationKey: "foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				podAnnotations: map[string]string{
0000000000000000000000000000000000000000;;					kapi.SeccompPodAnnotationKey: "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldAdmit: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"seccomp, allow specific container annotation failure": {
0000000000000000000000000000000000000000;;				pspAnnotations: map[string]string{
0000000000000000000000000000000000000000;;					// provide a default so we don't have to give the pod annotation
0000000000000000000000000000000000000000;;					seccomp.DefaultProfileAnnotationKey:  "foo",
0000000000000000000000000000000000000000;;					seccomp.AllowedProfilesAnnotationKey: "foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				podAnnotations: map[string]string{
0000000000000000000000000000000000000000;;					kapi.SeccompContainerAnnotationKeyPrefix + containerName: "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldAdmit: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"seccomp, allow specific pod annotation pass": {
0000000000000000000000000000000000000000;;				pspAnnotations: map[string]string{
0000000000000000000000000000000000000000;;					seccomp.AllowedProfilesAnnotationKey: "foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				podAnnotations: map[string]string{
0000000000000000000000000000000000000000;;					kapi.SeccompPodAnnotationKey: "foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldAdmit: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"seccomp, allow specific container annotation pass": {
0000000000000000000000000000000000000000;;				pspAnnotations: map[string]string{
0000000000000000000000000000000000000000;;					// provide a default so we don't have to give the pod annotation
0000000000000000000000000000000000000000;;					seccomp.DefaultProfileAnnotationKey:  "foo",
0000000000000000000000000000000000000000;;					seccomp.AllowedProfilesAnnotationKey: "foo,bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				podAnnotations: map[string]string{
0000000000000000000000000000000000000000;;					kapi.SeccompContainerAnnotationKeyPrefix + containerName: "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldAdmit: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			psp := restrictivePSP()
0000000000000000000000000000000000000000;;			psp.Annotations = v.pspAnnotations
0000000000000000000000000000000000000000;;			pod := &kapi.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Annotations: v.podAnnotations,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: kapi.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []kapi.Container{
0000000000000000000000000000000000000000;;						{Name: containerName},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			testPSPAdmit(k, []*extensions.PodSecurityPolicy{psp}, pod, v.shouldAdmit, psp.Name, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitPrivileged(t *testing.T) {
0000000000000000000000000000000000000000;;		createPodWithPriv := func(priv bool) *kapi.Pod {
0000000000000000000000000000000000000000;;			pod := goodPod()
0000000000000000000000000000000000000000;;			pod.Spec.Containers[0].SecurityContext.Privileged = &priv
0000000000000000000000000000000000000000;;			return pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nonPrivilegedPSP := restrictivePSP()
0000000000000000000000000000000000000000;;		nonPrivilegedPSP.Name = "non-priv"
0000000000000000000000000000000000000000;;		nonPrivilegedPSP.Spec.Privileged = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		privilegedPSP := restrictivePSP()
0000000000000000000000000000000000000000;;		privilegedPSP.Name = "priv"
0000000000000000000000000000000000000000;;		privilegedPSP.Spec.Privileged = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			pod          *kapi.Pod
0000000000000000000000000000000000000000;;			psps         []*extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;			shouldPass   bool
0000000000000000000000000000000000000000;;			expectedPriv bool
0000000000000000000000000000000000000000;;			expectedPSP  string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"pod without priv request allowed under non priv PSP": {
0000000000000000000000000000000000000000;;				pod:          goodPod(),
0000000000000000000000000000000000000000;;				psps:         []*extensions.PodSecurityPolicy{nonPrivilegedPSP},
0000000000000000000000000000000000000000;;				shouldPass:   true,
0000000000000000000000000000000000000000;;				expectedPriv: false,
0000000000000000000000000000000000000000;;				expectedPSP:  nonPrivilegedPSP.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod without priv request allowed under priv PSP": {
0000000000000000000000000000000000000000;;				pod:          goodPod(),
0000000000000000000000000000000000000000;;				psps:         []*extensions.PodSecurityPolicy{privilegedPSP},
0000000000000000000000000000000000000000;;				shouldPass:   true,
0000000000000000000000000000000000000000;;				expectedPriv: false,
0000000000000000000000000000000000000000;;				expectedPSP:  privilegedPSP.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with priv request denied by non priv PSP": {
0000000000000000000000000000000000000000;;				pod:        createPodWithPriv(true),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{nonPrivilegedPSP},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with priv request allowed by priv PSP": {
0000000000000000000000000000000000000000;;				pod:          createPodWithPriv(true),
0000000000000000000000000000000000000000;;				psps:         []*extensions.PodSecurityPolicy{nonPrivilegedPSP, privilegedPSP},
0000000000000000000000000000000000000000;;				shouldPass:   true,
0000000000000000000000000000000000000000;;				expectedPriv: true,
0000000000000000000000000000000000000000;;				expectedPSP:  privilegedPSP.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			testPSPAdmit(k, v.psps, v.pod, v.shouldPass, v.expectedPSP, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v.shouldPass {
0000000000000000000000000000000000000000;;				if v.pod.Spec.Containers[0].SecurityContext.Privileged == nil ||
0000000000000000000000000000000000000000;;					*v.pod.Spec.Containers[0].SecurityContext.Privileged != v.expectedPriv {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected privileged to be %t", k, v.expectedPriv)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitCaps(t *testing.T) {
0000000000000000000000000000000000000000;;		createPodWithCaps := func(caps *kapi.Capabilities) *kapi.Pod {
0000000000000000000000000000000000000000;;			pod := goodPod()
0000000000000000000000000000000000000000;;			pod.Spec.Containers[0].SecurityContext.Capabilities = caps
0000000000000000000000000000000000000000;;			return pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restricted := restrictivePSP()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allowsFooInAllowed := restrictivePSP()
0000000000000000000000000000000000000000;;		allowsFooInAllowed.Name = "allowCapInAllowed"
0000000000000000000000000000000000000000;;		allowsFooInAllowed.Spec.AllowedCapabilities = []kapi.Capability{"foo"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allowsFooInRequired := restrictivePSP()
0000000000000000000000000000000000000000;;		allowsFooInRequired.Name = "allowCapInRequired"
0000000000000000000000000000000000000000;;		allowsFooInRequired.Spec.DefaultAddCapabilities = []kapi.Capability{"foo"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requiresFooToBeDropped := restrictivePSP()
0000000000000000000000000000000000000000;;		requiresFooToBeDropped.Name = "requireDrop"
0000000000000000000000000000000000000000;;		requiresFooToBeDropped.Spec.RequiredDropCapabilities = []kapi.Capability{"foo"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc := map[string]struct {
0000000000000000000000000000000000000000;;			pod                  *kapi.Pod
0000000000000000000000000000000000000000;;			psps                 []*extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;			shouldPass           bool
0000000000000000000000000000000000000000;;			expectedCapabilities *kapi.Capabilities
0000000000000000000000000000000000000000;;			expectedPSP          string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// UC 1: if a PSP does not define allowed or required caps then a pod requesting a cap
0000000000000000000000000000000000000000;;			// should be rejected.
0000000000000000000000000000000000000000;;			"should reject cap add when not allowed or required": {
0000000000000000000000000000000000000000;;				pod:        createPodWithCaps(&kapi.Capabilities{Add: []kapi.Capability{"foo"}}),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{restricted},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// UC 2: if a PSP allows a cap in the allowed field it should accept the pod request
0000000000000000000000000000000000000000;;			// to add the cap.
0000000000000000000000000000000000000000;;			"should accept cap add when in allowed": {
0000000000000000000000000000000000000000;;				pod:         createPodWithCaps(&kapi.Capabilities{Add: []kapi.Capability{"foo"}}),
0000000000000000000000000000000000000000;;				psps:        []*extensions.PodSecurityPolicy{restricted, allowsFooInAllowed},
0000000000000000000000000000000000000000;;				shouldPass:  true,
0000000000000000000000000000000000000000;;				expectedPSP: allowsFooInAllowed.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// UC 3: if a PSP requires a cap then it should accept the pod request
0000000000000000000000000000000000000000;;			// to add the cap.
0000000000000000000000000000000000000000;;			"should accept cap add when in required": {
0000000000000000000000000000000000000000;;				pod:         createPodWithCaps(&kapi.Capabilities{Add: []kapi.Capability{"foo"}}),
0000000000000000000000000000000000000000;;				psps:        []*extensions.PodSecurityPolicy{restricted, allowsFooInRequired},
0000000000000000000000000000000000000000;;				shouldPass:  true,
0000000000000000000000000000000000000000;;				expectedPSP: allowsFooInRequired.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// UC 4: if a PSP requires a cap to be dropped then it should fail both
0000000000000000000000000000000000000000;;			// in the verification of adds and verification of drops
0000000000000000000000000000000000000000;;			"should reject cap add when requested cap is required to be dropped": {
0000000000000000000000000000000000000000;;				pod:        createPodWithCaps(&kapi.Capabilities{Add: []kapi.Capability{"foo"}}),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{restricted, requiresFooToBeDropped},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// UC 5: if a PSP requires a cap to be dropped it should accept
0000000000000000000000000000000000000000;;			// a manual request to drop the cap.
0000000000000000000000000000000000000000;;			"should accept cap drop when cap is required to be dropped": {
0000000000000000000000000000000000000000;;				pod:         createPodWithCaps(&kapi.Capabilities{Drop: []kapi.Capability{"foo"}}),
0000000000000000000000000000000000000000;;				psps:        []*extensions.PodSecurityPolicy{requiresFooToBeDropped},
0000000000000000000000000000000000000000;;				shouldPass:  true,
0000000000000000000000000000000000000000;;				expectedPSP: requiresFooToBeDropped.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// UC 6: required add is defaulted
0000000000000000000000000000000000000000;;			"required add is defaulted": {
0000000000000000000000000000000000000000;;				pod:        goodPod(),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{allowsFooInRequired},
0000000000000000000000000000000000000000;;				shouldPass: true,
0000000000000000000000000000000000000000;;				expectedCapabilities: &kapi.Capabilities{
0000000000000000000000000000000000000000;;					Add: []kapi.Capability{"foo"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedPSP: allowsFooInRequired.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// UC 7: required drop is defaulted
0000000000000000000000000000000000000000;;			"required drop is defaulted": {
0000000000000000000000000000000000000000;;				pod:        goodPod(),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{requiresFooToBeDropped},
0000000000000000000000000000000000000000;;				shouldPass: true,
0000000000000000000000000000000000000000;;				expectedCapabilities: &kapi.Capabilities{
0000000000000000000000000000000000000000;;					Drop: []kapi.Capability{"foo"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedPSP: requiresFooToBeDropped.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tc {
0000000000000000000000000000000000000000;;			testPSPAdmit(k, v.psps, v.pod, v.shouldPass, v.expectedPSP, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v.expectedCapabilities != nil {
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(v.expectedCapabilities, v.pod.Spec.Containers[0].SecurityContext.Capabilities) {
0000000000000000000000000000000000000000;;					t.Errorf("%s resulted in caps that were not expected - expected: %v, received: %v", k, v.expectedCapabilities, v.pod.Spec.Containers[0].SecurityContext.Capabilities)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tc {
0000000000000000000000000000000000000000;;			useInitContainers(v.pod)
0000000000000000000000000000000000000000;;			testPSPAdmit(k, v.psps, v.pod, v.shouldPass, v.expectedPSP, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v.expectedCapabilities != nil {
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(v.expectedCapabilities, v.pod.Spec.InitContainers[0].SecurityContext.Capabilities) {
0000000000000000000000000000000000000000;;					t.Errorf("%s resulted in caps that were not expected - expected: %v, received: %v", k, v.expectedCapabilities, v.pod.Spec.InitContainers[0].SecurityContext.Capabilities)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitVolumes(t *testing.T) {
0000000000000000000000000000000000000000;;		val := reflect.ValueOf(kapi.VolumeSource{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < val.NumField(); i++ {
0000000000000000000000000000000000000000;;			// reflectively create the volume source
0000000000000000000000000000000000000000;;			fieldVal := val.Type().Field(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			volumeSource := kapi.VolumeSource{}
0000000000000000000000000000000000000000;;			volumeSourceVolume := reflect.New(fieldVal.Type.Elem())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			reflect.ValueOf(&volumeSource).Elem().FieldByName(fieldVal.Name).Set(volumeSourceVolume)
0000000000000000000000000000000000000000;;			volume := kapi.Volume{VolumeSource: volumeSource}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// sanity check before moving on
0000000000000000000000000000000000000000;;			fsType, err := psputil.GetVolumeFSType(volume)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("error getting FSType for %s: %s", fieldVal.Name, err.Error())
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// add the volume to the pod
0000000000000000000000000000000000000000;;			pod := goodPod()
0000000000000000000000000000000000000000;;			pod.Spec.Volumes = []kapi.Volume{volume}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// create a PSP that allows no volumes
0000000000000000000000000000000000000000;;			psp := restrictivePSP()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// expect a denial for this PSP
0000000000000000000000000000000000000000;;			testPSPAdmit(fmt.Sprintf("%s denial", string(fsType)), []*extensions.PodSecurityPolicy{psp}, pod, false, "", t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// also expect a denial for this PSP if it's an init container
0000000000000000000000000000000000000000;;			useInitContainers(pod)
0000000000000000000000000000000000000000;;			testPSPAdmit(fmt.Sprintf("%s denial", string(fsType)), []*extensions.PodSecurityPolicy{psp}, pod, false, "", t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// now add the fstype directly to the psp and it should validate
0000000000000000000000000000000000000000;;			psp.Spec.Volumes = []extensions.FSType{fsType}
0000000000000000000000000000000000000000;;			testPSPAdmit(fmt.Sprintf("%s direct accept", string(fsType)), []*extensions.PodSecurityPolicy{psp}, pod, true, psp.Name, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// now change the psp to allow any volumes and the pod should still validate
0000000000000000000000000000000000000000;;			psp.Spec.Volumes = []extensions.FSType{extensions.All}
0000000000000000000000000000000000000000;;			testPSPAdmit(fmt.Sprintf("%s wildcard accept", string(fsType)), []*extensions.PodSecurityPolicy{psp}, pod, true, psp.Name, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitHostNetwork(t *testing.T) {
0000000000000000000000000000000000000000;;		createPodWithHostNetwork := func(hostNetwork bool) *kapi.Pod {
0000000000000000000000000000000000000000;;			pod := goodPod()
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext.HostNetwork = hostNetwork
0000000000000000000000000000000000000000;;			return pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		noHostNetwork := restrictivePSP()
0000000000000000000000000000000000000000;;		noHostNetwork.Name = "no-hostnetwork"
0000000000000000000000000000000000000000;;		noHostNetwork.Spec.HostNetwork = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostNetwork := restrictivePSP()
0000000000000000000000000000000000000000;;		hostNetwork.Name = "hostnetwork"
0000000000000000000000000000000000000000;;		hostNetwork.Spec.HostNetwork = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			pod                 *kapi.Pod
0000000000000000000000000000000000000000;;			psps                []*extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;			shouldPass          bool
0000000000000000000000000000000000000000;;			expectedHostNetwork bool
0000000000000000000000000000000000000000;;			expectedPSP         string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"pod without hostnetwork request allowed under noHostNetwork PSP": {
0000000000000000000000000000000000000000;;				pod:                 goodPod(),
0000000000000000000000000000000000000000;;				psps:                []*extensions.PodSecurityPolicy{noHostNetwork},
0000000000000000000000000000000000000000;;				shouldPass:          true,
0000000000000000000000000000000000000000;;				expectedHostNetwork: false,
0000000000000000000000000000000000000000;;				expectedPSP:         noHostNetwork.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod without hostnetwork request allowed under hostNetwork PSP": {
0000000000000000000000000000000000000000;;				pod:                 goodPod(),
0000000000000000000000000000000000000000;;				psps:                []*extensions.PodSecurityPolicy{hostNetwork},
0000000000000000000000000000000000000000;;				shouldPass:          true,
0000000000000000000000000000000000000000;;				expectedHostNetwork: false,
0000000000000000000000000000000000000000;;				expectedPSP:         hostNetwork.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with hostnetwork request denied by noHostNetwork PSP": {
0000000000000000000000000000000000000000;;				pod:        createPodWithHostNetwork(true),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{noHostNetwork},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with hostnetwork request allowed by hostNetwork PSP": {
0000000000000000000000000000000000000000;;				pod:                 createPodWithHostNetwork(true),
0000000000000000000000000000000000000000;;				psps:                []*extensions.PodSecurityPolicy{noHostNetwork, hostNetwork},
0000000000000000000000000000000000000000;;				shouldPass:          true,
0000000000000000000000000000000000000000;;				expectedHostNetwork: true,
0000000000000000000000000000000000000000;;				expectedPSP:         hostNetwork.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			testPSPAdmit(k, v.psps, v.pod, v.shouldPass, v.expectedPSP, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v.shouldPass {
0000000000000000000000000000000000000000;;				if v.pod.Spec.SecurityContext.HostNetwork != v.expectedHostNetwork {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected hostNetwork to be %t", k, v.expectedHostNetwork)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// test again with init containers
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			useInitContainers(v.pod)
0000000000000000000000000000000000000000;;			testPSPAdmit(k, v.psps, v.pod, v.shouldPass, v.expectedPSP, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v.shouldPass {
0000000000000000000000000000000000000000;;				if v.pod.Spec.SecurityContext.HostNetwork != v.expectedHostNetwork {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected hostNetwork to be %t", k, v.expectedHostNetwork)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitHostPorts(t *testing.T) {
0000000000000000000000000000000000000000;;		createPodWithHostPorts := func(port int32) *kapi.Pod {
0000000000000000000000000000000000000000;;			pod := goodPod()
0000000000000000000000000000000000000000;;			pod.Spec.Containers[0].Ports = []kapi.ContainerPort{
0000000000000000000000000000000000000000;;				{HostPort: port},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		noHostPorts := restrictivePSP()
0000000000000000000000000000000000000000;;		noHostPorts.Name = "noHostPorts"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostPorts := restrictivePSP()
0000000000000000000000000000000000000000;;		hostPorts.Name = "hostPorts"
0000000000000000000000000000000000000000;;		hostPorts.Spec.HostPorts = []extensions.HostPortRange{
0000000000000000000000000000000000000000;;			{Min: 1, Max: 10},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			pod         *kapi.Pod
0000000000000000000000000000000000000000;;			psps        []*extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;			shouldPass  bool
0000000000000000000000000000000000000000;;			expectedPSP string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"host port out of range": {
0000000000000000000000000000000000000000;;				pod:        createPodWithHostPorts(11),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{hostPorts},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"host port in range": {
0000000000000000000000000000000000000000;;				pod:         createPodWithHostPorts(5),
0000000000000000000000000000000000000000;;				psps:        []*extensions.PodSecurityPolicy{hostPorts},
0000000000000000000000000000000000000000;;				shouldPass:  true,
0000000000000000000000000000000000000000;;				expectedPSP: hostPorts.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no host ports with range": {
0000000000000000000000000000000000000000;;				pod:         goodPod(),
0000000000000000000000000000000000000000;;				psps:        []*extensions.PodSecurityPolicy{hostPorts},
0000000000000000000000000000000000000000;;				shouldPass:  true,
0000000000000000000000000000000000000000;;				expectedPSP: hostPorts.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no host ports without range": {
0000000000000000000000000000000000000000;;				pod:         goodPod(),
0000000000000000000000000000000000000000;;				psps:        []*extensions.PodSecurityPolicy{noHostPorts},
0000000000000000000000000000000000000000;;				shouldPass:  true,
0000000000000000000000000000000000000000;;				expectedPSP: noHostPorts.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"host ports without range": {
0000000000000000000000000000000000000000;;				pod:        createPodWithHostPorts(5),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{noHostPorts},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 2; i++ {
0000000000000000000000000000000000000000;;			for k, v := range tests {
0000000000000000000000000000000000000000;;				v.pod.Spec.Containers, v.pod.Spec.InitContainers = v.pod.Spec.InitContainers, v.pod.Spec.Containers
0000000000000000000000000000000000000000;;				testPSPAdmit(k, v.psps, v.pod, v.shouldPass, v.expectedPSP, t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitHostPID(t *testing.T) {
0000000000000000000000000000000000000000;;		createPodWithHostPID := func(hostPID bool) *kapi.Pod {
0000000000000000000000000000000000000000;;			pod := goodPod()
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext.HostPID = hostPID
0000000000000000000000000000000000000000;;			return pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		noHostPID := restrictivePSP()
0000000000000000000000000000000000000000;;		noHostPID.Name = "no-hostpid"
0000000000000000000000000000000000000000;;		noHostPID.Spec.HostPID = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostPID := restrictivePSP()
0000000000000000000000000000000000000000;;		hostPID.Name = "hostpid"
0000000000000000000000000000000000000000;;		hostPID.Spec.HostPID = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			pod             *kapi.Pod
0000000000000000000000000000000000000000;;			psps            []*extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;			shouldPass      bool
0000000000000000000000000000000000000000;;			expectedHostPID bool
0000000000000000000000000000000000000000;;			expectedPSP     string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"pod without hostpid request allowed under noHostPID PSP": {
0000000000000000000000000000000000000000;;				pod:             goodPod(),
0000000000000000000000000000000000000000;;				psps:            []*extensions.PodSecurityPolicy{noHostPID},
0000000000000000000000000000000000000000;;				shouldPass:      true,
0000000000000000000000000000000000000000;;				expectedHostPID: false,
0000000000000000000000000000000000000000;;				expectedPSP:     noHostPID.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod without hostpid request allowed under hostPID PSP": {
0000000000000000000000000000000000000000;;				pod:             goodPod(),
0000000000000000000000000000000000000000;;				psps:            []*extensions.PodSecurityPolicy{hostPID},
0000000000000000000000000000000000000000;;				shouldPass:      true,
0000000000000000000000000000000000000000;;				expectedHostPID: false,
0000000000000000000000000000000000000000;;				expectedPSP:     hostPID.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with hostpid request denied by noHostPID PSP": {
0000000000000000000000000000000000000000;;				pod:        createPodWithHostPID(true),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{noHostPID},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with hostpid request allowed by hostPID PSP": {
0000000000000000000000000000000000000000;;				pod:             createPodWithHostPID(true),
0000000000000000000000000000000000000000;;				psps:            []*extensions.PodSecurityPolicy{noHostPID, hostPID},
0000000000000000000000000000000000000000;;				shouldPass:      true,
0000000000000000000000000000000000000000;;				expectedHostPID: true,
0000000000000000000000000000000000000000;;				expectedPSP:     hostPID.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			testPSPAdmit(k, v.psps, v.pod, v.shouldPass, v.expectedPSP, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v.shouldPass {
0000000000000000000000000000000000000000;;				if v.pod.Spec.SecurityContext.HostPID != v.expectedHostPID {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected hostPID to be %t", k, v.expectedHostPID)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitHostIPC(t *testing.T) {
0000000000000000000000000000000000000000;;		createPodWithHostIPC := func(hostIPC bool) *kapi.Pod {
0000000000000000000000000000000000000000;;			pod := goodPod()
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext.HostIPC = hostIPC
0000000000000000000000000000000000000000;;			return pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		noHostIPC := restrictivePSP()
0000000000000000000000000000000000000000;;		noHostIPC.Name = "no-hostIPC"
0000000000000000000000000000000000000000;;		noHostIPC.Spec.HostIPC = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostIPC := restrictivePSP()
0000000000000000000000000000000000000000;;		hostIPC.Name = "hostIPC"
0000000000000000000000000000000000000000;;		hostIPC.Spec.HostIPC = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			pod             *kapi.Pod
0000000000000000000000000000000000000000;;			psps            []*extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;			shouldPass      bool
0000000000000000000000000000000000000000;;			expectedHostIPC bool
0000000000000000000000000000000000000000;;			expectedPSP     string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"pod without hostIPC request allowed under noHostIPC PSP": {
0000000000000000000000000000000000000000;;				pod:             goodPod(),
0000000000000000000000000000000000000000;;				psps:            []*extensions.PodSecurityPolicy{noHostIPC},
0000000000000000000000000000000000000000;;				shouldPass:      true,
0000000000000000000000000000000000000000;;				expectedHostIPC: false,
0000000000000000000000000000000000000000;;				expectedPSP:     noHostIPC.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod without hostIPC request allowed under hostIPC PSP": {
0000000000000000000000000000000000000000;;				pod:             goodPod(),
0000000000000000000000000000000000000000;;				psps:            []*extensions.PodSecurityPolicy{hostIPC},
0000000000000000000000000000000000000000;;				shouldPass:      true,
0000000000000000000000000000000000000000;;				expectedHostIPC: false,
0000000000000000000000000000000000000000;;				expectedPSP:     hostIPC.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with hostIPC request denied by noHostIPC PSP": {
0000000000000000000000000000000000000000;;				pod:        createPodWithHostIPC(true),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{noHostIPC},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with hostIPC request allowed by hostIPC PSP": {
0000000000000000000000000000000000000000;;				pod:             createPodWithHostIPC(true),
0000000000000000000000000000000000000000;;				psps:            []*extensions.PodSecurityPolicy{noHostIPC, hostIPC},
0000000000000000000000000000000000000000;;				shouldPass:      true,
0000000000000000000000000000000000000000;;				expectedHostIPC: true,
0000000000000000000000000000000000000000;;				expectedPSP:     hostIPC.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			testPSPAdmit(k, v.psps, v.pod, v.shouldPass, v.expectedPSP, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v.shouldPass {
0000000000000000000000000000000000000000;;				if v.pod.Spec.SecurityContext.HostIPC != v.expectedHostIPC {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected hostIPC to be %t", k, v.expectedHostIPC)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitSELinux(t *testing.T) {
0000000000000000000000000000000000000000;;		createPodWithSELinux := func(opts *kapi.SELinuxOptions) *kapi.Pod {
0000000000000000000000000000000000000000;;			pod := goodPod()
0000000000000000000000000000000000000000;;			// doesn't matter if we set it here or on the container, the
0000000000000000000000000000000000000000;;			// admission controller uses DetermineEffectiveSC to get the defaulting
0000000000000000000000000000000000000000;;			// behavior so it can validate what will be applied at runtime
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext.SELinuxOptions = opts
0000000000000000000000000000000000000000;;			return pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runAsAny := restrictivePSP()
0000000000000000000000000000000000000000;;		runAsAny.Name = "runAsAny"
0000000000000000000000000000000000000000;;		runAsAny.Spec.SELinux.Rule = extensions.SELinuxStrategyRunAsAny
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mustRunAs := restrictivePSP()
0000000000000000000000000000000000000000;;		mustRunAs.Name = "mustRunAs"
0000000000000000000000000000000000000000;;		mustRunAs.Spec.SELinux.SELinuxOptions.Level = "level"
0000000000000000000000000000000000000000;;		mustRunAs.Spec.SELinux.SELinuxOptions.Role = "role"
0000000000000000000000000000000000000000;;		mustRunAs.Spec.SELinux.SELinuxOptions.Type = "type"
0000000000000000000000000000000000000000;;		mustRunAs.Spec.SELinux.SELinuxOptions.User = "user"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			pod             *kapi.Pod
0000000000000000000000000000000000000000;;			psps            []*extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;			shouldPass      bool
0000000000000000000000000000000000000000;;			expectedSELinux *kapi.SELinuxOptions
0000000000000000000000000000000000000000;;			expectedPSP     string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"runAsAny with no pod request": {
0000000000000000000000000000000000000000;;				pod:             goodPod(),
0000000000000000000000000000000000000000;;				psps:            []*extensions.PodSecurityPolicy{runAsAny},
0000000000000000000000000000000000000000;;				shouldPass:      true,
0000000000000000000000000000000000000000;;				expectedSELinux: nil,
0000000000000000000000000000000000000000;;				expectedPSP:     runAsAny.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"runAsAny with pod request": {
0000000000000000000000000000000000000000;;				pod:             createPodWithSELinux(&kapi.SELinuxOptions{User: "foo"}),
0000000000000000000000000000000000000000;;				psps:            []*extensions.PodSecurityPolicy{runAsAny},
0000000000000000000000000000000000000000;;				shouldPass:      true,
0000000000000000000000000000000000000000;;				expectedSELinux: &kapi.SELinuxOptions{User: "foo"},
0000000000000000000000000000000000000000;;				expectedPSP:     runAsAny.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"mustRunAs with bad pod request": {
0000000000000000000000000000000000000000;;				pod:        createPodWithSELinux(&kapi.SELinuxOptions{User: "foo"}),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{mustRunAs},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"mustRunAs with no pod request": {
0000000000000000000000000000000000000000;;				pod:             goodPod(),
0000000000000000000000000000000000000000;;				psps:            []*extensions.PodSecurityPolicy{mustRunAs},
0000000000000000000000000000000000000000;;				shouldPass:      true,
0000000000000000000000000000000000000000;;				expectedSELinux: mustRunAs.Spec.SELinux.SELinuxOptions,
0000000000000000000000000000000000000000;;				expectedPSP:     mustRunAs.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"mustRunAs with good pod request": {
0000000000000000000000000000000000000000;;				pod:             createPodWithSELinux(&kapi.SELinuxOptions{Level: "level", Role: "role", Type: "type", User: "user"}),
0000000000000000000000000000000000000000;;				psps:            []*extensions.PodSecurityPolicy{mustRunAs},
0000000000000000000000000000000000000000;;				shouldPass:      true,
0000000000000000000000000000000000000000;;				expectedSELinux: mustRunAs.Spec.SELinux.SELinuxOptions,
0000000000000000000000000000000000000000;;				expectedPSP:     mustRunAs.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			testPSPAdmit(k, v.psps, v.pod, v.shouldPass, v.expectedPSP, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v.shouldPass {
0000000000000000000000000000000000000000;;				if v.pod.Spec.Containers[0].SecurityContext.SELinuxOptions == nil && v.expectedSELinux == nil {
0000000000000000000000000000000000000000;;					// ok, don't need to worry about identifying specific diffs
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if v.pod.Spec.Containers[0].SecurityContext.SELinuxOptions == nil && v.expectedSELinux != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected selinux to be: %v but found nil", k, v.expectedSELinux)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if v.pod.Spec.Containers[0].SecurityContext.SELinuxOptions != nil && v.expectedSELinux == nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected selinux to be nil but found: %v", k, *v.pod.Spec.Containers[0].SecurityContext.SELinuxOptions)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(*v.expectedSELinux, *v.pod.Spec.Containers[0].SecurityContext.SELinuxOptions) {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected selinux to be: %v but found %v", k, *v.expectedSELinux, *v.pod.Spec.Containers[0].SecurityContext.SELinuxOptions)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitAppArmor(t *testing.T) {
0000000000000000000000000000000000000000;;		createPodWithAppArmor := func(profile string) *kapi.Pod {
0000000000000000000000000000000000000000;;			pod := goodPod()
0000000000000000000000000000000000000000;;			apparmor.SetProfileNameFromPodAnnotations(pod.Annotations, defaultContainerName, profile)
0000000000000000000000000000000000000000;;			return pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unconstrainedPSP := restrictivePSP()
0000000000000000000000000000000000000000;;		defaultedPSP := restrictivePSP()
0000000000000000000000000000000000000000;;		defaultedPSP.Annotations = map[string]string{
0000000000000000000000000000000000000000;;			apparmor.DefaultProfileAnnotationKey: apparmor.ProfileRuntimeDefault,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		appArmorPSP := restrictivePSP()
0000000000000000000000000000000000000000;;		appArmorPSP.Annotations = map[string]string{
0000000000000000000000000000000000000000;;			apparmor.AllowedProfilesAnnotationKey: apparmor.ProfileRuntimeDefault,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		appArmorDefaultPSP := restrictivePSP()
0000000000000000000000000000000000000000;;		appArmorDefaultPSP.Annotations = map[string]string{
0000000000000000000000000000000000000000;;			apparmor.DefaultProfileAnnotationKey:  apparmor.ProfileRuntimeDefault,
0000000000000000000000000000000000000000;;			apparmor.AllowedProfilesAnnotationKey: apparmor.ProfileRuntimeDefault + "," + apparmor.ProfileNamePrefix + "foo",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			pod             *kapi.Pod
0000000000000000000000000000000000000000;;			psp             *extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;			shouldPass      bool
0000000000000000000000000000000000000000;;			expectedProfile string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"unconstrained with no profile": {
0000000000000000000000000000000000000000;;				pod:             goodPod(),
0000000000000000000000000000000000000000;;				psp:             unconstrainedPSP,
0000000000000000000000000000000000000000;;				shouldPass:      true,
0000000000000000000000000000000000000000;;				expectedProfile: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"unconstrained with profile": {
0000000000000000000000000000000000000000;;				pod:             createPodWithAppArmor(apparmor.ProfileRuntimeDefault),
0000000000000000000000000000000000000000;;				psp:             unconstrainedPSP,
0000000000000000000000000000000000000000;;				shouldPass:      true,
0000000000000000000000000000000000000000;;				expectedProfile: apparmor.ProfileRuntimeDefault,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"unconstrained with default profile": {
0000000000000000000000000000000000000000;;				pod:             goodPod(),
0000000000000000000000000000000000000000;;				psp:             defaultedPSP,
0000000000000000000000000000000000000000;;				shouldPass:      true,
0000000000000000000000000000000000000000;;				expectedProfile: apparmor.ProfileRuntimeDefault,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"AppArmor enforced with no profile": {
0000000000000000000000000000000000000000;;				pod:        goodPod(),
0000000000000000000000000000000000000000;;				psp:        appArmorPSP,
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"AppArmor enforced with default profile": {
0000000000000000000000000000000000000000;;				pod:             goodPod(),
0000000000000000000000000000000000000000;;				psp:             appArmorDefaultPSP,
0000000000000000000000000000000000000000;;				shouldPass:      true,
0000000000000000000000000000000000000000;;				expectedProfile: apparmor.ProfileRuntimeDefault,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"AppArmor enforced with good profile": {
0000000000000000000000000000000000000000;;				pod:             createPodWithAppArmor(apparmor.ProfileNamePrefix + "foo"),
0000000000000000000000000000000000000000;;				psp:             appArmorDefaultPSP,
0000000000000000000000000000000000000000;;				shouldPass:      true,
0000000000000000000000000000000000000000;;				expectedProfile: apparmor.ProfileNamePrefix + "foo",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"AppArmor enforced with local profile": {
0000000000000000000000000000000000000000;;				pod:        createPodWithAppArmor(apparmor.ProfileNamePrefix + "bar"),
0000000000000000000000000000000000000000;;				psp:        appArmorPSP,
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			testPSPAdmit(k, []*extensions.PodSecurityPolicy{v.psp}, v.pod, v.shouldPass, v.psp.Name, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v.shouldPass {
0000000000000000000000000000000000000000;;				assert.Equal(t, v.expectedProfile, apparmor.GetProfileNameFromPodAnnotations(v.pod.Annotations, defaultContainerName), k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitRunAsUser(t *testing.T) {
0000000000000000000000000000000000000000;;		createPodWithRunAsUser := func(user int64) *kapi.Pod {
0000000000000000000000000000000000000000;;			pod := goodPod()
0000000000000000000000000000000000000000;;			// doesn't matter if we set it here or on the container, the
0000000000000000000000000000000000000000;;			// admission controller uses DetermineEffectiveSC to get the defaulting
0000000000000000000000000000000000000000;;			// behavior so it can validate what will be applied at runtime
0000000000000000000000000000000000000000;;			userID := int64(user)
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext.RunAsUser = &userID
0000000000000000000000000000000000000000;;			return pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runAsAny := restrictivePSP()
0000000000000000000000000000000000000000;;		runAsAny.Name = "runAsAny"
0000000000000000000000000000000000000000;;		runAsAny.Spec.RunAsUser.Rule = extensions.RunAsUserStrategyRunAsAny
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mustRunAs := restrictivePSP()
0000000000000000000000000000000000000000;;		mustRunAs.Name = "mustRunAs"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runAsNonRoot := restrictivePSP()
0000000000000000000000000000000000000000;;		runAsNonRoot.Name = "runAsNonRoot"
0000000000000000000000000000000000000000;;		runAsNonRoot.Spec.RunAsUser.Rule = extensions.RunAsUserStrategyMustRunAsNonRoot
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			pod               *kapi.Pod
0000000000000000000000000000000000000000;;			psps              []*extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;			shouldPass        bool
0000000000000000000000000000000000000000;;			expectedRunAsUser *int64
0000000000000000000000000000000000000000;;			expectedPSP       string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"runAsAny no pod request": {
0000000000000000000000000000000000000000;;				pod:               goodPod(),
0000000000000000000000000000000000000000;;				psps:              []*extensions.PodSecurityPolicy{runAsAny},
0000000000000000000000000000000000000000;;				shouldPass:        true,
0000000000000000000000000000000000000000;;				expectedRunAsUser: nil,
0000000000000000000000000000000000000000;;				expectedPSP:       runAsAny.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"runAsAny pod request": {
0000000000000000000000000000000000000000;;				pod:               createPodWithRunAsUser(1),
0000000000000000000000000000000000000000;;				psps:              []*extensions.PodSecurityPolicy{runAsAny},
0000000000000000000000000000000000000000;;				shouldPass:        true,
0000000000000000000000000000000000000000;;				expectedRunAsUser: userIDPtr(1),
0000000000000000000000000000000000000000;;				expectedPSP:       runAsAny.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"mustRunAs pod request out of range": {
0000000000000000000000000000000000000000;;				pod:        createPodWithRunAsUser(1),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{mustRunAs},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"mustRunAs pod request in range": {
0000000000000000000000000000000000000000;;				pod:               createPodWithRunAsUser(999),
0000000000000000000000000000000000000000;;				psps:              []*extensions.PodSecurityPolicy{mustRunAs},
0000000000000000000000000000000000000000;;				shouldPass:        true,
0000000000000000000000000000000000000000;;				expectedRunAsUser: &mustRunAs.Spec.RunAsUser.Ranges[0].Min,
0000000000000000000000000000000000000000;;				expectedPSP:       mustRunAs.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"mustRunAs no pod request": {
0000000000000000000000000000000000000000;;				pod:               goodPod(),
0000000000000000000000000000000000000000;;				psps:              []*extensions.PodSecurityPolicy{mustRunAs},
0000000000000000000000000000000000000000;;				shouldPass:        true,
0000000000000000000000000000000000000000;;				expectedRunAsUser: &mustRunAs.Spec.RunAsUser.Ranges[0].Min,
0000000000000000000000000000000000000000;;				expectedPSP:       mustRunAs.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"runAsNonRoot no pod request": {
0000000000000000000000000000000000000000;;				pod:               goodPod(),
0000000000000000000000000000000000000000;;				psps:              []*extensions.PodSecurityPolicy{runAsNonRoot},
0000000000000000000000000000000000000000;;				shouldPass:        true,
0000000000000000000000000000000000000000;;				expectedRunAsUser: nil,
0000000000000000000000000000000000000000;;				expectedPSP:       runAsNonRoot.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"runAsNonRoot pod request root": {
0000000000000000000000000000000000000000;;				pod:        createPodWithRunAsUser(0),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{runAsNonRoot},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"runAsNonRoot pod request non-root": {
0000000000000000000000000000000000000000;;				pod:               createPodWithRunAsUser(1),
0000000000000000000000000000000000000000;;				psps:              []*extensions.PodSecurityPolicy{runAsNonRoot},
0000000000000000000000000000000000000000;;				shouldPass:        true,
0000000000000000000000000000000000000000;;				expectedRunAsUser: userIDPtr(1),
0000000000000000000000000000000000000000;;				expectedPSP:       runAsNonRoot.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			testPSPAdmit(k, v.psps, v.pod, v.shouldPass, v.expectedPSP, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v.shouldPass {
0000000000000000000000000000000000000000;;				if v.pod.Spec.Containers[0].SecurityContext.RunAsUser == nil && v.expectedRunAsUser == nil {
0000000000000000000000000000000000000000;;					// ok, don't need to worry about identifying specific diffs
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if v.pod.Spec.Containers[0].SecurityContext.RunAsUser == nil && v.expectedRunAsUser != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected RunAsUser to be: %v but found nil", k, v.expectedRunAsUser)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if v.pod.Spec.Containers[0].SecurityContext.RunAsUser != nil && v.expectedRunAsUser == nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected RunAsUser to be nil but found: %v", k, *v.pod.Spec.Containers[0].SecurityContext.RunAsUser)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if *v.expectedRunAsUser != *v.pod.Spec.Containers[0].SecurityContext.RunAsUser {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected RunAsUser to be: %v but found %v", k, *v.expectedRunAsUser, *v.pod.Spec.Containers[0].SecurityContext.RunAsUser)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitSupplementalGroups(t *testing.T) {
0000000000000000000000000000000000000000;;		createPodWithSupGroup := func(group int64) *kapi.Pod {
0000000000000000000000000000000000000000;;			pod := goodPod()
0000000000000000000000000000000000000000;;			// doesn't matter if we set it here or on the container, the
0000000000000000000000000000000000000000;;			// admission controller uses DetermineEffectiveSC to get the defaulting
0000000000000000000000000000000000000000;;			// behavior so it can validate what will be applied at runtime
0000000000000000000000000000000000000000;;			groupID := int64(group)
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext.SupplementalGroups = []int64{groupID}
0000000000000000000000000000000000000000;;			return pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runAsAny := restrictivePSP()
0000000000000000000000000000000000000000;;		runAsAny.Name = "runAsAny"
0000000000000000000000000000000000000000;;		runAsAny.Spec.SupplementalGroups.Rule = extensions.SupplementalGroupsStrategyRunAsAny
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mustRunAs := restrictivePSP()
0000000000000000000000000000000000000000;;		mustRunAs.Name = "mustRunAs"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			pod               *kapi.Pod
0000000000000000000000000000000000000000;;			psps              []*extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;			shouldPass        bool
0000000000000000000000000000000000000000;;			expectedSupGroups []int64
0000000000000000000000000000000000000000;;			expectedPSP       string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"runAsAny no pod request": {
0000000000000000000000000000000000000000;;				pod:               goodPod(),
0000000000000000000000000000000000000000;;				psps:              []*extensions.PodSecurityPolicy{runAsAny},
0000000000000000000000000000000000000000;;				shouldPass:        true,
0000000000000000000000000000000000000000;;				expectedSupGroups: []int64{},
0000000000000000000000000000000000000000;;				expectedPSP:       runAsAny.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"runAsAny pod request": {
0000000000000000000000000000000000000000;;				pod:               createPodWithSupGroup(1),
0000000000000000000000000000000000000000;;				psps:              []*extensions.PodSecurityPolicy{runAsAny},
0000000000000000000000000000000000000000;;				shouldPass:        true,
0000000000000000000000000000000000000000;;				expectedSupGroups: []int64{1},
0000000000000000000000000000000000000000;;				expectedPSP:       runAsAny.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"mustRunAs no pod request": {
0000000000000000000000000000000000000000;;				pod:               goodPod(),
0000000000000000000000000000000000000000;;				psps:              []*extensions.PodSecurityPolicy{mustRunAs},
0000000000000000000000000000000000000000;;				shouldPass:        true,
0000000000000000000000000000000000000000;;				expectedSupGroups: []int64{mustRunAs.Spec.SupplementalGroups.Ranges[0].Min},
0000000000000000000000000000000000000000;;				expectedPSP:       mustRunAs.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"mustRunAs bad pod request": {
0000000000000000000000000000000000000000;;				pod:        createPodWithSupGroup(1),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{mustRunAs},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"mustRunAs good pod request": {
0000000000000000000000000000000000000000;;				pod:               createPodWithSupGroup(999),
0000000000000000000000000000000000000000;;				psps:              []*extensions.PodSecurityPolicy{mustRunAs},
0000000000000000000000000000000000000000;;				shouldPass:        true,
0000000000000000000000000000000000000000;;				expectedSupGroups: []int64{999},
0000000000000000000000000000000000000000;;				expectedPSP:       mustRunAs.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			testPSPAdmit(k, v.psps, v.pod, v.shouldPass, v.expectedPSP, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v.shouldPass {
0000000000000000000000000000000000000000;;				if v.pod.Spec.SecurityContext.SupplementalGroups == nil && v.expectedSupGroups != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected SupplementalGroups to be: %v but found nil", k, v.expectedSupGroups)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if v.pod.Spec.SecurityContext.SupplementalGroups != nil && v.expectedSupGroups == nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected SupplementalGroups to be nil but found: %v", k, v.pod.Spec.SecurityContext.SupplementalGroups)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(v.expectedSupGroups, v.pod.Spec.SecurityContext.SupplementalGroups) {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected SupplementalGroups to be: %v but found %v", k, v.expectedSupGroups, v.pod.Spec.SecurityContext.SupplementalGroups)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitFSGroup(t *testing.T) {
0000000000000000000000000000000000000000;;		createPodWithFSGroup := func(group int) *kapi.Pod {
0000000000000000000000000000000000000000;;			pod := goodPod()
0000000000000000000000000000000000000000;;			// doesn't matter if we set it here or on the container, the
0000000000000000000000000000000000000000;;			// admission controller uses DetermineEffectiveSC to get the defaulting
0000000000000000000000000000000000000000;;			// behavior so it can validate what will be applied at runtime
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext.FSGroup = groupIDPtr(group)
0000000000000000000000000000000000000000;;			return pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runAsAny := restrictivePSP()
0000000000000000000000000000000000000000;;		runAsAny.Name = "runAsAny"
0000000000000000000000000000000000000000;;		runAsAny.Spec.FSGroup.Rule = extensions.FSGroupStrategyRunAsAny
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mustRunAs := restrictivePSP()
0000000000000000000000000000000000000000;;		mustRunAs.Name = "mustRunAs"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			pod             *kapi.Pod
0000000000000000000000000000000000000000;;			psps            []*extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;			shouldPass      bool
0000000000000000000000000000000000000000;;			expectedFSGroup *int64
0000000000000000000000000000000000000000;;			expectedPSP     string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"runAsAny no pod request": {
0000000000000000000000000000000000000000;;				pod:             goodPod(),
0000000000000000000000000000000000000000;;				psps:            []*extensions.PodSecurityPolicy{runAsAny},
0000000000000000000000000000000000000000;;				shouldPass:      true,
0000000000000000000000000000000000000000;;				expectedFSGroup: nil,
0000000000000000000000000000000000000000;;				expectedPSP:     runAsAny.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"runAsAny pod request": {
0000000000000000000000000000000000000000;;				pod:             createPodWithFSGroup(1),
0000000000000000000000000000000000000000;;				psps:            []*extensions.PodSecurityPolicy{runAsAny},
0000000000000000000000000000000000000000;;				shouldPass:      true,
0000000000000000000000000000000000000000;;				expectedFSGroup: groupIDPtr(1),
0000000000000000000000000000000000000000;;				expectedPSP:     runAsAny.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"mustRunAs no pod request": {
0000000000000000000000000000000000000000;;				pod:             goodPod(),
0000000000000000000000000000000000000000;;				psps:            []*extensions.PodSecurityPolicy{mustRunAs},
0000000000000000000000000000000000000000;;				shouldPass:      true,
0000000000000000000000000000000000000000;;				expectedFSGroup: &mustRunAs.Spec.SupplementalGroups.Ranges[0].Min,
0000000000000000000000000000000000000000;;				expectedPSP:     mustRunAs.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"mustRunAs bad pod request": {
0000000000000000000000000000000000000000;;				pod:        createPodWithFSGroup(1),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{mustRunAs},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"mustRunAs good pod request": {
0000000000000000000000000000000000000000;;				pod:             createPodWithFSGroup(999),
0000000000000000000000000000000000000000;;				psps:            []*extensions.PodSecurityPolicy{mustRunAs},
0000000000000000000000000000000000000000;;				shouldPass:      true,
0000000000000000000000000000000000000000;;				expectedFSGroup: groupIDPtr(999),
0000000000000000000000000000000000000000;;				expectedPSP:     mustRunAs.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			testPSPAdmit(k, v.psps, v.pod, v.shouldPass, v.expectedPSP, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v.shouldPass {
0000000000000000000000000000000000000000;;				if v.pod.Spec.SecurityContext.FSGroup == nil && v.expectedFSGroup == nil {
0000000000000000000000000000000000000000;;					// ok, don't need to worry about identifying specific diffs
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if v.pod.Spec.SecurityContext.FSGroup == nil && v.expectedFSGroup != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected FSGroup to be: %v but found nil", k, *v.expectedFSGroup)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if v.pod.Spec.SecurityContext.FSGroup != nil && v.expectedFSGroup == nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected FSGroup to be nil but found: %v", k, *v.pod.Spec.SecurityContext.FSGroup)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if *v.expectedFSGroup != *v.pod.Spec.SecurityContext.FSGroup {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected FSGroup to be: %v but found %v", k, *v.expectedFSGroup, *v.pod.Spec.SecurityContext.FSGroup)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitReadOnlyRootFilesystem(t *testing.T) {
0000000000000000000000000000000000000000;;		createPodWithRORFS := func(rorfs bool) *kapi.Pod {
0000000000000000000000000000000000000000;;			pod := goodPod()
0000000000000000000000000000000000000000;;			pod.Spec.Containers[0].SecurityContext.ReadOnlyRootFilesystem = &rorfs
0000000000000000000000000000000000000000;;			return pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		noRORFS := restrictivePSP()
0000000000000000000000000000000000000000;;		noRORFS.Name = "no-rorfs"
0000000000000000000000000000000000000000;;		noRORFS.Spec.ReadOnlyRootFilesystem = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rorfs := restrictivePSP()
0000000000000000000000000000000000000000;;		rorfs.Name = "rorfs"
0000000000000000000000000000000000000000;;		rorfs.Spec.ReadOnlyRootFilesystem = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			pod           *kapi.Pod
0000000000000000000000000000000000000000;;			psps          []*extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;			shouldPass    bool
0000000000000000000000000000000000000000;;			expectedRORFS bool
0000000000000000000000000000000000000000;;			expectedPSP   string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"no-rorfs allows pod request with rorfs": {
0000000000000000000000000000000000000000;;				pod:           createPodWithRORFS(true),
0000000000000000000000000000000000000000;;				psps:          []*extensions.PodSecurityPolicy{noRORFS},
0000000000000000000000000000000000000000;;				shouldPass:    true,
0000000000000000000000000000000000000000;;				expectedRORFS: true,
0000000000000000000000000000000000000000;;				expectedPSP:   noRORFS.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no-rorfs allows pod request without rorfs": {
0000000000000000000000000000000000000000;;				pod:           createPodWithRORFS(false),
0000000000000000000000000000000000000000;;				psps:          []*extensions.PodSecurityPolicy{noRORFS},
0000000000000000000000000000000000000000;;				shouldPass:    true,
0000000000000000000000000000000000000000;;				expectedRORFS: false,
0000000000000000000000000000000000000000;;				expectedPSP:   noRORFS.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"rorfs rejects pod request without rorfs": {
0000000000000000000000000000000000000000;;				pod:        createPodWithRORFS(false),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{rorfs},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"rorfs defaults nil pod request": {
0000000000000000000000000000000000000000;;				pod:           goodPod(),
0000000000000000000000000000000000000000;;				psps:          []*extensions.PodSecurityPolicy{rorfs},
0000000000000000000000000000000000000000;;				shouldPass:    true,
0000000000000000000000000000000000000000;;				expectedRORFS: true,
0000000000000000000000000000000000000000;;				expectedPSP:   rorfs.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"rorfs accepts pod request with rorfs": {
0000000000000000000000000000000000000000;;				pod:           createPodWithRORFS(true),
0000000000000000000000000000000000000000;;				psps:          []*extensions.PodSecurityPolicy{rorfs},
0000000000000000000000000000000000000000;;				shouldPass:    true,
0000000000000000000000000000000000000000;;				expectedRORFS: true,
0000000000000000000000000000000000000000;;				expectedPSP:   rorfs.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			testPSPAdmit(k, v.psps, v.pod, v.shouldPass, v.expectedPSP, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v.shouldPass {
0000000000000000000000000000000000000000;;				if v.pod.Spec.Containers[0].SecurityContext.ReadOnlyRootFilesystem == nil ||
0000000000000000000000000000000000000000;;					*v.pod.Spec.Containers[0].SecurityContext.ReadOnlyRootFilesystem != v.expectedRORFS {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected ReadOnlyRootFilesystem to be %t but found %#v", k, v.expectedRORFS, v.pod.Spec.Containers[0].SecurityContext.ReadOnlyRootFilesystem)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitSysctls(t *testing.T) {
0000000000000000000000000000000000000000;;		podWithSysctls := func(safeSysctls []string, unsafeSysctls []string) *kapi.Pod {
0000000000000000000000000000000000000000;;			pod := goodPod()
0000000000000000000000000000000000000000;;			dummySysctls := func(names []string) []kapi.Sysctl {
0000000000000000000000000000000000000000;;				sysctls := make([]kapi.Sysctl, len(names))
0000000000000000000000000000000000000000;;				for i, n := range names {
0000000000000000000000000000000000000000;;					sysctls[i].Name = n
0000000000000000000000000000000000000000;;					sysctls[i].Value = "dummy"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return sysctls
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod.Annotations[kapi.SysctlsPodAnnotationKey] = helper.PodAnnotationsFromSysctls(dummySysctls(safeSysctls))
0000000000000000000000000000000000000000;;			pod.Annotations[kapi.UnsafeSysctlsPodAnnotationKey] = helper.PodAnnotationsFromSysctls(dummySysctls(unsafeSysctls))
0000000000000000000000000000000000000000;;			return pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		noSysctls := restrictivePSP()
0000000000000000000000000000000000000000;;		noSysctls.Name = "no sysctls"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		emptySysctls := restrictivePSP()
0000000000000000000000000000000000000000;;		emptySysctls.Name = "empty sysctls"
0000000000000000000000000000000000000000;;		emptySysctls.Annotations[extensions.SysctlsPodSecurityPolicyAnnotationKey] = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mixedSysctls := restrictivePSP()
0000000000000000000000000000000000000000;;		mixedSysctls.Name = "wildcard sysctls"
0000000000000000000000000000000000000000;;		mixedSysctls.Annotations[extensions.SysctlsPodSecurityPolicyAnnotationKey] = "a.*,b.*,c,d.e.f"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		aSysctl := restrictivePSP()
0000000000000000000000000000000000000000;;		aSysctl.Name = "a sysctl"
0000000000000000000000000000000000000000;;		aSysctl.Annotations[extensions.SysctlsPodSecurityPolicyAnnotationKey] = "a"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bSysctl := restrictivePSP()
0000000000000000000000000000000000000000;;		bSysctl.Name = "b sysctl"
0000000000000000000000000000000000000000;;		bSysctl.Annotations[extensions.SysctlsPodSecurityPolicyAnnotationKey] = "b"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cSysctl := restrictivePSP()
0000000000000000000000000000000000000000;;		cSysctl.Name = "c sysctl"
0000000000000000000000000000000000000000;;		cSysctl.Annotations[extensions.SysctlsPodSecurityPolicyAnnotationKey] = "c"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		catchallSysctls := restrictivePSP()
0000000000000000000000000000000000000000;;		catchallSysctls.Name = "catchall sysctl"
0000000000000000000000000000000000000000;;		catchallSysctls.Annotations[extensions.SysctlsPodSecurityPolicyAnnotationKey] = "*"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			pod         *kapi.Pod
0000000000000000000000000000000000000000;;			psps        []*extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;			shouldPass  bool
0000000000000000000000000000000000000000;;			expectedPSP string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"pod without unsafe sysctls request allowed under noSysctls PSP": {
0000000000000000000000000000000000000000;;				pod:         goodPod(),
0000000000000000000000000000000000000000;;				psps:        []*extensions.PodSecurityPolicy{noSysctls},
0000000000000000000000000000000000000000;;				shouldPass:  true,
0000000000000000000000000000000000000000;;				expectedPSP: noSysctls.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod without any sysctls request allowed under emptySysctls PSP": {
0000000000000000000000000000000000000000;;				pod:         goodPod(),
0000000000000000000000000000000000000000;;				psps:        []*extensions.PodSecurityPolicy{emptySysctls},
0000000000000000000000000000000000000000;;				shouldPass:  true,
0000000000000000000000000000000000000000;;				expectedPSP: emptySysctls.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with safe sysctls request allowed under noSysctls PSP": {
0000000000000000000000000000000000000000;;				pod:         podWithSysctls([]string{"a", "b"}, []string{}),
0000000000000000000000000000000000000000;;				psps:        []*extensions.PodSecurityPolicy{noSysctls},
0000000000000000000000000000000000000000;;				shouldPass:  true,
0000000000000000000000000000000000000000;;				expectedPSP: noSysctls.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with unsafe sysctls request allowed under noSysctls PSP": {
0000000000000000000000000000000000000000;;				pod:         podWithSysctls([]string{}, []string{"a", "b"}),
0000000000000000000000000000000000000000;;				psps:        []*extensions.PodSecurityPolicy{noSysctls},
0000000000000000000000000000000000000000;;				shouldPass:  true,
0000000000000000000000000000000000000000;;				expectedPSP: noSysctls.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with safe sysctls request disallowed under emptySysctls PSP": {
0000000000000000000000000000000000000000;;				pod:        podWithSysctls([]string{"a", "b"}, []string{}),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{emptySysctls},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with unsafe sysctls a, b request disallowed under aSysctls SCC": {
0000000000000000000000000000000000000000;;				pod:        podWithSysctls([]string{}, []string{"a", "b"}),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{aSysctl},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with unsafe sysctls b request disallowed under aSysctls SCC": {
0000000000000000000000000000000000000000;;				pod:        podWithSysctls([]string{}, []string{"b"}),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{aSysctl},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with unsafe sysctls a request allowed under aSysctls SCC": {
0000000000000000000000000000000000000000;;				pod:         podWithSysctls([]string{}, []string{"a"}),
0000000000000000000000000000000000000000;;				psps:        []*extensions.PodSecurityPolicy{aSysctl},
0000000000000000000000000000000000000000;;				shouldPass:  true,
0000000000000000000000000000000000000000;;				expectedPSP: aSysctl.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with safe sysctls a, b request disallowed under aSysctls SCC": {
0000000000000000000000000000000000000000;;				pod:        podWithSysctls([]string{"a", "b"}, []string{}),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{aSysctl},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with safe sysctls b request disallowed under aSysctls SCC": {
0000000000000000000000000000000000000000;;				pod:        podWithSysctls([]string{"b"}, []string{}),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{aSysctl},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with safe sysctls a request allowed under aSysctls SCC": {
0000000000000000000000000000000000000000;;				pod:         podWithSysctls([]string{"a"}, []string{}),
0000000000000000000000000000000000000000;;				psps:        []*extensions.PodSecurityPolicy{aSysctl},
0000000000000000000000000000000000000000;;				shouldPass:  true,
0000000000000000000000000000000000000000;;				expectedPSP: aSysctl.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with unsafe sysctls request disallowed under emptySysctls PSP": {
0000000000000000000000000000000000000000;;				pod:        podWithSysctls([]string{}, []string{"a", "b"}),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{emptySysctls},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with matching sysctls request allowed under mixedSysctls PSP": {
0000000000000000000000000000000000000000;;				pod:         podWithSysctls([]string{"a.b", "b.c"}, []string{"c", "d.e.f"}),
0000000000000000000000000000000000000000;;				psps:        []*extensions.PodSecurityPolicy{mixedSysctls},
0000000000000000000000000000000000000000;;				shouldPass:  true,
0000000000000000000000000000000000000000;;				expectedPSP: mixedSysctls.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with not-matching unsafe sysctls request disallowed under mixedSysctls PSP": {
0000000000000000000000000000000000000000;;				pod:        podWithSysctls([]string{"a.b", "b.c", "c", "d.e.f"}, []string{"e"}),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{mixedSysctls},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with not-matching safe sysctls request disallowed under mixedSysctls PSP": {
0000000000000000000000000000000000000000;;				pod:        podWithSysctls([]string{"a.b", "b.c", "c", "d.e.f", "e"}, []string{}),
0000000000000000000000000000000000000000;;				psps:       []*extensions.PodSecurityPolicy{mixedSysctls},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with sysctls request allowed under catchallSysctls PSP": {
0000000000000000000000000000000000000000;;				pod:         podWithSysctls([]string{"e"}, []string{"f"}),
0000000000000000000000000000000000000000;;				psps:        []*extensions.PodSecurityPolicy{catchallSysctls},
0000000000000000000000000000000000000000;;				shouldPass:  true,
0000000000000000000000000000000000000000;;				expectedPSP: catchallSysctls.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with sysctls request allowed under catchallSysctls PSP, not under mixedSysctls or emptySysctls PSP": {
0000000000000000000000000000000000000000;;				pod:         podWithSysctls([]string{"e"}, []string{"f"}),
0000000000000000000000000000000000000000;;				psps:        []*extensions.PodSecurityPolicy{mixedSysctls, catchallSysctls, emptySysctls},
0000000000000000000000000000000000000000;;				shouldPass:  true,
0000000000000000000000000000000000000000;;				expectedPSP: catchallSysctls.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with safe c sysctl request allowed under cSysctl PSP, not under aSysctl or bSysctl PSP": {
0000000000000000000000000000000000000000;;				pod:         podWithSysctls([]string{}, []string{"c"}),
0000000000000000000000000000000000000000;;				psps:        []*extensions.PodSecurityPolicy{aSysctl, bSysctl, cSysctl},
0000000000000000000000000000000000000000;;				shouldPass:  true,
0000000000000000000000000000000000000000;;				expectedPSP: cSysctl.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod with unsafe c sysctl request allowed under cSysctl PSP, not under aSysctl or bSysctl PSP": {
0000000000000000000000000000000000000000;;				pod:         podWithSysctls([]string{"c"}, []string{}),
0000000000000000000000000000000000000000;;				psps:        []*extensions.PodSecurityPolicy{aSysctl, bSysctl, cSysctl},
0000000000000000000000000000000000000000;;				shouldPass:  true,
0000000000000000000000000000000000000000;;				expectedPSP: cSysctl.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			origSafeSysctls, origUnsafeSysctls, err := helper.SysctlsFromPodAnnotations(v.pod.Annotations)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("invalid sysctl annotation: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			testPSPAdmit(k, v.psps, v.pod, v.shouldPass, v.expectedPSP, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v.shouldPass {
0000000000000000000000000000000000000000;;				safeSysctls, unsafeSysctls, _ := helper.SysctlsFromPodAnnotations(v.pod.Annotations)
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(safeSysctls, origSafeSysctls) {
0000000000000000000000000000000000000000;;					t.Errorf("%s: wrong safe sysctls: expected=%v, got=%v", k, origSafeSysctls, safeSysctls)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(unsafeSysctls, origUnsafeSysctls) {
0000000000000000000000000000000000000000;;					t.Errorf("%s: wrong unsafe sysctls: expected=%v, got=%v", k, origSafeSysctls, safeSysctls)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testPSPAdmit(testCaseName string, psps []*extensions.PodSecurityPolicy, pod *kapi.Pod, shouldPass bool, expectedPSP string, t *testing.T) {
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(nil, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		store := informerFactory.Extensions().InternalVersion().PodSecurityPolicies().Informer().GetStore()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, psp := range psps {
0000000000000000000000000000000000000000;;			store.Add(psp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugin := NewTestAdmission(informerFactory.Extensions().InternalVersion().PodSecurityPolicies().Lister())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attrs := kadmission.NewAttributesRecord(pod, nil, kapi.Kind("Pod").WithVersion("version"), "namespace", "", kapi.Resource("pods").WithVersion("version"), "", kadmission.Create, &user.DefaultInfo{})
0000000000000000000000000000000000000000;;		err := plugin.Admit(attrs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if shouldPass && err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("%s: expected no errors but received %v", testCaseName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if shouldPass && err == nil {
0000000000000000000000000000000000000000;;			if pod.Annotations[psputil.ValidatedPSPAnnotation] != expectedPSP {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected to validate under %s but found %s", testCaseName, expectedPSP, pod.Annotations[psputil.ValidatedPSPAnnotation])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !shouldPass && err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("%s: expected errors but received none", testCaseName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAssignSecurityContext(t *testing.T) {
0000000000000000000000000000000000000000;;		// psp that will deny privileged container requests and has a default value for a field (uid)
0000000000000000000000000000000000000000;;		psp := restrictivePSP()
0000000000000000000000000000000000000000;;		provider, err := kpsp.NewSimpleProvider(psp, "namespace", kpsp.NewSimpleStrategyFactory())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to create provider: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		createContainer := func(priv bool) kapi.Container {
0000000000000000000000000000000000000000;;			return kapi.Container{
0000000000000000000000000000000000000000;;				SecurityContext: &kapi.SecurityContext{
0000000000000000000000000000000000000000;;					Privileged: &priv,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// these are set up such that the containers always have a nil uid.  If the case should not
0000000000000000000000000000000000000000;;		// validate then the uids should not have been updated by the strategy.  If the case should
0000000000000000000000000000000000000000;;		// validate then uids should be set.  This is ensuring that we're hanging on to the old SC
0000000000000000000000000000000000000000;;		// as we generate/validate and only updating the original container if the entire pod validates
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			pod            *kapi.Pod
0000000000000000000000000000000000000000;;			shouldValidate bool
0000000000000000000000000000000000000000;;			expectedUID    *int64
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"pod and container SC is not changed when invalid": {
0000000000000000000000000000000000000000;;				pod: &kapi.Pod{
0000000000000000000000000000000000000000;;					Spec: kapi.PodSpec{
0000000000000000000000000000000000000000;;						SecurityContext: &kapi.PodSecurityContext{},
0000000000000000000000000000000000000000;;						Containers:      []kapi.Container{createContainer(true)},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldValidate: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"must validate all containers": {
0000000000000000000000000000000000000000;;				pod: &kapi.Pod{
0000000000000000000000000000000000000000;;					Spec: kapi.PodSpec{
0000000000000000000000000000000000000000;;						// good container and bad container
0000000000000000000000000000000000000000;;						SecurityContext: &kapi.PodSecurityContext{},
0000000000000000000000000000000000000000;;						Containers:      []kapi.Container{createContainer(false), createContainer(true)},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldValidate: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pod validates": {
0000000000000000000000000000000000000000;;				pod: &kapi.Pod{
0000000000000000000000000000000000000000;;					Spec: kapi.PodSpec{
0000000000000000000000000000000000000000;;						SecurityContext: &kapi.PodSecurityContext{},
0000000000000000000000000000000000000000;;						Containers:      []kapi.Container{createContainer(false)},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldValidate: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range testCases {
0000000000000000000000000000000000000000;;			errs := assignSecurityContext(provider, v.pod, nil)
0000000000000000000000000000000000000000;;			if v.shouldValidate && len(errs) > 0 {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected to validate but received errors %v", k, errs)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !v.shouldValidate && len(errs) == 0 {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected validation errors but received none", k)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if we shouldn't have validated ensure that uid is not set on the containers
0000000000000000000000000000000000000000;;			if !v.shouldValidate {
0000000000000000000000000000000000000000;;				for _, c := range v.pod.Spec.Containers {
0000000000000000000000000000000000000000;;					if c.SecurityContext.RunAsUser != nil {
0000000000000000000000000000000000000000;;						t.Errorf("%s had non-nil UID %d.  UID should not be set on test cases that don't validate", k, *c.SecurityContext.RunAsUser)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if we validated then the pod sc should be updated now with the defaults from the psp
0000000000000000000000000000000000000000;;			if v.shouldValidate {
0000000000000000000000000000000000000000;;				for _, c := range v.pod.Spec.Containers {
0000000000000000000000000000000000000000;;					if *c.SecurityContext.RunAsUser != 999 {
0000000000000000000000000000000000000000;;						t.Errorf("%s expected uid to be defaulted to 999 but found %v", k, *c.SecurityContext.RunAsUser)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateProvidersFromConstraints(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			// use a generating function so we can test for non-mutation
0000000000000000000000000000000000000000;;			psp         func() *extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;			expectedErr string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"valid psp": {
0000000000000000000000000000000000000000;;				psp: func() *extensions.PodSecurityPolicy {
0000000000000000000000000000000000000000;;					return &extensions.PodSecurityPolicy{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name: "valid psp",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Spec: extensions.PodSecurityPolicySpec{
0000000000000000000000000000000000000000;;							SELinux: extensions.SELinuxStrategyOptions{
0000000000000000000000000000000000000000;;								Rule: extensions.SELinuxStrategyRunAsAny,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							RunAsUser: extensions.RunAsUserStrategyOptions{
0000000000000000000000000000000000000000;;								Rule: extensions.RunAsUserStrategyRunAsAny,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							FSGroup: extensions.FSGroupStrategyOptions{
0000000000000000000000000000000000000000;;								Rule: extensions.FSGroupStrategyRunAsAny,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							SupplementalGroups: extensions.SupplementalGroupsStrategyOptions{
0000000000000000000000000000000000000000;;								Rule: extensions.SupplementalGroupsStrategyRunAsAny,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"bad psp strategy options": {
0000000000000000000000000000000000000000;;				psp: func() *extensions.PodSecurityPolicy {
0000000000000000000000000000000000000000;;					return &extensions.PodSecurityPolicy{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name: "bad psp user options",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Spec: extensions.PodSecurityPolicySpec{
0000000000000000000000000000000000000000;;							SELinux: extensions.SELinuxStrategyOptions{
0000000000000000000000000000000000000000;;								Rule: extensions.SELinuxStrategyRunAsAny,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							RunAsUser: extensions.RunAsUserStrategyOptions{
0000000000000000000000000000000000000000;;								Rule: extensions.RunAsUserStrategyMustRunAs,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							FSGroup: extensions.FSGroupStrategyOptions{
0000000000000000000000000000000000000000;;								Rule: extensions.FSGroupStrategyRunAsAny,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							SupplementalGroups: extensions.SupplementalGroupsStrategyOptions{
0000000000000000000000000000000000000000;;								Rule: extensions.SupplementalGroupsStrategyRunAsAny,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedErr: "MustRunAsRange requires at least one range",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range testCases {
0000000000000000000000000000000000000000;;			admit := &podSecurityPolicyPlugin{
0000000000000000000000000000000000000000;;				Handler:         kadmission.NewHandler(kadmission.Create, kadmission.Update),
0000000000000000000000000000000000000000;;				strategyFactory: kpsp.NewSimpleStrategyFactory(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			psp := v.psp()
0000000000000000000000000000000000000000;;			_, errs := admit.createProvidersFromPolicies([]*extensions.PodSecurityPolicy{psp}, "namespace")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(psp, v.psp()) {
0000000000000000000000000000000000000000;;				diff := diff.ObjectDiff(psp, v.psp())
0000000000000000000000000000000000000000;;				t.Errorf("%s createProvidersFromPolicies mutated policy. diff:\n%s", k, diff)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(v.expectedErr) > 0 && len(errs) != 1 {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected a single error '%s' but received %v", k, v.expectedErr, errs)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(v.expectedErr) == 0 && len(errs) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("%s did not expect an error but received %v", k, errs)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// check that we got the error we expected
0000000000000000000000000000000000000000;;			if len(v.expectedErr) > 0 {
0000000000000000000000000000000000000000;;				if !strings.Contains(errs[0].Error(), v.expectedErr) {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected error '%s' but received %v", k, v.expectedErr, errs[0])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetMatchingPolicies(t *testing.T) {
0000000000000000000000000000000000000000;;		policyWithName := func(name string) *extensions.PodSecurityPolicy {
0000000000000000000000000000000000000000;;			p := restrictivePSP()
0000000000000000000000000000000000000000;;			p.Name = name
0000000000000000000000000000000000000000;;			return p
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			user             user.Info
0000000000000000000000000000000000000000;;			sa               user.Info
0000000000000000000000000000000000000000;;			ns               string
0000000000000000000000000000000000000000;;			expectedPolicies sets.String
0000000000000000000000000000000000000000;;			inPolicies       []*extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;			allowed          map[string]map[string]map[string]bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"policy allowed by user": {
0000000000000000000000000000000000000000;;				user: &user.DefaultInfo{Name: "user"},
0000000000000000000000000000000000000000;;				sa:   &user.DefaultInfo{Name: "sa"},
0000000000000000000000000000000000000000;;				ns:   "test",
0000000000000000000000000000000000000000;;				allowed: map[string]map[string]map[string]bool{
0000000000000000000000000000000000000000;;					"user": {
0000000000000000000000000000000000000000;;						"test": {"policy": true},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				inPolicies:       []*extensions.PodSecurityPolicy{policyWithName("policy")},
0000000000000000000000000000000000000000;;				expectedPolicies: sets.NewString("policy"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"policy allowed by sa": {
0000000000000000000000000000000000000000;;				user: &user.DefaultInfo{Name: "user"},
0000000000000000000000000000000000000000;;				sa:   &user.DefaultInfo{Name: "sa"},
0000000000000000000000000000000000000000;;				ns:   "test",
0000000000000000000000000000000000000000;;				allowed: map[string]map[string]map[string]bool{
0000000000000000000000000000000000000000;;					"sa": {
0000000000000000000000000000000000000000;;						"test": {"policy": true},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				inPolicies:       []*extensions.PodSecurityPolicy{policyWithName("policy")},
0000000000000000000000000000000000000000;;				expectedPolicies: sets.NewString("policy"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no policies allowed": {
0000000000000000000000000000000000000000;;				user:             &user.DefaultInfo{Name: "user"},
0000000000000000000000000000000000000000;;				sa:               &user.DefaultInfo{Name: "sa"},
0000000000000000000000000000000000000000;;				ns:               "test",
0000000000000000000000000000000000000000;;				allowed:          map[string]map[string]map[string]bool{},
0000000000000000000000000000000000000000;;				inPolicies:       []*extensions.PodSecurityPolicy{policyWithName("policy")},
0000000000000000000000000000000000000000;;				expectedPolicies: sets.NewString(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"multiple policies allowed": {
0000000000000000000000000000000000000000;;				user: &user.DefaultInfo{Name: "user"},
0000000000000000000000000000000000000000;;				sa:   &user.DefaultInfo{Name: "sa"},
0000000000000000000000000000000000000000;;				ns:   "test",
0000000000000000000000000000000000000000;;				allowed: map[string]map[string]map[string]bool{
0000000000000000000000000000000000000000;;					"sa": {
0000000000000000000000000000000000000000;;						"test":  {"policy1": true},
0000000000000000000000000000000000000000;;						"":      {"policy4": true},
0000000000000000000000000000000000000000;;						"other": {"policy6": true},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"user": {
0000000000000000000000000000000000000000;;						"test":  {"policy2": true},
0000000000000000000000000000000000000000;;						"":      {"policy5": true},
0000000000000000000000000000000000000000;;						"other": {"policy7": true},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				inPolicies: []*extensions.PodSecurityPolicy{
0000000000000000000000000000000000000000;;					policyWithName("policy1"), // allowed by sa
0000000000000000000000000000000000000000;;					policyWithName("policy2"), // allowed by user
0000000000000000000000000000000000000000;;					policyWithName("policy3"), // not allowed
0000000000000000000000000000000000000000;;					policyWithName("policy4"), // allowed by sa at cluster level
0000000000000000000000000000000000000000;;					policyWithName("policy5"), // allowed by user at cluster level
0000000000000000000000000000000000000000;;					policyWithName("policy6"), // not allowed in this namespace
0000000000000000000000000000000000000000;;					policyWithName("policy7"), // not allowed in this namespace
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedPolicies: sets.NewString("policy1", "policy2", "policy4", "policy5"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"policies are not allowed for nil user info": {
0000000000000000000000000000000000000000;;				user: nil,
0000000000000000000000000000000000000000;;				sa:   &user.DefaultInfo{Name: "sa"},
0000000000000000000000000000000000000000;;				ns:   "test",
0000000000000000000000000000000000000000;;				allowed: map[string]map[string]map[string]bool{
0000000000000000000000000000000000000000;;					"sa": {
0000000000000000000000000000000000000000;;						"test": {"policy1": true},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"user": {
0000000000000000000000000000000000000000;;						"test": {"policy2": true},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				inPolicies: []*extensions.PodSecurityPolicy{
0000000000000000000000000000000000000000;;					policyWithName("policy1"),
0000000000000000000000000000000000000000;;					policyWithName("policy2"),
0000000000000000000000000000000000000000;;					policyWithName("policy3"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				// only the policies for the sa are allowed when user info is nil
0000000000000000000000000000000000000000;;				expectedPolicies: sets.NewString("policy1"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"policies are not allowed for nil sa info": {
0000000000000000000000000000000000000000;;				user: &user.DefaultInfo{Name: "user"},
0000000000000000000000000000000000000000;;				sa:   nil,
0000000000000000000000000000000000000000;;				ns:   "test",
0000000000000000000000000000000000000000;;				allowed: map[string]map[string]map[string]bool{
0000000000000000000000000000000000000000;;					"sa": {
0000000000000000000000000000000000000000;;						"test": {"policy1": true},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"user": {
0000000000000000000000000000000000000000;;						"test": {"policy2": true},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				inPolicies: []*extensions.PodSecurityPolicy{
0000000000000000000000000000000000000000;;					policyWithName("policy1"),
0000000000000000000000000000000000000000;;					policyWithName("policy2"),
0000000000000000000000000000000000000000;;					policyWithName("policy3"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				// only the policies for the user are allowed when sa info is nil
0000000000000000000000000000000000000000;;				expectedPolicies: sets.NewString("policy2"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"policies are not allowed for nil sa and user info": {
0000000000000000000000000000000000000000;;				user: nil,
0000000000000000000000000000000000000000;;				sa:   nil,
0000000000000000000000000000000000000000;;				ns:   "test",
0000000000000000000000000000000000000000;;				allowed: map[string]map[string]map[string]bool{
0000000000000000000000000000000000000000;;					"sa": {
0000000000000000000000000000000000000000;;						"test": {"policy1": true},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"user": {
0000000000000000000000000000000000000000;;						"test": {"policy2": true},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				inPolicies: []*extensions.PodSecurityPolicy{
0000000000000000000000000000000000000000;;					policyWithName("policy1"),
0000000000000000000000000000000000000000;;					policyWithName("policy2"),
0000000000000000000000000000000000000000;;					policyWithName("policy3"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				// no policies are allowed if sa and user are both nil
0000000000000000000000000000000000000000;;				expectedPolicies: sets.NewString(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			informerFactory := informers.NewSharedInformerFactory(nil, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;			pspInformer := informerFactory.Extensions().InternalVersion().PodSecurityPolicies()
0000000000000000000000000000000000000000;;			store := pspInformer.Informer().GetStore()
0000000000000000000000000000000000000000;;			for _, psp := range v.inPolicies {
0000000000000000000000000000000000000000;;				store.Add(psp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			authz := &TestAuthorizer{usernameToNamespaceToAllowedPSPs: v.allowed}
0000000000000000000000000000000000000000;;			allowedPolicies, err := getMatchingPolicies(pspInformer.Lister(), v.user, v.sa, authz, v.ns)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s got unexpected error %#v", k, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allowedPolicyNames := sets.NewString()
0000000000000000000000000000000000000000;;			for _, p := range allowedPolicies {
0000000000000000000000000000000000000000;;				allowedPolicyNames.Insert(p.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !v.expectedPolicies.Equal(allowedPolicyNames) {
0000000000000000000000000000000000000000;;				t.Errorf("%s received unexpected policies.  Expected %#v but got %#v", k, v.expectedPolicies.List(), allowedPolicyNames.List())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func restrictivePSP() *extensions.PodSecurityPolicy {
0000000000000000000000000000000000000000;;		return &extensions.PodSecurityPolicy{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        "restrictive",
0000000000000000000000000000000000000000;;				Annotations: map[string]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.PodSecurityPolicySpec{
0000000000000000000000000000000000000000;;				RunAsUser: extensions.RunAsUserStrategyOptions{
0000000000000000000000000000000000000000;;					Rule: extensions.RunAsUserStrategyMustRunAs,
0000000000000000000000000000000000000000;;					Ranges: []extensions.UserIDRange{
0000000000000000000000000000000000000000;;						{Min: int64(999), Max: int64(999)},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				SELinux: extensions.SELinuxStrategyOptions{
0000000000000000000000000000000000000000;;					Rule: extensions.SELinuxStrategyMustRunAs,
0000000000000000000000000000000000000000;;					SELinuxOptions: &kapi.SELinuxOptions{
0000000000000000000000000000000000000000;;						Level: "s9:z0,z1",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				FSGroup: extensions.FSGroupStrategyOptions{
0000000000000000000000000000000000000000;;					Rule: extensions.FSGroupStrategyMustRunAs,
0000000000000000000000000000000000000000;;					Ranges: []extensions.GroupIDRange{
0000000000000000000000000000000000000000;;						{Min: int64(999), Max: int64(999)},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				SupplementalGroups: extensions.SupplementalGroupsStrategyOptions{
0000000000000000000000000000000000000000;;					Rule: extensions.SupplementalGroupsStrategyMustRunAs,
0000000000000000000000000000000000000000;;					Ranges: []extensions.GroupIDRange{
0000000000000000000000000000000000000000;;						{Min: int64(999), Max: int64(999)},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createNamespaceForTest() *kapi.Namespace {
0000000000000000000000000000000000000000;;		return &kapi.Namespace{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "default",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createSAForTest() *kapi.ServiceAccount {
0000000000000000000000000000000000000000;;		return &kapi.ServiceAccount{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: "default",
0000000000000000000000000000000000000000;;				Name:      "default",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// goodPod is empty and should not be used directly for testing since we're providing
0000000000000000000000000000000000000000;;	// two different PSPs.  Since no values are specified it would be allowed to match any
0000000000000000000000000000000000000000;;	// psp when defaults are filled in.
0000000000000000000000000000000000000000;;	func goodPod() *kapi.Pod {
0000000000000000000000000000000000000000;;		return &kapi.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Annotations: map[string]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: kapi.PodSpec{
0000000000000000000000000000000000000000;;				ServiceAccountName: "default",
0000000000000000000000000000000000000000;;				SecurityContext:    &kapi.PodSecurityContext{},
0000000000000000000000000000000000000000;;				Containers: []kapi.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:            defaultContainerName,
0000000000000000000000000000000000000000;;						SecurityContext: &kapi.SecurityContext{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func userIDPtr(i int) *int64 {
0000000000000000000000000000000000000000;;		userID := int64(i)
0000000000000000000000000000000000000000;;		return &userID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func groupIDPtr(i int) *int64 {
0000000000000000000000000000000000000000;;		groupID := int64(i)
0000000000000000000000000000000000000000;;		return &groupID
0000000000000000000000000000000000000000;;	}
