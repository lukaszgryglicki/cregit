0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
de836c63d05770a43e1f2178fd4d1427d5da1111;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package podsecuritypolicy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/internalversion"
0000000000000000000000000000000000000000;;		extensionslisters "k8s.io/kubernetes/pkg/client/listers/extensions/internalversion"
0000000000000000000000000000000000000000;;		kubeapiserveradmission "k8s.io/kubernetes/pkg/kubeapiserver/admission"
0000000000000000000000000000000000000000;;		psp "k8s.io/kubernetes/pkg/security/podsecuritypolicy"
0000000000000000000000000000000000000000;;		psputil "k8s.io/kubernetes/pkg/security/podsecuritypolicy/util"
0000000000000000000000000000000000000000;;		sc "k8s.io/kubernetes/pkg/securitycontext"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/serviceaccount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/maps"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		PluginName = "PodSecurityPolicy"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register registers a plugin
0000000000000000000000000000000000000000;;	func Register(plugins *admission.Plugins) {
0000000000000000000000000000000000000000;;		plugins.Register(PluginName, func(config io.Reader) (admission.Interface, error) {
0000000000000000000000000000000000000000;;			plugin := NewPlugin(psp.NewSimpleStrategyFactory(), getMatchingPolicies, true)
0000000000000000000000000000000000000000;;			return plugin, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PSPMatchFn allows plugging in how PSPs are matched against user information.
0000000000000000000000000000000000000000;;	type PSPMatchFn func(lister extensionslisters.PodSecurityPolicyLister, user user.Info, sa user.Info, authz authorizer.Authorizer, namespace string) ([]*extensions.PodSecurityPolicy, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// podSecurityPolicyPlugin holds state for and implements the admission plugin.
0000000000000000000000000000000000000000;;	type podSecurityPolicyPlugin struct {
0000000000000000000000000000000000000000;;		*admission.Handler
0000000000000000000000000000000000000000;;		strategyFactory  psp.StrategyFactory
0000000000000000000000000000000000000000;;		pspMatcher       PSPMatchFn
0000000000000000000000000000000000000000;;		failOnNoPolicies bool
0000000000000000000000000000000000000000;;		authz            authorizer.Authorizer
0000000000000000000000000000000000000000;;		lister           extensionslisters.PodSecurityPolicyLister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetAuthorizer sets the authorizer.
0000000000000000000000000000000000000000;;	func (plugin *podSecurityPolicyPlugin) SetAuthorizer(authz authorizer.Authorizer) {
0000000000000000000000000000000000000000;;		plugin.authz = authz
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate ensures an authorizer is set.
0000000000000000000000000000000000000000;;	func (plugin *podSecurityPolicyPlugin) Validate() error {
0000000000000000000000000000000000000000;;		if plugin.authz == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%s requires an authorizer", PluginName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plugin.lister == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%s requires a lister", PluginName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ admission.Interface = &podSecurityPolicyPlugin{}
0000000000000000000000000000000000000000;;	var _ kubeapiserveradmission.WantsAuthorizer = &podSecurityPolicyPlugin{}
0000000000000000000000000000000000000000;;	var _ kubeapiserveradmission.WantsInternalKubeInformerFactory = &podSecurityPolicyPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPlugin creates a new PSP admission plugin.
0000000000000000000000000000000000000000;;	func NewPlugin(strategyFactory psp.StrategyFactory, pspMatcher PSPMatchFn, failOnNoPolicies bool) *podSecurityPolicyPlugin {
0000000000000000000000000000000000000000;;		return &podSecurityPolicyPlugin{
0000000000000000000000000000000000000000;;			Handler:          admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			strategyFactory:  strategyFactory,
0000000000000000000000000000000000000000;;			pspMatcher:       pspMatcher,
0000000000000000000000000000000000000000;;			failOnNoPolicies: failOnNoPolicies,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *podSecurityPolicyPlugin) SetInternalKubeInformerFactory(f informers.SharedInformerFactory) {
0000000000000000000000000000000000000000;;		podSecurityPolicyInformer := f.Extensions().InternalVersion().PodSecurityPolicies()
0000000000000000000000000000000000000000;;		a.lister = podSecurityPolicyInformer.Lister()
0000000000000000000000000000000000000000;;		a.SetReadyFunc(podSecurityPolicyInformer.Informer().HasSynced)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Admit determines if the pod should be admitted based on the requested security context
0000000000000000000000000000000000000000;;	// and the available PSPs.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 1.  Find available PSPs.
0000000000000000000000000000000000000000;;	// 2.  Create the providers, includes setting pre-allocated values if necessary.
0000000000000000000000000000000000000000;;	// 3.  Try to generate and validate a PSP with providers.  If we find one then admit the pod
0000000000000000000000000000000000000000;;	//     with the validated PSP.  If we don't find any reject the pod and give all errors from the
0000000000000000000000000000000000000000;;	//     failed attempts.
0000000000000000000000000000000000000000;;	func (c *podSecurityPolicyPlugin) Admit(a admission.Attributes) error {
0000000000000000000000000000000000000000;;		if a.GetResource().GroupResource() != api.Resource("pods") {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(a.GetSubresource()) != 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod, ok := a.GetObject().(*api.Pod)
0000000000000000000000000000000000000000;;		// if we can't convert then we don't handle this object so just return
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get all constraints that are usable by the user
0000000000000000000000000000000000000000;;		glog.V(4).Infof("getting pod security policies for pod %s (generate: %s)", pod.Name, pod.GenerateName)
0000000000000000000000000000000000000000;;		var saInfo user.Info
0000000000000000000000000000000000000000;;		if len(pod.Spec.ServiceAccountName) > 0 {
0000000000000000000000000000000000000000;;			saInfo = serviceaccount.UserInfo(a.GetNamespace(), pod.Spec.ServiceAccountName, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		matchedPolicies, err := c.pspMatcher(c.lister, a.GetUserInfo(), saInfo, c.authz, a.GetNamespace())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return admission.NewForbidden(a, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we have no policies and want to succeed then return.  Otherwise we'll end up with no
0000000000000000000000000000000000000000;;		// providers and fail with "unable to validate against any pod security policy" below.
0000000000000000000000000000000000000000;;		if len(matchedPolicies) == 0 && !c.failOnNoPolicies {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		providers, errs := c.createProvidersFromPolicies(matchedPolicies, pod.Namespace)
0000000000000000000000000000000000000000;;		logProviders(pod, providers, errs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(providers) == 0 {
0000000000000000000000000000000000000000;;			return admission.NewForbidden(a, fmt.Errorf("no providers available to validate pod request"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// all containers in a single pod must validate under a single provider or we will reject the request
0000000000000000000000000000000000000000;;		validationErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for _, provider := range providers {
0000000000000000000000000000000000000000;;			if errs := assignSecurityContext(provider, pod, field.NewPath(fmt.Sprintf("provider %s: ", provider.GetPSPName()))); len(errs) > 0 {
0000000000000000000000000000000000000000;;				validationErrs = append(validationErrs, errs...)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// the entire pod validated, annotate and accept the pod
0000000000000000000000000000000000000000;;			glog.V(4).Infof("pod %s (generate: %s) validated against provider %s", pod.Name, pod.GenerateName, provider.GetPSPName())
0000000000000000000000000000000000000000;;			if pod.ObjectMeta.Annotations == nil {
0000000000000000000000000000000000000000;;				pod.ObjectMeta.Annotations = map[string]string{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod.ObjectMeta.Annotations[psputil.ValidatedPSPAnnotation] = provider.GetPSPName()
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we didn't validate against any provider, reject the pod and give the errors for each attempt
0000000000000000000000000000000000000000;;		glog.V(4).Infof("unable to validate pod %s (generate: %s) against any pod security policy: %v", pod.Name, pod.GenerateName, validationErrs)
0000000000000000000000000000000000000000;;		return admission.NewForbidden(a, fmt.Errorf("unable to validate against any pod security policy: %v", validationErrs))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// assignSecurityContext creates a security context for each container in the pod
0000000000000000000000000000000000000000;;	// and validates that the sc falls within the psp constraints.  All containers must validate against
0000000000000000000000000000000000000000;;	// the same psp or is not considered valid.
0000000000000000000000000000000000000000;;	func assignSecurityContext(provider psp.Provider, pod *api.Pod, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		generatedSCs := make([]*api.SecurityContext, len(pod.Spec.Containers))
0000000000000000000000000000000000000000;;		var generatedInitSCs []*api.SecurityContext
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		psc, pscAnnotations, err := provider.CreatePodSecurityContext(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			errs = append(errs, field.Invalid(field.NewPath("spec", "securityContext"), pod.Spec.SecurityContext, err.Error()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// save the original PSC and validate the generated PSC.  Leave the generated PSC
0000000000000000000000000000000000000000;;		// set for container generation/validation.  We will reset to original post container
0000000000000000000000000000000000000000;;		// validation.
0000000000000000000000000000000000000000;;		originalPSC := pod.Spec.SecurityContext
0000000000000000000000000000000000000000;;		pod.Spec.SecurityContext = psc
0000000000000000000000000000000000000000;;		originalAnnotations := maps.CopySS(pod.Annotations)
0000000000000000000000000000000000000000;;		pod.Annotations = pscAnnotations
0000000000000000000000000000000000000000;;		errs = append(errs, provider.ValidatePodSecurityContext(pod, field.NewPath("spec", "securityContext"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Note: this is not changing the original container, we will set container SCs later so long
0000000000000000000000000000000000000000;;		// as all containers validated under the same PSP.
0000000000000000000000000000000000000000;;		for i, containerCopy := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;			// We will determine the effective security context for the container and validate against that
0000000000000000000000000000000000000000;;			// since that is how the sc provider will eventually apply settings in the runtime.
0000000000000000000000000000000000000000;;			// This results in an SC that is based on the Pod's PSC with the set fields from the container
0000000000000000000000000000000000000000;;			// overriding pod level settings.
0000000000000000000000000000000000000000;;			containerCopy.SecurityContext = sc.InternalDetermineEffectiveSecurityContext(pod, &containerCopy)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			sc, scAnnotations, err := provider.CreateContainerSecurityContext(pod, &containerCopy)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, field.Invalid(field.NewPath("spec", "initContainers").Index(i).Child("securityContext"), "", err.Error()))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			generatedInitSCs = append(generatedInitSCs, sc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			containerCopy.SecurityContext = sc
0000000000000000000000000000000000000000;;			pod.Annotations = scAnnotations
0000000000000000000000000000000000000000;;			errs = append(errs, provider.ValidateContainerSecurityContext(pod, &containerCopy, field.NewPath("spec", "initContainers").Index(i).Child("securityContext"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Note: this is not changing the original container, we will set container SCs later so long
0000000000000000000000000000000000000000;;		// as all containers validated under the same PSP.
0000000000000000000000000000000000000000;;		for i, containerCopy := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			// We will determine the effective security context for the container and validate against that
0000000000000000000000000000000000000000;;			// since that is how the sc provider will eventually apply settings in the runtime.
0000000000000000000000000000000000000000;;			// This results in an SC that is based on the Pod's PSC with the set fields from the container
0000000000000000000000000000000000000000;;			// overriding pod level settings.
0000000000000000000000000000000000000000;;			containerCopy.SecurityContext = sc.InternalDetermineEffectiveSecurityContext(pod, &containerCopy)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			sc, scAnnotations, err := provider.CreateContainerSecurityContext(pod, &containerCopy)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, field.Invalid(field.NewPath("spec", "containers").Index(i).Child("securityContext"), "", err.Error()))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			generatedSCs[i] = sc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			containerCopy.SecurityContext = sc
0000000000000000000000000000000000000000;;			pod.Annotations = scAnnotations
0000000000000000000000000000000000000000;;			errs = append(errs, provider.ValidateContainerSecurityContext(pod, &containerCopy, field.NewPath("spec", "containers").Index(i).Child("securityContext"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(errs) > 0 {
0000000000000000000000000000000000000000;;			// ensure psc is not mutated if there are errors
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext = originalPSC
0000000000000000000000000000000000000000;;			pod.Annotations = originalAnnotations
0000000000000000000000000000000000000000;;			return errs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we've reached this code then we've generated and validated an SC for every container in the
0000000000000000000000000000000000000000;;		// pod so let's apply what we generated.  Note: the psc is already applied.
0000000000000000000000000000000000000000;;		for i, sc := range generatedInitSCs {
0000000000000000000000000000000000000000;;			pod.Spec.InitContainers[i].SecurityContext = sc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, sc := range generatedSCs {
0000000000000000000000000000000000000000;;			pod.Spec.Containers[i].SecurityContext = sc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createProvidersFromPolicies creates providers from the constraints supplied.
0000000000000000000000000000000000000000;;	func (c *podSecurityPolicyPlugin) createProvidersFromPolicies(psps []*extensions.PodSecurityPolicy, namespace string) ([]psp.Provider, []error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			// collected providers
0000000000000000000000000000000000000000;;			providers []psp.Provider
0000000000000000000000000000000000000000;;			// collected errors to return
0000000000000000000000000000000000000000;;			errs []error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, constraint := range psps {
0000000000000000000000000000000000000000;;			provider, err := psp.NewSimpleProvider(constraint, namespace, c.strategyFactory)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, fmt.Errorf("error creating provider for PSP %s: %v", constraint.Name, err))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			providers = append(providers, provider)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return providers, errs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getMatchingPolicies returns policies from the lister.  For now this returns everything
0000000000000000000000000000000000000000;;	// in the future it can filter based on UserInfo and permissions.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: this will likely need optimization since the initial implementation will
0000000000000000000000000000000000000000;;	// always query for authorization.  Needs scale testing and possibly checking against
0000000000000000000000000000000000000000;;	// a cache.
0000000000000000000000000000000000000000;;	func getMatchingPolicies(lister extensionslisters.PodSecurityPolicyLister, user user.Info, sa user.Info, authz authorizer.Authorizer, namespace string) ([]*extensions.PodSecurityPolicy, error) {
0000000000000000000000000000000000000000;;		matchedPolicies := make([]*extensions.PodSecurityPolicy, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		list, err := lister.List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, constraint := range list {
0000000000000000000000000000000000000000;;			if authorizedForPolicy(user, namespace, constraint, authz) || authorizedForPolicy(sa, namespace, constraint, authz) {
0000000000000000000000000000000000000000;;				matchedPolicies = append(matchedPolicies, constraint)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return matchedPolicies, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// authorizedForPolicy returns true if info is authorized to perform the "use" verb on the policy resource.
0000000000000000000000000000000000000000;;	func authorizedForPolicy(info user.Info, namespace string, policy *extensions.PodSecurityPolicy, authz authorizer.Authorizer) bool {
0000000000000000000000000000000000000000;;		if info == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attr := buildAttributes(info, namespace, policy)
0000000000000000000000000000000000000000;;		allowed, reason, err := authz.Authorize(attr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("cannot authorize for policy: %v,%v", reason, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allowed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildAttributes builds an attributes record for a SAR based on the user info and policy.
0000000000000000000000000000000000000000;;	func buildAttributes(info user.Info, namespace string, policy *extensions.PodSecurityPolicy) authorizer.Attributes {
0000000000000000000000000000000000000000;;		// check against the namespace that the pod is being created in to allow per-namespace PSP grants.
0000000000000000000000000000000000000000;;		attr := authorizer.AttributesRecord{
0000000000000000000000000000000000000000;;			User:            info,
0000000000000000000000000000000000000000;;			Verb:            "use",
0000000000000000000000000000000000000000;;			Namespace:       namespace,
0000000000000000000000000000000000000000;;			Name:            policy.Name,
0000000000000000000000000000000000000000;;			APIGroup:        extensions.GroupName,
0000000000000000000000000000000000000000;;			Resource:        "podsecuritypolicies",
0000000000000000000000000000000000000000;;			ResourceRequest: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return attr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// logProviders logs what providers were found for the pod as well as any errors that were encountered
0000000000000000000000000000000000000000;;	// while creating providers.
0000000000000000000000000000000000000000;;	func logProviders(pod *api.Pod, providers []psp.Provider, providerCreationErrs []error) {
0000000000000000000000000000000000000000;;		for _, err := range providerCreationErrs {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("provider creation error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(providers) == 0 {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("unable to validate pod %s (generate: %s) against any provider.", pod.Name, pod.GenerateName)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		names := make([]string, len(providers))
0000000000000000000000000000000000000000;;		for i, p := range providers {
0000000000000000000000000000000000000000;;			names[i] = p.GetPSPName()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("validating pod %s (generate: %s) against providers: %s", pod.Name, pod.GenerateName, strings.Join(names, ","))
0000000000000000000000000000000000000000;;	}
