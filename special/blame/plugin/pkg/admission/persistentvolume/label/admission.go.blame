0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
9fa32752692c2c53fd4b4c039ab345a60e06bac6;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package label
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/aws"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/gce"
0000000000000000000000000000000000000000;;		kubeapiserveradmission "k8s.io/kubernetes/pkg/kubeapiserver/admission"
0000000000000000000000000000000000000000;;		kubeletapis "k8s.io/kubernetes/pkg/kubelet/apis"
0000000000000000000000000000000000000000;;		vol "k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register registers a plugin
0000000000000000000000000000000000000000;;	func Register(plugins *admission.Plugins) {
0000000000000000000000000000000000000000;;		plugins.Register("PersistentVolumeLabel", func(config io.Reader) (admission.Interface, error) {
0000000000000000000000000000000000000000;;			persistentVolumeLabelAdmission := NewPersistentVolumeLabel()
0000000000000000000000000000000000000000;;			return persistentVolumeLabelAdmission, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = admission.Interface(&persistentVolumeLabel{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type persistentVolumeLabel struct {
0000000000000000000000000000000000000000;;		*admission.Handler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mutex            sync.Mutex
0000000000000000000000000000000000000000;;		ebsVolumes       aws.Volumes
0000000000000000000000000000000000000000;;		cloudConfig      []byte
0000000000000000000000000000000000000000;;		gceCloudProvider *gce.GCECloud
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ kubeapiserveradmission.WantsCloudConfig = &persistentVolumeLabel{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPersistentVolumeLabel returns an admission.Interface implementation which adds labels to PersistentVolume CREATE requests,
0000000000000000000000000000000000000000;;	// based on the labels provided by the underlying cloud provider.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// As a side effect, the cloud provider may block invalid or non-existent volumes.
0000000000000000000000000000000000000000;;	func NewPersistentVolumeLabel() *persistentVolumeLabel {
0000000000000000000000000000000000000000;;		return &persistentVolumeLabel{
0000000000000000000000000000000000000000;;			Handler: admission.NewHandler(admission.Create),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *persistentVolumeLabel) SetCloudConfig(cloudConfig []byte) {
0000000000000000000000000000000000000000;;		l.cloudConfig = cloudConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *persistentVolumeLabel) Admit(a admission.Attributes) (err error) {
0000000000000000000000000000000000000000;;		if a.GetResource().GroupResource() != api.Resource("persistentvolumes") {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj := a.GetObject()
0000000000000000000000000000000000000000;;		if obj == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volume, ok := obj.(*api.PersistentVolume)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var volumeLabels map[string]string
0000000000000000000000000000000000000000;;		if volume.Spec.AWSElasticBlockStore != nil {
0000000000000000000000000000000000000000;;			labels, err := l.findAWSEBSLabels(volume)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return admission.NewForbidden(a, fmt.Errorf("error querying AWS EBS volume %s: %v", volume.Spec.AWSElasticBlockStore.VolumeID, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			volumeLabels = labels
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if volume.Spec.GCEPersistentDisk != nil {
0000000000000000000000000000000000000000;;			labels, err := l.findGCEPDLabels(volume)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return admission.NewForbidden(a, fmt.Errorf("error querying GCE PD volume %s: %v", volume.Spec.GCEPersistentDisk.PDName, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			volumeLabels = labels
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(volumeLabels) != 0 {
0000000000000000000000000000000000000000;;			if volume.Labels == nil {
0000000000000000000000000000000000000000;;				volume.Labels = make(map[string]string)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k, v := range volumeLabels {
0000000000000000000000000000000000000000;;				// We (silently) replace labels if they are provided.
0000000000000000000000000000000000000000;;				// This should be OK because they are in the kubernetes.io namespace
0000000000000000000000000000000000000000;;				// i.e. we own them
0000000000000000000000000000000000000000;;				volume.Labels[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *persistentVolumeLabel) findAWSEBSLabels(volume *api.PersistentVolume) (map[string]string, error) {
0000000000000000000000000000000000000000;;		// Ignore any volumes that are being provisioned
0000000000000000000000000000000000000000;;		if volume.Spec.AWSElasticBlockStore.VolumeID == vol.ProvisionedVolumeName {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ebsVolumes, err := l.getEBSVolumes()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ebsVolumes == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to build AWS cloud provider for EBS")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: GetVolumeLabels is actually a method on the Volumes interface
0000000000000000000000000000000000000000;;		// If that gets standardized we can refactor to reduce code duplication
0000000000000000000000000000000000000000;;		spec := aws.KubernetesVolumeID(volume.Spec.AWSElasticBlockStore.VolumeID)
0000000000000000000000000000000000000000;;		labels, err := ebsVolumes.GetVolumeLabels(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return labels, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getEBSVolumes returns the AWS Volumes interface for ebs
0000000000000000000000000000000000000000;;	func (l *persistentVolumeLabel) getEBSVolumes() (aws.Volumes, error) {
0000000000000000000000000000000000000000;;		l.mutex.Lock()
0000000000000000000000000000000000000000;;		defer l.mutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if l.ebsVolumes == nil {
0000000000000000000000000000000000000000;;			var cloudConfigReader io.Reader
0000000000000000000000000000000000000000;;			if len(l.cloudConfig) > 0 {
0000000000000000000000000000000000000000;;				cloudConfigReader = bytes.NewReader(l.cloudConfig)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cloudProvider, err := cloudprovider.GetCloudProvider("aws", cloudConfigReader)
0000000000000000000000000000000000000000;;			if err != nil || cloudProvider == nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			awsCloudProvider, ok := cloudProvider.(*aws.Cloud)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// GetCloudProvider has gone very wrong
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("error retrieving AWS cloud provider")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l.ebsVolumes = awsCloudProvider
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l.ebsVolumes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *persistentVolumeLabel) findGCEPDLabels(volume *api.PersistentVolume) (map[string]string, error) {
0000000000000000000000000000000000000000;;		// Ignore any volumes that are being provisioned
0000000000000000000000000000000000000000;;		if volume.Spec.GCEPersistentDisk.PDName == vol.ProvisionedVolumeName {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		provider, err := l.getGCECloudProvider()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if provider == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to build GCE cloud provider for PD")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the zone is already labeled, honor the hint
0000000000000000000000000000000000000000;;		zone := volume.Labels[kubeletapis.LabelZoneFailureDomain]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labels, err := provider.GetAutoLabelsForPD(volume.Spec.GCEPersistentDisk.PDName, zone)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return labels, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getGCECloudProvider returns the GCE cloud provider, for use for querying volume labels
0000000000000000000000000000000000000000;;	func (l *persistentVolumeLabel) getGCECloudProvider() (*gce.GCECloud, error) {
0000000000000000000000000000000000000000;;		l.mutex.Lock()
0000000000000000000000000000000000000000;;		defer l.mutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if l.gceCloudProvider == nil {
0000000000000000000000000000000000000000;;			var cloudConfigReader io.Reader
0000000000000000000000000000000000000000;;			if len(l.cloudConfig) > 0 {
0000000000000000000000000000000000000000;;				cloudConfigReader = bytes.NewReader(l.cloudConfig)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cloudProvider, err := cloudprovider.GetCloudProvider("gce", cloudConfigReader)
0000000000000000000000000000000000000000;;			if err != nil || cloudProvider == nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gceCloudProvider, ok := cloudProvider.(*gce.GCECloud)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// GetCloudProvider has gone very wrong
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("error retrieving GCE cloud provider")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l.gceCloudProvider = gceCloudProvider
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l.gceCloudProvider, nil
0000000000000000000000000000000000000000;;	}
