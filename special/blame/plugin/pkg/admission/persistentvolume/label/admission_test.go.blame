0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
9fa32752692c2c53fd4b4c039ab345a60e06bac6;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package label
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/aws"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mockVolumes struct {
0000000000000000000000000000000000000000;;		volumeLabels      map[string]string
0000000000000000000000000000000000000000;;		volumeLabelsError error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ aws.Volumes = &mockVolumes{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *mockVolumes) AttachDisk(diskName aws.KubernetesVolumeID, nodeName types.NodeName, readOnly bool) (string, error) {
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *mockVolumes) DetachDisk(diskName aws.KubernetesVolumeID, nodeName types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *mockVolumes) CreateDisk(volumeOptions *aws.VolumeOptions) (volumeName aws.KubernetesVolumeID, err error) {
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *mockVolumes) DeleteDisk(volumeName aws.KubernetesVolumeID) (bool, error) {
0000000000000000000000000000000000000000;;		return false, fmt.Errorf("not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *mockVolumes) GetVolumeLabels(volumeName aws.KubernetesVolumeID) (map[string]string, error) {
0000000000000000000000000000000000000000;;		return v.volumeLabels, v.volumeLabelsError
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *mockVolumes) GetDiskPath(volumeName aws.KubernetesVolumeID) (string, error) {
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *mockVolumes) DiskIsAttached(volumeName aws.KubernetesVolumeID, nodeName types.NodeName) (bool, error) {
0000000000000000000000000000000000000000;;		return false, fmt.Errorf("not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *mockVolumes) DisksAreAttached(nodeDisks map[types.NodeName][]aws.KubernetesVolumeID) (map[types.NodeName]map[aws.KubernetesVolumeID]bool, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mockVolumeFailure(err error) *mockVolumes {
0000000000000000000000000000000000000000;;		return &mockVolumes{volumeLabelsError: err}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mockVolumeLabels(labels map[string]string) *mockVolumes {
0000000000000000000000000000000000000000;;		return &mockVolumes{volumeLabels: labels}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAdmission
0000000000000000000000000000000000000000;;	func TestAdmission(t *testing.T) {
0000000000000000000000000000000000000000;;		pvHandler := NewPersistentVolumeLabel()
0000000000000000000000000000000000000000;;		handler := admission.NewChainHandler(pvHandler)
0000000000000000000000000000000000000000;;		ignoredPV := api.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "noncloud", Namespace: "myns"},
0000000000000000000000000000000000000000;;			Spec: api.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeSource: api.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					HostPath: &api.HostPathVolumeSource{
0000000000000000000000000000000000000000;;						Path: "/",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		awsPV := api.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "noncloud", Namespace: "myns"},
0000000000000000000000000000000000000000;;			Spec: api.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeSource: api.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					AWSElasticBlockStore: &api.AWSElasticBlockStoreVolumeSource{
0000000000000000000000000000000000000000;;						VolumeID: "123",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Non-cloud PVs are ignored
0000000000000000000000000000000000000000;;		err := handler.Admit(admission.NewAttributesRecord(&ignoredPV, nil, api.Kind("PersistentVolume").WithVersion("version"), ignoredPV.Namespace, ignoredPV.Name, api.Resource("persistentvolumes").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error returned from admission handler (on ignored pv): %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We only add labels on creation
0000000000000000000000000000000000000000;;		err = handler.Admit(admission.NewAttributesRecord(&awsPV, nil, api.Kind("PersistentVolume").WithVersion("version"), awsPV.Namespace, awsPV.Name, api.Resource("persistentvolumes").WithVersion("version"), "", admission.Delete, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error returned from admission handler (when deleting aws pv):  %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Errors from the cloudprovider block creation of the volume
0000000000000000000000000000000000000000;;		pvHandler.ebsVolumes = mockVolumeFailure(fmt.Errorf("invalid volume"))
0000000000000000000000000000000000000000;;		err = handler.Admit(admission.NewAttributesRecord(&awsPV, nil, api.Kind("PersistentVolume").WithVersion("version"), awsPV.Namespace, awsPV.Name, api.Resource("persistentvolumes").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected error when aws pv info fails")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Don't add labels if the cloudprovider doesn't return any
0000000000000000000000000000000000000000;;		labels := make(map[string]string)
0000000000000000000000000000000000000000;;		pvHandler.ebsVolumes = mockVolumeLabels(labels)
0000000000000000000000000000000000000000;;		err = handler.Admit(admission.NewAttributesRecord(&awsPV, nil, api.Kind("PersistentVolume").WithVersion("version"), awsPV.Namespace, awsPV.Name, api.Resource("persistentvolumes").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected no error when creating aws pv")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(awsPV.ObjectMeta.Labels) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected number of labels")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Don't panic if the cloudprovider returns nil, nil
0000000000000000000000000000000000000000;;		pvHandler.ebsVolumes = mockVolumeFailure(nil)
0000000000000000000000000000000000000000;;		err = handler.Admit(admission.NewAttributesRecord(&awsPV, nil, api.Kind("PersistentVolume").WithVersion("version"), awsPV.Namespace, awsPV.Name, api.Resource("persistentvolumes").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected no error when cloud provider returns empty labels")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Labels from the cloudprovider should be applied to the volume
0000000000000000000000000000000000000000;;		labels = make(map[string]string)
0000000000000000000000000000000000000000;;		labels["a"] = "1"
0000000000000000000000000000000000000000;;		labels["b"] = "2"
0000000000000000000000000000000000000000;;		pvHandler.ebsVolumes = mockVolumeLabels(labels)
0000000000000000000000000000000000000000;;		err = handler.Admit(admission.NewAttributesRecord(&awsPV, nil, api.Kind("PersistentVolume").WithVersion("version"), awsPV.Namespace, awsPV.Name, api.Resource("persistentvolumes").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected no error when creating aws pv")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if awsPV.Labels["a"] != "1" || awsPV.Labels["b"] != "2" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected label a to be added when creating aws pv")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// User-provided labels should be honored, but cloudprovider labels replace them when they overlap
0000000000000000000000000000000000000000;;		awsPV.ObjectMeta.Labels = make(map[string]string)
0000000000000000000000000000000000000000;;		awsPV.ObjectMeta.Labels["a"] = "not1"
0000000000000000000000000000000000000000;;		awsPV.ObjectMeta.Labels["c"] = "3"
0000000000000000000000000000000000000000;;		err = handler.Admit(admission.NewAttributesRecord(&awsPV, nil, api.Kind("PersistentVolume").WithVersion("version"), awsPV.Namespace, awsPV.Name, api.Resource("persistentvolumes").WithVersion("version"), "", admission.Create, nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected no error when creating aws pv")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if awsPV.Labels["a"] != "1" || awsPV.Labels["b"] != "2" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected cloudprovider labels to replace user labels when creating aws pv")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if awsPV.Labels["c"] != "3" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected (non-conflicting) user provided labels to be honored when creating aws pv")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
