0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
ac8132e309907df8c1f9e805f49f62b2f42886c3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package podnodeselector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/yaml"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/internalversion"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/internalversion"
0000000000000000000000000000000000000000;;		kubeapiserveradmission "k8s.io/kubernetes/pkg/kubeapiserver/admission"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The annotation key scheduler.alpha.kubernetes.io/node-selector is for assigning
0000000000000000000000000000000000000000;;	// node selectors labels to namespaces
0000000000000000000000000000000000000000;;	var NamespaceNodeSelectors = []string{"scheduler.alpha.kubernetes.io/node-selector"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register registers a plugin
0000000000000000000000000000000000000000;;	func Register(plugins *admission.Plugins) {
0000000000000000000000000000000000000000;;		plugins.Register("PodNodeSelector", func(config io.Reader) (admission.Interface, error) {
0000000000000000000000000000000000000000;;			// TODO move this to a versioned configuration file format.
0000000000000000000000000000000000000000;;			pluginConfig := readConfig(config)
0000000000000000000000000000000000000000;;			plugin := NewPodNodeSelector(pluginConfig.PodNodeSelectorPluginConfig)
0000000000000000000000000000000000000000;;			return plugin, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// podNodeSelector is an implementation of admission.Interface.
0000000000000000000000000000000000000000;;	type podNodeSelector struct {
0000000000000000000000000000000000000000;;		*admission.Handler
0000000000000000000000000000000000000000;;		client          internalclientset.Interface
0000000000000000000000000000000000000000;;		namespaceLister corelisters.NamespaceLister
0000000000000000000000000000000000000000;;		// global default node selector and namespace whitelists in a cluster.
0000000000000000000000000000000000000000;;		clusterNodeSelectors map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = kubeapiserveradmission.WantsInternalKubeClientSet(&podNodeSelector{})
0000000000000000000000000000000000000000;;	var _ = kubeapiserveradmission.WantsInternalKubeInformerFactory(&podNodeSelector{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pluginConfig struct {
0000000000000000000000000000000000000000;;		PodNodeSelectorPluginConfig map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readConfig reads default value of clusterDefaultNodeSelector
0000000000000000000000000000000000000000;;	// from the file provided with --admission-control-config-file
0000000000000000000000000000000000000000;;	// If the file is not supplied, it defaults to ""
0000000000000000000000000000000000000000;;	// The format in a file:
0000000000000000000000000000000000000000;;	// podNodeSelectorPluginConfig:
0000000000000000000000000000000000000000;;	//  clusterDefaultNodeSelector: <node-selectors-labels>
0000000000000000000000000000000000000000;;	//  namespace1: <node-selectors-labels>
0000000000000000000000000000000000000000;;	//  namespace2: <node-selectors-labels>
0000000000000000000000000000000000000000;;	func readConfig(config io.Reader) *pluginConfig {
0000000000000000000000000000000000000000;;		defaultConfig := &pluginConfig{}
0000000000000000000000000000000000000000;;		if config == nil || reflect.ValueOf(config).IsNil() {
0000000000000000000000000000000000000000;;			return defaultConfig
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d := yaml.NewYAMLOrJSONDecoder(config, 4096)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if err := d.Decode(defaultConfig); err != nil {
0000000000000000000000000000000000000000;;				if err != io.EOF {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return defaultConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Admit enforces that pod and its namespace node label selectors matches at least a node in the cluster.
0000000000000000000000000000000000000000;;	func (p *podNodeSelector) Admit(a admission.Attributes) error {
0000000000000000000000000000000000000000;;		resource := a.GetResource().GroupResource()
0000000000000000000000000000000000000000;;		if resource != api.Resource("pods") {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.GetSubresource() != "" {
0000000000000000000000000000000000000000;;			// only run the checks below on pods proper and not subresources
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj := a.GetObject()
0000000000000000000000000000000000000000;;		pod, ok := obj.(*api.Pod)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.Errorf("expected pod but got %s", a.GetKind().Kind)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !p.WaitForReady() {
0000000000000000000000000000000000000000;;			return admission.NewForbidden(a, fmt.Errorf("not yet ready to handle request"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := pod.Name
0000000000000000000000000000000000000000;;		nsName := a.GetNamespace()
0000000000000000000000000000000000000000;;		var namespace *api.Namespace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespace, err := p.namespaceLister.Get(nsName)
0000000000000000000000000000000000000000;;		if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			namespace, err = p.defaultGetNamespace(nsName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return errors.NewInternalError(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			return errors.NewInternalError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespaceNodeSelector, err := p.getNodeSelectorMap(namespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if labels.Conflicts(namespaceNodeSelector, labels.Set(pod.Spec.NodeSelector)) {
0000000000000000000000000000000000000000;;			return errors.NewForbidden(resource, name, fmt.Errorf("pod node label selector conflicts with its namespace node label selector"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		whitelist, err := labels.ConvertSelectorToLabelsMap(p.clusterNodeSelectors[namespace.Name])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Merge pod node selector = namespace node selector + current pod node selector
0000000000000000000000000000000000000000;;		podNodeSelectorLabels := labels.Merge(namespaceNodeSelector, pod.Spec.NodeSelector)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// whitelist verification
0000000000000000000000000000000000000000;;		if !labels.AreLabelsInWhiteList(podNodeSelectorLabels, whitelist) {
0000000000000000000000000000000000000000;;			return errors.NewForbidden(resource, name, fmt.Errorf("pod node label selector labels conflict with its namespace whitelist"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Updated pod node selector = namespace node selector + current pod node selector
0000000000000000000000000000000000000000;;		pod.Spec.NodeSelector = map[string]string(podNodeSelectorLabels)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewPodNodeSelector(clusterNodeSelectors map[string]string) *podNodeSelector {
0000000000000000000000000000000000000000;;		return &podNodeSelector{
0000000000000000000000000000000000000000;;			Handler:              admission.NewHandler(admission.Create),
0000000000000000000000000000000000000000;;			clusterNodeSelectors: clusterNodeSelectors,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *podNodeSelector) SetInternalKubeClientSet(client internalclientset.Interface) {
0000000000000000000000000000000000000000;;		a.client = client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *podNodeSelector) SetInternalKubeInformerFactory(f informers.SharedInformerFactory) {
0000000000000000000000000000000000000000;;		namespaceInformer := f.Core().InternalVersion().Namespaces()
0000000000000000000000000000000000000000;;		p.namespaceLister = namespaceInformer.Lister()
0000000000000000000000000000000000000000;;		p.SetReadyFunc(namespaceInformer.Informer().HasSynced)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *podNodeSelector) Validate() error {
0000000000000000000000000000000000000000;;		if p.namespaceLister == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing namespaceLister")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.client == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing client")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *podNodeSelector) defaultGetNamespace(name string) (*api.Namespace, error) {
0000000000000000000000000000000000000000;;		namespace, err := p.client.Core().Namespaces().Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("namespace %s does not exist", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return namespace, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *podNodeSelector) getNodeSelectorMap(namespace *api.Namespace) (labels.Set, error) {
0000000000000000000000000000000000000000;;		selector := labels.Set{}
0000000000000000000000000000000000000000;;		labelsMap := labels.Set{}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		found := false
0000000000000000000000000000000000000000;;		if len(namespace.ObjectMeta.Annotations) > 0 {
0000000000000000000000000000000000000000;;			for _, annotation := range NamespaceNodeSelectors {
0000000000000000000000000000000000000000;;				if ns, ok := namespace.ObjectMeta.Annotations[annotation]; ok {
0000000000000000000000000000000000000000;;					labelsMap, err = labels.ConvertSelectorToLabelsMap(ns)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return labels.Set{}, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if labels.Conflicts(selector, labelsMap) {
0000000000000000000000000000000000000000;;						nsName := namespace.ObjectMeta.Name
0000000000000000000000000000000000000000;;						return labels.Set{}, fmt.Errorf("%s annotations' node label selectors conflict", nsName)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					selector = labels.Merge(selector, labelsMap)
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			selector, err = labels.ConvertSelectorToLabelsMap(p.clusterNodeSelectors["clusterDefaultNodeSelector"])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return labels.Set{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return selector, nil
0000000000000000000000000000000000000000;;	}
