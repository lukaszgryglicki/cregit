0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
1dae5b565eb9eae3ff70a54028c77c2f735d24b8;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package bootstrap provides a token authenticator for TLS bootstrap secrets.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package bootstrap
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/subtle"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		bootstrapapi "k8s.io/kubernetes/pkg/bootstrap/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/listers/core/internalversion"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: A few methods in this package is copied from other sources. Either
0000000000000000000000000000000000000000;;	// because the existing functionality isn't exported or because it is in a
0000000000000000000000000000000000000000;;	// package that shouldn't be directly imported by this packages.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTokenAuthenticator initializes a bootstrap token authenticator.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Lister is expected to be for the "kube-system" namespace.
0000000000000000000000000000000000000000;;	func NewTokenAuthenticator(lister internalversion.SecretNamespaceLister) *TokenAuthenticator {
0000000000000000000000000000000000000000;;		return &TokenAuthenticator{lister}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TokenAuthenticator authenticates bootstrap tokens from secrets in the API server.
0000000000000000000000000000000000000000;;	type TokenAuthenticator struct {
0000000000000000000000000000000000000000;;		lister internalversion.SecretNamespaceLister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tokenErrorf prints a error message for a secret that has matched a bearer
0000000000000000000000000000000000000000;;	// token but fails to meet some other criteria.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    tokenErrorf(secret, "has invalid value for key %s", key)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func tokenErrorf(s *api.Secret, format string, i ...interface{}) {
0000000000000000000000000000000000000000;;		format = fmt.Sprintf("Bootstrap secret %s/%s matching bearer token ", s.Namespace, s.Name) + format
0000000000000000000000000000000000000000;;		glog.V(3).Infof(format, i...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AuthenticateToken tries to match the provided token to a bootstrap token secret
0000000000000000000000000000000000000000;;	// in a given namespace. If found, it authenticates the token in the
0000000000000000000000000000000000000000;;	// "system:bootstrappers" group and with the "system:bootstrap:(token-id)" username.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// All secrets must be of type "bootstrap.kubernetes.io/token". An example secret:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     apiVersion: v1
0000000000000000000000000000000000000000;;	//     kind: Secret
0000000000000000000000000000000000000000;;	//     metadata:
0000000000000000000000000000000000000000;;	//       # Name MUST be of form "bootstrap-token-( token id )".
0000000000000000000000000000000000000000;;	//       name: bootstrap-token-( token id )
0000000000000000000000000000000000000000;;	//       namespace: kube-system
0000000000000000000000000000000000000000;;	//     # Only secrets of this type will be evaluated.
0000000000000000000000000000000000000000;;	//     type: bootstrap.kubernetes.io/token
0000000000000000000000000000000000000000;;	//     data:
0000000000000000000000000000000000000000;;	//       token-secret: ( private part of token )
0000000000000000000000000000000000000000;;	//       token-id: ( token id )
0000000000000000000000000000000000000000;;	//       # Required key usage.
0000000000000000000000000000000000000000;;	//       usage-bootstrap-authentication: true
0000000000000000000000000000000000000000;;	//       # May also contain an expiry.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Tokens are expected to be of the form:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     ( token-id ).( token-secret )
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (t *TokenAuthenticator) AuthenticateToken(token string) (user.Info, bool, error) {
0000000000000000000000000000000000000000;;		tokenID, tokenSecret, err := parseToken(token)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Token isn't of the correct form, ignore it.
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secretName := bootstrapapi.BootstrapTokenSecretPrefix + tokenID
0000000000000000000000000000000000000000;;		secret, err := t.lister.Get(secretName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				glog.V(3).Infof("No secret of name %s to match bootstrap bearer token", secretName)
0000000000000000000000000000000000000000;;				return nil, false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if string(secret.Type) != string(bootstrapapi.SecretTypeBootstrapToken) || secret.Data == nil {
0000000000000000000000000000000000000000;;			tokenErrorf(secret, "has invalid type, expected %s.", bootstrapapi.SecretTypeBootstrapToken)
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ts := getSecretString(secret, bootstrapapi.BootstrapTokenSecretKey)
0000000000000000000000000000000000000000;;		if subtle.ConstantTimeCompare([]byte(ts), []byte(tokenSecret)) != 1 {
0000000000000000000000000000000000000000;;			tokenErrorf(secret, "has invalid value for key %s, expected %s.", bootstrapapi.BootstrapTokenSecretKey, tokenSecret)
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		id := getSecretString(secret, bootstrapapi.BootstrapTokenIDKey)
0000000000000000000000000000000000000000;;		if id != tokenID {
0000000000000000000000000000000000000000;;			tokenErrorf(secret, "has invalid value for key %s, expected %s.", bootstrapapi.BootstrapTokenIDKey, tokenID)
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isSecretExpired(secret) {
0000000000000000000000000000000000000000;;			// logging done in isSecretExpired method.
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if getSecretString(secret, bootstrapapi.BootstrapTokenUsageAuthentication) != "true" {
0000000000000000000000000000000000000000;;			tokenErrorf(secret, "not marked %s=true.", bootstrapapi.BootstrapTokenUsageAuthentication)
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &user.DefaultInfo{
0000000000000000000000000000000000000000;;			Name:   bootstrapapi.BootstrapUserPrefix + string(id),
0000000000000000000000000000000000000000;;			Groups: []string{bootstrapapi.BootstrapGroup},
0000000000000000000000000000000000000000;;		}, true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copied from k8s.io/kubernetes/pkg/bootstrap/api
0000000000000000000000000000000000000000;;	func getSecretString(secret *api.Secret, key string) string {
0000000000000000000000000000000000000000;;		if secret.Data == nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if val, ok := secret.Data[key]; ok {
0000000000000000000000000000000000000000;;			return string(val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copied from k8s.io/kubernetes/pkg/bootstrap/api
0000000000000000000000000000000000000000;;	func isSecretExpired(secret *api.Secret) bool {
0000000000000000000000000000000000000000;;		expiration := getSecretString(secret, bootstrapapi.BootstrapTokenExpirationKey)
0000000000000000000000000000000000000000;;		if len(expiration) > 0 {
0000000000000000000000000000000000000000;;			expTime, err2 := time.Parse(time.RFC3339, expiration)
0000000000000000000000000000000000000000;;			if err2 != nil {
0000000000000000000000000000000000000000;;				tokenErrorf(secret, "has unparsable expiration time (%s). Treating as expired.", expiration)
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if time.Now().After(expTime) {
0000000000000000000000000000000000000000;;				tokenErrorf(secret, "has expired.", expiration)
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copied from kubernetes/cmd/kubeadm/app/util/token
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		tokenRegexpString = "^([a-z0-9]{6})\\.([a-z0-9]{16})$"
0000000000000000000000000000000000000000;;		tokenRegexp       = regexp.MustCompile(tokenRegexpString)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseToken tries and parse a valid token from a string.
0000000000000000000000000000000000000000;;	// A token ID and token secret are returned in case of success, an error otherwise.
0000000000000000000000000000000000000000;;	func parseToken(s string) (string, string, error) {
0000000000000000000000000000000000000000;;		split := tokenRegexp.FindStringSubmatch(s)
0000000000000000000000000000000000000000;;		if len(split) != 3 {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("token [%q] was not of form [%q]", s, tokenRegexpString)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return split[1], split[2], nil
0000000000000000000000000000000000000000;;	}
