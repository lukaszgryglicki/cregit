0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
9c97f06e1356e7ea7b8c52255a3c0aebc1c1200d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"runtime/pprof"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/auth/nodeidentifier"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/auth/authorizer/rbac/bootstrappolicy"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAuthorizer(t *testing.T) {
0000000000000000000000000000000000000000;;		g := NewGraph()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts := sampleDataOpts{
0000000000000000000000000000000000000000;;			nodes:                  2,
0000000000000000000000000000000000000000;;			namespaces:             2,
0000000000000000000000000000000000000000;;			podsPerNode:            2,
0000000000000000000000000000000000000000;;			sharedConfigMapsPerPod: 0,
0000000000000000000000000000000000000000;;			uniqueConfigMapsPerPod: 1,
0000000000000000000000000000000000000000;;			sharedSecretsPerPod:    1,
0000000000000000000000000000000000000000;;			uniqueSecretsPerPod:    1,
0000000000000000000000000000000000000000;;			sharedPVCsPerPod:       0,
0000000000000000000000000000000000000000;;			uniquePVCsPerPod:       1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pods, pvs := generate(opts)
0000000000000000000000000000000000000000;;		populate(g, pods, pvs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		identifier := nodeidentifier.NewDefaultNodeIdentifier()
0000000000000000000000000000000000000000;;		authz := NewAuthorizer(g, identifier, bootstrappolicy.NodeRules())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node0 := &user.DefaultInfo{Name: "system:node:node0", Groups: []string{"system:nodes"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name   string
0000000000000000000000000000000000000000;;			attrs  authorizer.AttributesRecord
0000000000000000000000000000000000000000;;			expect bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "allowed configmap",
0000000000000000000000000000000000000000;;				attrs:  authorizer.AttributesRecord{User: node0, ResourceRequest: true, Verb: "get", Resource: "configmaps", Name: "configmap0-pod0-node0", Namespace: "ns0"},
0000000000000000000000000000000000000000;;				expect: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "allowed secret via pod",
0000000000000000000000000000000000000000;;				attrs:  authorizer.AttributesRecord{User: node0, ResourceRequest: true, Verb: "get", Resource: "secrets", Name: "secret0-pod0-node0", Namespace: "ns0"},
0000000000000000000000000000000000000000;;				expect: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "allowed shared secret via pod",
0000000000000000000000000000000000000000;;				attrs:  authorizer.AttributesRecord{User: node0, ResourceRequest: true, Verb: "get", Resource: "secrets", Name: "secret0-shared", Namespace: "ns0"},
0000000000000000000000000000000000000000;;				expect: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "allowed shared secret via pvc",
0000000000000000000000000000000000000000;;				attrs:  authorizer.AttributesRecord{User: node0, ResourceRequest: true, Verb: "get", Resource: "secrets", Name: "secret-pv0-pod0-node0-ns0", Namespace: "ns0"},
0000000000000000000000000000000000000000;;				expect: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "allowed pvc",
0000000000000000000000000000000000000000;;				attrs:  authorizer.AttributesRecord{User: node0, ResourceRequest: true, Verb: "get", Resource: "persistentvolumeclaims", Name: "pvc0-pod0-node0", Namespace: "ns0"},
0000000000000000000000000000000000000000;;				expect: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "allowed pv",
0000000000000000000000000000000000000000;;				attrs:  authorizer.AttributesRecord{User: node0, ResourceRequest: true, Verb: "get", Resource: "persistentvolumes", Name: "pv0-pod0-node0-ns0", Namespace: ""},
0000000000000000000000000000000000000000;;				expect: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "disallowed configmap",
0000000000000000000000000000000000000000;;				attrs:  authorizer.AttributesRecord{User: node0, ResourceRequest: true, Verb: "get", Resource: "configmaps", Name: "configmap0-pod0-node1", Namespace: "ns0"},
0000000000000000000000000000000000000000;;				expect: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "disallowed secret via pod",
0000000000000000000000000000000000000000;;				attrs:  authorizer.AttributesRecord{User: node0, ResourceRequest: true, Verb: "get", Resource: "secrets", Name: "secret0-pod0-node1", Namespace: "ns0"},
0000000000000000000000000000000000000000;;				expect: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "disallowed shared secret via pvc",
0000000000000000000000000000000000000000;;				attrs:  authorizer.AttributesRecord{User: node0, ResourceRequest: true, Verb: "get", Resource: "secrets", Name: "secret-pv0-pod0-node1-ns0", Namespace: "ns0"},
0000000000000000000000000000000000000000;;				expect: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "disallowed pvc",
0000000000000000000000000000000000000000;;				attrs:  authorizer.AttributesRecord{User: node0, ResourceRequest: true, Verb: "get", Resource: "persistentvolumeclaims", Name: "pvc0-pod0-node1", Namespace: "ns0"},
0000000000000000000000000000000000000000;;				expect: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "disallowed pv",
0000000000000000000000000000000000000000;;				attrs:  authorizer.AttributesRecord{User: node0, ResourceRequest: true, Verb: "get", Resource: "persistentvolumes", Name: "pv0-pod0-node1-ns0", Namespace: ""},
0000000000000000000000000000000000000000;;				expect: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range tests {
0000000000000000000000000000000000000000;;			t.Run(tc.name, func(t *testing.T) {
0000000000000000000000000000000000000000;;				ok, _, _ := authz.Authorize(tc.attrs)
0000000000000000000000000000000000000000;;				if ok != tc.expect {
0000000000000000000000000000000000000000;;					t.Errorf("expected %v, got %v", tc.expect, ok)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAuthorizerSharedResources(t *testing.T) {
0000000000000000000000000000000000000000;;		g := NewGraph()
0000000000000000000000000000000000000000;;		identifier := nodeidentifier.NewDefaultNodeIdentifier()
0000000000000000000000000000000000000000;;		authz := NewAuthorizer(g, identifier, bootstrappolicy.NodeRules())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node1 := &user.DefaultInfo{Name: "system:node:node1", Groups: []string{"system:nodes"}}
0000000000000000000000000000000000000000;;		node2 := &user.DefaultInfo{Name: "system:node:node2", Groups: []string{"system:nodes"}}
0000000000000000000000000000000000000000;;		node3 := &user.DefaultInfo{Name: "system:node:node3", Groups: []string{"system:nodes"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.AddPod(&api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "pod1-node1", Namespace: "ns1"},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				NodeName: "node1",
0000000000000000000000000000000000000000;;				Volumes: []api.Volume{
0000000000000000000000000000000000000000;;					{VolumeSource: api.VolumeSource{Secret: &api.SecretVolumeSource{SecretName: "node1-only"}}},
0000000000000000000000000000000000000000;;					{VolumeSource: api.VolumeSource{Secret: &api.SecretVolumeSource{SecretName: "node1-node2-only"}}},
0000000000000000000000000000000000000000;;					{VolumeSource: api.VolumeSource{Secret: &api.SecretVolumeSource{SecretName: "shared-all"}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		g.AddPod(&api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "pod2-node2", Namespace: "ns1"},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				NodeName: "node2",
0000000000000000000000000000000000000000;;				Volumes: []api.Volume{
0000000000000000000000000000000000000000;;					{VolumeSource: api.VolumeSource{Secret: &api.SecretVolumeSource{SecretName: "node1-node2-only"}}},
0000000000000000000000000000000000000000;;					{VolumeSource: api.VolumeSource{Secret: &api.SecretVolumeSource{SecretName: "shared-all"}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		g.AddPod(&api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "pod3-node3", Namespace: "ns1"},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				NodeName: "node3",
0000000000000000000000000000000000000000;;				Volumes: []api.Volume{
0000000000000000000000000000000000000000;;					{VolumeSource: api.VolumeSource{Secret: &api.SecretVolumeSource{SecretName: "shared-all"}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testcases := []struct {
0000000000000000000000000000000000000000;;			User          user.Info
0000000000000000000000000000000000000000;;			Secret        string
0000000000000000000000000000000000000000;;			ExpectAllowed bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{User: node1, ExpectAllowed: true, Secret: "node1-only"},
0000000000000000000000000000000000000000;;			{User: node1, ExpectAllowed: true, Secret: "node1-node2-only"},
0000000000000000000000000000000000000000;;			{User: node1, ExpectAllowed: true, Secret: "shared-all"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{User: node2, ExpectAllowed: false, Secret: "node1-only"},
0000000000000000000000000000000000000000;;			{User: node2, ExpectAllowed: true, Secret: "node1-node2-only"},
0000000000000000000000000000000000000000;;			{User: node2, ExpectAllowed: true, Secret: "shared-all"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{User: node3, ExpectAllowed: false, Secret: "node1-only"},
0000000000000000000000000000000000000000;;			{User: node3, ExpectAllowed: false, Secret: "node1-node2-only"},
0000000000000000000000000000000000000000;;			{User: node3, ExpectAllowed: true, Secret: "shared-all"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testcases {
0000000000000000000000000000000000000000;;			ok, _, err := authz.Authorize(authorizer.AttributesRecord{User: tc.User, ResourceRequest: true, Verb: "get", Resource: "secrets", Namespace: "ns1", Name: tc.Secret})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ok != tc.ExpectAllowed {
0000000000000000000000000000000000000000;;				t.Errorf("%d: expected %v, got %v", i, tc.ExpectAllowed, ok)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sampleDataOpts struct {
0000000000000000000000000000000000000000;;		nodes int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespaces int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podsPerNode int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sharedConfigMapsPerPod int
0000000000000000000000000000000000000000;;		sharedSecretsPerPod    int
0000000000000000000000000000000000000000;;		sharedPVCsPerPod       int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uniqueSecretsPerPod    int
0000000000000000000000000000000000000000;;		uniqueConfigMapsPerPod int
0000000000000000000000000000000000000000;;		uniquePVCsPerPod       int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkPopulationAllocation(b *testing.B) {
0000000000000000000000000000000000000000;;		opts := sampleDataOpts{
0000000000000000000000000000000000000000;;			nodes:                  500,
0000000000000000000000000000000000000000;;			namespaces:             200,
0000000000000000000000000000000000000000;;			podsPerNode:            200,
0000000000000000000000000000000000000000;;			sharedConfigMapsPerPod: 0,
0000000000000000000000000000000000000000;;			uniqueConfigMapsPerPod: 1,
0000000000000000000000000000000000000000;;			sharedSecretsPerPod:    1,
0000000000000000000000000000000000000000;;			uniqueSecretsPerPod:    1,
0000000000000000000000000000000000000000;;			sharedPVCsPerPod:       0,
0000000000000000000000000000000000000000;;			uniquePVCsPerPod:       1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods, pvs := generate(opts)
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			g := NewGraph()
0000000000000000000000000000000000000000;;			populate(g, pods, pvs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkPopulationRetention(b *testing.B) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run with:
0000000000000000000000000000000000000000;;		// go test ./plugin/pkg/auth/authorizer/node -benchmem -bench . -run None -v -o node.test -timeout 300m
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Evaluate retained memory with:
0000000000000000000000000000000000000000;;		// go tool pprof --inuse_space node.test plugin/pkg/auth/authorizer/node/BenchmarkPopulationRetention.profile
0000000000000000000000000000000000000000;;		// list populate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts := sampleDataOpts{
0000000000000000000000000000000000000000;;			nodes:                  500,
0000000000000000000000000000000000000000;;			namespaces:             200,
0000000000000000000000000000000000000000;;			podsPerNode:            200,
0000000000000000000000000000000000000000;;			sharedConfigMapsPerPod: 0,
0000000000000000000000000000000000000000;;			uniqueConfigMapsPerPod: 1,
0000000000000000000000000000000000000000;;			sharedSecretsPerPod:    1,
0000000000000000000000000000000000000000;;			uniqueSecretsPerPod:    1,
0000000000000000000000000000000000000000;;			sharedPVCsPerPod:       0,
0000000000000000000000000000000000000000;;			uniquePVCsPerPod:       1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods, pvs := generate(opts)
0000000000000000000000000000000000000000;;		// Garbage collect before the first iteration
0000000000000000000000000000000000000000;;		runtime.GC()
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			g := NewGraph()
0000000000000000000000000000000000000000;;			populate(g, pods, pvs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i == 0 {
0000000000000000000000000000000000000000;;				f, _ := os.Create("BenchmarkPopulationRetention.profile")
0000000000000000000000000000000000000000;;				runtime.GC()
0000000000000000000000000000000000000000;;				pprof.WriteHeapProfile(f)
0000000000000000000000000000000000000000;;				f.Close()
0000000000000000000000000000000000000000;;				// reference the graph to keep it from getting garbage collected
0000000000000000000000000000000000000000;;				_ = fmt.Sprintf("%T\n", g)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkAuthorization(b *testing.B) {
0000000000000000000000000000000000000000;;		g := NewGraph()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts := sampleDataOpts{
0000000000000000000000000000000000000000;;			nodes:                  500,
0000000000000000000000000000000000000000;;			namespaces:             200,
0000000000000000000000000000000000000000;;			podsPerNode:            200,
0000000000000000000000000000000000000000;;			sharedConfigMapsPerPod: 0,
0000000000000000000000000000000000000000;;			uniqueConfigMapsPerPod: 1,
0000000000000000000000000000000000000000;;			sharedSecretsPerPod:    1,
0000000000000000000000000000000000000000;;			uniqueSecretsPerPod:    1,
0000000000000000000000000000000000000000;;			sharedPVCsPerPod:       0,
0000000000000000000000000000000000000000;;			uniquePVCsPerPod:       1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pods, pvs := generate(opts)
0000000000000000000000000000000000000000;;		populate(g, pods, pvs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		identifier := nodeidentifier.NewDefaultNodeIdentifier()
0000000000000000000000000000000000000000;;		authz := NewAuthorizer(g, identifier, bootstrappolicy.NodeRules())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node0 := &user.DefaultInfo{Name: "system:node:node0", Groups: []string{"system:nodes"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name   string
0000000000000000000000000000000000000000;;			attrs  authorizer.AttributesRecord
0000000000000000000000000000000000000000;;			expect bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "allowed configmap",
0000000000000000000000000000000000000000;;				attrs:  authorizer.AttributesRecord{User: node0, ResourceRequest: true, Verb: "get", Resource: "configmaps", Name: "configmap0-pod0-node0", Namespace: "ns0"},
0000000000000000000000000000000000000000;;				expect: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "allowed secret via pod",
0000000000000000000000000000000000000000;;				attrs:  authorizer.AttributesRecord{User: node0, ResourceRequest: true, Verb: "get", Resource: "secrets", Name: "secret0-pod0-node0", Namespace: "ns0"},
0000000000000000000000000000000000000000;;				expect: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "allowed shared secret via pod",
0000000000000000000000000000000000000000;;				attrs:  authorizer.AttributesRecord{User: node0, ResourceRequest: true, Verb: "get", Resource: "secrets", Name: "secret0-shared", Namespace: "ns0"},
0000000000000000000000000000000000000000;;				expect: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "disallowed configmap",
0000000000000000000000000000000000000000;;				attrs:  authorizer.AttributesRecord{User: node0, ResourceRequest: true, Verb: "get", Resource: "configmaps", Name: "configmap0-pod0-node1", Namespace: "ns0"},
0000000000000000000000000000000000000000;;				expect: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "disallowed secret via pod",
0000000000000000000000000000000000000000;;				attrs:  authorizer.AttributesRecord{User: node0, ResourceRequest: true, Verb: "get", Resource: "secrets", Name: "secret0-pod0-node1", Namespace: "ns0"},
0000000000000000000000000000000000000000;;				expect: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "disallowed shared secret via pvc",
0000000000000000000000000000000000000000;;				attrs:  authorizer.AttributesRecord{User: node0, ResourceRequest: true, Verb: "get", Resource: "secrets", Name: "secret-pv0-pod0-node1-ns0", Namespace: "ns0"},
0000000000000000000000000000000000000000;;				expect: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "disallowed pvc",
0000000000000000000000000000000000000000;;				attrs:  authorizer.AttributesRecord{User: node0, ResourceRequest: true, Verb: "get", Resource: "persistentvolumeclaims", Name: "pvc0-pod0-node1", Namespace: "ns0"},
0000000000000000000000000000000000000000;;				expect: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "disallowed pv",
0000000000000000000000000000000000000000;;				attrs:  authorizer.AttributesRecord{User: node0, ResourceRequest: true, Verb: "get", Resource: "persistentvolumes", Name: "pv0-pod0-node1-ns0", Namespace: ""},
0000000000000000000000000000000000000000;;				expect: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for _, tc := range tests {
0000000000000000000000000000000000000000;;			b.Run(tc.name, func(b *testing.B) {
0000000000000000000000000000000000000000;;				for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;					ok, _, _ := authz.Authorize(tc.attrs)
0000000000000000000000000000000000000000;;					if ok != tc.expect {
0000000000000000000000000000000000000000;;						b.Errorf("expected %v, got %v", tc.expect, ok)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func populate(graph *Graph, pods []*api.Pod, pvs []*api.PersistentVolume) {
0000000000000000000000000000000000000000;;		p := &graphPopulator{}
0000000000000000000000000000000000000000;;		p.graph = graph
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			p.addPod(pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pv := range pvs {
0000000000000000000000000000000000000000;;			p.addPV(pv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generate creates sample pods and persistent volumes based on the provided options.
0000000000000000000000000000000000000000;;	// the secret/configmap/pvc/node references in the pod and pv objects are named to indicate the connections between the objects.
0000000000000000000000000000000000000000;;	// for example, secret0-pod0-node0 is a secret referenced by pod0 which is bound to node0.
0000000000000000000000000000000000000000;;	// when populated into the graph, the node authorizer should allow node0 to access that secret, but not node1.
0000000000000000000000000000000000000000;;	func generate(opts sampleDataOpts) ([]*api.Pod, []*api.PersistentVolume) {
0000000000000000000000000000000000000000;;		pods := make([]*api.Pod, 0, opts.nodes*opts.podsPerNode)
0000000000000000000000000000000000000000;;		pvs := make([]*api.PersistentVolume, 0, (opts.nodes*opts.podsPerNode*opts.uniquePVCsPerPod)+(opts.sharedPVCsPerPod*opts.namespaces))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for n := 0; n < opts.nodes; n++ {
0000000000000000000000000000000000000000;;			nodeName := fmt.Sprintf("node%d", n)
0000000000000000000000000000000000000000;;			for p := 0; p < opts.podsPerNode; p++ {
0000000000000000000000000000000000000000;;				pod := &api.Pod{}
0000000000000000000000000000000000000000;;				pod.Namespace = fmt.Sprintf("ns%d", p%opts.namespaces)
0000000000000000000000000000000000000000;;				pod.Name = fmt.Sprintf("pod%d-%s", p, nodeName)
0000000000000000000000000000000000000000;;				pod.Spec.NodeName = nodeName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for i := 0; i < opts.uniqueSecretsPerPod; i++ {
0000000000000000000000000000000000000000;;					pod.Spec.Volumes = append(pod.Spec.Volumes, api.Volume{VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;						Secret: &api.SecretVolumeSource{SecretName: fmt.Sprintf("secret%d-%s", i, pod.Name)},
0000000000000000000000000000000000000000;;					}})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for i := 0; i < opts.sharedSecretsPerPod; i++ {
0000000000000000000000000000000000000000;;					pod.Spec.Volumes = append(pod.Spec.Volumes, api.Volume{VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;						Secret: &api.SecretVolumeSource{SecretName: fmt.Sprintf("secret%d-shared", i)},
0000000000000000000000000000000000000000;;					}})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for i := 0; i < opts.uniqueConfigMapsPerPod; i++ {
0000000000000000000000000000000000000000;;					pod.Spec.Volumes = append(pod.Spec.Volumes, api.Volume{VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;						ConfigMap: &api.ConfigMapVolumeSource{LocalObjectReference: api.LocalObjectReference{Name: fmt.Sprintf("configmap%d-%s", i, pod.Name)}},
0000000000000000000000000000000000000000;;					}})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for i := 0; i < opts.sharedConfigMapsPerPod; i++ {
0000000000000000000000000000000000000000;;					pod.Spec.Volumes = append(pod.Spec.Volumes, api.Volume{VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;						ConfigMap: &api.ConfigMapVolumeSource{LocalObjectReference: api.LocalObjectReference{Name: fmt.Sprintf("configmap%d-shared", i)}},
0000000000000000000000000000000000000000;;					}})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for i := 0; i < opts.uniquePVCsPerPod; i++ {
0000000000000000000000000000000000000000;;					pv := &api.PersistentVolume{}
0000000000000000000000000000000000000000;;					pv.Name = fmt.Sprintf("pv%d-%s-%s", i, pod.Name, pod.Namespace)
0000000000000000000000000000000000000000;;					pv.Spec.FlexVolume = &api.FlexVolumeSource{SecretRef: &api.LocalObjectReference{Name: fmt.Sprintf("secret-%s", pv.Name)}}
0000000000000000000000000000000000000000;;					pv.Spec.ClaimRef = &api.ObjectReference{Name: fmt.Sprintf("pvc%d-%s", i, pod.Name), Namespace: pod.Namespace}
0000000000000000000000000000000000000000;;					pvs = append(pvs, pv)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					pod.Spec.Volumes = append(pod.Spec.Volumes, api.Volume{VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;						PersistentVolumeClaim: &api.PersistentVolumeClaimVolumeSource{ClaimName: pv.Spec.ClaimRef.Name},
0000000000000000000000000000000000000000;;					}})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for i := 0; i < opts.sharedPVCsPerPod; i++ {
0000000000000000000000000000000000000000;;					pv := &api.PersistentVolume{}
0000000000000000000000000000000000000000;;					pv.Name = fmt.Sprintf("pv%d-shared-%s", i, pod.Namespace)
0000000000000000000000000000000000000000;;					pv.Spec.FlexVolume = &api.FlexVolumeSource{SecretRef: &api.LocalObjectReference{Name: fmt.Sprintf("secret-%s", pv.Name)}}
0000000000000000000000000000000000000000;;					pv.Spec.ClaimRef = &api.ObjectReference{Name: fmt.Sprintf("pvc%d-shared", i), Namespace: pod.Namespace}
0000000000000000000000000000000000000000;;					pvs = append(pvs, pv)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					pod.Spec.Volumes = append(pod.Spec.Volumes, api.Volume{VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;						PersistentVolumeClaim: &api.PersistentVolumeClaimVolumeSource{ClaimName: pv.Spec.ClaimRef.Name},
0000000000000000000000000000000000000000;;					}})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				pods = append(pods, pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pods, pvs
0000000000000000000000000000000000000000;;	}
