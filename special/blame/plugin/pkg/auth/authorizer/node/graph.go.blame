0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
9c97f06e1356e7ea7b8c52255a3c0aebc1c1200d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		pvutil "k8s.io/kubernetes/pkg/api/persistentvolume"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/third_party/forked/gonum/graph"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/third_party/forked/gonum/graph/simple"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// namedVertex implements graph.Node and remembers the type, namespace, and name of its related API object
0000000000000000000000000000000000000000;;	type namedVertex struct {
0000000000000000000000000000000000000000;;		name       string
0000000000000000000000000000000000000000;;		namespace  string
0000000000000000000000000000000000000000;;		id         int
0000000000000000000000000000000000000000;;		vertexType vertexType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newNamedVertex(vertexType vertexType, namespace, name string, id int) *namedVertex {
0000000000000000000000000000000000000000;;		return &namedVertex{
0000000000000000000000000000000000000000;;			vertexType: vertexType,
0000000000000000000000000000000000000000;;			name:       name,
0000000000000000000000000000000000000000;;			namespace:  namespace,
0000000000000000000000000000000000000000;;			id:         id,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (n *namedVertex) ID() int {
0000000000000000000000000000000000000000;;		return n.id
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (n *namedVertex) String() string {
0000000000000000000000000000000000000000;;		if len(n.namespace) == 0 {
0000000000000000000000000000000000000000;;			return vertexTypes[n.vertexType] + ":" + n.name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vertexTypes[n.vertexType] + ":" + n.namespace + "/" + n.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// destinationEdge is a graph edge that includes a denormalized reference to the final destination vertex.
0000000000000000000000000000000000000000;;	// This should only be used when there is a single leaf vertex reachable from T.
0000000000000000000000000000000000000000;;	type destinationEdge struct {
0000000000000000000000000000000000000000;;		F           graph.Node
0000000000000000000000000000000000000000;;		T           graph.Node
0000000000000000000000000000000000000000;;		Destination graph.Node
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDestinationEdge(from, to, destination graph.Node) graph.Edge {
0000000000000000000000000000000000000000;;		return &destinationEdge{F: from, T: to, Destination: destination}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (e *destinationEdge) From() graph.Node   { return e.F }
0000000000000000000000000000000000000000;;	func (e *destinationEdge) To() graph.Node     { return e.T }
0000000000000000000000000000000000000000;;	func (e *destinationEdge) Weight() float64    { return 0 }
0000000000000000000000000000000000000000;;	func (e *destinationEdge) DestinationID() int { return e.Destination.ID() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Graph holds graph vertices and a way to look up a vertex for a particular API type/namespace/name.
0000000000000000000000000000000000000000;;	// All edges point toward the vertices representing Kubernetes nodes:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// node <- pod
0000000000000000000000000000000000000000;;	// pod  <- secret,configmap,pvc
0000000000000000000000000000000000000000;;	// pvc  <- pv
0000000000000000000000000000000000000000;;	// pv   <- secret
0000000000000000000000000000000000000000;;	type Graph struct {
0000000000000000000000000000000000000000;;		lock  sync.RWMutex
0000000000000000000000000000000000000000;;		graph *simple.DirectedAcyclicGraph
0000000000000000000000000000000000000000;;		// vertices is a map of type -> namespace -> name -> vertex
0000000000000000000000000000000000000000;;		vertices map[vertexType]namespaceVertexMapping
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// namespaceVertexMapping is a map of namespace -> name -> vertex
0000000000000000000000000000000000000000;;	type namespaceVertexMapping map[string]nameVertexMapping
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nameVertexMapping is a map of name -> vertex
0000000000000000000000000000000000000000;;	type nameVertexMapping map[string]*namedVertex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewGraph() *Graph {
0000000000000000000000000000000000000000;;		return &Graph{
0000000000000000000000000000000000000000;;			vertices: map[vertexType]namespaceVertexMapping{},
0000000000000000000000000000000000000000;;			graph:    simple.NewDirectedAcyclicGraph(0, 0),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// vertexType indicates the type of the API object the vertex represents.
0000000000000000000000000000000000000000;;	// represented as a byte to minimize space used in the vertices.
0000000000000000000000000000000000000000;;	type vertexType byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		configMapVertexType vertexType = iota
0000000000000000000000000000000000000000;;		nodeVertexType
0000000000000000000000000000000000000000;;		podVertexType
0000000000000000000000000000000000000000;;		pvcVertexType
0000000000000000000000000000000000000000;;		pvVertexType
0000000000000000000000000000000000000000;;		secretVertexType
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var vertexTypes = map[vertexType]string{
0000000000000000000000000000000000000000;;		configMapVertexType: "configmap",
0000000000000000000000000000000000000000;;		nodeVertexType:      "node",
0000000000000000000000000000000000000000;;		podVertexType:       "pod",
0000000000000000000000000000000000000000;;		pvcVertexType:       "pvc",
0000000000000000000000000000000000000000;;		pvVertexType:        "pv",
0000000000000000000000000000000000000000;;		secretVertexType:    "secret",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// must be called under a write lock
0000000000000000000000000000000000000000;;	func (g *Graph) getOrCreateVertex_locked(vertexType vertexType, namespace, name string) *namedVertex {
0000000000000000000000000000000000000000;;		if vertex, exists := g.getVertex_rlocked(vertexType, namespace, name); exists {
0000000000000000000000000000000000000000;;			return vertex
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return g.createVertex_locked(vertexType, namespace, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// must be called under a read lock
0000000000000000000000000000000000000000;;	func (g *Graph) getVertex_rlocked(vertexType vertexType, namespace, name string) (*namedVertex, bool) {
0000000000000000000000000000000000000000;;		vertex, exists := g.vertices[vertexType][namespace][name]
0000000000000000000000000000000000000000;;		return vertex, exists
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// must be called under a write lock
0000000000000000000000000000000000000000;;	func (g *Graph) createVertex_locked(vertexType vertexType, namespace, name string) *namedVertex {
0000000000000000000000000000000000000000;;		typedVertices, exists := g.vertices[vertexType]
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			typedVertices = namespaceVertexMapping{}
0000000000000000000000000000000000000000;;			g.vertices[vertexType] = typedVertices
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespacedVertices, exists := typedVertices[namespace]
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			namespacedVertices = map[string]*namedVertex{}
0000000000000000000000000000000000000000;;			typedVertices[namespace] = namespacedVertices
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vertex := newNamedVertex(vertexType, namespace, name, g.graph.NewNodeID())
0000000000000000000000000000000000000000;;		namespacedVertices[name] = vertex
0000000000000000000000000000000000000000;;		g.graph.AddNode(vertex)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return vertex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// must be called under write lock
0000000000000000000000000000000000000000;;	func (g *Graph) deleteVertex_locked(vertexType vertexType, namespace, name string) {
0000000000000000000000000000000000000000;;		vertex, exists := g.getVertex_rlocked(vertexType, namespace, name)
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// find existing neighbors with a single edge (meaning we are their only neighbor)
0000000000000000000000000000000000000000;;		neighborsToRemove := []graph.Node{}
0000000000000000000000000000000000000000;;		g.graph.VisitFrom(vertex, func(neighbor graph.Node) bool {
0000000000000000000000000000000000000000;;			// this downstream neighbor has only one edge (which must be from us), so remove them as well
0000000000000000000000000000000000000000;;			if g.graph.Degree(neighbor) == 1 {
0000000000000000000000000000000000000000;;				neighborsToRemove = append(neighborsToRemove, neighbor)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		g.graph.VisitTo(vertex, func(neighbor graph.Node) bool {
0000000000000000000000000000000000000000;;			// this upstream neighbor has only one edge (which must be to us), so remove them as well
0000000000000000000000000000000000000000;;			if g.graph.Degree(neighbor) == 1 {
0000000000000000000000000000000000000000;;				neighborsToRemove = append(neighborsToRemove, neighbor)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// remove the vertex
0000000000000000000000000000000000000000;;		g.graph.RemoveNode(vertex)
0000000000000000000000000000000000000000;;		delete(g.vertices[vertexType][namespace], name)
0000000000000000000000000000000000000000;;		if len(g.vertices[vertexType][namespace]) == 0 {
0000000000000000000000000000000000000000;;			delete(g.vertices[vertexType], namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// remove neighbors that are now edgeless
0000000000000000000000000000000000000000;;		for _, neighbor := range neighborsToRemove {
0000000000000000000000000000000000000000;;			g.graph.RemoveNode(neighbor)
0000000000000000000000000000000000000000;;			n := neighbor.(*namedVertex)
0000000000000000000000000000000000000000;;			delete(g.vertices[n.vertexType][n.namespace], n.name)
0000000000000000000000000000000000000000;;			if len(g.vertices[n.vertexType][n.namespace]) == 0 {
0000000000000000000000000000000000000000;;				delete(g.vertices[n.vertexType], n.namespace)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddPod should only be called once spec.NodeName is populated.
0000000000000000000000000000000000000000;;	// It sets up edges for the following relationships (which are immutable for a pod once bound to a node):
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   pod -> node
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   secret    -> pod
0000000000000000000000000000000000000000;;	//   configmap -> pod
0000000000000000000000000000000000000000;;	//   pvc       -> pod
0000000000000000000000000000000000000000;;	func (g *Graph) AddPod(pod *api.Pod) {
0000000000000000000000000000000000000000;;		g.lock.Lock()
0000000000000000000000000000000000000000;;		defer g.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.deleteVertex_locked(podVertexType, pod.Namespace, pod.Name)
0000000000000000000000000000000000000000;;		podVertex := g.getOrCreateVertex_locked(podVertexType, pod.Namespace, pod.Name)
0000000000000000000000000000000000000000;;		nodeVertex := g.getOrCreateVertex_locked(nodeVertexType, "", pod.Spec.NodeName)
0000000000000000000000000000000000000000;;		g.graph.SetEdge(newDestinationEdge(podVertex, nodeVertex, nodeVertex))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podutil.VisitPodSecretNames(pod, func(secret string) bool {
0000000000000000000000000000000000000000;;			g.graph.SetEdge(newDestinationEdge(g.getOrCreateVertex_locked(secretVertexType, pod.Namespace, secret), podVertex, nodeVertex))
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podutil.VisitPodConfigmapNames(pod, func(configmap string) bool {
0000000000000000000000000000000000000000;;			g.graph.SetEdge(newDestinationEdge(g.getOrCreateVertex_locked(configMapVertexType, pod.Namespace, configmap), podVertex, nodeVertex))
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, v := range pod.Spec.Volumes {
0000000000000000000000000000000000000000;;			if v.PersistentVolumeClaim != nil {
0000000000000000000000000000000000000000;;				g.graph.SetEdge(newDestinationEdge(g.getOrCreateVertex_locked(pvcVertexType, pod.Namespace, v.PersistentVolumeClaim.ClaimName), podVertex, nodeVertex))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (g *Graph) DeletePod(name, namespace string) {
0000000000000000000000000000000000000000;;		g.lock.Lock()
0000000000000000000000000000000000000000;;		defer g.lock.Unlock()
0000000000000000000000000000000000000000;;		g.deleteVertex_locked(podVertexType, namespace, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddPV sets up edges for the following relationships:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   secret -> pv
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   pv -> pvc
0000000000000000000000000000000000000000;;	func (g *Graph) AddPV(pv *api.PersistentVolume) {
0000000000000000000000000000000000000000;;		g.lock.Lock()
0000000000000000000000000000000000000000;;		defer g.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// clear existing edges
0000000000000000000000000000000000000000;;		g.deleteVertex_locked(pvVertexType, "", pv.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we have a pvc, establish new edges
0000000000000000000000000000000000000000;;		if pv.Spec.ClaimRef != nil {
0000000000000000000000000000000000000000;;			pvVertex := g.getOrCreateVertex_locked(pvVertexType, "", pv.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// since we don't know the other end of the pvc -> pod -> node chain (or it may not even exist yet), we can't decorate these edges with kubernetes node info
0000000000000000000000000000000000000000;;			g.graph.SetEdge(simple.Edge{F: pvVertex, T: g.getOrCreateVertex_locked(pvcVertexType, pv.Spec.ClaimRef.Namespace, pv.Spec.ClaimRef.Name)})
0000000000000000000000000000000000000000;;			pvutil.VisitPVSecretNames(pv, func(namespace, secret string) bool {
0000000000000000000000000000000000000000;;				// This grants access to the named secret in the same namespace as the bound PVC
0000000000000000000000000000000000000000;;				g.graph.SetEdge(simple.Edge{F: g.getOrCreateVertex_locked(secretVertexType, namespace, secret), T: pvVertex})
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (g *Graph) DeletePV(name string) {
0000000000000000000000000000000000000000;;		g.lock.Lock()
0000000000000000000000000000000000000000;;		defer g.lock.Unlock()
0000000000000000000000000000000000000000;;		g.deleteVertex_locked(pvVertexType, "", name)
0000000000000000000000000000000000000000;;	}
