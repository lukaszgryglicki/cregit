0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
9c97f06e1356e7ea7b8c52255a3c0aebc1c1200d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		rbacapi "k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/auth/nodeidentifier"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/auth/authorizer/rbac"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/third_party/forked/gonum/graph"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/third_party/forked/gonum/graph/traverse"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeAuthorizer authorizes requests from kubelets, with the following logic:
0000000000000000000000000000000000000000;;	// 1. If a request is not from a node (IdentifyNode() returns isNode=false), reject
0000000000000000000000000000000000000000;;	// 2. If a specific node cannot be identified (IdentifyNode() returns nodeName=""), reject
0000000000000000000000000000000000000000;;	// 3. If a request is for a secret, configmap, persistent volume or persistent volume claim, reject unless the verb is get, and the requested object is related to the requesting node:
0000000000000000000000000000000000000000;;	//    node <- pod
0000000000000000000000000000000000000000;;	//    node <- pod <- secret
0000000000000000000000000000000000000000;;	//    node <- pod <- configmap
0000000000000000000000000000000000000000;;	//    node <- pod <- pvc
0000000000000000000000000000000000000000;;	//    node <- pod <- pvc <- pv
0000000000000000000000000000000000000000;;	//    node <- pod <- pvc <- pv <- secret
0000000000000000000000000000000000000000;;	// 4. For other resources, authorize all nodes uniformly using statically defined rules
0000000000000000000000000000000000000000;;	type NodeAuthorizer struct {
0000000000000000000000000000000000000000;;		graph      *Graph
0000000000000000000000000000000000000000;;		identifier nodeidentifier.NodeIdentifier
0000000000000000000000000000000000000000;;		nodeRules  []rbacapi.PolicyRule
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAuthorizer returns a new node authorizer
0000000000000000000000000000000000000000;;	func NewAuthorizer(graph *Graph, identifier nodeidentifier.NodeIdentifier, rules []rbacapi.PolicyRule) authorizer.Authorizer {
0000000000000000000000000000000000000000;;		return &NodeAuthorizer{
0000000000000000000000000000000000000000;;			graph:      graph,
0000000000000000000000000000000000000000;;			identifier: identifier,
0000000000000000000000000000000000000000;;			nodeRules:  rules,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		configMapResource = api.Resource("configmaps")
0000000000000000000000000000000000000000;;		secretResource    = api.Resource("secrets")
0000000000000000000000000000000000000000;;		pvcResource       = api.Resource("persistentvolumeclaims")
0000000000000000000000000000000000000000;;		pvResource        = api.Resource("persistentvolumes")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *NodeAuthorizer) Authorize(attrs authorizer.Attributes) (bool, string, error) {
0000000000000000000000000000000000000000;;		nodeName, isNode := r.identifier.NodeIdentity(attrs.GetUser())
0000000000000000000000000000000000000000;;		if !isNode {
0000000000000000000000000000000000000000;;			// reject requests from non-nodes
0000000000000000000000000000000000000000;;			return false, "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(nodeName) == 0 {
0000000000000000000000000000000000000000;;			// reject requests from unidentifiable nodes
0000000000000000000000000000000000000000;;			glog.V(2).Infof("NODE DENY: unknown node for user %q", attrs.GetUser().GetName())
0000000000000000000000000000000000000000;;			return false, fmt.Sprintf("unknown node for user %q", attrs.GetUser().GetName()), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// subdivide access to specific resources
0000000000000000000000000000000000000000;;		if attrs.IsResourceRequest() {
0000000000000000000000000000000000000000;;			requestResource := schema.GroupResource{Group: attrs.GetAPIGroup(), Resource: attrs.GetResource()}
0000000000000000000000000000000000000000;;			switch requestResource {
0000000000000000000000000000000000000000;;			case secretResource:
0000000000000000000000000000000000000000;;				return r.authorizeGet(nodeName, secretVertexType, attrs)
0000000000000000000000000000000000000000;;			case configMapResource:
0000000000000000000000000000000000000000;;				return r.authorizeGet(nodeName, configMapVertexType, attrs)
0000000000000000000000000000000000000000;;			case pvcResource:
0000000000000000000000000000000000000000;;				return r.authorizeGet(nodeName, pvcVertexType, attrs)
0000000000000000000000000000000000000000;;			case pvResource:
0000000000000000000000000000000000000000;;				return r.authorizeGet(nodeName, pvVertexType, attrs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Access to other resources is not subdivided, so just evaluate against the statically defined node rules
0000000000000000000000000000000000000000;;		return rbac.RulesAllow(attrs, r.nodeRules...), "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// authorizeGet authorizes "get" requests to objects of the specified type if they are related to the specified node
0000000000000000000000000000000000000000;;	func (r *NodeAuthorizer) authorizeGet(nodeName string, startingType vertexType, attrs authorizer.Attributes) (bool, string, error) {
0000000000000000000000000000000000000000;;		if attrs.GetVerb() != "get" || len(attrs.GetName()) == 0 {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("NODE DENY: %s %#v", nodeName, attrs)
0000000000000000000000000000000000000000;;			return false, "can only get individual resources of this type", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(attrs.GetSubresource()) > 0 {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("NODE DENY: %s %#v", nodeName, attrs)
0000000000000000000000000000000000000000;;			return false, "cannot get subresource", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ok, err := r.hasPathFrom(nodeName, startingType, attrs.GetNamespace(), attrs.GetName())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("NODE DENY: %v", err)
0000000000000000000000000000000000000000;;			return false, "no path found to object", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("NODE DENY: %q %#v", nodeName, attrs)
0000000000000000000000000000000000000000;;			return false, "no path found to object", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ok, "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hasPathFrom returns true if there is a directed path from the specified type/namespace/name to the specified Node
0000000000000000000000000000000000000000;;	func (r *NodeAuthorizer) hasPathFrom(nodeName string, startingType vertexType, startingNamespace, startingName string) (bool, error) {
0000000000000000000000000000000000000000;;		r.graph.lock.RLock()
0000000000000000000000000000000000000000;;		defer r.graph.lock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeVertex, exists := r.graph.getVertex_rlocked(nodeVertexType, "", nodeName)
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("unknown node %q cannot get %s %s/%s", nodeName, vertexTypes[startingType], startingNamespace, startingName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		startingVertex, exists := r.graph.getVertex_rlocked(startingType, startingNamespace, startingName)
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("node %q cannot get unknown %s %s/%s", nodeName, vertexTypes[startingType], startingNamespace, startingName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		found := false
0000000000000000000000000000000000000000;;		traversal := &traverse.VisitingDepthFirst{
0000000000000000000000000000000000000000;;			EdgeFilter: func(edge graph.Edge) bool {
0000000000000000000000000000000000000000;;				if destinationEdge, ok := edge.(*destinationEdge); ok {
0000000000000000000000000000000000000000;;					if destinationEdge.DestinationID() != nodeVertex.ID() {
0000000000000000000000000000000000000000;;						// Don't follow edges leading to other nodes
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// We found an edge leading to the node we want
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Visit this edge
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		traversal.Walk(r.graph.graph, startingVertex, func(n graph.Node) bool {
0000000000000000000000000000000000000000;;			if n.ID() == nodeVertex.ID() {
0000000000000000000000000000000000000000;;				// We found the node we want
0000000000000000000000000000000000000000;;				found = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Stop visiting if we've found the node we want
0000000000000000000000000000000000000000;;			return found
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("node %q cannot get %s %s/%s, no path was found", nodeName, vertexTypes[startingType], startingNamespace, startingName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
