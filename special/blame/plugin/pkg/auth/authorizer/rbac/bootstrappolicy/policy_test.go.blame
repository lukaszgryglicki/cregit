0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
dfc5cfa19ebc203edf34d3d3fd753d679629ad02;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package bootstrappolicy_test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/ghodss/yaml"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		rbacv1beta1 "k8s.io/api/rbac/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/api/install"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/rbac/install"
0000000000000000000000000000000000000000;;		rbacregistryvalidation "k8s.io/kubernetes/pkg/registry/rbac/validation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/auth/authorizer/rbac/bootstrappolicy"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// semanticRoles is a few enumerated roles for which the relationships are well established
0000000000000000000000000000000000000000;;	// and we want to maintain symmetric roles
0000000000000000000000000000000000000000;;	type semanticRoles struct {
0000000000000000000000000000000000000000;;		admin *rbac.ClusterRole
0000000000000000000000000000000000000000;;		edit  *rbac.ClusterRole
0000000000000000000000000000000000000000;;		view  *rbac.ClusterRole
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSemanticRoles(roles []rbac.ClusterRole) semanticRoles {
0000000000000000000000000000000000000000;;		ret := semanticRoles{}
0000000000000000000000000000000000000000;;		for i := range roles {
0000000000000000000000000000000000000000;;			role := roles[i]
0000000000000000000000000000000000000000;;			switch role.Name {
0000000000000000000000000000000000000000;;			case "admin":
0000000000000000000000000000000000000000;;				ret.admin = &role
0000000000000000000000000000000000000000;;			case "edit":
0000000000000000000000000000000000000000;;				ret.edit = &role
0000000000000000000000000000000000000000;;			case "view":
0000000000000000000000000000000000000000;;				ret.view = &role
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Some roles should always cover others
0000000000000000000000000000000000000000;;	func TestCovers(t *testing.T) {
0000000000000000000000000000000000000000;;		semanticRoles := getSemanticRoles(bootstrappolicy.ClusterRoles())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if covers, miss := rbacregistryvalidation.Covers(semanticRoles.admin.Rules, semanticRoles.edit.Rules); !covers {
0000000000000000000000000000000000000000;;			t.Errorf("failed to cover: %#v", miss)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if covers, miss := rbacregistryvalidation.Covers(semanticRoles.admin.Rules, semanticRoles.view.Rules); !covers {
0000000000000000000000000000000000000000;;			t.Errorf("failed to cover: %#v", miss)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if covers, miss := rbacregistryvalidation.Covers(semanticRoles.edit.Rules, semanticRoles.view.Rules); !covers {
0000000000000000000000000000000000000000;;			t.Errorf("failed to cover: %#v", miss)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// additionalAdminPowers is the list of powers that we expect to be different than the editor role.
0000000000000000000000000000000000000000;;	// one resource per rule to make the "does not already contain" check easy
0000000000000000000000000000000000000000;;	var additionalAdminPowers = []rbac.PolicyRule{
0000000000000000000000000000000000000000;;		rbac.NewRule("create").Groups("authorization.k8s.io").Resources("localsubjectaccessreviews").RuleOrDie(),
0000000000000000000000000000000000000000;;		rbac.NewRule(bootstrappolicy.ReadWrite...).Groups("rbac.authorization.k8s.io").Resources("rolebindings").RuleOrDie(),
0000000000000000000000000000000000000000;;		rbac.NewRule(bootstrappolicy.ReadWrite...).Groups("rbac.authorization.k8s.io").Resources("roles").RuleOrDie(),
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdminEditRelationship(t *testing.T) {
0000000000000000000000000000000000000000;;		semanticRoles := getSemanticRoles(bootstrappolicy.ClusterRoles())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// confirm that the edit role doesn't already have extra powers
0000000000000000000000000000000000000000;;		for _, rule := range additionalAdminPowers {
0000000000000000000000000000000000000000;;			if covers, _ := rbacregistryvalidation.Covers(semanticRoles.edit.Rules, []rbac.PolicyRule{rule}); covers {
0000000000000000000000000000000000000000;;				t.Errorf("edit has extra powers: %#v", rule)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		semanticRoles.edit.Rules = append(semanticRoles.edit.Rules, additionalAdminPowers...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// at this point, we should have a two way covers relationship
0000000000000000000000000000000000000000;;		if covers, miss := rbacregistryvalidation.Covers(semanticRoles.admin.Rules, semanticRoles.edit.Rules); !covers {
0000000000000000000000000000000000000000;;			t.Errorf("admin has lost rules for: %#v", miss)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if covers, miss := rbacregistryvalidation.Covers(semanticRoles.edit.Rules, semanticRoles.admin.Rules); !covers {
0000000000000000000000000000000000000000;;			t.Errorf("edit is missing rules for: %#v\nIf these should only be admin powers, add them to the list.  Otherwise, add them to the edit role.", miss)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// viewEscalatingNamespaceResources is the list of rules that would allow privilege escalation attacks based on
0000000000000000000000000000000000000000;;	// ability to view (GET) them
0000000000000000000000000000000000000000;;	var viewEscalatingNamespaceResources = []rbac.PolicyRule{
0000000000000000000000000000000000000000;;		rbac.NewRule(bootstrappolicy.Read...).Groups("").Resources("pods/attach").RuleOrDie(),
0000000000000000000000000000000000000000;;		rbac.NewRule(bootstrappolicy.Read...).Groups("").Resources("pods/proxy").RuleOrDie(),
0000000000000000000000000000000000000000;;		rbac.NewRule(bootstrappolicy.Read...).Groups("").Resources("pods/exec").RuleOrDie(),
0000000000000000000000000000000000000000;;		rbac.NewRule(bootstrappolicy.Read...).Groups("").Resources("pods/portforward").RuleOrDie(),
0000000000000000000000000000000000000000;;		rbac.NewRule(bootstrappolicy.Read...).Groups("").Resources("secrets").RuleOrDie(),
0000000000000000000000000000000000000000;;		rbac.NewRule(bootstrappolicy.Read...).Groups("").Resources("services/proxy").RuleOrDie(),
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ungettableResources is the list of rules that don't allow to view (GET) them
0000000000000000000000000000000000000000;;	// this is purposefully separate list to distinguish from escalating privs
0000000000000000000000000000000000000000;;	var ungettableResources = []rbac.PolicyRule{
0000000000000000000000000000000000000000;;		rbac.NewRule(bootstrappolicy.Read...).Groups("apps", "extensions").Resources("deployments/rollback").RuleOrDie(),
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEditViewRelationship(t *testing.T) {
0000000000000000000000000000000000000000;;		readVerbs := sets.NewString(bootstrappolicy.Read...)
0000000000000000000000000000000000000000;;		semanticRoles := getSemanticRoles(bootstrappolicy.ClusterRoles())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// modify the edit role rules to make then read-only for comparison against view role rules
0000000000000000000000000000000000000000;;		for i := range semanticRoles.edit.Rules {
0000000000000000000000000000000000000000;;			rule := semanticRoles.edit.Rules[i]
0000000000000000000000000000000000000000;;			remainingVerbs := []string{}
0000000000000000000000000000000000000000;;			for _, verb := range rule.Verbs {
0000000000000000000000000000000000000000;;				if readVerbs.Has(verb) {
0000000000000000000000000000000000000000;;					remainingVerbs = append(remainingVerbs, verb)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rule.Verbs = remainingVerbs
0000000000000000000000000000000000000000;;			semanticRoles.edit.Rules[i] = rule
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// confirm that the view role doesn't already have extra powers
0000000000000000000000000000000000000000;;		for _, rule := range viewEscalatingNamespaceResources {
0000000000000000000000000000000000000000;;			if covers, _ := rbacregistryvalidation.Covers(semanticRoles.view.Rules, []rbac.PolicyRule{rule}); covers {
0000000000000000000000000000000000000000;;				t.Errorf("view has extra powers: %#v", rule)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		semanticRoles.view.Rules = append(semanticRoles.view.Rules, viewEscalatingNamespaceResources...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// confirm that the view role doesn't have ungettable resources
0000000000000000000000000000000000000000;;		for _, rule := range ungettableResources {
0000000000000000000000000000000000000000;;			if covers, _ := rbacregistryvalidation.Covers(semanticRoles.view.Rules, []rbac.PolicyRule{rule}); covers {
0000000000000000000000000000000000000000;;				t.Errorf("view has ungettable resource: %#v", rule)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		semanticRoles.view.Rules = append(semanticRoles.view.Rules, ungettableResources...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// at this point, we should have a two way covers relationship
0000000000000000000000000000000000000000;;		if covers, miss := rbacregistryvalidation.Covers(semanticRoles.edit.Rules, semanticRoles.view.Rules); !covers {
0000000000000000000000000000000000000000;;			t.Errorf("edit has lost rules for: %#v", miss)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if covers, miss := rbacregistryvalidation.Covers(semanticRoles.view.Rules, semanticRoles.edit.Rules); !covers {
0000000000000000000000000000000000000000;;			t.Errorf("view is missing rules for: %#v\nIf these are escalating powers, add them to the list.  Otherwise, add them to the view role.", miss)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBootstrapNamespaceRoles(t *testing.T) {
0000000000000000000000000000000000000000;;		list := &api.List{}
0000000000000000000000000000000000000000;;		names := sets.NewString()
0000000000000000000000000000000000000000;;		roles := map[string]runtime.Object{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespaceRoles := bootstrappolicy.NamespaceRoles()
0000000000000000000000000000000000000000;;		for _, namespace := range sets.StringKeySet(namespaceRoles).List() {
0000000000000000000000000000000000000000;;			bootstrapRoles := namespaceRoles[namespace]
0000000000000000000000000000000000000000;;			for i := range bootstrapRoles {
0000000000000000000000000000000000000000;;				role := bootstrapRoles[i]
0000000000000000000000000000000000000000;;				names.Insert(role.Name)
0000000000000000000000000000000000000000;;				roles[role.Name] = &role
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, name := range names.List() {
0000000000000000000000000000000000000000;;				list.Items = append(list.Items, roles[name])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testObjects(t, list, "namespace-roles.yaml")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBootstrapNamespaceRoleBindings(t *testing.T) {
0000000000000000000000000000000000000000;;		list := &api.List{}
0000000000000000000000000000000000000000;;		names := sets.NewString()
0000000000000000000000000000000000000000;;		roleBindings := map[string]runtime.Object{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespaceRoleBindings := bootstrappolicy.NamespaceRoleBindings()
0000000000000000000000000000000000000000;;		for _, namespace := range sets.StringKeySet(namespaceRoleBindings).List() {
0000000000000000000000000000000000000000;;			bootstrapRoleBindings := namespaceRoleBindings[namespace]
0000000000000000000000000000000000000000;;			for i := range bootstrapRoleBindings {
0000000000000000000000000000000000000000;;				roleBinding := bootstrapRoleBindings[i]
0000000000000000000000000000000000000000;;				names.Insert(roleBinding.Name)
0000000000000000000000000000000000000000;;				roleBindings[roleBinding.Name] = &roleBinding
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, name := range names.List() {
0000000000000000000000000000000000000000;;				list.Items = append(list.Items, roleBindings[name])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testObjects(t, list, "namespace-role-bindings.yaml")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBootstrapClusterRoles(t *testing.T) {
0000000000000000000000000000000000000000;;		list := &api.List{}
0000000000000000000000000000000000000000;;		names := sets.NewString()
0000000000000000000000000000000000000000;;		roles := map[string]runtime.Object{}
0000000000000000000000000000000000000000;;		bootstrapRoles := bootstrappolicy.ClusterRoles()
0000000000000000000000000000000000000000;;		for i := range bootstrapRoles {
0000000000000000000000000000000000000000;;			role := bootstrapRoles[i]
0000000000000000000000000000000000000000;;			names.Insert(role.Name)
0000000000000000000000000000000000000000;;			roles[role.Name] = &role
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, name := range names.List() {
0000000000000000000000000000000000000000;;			list.Items = append(list.Items, roles[name])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testObjects(t, list, "cluster-roles.yaml")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBootstrapClusterRoleBindings(t *testing.T) {
0000000000000000000000000000000000000000;;		list := &api.List{}
0000000000000000000000000000000000000000;;		names := sets.NewString()
0000000000000000000000000000000000000000;;		roleBindings := map[string]runtime.Object{}
0000000000000000000000000000000000000000;;		bootstrapRoleBindings := bootstrappolicy.ClusterRoleBindings()
0000000000000000000000000000000000000000;;		for i := range bootstrapRoleBindings {
0000000000000000000000000000000000000000;;			role := bootstrapRoleBindings[i]
0000000000000000000000000000000000000000;;			names.Insert(role.Name)
0000000000000000000000000000000000000000;;			roleBindings[role.Name] = &role
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, name := range names.List() {
0000000000000000000000000000000000000000;;			list.Items = append(list.Items, roleBindings[name])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testObjects(t, list, "cluster-role-bindings.yaml")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBootstrapControllerRoles(t *testing.T) {
0000000000000000000000000000000000000000;;		list := &api.List{}
0000000000000000000000000000000000000000;;		names := sets.NewString()
0000000000000000000000000000000000000000;;		roles := map[string]runtime.Object{}
0000000000000000000000000000000000000000;;		bootstrapRoles := bootstrappolicy.ControllerRoles()
0000000000000000000000000000000000000000;;		for i := range bootstrapRoles {
0000000000000000000000000000000000000000;;			role := bootstrapRoles[i]
0000000000000000000000000000000000000000;;			names.Insert(role.Name)
0000000000000000000000000000000000000000;;			roles[role.Name] = &role
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, name := range names.List() {
0000000000000000000000000000000000000000;;			list.Items = append(list.Items, roles[name])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testObjects(t, list, "controller-roles.yaml")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBootstrapControllerRoleBindings(t *testing.T) {
0000000000000000000000000000000000000000;;		list := &api.List{}
0000000000000000000000000000000000000000;;		names := sets.NewString()
0000000000000000000000000000000000000000;;		roleBindings := map[string]runtime.Object{}
0000000000000000000000000000000000000000;;		bootstrapRoleBindings := bootstrappolicy.ControllerRoleBindings()
0000000000000000000000000000000000000000;;		for i := range bootstrapRoleBindings {
0000000000000000000000000000000000000000;;			roleBinding := bootstrapRoleBindings[i]
0000000000000000000000000000000000000000;;			names.Insert(roleBinding.Name)
0000000000000000000000000000000000000000;;			roleBindings[roleBinding.Name] = &roleBinding
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, name := range names.List() {
0000000000000000000000000000000000000000;;			list.Items = append(list.Items, roleBindings[name])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testObjects(t, list, "controller-role-bindings.yaml")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testObjects(t *testing.T, list *api.List, fixtureFilename string) {
0000000000000000000000000000000000000000;;		filename := filepath.Join("testdata", fixtureFilename)
0000000000000000000000000000000000000000;;		expectedYAML, err := ioutil.ReadFile(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := runtime.EncodeList(api.Codecs.LegacyCodec(v1.SchemeGroupVersion, rbacv1beta1.SchemeGroupVersion), list.Items); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jsonData, err := runtime.Encode(api.Codecs.LegacyCodec(v1.SchemeGroupVersion, rbacv1beta1.SchemeGroupVersion), list)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		yamlData, err := yaml.JSONToYAML(jsonData)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if string(yamlData) != string(expectedYAML) {
0000000000000000000000000000000000000000;;			t.Errorf("Bootstrap policy data does not match the test fixture in %s", filename)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			const updateEnvVar = "UPDATE_BOOTSTRAP_POLICY_FIXTURE_DATA"
0000000000000000000000000000000000000000;;			if os.Getenv(updateEnvVar) == "true" {
0000000000000000000000000000000000000000;;				if err := ioutil.WriteFile(filename, []byte(yamlData), os.FileMode(0755)); err == nil {
0000000000000000000000000000000000000000;;					t.Logf("Updated data in %s", filename)
0000000000000000000000000000000000000000;;					t.Logf("Verify the diff, commit changes, and rerun the tests")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					t.Logf("Could not update data in %s: %v", filename, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				t.Logf("Diff between bootstrap data and fixture data in %s:\n-------------\n%s", filename, diff.StringDiff(string(yamlData), string(expectedYAML)))
0000000000000000000000000000000000000000;;				t.Logf("If the change is expected, re-run with %s=true to update the fixtures", updateEnvVar)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestClusterRoleLabel(t *testing.T) {
0000000000000000000000000000000000000000;;		roles := bootstrappolicy.ClusterRoles()
0000000000000000000000000000000000000000;;		for i := range roles {
0000000000000000000000000000000000000000;;			role := roles[i]
0000000000000000000000000000000000000000;;			accessor, err := meta.Accessor(&role)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if got, want := accessor.GetLabels(), map[string]string{"kubernetes.io/bootstrapping": "rbac-defaults"}; !reflect.DeepEqual(got, want) {
0000000000000000000000000000000000000000;;				t.Errorf("ClusterRole: %s GetLabels() = %s, want %s", accessor.GetName(), got, want)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rolebindings := bootstrappolicy.ClusterRoleBindings()
0000000000000000000000000000000000000000;;		for i := range rolebindings {
0000000000000000000000000000000000000000;;			rolebinding := rolebindings[i]
0000000000000000000000000000000000000000;;			accessor, err := meta.Accessor(&rolebinding)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if got, want := accessor.GetLabels(), map[string]string{"kubernetes.io/bootstrapping": "rbac-defaults"}; !reflect.DeepEqual(got, want) {
0000000000000000000000000000000000000000;;				t.Errorf("ClusterRoleBinding: %s GetLabels() = %s, want %s", accessor.GetName(), got, want)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
