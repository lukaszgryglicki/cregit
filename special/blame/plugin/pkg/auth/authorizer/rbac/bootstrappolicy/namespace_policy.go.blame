0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
70846e6e95eae98b99d526e6441a152d4bc7917e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package bootstrappolicy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		rbac "k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// namespaceRoles is a map of namespace to slice of roles to create
0000000000000000000000000000000000000000;;		namespaceRoles = map[string][]rbac.Role{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// namespaceRoleBindings is a map of namespace to slice of roleBindings to create
0000000000000000000000000000000000000000;;		namespaceRoleBindings = map[string][]rbac.RoleBinding{}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addNamespaceRole(namespace string, role rbac.Role) {
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(namespace, "kube-") {
0000000000000000000000000000000000000000;;			glog.Fatalf(`roles can only be bootstrapped into reserved namespaces starting with "kube-", not %q`, namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existingRoles := namespaceRoles[namespace]
0000000000000000000000000000000000000000;;		for _, existingRole := range existingRoles {
0000000000000000000000000000000000000000;;			if role.Name == existingRole.Name {
0000000000000000000000000000000000000000;;				glog.Fatalf("role %q was already registered in %q", role.Name, namespace)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		role.Namespace = namespace
0000000000000000000000000000000000000000;;		addDefaultMetadata(&role)
0000000000000000000000000000000000000000;;		existingRoles = append(existingRoles, role)
0000000000000000000000000000000000000000;;		namespaceRoles[namespace] = existingRoles
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addNamespaceRoleBinding(namespace string, roleBinding rbac.RoleBinding) {
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(namespace, "kube-") {
0000000000000000000000000000000000000000;;			glog.Fatalf(`roles can only be bootstrapped into reserved namespaces starting with "kube-", not %q`, namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existingRoleBindings := namespaceRoleBindings[namespace]
0000000000000000000000000000000000000000;;		for _, existingRoleBinding := range existingRoleBindings {
0000000000000000000000000000000000000000;;			if roleBinding.Name == existingRoleBinding.Name {
0000000000000000000000000000000000000000;;				glog.Fatalf("rolebinding %q was already registered in %q", roleBinding.Name, namespace)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		roleBinding.Namespace = namespace
0000000000000000000000000000000000000000;;		addDefaultMetadata(&roleBinding)
0000000000000000000000000000000000000000;;		existingRoleBindings = append(existingRoleBindings, roleBinding)
0000000000000000000000000000000000000000;;		namespaceRoleBindings[namespace] = existingRoleBindings
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		addNamespaceRole(metav1.NamespaceSystem, rbac.Role{
0000000000000000000000000000000000000000;;			// role for finding authentication config info for starting a server
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "extension-apiserver-authentication-reader"},
0000000000000000000000000000000000000000;;			Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;				// this particular config map is exposed and contains authentication configuration information
0000000000000000000000000000000000000000;;				rbac.NewRule("get").Groups(legacyGroup).Resources("configmaps").Names("extension-apiserver-authentication").RuleOrDie(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		addNamespaceRole(metav1.NamespaceSystem, rbac.Role{
0000000000000000000000000000000000000000;;			// role for the bootstrap signer to be able to inspect kube-system secrets
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: saRolePrefix + "bootstrap-signer"},
0000000000000000000000000000000000000000;;			Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;				rbac.NewRule("get", "list", "watch").Groups(legacyGroup).Resources("secrets").RuleOrDie(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		addNamespaceRole(metav1.NamespaceSystem, rbac.Role{
0000000000000000000000000000000000000000;;			// role for the cloud providers to access/create kube-system configmaps
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: saRolePrefix + "cloud-provider"},
0000000000000000000000000000000000000000;;			Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;				rbac.NewRule("create", "get", "list", "watch").Groups(legacyGroup).Resources("configmaps").RuleOrDie(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		addNamespaceRole(metav1.NamespaceSystem, rbac.Role{
0000000000000000000000000000000000000000;;			// role for the token-cleaner to be able to remove secrets, but only in kube-system
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: saRolePrefix + "token-cleaner"},
0000000000000000000000000000000000000000;;			Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;				rbac.NewRule("get", "list", "watch", "delete").Groups(legacyGroup).Resources("secrets").RuleOrDie(),
0000000000000000000000000000000000000000;;				eventsRule(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		// TODO: Create util on Role+Binding for leader locking if more cases evolve.
0000000000000000000000000000000000000000;;		addNamespaceRole(metav1.NamespaceSystem, rbac.Role{
0000000000000000000000000000000000000000;;			// role for the leader locking on supplied configmap
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "system::leader-locking-kube-controller-manager"},
0000000000000000000000000000000000000000;;			Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;				rbac.NewRule("watch").Groups(legacyGroup).Resources("configmaps").RuleOrDie(),
0000000000000000000000000000000000000000;;				rbac.NewRule("get", "update").Groups(legacyGroup).Resources("configmaps").Names("kube-controller-manager").RuleOrDie(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		addNamespaceRole(metav1.NamespaceSystem, rbac.Role{
0000000000000000000000000000000000000000;;			// role for the leader locking on supplied configmap
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "system::leader-locking-kube-scheduler"},
0000000000000000000000000000000000000000;;			Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;				rbac.NewRule("watch").Groups(legacyGroup).Resources("configmaps").RuleOrDie(),
0000000000000000000000000000000000000000;;				rbac.NewRule("get", "update").Groups(legacyGroup).Resources("configmaps").Names("kube-scheduler").RuleOrDie(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		addNamespaceRoleBinding(metav1.NamespaceSystem,
0000000000000000000000000000000000000000;;			rbac.NewRoleBinding("system::leader-locking-kube-controller-manager", metav1.NamespaceSystem).SAs(metav1.NamespaceSystem, "kube-controller-manager").BindingOrDie())
0000000000000000000000000000000000000000;;		addNamespaceRoleBinding(metav1.NamespaceSystem,
0000000000000000000000000000000000000000;;			rbac.NewRoleBinding("system::leader-locking-kube-scheduler", metav1.NamespaceSystem).SAs(metav1.NamespaceSystem, "kube-scheduler").BindingOrDie())
0000000000000000000000000000000000000000;;		addNamespaceRoleBinding(metav1.NamespaceSystem,
0000000000000000000000000000000000000000;;			rbac.NewRoleBinding(saRolePrefix+"bootstrap-signer", metav1.NamespaceSystem).SAs(metav1.NamespaceSystem, "bootstrap-signer").BindingOrDie())
0000000000000000000000000000000000000000;;		addNamespaceRoleBinding(metav1.NamespaceSystem,
0000000000000000000000000000000000000000;;			rbac.NewRoleBinding(saRolePrefix+"cloud-provider", metav1.NamespaceSystem).SAs(metav1.NamespaceSystem, "cloud-provider").BindingOrDie())
0000000000000000000000000000000000000000;;		addNamespaceRoleBinding(metav1.NamespaceSystem,
0000000000000000000000000000000000000000;;			rbac.NewRoleBinding(saRolePrefix+"token-cleaner", metav1.NamespaceSystem).SAs(metav1.NamespaceSystem, "token-cleaner").BindingOrDie())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addNamespaceRole(metav1.NamespacePublic, rbac.Role{
0000000000000000000000000000000000000000;;			// role for the bootstrap signer to be able to write its configmap
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: saRolePrefix + "bootstrap-signer"},
0000000000000000000000000000000000000000;;			Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;				rbac.NewRule("get", "list", "watch").Groups(legacyGroup).Resources("configmaps").RuleOrDie(),
0000000000000000000000000000000000000000;;				rbac.NewRule("update").Groups(legacyGroup).Resources("configmaps").Names("cluster-info").RuleOrDie(),
0000000000000000000000000000000000000000;;				eventsRule(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		addNamespaceRoleBinding(metav1.NamespacePublic,
0000000000000000000000000000000000000000;;			rbac.NewRoleBinding(saRolePrefix+"bootstrap-signer", metav1.NamespacePublic).SAs(metav1.NamespaceSystem, "bootstrap-signer").BindingOrDie())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceRoles returns a map of namespace to slice of roles to create
0000000000000000000000000000000000000000;;	func NamespaceRoles() map[string][]rbac.Role {
0000000000000000000000000000000000000000;;		return namespaceRoles
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceRoleBindings returns a map of namespace to slice of roles to create
0000000000000000000000000000000000000000;;	func NamespaceRoleBindings() map[string][]rbac.RoleBinding {
0000000000000000000000000000000000000000;;		return namespaceRoleBindings
0000000000000000000000000000000000000000;;	}
