0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
7802b316946edff8d0d6e776538711453d5478fe;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package bootstrappolicy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		rbac "k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ReadWrite = []string{"get", "list", "watch", "create", "update", "patch", "delete", "deletecollection"}
0000000000000000000000000000000000000000;;		Read      = []string{"get", "list", "watch"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Label      = map[string]string{"kubernetes.io/bootstrapping": "rbac-defaults"}
0000000000000000000000000000000000000000;;		Annotation = map[string]string{rbac.AutoUpdateAnnotationKey: "true"}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		legacyGroup         = ""
0000000000000000000000000000000000000000;;		appsGroup           = "apps"
0000000000000000000000000000000000000000;;		authenticationGroup = "authentication.k8s.io"
0000000000000000000000000000000000000000;;		authorizationGroup  = "authorization.k8s.io"
0000000000000000000000000000000000000000;;		autoscalingGroup    = "autoscaling"
0000000000000000000000000000000000000000;;		batchGroup          = "batch"
0000000000000000000000000000000000000000;;		certificatesGroup   = "certificates.k8s.io"
0000000000000000000000000000000000000000;;		extensionsGroup     = "extensions"
0000000000000000000000000000000000000000;;		policyGroup         = "policy"
0000000000000000000000000000000000000000;;		rbacGroup           = "rbac.authorization.k8s.io"
0000000000000000000000000000000000000000;;		storageGroup        = "storage.k8s.io"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addDefaultMetadata(obj runtime.Object) {
0000000000000000000000000000000000000000;;		metadata, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// if this happens, then some static code is broken
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labels := metadata.GetLabels()
0000000000000000000000000000000000000000;;		if labels == nil {
0000000000000000000000000000000000000000;;			labels = map[string]string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range Label {
0000000000000000000000000000000000000000;;			labels[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metadata.SetLabels(labels)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		annotations := metadata.GetAnnotations()
0000000000000000000000000000000000000000;;		if annotations == nil {
0000000000000000000000000000000000000000;;			annotations = map[string]string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range Annotation {
0000000000000000000000000000000000000000;;			annotations[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metadata.SetAnnotations(annotations)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addClusterRoleLabel(roles []rbac.ClusterRole) {
0000000000000000000000000000000000000000;;		for i := range roles {
0000000000000000000000000000000000000000;;			addDefaultMetadata(&roles[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addClusterRoleBindingLabel(rolebindings []rbac.ClusterRoleBinding) {
0000000000000000000000000000000000000000;;		for i := range rolebindings {
0000000000000000000000000000000000000000;;			addDefaultMetadata(&rolebindings[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NodeRules() []rbac.PolicyRule {
0000000000000000000000000000000000000000;;		return []rbac.PolicyRule{
0000000000000000000000000000000000000000;;			// Needed to check API access.  These creates are non-mutating
0000000000000000000000000000000000000000;;			rbac.NewRule("create").Groups(authenticationGroup).Resources("tokenreviews").RuleOrDie(),
0000000000000000000000000000000000000000;;			rbac.NewRule("create").Groups(authorizationGroup).Resources("subjectaccessreviews", "localsubjectaccessreviews").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Needed to build serviceLister, to populate env vars for services
0000000000000000000000000000000000000000;;			rbac.NewRule(Read...).Groups(legacyGroup).Resources("services").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Nodes can register Node API objects and report status.
0000000000000000000000000000000000000000;;			// Use the NodeRestriction admission plugin to limit a node to creating/updating its own API object.
0000000000000000000000000000000000000000;;			rbac.NewRule("create", "get", "list", "watch").Groups(legacyGroup).Resources("nodes").RuleOrDie(),
0000000000000000000000000000000000000000;;			rbac.NewRule("update", "patch").Groups(legacyGroup).Resources("nodes/status").RuleOrDie(),
0000000000000000000000000000000000000000;;			rbac.NewRule("update", "patch", "delete").Groups(legacyGroup).Resources("nodes").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: restrict to the bound node as creator in the NodeRestrictions admission plugin
0000000000000000000000000000000000000000;;			rbac.NewRule("create", "update", "patch").Groups(legacyGroup).Resources("events").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: restrict to pods scheduled on the bound node once field selectors are supported by list/watch authorization
0000000000000000000000000000000000000000;;			rbac.NewRule(Read...).Groups(legacyGroup).Resources("pods").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Needed for the node to create/delete mirror pods.
0000000000000000000000000000000000000000;;			// Use the NodeRestriction admission plugin to limit a node to creating/deleting mirror pods bound to itself.
0000000000000000000000000000000000000000;;			rbac.NewRule("create", "delete").Groups(legacyGroup).Resources("pods").RuleOrDie(),
0000000000000000000000000000000000000000;;			// Needed for the node to report status of pods it is running.
0000000000000000000000000000000000000000;;			// Use the NodeRestriction admission plugin to limit a node to updating status of pods bound to itself.
0000000000000000000000000000000000000000;;			rbac.NewRule("update").Groups(legacyGroup).Resources("pods/status").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Needed for imagepullsecrets, rbd/ceph and secret volumes, and secrets in envs
0000000000000000000000000000000000000000;;			// Needed for configmap volume and envs
0000000000000000000000000000000000000000;;			// Use the NodeRestriction admission plugin to limit a node to get secrets/configmaps referenced by pods bound to itself.
0000000000000000000000000000000000000000;;			rbac.NewRule("get").Groups(legacyGroup).Resources("secrets", "configmaps").RuleOrDie(),
0000000000000000000000000000000000000000;;			// Needed for persistent volumes
0000000000000000000000000000000000000000;;			// Use the NodeRestriction admission plugin to limit a node to get pv/pvc objects referenced by pods bound to itself.
0000000000000000000000000000000000000000;;			rbac.NewRule("get").Groups(legacyGroup).Resources("persistentvolumeclaims", "persistentvolumes").RuleOrDie(),
0000000000000000000000000000000000000000;;			// TODO: add to the Node authorizer and restrict to endpoints referenced by pods or PVs bound to the node
0000000000000000000000000000000000000000;;			// Needed for glusterfs volumes
0000000000000000000000000000000000000000;;			rbac.NewRule("get").Groups(legacyGroup).Resources("endpoints").RuleOrDie(),
0000000000000000000000000000000000000000;;			// Used to create a certificatesigningrequest for a node-specific client certificate, and watch
0000000000000000000000000000000000000000;;			// for it to be signed. This allows the kubelet to rotate it's own certificate.
0000000000000000000000000000000000000000;;			rbac.NewRule("create", "get", "list", "watch").Groups(certificatesGroup).Resources("certificatesigningrequests").RuleOrDie(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClusterRoles returns the cluster roles to bootstrap an API server with
0000000000000000000000000000000000000000;;	func ClusterRoles() []rbac.ClusterRole {
0000000000000000000000000000000000000000;;		roles := []rbac.ClusterRole{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// a "root" role which can do absolutely anything
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "cluster-admin"},
0000000000000000000000000000000000000000;;				Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;					rbac.NewRule("*").Groups("*").Resources("*").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule("*").URLs("*").RuleOrDie(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// a role which provides just enough power to determine if the server is ready and discover API versions for negotiation
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "system:discovery"},
0000000000000000000000000000000000000000;;				Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;					rbac.NewRule("get").URLs("/healthz", "/version", "/swaggerapi", "/swaggerapi/*", "/api", "/api/*", "/apis", "/apis/*").RuleOrDie(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// a role which provides minimal resource access to allow a "normal" user to learn information about themselves
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "system:basic-user"},
0000000000000000000000000000000000000000;;				Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;					// TODO add future selfsubjectrulesreview, project request APIs, project listing APIs
0000000000000000000000000000000000000000;;					rbac.NewRule("create").Groups(authorizationGroup).Resources("selfsubjectaccessreviews").RuleOrDie(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// a role for a namespace level admin.  It is `edit` plus the power to grant permissions to other users.
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "admin"},
0000000000000000000000000000000000000000;;				Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;					rbac.NewRule(ReadWrite...).Groups(legacyGroup).Resources("pods", "pods/attach", "pods/proxy", "pods/exec", "pods/portforward").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule(ReadWrite...).Groups(legacyGroup).Resources("replicationcontrollers", "replicationcontrollers/scale", "serviceaccounts",
0000000000000000000000000000000000000000;;						"services", "services/proxy", "endpoints", "persistentvolumeclaims", "configmaps", "secrets").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule(Read...).Groups(legacyGroup).Resources("limitranges", "resourcequotas", "bindings", "events",
0000000000000000000000000000000000000000;;						"pods/status", "resourcequotas/status", "namespaces/status", "replicationcontrollers/status", "pods/log").RuleOrDie(),
0000000000000000000000000000000000000000;;					// read access to namespaces at the namespace scope means you can read *this* namespace.  This can be used as an
0000000000000000000000000000000000000000;;					// indicator of which namespaces you have access to.
0000000000000000000000000000000000000000;;					rbac.NewRule(Read...).Groups(legacyGroup).Resources("namespaces").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule("impersonate").Groups(legacyGroup).Resources("serviceaccounts").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					rbac.NewRule(ReadWrite...).Groups(appsGroup).Resources("statefulsets",
0000000000000000000000000000000000000000;;						"deployments", "deployments/scale", "deployments/rollback").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					rbac.NewRule(ReadWrite...).Groups(autoscalingGroup).Resources("horizontalpodautoscalers").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					rbac.NewRule(ReadWrite...).Groups(batchGroup).Resources("jobs", "cronjobs", "scheduledjobs").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					rbac.NewRule(ReadWrite...).Groups(extensionsGroup).Resources("daemonsets",
0000000000000000000000000000000000000000;;						"deployments", "deployments/scale", "deployments/rollback", "ingresses",
0000000000000000000000000000000000000000;;						"replicasets", "replicasets/scale", "replicationcontrollers/scale").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// additional admin powers
0000000000000000000000000000000000000000;;					rbac.NewRule("create").Groups(authorizationGroup).Resources("localsubjectaccessreviews").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule(ReadWrite...).Groups(rbacGroup).Resources("roles", "rolebindings").RuleOrDie(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// a role for a namespace level editor.  It grants access to all user level actions in a namespace.
0000000000000000000000000000000000000000;;				// It does not grant powers for "privileged" resources which are domain of the system: `/status`
0000000000000000000000000000000000000000;;				// subresources or `quota`/`limits` which are used to control namespaces
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "edit"},
0000000000000000000000000000000000000000;;				Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;					rbac.NewRule(ReadWrite...).Groups(legacyGroup).Resources("pods", "pods/attach", "pods/proxy", "pods/exec", "pods/portforward").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule(ReadWrite...).Groups(legacyGroup).Resources("replicationcontrollers", "replicationcontrollers/scale", "serviceaccounts",
0000000000000000000000000000000000000000;;						"services", "services/proxy", "endpoints", "persistentvolumeclaims", "configmaps", "secrets").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule(Read...).Groups(legacyGroup).Resources("limitranges", "resourcequotas", "bindings", "events",
0000000000000000000000000000000000000000;;						"pods/status", "resourcequotas/status", "namespaces/status", "replicationcontrollers/status", "pods/log").RuleOrDie(),
0000000000000000000000000000000000000000;;					// read access to namespaces at the namespace scope means you can read *this* namespace.  This can be used as an
0000000000000000000000000000000000000000;;					// indicator of which namespaces you have access to.
0000000000000000000000000000000000000000;;					rbac.NewRule(Read...).Groups(legacyGroup).Resources("namespaces").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule("impersonate").Groups(legacyGroup).Resources("serviceaccounts").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					rbac.NewRule(ReadWrite...).Groups(appsGroup).Resources("statefulsets",
0000000000000000000000000000000000000000;;						"deployments", "deployments/scale", "deployments/rollback").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					rbac.NewRule(ReadWrite...).Groups(autoscalingGroup).Resources("horizontalpodautoscalers").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					rbac.NewRule(ReadWrite...).Groups(batchGroup).Resources("jobs", "cronjobs", "scheduledjobs").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					rbac.NewRule(ReadWrite...).Groups(extensionsGroup).Resources("daemonsets",
0000000000000000000000000000000000000000;;						"deployments", "deployments/scale", "deployments/rollback", "ingresses",
0000000000000000000000000000000000000000;;						"replicasets", "replicasets/scale", "replicationcontrollers/scale").RuleOrDie(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// a role for namespace level viewing.  It grants Read-only access to non-escalating resources in
0000000000000000000000000000000000000000;;				// a namespace.
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "view"},
0000000000000000000000000000000000000000;;				Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;					rbac.NewRule(Read...).Groups(legacyGroup).Resources("pods", "replicationcontrollers", "replicationcontrollers/scale", "serviceaccounts",
0000000000000000000000000000000000000000;;						"services", "endpoints", "persistentvolumeclaims", "configmaps").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule(Read...).Groups(legacyGroup).Resources("limitranges", "resourcequotas", "bindings", "events",
0000000000000000000000000000000000000000;;						"pods/status", "resourcequotas/status", "namespaces/status", "replicationcontrollers/status", "pods/log").RuleOrDie(),
0000000000000000000000000000000000000000;;					// read access to namespaces at the namespace scope means you can read *this* namespace.  This can be used as an
0000000000000000000000000000000000000000;;					// indicator of which namespaces you have access to.
0000000000000000000000000000000000000000;;					rbac.NewRule(Read...).Groups(legacyGroup).Resources("namespaces").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					rbac.NewRule(Read...).Groups(appsGroup).Resources("statefulsets", "deployments", "deployments/scale").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					rbac.NewRule(Read...).Groups(autoscalingGroup).Resources("horizontalpodautoscalers").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					rbac.NewRule(Read...).Groups(batchGroup).Resources("jobs", "cronjobs", "scheduledjobs").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					rbac.NewRule(Read...).Groups(extensionsGroup).Resources("daemonsets", "deployments", "deployments/scale",
0000000000000000000000000000000000000000;;						"ingresses", "replicasets", "replicasets/scale", "replicationcontrollers/scale").RuleOrDie(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// a role to use for heapster's connections back to the API server
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "system:heapster"},
0000000000000000000000000000000000000000;;				Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;					rbac.NewRule(Read...).Groups(legacyGroup).Resources("events", "pods", "nodes", "namespaces").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule(Read...).Groups(extensionsGroup).Resources("deployments").RuleOrDie(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// a role for nodes to use to have the access they need for running pods
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "system:node"},
0000000000000000000000000000000000000000;;				Rules:      NodeRules(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// a role to use for node-problem-detector access.  It does not get bound to default location since
0000000000000000000000000000000000000000;;				// deployment locations can reasonably vary.
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "system:node-problem-detector"},
0000000000000000000000000000000000000000;;				Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;					rbac.NewRule("get").Groups(legacyGroup).Resources("nodes").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule("patch").Groups(legacyGroup).Resources("nodes/status").RuleOrDie(),
0000000000000000000000000000000000000000;;					eventsRule(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// a role to use for setting up a proxy
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "system:node-proxier"},
0000000000000000000000000000000000000000;;				Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;					// Used to build serviceLister
0000000000000000000000000000000000000000;;					rbac.NewRule("list", "watch").Groups(legacyGroup).Resources("services", "endpoints").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule("get").Groups(legacyGroup).Resources("nodes").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					eventsRule(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// a role to use for bootstrapping a node's client certificates
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "system:node-bootstrapper"},
0000000000000000000000000000000000000000;;				Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;					// used to create a certificatesigningrequest for a node-specific client certificate, and watch for it to be signed
0000000000000000000000000000000000000000;;					rbac.NewRule("create", "get", "list", "watch").Groups(certificatesGroup).Resources("certificatesigningrequests").RuleOrDie(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// a role to use for allowing authentication and authorization delegation
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "system:auth-delegator"},
0000000000000000000000000000000000000000;;				Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;					// These creates are non-mutating
0000000000000000000000000000000000000000;;					rbac.NewRule("create").Groups(authenticationGroup).Resources("tokenreviews").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule("create").Groups(authorizationGroup).Resources("subjectaccessreviews").RuleOrDie(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// a role to use for the API registry, summarization, and proxy handling
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "system:kube-aggregator"},
0000000000000000000000000000000000000000;;				Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;					// it needs to see all services so that it knows whether the ones it points to exist or not
0000000000000000000000000000000000000000;;					rbac.NewRule(Read...).Groups(legacyGroup).Resources("services", "endpoints").RuleOrDie(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// a role to use for bootstrapping the kube-controller-manager so it can create the shared informers
0000000000000000000000000000000000000000;;				// service accounts, and secrets that we need to create separate identities for other controllers
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "system:kube-controller-manager"},
0000000000000000000000000000000000000000;;				Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;					eventsRule(),
0000000000000000000000000000000000000000;;					rbac.NewRule("create").Groups(legacyGroup).Resources("endpoints", "secrets", "serviceaccounts").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule("delete").Groups(legacyGroup).Resources("secrets").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule("get").Groups(legacyGroup).Resources("endpoints", "namespaces", "secrets", "serviceaccounts").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule("update").Groups(legacyGroup).Resources("endpoints", "secrets", "serviceaccounts").RuleOrDie(),
0000000000000000000000000000000000000000;;					// Needed to check API access.  These creates are non-mutating
0000000000000000000000000000000000000000;;					rbac.NewRule("create").Groups(authenticationGroup).Resources("tokenreviews").RuleOrDie(),
0000000000000000000000000000000000000000;;					// Needed for all shared informers
0000000000000000000000000000000000000000;;					rbac.NewRule("list", "watch").Groups("*").Resources("*").RuleOrDie(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// a role to use for the kube-scheduler
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "system:kube-scheduler"},
0000000000000000000000000000000000000000;;				Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;					eventsRule(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// this is for leaderlease access
0000000000000000000000000000000000000000;;					// TODO: scope this to the kube-system namespace
0000000000000000000000000000000000000000;;					rbac.NewRule("create").Groups(legacyGroup).Resources("endpoints").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule("get", "update", "patch", "delete").Groups(legacyGroup).Resources("endpoints").Names("kube-scheduler").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// fundamental resources
0000000000000000000000000000000000000000;;					rbac.NewRule(Read...).Groups(legacyGroup).Resources("nodes", "pods").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule("create").Groups(legacyGroup).Resources("pods/binding", "bindings").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule("update").Groups(legacyGroup).Resources("pods/status").RuleOrDie(),
0000000000000000000000000000000000000000;;					// things that select pods
0000000000000000000000000000000000000000;;					rbac.NewRule(Read...).Groups(legacyGroup).Resources("services", "replicationcontrollers").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule(Read...).Groups(extensionsGroup).Resources("replicasets").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule(Read...).Groups(appsGroup).Resources("statefulsets").RuleOrDie(),
0000000000000000000000000000000000000000;;					// things that pods use
0000000000000000000000000000000000000000;;					rbac.NewRule(Read...).Groups(legacyGroup).Resources("persistentvolumeclaims", "persistentvolumes").RuleOrDie(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// a role to use for the kube-dns pod
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "system:kube-dns"},
0000000000000000000000000000000000000000;;				Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;					rbac.NewRule("list", "watch").Groups(legacyGroup).Resources("endpoints", "services").RuleOrDie(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// a role for an external/out-of-tree persistent volume provisioner
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "system:persistent-volume-provisioner"},
0000000000000000000000000000000000000000;;				Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;					rbac.NewRule("get", "list", "watch", "create", "delete").Groups(legacyGroup).Resources("persistentvolumes").RuleOrDie(),
0000000000000000000000000000000000000000;;					// update is needed in addition to read access for setting lock annotations on PVCs
0000000000000000000000000000000000000000;;					rbac.NewRule("get", "list", "watch", "update").Groups(legacyGroup).Resources("persistentvolumeclaims").RuleOrDie(),
0000000000000000000000000000000000000000;;					rbac.NewRule(Read...).Groups(storageGroup).Resources("storageclasses").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Needed for watching provisioning success and failure events
0000000000000000000000000000000000000000;;					rbac.NewRule("watch").Groups(legacyGroup).Resources("events").RuleOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					eventsRule(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		addClusterRoleLabel(roles)
0000000000000000000000000000000000000000;;		return roles
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClusterRoleBindingFilter can modify and return or omit (by returning nil) a role binding
0000000000000000000000000000000000000000;;	type ClusterRoleBindingFilter func(*rbac.ClusterRoleBinding) *rbac.ClusterRoleBinding
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddClusterRoleBindingFilter adds the given filter to the list that is invoked when determing bootstrap roles to reconcile.
0000000000000000000000000000000000000000;;	func AddClusterRoleBindingFilter(filter ClusterRoleBindingFilter) {
0000000000000000000000000000000000000000;;		clusterRoleBindingFilters = append(clusterRoleBindingFilters, filter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClearClusterRoleBindingFilters removes any filters added using AddClusterRoleBindingFilter
0000000000000000000000000000000000000000;;	func ClearClusterRoleBindingFilters() {
0000000000000000000000000000000000000000;;		clusterRoleBindingFilters = nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const systemNodeRoleName = "system:node"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var clusterRoleBindingFilters []ClusterRoleBindingFilter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OmitNodesGroupBinding is a filter that omits the deprecated binding for the system:nodes group to the system:node role.
0000000000000000000000000000000000000000;;	var OmitNodesGroupBinding = ClusterRoleBindingFilter(func(binding *rbac.ClusterRoleBinding) *rbac.ClusterRoleBinding {
0000000000000000000000000000000000000000;;		if binding.RoleRef.Name == systemNodeRoleName {
0000000000000000000000000000000000000000;;			subjects := []rbac.Subject{}
0000000000000000000000000000000000000000;;			for _, subject := range binding.Subjects {
0000000000000000000000000000000000000000;;				if subject.Kind == rbac.GroupKind && subject.Name == user.NodesGroup {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				subjects = append(subjects, subject)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			binding.Subjects = subjects
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return binding
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClusterRoleBindings return default rolebindings to the default roles
0000000000000000000000000000000000000000;;	func ClusterRoleBindings() []rbac.ClusterRoleBinding {
0000000000000000000000000000000000000000;;		rolebindings := []rbac.ClusterRoleBinding{
0000000000000000000000000000000000000000;;			rbac.NewClusterBinding("cluster-admin").Groups(user.SystemPrivilegedGroup).BindingOrDie(),
0000000000000000000000000000000000000000;;			rbac.NewClusterBinding("system:discovery").Groups(user.AllAuthenticated, user.AllUnauthenticated).BindingOrDie(),
0000000000000000000000000000000000000000;;			rbac.NewClusterBinding("system:basic-user").Groups(user.AllAuthenticated, user.AllUnauthenticated).BindingOrDie(),
0000000000000000000000000000000000000000;;			rbac.NewClusterBinding("system:node-proxier").Users(user.KubeProxy).BindingOrDie(),
0000000000000000000000000000000000000000;;			rbac.NewClusterBinding("system:kube-controller-manager").Users(user.KubeControllerManager).BindingOrDie(),
0000000000000000000000000000000000000000;;			rbac.NewClusterBinding("system:kube-dns").SAs("kube-system", "kube-dns").BindingOrDie(),
0000000000000000000000000000000000000000;;			rbac.NewClusterBinding("system:kube-scheduler").Users(user.KubeScheduler).BindingOrDie(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// This default system:nodes binding is deprecated in 1.7 with the availability of the Node authorizer.
0000000000000000000000000000000000000000;;			// If an admin wants to grant the system:node role (which cannot partition Node API access), they will need to create their own clusterrolebinding.
0000000000000000000000000000000000000000;;			// TODO: Remove the subjects from this binding in 1.8 (leave the empty binding for tightening reconciliation), and remove AddClusterRoleBindingFilter()
0000000000000000000000000000000000000000;;			rbac.NewClusterBinding(systemNodeRoleName).Groups(user.NodesGroup).BindingOrDie(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addClusterRoleBindingLabel(rolebindings)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		retval := []rbac.ClusterRoleBinding{}
0000000000000000000000000000000000000000;;		for i := range rolebindings {
0000000000000000000000000000000000000000;;			binding := &rolebindings[i]
0000000000000000000000000000000000000000;;			for _, filter := range clusterRoleBindingFilters {
0000000000000000000000000000000000000000;;				binding = filter(binding)
0000000000000000000000000000000000000000;;				if binding == nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if binding != nil {
0000000000000000000000000000000000000000;;				retval = append(retval, *binding)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return retval
0000000000000000000000000000000000000000;;	}
