0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2977f9c93c0ca7b949d0f599323149e5802ad6bc;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package rbac implements the authorizer.Authorizer interface using roles base access control.
0000000000000000000000000000000000000000;;	package rbac
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;		rbacregistryvalidation "k8s.io/kubernetes/pkg/registry/rbac/validation"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RequestToRuleMapper interface {
0000000000000000000000000000000000000000;;		// RulesFor returns all known PolicyRules and any errors that happened while locating those rules.
0000000000000000000000000000000000000000;;		// Any rule returned is still valid, since rules are deny by default.  If you can pass with the rules
0000000000000000000000000000000000000000;;		// supplied, you do not have to fail the request.  If you cannot, you should indicate the error along
0000000000000000000000000000000000000000;;		// with your denial.
0000000000000000000000000000000000000000;;		RulesFor(subject user.Info, namespace string) ([]rbac.PolicyRule, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// VisitRulesFor invokes visitor() with each rule that applies to a given user in a given namespace,
0000000000000000000000000000000000000000;;		// and each error encountered resolving those rules. Rule may be nil if err is non-nil.
0000000000000000000000000000000000000000;;		// If visitor() returns false, visiting is short-circuited.
0000000000000000000000000000000000000000;;		VisitRulesFor(user user.Info, namespace string, visitor func(rule *rbac.PolicyRule, err error) bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RBACAuthorizer struct {
0000000000000000000000000000000000000000;;		authorizationRuleResolver RequestToRuleMapper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// authorizingVisitor short-circuits once allowed, and collects any resolution errors encountered
0000000000000000000000000000000000000000;;	type authorizingVisitor struct {
0000000000000000000000000000000000000000;;		requestAttributes authorizer.Attributes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allowed bool
0000000000000000000000000000000000000000;;		errors  []error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *authorizingVisitor) visit(rule *rbac.PolicyRule, err error) bool {
0000000000000000000000000000000000000000;;		if rule != nil && RuleAllows(v.requestAttributes, rule) {
0000000000000000000000000000000000000000;;			v.allowed = true
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			v.errors = append(v.errors, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *RBACAuthorizer) Authorize(requestAttributes authorizer.Attributes) (bool, string, error) {
0000000000000000000000000000000000000000;;		ruleCheckingVisitor := &authorizingVisitor{requestAttributes: requestAttributes}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.authorizationRuleResolver.VisitRulesFor(requestAttributes.GetUser(), requestAttributes.GetNamespace(), ruleCheckingVisitor.visit)
0000000000000000000000000000000000000000;;		if ruleCheckingVisitor.allowed {
0000000000000000000000000000000000000000;;			return true, "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Build a detailed log of the denial.
0000000000000000000000000000000000000000;;		// Make the whole block conditional so we don't do a lot of string-building we won't use.
0000000000000000000000000000000000000000;;		if glog.V(2) {
0000000000000000000000000000000000000000;;			var operation string
0000000000000000000000000000000000000000;;			if requestAttributes.IsResourceRequest() {
0000000000000000000000000000000000000000;;				b := &bytes.Buffer{}
0000000000000000000000000000000000000000;;				b.WriteString(`"`)
0000000000000000000000000000000000000000;;				b.WriteString(requestAttributes.GetVerb())
0000000000000000000000000000000000000000;;				b.WriteString(`" resource "`)
0000000000000000000000000000000000000000;;				b.WriteString(requestAttributes.GetResource())
0000000000000000000000000000000000000000;;				if len(requestAttributes.GetAPIGroup()) > 0 {
0000000000000000000000000000000000000000;;					b.WriteString(`.`)
0000000000000000000000000000000000000000;;					b.WriteString(requestAttributes.GetAPIGroup())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(requestAttributes.GetSubresource()) > 0 {
0000000000000000000000000000000000000000;;					b.WriteString(`/`)
0000000000000000000000000000000000000000;;					b.WriteString(requestAttributes.GetSubresource())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b.WriteString(`"`)
0000000000000000000000000000000000000000;;				if len(requestAttributes.GetName()) > 0 {
0000000000000000000000000000000000000000;;					b.WriteString(` named "`)
0000000000000000000000000000000000000000;;					b.WriteString(requestAttributes.GetName())
0000000000000000000000000000000000000000;;					b.WriteString(`"`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				operation = b.String()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				operation = fmt.Sprintf("%q nonResourceURL %q", requestAttributes.GetVerb(), requestAttributes.GetPath())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var scope string
0000000000000000000000000000000000000000;;			if ns := requestAttributes.GetNamespace(); len(ns) > 0 {
0000000000000000000000000000000000000000;;				scope = fmt.Sprintf("in namespace %q", ns)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				scope = "cluster-wide"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.Infof("RBAC DENY: user %q groups %q cannot %s %s", requestAttributes.GetUser().GetName(), requestAttributes.GetUser().GetGroups(), operation, scope)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reason := ""
0000000000000000000000000000000000000000;;		if len(ruleCheckingVisitor.errors) > 0 {
0000000000000000000000000000000000000000;;			reason = fmt.Sprintf("%v", utilerrors.NewAggregate(ruleCheckingVisitor.errors))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, reason, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New(roles rbacregistryvalidation.RoleGetter, roleBindings rbacregistryvalidation.RoleBindingLister, clusterRoles rbacregistryvalidation.ClusterRoleGetter, clusterRoleBindings rbacregistryvalidation.ClusterRoleBindingLister) *RBACAuthorizer {
0000000000000000000000000000000000000000;;		authorizer := &RBACAuthorizer{
0000000000000000000000000000000000000000;;			authorizationRuleResolver: rbacregistryvalidation.NewDefaultRuleResolver(
0000000000000000000000000000000000000000;;				roles, roleBindings, clusterRoles, clusterRoleBindings,
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return authorizer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RulesAllow(requestAttributes authorizer.Attributes, rules ...rbac.PolicyRule) bool {
0000000000000000000000000000000000000000;;		for i := range rules {
0000000000000000000000000000000000000000;;			if RuleAllows(requestAttributes, &rules[i]) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RuleAllows(requestAttributes authorizer.Attributes, rule *rbac.PolicyRule) bool {
0000000000000000000000000000000000000000;;		if requestAttributes.IsResourceRequest() {
0000000000000000000000000000000000000000;;			resource := requestAttributes.GetResource()
0000000000000000000000000000000000000000;;			if len(requestAttributes.GetSubresource()) > 0 {
0000000000000000000000000000000000000000;;				resource = requestAttributes.GetResource() + "/" + requestAttributes.GetSubresource()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return rbac.VerbMatches(rule, requestAttributes.GetVerb()) &&
0000000000000000000000000000000000000000;;				rbac.APIGroupMatches(rule, requestAttributes.GetAPIGroup()) &&
0000000000000000000000000000000000000000;;				rbac.ResourceMatches(rule, resource) &&
0000000000000000000000000000000000000000;;				rbac.ResourceNameMatches(rule, requestAttributes.GetName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rbac.VerbMatches(rule, requestAttributes.GetVerb()) &&
0000000000000000000000000000000000000000;;			rbac.NonResourceURLMatches(rule, requestAttributes.GetPath())
0000000000000000000000000000000000000000;;	}
