0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
4e07c70b9e659ac375e092feca91223033da2829;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package rbac implements the authorizer.Authorizer interface using roles base access control.
0000000000000000000000000000000000000000;;	package rbac
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;		rbacregistryvalidation "k8s.io/kubernetes/pkg/registry/rbac/validation"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RoleToRuleMapper interface {
0000000000000000000000000000000000000000;;		// GetRoleReferenceRules attempts to resolve the role reference of a RoleBinding or ClusterRoleBinding.  The passed namespace should be the namespace
0000000000000000000000000000000000000000;;		// of the role binding, the empty string if a cluster role binding.
0000000000000000000000000000000000000000;;		GetRoleReferenceRules(roleRef rbac.RoleRef, namespace string) ([]rbac.PolicyRule, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SubjectAccessEvaluator struct {
0000000000000000000000000000000000000000;;		superUser string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		roleBindingLister        rbacregistryvalidation.RoleBindingLister
0000000000000000000000000000000000000000;;		clusterRoleBindingLister rbacregistryvalidation.ClusterRoleBindingLister
0000000000000000000000000000000000000000;;		roleToRuleMapper         RoleToRuleMapper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSubjectAccessEvaluator(roles rbacregistryvalidation.RoleGetter, roleBindings rbacregistryvalidation.RoleBindingLister, clusterRoles rbacregistryvalidation.ClusterRoleGetter, clusterRoleBindings rbacregistryvalidation.ClusterRoleBindingLister, superUser string) *SubjectAccessEvaluator {
0000000000000000000000000000000000000000;;		subjectLocator := &SubjectAccessEvaluator{
0000000000000000000000000000000000000000;;			superUser:                superUser,
0000000000000000000000000000000000000000;;			roleBindingLister:        roleBindings,
0000000000000000000000000000000000000000;;			clusterRoleBindingLister: clusterRoleBindings,
0000000000000000000000000000000000000000;;			roleToRuleMapper: rbacregistryvalidation.NewDefaultRuleResolver(
0000000000000000000000000000000000000000;;				roles, roleBindings, clusterRoles, clusterRoleBindings,
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return subjectLocator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllowedSubjects returns the subjects that can perform an action and any errors encountered while computing the list.
0000000000000000000000000000000000000000;;	// It is possible to have both subjects and errors returned if some rolebindings couldn't be resolved, but others could be.
0000000000000000000000000000000000000000;;	func (r *SubjectAccessEvaluator) AllowedSubjects(requestAttributes authorizer.Attributes) ([]rbac.Subject, error) {
0000000000000000000000000000000000000000;;		subjects := []rbac.Subject{{Kind: rbac.GroupKind, APIGroup: rbac.GroupName, Name: user.SystemPrivilegedGroup}}
0000000000000000000000000000000000000000;;		if len(r.superUser) > 0 {
0000000000000000000000000000000000000000;;			subjects = append(subjects, rbac.Subject{Kind: rbac.UserKind, APIGroup: rbac.GroupName, Name: r.superUser})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errorlist := []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if clusterRoleBindings, err := r.clusterRoleBindingLister.ListClusterRoleBindings(); err != nil {
0000000000000000000000000000000000000000;;			errorlist = append(errorlist, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, clusterRoleBinding := range clusterRoleBindings {
0000000000000000000000000000000000000000;;				rules, err := r.roleToRuleMapper.GetRoleReferenceRules(clusterRoleBinding.RoleRef, "")
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// if we have an error, just keep track of it and keep processing.  Since rules are additive,
0000000000000000000000000000000000000000;;					// missing a reference is bad, but we can continue with other rolebindings and still have a list
0000000000000000000000000000000000000000;;					// that does not contain any invalid values
0000000000000000000000000000000000000000;;					errorlist = append(errorlist, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if RulesAllow(requestAttributes, rules...) {
0000000000000000000000000000000000000000;;					subjects = append(subjects, clusterRoleBinding.Subjects...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if namespace := requestAttributes.GetNamespace(); len(namespace) > 0 {
0000000000000000000000000000000000000000;;			if roleBindings, err := r.roleBindingLister.ListRoleBindings(namespace); err != nil {
0000000000000000000000000000000000000000;;				errorlist = append(errorlist, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				for _, roleBinding := range roleBindings {
0000000000000000000000000000000000000000;;					rules, err := r.roleToRuleMapper.GetRoleReferenceRules(roleBinding.RoleRef, namespace)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						// if we have an error, just keep track of it and keep processing.  Since rules are additive,
0000000000000000000000000000000000000000;;						// missing a reference is bad, but we can continue with other rolebindings and still have a list
0000000000000000000000000000000000000000;;						// that does not contain any invalid values
0000000000000000000000000000000000000000;;						errorlist = append(errorlist, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if RulesAllow(requestAttributes, rules...) {
0000000000000000000000000000000000000000;;						subjects = append(subjects, roleBinding.Subjects...)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dedupedSubjects := []rbac.Subject{}
0000000000000000000000000000000000000000;;		for _, subject := range subjects {
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			for _, curr := range dedupedSubjects {
0000000000000000000000000000000000000000;;				if curr == subject {
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				dedupedSubjects = append(dedupedSubjects, subject)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return subjects, utilerrors.NewAggregate(errorlist)
0000000000000000000000000000000000000000;;	}
