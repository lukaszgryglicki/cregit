0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
75fa450029b357c96a43c0c8f119e7e9f3971d81;plugin/pkg/scheduler/equivalence_cache.go[plugin/pkg/scheduler/equivalence_cache.go][plugin/pkg/scheduler/core/equivalence_cache.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package core
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"hash/fnv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		hashutil "k8s.io/kubernetes/pkg/util/hash"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/golang/groupcache/lru"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// we use predicate names as cache's key, its count is limited
0000000000000000000000000000000000000000;;	const maxCacheEntries = 100
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type HostPredicate struct {
0000000000000000000000000000000000000000;;		Fit         bool
0000000000000000000000000000000000000000;;		FailReasons []algorithm.PredicateFailureReason
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AlgorithmCache struct {
0000000000000000000000000000000000000000;;		// Only consider predicates for now, priorities rely on: #31606
0000000000000000000000000000000000000000;;		predicatesCache *lru.Cache
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PredicateMap use equivalence hash as key
0000000000000000000000000000000000000000;;	type PredicateMap map[uint64]HostPredicate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newAlgorithmCache() AlgorithmCache {
0000000000000000000000000000000000000000;;		return AlgorithmCache{
0000000000000000000000000000000000000000;;			predicatesCache: lru.New(maxCacheEntries),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Store a map of predicate cache with maxsize
0000000000000000000000000000000000000000;;	type EquivalenceCache struct {
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;		getEquivalencePod algorithm.GetEquivalencePodFunc
0000000000000000000000000000000000000000;;		algorithmCache    map[string]AlgorithmCache
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewEquivalenceCache(getEquivalencePodFunc algorithm.GetEquivalencePodFunc) *EquivalenceCache {
0000000000000000000000000000000000000000;;		return &EquivalenceCache{
0000000000000000000000000000000000000000;;			getEquivalencePod: getEquivalencePodFunc,
0000000000000000000000000000000000000000;;			algorithmCache:    make(map[string]AlgorithmCache),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateCachedPredicateItem updates pod predicate for equivalence class
0000000000000000000000000000000000000000;;	func (ec *EquivalenceCache) UpdateCachedPredicateItem(pod *v1.Pod, nodeName, predicateKey string, fit bool, reasons []algorithm.PredicateFailureReason, equivalenceHash uint64) {
0000000000000000000000000000000000000000;;		ec.Lock()
0000000000000000000000000000000000000000;;		defer ec.Unlock()
0000000000000000000000000000000000000000;;		if _, exist := ec.algorithmCache[nodeName]; !exist {
0000000000000000000000000000000000000000;;			ec.algorithmCache[nodeName] = newAlgorithmCache()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		predicateItem := HostPredicate{
0000000000000000000000000000000000000000;;			Fit:         fit,
0000000000000000000000000000000000000000;;			FailReasons: reasons,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if cached predicate map already exists, just update the predicate by key
0000000000000000000000000000000000000000;;		if v, ok := ec.algorithmCache[nodeName].predicatesCache.Get(predicateKey); ok {
0000000000000000000000000000000000000000;;			predicateMap := v.(PredicateMap)
0000000000000000000000000000000000000000;;			// maps in golang are references, no need to add them back
0000000000000000000000000000000000000000;;			predicateMap[equivalenceHash] = predicateItem
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ec.algorithmCache[nodeName].predicatesCache.Add(predicateKey,
0000000000000000000000000000000000000000;;				PredicateMap{
0000000000000000000000000000000000000000;;					equivalenceHash: predicateItem,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Updated cached predicate: %v for pod: %v on node: %s, with item %v", predicateKey, pod.GetName(), nodeName, predicateItem)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PredicateWithECache returns:
0000000000000000000000000000000000000000;;	// 1. if fit
0000000000000000000000000000000000000000;;	// 2. reasons if not fit
0000000000000000000000000000000000000000;;	// 3. if this cache is invalid
0000000000000000000000000000000000000000;;	// based on cached predicate results
0000000000000000000000000000000000000000;;	func (ec *EquivalenceCache) PredicateWithECache(pod *v1.Pod, nodeName, predicateKey string, equivalenceHash uint64) (bool, []algorithm.PredicateFailureReason, bool) {
0000000000000000000000000000000000000000;;		ec.RLock()
0000000000000000000000000000000000000000;;		defer ec.RUnlock()
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Begin to calculate predicate: %v for pod: %s on node: %s based on equivalence cache", predicateKey, pod.GetName(), nodeName)
0000000000000000000000000000000000000000;;		if algorithmCache, exist := ec.algorithmCache[nodeName]; exist {
0000000000000000000000000000000000000000;;			if cachePredicate, exist := algorithmCache.predicatesCache.Get(predicateKey); exist {
0000000000000000000000000000000000000000;;				predicateMap := cachePredicate.(PredicateMap)
0000000000000000000000000000000000000000;;				// TODO(resouer) Is it possible a race that cache failed to update immediately?
0000000000000000000000000000000000000000;;				if hostPredicate, ok := predicateMap[equivalenceHash]; ok {
0000000000000000000000000000000000000000;;					if hostPredicate.Fit {
0000000000000000000000000000000000000000;;						return true, []algorithm.PredicateFailureReason{}, false
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						return false, hostPredicate.FailReasons, false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// is invalid
0000000000000000000000000000000000000000;;					return false, []algorithm.PredicateFailureReason{}, true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, []algorithm.PredicateFailureReason{}, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InvalidateCachedPredicateItem marks all items of given predicateKeys, of all pods, on the given node as invalid
0000000000000000000000000000000000000000;;	func (ec *EquivalenceCache) InvalidateCachedPredicateItem(nodeName string, predicateKeys sets.String) {
0000000000000000000000000000000000000000;;		if len(predicateKeys) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ec.Lock()
0000000000000000000000000000000000000000;;		defer ec.Unlock()
0000000000000000000000000000000000000000;;		if algorithmCache, exist := ec.algorithmCache[nodeName]; exist {
0000000000000000000000000000000000000000;;			for predicateKey := range predicateKeys {
0000000000000000000000000000000000000000;;				algorithmCache.predicatesCache.Remove(predicateKey)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Done invalidating cached predicates: %v on node: %s", predicateKeys, nodeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InvalidateCachedPredicateItemOfAllNodes marks all items of given predicateKeys, of all pods, on all node as invalid
0000000000000000000000000000000000000000;;	func (ec *EquivalenceCache) InvalidateCachedPredicateItemOfAllNodes(predicateKeys sets.String) {
0000000000000000000000000000000000000000;;		if len(predicateKeys) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ec.Lock()
0000000000000000000000000000000000000000;;		defer ec.Unlock()
0000000000000000000000000000000000000000;;		// algorithmCache uses nodeName as key, so we just iterate it and invalid given predicates
0000000000000000000000000000000000000000;;		for _, algorithmCache := range ec.algorithmCache {
0000000000000000000000000000000000000000;;			for predicateKey := range predicateKeys {
0000000000000000000000000000000000000000;;				// just use keys is enough
0000000000000000000000000000000000000000;;				algorithmCache.predicatesCache.Remove(predicateKey)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Done invalidating cached predicates: %v on all node", predicateKeys)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InvalidateAllCachedPredicateItemOfNode marks all cached items on given node as invalid
0000000000000000000000000000000000000000;;	func (ec *EquivalenceCache) InvalidateAllCachedPredicateItemOfNode(nodeName string) {
0000000000000000000000000000000000000000;;		ec.Lock()
0000000000000000000000000000000000000000;;		defer ec.Unlock()
0000000000000000000000000000000000000000;;		delete(ec.algorithmCache, nodeName)
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Done invalidating all cached predicates on node: %s", nodeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InvalidateCachedPredicateItemForPod marks item of given predicateKeys, of given pod, on the given node as invalid
0000000000000000000000000000000000000000;;	func (ec *EquivalenceCache) InvalidateCachedPredicateItemForPod(nodeName string, predicateKeys sets.String, pod *v1.Pod) {
0000000000000000000000000000000000000000;;		if len(predicateKeys) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		equivalenceHash := ec.getHashEquivalencePod(pod)
0000000000000000000000000000000000000000;;		if equivalenceHash == 0 {
0000000000000000000000000000000000000000;;			// no equivalence pod found, just return
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ec.Lock()
0000000000000000000000000000000000000000;;		defer ec.Unlock()
0000000000000000000000000000000000000000;;		if algorithmCache, exist := ec.algorithmCache[nodeName]; exist {
0000000000000000000000000000000000000000;;			for predicateKey := range predicateKeys {
0000000000000000000000000000000000000000;;				if cachePredicate, exist := algorithmCache.predicatesCache.Get(predicateKey); exist {
0000000000000000000000000000000000000000;;					// got the cached item of by predicateKey & pod
0000000000000000000000000000000000000000;;					predicateMap := cachePredicate.(PredicateMap)
0000000000000000000000000000000000000000;;					delete(predicateMap, equivalenceHash)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Done invalidating cached predicates %v on node %s, for pod %v", predicateKeys, nodeName, pod.GetName())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InvalidateCachedPredicateItemForPodAdd is a wrapper of InvalidateCachedPredicateItem for pod add case
0000000000000000000000000000000000000000;;	func (ec *EquivalenceCache) InvalidateCachedPredicateItemForPodAdd(pod *v1.Pod, nodeName string) {
0000000000000000000000000000000000000000;;		// MatchInterPodAffinity: we assume scheduler can make sure newly binded pod
0000000000000000000000000000000000000000;;		// will not break the existing inter pod affinity. So we does not need to invalidate
0000000000000000000000000000000000000000;;		// MatchInterPodAffinity when pod added.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// But when a pod is deleted, existing inter pod affinity may become invalid.
0000000000000000000000000000000000000000;;		// (e.g. this pod was preferred by some else, or vice versa)
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// NOTE: assumptions above will not stand when we implemented features like
0000000000000000000000000000000000000000;;		// RequiredDuringSchedulingRequiredDuringExecution.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NoDiskConflict: the newly scheduled pod fits to existing pods on this node,
0000000000000000000000000000000000000000;;		// it will also fits to equivalence class of existing pods
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GeneralPredicates: will always be affected by adding a new pod
0000000000000000000000000000000000000000;;		invalidPredicates := sets.NewString("GeneralPredicates")
0000000000000000000000000000000000000000;;		ec.InvalidateCachedPredicateItem(nodeName, invalidPredicates)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getHashEquivalencePod returns the hash of equivalence pod.
0000000000000000000000000000000000000000;;	// if no equivalence pod found, return 0
0000000000000000000000000000000000000000;;	func (ec *EquivalenceCache) getHashEquivalencePod(pod *v1.Pod) uint64 {
0000000000000000000000000000000000000000;;		equivalencePod := ec.getEquivalencePod(pod)
0000000000000000000000000000000000000000;;		if equivalencePod != nil {
0000000000000000000000000000000000000000;;			hash := fnv.New32a()
0000000000000000000000000000000000000000;;			hashutil.DeepHashObject(hash, equivalencePod)
0000000000000000000000000000000000000000;;			return uint64(hash.Sum32())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
