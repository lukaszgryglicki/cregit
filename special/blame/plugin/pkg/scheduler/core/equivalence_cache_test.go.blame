0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
3897d9b5f22ff30f8579290d7004621dbfb19d55;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package core
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm/predicates"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateCachedPredicateItem(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name            string
0000000000000000000000000000000000000000;;			pod             *v1.Pod
0000000000000000000000000000000000000000;;			predicateKey    string
0000000000000000000000000000000000000000;;			nodeName        string
0000000000000000000000000000000000000000;;			fit             bool
0000000000000000000000000000000000000000;;			reasons         []algorithm.PredicateFailureReason
0000000000000000000000000000000000000000;;			equivalenceHash uint64
0000000000000000000000000000000000000000;;			expectCacheItem HostPredicate
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:            "test 1",
0000000000000000000000000000000000000000;;				pod:             &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "testPod"}},
0000000000000000000000000000000000000000;;				predicateKey:    "GeneralPredicates",
0000000000000000000000000000000000000000;;				nodeName:        "node1",
0000000000000000000000000000000000000000;;				fit:             true,
0000000000000000000000000000000000000000;;				equivalenceHash: 123,
0000000000000000000000000000000000000000;;				expectCacheItem: HostPredicate{
0000000000000000000000000000000000000000;;					Fit: true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			// this case does not need to calculate equivalence hash, just pass an empty function
0000000000000000000000000000000000000000;;			fakeGetEquivalencePodFunc := func(pod *v1.Pod) interface{} { return nil }
0000000000000000000000000000000000000000;;			ecache := NewEquivalenceCache(fakeGetEquivalencePodFunc)
0000000000000000000000000000000000000000;;			ecache.UpdateCachedPredicateItem(test.pod, test.nodeName, test.predicateKey, test.fit, test.reasons, test.equivalenceHash)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			value, ok := ecache.algorithmCache[test.nodeName].predicatesCache.Get(test.predicateKey)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				t.Errorf("Failed : %s, can't find expected cache item: %v", test.name, test.expectCacheItem)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				cachedMapItem := value.(PredicateMap)
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(cachedMapItem[test.equivalenceHash], test.expectCacheItem) {
0000000000000000000000000000000000000000;;					t.Errorf("Failed : %s, expected cached item: %v, but got: %v", test.name, test.expectCacheItem, cachedMapItem[test.equivalenceHash])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type predicateItemType struct {
0000000000000000000000000000000000000000;;		fit     bool
0000000000000000000000000000000000000000;;		reasons []algorithm.PredicateFailureReason
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInvalidateCachedPredicateItem(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name                  string
0000000000000000000000000000000000000000;;			pod                   *v1.Pod
0000000000000000000000000000000000000000;;			nodeName              string
0000000000000000000000000000000000000000;;			predicateKey          string
0000000000000000000000000000000000000000;;			equivalenceHash       uint64
0000000000000000000000000000000000000000;;			cachedItem            predicateItemType
0000000000000000000000000000000000000000;;			expectedInvalid       bool
0000000000000000000000000000000000000000;;			expectedPredicateItem predicateItemType
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:            "test 1",
0000000000000000000000000000000000000000;;				pod:             &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "testPod"}},
0000000000000000000000000000000000000000;;				nodeName:        "node1",
0000000000000000000000000000000000000000;;				equivalenceHash: 123,
0000000000000000000000000000000000000000;;				predicateKey:    "GeneralPredicates",
0000000000000000000000000000000000000000;;				cachedItem: predicateItemType{
0000000000000000000000000000000000000000;;					fit:     false,
0000000000000000000000000000000000000000;;					reasons: []algorithm.PredicateFailureReason{predicates.ErrPodNotFitsHostPorts},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedInvalid: true,
0000000000000000000000000000000000000000;;				expectedPredicateItem: predicateItemType{
0000000000000000000000000000000000000000;;					fit:     false,
0000000000000000000000000000000000000000;;					reasons: []algorithm.PredicateFailureReason{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			// this case does not need to calculate equivalence hash, just pass an empty function
0000000000000000000000000000000000000000;;			fakeGetEquivalencePodFunc := func(pod *v1.Pod) interface{} { return nil }
0000000000000000000000000000000000000000;;			ecache := NewEquivalenceCache(fakeGetEquivalencePodFunc)
0000000000000000000000000000000000000000;;			// set cached item to equivalence cache
0000000000000000000000000000000000000000;;			ecache.UpdateCachedPredicateItem(test.pod, test.nodeName, test.predicateKey, test.cachedItem.fit, test.cachedItem.reasons, test.equivalenceHash)
0000000000000000000000000000000000000000;;			// if we want to do invalid, invalid the cached item
0000000000000000000000000000000000000000;;			if test.expectedInvalid {
0000000000000000000000000000000000000000;;				predicateKeys := sets.NewString()
0000000000000000000000000000000000000000;;				predicateKeys.Insert(test.predicateKey)
0000000000000000000000000000000000000000;;				ecache.InvalidateCachedPredicateItem(test.nodeName, predicateKeys)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// calculate predicate with equivalence cache
0000000000000000000000000000000000000000;;			fit, reasons, invalid := ecache.PredicateWithECache(test.pod, test.nodeName, test.predicateKey, test.equivalenceHash)
0000000000000000000000000000000000000000;;			// returned invalid should match expectedInvalid
0000000000000000000000000000000000000000;;			if invalid != test.expectedInvalid {
0000000000000000000000000000000000000000;;				t.Errorf("Failed : %s, expected invalid: %v, but got: %v", test.name, test.expectedInvalid, invalid)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// returned predicate result should match expected predicate item
0000000000000000000000000000000000000000;;			if fit != test.expectedPredicateItem.fit {
0000000000000000000000000000000000000000;;				t.Errorf("Failed : %s, expected fit: %v, but got: %v", test.name, test.cachedItem.fit, fit)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(reasons, test.expectedPredicateItem.reasons) {
0000000000000000000000000000000000000000;;				t.Errorf("Failed : %s, expected reasons: %v, but got: %v", test.name, test.cachedItem.reasons, reasons)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
