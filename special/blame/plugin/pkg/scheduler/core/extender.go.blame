0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
184f19e39f4665efa1da538e9d9290d4e50f48e5;plugin/pkg/scheduler/extender.go[plugin/pkg/scheduler/extender.go][plugin/pkg/scheduler/core/extender.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package core
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm"
0000000000000000000000000000000000000000;;		schedulerapi "k8s.io/kubernetes/plugin/pkg/scheduler/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/schedulercache"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DefaultExtenderTimeout = 5 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTTPExtender implements the algorithm.SchedulerExtender interface.
0000000000000000000000000000000000000000;;	type HTTPExtender struct {
0000000000000000000000000000000000000000;;		extenderURL      string
0000000000000000000000000000000000000000;;		filterVerb       string
0000000000000000000000000000000000000000;;		prioritizeVerb   string
0000000000000000000000000000000000000000;;		bindVerb         string
0000000000000000000000000000000000000000;;		weight           int
0000000000000000000000000000000000000000;;		client           *http.Client
0000000000000000000000000000000000000000;;		nodeCacheCapable bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeTransport(config *schedulerapi.ExtenderConfig) (http.RoundTripper, error) {
0000000000000000000000000000000000000000;;		var cfg restclient.Config
0000000000000000000000000000000000000000;;		if config.TLSConfig != nil {
0000000000000000000000000000000000000000;;			cfg.TLSClientConfig = *config.TLSConfig
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.EnableHttps {
0000000000000000000000000000000000000000;;			hasCA := len(cfg.CAFile) > 0 || len(cfg.CAData) > 0
0000000000000000000000000000000000000000;;			if !hasCA {
0000000000000000000000000000000000000000;;				cfg.Insecure = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tlsConfig, err := restclient.TLSConfigFor(&cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tlsConfig != nil {
0000000000000000000000000000000000000000;;			return utilnet.SetTransportDefaults(&http.Transport{
0000000000000000000000000000000000000000;;				TLSClientConfig: tlsConfig,
0000000000000000000000000000000000000000;;			}), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilnet.SetTransportDefaults(&http.Transport{}), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewHTTPExtender(config *schedulerapi.ExtenderConfig) (algorithm.SchedulerExtender, error) {
0000000000000000000000000000000000000000;;		if config.HTTPTimeout.Nanoseconds() == 0 {
0000000000000000000000000000000000000000;;			config.HTTPTimeout = time.Duration(DefaultExtenderTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		transport, err := makeTransport(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client := &http.Client{
0000000000000000000000000000000000000000;;			Transport: transport,
0000000000000000000000000000000000000000;;			Timeout:   config.HTTPTimeout,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &HTTPExtender{
0000000000000000000000000000000000000000;;			extenderURL:      config.URLPrefix,
0000000000000000000000000000000000000000;;			filterVerb:       config.FilterVerb,
0000000000000000000000000000000000000000;;			prioritizeVerb:   config.PrioritizeVerb,
0000000000000000000000000000000000000000;;			bindVerb:         config.BindVerb,
0000000000000000000000000000000000000000;;			weight:           config.Weight,
0000000000000000000000000000000000000000;;			client:           client,
0000000000000000000000000000000000000000;;			nodeCacheCapable: config.NodeCacheCapable,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Filter based on extender implemented predicate functions. The filtered list is
0000000000000000000000000000000000000000;;	// expected to be a subset of the supplied list. failedNodesMap optionally contains
0000000000000000000000000000000000000000;;	// the list of failed nodes and failure reasons.
0000000000000000000000000000000000000000;;	func (h *HTTPExtender) Filter(pod *v1.Pod, nodes []*v1.Node, nodeNameToInfo map[string]*schedulercache.NodeInfo) ([]*v1.Node, schedulerapi.FailedNodesMap, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			result     schedulerapi.ExtenderFilterResult
0000000000000000000000000000000000000000;;			nodeList   *v1.NodeList
0000000000000000000000000000000000000000;;			nodeNames  *[]string
0000000000000000000000000000000000000000;;			nodeResult []*v1.Node
0000000000000000000000000000000000000000;;			args       *schedulerapi.ExtenderArgs
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if h.filterVerb == "" {
0000000000000000000000000000000000000000;;			return nodes, schedulerapi.FailedNodesMap{}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if h.nodeCacheCapable {
0000000000000000000000000000000000000000;;			nodeNameSlice := make([]string, 0, len(nodes))
0000000000000000000000000000000000000000;;			for _, node := range nodes {
0000000000000000000000000000000000000000;;				nodeNameSlice = append(nodeNameSlice, node.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nodeNames = &nodeNameSlice
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			nodeList = &v1.NodeList{}
0000000000000000000000000000000000000000;;			for _, node := range nodes {
0000000000000000000000000000000000000000;;				nodeList.Items = append(nodeList.Items, *node)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		args = &schedulerapi.ExtenderArgs{
0000000000000000000000000000000000000000;;			Pod:       *pod,
0000000000000000000000000000000000000000;;			Nodes:     nodeList,
0000000000000000000000000000000000000000;;			NodeNames: nodeNames,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := h.send(h.filterVerb, args, &result); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.Error != "" {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf(result.Error)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if h.nodeCacheCapable && result.NodeNames != nil {
0000000000000000000000000000000000000000;;			nodeResult = make([]*v1.Node, 0, len(*result.NodeNames))
0000000000000000000000000000000000000000;;			for i := range *result.NodeNames {
0000000000000000000000000000000000000000;;				nodeResult = append(nodeResult, nodeNameToInfo[(*result.NodeNames)[i]].Node())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if result.Nodes != nil {
0000000000000000000000000000000000000000;;			nodeResult = make([]*v1.Node, 0, len(result.Nodes.Items))
0000000000000000000000000000000000000000;;			for i := range result.Nodes.Items {
0000000000000000000000000000000000000000;;				nodeResult = append(nodeResult, &result.Nodes.Items[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nodeResult, result.FailedNodes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Prioritize based on extender implemented priority functions. Weight*priority is added
0000000000000000000000000000000000000000;;	// up for each such priority function. The returned score is added to the score computed
0000000000000000000000000000000000000000;;	// by Kubernetes scheduler. The total score is used to do the host selection.
0000000000000000000000000000000000000000;;	func (h *HTTPExtender) Prioritize(pod *v1.Pod, nodes []*v1.Node) (*schedulerapi.HostPriorityList, int, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			result    schedulerapi.HostPriorityList
0000000000000000000000000000000000000000;;			nodeList  *v1.NodeList
0000000000000000000000000000000000000000;;			nodeNames *[]string
0000000000000000000000000000000000000000;;			args      *schedulerapi.ExtenderArgs
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if h.prioritizeVerb == "" {
0000000000000000000000000000000000000000;;			result := schedulerapi.HostPriorityList{}
0000000000000000000000000000000000000000;;			for _, node := range nodes {
0000000000000000000000000000000000000000;;				result = append(result, schedulerapi.HostPriority{Host: node.Name, Score: 0})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &result, 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if h.nodeCacheCapable {
0000000000000000000000000000000000000000;;			nodeNameSlice := make([]string, 0, len(nodes))
0000000000000000000000000000000000000000;;			for _, node := range nodes {
0000000000000000000000000000000000000000;;				nodeNameSlice = append(nodeNameSlice, node.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nodeNames = &nodeNameSlice
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			nodeList = &v1.NodeList{}
0000000000000000000000000000000000000000;;			for _, node := range nodes {
0000000000000000000000000000000000000000;;				nodeList.Items = append(nodeList.Items, *node)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		args = &schedulerapi.ExtenderArgs{
0000000000000000000000000000000000000000;;			Pod:       *pod,
0000000000000000000000000000000000000000;;			Nodes:     nodeList,
0000000000000000000000000000000000000000;;			NodeNames: nodeNames,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := h.send(h.prioritizeVerb, args, &result); err != nil {
0000000000000000000000000000000000000000;;			return nil, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &result, h.weight, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bind delegates the action of binding a pod to a node to the extender.
0000000000000000000000000000000000000000;;	func (h *HTTPExtender) Bind(binding *v1.Binding) error {
0000000000000000000000000000000000000000;;		var result schedulerapi.ExtenderBindingResult
0000000000000000000000000000000000000000;;		if !h.IsBinder() {
0000000000000000000000000000000000000000;;			// This shouldn't happen as this extender wouldn't have become a Binder.
0000000000000000000000000000000000000000;;			return fmt.Errorf("Unexpected empty bindVerb in extender")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req := &schedulerapi.ExtenderBindingArgs{
0000000000000000000000000000000000000000;;			PodName:      binding.Name,
0000000000000000000000000000000000000000;;			PodNamespace: binding.Namespace,
0000000000000000000000000000000000000000;;			PodUID:       binding.UID,
0000000000000000000000000000000000000000;;			Node:         binding.Target.Name,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := h.send(h.bindVerb, &req, &result); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.Error != "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf(result.Error)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsBinder returns whether this extender is configured for the Bind method.
0000000000000000000000000000000000000000;;	func (h *HTTPExtender) IsBinder() bool {
0000000000000000000000000000000000000000;;		return h.bindVerb != ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Helper function to send messages to the extender
0000000000000000000000000000000000000000;;	func (h *HTTPExtender) send(action string, args interface{}, result interface{}) error {
0000000000000000000000000000000000000000;;		out, err := json.Marshal(args)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		url := strings.TrimRight(h.extenderURL, "/") + "/" + action
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("POST", url, bytes.NewReader(out))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := h.client.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed %v with extender at URL %v, code %v", action, h.extenderURL, resp.StatusCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.NewDecoder(resp.Body).Decode(result)
0000000000000000000000000000000000000000;;	}
