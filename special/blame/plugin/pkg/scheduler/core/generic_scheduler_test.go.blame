0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
15cb1f713ffa0a0d4a81f56e9845d133f87e1375;pkg/scheduler/generic_scheduler_test.go[pkg/scheduler/generic_scheduler_test.go][plugin/pkg/scheduler/core/generic_scheduler_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package core
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apps "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm"
0000000000000000000000000000000000000000;;		algorithmpredicates "k8s.io/kubernetes/plugin/pkg/scheduler/algorithm/predicates"
0000000000000000000000000000000000000000;;		algorithmpriorities "k8s.io/kubernetes/plugin/pkg/scheduler/algorithm/priorities"
0000000000000000000000000000000000000000;;		priorityutil "k8s.io/kubernetes/plugin/pkg/scheduler/algorithm/priorities/util"
0000000000000000000000000000000000000000;;		schedulerapi "k8s.io/kubernetes/plugin/pkg/scheduler/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/schedulercache"
0000000000000000000000000000000000000000;;		schedulertesting "k8s.io/kubernetes/plugin/pkg/scheduler/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func falsePredicate(pod *v1.Pod, meta interface{}, nodeInfo *schedulercache.NodeInfo) (bool, []algorithm.PredicateFailureReason, error) {
0000000000000000000000000000000000000000;;		return false, []algorithm.PredicateFailureReason{algorithmpredicates.ErrFakePredicate}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func truePredicate(pod *v1.Pod, meta interface{}, nodeInfo *schedulercache.NodeInfo) (bool, []algorithm.PredicateFailureReason, error) {
0000000000000000000000000000000000000000;;		return true, nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func matchesPredicate(pod *v1.Pod, meta interface{}, nodeInfo *schedulercache.NodeInfo) (bool, []algorithm.PredicateFailureReason, error) {
0000000000000000000000000000000000000000;;		node := nodeInfo.Node()
0000000000000000000000000000000000000000;;		if node == nil {
0000000000000000000000000000000000000000;;			return false, nil, fmt.Errorf("node not found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pod.Name == node.Name {
0000000000000000000000000000000000000000;;			return true, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, []algorithm.PredicateFailureReason{algorithmpredicates.ErrFakePredicate}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasNoPodsPredicate(pod *v1.Pod, meta interface{}, nodeInfo *schedulercache.NodeInfo) (bool, []algorithm.PredicateFailureReason, error) {
0000000000000000000000000000000000000000;;		if len(nodeInfo.Pods()) == 0 {
0000000000000000000000000000000000000000;;			return true, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, []algorithm.PredicateFailureReason{algorithmpredicates.ErrFakePredicate}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func numericPriority(pod *v1.Pod, nodeNameToInfo map[string]*schedulercache.NodeInfo, nodes []*v1.Node) (schedulerapi.HostPriorityList, error) {
0000000000000000000000000000000000000000;;		result := []schedulerapi.HostPriority{}
0000000000000000000000000000000000000000;;		for _, node := range nodes {
0000000000000000000000000000000000000000;;			score, err := strconv.Atoi(node.Name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = append(result, schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;				Host:  node.Name,
0000000000000000000000000000000000000000;;				Score: score,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func reverseNumericPriority(pod *v1.Pod, nodeNameToInfo map[string]*schedulercache.NodeInfo, nodes []*v1.Node) (schedulerapi.HostPriorityList, error) {
0000000000000000000000000000000000000000;;		var maxScore float64
0000000000000000000000000000000000000000;;		minScore := math.MaxFloat64
0000000000000000000000000000000000000000;;		reverseResult := []schedulerapi.HostPriority{}
0000000000000000000000000000000000000000;;		result, err := numericPriority(pod, nodeNameToInfo, nodes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, hostPriority := range result {
0000000000000000000000000000000000000000;;			maxScore = math.Max(maxScore, float64(hostPriority.Score))
0000000000000000000000000000000000000000;;			minScore = math.Min(minScore, float64(hostPriority.Score))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, hostPriority := range result {
0000000000000000000000000000000000000000;;			reverseResult = append(reverseResult, schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;				Host:  hostPriority.Host,
0000000000000000000000000000000000000000;;				Score: int(maxScore + minScore - float64(hostPriority.Score)),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return reverseResult, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeNodeList(nodeNames []string) []*v1.Node {
0000000000000000000000000000000000000000;;		result := make([]*v1.Node, 0, len(nodeNames))
0000000000000000000000000000000000000000;;		for _, nodeName := range nodeNames {
0000000000000000000000000000000000000000;;			result = append(result, &v1.Node{ObjectMeta: metav1.ObjectMeta{Name: nodeName}})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSelectHost(t *testing.T) {
0000000000000000000000000000000000000000;;		scheduler := genericScheduler{}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			list          schedulerapi.HostPriorityList
0000000000000000000000000000000000000000;;			possibleHosts sets.String
0000000000000000000000000000000000000000;;			expectsErr    bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				list: []schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;					{Host: "machine1.1", Score: 1},
0000000000000000000000000000000000000000;;					{Host: "machine2.1", Score: 2},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				possibleHosts: sets.NewString("machine2.1"),
0000000000000000000000000000000000000000;;				expectsErr:    false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// equal scores
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				list: []schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;					{Host: "machine1.1", Score: 1},
0000000000000000000000000000000000000000;;					{Host: "machine1.2", Score: 2},
0000000000000000000000000000000000000000;;					{Host: "machine1.3", Score: 2},
0000000000000000000000000000000000000000;;					{Host: "machine2.1", Score: 2},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				possibleHosts: sets.NewString("machine1.2", "machine1.3", "machine2.1"),
0000000000000000000000000000000000000000;;				expectsErr:    false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// out of order scores
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				list: []schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;					{Host: "machine1.1", Score: 3},
0000000000000000000000000000000000000000;;					{Host: "machine1.2", Score: 3},
0000000000000000000000000000000000000000;;					{Host: "machine2.1", Score: 2},
0000000000000000000000000000000000000000;;					{Host: "machine3.1", Score: 1},
0000000000000000000000000000000000000000;;					{Host: "machine1.3", Score: 3},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				possibleHosts: sets.NewString("machine1.1", "machine1.2", "machine1.3"),
0000000000000000000000000000000000000000;;				expectsErr:    false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// empty priorityList
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				list:          []schedulerapi.HostPriority{},
0000000000000000000000000000000000000000;;				possibleHosts: sets.NewString(),
0000000000000000000000000000000000000000;;				expectsErr:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			// increase the randomness
0000000000000000000000000000000000000000;;			for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;				got, err := scheduler.selectHost(test.list)
0000000000000000000000000000000000000000;;				if test.expectsErr {
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						t.Error("Unexpected non-error")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !test.possibleHosts.Has(got) {
0000000000000000000000000000000000000000;;						t.Errorf("got %s is not in the possible map %v", got, test.possibleHosts)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGenericScheduler(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name          string
0000000000000000000000000000000000000000;;			predicates    map[string]algorithm.FitPredicate
0000000000000000000000000000000000000000;;			prioritizers  []algorithm.PriorityConfig
0000000000000000000000000000000000000000;;			nodes         []string
0000000000000000000000000000000000000000;;			pod           *v1.Pod
0000000000000000000000000000000000000000;;			pods          []*v1.Pod
0000000000000000000000000000000000000000;;			expectedHosts sets.String
0000000000000000000000000000000000000000;;			expectsErr    bool
0000000000000000000000000000000000000000;;			wErr          error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				predicates:   map[string]algorithm.FitPredicate{"false": falsePredicate},
0000000000000000000000000000000000000000;;				prioritizers: []algorithm.PriorityConfig{{Map: EqualPriorityMap, Weight: 1}},
0000000000000000000000000000000000000000;;				nodes:        []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				expectsErr:   true,
0000000000000000000000000000000000000000;;				pod:          &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "2"}},
0000000000000000000000000000000000000000;;				name:         "test 1",
0000000000000000000000000000000000000000;;				wErr: &FitError{
0000000000000000000000000000000000000000;;					Pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "2"}},
0000000000000000000000000000000000000000;;					FailedPredicates: FailedPredicateMap{
0000000000000000000000000000000000000000;;						"machine1": []algorithm.PredicateFailureReason{algorithmpredicates.ErrFakePredicate},
0000000000000000000000000000000000000000;;						"machine2": []algorithm.PredicateFailureReason{algorithmpredicates.ErrFakePredicate},
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				predicates:    map[string]algorithm.FitPredicate{"true": truePredicate},
0000000000000000000000000000000000000000;;				prioritizers:  []algorithm.PriorityConfig{{Map: EqualPriorityMap, Weight: 1}},
0000000000000000000000000000000000000000;;				nodes:         []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				pod:           &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "ignore"}},
0000000000000000000000000000000000000000;;				expectedHosts: sets.NewString("machine1", "machine2"),
0000000000000000000000000000000000000000;;				name:          "test 2",
0000000000000000000000000000000000000000;;				wErr:          nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Fits on a machine where the pod ID matches the machine name
0000000000000000000000000000000000000000;;				predicates:    map[string]algorithm.FitPredicate{"matches": matchesPredicate},
0000000000000000000000000000000000000000;;				prioritizers:  []algorithm.PriorityConfig{{Map: EqualPriorityMap, Weight: 1}},
0000000000000000000000000000000000000000;;				nodes:         []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				pod:           &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "machine2"}},
0000000000000000000000000000000000000000;;				expectedHosts: sets.NewString("machine2"),
0000000000000000000000000000000000000000;;				name:          "test 3",
0000000000000000000000000000000000000000;;				wErr:          nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				predicates:    map[string]algorithm.FitPredicate{"true": truePredicate},
0000000000000000000000000000000000000000;;				prioritizers:  []algorithm.PriorityConfig{{Function: numericPriority, Weight: 1}},
0000000000000000000000000000000000000000;;				nodes:         []string{"3", "2", "1"},
0000000000000000000000000000000000000000;;				pod:           &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "ignore"}},
0000000000000000000000000000000000000000;;				expectedHosts: sets.NewString("3"),
0000000000000000000000000000000000000000;;				name:          "test 4",
0000000000000000000000000000000000000000;;				wErr:          nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				predicates:    map[string]algorithm.FitPredicate{"matches": matchesPredicate},
0000000000000000000000000000000000000000;;				prioritizers:  []algorithm.PriorityConfig{{Function: numericPriority, Weight: 1}},
0000000000000000000000000000000000000000;;				nodes:         []string{"3", "2", "1"},
0000000000000000000000000000000000000000;;				pod:           &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "2"}},
0000000000000000000000000000000000000000;;				expectedHosts: sets.NewString("2"),
0000000000000000000000000000000000000000;;				name:          "test 5",
0000000000000000000000000000000000000000;;				wErr:          nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				predicates:    map[string]algorithm.FitPredicate{"true": truePredicate},
0000000000000000000000000000000000000000;;				prioritizers:  []algorithm.PriorityConfig{{Function: numericPriority, Weight: 1}, {Function: reverseNumericPriority, Weight: 2}},
0000000000000000000000000000000000000000;;				nodes:         []string{"3", "2", "1"},
0000000000000000000000000000000000000000;;				pod:           &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "2"}},
0000000000000000000000000000000000000000;;				expectedHosts: sets.NewString("1"),
0000000000000000000000000000000000000000;;				name:          "test 6",
0000000000000000000000000000000000000000;;				wErr:          nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				predicates:   map[string]algorithm.FitPredicate{"true": truePredicate, "false": falsePredicate},
0000000000000000000000000000000000000000;;				prioritizers: []algorithm.PriorityConfig{{Function: numericPriority, Weight: 1}},
0000000000000000000000000000000000000000;;				nodes:        []string{"3", "2", "1"},
0000000000000000000000000000000000000000;;				pod:          &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "2"}},
0000000000000000000000000000000000000000;;				expectsErr:   true,
0000000000000000000000000000000000000000;;				name:         "test 7",
0000000000000000000000000000000000000000;;				wErr: &FitError{
0000000000000000000000000000000000000000;;					Pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "2"}},
0000000000000000000000000000000000000000;;					FailedPredicates: FailedPredicateMap{
0000000000000000000000000000000000000000;;						"3": []algorithm.PredicateFailureReason{algorithmpredicates.ErrFakePredicate},
0000000000000000000000000000000000000000;;						"2": []algorithm.PredicateFailureReason{algorithmpredicates.ErrFakePredicate},
0000000000000000000000000000000000000000;;						"1": []algorithm.PredicateFailureReason{algorithmpredicates.ErrFakePredicate},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				predicates: map[string]algorithm.FitPredicate{
0000000000000000000000000000000000000000;;					"nopods":  hasNoPodsPredicate,
0000000000000000000000000000000000000000;;					"matches": matchesPredicate,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{Name: "2"},
0000000000000000000000000000000000000000;;						Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;							NodeName: "2",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.PodStatus{
0000000000000000000000000000000000000000;;							Phase: v1.PodRunning,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pod:          &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "2"}},
0000000000000000000000000000000000000000;;				prioritizers: []algorithm.PriorityConfig{{Function: numericPriority, Weight: 1}},
0000000000000000000000000000000000000000;;				nodes:        []string{"1", "2"},
0000000000000000000000000000000000000000;;				expectsErr:   true,
0000000000000000000000000000000000000000;;				name:         "test 8",
0000000000000000000000000000000000000000;;				wErr: &FitError{
0000000000000000000000000000000000000000;;					Pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "2"}},
0000000000000000000000000000000000000000;;					FailedPredicates: FailedPredicateMap{
0000000000000000000000000000000000000000;;						"1": []algorithm.PredicateFailureReason{algorithmpredicates.ErrFakePredicate},
0000000000000000000000000000000000000000;;						"2": []algorithm.PredicateFailureReason{algorithmpredicates.ErrFakePredicate},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			cache := schedulercache.New(time.Duration(0), wait.NeverStop)
0000000000000000000000000000000000000000;;			for _, pod := range test.pods {
0000000000000000000000000000000000000000;;				cache.AddPod(pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, name := range test.nodes {
0000000000000000000000000000000000000000;;				cache.AddNode(&v1.Node{ObjectMeta: metav1.ObjectMeta{Name: name}})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			scheduler := NewGenericScheduler(
0000000000000000000000000000000000000000;;				cache, nil, test.predicates, algorithm.EmptyMetadataProducer, test.prioritizers, algorithm.EmptyMetadataProducer,
0000000000000000000000000000000000000000;;				[]algorithm.SchedulerExtender{})
0000000000000000000000000000000000000000;;			machine, err := scheduler.Schedule(test.pod, schedulertesting.FakeNodeLister(makeNodeList(test.nodes)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(err, test.wErr) {
0000000000000000000000000000000000000000;;				t.Errorf("Failed : %s, Unexpected error: %v, expected: %v", test.name, err, test.wErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.expectedHosts != nil && !test.expectedHosts.Has(machine) {
0000000000000000000000000000000000000000;;				t.Errorf("Failed : %s, Expected: %s, got: %s", test.name, test.expectedHosts, machine)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFindFitAllError(t *testing.T) {
0000000000000000000000000000000000000000;;		nodes := []string{"3", "2", "1"}
0000000000000000000000000000000000000000;;		predicates := map[string]algorithm.FitPredicate{"true": truePredicate, "false": falsePredicate}
0000000000000000000000000000000000000000;;		nodeNameToInfo := map[string]*schedulercache.NodeInfo{
0000000000000000000000000000000000000000;;			"3": schedulercache.NewNodeInfo(),
0000000000000000000000000000000000000000;;			"2": schedulercache.NewNodeInfo(),
0000000000000000000000000000000000000000;;			"1": schedulercache.NewNodeInfo(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, predicateMap, err := findNodesThatFit(&v1.Pod{}, nodeNameToInfo, makeNodeList(nodes), predicates, nil, algorithm.EmptyMetadataProducer, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(predicateMap) != len(nodes) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected failed predicate map: %v", predicateMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, node := range nodes {
0000000000000000000000000000000000000000;;			failures, found := predicateMap[node]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				t.Errorf("failed to find node: %s in %v", node, predicateMap)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(failures) != 1 || failures[0] != algorithmpredicates.ErrFakePredicate {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected failures: %v", failures)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFindFitSomeError(t *testing.T) {
0000000000000000000000000000000000000000;;		nodes := []string{"3", "2", "1"}
0000000000000000000000000000000000000000;;		predicates := map[string]algorithm.FitPredicate{"true": truePredicate, "match": matchesPredicate}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "1"}}
0000000000000000000000000000000000000000;;		nodeNameToInfo := map[string]*schedulercache.NodeInfo{
0000000000000000000000000000000000000000;;			"3": schedulercache.NewNodeInfo(),
0000000000000000000000000000000000000000;;			"2": schedulercache.NewNodeInfo(),
0000000000000000000000000000000000000000;;			"1": schedulercache.NewNodeInfo(pod),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for name := range nodeNameToInfo {
0000000000000000000000000000000000000000;;			nodeNameToInfo[name].SetNode(&v1.Node{ObjectMeta: metav1.ObjectMeta{Name: name}})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, predicateMap, err := findNodesThatFit(pod, nodeNameToInfo, makeNodeList(nodes), predicates, nil, algorithm.EmptyMetadataProducer, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(predicateMap) != (len(nodes) - 1) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected failed predicate map: %v", predicateMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, node := range nodes {
0000000000000000000000000000000000000000;;			if node == pod.Name {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			failures, found := predicateMap[node]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				t.Errorf("failed to find node: %s in %v", node, predicateMap)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(failures) != 1 || failures[0] != algorithmpredicates.ErrFakePredicate {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected failures: %v", failures)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeNode(node string, milliCPU, memory int64) *v1.Node {
0000000000000000000000000000000000000000;;		return &v1.Node{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: node},
0000000000000000000000000000000000000000;;			Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					"cpu":    *resource.NewMilliQuantity(milliCPU, resource.DecimalSI),
0000000000000000000000000000000000000000;;					"memory": *resource.NewQuantity(memory, resource.BinarySI),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Allocatable: v1.ResourceList{
0000000000000000000000000000000000000000;;					"cpu":    *resource.NewMilliQuantity(milliCPU, resource.DecimalSI),
0000000000000000000000000000000000000000;;					"memory": *resource.NewQuantity(memory, resource.BinarySI),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHumanReadableFitError(t *testing.T) {
0000000000000000000000000000000000000000;;		error := &FitError{
0000000000000000000000000000000000000000;;			Pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "2"}},
0000000000000000000000000000000000000000;;			FailedPredicates: FailedPredicateMap{
0000000000000000000000000000000000000000;;				"1": []algorithm.PredicateFailureReason{algorithmpredicates.ErrNodeUnderMemoryPressure},
0000000000000000000000000000000000000000;;				"2": []algorithm.PredicateFailureReason{algorithmpredicates.ErrNodeUnderDiskPressure},
0000000000000000000000000000000000000000;;				"3": []algorithm.PredicateFailureReason{algorithmpredicates.ErrNodeUnderDiskPressure},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.Contains(error.Error(), NoNodeAvailableMsg) {
0000000000000000000000000000000000000000;;			if strings.Contains(error.Error(), "NodeUnderDiskPressure (2)") && strings.Contains(error.Error(), "NodeUnderMemoryPressure (1)") {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Errorf("Error message doesn't have all the information content: [" + error.Error() + "]")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The point of this test is to show that you:
0000000000000000000000000000000000000000;;	// - get the same priority for a zero-request pod as for a pod with the defaults requests,
0000000000000000000000000000000000000000;;	//   both when the zero-request pod is already on the machine and when the zero-request pod
0000000000000000000000000000000000000000;;	//   is the one being scheduled.
0000000000000000000000000000000000000000;;	// - don't get the same score no matter what we schedule.
0000000000000000000000000000000000000000;;	func TestZeroRequest(t *testing.T) {
0000000000000000000000000000000000000000;;		// A pod with no resources. We expect spreading to count it as having the default resources.
0000000000000000000000000000000000000000;;		noResources := v1.PodSpec{
0000000000000000000000000000000000000000;;			Containers: []v1.Container{
0000000000000000000000000000000000000000;;				{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		noResources1 := noResources
0000000000000000000000000000000000000000;;		noResources1.NodeName = "machine1"
0000000000000000000000000000000000000000;;		// A pod with the same resources as a 0-request pod gets by default as its resources (for spreading).
0000000000000000000000000000000000000000;;		small := v1.PodSpec{
0000000000000000000000000000000000000000;;			Containers: []v1.Container{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;						Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;							"cpu": resource.MustParse(
0000000000000000000000000000000000000000;;								strconv.FormatInt(priorityutil.DefaultMilliCpuRequest, 10) + "m"),
0000000000000000000000000000000000000000;;							"memory": resource.MustParse(
0000000000000000000000000000000000000000;;								strconv.FormatInt(priorityutil.DefaultMemoryRequest, 10)),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		small2 := small
0000000000000000000000000000000000000000;;		small2.NodeName = "machine2"
0000000000000000000000000000000000000000;;		// A larger pod.
0000000000000000000000000000000000000000;;		large := v1.PodSpec{
0000000000000000000000000000000000000000;;			Containers: []v1.Container{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;						Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;							"cpu": resource.MustParse(
0000000000000000000000000000000000000000;;								strconv.FormatInt(priorityutil.DefaultMilliCpuRequest*3, 10) + "m"),
0000000000000000000000000000000000000000;;							"memory": resource.MustParse(
0000000000000000000000000000000000000000;;								strconv.FormatInt(priorityutil.DefaultMemoryRequest*3, 10)),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		large1 := large
0000000000000000000000000000000000000000;;		large1.NodeName = "machine1"
0000000000000000000000000000000000000000;;		large2 := large
0000000000000000000000000000000000000000;;		large2.NodeName = "machine2"
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod   *v1.Pod
0000000000000000000000000000000000000000;;			pods  []*v1.Pod
0000000000000000000000000000000000000000;;			nodes []*v1.Node
0000000000000000000000000000000000000000;;			test  string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// The point of these next two tests is to show you get the same priority for a zero-request pod
0000000000000000000000000000000000000000;;			// as for a pod with the defaults requests, both when the zero-request pod is already on the machine
0000000000000000000000000000000000000000;;			// and when the zero-request pod is the one being scheduled.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:   &v1.Pod{Spec: noResources},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{makeNode("machine1", 1000, priorityutil.DefaultMemoryRequest*10), makeNode("machine2", 1000, priorityutil.DefaultMemoryRequest*10)},
0000000000000000000000000000000000000000;;				test:  "test priority of zero-request pod with machine with zero-request pod",
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: large1}, {Spec: noResources1},
0000000000000000000000000000000000000000;;					{Spec: large2}, {Spec: small2},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:   &v1.Pod{Spec: small},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{makeNode("machine1", 1000, priorityutil.DefaultMemoryRequest*10), makeNode("machine2", 1000, priorityutil.DefaultMemoryRequest*10)},
0000000000000000000000000000000000000000;;				test:  "test priority of nonzero-request pod with machine with zero-request pod",
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: large1}, {Spec: noResources1},
0000000000000000000000000000000000000000;;					{Spec: large2}, {Spec: small2},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// The point of this test is to verify that we're not just getting the same score no matter what we schedule.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:   &v1.Pod{Spec: large},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{makeNode("machine1", 1000, priorityutil.DefaultMemoryRequest*10), makeNode("machine2", 1000, priorityutil.DefaultMemoryRequest*10)},
0000000000000000000000000000000000000000;;				test:  "test priority of larger pod with machine with zero-request pod",
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: large1}, {Spec: noResources1},
0000000000000000000000000000000000000000;;					{Spec: large2}, {Spec: small2},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const expectedPriority int = 25
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			// This should match the configuration in defaultPriorities() in
0000000000000000000000000000000000000000;;			// plugin/pkg/scheduler/algorithmprovider/defaults/defaults.go if you want
0000000000000000000000000000000000000000;;			// to test what's actually in production.
0000000000000000000000000000000000000000;;			priorityConfigs := []algorithm.PriorityConfig{
0000000000000000000000000000000000000000;;				{Map: algorithmpriorities.LeastRequestedPriorityMap, Weight: 1},
0000000000000000000000000000000000000000;;				{Map: algorithmpriorities.BalancedResourceAllocationMap, Weight: 1},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Function: algorithmpriorities.NewSelectorSpreadPriority(
0000000000000000000000000000000000000000;;						schedulertesting.FakeServiceLister([]*v1.Service{}),
0000000000000000000000000000000000000000;;						schedulertesting.FakeControllerLister([]*v1.ReplicationController{}),
0000000000000000000000000000000000000000;;						schedulertesting.FakeReplicaSetLister([]*extensions.ReplicaSet{}),
0000000000000000000000000000000000000000;;						schedulertesting.FakeStatefulSetLister([]*apps.StatefulSet{})),
0000000000000000000000000000000000000000;;					Weight: 1,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nodeNameToInfo := schedulercache.CreateNodeNameToInfoMap(test.pods, test.nodes)
0000000000000000000000000000000000000000;;			list, err := PrioritizeNodes(
0000000000000000000000000000000000000000;;				test.pod, nodeNameToInfo, algorithm.EmptyMetadataProducer, priorityConfigs,
0000000000000000000000000000000000000000;;				schedulertesting.FakeNodeLister(test.nodes), []algorithm.SchedulerExtender{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, hp := range list {
0000000000000000000000000000000000000000;;				if test.test == "test priority of larger pod with machine with zero-request pod" {
0000000000000000000000000000000000000000;;					if hp.Score == expectedPriority {
0000000000000000000000000000000000000000;;						t.Errorf("%s: expected non-%d for all priorities, got list %#v", test.test, expectedPriority, list)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if hp.Score != expectedPriority {
0000000000000000000000000000000000000000;;						t.Errorf("%s: expected %d for all priorities, got list %#v", test.test, expectedPriority, list)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
