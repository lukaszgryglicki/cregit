0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
ac5aa537bc547bb5e6296123dea26dfd4463b051;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package factory can set up a scheduler. This code is here instead of
0000000000000000000000000000000000000000;;	// plugin/cmd/scheduler for both testability and reuse.
0000000000000000000000000000000000000000;;	package factory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		appsinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/apps/v1beta1"
0000000000000000000000000000000000000000;;		coreinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/core/v1"
0000000000000000000000000000000000000000;;		extensionsinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/extensions/v1beta1"
0000000000000000000000000000000000000000;;		appslisters "k8s.io/kubernetes/pkg/client/listers/apps/v1beta1"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		extensionslisters "k8s.io/kubernetes/pkg/client/listers/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm/predicates"
0000000000000000000000000000000000000000;;		schedulerapi "k8s.io/kubernetes/plugin/pkg/scheduler/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/api/validation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/core"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/schedulercache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		initialGetBackoff = 100 * time.Millisecond
0000000000000000000000000000000000000000;;		maximalGetBackoff = time.Minute
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfigFactory is the default implementation of the scheduler.Configurator interface.
0000000000000000000000000000000000000000;;	// TODO make this private if possible, so that only its interface is externally used.
0000000000000000000000000000000000000000;;	type ConfigFactory struct {
0000000000000000000000000000000000000000;;		client clientset.Interface
0000000000000000000000000000000000000000;;		// queue for pods that need scheduling
0000000000000000000000000000000000000000;;		podQueue *cache.FIFO
0000000000000000000000000000000000000000;;		// a means to list all known scheduled pods.
0000000000000000000000000000000000000000;;		scheduledPodLister corelisters.PodLister
0000000000000000000000000000000000000000;;		// a means to list all known scheduled pods and pods assumed to have been scheduled.
0000000000000000000000000000000000000000;;		podLister algorithm.PodLister
0000000000000000000000000000000000000000;;		// a means to list all nodes
0000000000000000000000000000000000000000;;		nodeLister corelisters.NodeLister
0000000000000000000000000000000000000000;;		// a means to list all PersistentVolumes
0000000000000000000000000000000000000000;;		pVLister corelisters.PersistentVolumeLister
0000000000000000000000000000000000000000;;		// a means to list all PersistentVolumeClaims
0000000000000000000000000000000000000000;;		pVCLister corelisters.PersistentVolumeClaimLister
0000000000000000000000000000000000000000;;		// a means to list all services
0000000000000000000000000000000000000000;;		serviceLister corelisters.ServiceLister
0000000000000000000000000000000000000000;;		// a means to list all controllers
0000000000000000000000000000000000000000;;		controllerLister corelisters.ReplicationControllerLister
0000000000000000000000000000000000000000;;		// a means to list all replicasets
0000000000000000000000000000000000000000;;		replicaSetLister extensionslisters.ReplicaSetLister
0000000000000000000000000000000000000000;;		// a means to list all statefulsets
0000000000000000000000000000000000000000;;		statefulSetLister appslisters.StatefulSetLister
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close this to stop all reflectors
0000000000000000000000000000000000000000;;		StopEverything chan struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scheduledPodsHasSynced cache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		schedulerCache schedulercache.Cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SchedulerName of a scheduler is used to select which pods will be
0000000000000000000000000000000000000000;;		// processed by this scheduler, based on pods's "spec.SchedulerName".
0000000000000000000000000000000000000000;;		schedulerName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RequiredDuringScheduling affinity is not symmetric, but there is an implicit PreferredDuringScheduling affinity rule
0000000000000000000000000000000000000000;;		// corresponding to every RequiredDuringScheduling affinity rule.
0000000000000000000000000000000000000000;;		// HardPodAffinitySymmetricWeight represents the weight of implicit PreferredDuringScheduling affinity rule, in the range 0-100.
0000000000000000000000000000000000000000;;		hardPodAffinitySymmetricWeight int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Equivalence class cache
0000000000000000000000000000000000000000;;		equivalencePodCache *core.EquivalenceCache
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewConfigFactory initializes the default implementation of a Configurator To encourage eventual privatization of the struct type, we only
0000000000000000000000000000000000000000;;	// return the interface.
0000000000000000000000000000000000000000;;	func NewConfigFactory(
0000000000000000000000000000000000000000;;		schedulerName string,
0000000000000000000000000000000000000000;;		client clientset.Interface,
0000000000000000000000000000000000000000;;		nodeInformer coreinformers.NodeInformer,
0000000000000000000000000000000000000000;;		podInformer coreinformers.PodInformer,
0000000000000000000000000000000000000000;;		pvInformer coreinformers.PersistentVolumeInformer,
0000000000000000000000000000000000000000;;		pvcInformer coreinformers.PersistentVolumeClaimInformer,
0000000000000000000000000000000000000000;;		replicationControllerInformer coreinformers.ReplicationControllerInformer,
0000000000000000000000000000000000000000;;		replicaSetInformer extensionsinformers.ReplicaSetInformer,
0000000000000000000000000000000000000000;;		statefulSetInformer appsinformers.StatefulSetInformer,
0000000000000000000000000000000000000000;;		serviceInformer coreinformers.ServiceInformer,
0000000000000000000000000000000000000000;;		hardPodAffinitySymmetricWeight int,
0000000000000000000000000000000000000000;;	) scheduler.Configurator {
0000000000000000000000000000000000000000;;		stopEverything := make(chan struct{})
0000000000000000000000000000000000000000;;		schedulerCache := schedulercache.New(30*time.Second, stopEverything)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := &ConfigFactory{
0000000000000000000000000000000000000000;;			client:                         client,
0000000000000000000000000000000000000000;;			podLister:                      schedulerCache,
0000000000000000000000000000000000000000;;			podQueue:                       cache.NewFIFO(cache.MetaNamespaceKeyFunc),
0000000000000000000000000000000000000000;;			pVLister:                       pvInformer.Lister(),
0000000000000000000000000000000000000000;;			pVCLister:                      pvcInformer.Lister(),
0000000000000000000000000000000000000000;;			serviceLister:                  serviceInformer.Lister(),
0000000000000000000000000000000000000000;;			controllerLister:               replicationControllerInformer.Lister(),
0000000000000000000000000000000000000000;;			replicaSetLister:               replicaSetInformer.Lister(),
0000000000000000000000000000000000000000;;			statefulSetLister:              statefulSetInformer.Lister(),
0000000000000000000000000000000000000000;;			schedulerCache:                 schedulerCache,
0000000000000000000000000000000000000000;;			StopEverything:                 stopEverything,
0000000000000000000000000000000000000000;;			schedulerName:                  schedulerName,
0000000000000000000000000000000000000000;;			hardPodAffinitySymmetricWeight: hardPodAffinitySymmetricWeight,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.scheduledPodsHasSynced = podInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;		// scheduled pod cache
0000000000000000000000000000000000000000;;		podInformer.Informer().AddEventHandler(
0000000000000000000000000000000000000000;;			cache.FilteringResourceEventHandler{
0000000000000000000000000000000000000000;;				FilterFunc: func(obj interface{}) bool {
0000000000000000000000000000000000000000;;					switch t := obj.(type) {
0000000000000000000000000000000000000000;;					case *v1.Pod:
0000000000000000000000000000000000000000;;						return assignedNonTerminatedPod(t)
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						runtime.HandleError(fmt.Errorf("unable to handle object in %T: %T", c, obj))
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Handler: cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;					AddFunc:    c.addPodToCache,
0000000000000000000000000000000000000000;;					UpdateFunc: c.updatePodInCache,
0000000000000000000000000000000000000000;;					DeleteFunc: c.deletePodFromCache,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		// unscheduled pod queue
0000000000000000000000000000000000000000;;		podInformer.Informer().AddEventHandler(
0000000000000000000000000000000000000000;;			cache.FilteringResourceEventHandler{
0000000000000000000000000000000000000000;;				FilterFunc: func(obj interface{}) bool {
0000000000000000000000000000000000000000;;					switch t := obj.(type) {
0000000000000000000000000000000000000000;;					case *v1.Pod:
0000000000000000000000000000000000000000;;						return unassignedNonTerminatedPod(t)
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						runtime.HandleError(fmt.Errorf("unable to handle object in %T: %T", c, obj))
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Handler: cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;					AddFunc: func(obj interface{}) {
0000000000000000000000000000000000000000;;						if err := c.podQueue.Add(obj); err != nil {
0000000000000000000000000000000000000000;;							runtime.HandleError(fmt.Errorf("unable to queue %T: %v", obj, err))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					UpdateFunc: func(oldObj, newObj interface{}) {
0000000000000000000000000000000000000000;;						if err := c.podQueue.Update(newObj); err != nil {
0000000000000000000000000000000000000000;;							runtime.HandleError(fmt.Errorf("unable to update %T: %v", newObj, err))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					DeleteFunc: func(obj interface{}) {
0000000000000000000000000000000000000000;;						if err := c.podQueue.Delete(obj); err != nil {
0000000000000000000000000000000000000000;;							runtime.HandleError(fmt.Errorf("unable to dequeue %T: %v", obj, err))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		// ScheduledPodLister is something we provide to plug-in functions that
0000000000000000000000000000000000000000;;		// they may need to call.
0000000000000000000000000000000000000000;;		c.scheduledPodLister = assignedPodLister{podInformer.Lister()}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Only nodes in the "Ready" condition with status == "True" are schedulable
0000000000000000000000000000000000000000;;		nodeInformer.Informer().AddEventHandlerWithResyncPeriod(
0000000000000000000000000000000000000000;;			cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;				AddFunc:    c.addNodeToCache,
0000000000000000000000000000000000000000;;				UpdateFunc: c.updateNodeInCache,
0000000000000000000000000000000000000000;;				DeleteFunc: c.deleteNodeFromCache,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			0,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		c.nodeLister = nodeInformer.Lister()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(harryz) need to fill all the handlers here and below for equivalence cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetNodeStore provides the cache to the nodes, mostly internal use, but may also be called by mock-tests.
0000000000000000000000000000000000000000;;	func (c *ConfigFactory) GetNodeLister() corelisters.NodeLister {
0000000000000000000000000000000000000000;;		return c.nodeLister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ConfigFactory) GetHardPodAffinitySymmetricWeight() int {
0000000000000000000000000000000000000000;;		return c.hardPodAffinitySymmetricWeight
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ConfigFactory) GetSchedulerName() string {
0000000000000000000000000000000000000000;;		return f.schedulerName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetClient provides a kubernetes client, mostly internal use, but may also be called by mock-tests.
0000000000000000000000000000000000000000;;	func (f *ConfigFactory) GetClient() clientset.Interface {
0000000000000000000000000000000000000000;;		return f.client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetScheduledPodListerIndexer provides a pod lister, mostly internal use, but may also be called by mock-tests.
0000000000000000000000000000000000000000;;	func (c *ConfigFactory) GetScheduledPodLister() corelisters.PodLister {
0000000000000000000000000000000000000000;;		return c.scheduledPodLister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(resouer) need to update all the handlers here and below for equivalence cache
0000000000000000000000000000000000000000;;	func (c *ConfigFactory) addPodToCache(obj interface{}) {
0000000000000000000000000000000000000000;;		pod, ok := obj.(*v1.Pod)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.Errorf("cannot convert to *v1.Pod: %v", obj)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := c.schedulerCache.AddPod(pod); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("scheduler cache AddPod failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ConfigFactory) updatePodInCache(oldObj, newObj interface{}) {
0000000000000000000000000000000000000000;;		oldPod, ok := oldObj.(*v1.Pod)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.Errorf("cannot convert oldObj to *v1.Pod: %v", oldObj)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newPod, ok := newObj.(*v1.Pod)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.Errorf("cannot convert newObj to *v1.Pod: %v", newObj)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := c.schedulerCache.UpdatePod(oldPod, newPod); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("scheduler cache UpdatePod failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ConfigFactory) deletePodFromCache(obj interface{}) {
0000000000000000000000000000000000000000;;		var pod *v1.Pod
0000000000000000000000000000000000000000;;		switch t := obj.(type) {
0000000000000000000000000000000000000000;;		case *v1.Pod:
0000000000000000000000000000000000000000;;			pod = t
0000000000000000000000000000000000000000;;		case cache.DeletedFinalStateUnknown:
0000000000000000000000000000000000000000;;			var ok bool
0000000000000000000000000000000000000000;;			pod, ok = t.Obj.(*v1.Pod)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				glog.Errorf("cannot convert to *v1.Pod: %v", t.Obj)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			glog.Errorf("cannot convert to *v1.Pod: %v", t)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := c.schedulerCache.RemovePod(pod); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("scheduler cache RemovePod failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ConfigFactory) addNodeToCache(obj interface{}) {
0000000000000000000000000000000000000000;;		node, ok := obj.(*v1.Node)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.Errorf("cannot convert to *v1.Node: %v", obj)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := c.schedulerCache.AddNode(node); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("scheduler cache AddNode failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ConfigFactory) updateNodeInCache(oldObj, newObj interface{}) {
0000000000000000000000000000000000000000;;		oldNode, ok := oldObj.(*v1.Node)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.Errorf("cannot convert oldObj to *v1.Node: %v", oldObj)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newNode, ok := newObj.(*v1.Node)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.Errorf("cannot convert newObj to *v1.Node: %v", newObj)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := c.schedulerCache.UpdateNode(oldNode, newNode); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("scheduler cache UpdateNode failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ConfigFactory) deleteNodeFromCache(obj interface{}) {
0000000000000000000000000000000000000000;;		var node *v1.Node
0000000000000000000000000000000000000000;;		switch t := obj.(type) {
0000000000000000000000000000000000000000;;		case *v1.Node:
0000000000000000000000000000000000000000;;			node = t
0000000000000000000000000000000000000000;;		case cache.DeletedFinalStateUnknown:
0000000000000000000000000000000000000000;;			var ok bool
0000000000000000000000000000000000000000;;			node, ok = t.Obj.(*v1.Node)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				glog.Errorf("cannot convert to *v1.Node: %v", t.Obj)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			glog.Errorf("cannot convert to *v1.Node: %v", t)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := c.schedulerCache.RemoveNode(node); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("scheduler cache RemoveNode failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create creates a scheduler with the default algorithm provider.
0000000000000000000000000000000000000000;;	func (f *ConfigFactory) Create() (*scheduler.Config, error) {
0000000000000000000000000000000000000000;;		return f.CreateFromProvider(DefaultProvider)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates a scheduler from the name of a registered algorithm provider.
0000000000000000000000000000000000000000;;	func (f *ConfigFactory) CreateFromProvider(providerName string) (*scheduler.Config, error) {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Creating scheduler from algorithm provider '%v'", providerName)
0000000000000000000000000000000000000000;;		provider, err := GetAlgorithmProvider(providerName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.CreateFromKeys(provider.FitPredicateKeys, provider.PriorityFunctionKeys, []algorithm.SchedulerExtender{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates a scheduler from the configuration file
0000000000000000000000000000000000000000;;	func (f *ConfigFactory) CreateFromConfig(policy schedulerapi.Policy) (*scheduler.Config, error) {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Creating scheduler from configuration: %v", policy)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// validate the policy configuration
0000000000000000000000000000000000000000;;		if err := validation.ValidatePolicy(policy); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		predicateKeys := sets.NewString()
0000000000000000000000000000000000000000;;		for _, predicate := range policy.Predicates {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Registering predicate: %s", predicate.Name)
0000000000000000000000000000000000000000;;			predicateKeys.Insert(RegisterCustomFitPredicate(predicate))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		priorityKeys := sets.NewString()
0000000000000000000000000000000000000000;;		for _, priority := range policy.Priorities {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Registering priority: %s", priority.Name)
0000000000000000000000000000000000000000;;			priorityKeys.Insert(RegisterCustomPriorityFunction(priority))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extenders := make([]algorithm.SchedulerExtender, 0)
0000000000000000000000000000000000000000;;		if len(policy.ExtenderConfigs) != 0 {
0000000000000000000000000000000000000000;;			for ii := range policy.ExtenderConfigs {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Creating extender with config %+v", policy.ExtenderConfigs[ii])
0000000000000000000000000000000000000000;;				if extender, err := core.NewHTTPExtender(&policy.ExtenderConfigs[ii]); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					extenders = append(extenders, extender)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Providing HardPodAffinitySymmetricWeight in the policy config is the new and preferred way of providing the value.
0000000000000000000000000000000000000000;;		// Give it higher precedence than scheduler CLI configuration when it is provided.
0000000000000000000000000000000000000000;;		if policy.HardPodAffinitySymmetricWeight != 0 {
0000000000000000000000000000000000000000;;			f.hardPodAffinitySymmetricWeight = policy.HardPodAffinitySymmetricWeight
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.CreateFromKeys(predicateKeys, priorityKeys, extenders)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getBinder returns an extender that supports bind or a default binder.
0000000000000000000000000000000000000000;;	func (f *ConfigFactory) getBinder(extenders []algorithm.SchedulerExtender) scheduler.Binder {
0000000000000000000000000000000000000000;;		for i := range extenders {
0000000000000000000000000000000000000000;;			if extenders[i].IsBinder() {
0000000000000000000000000000000000000000;;				return extenders[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &binder{f.client}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates a scheduler from a set of registered fit predicate keys and priority keys.
0000000000000000000000000000000000000000;;	func (f *ConfigFactory) CreateFromKeys(predicateKeys, priorityKeys sets.String, extenders []algorithm.SchedulerExtender) (*scheduler.Config, error) {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Creating scheduler with fit predicates '%v' and priority functions '%v", predicateKeys, priorityKeys)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.GetHardPodAffinitySymmetricWeight() < 1 || f.GetHardPodAffinitySymmetricWeight() > 100 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid hardPodAffinitySymmetricWeight: %d, must be in the range 1-100", f.GetHardPodAffinitySymmetricWeight())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		predicateFuncs, err := f.GetPredicates(predicateKeys)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		priorityConfigs, err := f.GetPriorityFunctionConfigs(priorityKeys)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		priorityMetaProducer, err := f.GetPriorityMetadataProducer()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		predicateMetaProducer, err := f.GetPredicateMetadataProducer()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(resouer) use equivalence cache instead of nil here when #36238 get merged
0000000000000000000000000000000000000000;;		algo := core.NewGenericScheduler(f.schedulerCache, nil, predicateFuncs, predicateMetaProducer, priorityConfigs, priorityMetaProducer, extenders)
0000000000000000000000000000000000000000;;		podBackoff := util.CreateDefaultPodBackoff()
0000000000000000000000000000000000000000;;		return &scheduler.Config{
0000000000000000000000000000000000000000;;			SchedulerCache: f.schedulerCache,
0000000000000000000000000000000000000000;;			// The scheduler only needs to consider schedulable nodes.
0000000000000000000000000000000000000000;;			NodeLister:          &nodePredicateLister{f.nodeLister},
0000000000000000000000000000000000000000;;			Algorithm:           algo,
0000000000000000000000000000000000000000;;			Binder:              f.getBinder(extenders),
0000000000000000000000000000000000000000;;			PodConditionUpdater: &podConditionUpdater{f.client},
0000000000000000000000000000000000000000;;			WaitForCacheSync: func() bool {
0000000000000000000000000000000000000000;;				return cache.WaitForCacheSync(f.StopEverything, f.scheduledPodsHasSynced)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			NextPod: func() *v1.Pod {
0000000000000000000000000000000000000000;;				return f.getNextPod()
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Error:          f.MakeDefaultErrorFunc(podBackoff, f.podQueue),
0000000000000000000000000000000000000000;;			StopEverything: f.StopEverything,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nodePredicateLister struct {
0000000000000000000000000000000000000000;;		corelisters.NodeLister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *nodePredicateLister) List() ([]*v1.Node, error) {
0000000000000000000000000000000000000000;;		return n.ListWithPredicate(getNodeConditionPredicate())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ConfigFactory) GetPriorityFunctionConfigs(priorityKeys sets.String) ([]algorithm.PriorityConfig, error) {
0000000000000000000000000000000000000000;;		pluginArgs, err := f.getPluginArgs()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return getPriorityFunctionConfigs(priorityKeys, *pluginArgs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ConfigFactory) GetPriorityMetadataProducer() (algorithm.MetadataProducer, error) {
0000000000000000000000000000000000000000;;		pluginArgs, err := f.getPluginArgs()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return getPriorityMetadataProducer(*pluginArgs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ConfigFactory) GetPredicateMetadataProducer() (algorithm.MetadataProducer, error) {
0000000000000000000000000000000000000000;;		pluginArgs, err := f.getPluginArgs()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return getPredicateMetadataProducer(*pluginArgs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ConfigFactory) GetPredicates(predicateKeys sets.String) (map[string]algorithm.FitPredicate, error) {
0000000000000000000000000000000000000000;;		pluginArgs, err := f.getPluginArgs()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return getFitPredicateFunctions(predicateKeys, *pluginArgs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ConfigFactory) getPluginArgs() (*PluginFactoryArgs, error) {
0000000000000000000000000000000000000000;;		return &PluginFactoryArgs{
0000000000000000000000000000000000000000;;			PodLister:         f.podLister,
0000000000000000000000000000000000000000;;			ServiceLister:     f.serviceLister,
0000000000000000000000000000000000000000;;			ControllerLister:  f.controllerLister,
0000000000000000000000000000000000000000;;			ReplicaSetLister:  f.replicaSetLister,
0000000000000000000000000000000000000000;;			StatefulSetLister: f.statefulSetLister,
0000000000000000000000000000000000000000;;			// All fit predicates only need to consider schedulable nodes.
0000000000000000000000000000000000000000;;			NodeLister: &nodePredicateLister{f.nodeLister},
0000000000000000000000000000000000000000;;			NodeInfo:   &predicates.CachedNodeInfo{NodeLister: f.nodeLister},
0000000000000000000000000000000000000000;;			PVInfo:     &predicates.CachedPersistentVolumeInfo{PersistentVolumeLister: f.pVLister},
0000000000000000000000000000000000000000;;			PVCInfo:    &predicates.CachedPersistentVolumeClaimInfo{PersistentVolumeClaimLister: f.pVCLister},
0000000000000000000000000000000000000000;;			HardPodAffinitySymmetricWeight: f.hardPodAffinitySymmetricWeight,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ConfigFactory) getNextPod() *v1.Pod {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			pod := cache.Pop(f.podQueue).(*v1.Pod)
0000000000000000000000000000000000000000;;			if f.ResponsibleForPod(pod) {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("About to try and schedule pod %v", pod.Name)
0000000000000000000000000000000000000000;;				return pod
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ConfigFactory) ResponsibleForPod(pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		return f.schedulerName == pod.Spec.SchedulerName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNodeConditionPredicate() corelisters.NodeConditionPredicate {
0000000000000000000000000000000000000000;;		return func(node *v1.Node) bool {
0000000000000000000000000000000000000000;;			for i := range node.Status.Conditions {
0000000000000000000000000000000000000000;;				cond := &node.Status.Conditions[i]
0000000000000000000000000000000000000000;;				// We consider the node for scheduling only when its:
0000000000000000000000000000000000000000;;				// - NodeReady condition status is ConditionTrue,
0000000000000000000000000000000000000000;;				// - NodeOutOfDisk condition status is ConditionFalse,
0000000000000000000000000000000000000000;;				// - NodeNetworkUnavailable condition status is ConditionFalse.
0000000000000000000000000000000000000000;;				if cond.Type == v1.NodeReady && cond.Status != v1.ConditionTrue {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Ignoring node %v with %v condition status %v", node.Name, cond.Type, cond.Status)
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				} else if cond.Type == v1.NodeOutOfDisk && cond.Status != v1.ConditionFalse {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Ignoring node %v with %v condition status %v", node.Name, cond.Type, cond.Status)
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				} else if cond.Type == v1.NodeNetworkUnavailable && cond.Status != v1.ConditionFalse {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Ignoring node %v with %v condition status %v", node.Name, cond.Type, cond.Status)
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Ignore nodes that are marked unschedulable
0000000000000000000000000000000000000000;;			if node.Spec.Unschedulable {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Ignoring node %v since it is unschedulable", node.Name)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unassignedNonTerminatedPod selects pods that are unassigned and non-terminal.
0000000000000000000000000000000000000000;;	func unassignedNonTerminatedPod(pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		if len(pod.Spec.NodeName) != 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pod.Status.Phase == v1.PodSucceeded || pod.Status.Phase == v1.PodFailed {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// assignedNonTerminatedPod selects pods that are assigned and non-terminal (scheduled and running).
0000000000000000000000000000000000000000;;	func assignedNonTerminatedPod(pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		if len(pod.Spec.NodeName) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pod.Status.Phase == v1.PodSucceeded || pod.Status.Phase == v1.PodFailed {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// assignedPodLister filters the pods returned from a PodLister to
0000000000000000000000000000000000000000;;	// only include those that have a node name set.
0000000000000000000000000000000000000000;;	type assignedPodLister struct {
0000000000000000000000000000000000000000;;		corelisters.PodLister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List lists all Pods in the indexer for a given namespace.
0000000000000000000000000000000000000000;;	func (l assignedPodLister) List(selector labels.Selector) ([]*v1.Pod, error) {
0000000000000000000000000000000000000000;;		list, err := l.PodLister.List(selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		filtered := make([]*v1.Pod, 0, len(list))
0000000000000000000000000000000000000000;;		for _, pod := range list {
0000000000000000000000000000000000000000;;			if len(pod.Spec.NodeName) > 0 {
0000000000000000000000000000000000000000;;				filtered = append(filtered, pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filtered, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List lists all Pods in the indexer for a given namespace.
0000000000000000000000000000000000000000;;	func (l assignedPodLister) Pods(namespace string) corelisters.PodNamespaceLister {
0000000000000000000000000000000000000000;;		return assignedPodNamespaceLister{l.PodLister.Pods(namespace)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// assignedPodNamespaceLister filters the pods returned from a PodNamespaceLister to
0000000000000000000000000000000000000000;;	// only include those that have a node name set.
0000000000000000000000000000000000000000;;	type assignedPodNamespaceLister struct {
0000000000000000000000000000000000000000;;		corelisters.PodNamespaceLister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List lists all Pods in the indexer for a given namespace.
0000000000000000000000000000000000000000;;	func (l assignedPodNamespaceLister) List(selector labels.Selector) (ret []*v1.Pod, err error) {
0000000000000000000000000000000000000000;;		list, err := l.PodNamespaceLister.List(selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		filtered := make([]*v1.Pod, 0, len(list))
0000000000000000000000000000000000000000;;		for _, pod := range list {
0000000000000000000000000000000000000000;;			if len(pod.Spec.NodeName) > 0 {
0000000000000000000000000000000000000000;;				filtered = append(filtered, pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filtered, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get retrieves the Pod from the indexer for a given namespace and name.
0000000000000000000000000000000000000000;;	func (l assignedPodNamespaceLister) Get(name string) (*v1.Pod, error) {
0000000000000000000000000000000000000000;;		pod, err := l.PodNamespaceLister.Get(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pod.Spec.NodeName) > 0 {
0000000000000000000000000000000000000000;;			return pod, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, errors.NewNotFound(schema.GroupResource{Resource: "pods"}, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type podInformer struct {
0000000000000000000000000000000000000000;;		informer cache.SharedIndexInformer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *podInformer) Informer() cache.SharedIndexInformer {
0000000000000000000000000000000000000000;;		return i.informer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *podInformer) Lister() corelisters.PodLister {
0000000000000000000000000000000000000000;;		return corelisters.NewPodLister(i.informer.GetIndexer())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPodInformer creates a shared index informer that returns only non-terminal pods.
0000000000000000000000000000000000000000;;	func NewPodInformer(client clientset.Interface, resyncPeriod time.Duration) coreinformers.PodInformer {
0000000000000000000000000000000000000000;;		selector := fields.ParseSelectorOrDie("status.phase!=" + string(v1.PodSucceeded) + ",status.phase!=" + string(v1.PodFailed))
0000000000000000000000000000000000000000;;		lw := cache.NewListWatchFromClient(client.Core().RESTClient(), "pods", metav1.NamespaceAll, selector)
0000000000000000000000000000000000000000;;		return &podInformer{
0000000000000000000000000000000000000000;;			informer: cache.NewSharedIndexInformer(lw, &v1.Pod{}, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (factory *ConfigFactory) MakeDefaultErrorFunc(backoff *util.PodBackoff, podQueue *cache.FIFO) func(pod *v1.Pod, err error) {
0000000000000000000000000000000000000000;;		return func(pod *v1.Pod, err error) {
0000000000000000000000000000000000000000;;			if err == core.ErrNoNodesAvailable {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Unable to schedule %v %v: no nodes are registered to the cluster; waiting", pod.Namespace, pod.Name)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if _, ok := err.(*core.FitError); ok {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Unable to schedule %v %v: no fit: %v; waiting", pod.Namespace, pod.Name, err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					glog.Errorf("Error scheduling %v %v: %v; retrying", pod.Namespace, pod.Name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			backoff.Gc()
0000000000000000000000000000000000000000;;			// Retry asynchronously.
0000000000000000000000000000000000000000;;			// Note that this is extremely rudimentary and we need a more real error handling path.
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;				podID := types.NamespacedName{
0000000000000000000000000000000000000000;;					Namespace: pod.Namespace,
0000000000000000000000000000000000000000;;					Name:      pod.Name,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				entry := backoff.GetEntry(podID)
0000000000000000000000000000000000000000;;				if !entry.TryWait(backoff.MaxDuration()) {
0000000000000000000000000000000000000000;;					glog.Warningf("Request for pod %v already in flight, abandoning", podID)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Get the pod again; it may have changed/been scheduled already.
0000000000000000000000000000000000000000;;				getBackoff := initialGetBackoff
0000000000000000000000000000000000000000;;				for {
0000000000000000000000000000000000000000;;					pod, err := factory.client.Core().Pods(podID.Namespace).Get(podID.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						if len(pod.Spec.NodeName) == 0 {
0000000000000000000000000000000000000000;;							podQueue.AddIfNotPresent(pod)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;						glog.Warningf("A pod %v no longer exists", podID)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					glog.Errorf("Error getting pod %v for retry: %v; retrying...", podID, err)
0000000000000000000000000000000000000000;;					if getBackoff = getBackoff * 2; getBackoff > maximalGetBackoff {
0000000000000000000000000000000000000000;;						getBackoff = maximalGetBackoff
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					time.Sleep(getBackoff)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nodeEnumerator allows a cache.Poller to enumerate items in an v1.NodeList
0000000000000000000000000000000000000000;;	type nodeEnumerator struct {
0000000000000000000000000000000000000000;;		*v1.NodeList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the number of items in the node list.
0000000000000000000000000000000000000000;;	func (ne *nodeEnumerator) Len() int {
0000000000000000000000000000000000000000;;		if ne.NodeList == nil {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(ne.Items)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get returns the item (and ID) with the particular index.
0000000000000000000000000000000000000000;;	func (ne *nodeEnumerator) Get(index int) interface{} {
0000000000000000000000000000000000000000;;		return &ne.Items[index]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type binder struct {
0000000000000000000000000000000000000000;;		Client clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bind just does a POST binding RPC.
0000000000000000000000000000000000000000;;	func (b *binder) Bind(binding *v1.Binding) error {
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Attempting to bind %v to %v", binding.Name, binding.Target.Name)
0000000000000000000000000000000000000000;;		return b.Client.CoreV1().Pods(binding.Namespace).Bind(binding)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type podConditionUpdater struct {
0000000000000000000000000000000000000000;;		Client clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *podConditionUpdater) Update(pod *v1.Pod, condition *v1.PodCondition) error {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Updating pod condition for %s/%s to (%s==%s)", pod.Namespace, pod.Name, condition.Type, condition.Status)
0000000000000000000000000000000000000000;;		if podutil.UpdatePodCondition(&pod.Status, condition) {
0000000000000000000000000000000000000000;;			_, err := p.Client.Core().Pods(pod.Namespace).UpdateStatus(pod)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
