0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
c6510882ccd910f8fdd42265cf1279227d269677;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package factory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm/predicates"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm/priorities"
0000000000000000000000000000000000000000;;		schedulerapi "k8s.io/kubernetes/plugin/pkg/scheduler/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PluginFactoryArgs are passed to all plugin factory functions.
0000000000000000000000000000000000000000;;	type PluginFactoryArgs struct {
0000000000000000000000000000000000000000;;		PodLister                      algorithm.PodLister
0000000000000000000000000000000000000000;;		ServiceLister                  algorithm.ServiceLister
0000000000000000000000000000000000000000;;		ControllerLister               algorithm.ControllerLister
0000000000000000000000000000000000000000;;		ReplicaSetLister               algorithm.ReplicaSetLister
0000000000000000000000000000000000000000;;		StatefulSetLister              algorithm.StatefulSetLister
0000000000000000000000000000000000000000;;		NodeLister                     algorithm.NodeLister
0000000000000000000000000000000000000000;;		NodeInfo                       predicates.NodeInfo
0000000000000000000000000000000000000000;;		PVInfo                         predicates.PersistentVolumeInfo
0000000000000000000000000000000000000000;;		PVCInfo                        predicates.PersistentVolumeClaimInfo
0000000000000000000000000000000000000000;;		HardPodAffinitySymmetricWeight int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MetadataProducerFactory produces MetadataProducer from the given args.
0000000000000000000000000000000000000000;;	type MetadataProducerFactory func(PluginFactoryArgs) algorithm.MetadataProducer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A FitPredicateFactory produces a FitPredicate from the given args.
0000000000000000000000000000000000000000;;	type FitPredicateFactory func(PluginFactoryArgs) algorithm.FitPredicate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DEPRECATED
0000000000000000000000000000000000000000;;	// Use Map-Reduce pattern for priority functions.
0000000000000000000000000000000000000000;;	// A PriorityFunctionFactory produces a PriorityConfig from the given args.
0000000000000000000000000000000000000000;;	type PriorityFunctionFactory func(PluginFactoryArgs) algorithm.PriorityFunction
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A PriorityFunctionFactory produces map & reduce priority functions
0000000000000000000000000000000000000000;;	// from a given args.
0000000000000000000000000000000000000000;;	// FIXME: Rename to PriorityFunctionFactory.
0000000000000000000000000000000000000000;;	type PriorityFunctionFactory2 func(PluginFactoryArgs) (algorithm.PriorityMapFunction, algorithm.PriorityReduceFunction)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A PriorityConfigFactory produces a PriorityConfig from the given function and weight
0000000000000000000000000000000000000000;;	type PriorityConfigFactory struct {
0000000000000000000000000000000000000000;;		Function          PriorityFunctionFactory
0000000000000000000000000000000000000000;;		MapReduceFunction PriorityFunctionFactory2
0000000000000000000000000000000000000000;;		Weight            int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		schedulerFactoryMutex sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// maps that hold registered algorithm types
0000000000000000000000000000000000000000;;		fitPredicateMap      = make(map[string]FitPredicateFactory)
0000000000000000000000000000000000000000;;		priorityFunctionMap  = make(map[string]PriorityConfigFactory)
0000000000000000000000000000000000000000;;		algorithmProviderMap = make(map[string]AlgorithmProviderConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Registered metadata producers
0000000000000000000000000000000000000000;;		priorityMetadataProducer  MetadataProducerFactory
0000000000000000000000000000000000000000;;		predicateMetadataProducer MetadataProducerFactory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get equivalence pod function
0000000000000000000000000000000000000000;;		getEquivalencePodFunc algorithm.GetEquivalencePodFunc
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DefaultProvider = "DefaultProvider"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AlgorithmProviderConfig struct {
0000000000000000000000000000000000000000;;		FitPredicateKeys     sets.String
0000000000000000000000000000000000000000;;		PriorityFunctionKeys sets.String
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterFitPredicate registers a fit predicate with the algorithm
0000000000000000000000000000000000000000;;	// registry. Returns the name with which the predicate was registered.
0000000000000000000000000000000000000000;;	func RegisterFitPredicate(name string, predicate algorithm.FitPredicate) string {
0000000000000000000000000000000000000000;;		return RegisterFitPredicateFactory(name, func(PluginFactoryArgs) algorithm.FitPredicate { return predicate })
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterFitPredicateFactory registers a fit predicate factory with the
0000000000000000000000000000000000000000;;	// algorithm registry. Returns the name with which the predicate was registered.
0000000000000000000000000000000000000000;;	func RegisterFitPredicateFactory(name string, predicateFactory FitPredicateFactory) string {
0000000000000000000000000000000000000000;;		schedulerFactoryMutex.Lock()
0000000000000000000000000000000000000000;;		defer schedulerFactoryMutex.Unlock()
0000000000000000000000000000000000000000;;		validateAlgorithmNameOrDie(name)
0000000000000000000000000000000000000000;;		fitPredicateMap[name] = predicateFactory
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterCustomFitPredicate registers a custom fit predicate with the algorithm registry.
0000000000000000000000000000000000000000;;	// Returns the name, with which the predicate was registered.
0000000000000000000000000000000000000000;;	func RegisterCustomFitPredicate(policy schedulerapi.PredicatePolicy) string {
0000000000000000000000000000000000000000;;		var predicateFactory FitPredicateFactory
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validatePredicateOrDie(policy)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// generate the predicate function, if a custom type is requested
0000000000000000000000000000000000000000;;		if policy.Argument != nil {
0000000000000000000000000000000000000000;;			if policy.Argument.ServiceAffinity != nil {
0000000000000000000000000000000000000000;;				predicateFactory = func(args PluginFactoryArgs) algorithm.FitPredicate {
0000000000000000000000000000000000000000;;					predicate, precomputationFunction := predicates.NewServiceAffinityPredicate(
0000000000000000000000000000000000000000;;						args.PodLister,
0000000000000000000000000000000000000000;;						args.ServiceLister,
0000000000000000000000000000000000000000;;						args.NodeInfo,
0000000000000000000000000000000000000000;;						policy.Argument.ServiceAffinity.Labels,
0000000000000000000000000000000000000000;;					)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Once we generate the predicate we should also Register the Precomputation
0000000000000000000000000000000000000000;;					predicates.RegisterPredicatePrecomputation(policy.Name, precomputationFunction)
0000000000000000000000000000000000000000;;					return predicate
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if policy.Argument.LabelsPresence != nil {
0000000000000000000000000000000000000000;;				predicateFactory = func(args PluginFactoryArgs) algorithm.FitPredicate {
0000000000000000000000000000000000000000;;					return predicates.NewNodeLabelPredicate(
0000000000000000000000000000000000000000;;						policy.Argument.LabelsPresence.Labels,
0000000000000000000000000000000000000000;;						policy.Argument.LabelsPresence.Presence,
0000000000000000000000000000000000000000;;					)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if predicateFactory, ok = fitPredicateMap[policy.Name]; ok {
0000000000000000000000000000000000000000;;			// checking to see if a pre-defined predicate is requested
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Predicate type %s already registered, reusing.", policy.Name)
0000000000000000000000000000000000000000;;			return policy.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if predicateFactory == nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Invalid configuration: Predicate type not found for %s", policy.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return RegisterFitPredicateFactory(policy.Name, predicateFactory)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsFitPredicateRegistered is useful for testing providers.
0000000000000000000000000000000000000000;;	func IsFitPredicateRegistered(name string) bool {
0000000000000000000000000000000000000000;;		schedulerFactoryMutex.Lock()
0000000000000000000000000000000000000000;;		defer schedulerFactoryMutex.Unlock()
0000000000000000000000000000000000000000;;		_, ok := fitPredicateMap[name]
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RegisterPriorityMetadataProducerFactory(factory MetadataProducerFactory) {
0000000000000000000000000000000000000000;;		schedulerFactoryMutex.Lock()
0000000000000000000000000000000000000000;;		defer schedulerFactoryMutex.Unlock()
0000000000000000000000000000000000000000;;		priorityMetadataProducer = factory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RegisterPredicateMetadataProducerFactory(factory MetadataProducerFactory) {
0000000000000000000000000000000000000000;;		schedulerFactoryMutex.Lock()
0000000000000000000000000000000000000000;;		defer schedulerFactoryMutex.Unlock()
0000000000000000000000000000000000000000;;		predicateMetadataProducer = factory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DEPRECATED
0000000000000000000000000000000000000000;;	// Use Map-Reduce pattern for priority functions.
0000000000000000000000000000000000000000;;	// Registers a priority function with the algorithm registry. Returns the name,
0000000000000000000000000000000000000000;;	// with which the function was registered.
0000000000000000000000000000000000000000;;	func RegisterPriorityFunction(name string, function algorithm.PriorityFunction, weight int) string {
0000000000000000000000000000000000000000;;		return RegisterPriorityConfigFactory(name, PriorityConfigFactory{
0000000000000000000000000000000000000000;;			Function: func(PluginFactoryArgs) algorithm.PriorityFunction {
0000000000000000000000000000000000000000;;				return function
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Weight: weight,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterPriorityFunction2 registers a priority function with the algorithm registry. Returns the name,
0000000000000000000000000000000000000000;;	// with which the function was registered.
0000000000000000000000000000000000000000;;	// FIXME: Rename to PriorityFunctionFactory.
0000000000000000000000000000000000000000;;	func RegisterPriorityFunction2(
0000000000000000000000000000000000000000;;		name string,
0000000000000000000000000000000000000000;;		mapFunction algorithm.PriorityMapFunction,
0000000000000000000000000000000000000000;;		reduceFunction algorithm.PriorityReduceFunction,
0000000000000000000000000000000000000000;;		weight int) string {
0000000000000000000000000000000000000000;;		return RegisterPriorityConfigFactory(name, PriorityConfigFactory{
0000000000000000000000000000000000000000;;			MapReduceFunction: func(PluginFactoryArgs) (algorithm.PriorityMapFunction, algorithm.PriorityReduceFunction) {
0000000000000000000000000000000000000000;;				return mapFunction, reduceFunction
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Weight: weight,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RegisterPriorityConfigFactory(name string, pcf PriorityConfigFactory) string {
0000000000000000000000000000000000000000;;		schedulerFactoryMutex.Lock()
0000000000000000000000000000000000000000;;		defer schedulerFactoryMutex.Unlock()
0000000000000000000000000000000000000000;;		validateAlgorithmNameOrDie(name)
0000000000000000000000000000000000000000;;		priorityFunctionMap[name] = pcf
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterCustomPriorityFunction registers a custom priority function with the algorithm registry.
0000000000000000000000000000000000000000;;	// Returns the name, with which the priority function was registered.
0000000000000000000000000000000000000000;;	func RegisterCustomPriorityFunction(policy schedulerapi.PriorityPolicy) string {
0000000000000000000000000000000000000000;;		var pcf *PriorityConfigFactory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validatePriorityOrDie(policy)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// generate the priority function, if a custom priority is requested
0000000000000000000000000000000000000000;;		if policy.Argument != nil {
0000000000000000000000000000000000000000;;			if policy.Argument.ServiceAntiAffinity != nil {
0000000000000000000000000000000000000000;;				pcf = &PriorityConfigFactory{
0000000000000000000000000000000000000000;;					Function: func(args PluginFactoryArgs) algorithm.PriorityFunction {
0000000000000000000000000000000000000000;;						return priorities.NewServiceAntiAffinityPriority(
0000000000000000000000000000000000000000;;							args.PodLister,
0000000000000000000000000000000000000000;;							args.ServiceLister,
0000000000000000000000000000000000000000;;							policy.Argument.ServiceAntiAffinity.Label,
0000000000000000000000000000000000000000;;						)
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Weight: policy.Weight,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if policy.Argument.LabelPreference != nil {
0000000000000000000000000000000000000000;;				pcf = &PriorityConfigFactory{
0000000000000000000000000000000000000000;;					MapReduceFunction: func(args PluginFactoryArgs) (algorithm.PriorityMapFunction, algorithm.PriorityReduceFunction) {
0000000000000000000000000000000000000000;;						return priorities.NewNodeLabelPriority(
0000000000000000000000000000000000000000;;							policy.Argument.LabelPreference.Label,
0000000000000000000000000000000000000000;;							policy.Argument.LabelPreference.Presence,
0000000000000000000000000000000000000000;;						)
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Weight: policy.Weight,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if existingPcf, ok := priorityFunctionMap[policy.Name]; ok {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Priority type %s already registered, reusing.", policy.Name)
0000000000000000000000000000000000000000;;			// set/update the weight based on the policy
0000000000000000000000000000000000000000;;			pcf = &PriorityConfigFactory{
0000000000000000000000000000000000000000;;				Function:          existingPcf.Function,
0000000000000000000000000000000000000000;;				MapReduceFunction: existingPcf.MapReduceFunction,
0000000000000000000000000000000000000000;;				Weight:            policy.Weight,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pcf == nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Invalid configuration: Priority type not found for %s", policy.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return RegisterPriorityConfigFactory(policy.Name, *pcf)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RegisterGetEquivalencePodFunction(equivalenceFunc algorithm.GetEquivalencePodFunc) {
0000000000000000000000000000000000000000;;		getEquivalencePodFunc = equivalenceFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPriorityFunctionRegistered is useful for testing providers.
0000000000000000000000000000000000000000;;	func IsPriorityFunctionRegistered(name string) bool {
0000000000000000000000000000000000000000;;		schedulerFactoryMutex.Lock()
0000000000000000000000000000000000000000;;		defer schedulerFactoryMutex.Unlock()
0000000000000000000000000000000000000000;;		_, ok := priorityFunctionMap[name]
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterAlgorithmProvider registers a new algorithm provider with the algorithm registry. This should
0000000000000000000000000000000000000000;;	// be called from the init function in a provider plugin.
0000000000000000000000000000000000000000;;	func RegisterAlgorithmProvider(name string, predicateKeys, priorityKeys sets.String) string {
0000000000000000000000000000000000000000;;		schedulerFactoryMutex.Lock()
0000000000000000000000000000000000000000;;		defer schedulerFactoryMutex.Unlock()
0000000000000000000000000000000000000000;;		validateAlgorithmNameOrDie(name)
0000000000000000000000000000000000000000;;		algorithmProviderMap[name] = AlgorithmProviderConfig{
0000000000000000000000000000000000000000;;			FitPredicateKeys:     predicateKeys,
0000000000000000000000000000000000000000;;			PriorityFunctionKeys: priorityKeys,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAlgorithmProvider should not be used to modify providers. It is publicly visible for testing.
0000000000000000000000000000000000000000;;	func GetAlgorithmProvider(name string) (*AlgorithmProviderConfig, error) {
0000000000000000000000000000000000000000;;		schedulerFactoryMutex.Lock()
0000000000000000000000000000000000000000;;		defer schedulerFactoryMutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		provider, ok := algorithmProviderMap[name]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("plugin %q has not been registered", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &provider, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getFitPredicateFunctions(names sets.String, args PluginFactoryArgs) (map[string]algorithm.FitPredicate, error) {
0000000000000000000000000000000000000000;;		schedulerFactoryMutex.Lock()
0000000000000000000000000000000000000000;;		defer schedulerFactoryMutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		predicates := map[string]algorithm.FitPredicate{}
0000000000000000000000000000000000000000;;		for _, name := range names.List() {
0000000000000000000000000000000000000000;;			factory, ok := fitPredicateMap[name]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Invalid predicate name %q specified - no corresponding function found", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			predicates[name] = factory(args)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return predicates, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPriorityMetadataProducer(args PluginFactoryArgs) (algorithm.MetadataProducer, error) {
0000000000000000000000000000000000000000;;		schedulerFactoryMutex.Lock()
0000000000000000000000000000000000000000;;		defer schedulerFactoryMutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if priorityMetadataProducer == nil {
0000000000000000000000000000000000000000;;			return algorithm.EmptyMetadataProducer, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return priorityMetadataProducer(args), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPredicateMetadataProducer(args PluginFactoryArgs) (algorithm.MetadataProducer, error) {
0000000000000000000000000000000000000000;;		schedulerFactoryMutex.Lock()
0000000000000000000000000000000000000000;;		defer schedulerFactoryMutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if predicateMetadataProducer == nil {
0000000000000000000000000000000000000000;;			return algorithm.EmptyMetadataProducer, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return predicateMetadataProducer(args), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPriorityFunctionConfigs(names sets.String, args PluginFactoryArgs) ([]algorithm.PriorityConfig, error) {
0000000000000000000000000000000000000000;;		schedulerFactoryMutex.Lock()
0000000000000000000000000000000000000000;;		defer schedulerFactoryMutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configs := []algorithm.PriorityConfig{}
0000000000000000000000000000000000000000;;		for _, name := range names.List() {
0000000000000000000000000000000000000000;;			factory, ok := priorityFunctionMap[name]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Invalid priority name %s specified - no corresponding function found", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if factory.Function != nil {
0000000000000000000000000000000000000000;;				configs = append(configs, algorithm.PriorityConfig{
0000000000000000000000000000000000000000;;					Function: factory.Function(args),
0000000000000000000000000000000000000000;;					Weight:   factory.Weight,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				mapFunction, reduceFunction := factory.MapReduceFunction(args)
0000000000000000000000000000000000000000;;				configs = append(configs, algorithm.PriorityConfig{
0000000000000000000000000000000000000000;;					Map:    mapFunction,
0000000000000000000000000000000000000000;;					Reduce: reduceFunction,
0000000000000000000000000000000000000000;;					Weight: factory.Weight,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := validateSelectedConfigs(configs); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return configs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateSelectedConfigs validates the config weights to avoid the overflow.
0000000000000000000000000000000000000000;;	func validateSelectedConfigs(configs []algorithm.PriorityConfig) error {
0000000000000000000000000000000000000000;;		var totalPriority int
0000000000000000000000000000000000000000;;		for _, config := range configs {
0000000000000000000000000000000000000000;;			// Checks totalPriority against MaxTotalPriority to avoid overflow
0000000000000000000000000000000000000000;;			if config.Weight*schedulerapi.MaxPriority > schedulerapi.MaxTotalPriority-totalPriority {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Total priority of priority functions has overflown")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			totalPriority += config.Weight * schedulerapi.MaxPriority
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var validName = regexp.MustCompile("^[a-zA-Z0-9]([-a-zA-Z0-9]*[a-zA-Z0-9])$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateAlgorithmNameOrDie(name string) {
0000000000000000000000000000000000000000;;		if !validName.MatchString(name) {
0000000000000000000000000000000000000000;;			glog.Fatalf("Algorithm name %v does not match the name validation regexp \"%v\".", name, validName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validatePredicateOrDie(predicate schedulerapi.PredicatePolicy) {
0000000000000000000000000000000000000000;;		if predicate.Argument != nil {
0000000000000000000000000000000000000000;;			numArgs := 0
0000000000000000000000000000000000000000;;			if predicate.Argument.ServiceAffinity != nil {
0000000000000000000000000000000000000000;;				numArgs++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if predicate.Argument.LabelsPresence != nil {
0000000000000000000000000000000000000000;;				numArgs++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if numArgs != 1 {
0000000000000000000000000000000000000000;;				glog.Fatalf("Exactly 1 predicate argument is required, numArgs: %v, Predicate: %s", numArgs, predicate.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validatePriorityOrDie(priority schedulerapi.PriorityPolicy) {
0000000000000000000000000000000000000000;;		if priority.Argument != nil {
0000000000000000000000000000000000000000;;			numArgs := 0
0000000000000000000000000000000000000000;;			if priority.Argument.ServiceAntiAffinity != nil {
0000000000000000000000000000000000000000;;				numArgs++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if priority.Argument.LabelPreference != nil {
0000000000000000000000000000000000000000;;				numArgs++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if numArgs != 1 {
0000000000000000000000000000000000000000;;				glog.Fatalf("Exactly 1 priority argument is required, numArgs: %v, Priority: %s", numArgs, priority.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ListRegisteredFitPredicates() []string {
0000000000000000000000000000000000000000;;		schedulerFactoryMutex.Lock()
0000000000000000000000000000000000000000;;		defer schedulerFactoryMutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		names := []string{}
0000000000000000000000000000000000000000;;		for name := range fitPredicateMap {
0000000000000000000000000000000000000000;;			names = append(names, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return names
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ListRegisteredPriorityFunctions() []string {
0000000000000000000000000000000000000000;;		schedulerFactoryMutex.Lock()
0000000000000000000000000000000000000000;;		defer schedulerFactoryMutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		names := []string{}
0000000000000000000000000000000000000000;;		for name := range priorityFunctionMap {
0000000000000000000000000000000000000000;;			names = append(names, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return names
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListAlgorithmProviders is called when listing all available algorithm providers in `kube-scheduler --help`
0000000000000000000000000000000000000000;;	func ListAlgorithmProviders() string {
0000000000000000000000000000000000000000;;		var availableAlgorithmProviders []string
0000000000000000000000000000000000000000;;		for name := range algorithmProviderMap {
0000000000000000000000000000000000000000;;			availableAlgorithmProviders = append(availableAlgorithmProviders, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(availableAlgorithmProviders)
0000000000000000000000000000000000000000;;		return strings.Join(availableAlgorithmProviders, " | ")
0000000000000000000000000000000000000000;;	}
