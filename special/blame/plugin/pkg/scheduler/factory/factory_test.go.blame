0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
ac5aa537bc547bb5e6296123dea26dfd4463b051;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package factory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		apitesting "k8s.io/kubernetes/pkg/api/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm"
0000000000000000000000000000000000000000;;		schedulerapi "k8s.io/kubernetes/plugin/pkg/scheduler/api"
0000000000000000000000000000000000000000;;		latestschedulerapi "k8s.io/kubernetes/plugin/pkg/scheduler/api/latest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/schedulercache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreate(t *testing.T) {
0000000000000000000000000000000000000000;;		handler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode:   500,
0000000000000000000000000000000000000000;;			ResponseBody: "",
0000000000000000000000000000000000000000;;			T:            t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		server := httptest.NewServer(&handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := clientset.NewForConfigOrDie(&restclient.Config{Host: server.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(client, 0)
0000000000000000000000000000000000000000;;		factory := NewConfigFactory(
0000000000000000000000000000000000000000;;			v1.DefaultSchedulerName,
0000000000000000000000000000000000000000;;			client,
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumeClaims(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().ReplicationControllers(),
0000000000000000000000000000000000000000;;			informerFactory.Extensions().V1beta1().ReplicaSets(),
0000000000000000000000000000000000000000;;			informerFactory.Apps().V1beta1().StatefulSets(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Services(),
0000000000000000000000000000000000000000;;			v1.DefaultHardPodAffinitySymmetricWeight,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		factory.Create()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test configures a scheduler from a policies defined in a file
0000000000000000000000000000000000000000;;	// It combines some configurable predicate/priorities with some pre-defined ones
0000000000000000000000000000000000000000;;	func TestCreateFromConfig(t *testing.T) {
0000000000000000000000000000000000000000;;		var configData []byte
0000000000000000000000000000000000000000;;		var policy schedulerapi.Policy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode:   500,
0000000000000000000000000000000000000000;;			ResponseBody: "",
0000000000000000000000000000000000000000;;			T:            t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		server := httptest.NewServer(&handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := clientset.NewForConfigOrDie(&restclient.Config{Host: server.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(client, 0)
0000000000000000000000000000000000000000;;		factory := NewConfigFactory(
0000000000000000000000000000000000000000;;			v1.DefaultSchedulerName,
0000000000000000000000000000000000000000;;			client,
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumeClaims(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().ReplicationControllers(),
0000000000000000000000000000000000000000;;			informerFactory.Extensions().V1beta1().ReplicaSets(),
0000000000000000000000000000000000000000;;			informerFactory.Apps().V1beta1().StatefulSets(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Services(),
0000000000000000000000000000000000000000;;			v1.DefaultHardPodAffinitySymmetricWeight,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pre-register some predicate and priority functions
0000000000000000000000000000000000000000;;		RegisterFitPredicate("PredicateOne", PredicateOne)
0000000000000000000000000000000000000000;;		RegisterFitPredicate("PredicateTwo", PredicateTwo)
0000000000000000000000000000000000000000;;		RegisterPriorityFunction("PriorityOne", PriorityOne, 1)
0000000000000000000000000000000000000000;;		RegisterPriorityFunction("PriorityTwo", PriorityTwo, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configData = []byte(`{
0000000000000000000000000000000000000000;;			"kind" : "Policy",
0000000000000000000000000000000000000000;;			"apiVersion" : "v1",
0000000000000000000000000000000000000000;;			"predicates" : [
0000000000000000000000000000000000000000;;				{"name" : "TestZoneAffinity", "argument" : {"serviceAffinity" : {"labels" : ["zone"]}}},
0000000000000000000000000000000000000000;;				{"name" : "TestRequireZone", "argument" : {"labelsPresence" : {"labels" : ["zone"], "presence" : true}}},
0000000000000000000000000000000000000000;;				{"name" : "PredicateOne"},
0000000000000000000000000000000000000000;;				{"name" : "PredicateTwo"}
0000000000000000000000000000000000000000;;			],
0000000000000000000000000000000000000000;;			"priorities" : [
0000000000000000000000000000000000000000;;				{"name" : "RackSpread", "weight" : 3, "argument" : {"serviceAntiAffinity" : {"label" : "rack"}}},
0000000000000000000000000000000000000000;;				{"name" : "PriorityOne", "weight" : 2},
0000000000000000000000000000000000000000;;				{"name" : "PriorityTwo", "weight" : 1}		]
0000000000000000000000000000000000000000;;		}`)
0000000000000000000000000000000000000000;;		if err := runtime.DecodeInto(latestschedulerapi.Codec, configData, &policy); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Invalid configuration: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		factory.CreateFromConfig(policy)
0000000000000000000000000000000000000000;;		hpa := factory.GetHardPodAffinitySymmetricWeight()
0000000000000000000000000000000000000000;;		if hpa != v1.DefaultHardPodAffinitySymmetricWeight {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong hardPodAffinitySymmetricWeight, ecpected: %d, got: %d", v1.DefaultHardPodAffinitySymmetricWeight, hpa)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateFromConfigWithHardPodAffinitySymmetricWeight(t *testing.T) {
0000000000000000000000000000000000000000;;		var configData []byte
0000000000000000000000000000000000000000;;		var policy schedulerapi.Policy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode:   500,
0000000000000000000000000000000000000000;;			ResponseBody: "",
0000000000000000000000000000000000000000;;			T:            t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		server := httptest.NewServer(&handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := clientset.NewForConfigOrDie(&restclient.Config{Host: server.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(client, 0)
0000000000000000000000000000000000000000;;		factory := NewConfigFactory(
0000000000000000000000000000000000000000;;			v1.DefaultSchedulerName,
0000000000000000000000000000000000000000;;			client,
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumeClaims(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().ReplicationControllers(),
0000000000000000000000000000000000000000;;			informerFactory.Extensions().V1beta1().ReplicaSets(),
0000000000000000000000000000000000000000;;			informerFactory.Apps().V1beta1().StatefulSets(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Services(),
0000000000000000000000000000000000000000;;			v1.DefaultHardPodAffinitySymmetricWeight,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pre-register some predicate and priority functions
0000000000000000000000000000000000000000;;		RegisterFitPredicate("PredicateOne", PredicateOne)
0000000000000000000000000000000000000000;;		RegisterFitPredicate("PredicateTwo", PredicateTwo)
0000000000000000000000000000000000000000;;		RegisterPriorityFunction("PriorityOne", PriorityOne, 1)
0000000000000000000000000000000000000000;;		RegisterPriorityFunction("PriorityTwo", PriorityTwo, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configData = []byte(`{
0000000000000000000000000000000000000000;;			"kind" : "Policy",
0000000000000000000000000000000000000000;;			"apiVersion" : "v1",
0000000000000000000000000000000000000000;;			"predicates" : [
0000000000000000000000000000000000000000;;				{"name" : "TestZoneAffinity", "argument" : {"serviceAffinity" : {"labels" : ["zone"]}}},
0000000000000000000000000000000000000000;;				{"name" : "TestRequireZone", "argument" : {"labelsPresence" : {"labels" : ["zone"], "presence" : true}}},
0000000000000000000000000000000000000000;;				{"name" : "PredicateOne"},
0000000000000000000000000000000000000000;;				{"name" : "PredicateTwo"}
0000000000000000000000000000000000000000;;			],
0000000000000000000000000000000000000000;;			"priorities" : [
0000000000000000000000000000000000000000;;				{"name" : "RackSpread", "weight" : 3, "argument" : {"serviceAntiAffinity" : {"label" : "rack"}}},
0000000000000000000000000000000000000000;;				{"name" : "PriorityOne", "weight" : 2},
0000000000000000000000000000000000000000;;				{"name" : "PriorityTwo", "weight" : 1}
0000000000000000000000000000000000000000;;			],
0000000000000000000000000000000000000000;;			"hardPodAffinitySymmetricWeight" : 10
0000000000000000000000000000000000000000;;		}`)
0000000000000000000000000000000000000000;;		if err := runtime.DecodeInto(latestschedulerapi.Codec, configData, &policy); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Invalid configuration: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		factory.CreateFromConfig(policy)
0000000000000000000000000000000000000000;;		hpa := factory.GetHardPodAffinitySymmetricWeight()
0000000000000000000000000000000000000000;;		if hpa != 10 {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong hardPodAffinitySymmetricWeight, ecpected: %d, got: %d", 10, hpa)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateFromEmptyConfig(t *testing.T) {
0000000000000000000000000000000000000000;;		var configData []byte
0000000000000000000000000000000000000000;;		var policy schedulerapi.Policy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode:   500,
0000000000000000000000000000000000000000;;			ResponseBody: "",
0000000000000000000000000000000000000000;;			T:            t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		server := httptest.NewServer(&handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := clientset.NewForConfigOrDie(&restclient.Config{Host: server.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(client, 0)
0000000000000000000000000000000000000000;;		factory := NewConfigFactory(
0000000000000000000000000000000000000000;;			v1.DefaultSchedulerName,
0000000000000000000000000000000000000000;;			client,
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumeClaims(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().ReplicationControllers(),
0000000000000000000000000000000000000000;;			informerFactory.Extensions().V1beta1().ReplicaSets(),
0000000000000000000000000000000000000000;;			informerFactory.Apps().V1beta1().StatefulSets(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Services(),
0000000000000000000000000000000000000000;;			v1.DefaultHardPodAffinitySymmetricWeight,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configData = []byte(`{}`)
0000000000000000000000000000000000000000;;		if err := runtime.DecodeInto(latestschedulerapi.Codec, configData, &policy); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Invalid configuration: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		factory.CreateFromConfig(policy)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PredicateOne(pod *v1.Pod, meta interface{}, nodeInfo *schedulercache.NodeInfo) (bool, []algorithm.PredicateFailureReason, error) {
0000000000000000000000000000000000000000;;		return true, nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PredicateTwo(pod *v1.Pod, meta interface{}, nodeInfo *schedulercache.NodeInfo) (bool, []algorithm.PredicateFailureReason, error) {
0000000000000000000000000000000000000000;;		return true, nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PriorityOne(pod *v1.Pod, nodeNameToInfo map[string]*schedulercache.NodeInfo, nodes []*v1.Node) (schedulerapi.HostPriorityList, error) {
0000000000000000000000000000000000000000;;		return []schedulerapi.HostPriority{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PriorityTwo(pod *v1.Pod, nodeNameToInfo map[string]*schedulercache.NodeInfo, nodes []*v1.Node) (schedulerapi.HostPriorityList, error) {
0000000000000000000000000000000000000000;;		return []schedulerapi.HostPriority{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDefaultErrorFunc(t *testing.T) {
0000000000000000000000000000000000000000;;		testPod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"},
0000000000000000000000000000000000000000;;			Spec:       apitesting.V1DeepEqualSafePodSpec(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode:   200,
0000000000000000000000000000000000000000;;			ResponseBody: runtime.EncodeOrDie(util.Test.Codec(), testPod),
0000000000000000000000000000000000000000;;			T:            t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mux := http.NewServeMux()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// FakeHandler musn't be sent requests other than the one you want to test.
0000000000000000000000000000000000000000;;		mux.Handle(util.Test.ResourcePath("pods", "bar", "foo"), &handler)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(mux)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := clientset.NewForConfigOrDie(&restclient.Config{Host: server.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(client, 0)
0000000000000000000000000000000000000000;;		factory := NewConfigFactory(
0000000000000000000000000000000000000000;;			v1.DefaultSchedulerName,
0000000000000000000000000000000000000000;;			client,
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumeClaims(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().ReplicationControllers(),
0000000000000000000000000000000000000000;;			informerFactory.Extensions().V1beta1().ReplicaSets(),
0000000000000000000000000000000000000000;;			informerFactory.Apps().V1beta1().StatefulSets(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Services(),
0000000000000000000000000000000000000000;;			v1.DefaultHardPodAffinitySymmetricWeight,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		queue := cache.NewFIFO(cache.MetaNamespaceKeyFunc)
0000000000000000000000000000000000000000;;		podBackoff := util.CreatePodBackoff(1*time.Millisecond, 1*time.Second)
0000000000000000000000000000000000000000;;		errFunc := factory.MakeDefaultErrorFunc(podBackoff, queue)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errFunc(testPod, nil)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// This is a terrible way to do this but I plan on replacing this
0000000000000000000000000000000000000000;;			// whole error handling system in the future. The test will time
0000000000000000000000000000000000000000;;			// out if something doesn't work.
0000000000000000000000000000000000000000;;			time.Sleep(10 * time.Millisecond)
0000000000000000000000000000000000000000;;			got, exists, _ := queue.Get(testPod)
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			handler.ValidateRequest(t, util.Test.ResourcePath("pods", "bar", "foo"), "GET", nil)
0000000000000000000000000000000000000000;;			if e, a := testPod, got; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNodeEnumerator(t *testing.T) {
0000000000000000000000000000000000000000;;		testList := &v1.NodeList{
0000000000000000000000000000000000000000;;			Items: []v1.Node{
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "foo"}},
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "bar"}},
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "baz"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		me := nodeEnumerator{testList}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := 3, me.Len(); e != a {
0000000000000000000000000000000000000000;;			t.Fatalf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range testList.Items {
0000000000000000000000000000000000000000;;			gotObj := me.Get(i)
0000000000000000000000000000000000000000;;			if e, a := testList.Items[i].Name, gotObj.(*v1.Node).Name; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := &testList.Items[i], gotObj; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %#v, got %v#", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBind(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			binding *v1.Binding
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{binding: &v1.Binding{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;					Name:      "foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Target: v1.ObjectReference{
0000000000000000000000000000000000000000;;					Name: "foohost.kubernetes.mydomain.com",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			handler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;				StatusCode:   200,
0000000000000000000000000000000000000000;;				ResponseBody: "",
0000000000000000000000000000000000000000;;				T:            t,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			server := httptest.NewServer(&handler)
0000000000000000000000000000000000000000;;			defer server.Close()
0000000000000000000000000000000000000000;;			client := clientset.NewForConfigOrDie(&restclient.Config{Host: server.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;			b := binder{client}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := b.Bind(item.binding); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			expectedBody := runtime.EncodeOrDie(util.Test.Codec(), item.binding)
0000000000000000000000000000000000000000;;			handler.ValidateRequest(t,
0000000000000000000000000000000000000000;;				util.Test.SubResourcePath("pods", metav1.NamespaceDefault, "foo", "binding"),
0000000000000000000000000000000000000000;;				"POST", &expectedBody)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestResponsibleForPod tests if a pod with an annotation that should cause it to
0000000000000000000000000000000000000000;;	// be picked up by the default scheduler, is in fact picked by the default scheduler
0000000000000000000000000000000000000000;;	// Two schedulers are made in the test: one is default scheduler and other scheduler
0000000000000000000000000000000000000000;;	// is of name "foo-scheduler". A pod must be picked up by at most one of the two
0000000000000000000000000000000000000000;;	// schedulers.
0000000000000000000000000000000000000000;;	func TestResponsibleForPod(t *testing.T) {
0000000000000000000000000000000000000000;;		handler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode:   500,
0000000000000000000000000000000000000000;;			ResponseBody: "",
0000000000000000000000000000000000000000;;			T:            t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		server := httptest.NewServer(&handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := clientset.NewForConfigOrDie(&restclient.Config{Host: server.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		// factory of "default-scheduler"
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(client, 0)
0000000000000000000000000000000000000000;;		factoryDefaultScheduler := NewConfigFactory(
0000000000000000000000000000000000000000;;			v1.DefaultSchedulerName,
0000000000000000000000000000000000000000;;			client,
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumeClaims(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().ReplicationControllers(),
0000000000000000000000000000000000000000;;			informerFactory.Extensions().V1beta1().ReplicaSets(),
0000000000000000000000000000000000000000;;			informerFactory.Apps().V1beta1().StatefulSets(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Services(),
0000000000000000000000000000000000000000;;			v1.DefaultHardPodAffinitySymmetricWeight,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		// factory of "foo-scheduler"
0000000000000000000000000000000000000000;;		factoryFooScheduler := NewConfigFactory(
0000000000000000000000000000000000000000;;			"foo-scheduler",
0000000000000000000000000000000000000000;;			client,
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumeClaims(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().ReplicationControllers(),
0000000000000000000000000000000000000000;;			informerFactory.Extensions().V1beta1().ReplicaSets(),
0000000000000000000000000000000000000000;;			informerFactory.Apps().V1beta1().StatefulSets(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Services(),
0000000000000000000000000000000000000000;;			v1.DefaultHardPodAffinitySymmetricWeight,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		// scheduler annotations to be tested
0000000000000000000000000000000000000000;;		schedulerFitsDefault := "default-scheduler"
0000000000000000000000000000000000000000;;		schedulerFitsFoo := "foo-scheduler"
0000000000000000000000000000000000000000;;		schedulerFitsNone := "bar-scheduler"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod             *v1.Pod
0000000000000000000000000000000000000000;;			pickedByDefault bool
0000000000000000000000000000000000000000;;			pickedByFoo     bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// pod with "spec.Schedulername=default-scheduler" should be picked
0000000000000000000000000000000000000000;;				// by the scheduler of name "default-scheduler", NOT by the one of name "foo-scheduler"
0000000000000000000000000000000000000000;;				pod:             &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"}, Spec: v1.PodSpec{SchedulerName: schedulerFitsDefault}},
0000000000000000000000000000000000000000;;				pickedByDefault: true,
0000000000000000000000000000000000000000;;				pickedByFoo:     false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// pod with "spec.SchedulerName=foo-scheduler" should be NOT
0000000000000000000000000000000000000000;;				// be picked by the scheduler of name "default-scheduler", but by the one of name "foo-scheduler"
0000000000000000000000000000000000000000;;				pod:             &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"}, Spec: v1.PodSpec{SchedulerName: schedulerFitsFoo}},
0000000000000000000000000000000000000000;;				pickedByDefault: false,
0000000000000000000000000000000000000000;;				pickedByFoo:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// pod with "spec.SchedulerName=foo-scheduler" should be NOT
0000000000000000000000000000000000000000;;				// be picked by niether the scheduler of name "default-scheduler" nor the one of name "foo-scheduler"
0000000000000000000000000000000000000000;;				pod:             &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"}, Spec: v1.PodSpec{SchedulerName: schedulerFitsNone}},
0000000000000000000000000000000000000000;;				pickedByDefault: false,
0000000000000000000000000000000000000000;;				pickedByFoo:     false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			podOfDefault := factoryDefaultScheduler.ResponsibleForPod(test.pod)
0000000000000000000000000000000000000000;;			podOfFoo := factoryFooScheduler.ResponsibleForPod(test.pod)
0000000000000000000000000000000000000000;;			results := []bool{podOfDefault, podOfFoo}
0000000000000000000000000000000000000000;;			expected := []bool{test.pickedByDefault, test.pickedByFoo}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(results, expected) {
0000000000000000000000000000000000000000;;				t.Errorf("expected: {%v, %v}, got {%v, %v}", test.pickedByDefault, test.pickedByFoo, podOfDefault, podOfFoo)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInvalidHardPodAffinitySymmetricWeight(t *testing.T) {
0000000000000000000000000000000000000000;;		handler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode:   500,
0000000000000000000000000000000000000000;;			ResponseBody: "",
0000000000000000000000000000000000000000;;			T:            t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		server := httptest.NewServer(&handler)
0000000000000000000000000000000000000000;;		// TODO: Uncomment when fix #19254
0000000000000000000000000000000000000000;;		// defer server.Close()
0000000000000000000000000000000000000000;;		client := clientset.NewForConfigOrDie(&restclient.Config{Host: server.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		// factory of "default-scheduler"
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(client, 0)
0000000000000000000000000000000000000000;;		factory := NewConfigFactory(
0000000000000000000000000000000000000000;;			v1.DefaultSchedulerName,
0000000000000000000000000000000000000000;;			client,
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumeClaims(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().ReplicationControllers(),
0000000000000000000000000000000000000000;;			informerFactory.Extensions().V1beta1().ReplicaSets(),
0000000000000000000000000000000000000000;;			informerFactory.Apps().V1beta1().StatefulSets(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Services(),
0000000000000000000000000000000000000000;;			-1,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		_, err := factory.Create()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected err: invalid hardPodAffinitySymmetricWeight, got nothing")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInvalidFactoryArgs(t *testing.T) {
0000000000000000000000000000000000000000;;		handler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode:   500,
0000000000000000000000000000000000000000;;			ResponseBody: "",
0000000000000000000000000000000000000000;;			T:            t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		server := httptest.NewServer(&handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := clientset.NewForConfigOrDie(&restclient.Config{Host: server.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			hardPodAffinitySymmetricWeight int
0000000000000000000000000000000000000000;;			expectErr                      string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				hardPodAffinitySymmetricWeight: -1,
0000000000000000000000000000000000000000;;				expectErr:                      "invalid hardPodAffinitySymmetricWeight: -1, must be in the range 0-100",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				hardPodAffinitySymmetricWeight: 101,
0000000000000000000000000000000000000000;;				expectErr:                      "invalid hardPodAffinitySymmetricWeight: 101, must be in the range 0-100",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range testCases {
0000000000000000000000000000000000000000;;			informerFactory := informers.NewSharedInformerFactory(client, 0)
0000000000000000000000000000000000000000;;			factory := NewConfigFactory(
0000000000000000000000000000000000000000;;				v1.DefaultSchedulerName,
0000000000000000000000000000000000000000;;				client,
0000000000000000000000000000000000000000;;				informerFactory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;				informerFactory.Core().V1().Pods(),
0000000000000000000000000000000000000000;;				informerFactory.Core().V1().PersistentVolumes(),
0000000000000000000000000000000000000000;;				informerFactory.Core().V1().PersistentVolumeClaims(),
0000000000000000000000000000000000000000;;				informerFactory.Core().V1().ReplicationControllers(),
0000000000000000000000000000000000000000;;				informerFactory.Extensions().V1beta1().ReplicaSets(),
0000000000000000000000000000000000000000;;				informerFactory.Apps().V1beta1().StatefulSets(),
0000000000000000000000000000000000000000;;				informerFactory.Core().V1().Services(),
0000000000000000000000000000000000000000;;				test.hardPodAffinitySymmetricWeight,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			_, err := factory.Create()
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("expected err: %s, got nothing", test.expectErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNodeConditionPredicate(t *testing.T) {
0000000000000000000000000000000000000000;;		nodeFunc := getNodeConditionPredicate()
0000000000000000000000000000000000000000;;		nodeList := &v1.NodeList{
0000000000000000000000000000000000000000;;			Items: []v1.Node{
0000000000000000000000000000000000000000;;				// node1 considered
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "node1"}, Status: v1.NodeStatus{Conditions: []v1.NodeCondition{{Type: v1.NodeReady, Status: v1.ConditionTrue}}}},
0000000000000000000000000000000000000000;;				// node2 ignored - node not Ready
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "node2"}, Status: v1.NodeStatus{Conditions: []v1.NodeCondition{{Type: v1.NodeReady, Status: v1.ConditionFalse}}}},
0000000000000000000000000000000000000000;;				// node3 ignored - node out of disk
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "node3"}, Status: v1.NodeStatus{Conditions: []v1.NodeCondition{{Type: v1.NodeOutOfDisk, Status: v1.ConditionTrue}}}},
0000000000000000000000000000000000000000;;				// node4 considered
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "node4"}, Status: v1.NodeStatus{Conditions: []v1.NodeCondition{{Type: v1.NodeOutOfDisk, Status: v1.ConditionFalse}}}},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// node5 ignored - node out of disk
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "node5"}, Status: v1.NodeStatus{Conditions: []v1.NodeCondition{{Type: v1.NodeReady, Status: v1.ConditionTrue}, {Type: v1.NodeOutOfDisk, Status: v1.ConditionTrue}}}},
0000000000000000000000000000000000000000;;				// node6 considered
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "node6"}, Status: v1.NodeStatus{Conditions: []v1.NodeCondition{{Type: v1.NodeReady, Status: v1.ConditionTrue}, {Type: v1.NodeOutOfDisk, Status: v1.ConditionFalse}}}},
0000000000000000000000000000000000000000;;				// node7 ignored - node out of disk, node not Ready
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "node7"}, Status: v1.NodeStatus{Conditions: []v1.NodeCondition{{Type: v1.NodeReady, Status: v1.ConditionFalse}, {Type: v1.NodeOutOfDisk, Status: v1.ConditionTrue}}}},
0000000000000000000000000000000000000000;;				// node8 ignored - node not Ready
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "node8"}, Status: v1.NodeStatus{Conditions: []v1.NodeCondition{{Type: v1.NodeReady, Status: v1.ConditionFalse}, {Type: v1.NodeOutOfDisk, Status: v1.ConditionFalse}}}},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// node9 ignored - node unschedulable
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "node9"}, Spec: v1.NodeSpec{Unschedulable: true}},
0000000000000000000000000000000000000000;;				// node10 considered
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "node10"}, Spec: v1.NodeSpec{Unschedulable: false}},
0000000000000000000000000000000000000000;;				// node11 considered
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "node11"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeNames := []string{}
0000000000000000000000000000000000000000;;		for _, node := range nodeList.Items {
0000000000000000000000000000000000000000;;			if nodeFunc(&node) {
0000000000000000000000000000000000000000;;				nodeNames = append(nodeNames, node.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedNodes := []string{"node1", "node4", "node6", "node10", "node11"}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(expectedNodes, nodeNames) {
0000000000000000000000000000000000000000;;			t.Errorf("expected: %v, got %v", expectedNodes, nodeNames)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
