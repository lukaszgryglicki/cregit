0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
d7757502a9e87dc48874e218a4263ece000aeab3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package factory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/api"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAlgorithmNameValidation(t *testing.T) {
0000000000000000000000000000000000000000;;		algorithmNamesShouldValidate := []string{
0000000000000000000000000000000000000000;;			"1SomeAlgo1rithm",
0000000000000000000000000000000000000000;;			"someAlgor-ithm1",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		algorithmNamesShouldNotValidate := []string{
0000000000000000000000000000000000000000;;			"-SomeAlgorithm",
0000000000000000000000000000000000000000;;			"SomeAlgorithm-",
0000000000000000000000000000000000000000;;			"Some,Alg:orithm",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, name := range algorithmNamesShouldValidate {
0000000000000000000000000000000000000000;;			if !validName.MatchString(name) {
0000000000000000000000000000000000000000;;				t.Errorf("%v should be a valid algorithm name but is not valid.", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, name := range algorithmNamesShouldNotValidate {
0000000000000000000000000000000000000000;;			if validName.MatchString(name) {
0000000000000000000000000000000000000000;;				t.Errorf("%v should be an invalid algorithm name but is valid.", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidatePriorityConfigOverFlow(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			description string
0000000000000000000000000000000000000000;;			configs     []algorithm.PriorityConfig
0000000000000000000000000000000000000000;;			expected    bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "one of the weights is MaxInt",
0000000000000000000000000000000000000000;;				configs:     []algorithm.PriorityConfig{{Weight: api.MaxInt}, {Weight: 5}},
0000000000000000000000000000000000000000;;				expected:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "after multiplication with MaxPriority the weight is larger than MaxWeight",
0000000000000000000000000000000000000000;;				configs:     []algorithm.PriorityConfig{{Weight: api.MaxInt/api.MaxPriority + api.MaxPriority}, {Weight: 5}},
0000000000000000000000000000000000000000;;				expected:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "normal weights",
0000000000000000000000000000000000000000;;				configs:     []algorithm.PriorityConfig{{Weight: 10000}, {Weight: 5}},
0000000000000000000000000000000000000000;;				expected:    false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			err := validateSelectedConfigs(test.configs)
0000000000000000000000000000000000000000;;			if test.expected {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("Expected Overflow for %s", test.description)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("Did not expect an overflow for %s", test.description)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
