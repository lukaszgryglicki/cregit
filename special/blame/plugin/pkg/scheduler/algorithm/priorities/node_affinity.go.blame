0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
a9f57888e41fd7f93946a9dfbf2eb68f6f97207d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package priorities
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		schedulerapi "k8s.io/kubernetes/plugin/pkg/scheduler/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/schedulercache"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CalculateNodeAffinityPriority prioritizes nodes according to node affinity scheduling preferences
0000000000000000000000000000000000000000;;	// indicated in PreferredDuringSchedulingIgnoredDuringExecution. Each time a node match a preferredSchedulingTerm,
0000000000000000000000000000000000000000;;	// it will a get an add of preferredSchedulingTerm.Weight. Thus, the more preferredSchedulingTerms
0000000000000000000000000000000000000000;;	// the node satisfies and the more the preferredSchedulingTerm that is satisfied weights, the higher
0000000000000000000000000000000000000000;;	// score the node gets.
0000000000000000000000000000000000000000;;	func CalculateNodeAffinityPriorityMap(pod *v1.Pod, meta interface{}, nodeInfo *schedulercache.NodeInfo) (schedulerapi.HostPriority, error) {
0000000000000000000000000000000000000000;;		node := nodeInfo.Node()
0000000000000000000000000000000000000000;;		if node == nil {
0000000000000000000000000000000000000000;;			return schedulerapi.HostPriority{}, fmt.Errorf("node not found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var affinity *v1.Affinity
0000000000000000000000000000000000000000;;		if priorityMeta, ok := meta.(*priorityMetadata); ok {
0000000000000000000000000000000000000000;;			affinity = priorityMeta.affinity
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// We couldn't parse metadata - fallback to the podspec.
0000000000000000000000000000000000000000;;			affinity = pod.Spec.Affinity
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var count int32
0000000000000000000000000000000000000000;;		// A nil element of PreferredDuringSchedulingIgnoredDuringExecution matches no objects.
0000000000000000000000000000000000000000;;		// An element of PreferredDuringSchedulingIgnoredDuringExecution that refers to an
0000000000000000000000000000000000000000;;		// empty PreferredSchedulingTerm matches all objects.
0000000000000000000000000000000000000000;;		if affinity != nil && affinity.NodeAffinity != nil && affinity.NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution != nil {
0000000000000000000000000000000000000000;;			// Match PreferredDuringSchedulingIgnoredDuringExecution term by term.
0000000000000000000000000000000000000000;;			for i := range affinity.NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution {
0000000000000000000000000000000000000000;;				preferredSchedulingTerm := &affinity.NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution[i]
0000000000000000000000000000000000000000;;				if preferredSchedulingTerm.Weight == 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// TODO: Avoid computing it for all nodes if this becomes a performance problem.
0000000000000000000000000000000000000000;;				nodeSelector, err := v1helper.NodeSelectorRequirementsAsSelector(preferredSchedulingTerm.Preference.MatchExpressions)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return schedulerapi.HostPriority{}, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if nodeSelector.Matches(labels.Set(node.Labels)) {
0000000000000000000000000000000000000000;;					count += preferredSchedulingTerm.Weight
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;			Host:  node.Name,
0000000000000000000000000000000000000000;;			Score: int(count),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CalculateNodeAffinityPriorityReduce(pod *v1.Pod, meta interface{}, nodeNameToInfo map[string]*schedulercache.NodeInfo, result schedulerapi.HostPriorityList) error {
0000000000000000000000000000000000000000;;		var maxCount int
0000000000000000000000000000000000000000;;		for i := range result {
0000000000000000000000000000000000000000;;			if result[i].Score > maxCount {
0000000000000000000000000000000000000000;;				maxCount = result[i].Score
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		maxCountFloat := float64(maxCount)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var fScore float64
0000000000000000000000000000000000000000;;		for i := range result {
0000000000000000000000000000000000000000;;			if maxCount > 0 {
0000000000000000000000000000000000000000;;				fScore = 10 * (float64(result[i].Score) / maxCountFloat)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fScore = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if glog.V(10) {
0000000000000000000000000000000000000000;;				// We explicitly don't do glog.V(10).Infof() to avoid computing all the parameters if this is
0000000000000000000000000000000000000000;;				// not logged. There is visible performance gain from it.
0000000000000000000000000000000000000000;;				glog.Infof("%v -> %v: NodeAffinityPriority, Score: (%d)", pod.Name, result[i].Host, int(fScore))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result[i].Score = int(fScore)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
