0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
79cb5f148f9fbb125b5ed9b40f2a31f6f99e3405;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package priorities
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		schedulerapi "k8s.io/kubernetes/plugin/pkg/scheduler/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/schedulercache"
0000000000000000000000000000000000000000;;		schedulertesting "k8s.io/kubernetes/plugin/pkg/scheduler/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeNodeListInfo []*v1.Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (nodes FakeNodeListInfo) GetNodeInfo(nodeName string) (*v1.Node, error) {
0000000000000000000000000000000000000000;;		for _, node := range nodes {
0000000000000000000000000000000000000000;;			if node.Name == nodeName {
0000000000000000000000000000000000000000;;				return node, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Unable to find node: %s", nodeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInterPodAffinityPriority(t *testing.T) {
0000000000000000000000000000000000000000;;		labelRgChina := map[string]string{
0000000000000000000000000000000000000000;;			"region": "China",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labelRgIndia := map[string]string{
0000000000000000000000000000000000000000;;			"region": "India",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labelAzAz1 := map[string]string{
0000000000000000000000000000000000000000;;			"az": "az1",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labelAzAz2 := map[string]string{
0000000000000000000000000000000000000000;;			"az": "az2",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labelRgChinaAzAz1 := map[string]string{
0000000000000000000000000000000000000000;;			"region": "China",
0000000000000000000000000000000000000000;;			"az":     "az1",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podLabelSecurityS1 := map[string]string{
0000000000000000000000000000000000000000;;			"security": "S1",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podLabelSecurityS2 := map[string]string{
0000000000000000000000000000000000000000;;			"security": "S2",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// considered only preferredDuringSchedulingIgnoredDuringExecution in pod affinity
0000000000000000000000000000000000000000;;		stayWithS1InRegion := &v1.Affinity{
0000000000000000000000000000000000000000;;			PodAffinity: &v1.PodAffinity{
0000000000000000000000000000000000000000;;				PreferredDuringSchedulingIgnoredDuringExecution: []v1.WeightedPodAffinityTerm{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Weight: 5,
0000000000000000000000000000000000000000;;						PodAffinityTerm: v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;							LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;								MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Key:      "security",
0000000000000000000000000000000000000000;;										Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;										Values:   []string{"S1"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							TopologyKey: "region",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stayWithS2InRegion := &v1.Affinity{
0000000000000000000000000000000000000000;;			PodAffinity: &v1.PodAffinity{
0000000000000000000000000000000000000000;;				PreferredDuringSchedulingIgnoredDuringExecution: []v1.WeightedPodAffinityTerm{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Weight: 6,
0000000000000000000000000000000000000000;;						PodAffinityTerm: v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;							LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;								MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Key:      "security",
0000000000000000000000000000000000000000;;										Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;										Values:   []string{"S2"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							TopologyKey: "region",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		affinity3 := &v1.Affinity{
0000000000000000000000000000000000000000;;			PodAffinity: &v1.PodAffinity{
0000000000000000000000000000000000000000;;				PreferredDuringSchedulingIgnoredDuringExecution: []v1.WeightedPodAffinityTerm{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Weight: 8,
0000000000000000000000000000000000000000;;						PodAffinityTerm: v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;							LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;								MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Key:      "security",
0000000000000000000000000000000000000000;;										Operator: metav1.LabelSelectorOpNotIn,
0000000000000000000000000000000000000000;;										Values:   []string{"S1"},
0000000000000000000000000000000000000000;;									}, {
0000000000000000000000000000000000000000;;										Key:      "security",
0000000000000000000000000000000000000000;;										Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;										Values:   []string{"S2"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							TopologyKey: "region",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}, {
0000000000000000000000000000000000000000;;						Weight: 2,
0000000000000000000000000000000000000000;;						PodAffinityTerm: v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;							LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;								MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Key:      "security",
0000000000000000000000000000000000000000;;										Operator: metav1.LabelSelectorOpExists,
0000000000000000000000000000000000000000;;									}, {
0000000000000000000000000000000000000000;;										Key:      "wrongkey",
0000000000000000000000000000000000000000;;										Operator: metav1.LabelSelectorOpDoesNotExist,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							TopologyKey: "region",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hardAffinity := &v1.Affinity{
0000000000000000000000000000000000000000;;			PodAffinity: &v1.PodAffinity{
0000000000000000000000000000000000000000;;				RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;							MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Key:      "security",
0000000000000000000000000000000000000000;;									Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;									Values:   []string{"S1", "value2"},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						TopologyKey: "region",
0000000000000000000000000000000000000000;;					}, {
0000000000000000000000000000000000000000;;						LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;							MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Key:      "security",
0000000000000000000000000000000000000000;;									Operator: metav1.LabelSelectorOpExists,
0000000000000000000000000000000000000000;;								}, {
0000000000000000000000000000000000000000;;									Key:      "wrongkey",
0000000000000000000000000000000000000000;;									Operator: metav1.LabelSelectorOpDoesNotExist,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						TopologyKey: "region",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		awayFromS1InAz := &v1.Affinity{
0000000000000000000000000000000000000000;;			PodAntiAffinity: &v1.PodAntiAffinity{
0000000000000000000000000000000000000000;;				PreferredDuringSchedulingIgnoredDuringExecution: []v1.WeightedPodAffinityTerm{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Weight: 5,
0000000000000000000000000000000000000000;;						PodAffinityTerm: v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;							LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;								MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Key:      "security",
0000000000000000000000000000000000000000;;										Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;										Values:   []string{"S1"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							TopologyKey: "az",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// to stay away from security S2 in any az.
0000000000000000000000000000000000000000;;		awayFromS2InAz := &v1.Affinity{
0000000000000000000000000000000000000000;;			PodAntiAffinity: &v1.PodAntiAffinity{
0000000000000000000000000000000000000000;;				PreferredDuringSchedulingIgnoredDuringExecution: []v1.WeightedPodAffinityTerm{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Weight: 5,
0000000000000000000000000000000000000000;;						PodAffinityTerm: v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;							LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;								MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Key:      "security",
0000000000000000000000000000000000000000;;										Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;										Values:   []string{"S2"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							TopologyKey: "az",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// to stay with security S1 in same region, stay away from security S2 in any az.
0000000000000000000000000000000000000000;;		stayWithS1InRegionAwayFromS2InAz := &v1.Affinity{
0000000000000000000000000000000000000000;;			PodAffinity: &v1.PodAffinity{
0000000000000000000000000000000000000000;;				PreferredDuringSchedulingIgnoredDuringExecution: []v1.WeightedPodAffinityTerm{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Weight: 8,
0000000000000000000000000000000000000000;;						PodAffinityTerm: v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;							LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;								MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Key:      "security",
0000000000000000000000000000000000000000;;										Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;										Values:   []string{"S1"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							TopologyKey: "region",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			PodAntiAffinity: &v1.PodAntiAffinity{
0000000000000000000000000000000000000000;;				PreferredDuringSchedulingIgnoredDuringExecution: []v1.WeightedPodAffinityTerm{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Weight: 5,
0000000000000000000000000000000000000000;;						PodAffinityTerm: v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;							LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;								MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Key:      "security",
0000000000000000000000000000000000000000;;										Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;										Values:   []string{"S2"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							TopologyKey: "az",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod          *v1.Pod
0000000000000000000000000000000000000000;;			pods         []*v1.Pod
0000000000000000000000000000000000000000;;			nodes        []*v1.Node
0000000000000000000000000000000000000000;;			expectedList schedulerapi.HostPriorityList
0000000000000000000000000000000000000000;;			test         string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{Spec: v1.PodSpec{NodeName: ""}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: labelRgIndia}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine3", Labels: labelAzAz1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 0}, {Host: "machine3", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "all machines are same priority as Affinity is nil",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// the node(machine1) that have the label {"region": "China"} (match the topology key) and that have existing pods that match the labelSelector get high score
0000000000000000000000000000000000000000;;			// the node(machine3) that don't have the label {"region": "whatever the value is"} (mismatch the topology key) but that have existing pods that match the labelSelector get low score
0000000000000000000000000000000000000000;;			// the node(machine2) that have the label {"region": "China"} (match the topology key) but that have existing pods that mismatch the labelSelector get low score
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{Spec: v1.PodSpec{NodeName: "", Affinity: stayWithS1InRegion}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine2"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS2}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine3"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: labelRgIndia}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine3", Labels: labelAzAz1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 10}, {Host: "machine2", Score: 0}, {Host: "machine3", Score: 0}},
0000000000000000000000000000000000000000;;				test: "Affinity: pod that matches topology key & pods in nodes will get high score comparing to others" +
0000000000000000000000000000000000000000;;					"which doesn't match either pods in nodes or in topology key",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// the node1(machine1) that have the label {"region": "China"} (match the topology key) and that have existing pods that match the labelSelector get high score
0000000000000000000000000000000000000000;;			// the node2(machine2) that have the label {"region": "China"}, match the topology key and have the same label value with node1, get the same high score with node1
0000000000000000000000000000000000000000;;			// the node3(machine3) that have the label {"region": "India"}, match the topology key but have a different label value, don't have existing pods that match the labelSelector,
0000000000000000000000000000000000000000;;			// get a low score.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{Spec: v1.PodSpec{NodeName: "", Affinity: stayWithS1InRegion}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: labelRgChinaAzAz1}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine3", Labels: labelRgIndia}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 10}, {Host: "machine2", Score: 10}, {Host: "machine3", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "All the nodes that have the same topology key & label value with one of them has an existing pod that match the affinity rules, have the same score",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// there are 2 regions, say regionChina(machine1,machine3,machine4) and regionIndia(machine2,machine5), both regions have nodes that match the preference.
0000000000000000000000000000000000000000;;			// But there are more nodes(actually more existing pods) in regionChina that match the preference than regionIndia.
0000000000000000000000000000000000000000;;			// Then, nodes in regionChina get higher score than nodes in regionIndia, and all the nodes in regionChina should get a same score(high score),
0000000000000000000000000000000000000000;;			// while all the nodes in regionIndia should get another same score(low score).
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{Spec: v1.PodSpec{NodeName: "", Affinity: stayWithS2InRegion}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS2}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS2}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine2"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS2}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine3"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS2}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine4"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS2}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine5"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS2}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: labelRgIndia}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine3", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine4", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine5", Labels: labelRgIndia}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 10}, {Host: "machine2", Score: 5}, {Host: "machine3", Score: 10}, {Host: "machine4", Score: 10}, {Host: "machine5", Score: 5}},
0000000000000000000000000000000000000000;;				test:         "Affinity: nodes in one region has more matching pods comparing to other reqion, so the region which has more macthes will get high score",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Test with the different operators and values for pod affinity scheduling preference, including some match failures.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{Spec: v1.PodSpec{NodeName: "", Affinity: affinity3}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine2"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS2}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine3"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: labelRgIndia}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine3", Labels: labelAzAz1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 2}, {Host: "machine2", Score: 10}, {Host: "machine3", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "Affinity: different Label operators and values for pod affinity scheduling preference, including some match failures ",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Test the symmetry cases for affinity, the difference between affinity and symmetry is not the pod wants to run together with some existing pods,
0000000000000000000000000000000000000000;;			// but the existing pods have the inter pod affinity preference while the pod to schedule satisfy the preference.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{Spec: v1.PodSpec{NodeName: ""}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS2}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine1", Affinity: stayWithS1InRegion}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine2", Affinity: stayWithS2InRegion}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS2}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: labelRgIndia}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine3", Labels: labelAzAz1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 10}, {Host: "machine3", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "Affinity symmetry: considred only the preferredDuringSchedulingIgnoredDuringExecution in pod affinity symmetry",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{Spec: v1.PodSpec{NodeName: ""}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine1", Affinity: hardAffinity}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine2", Affinity: hardAffinity}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS2}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: labelRgIndia}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine3", Labels: labelAzAz1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 10}, {Host: "machine2", Score: 10}, {Host: "machine3", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "Affinity symmetry: considred RequiredDuringSchedulingIgnoredDuringExecution in pod affinity symmetry",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// The pod to schedule prefer to stay away from some existing pods at node level using the pod anti affinity.
0000000000000000000000000000000000000000;;			// the nodes that have the label {"node": "bar"} (match the topology key) and that have existing pods that match the labelSelector get low score
0000000000000000000000000000000000000000;;			// the nodes that don't have the label {"node": "whatever the value is"} (mismatch the topology key) but that have existing pods that match the labelSelector get high score
0000000000000000000000000000000000000000;;			// the nodes that have the label {"node": "bar"} (match the topology key) but that have existing pods that mismatch the labelSelector get high score
0000000000000000000000000000000000000000;;			// there are 2 nodes, say node1 and node2, both nodes have pods that match the labelSelector and have topology-key in node.Labels.
0000000000000000000000000000000000000000;;			// But there are more pods on node1 that match the preference than node2. Then, node1 get a lower score than node2.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{Spec: v1.PodSpec{NodeName: "", Affinity: awayFromS1InAz}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine2"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS2}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: labelAzAz1}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 10}},
0000000000000000000000000000000000000000;;				test:         "Anti Affinity: pod that doesnot match existing pods in node will get high score ",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{Spec: v1.PodSpec{NodeName: "", Affinity: awayFromS1InAz}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine2"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: labelAzAz1}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 10}},
0000000000000000000000000000000000000000;;				test:         "Anti Affinity: pod that does not matches topology key & matches the pods in nodes will get higher score comparing to others ",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{Spec: v1.PodSpec{NodeName: "", Affinity: awayFromS1InAz}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine2"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS2}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: labelAzAz1}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: labelRgIndia}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 10}},
0000000000000000000000000000000000000000;;				test:         "Anti Affinity: one node has more matching pods comparing to other node, so the node which has more unmacthes will get high score",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Test the symmetry cases for anti affinity
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{Spec: v1.PodSpec{NodeName: ""}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS2}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine1", Affinity: awayFromS2InAz}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine2", Affinity: awayFromS1InAz}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS2}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: labelAzAz1}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: labelAzAz2}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 10}},
0000000000000000000000000000000000000000;;				test:         "Anti Affinity symmetry: the existing pods in node which has anti affinity match will get high score",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Test both  affinity and anti-affinity
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{Spec: v1.PodSpec{NodeName: "", Affinity: stayWithS1InRegionAwayFromS2InAz}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine2"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: labelAzAz1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 10}, {Host: "machine2", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "Affinity and Anti Affinity: considered only preferredDuringSchedulingIgnoredDuringExecution in both pod affinity & anti affinity",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Combined cases considering both affinity and anti-affinity, the pod to schedule and existing pods have the same labels (they are in the same RC/service),
0000000000000000000000000000000000000000;;			// the pod prefer to run together with its brother pods in the same region, but wants to stay away from them at node level,
0000000000000000000000000000000000000000;;			// so that all the pods of a RC/service can stay in a same region but trying to separate with each other
0000000000000000000000000000000000000000;;			// machine-1,machine-3,machine-4 are in ChinaRegion others machin-2,machine-5 are in IndiaRegion
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{Spec: v1.PodSpec{NodeName: "", Affinity: stayWithS1InRegionAwayFromS2InAz}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine2"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine3"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine3"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine4"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine5"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: labelRgChinaAzAz1}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: labelRgIndia}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine3", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine4", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine5", Labels: labelRgIndia}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 10}, {Host: "machine2", Score: 4}, {Host: "machine3", Score: 10}, {Host: "machine4", Score: 10}, {Host: "machine5", Score: 4}},
0000000000000000000000000000000000000000;;				test:         "Affinity and Anti Affinity: considering both affinity and anti-affinity, the pod to schedule and existing pods have the same labels",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Consider Affinity, Anti Affinity and symmetry together.
0000000000000000000000000000000000000000;;			// for Affinity, the weights are:                8,  0,  0,  0
0000000000000000000000000000000000000000;;			// for Anti Affinity, the weights are:           0, -5,  0,  0
0000000000000000000000000000000000000000;;			// for Affinity symmetry, the weights are:       0,  0,  8,  0
0000000000000000000000000000000000000000;;			// for Anti Affinity symmetry, the weights are:  0,  0,  0, -5
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{Spec: v1.PodSpec{NodeName: "", Affinity: stayWithS1InRegionAwayFromS2InAz}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS1}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine2"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelSecurityS2}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine3", Affinity: stayWithS1InRegionAwayFromS2InAz}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine4", Affinity: awayFromS1InAz}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: labelAzAz1}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine3", Labels: labelRgIndia}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine4", Labels: labelAzAz2}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 10}, {Host: "machine2", Score: 0}, {Host: "machine3", Score: 10}, {Host: "machine4", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "Affinity and Anti Affinity and symmetry: considered only preferredDuringSchedulingIgnoredDuringExecution in both pod affinity & anti affinity & symmetry",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			nodeNameToInfo := schedulercache.CreateNodeNameToInfoMap(test.pods, test.nodes)
0000000000000000000000000000000000000000;;			interPodAffinity := InterPodAffinity{
0000000000000000000000000000000000000000;;				info:                  FakeNodeListInfo(test.nodes),
0000000000000000000000000000000000000000;;				nodeLister:            schedulertesting.FakeNodeLister(test.nodes),
0000000000000000000000000000000000000000;;				podLister:             schedulertesting.FakePodLister(test.pods),
0000000000000000000000000000000000000000;;				hardPodAffinityWeight: v1.DefaultHardPodAffinitySymmetricWeight,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			list, err := interPodAffinity.CalculateInterPodAffinityPriority(test.pod, nodeNameToInfo, test.nodes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.expectedList, list) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: \nexpected \n\t%#v, \ngot \n\t%#v\n", test.test, test.expectedList, list)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHardPodAffinitySymmetricWeight(t *testing.T) {
0000000000000000000000000000000000000000;;		podLabelServiceS1 := map[string]string{
0000000000000000000000000000000000000000;;			"service": "S1",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labelRgChina := map[string]string{
0000000000000000000000000000000000000000;;			"region": "China",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labelRgIndia := map[string]string{
0000000000000000000000000000000000000000;;			"region": "India",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labelAzAz1 := map[string]string{
0000000000000000000000000000000000000000;;			"az": "az1",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hardPodAffinity := &v1.Affinity{
0000000000000000000000000000000000000000;;			PodAffinity: &v1.PodAffinity{
0000000000000000000000000000000000000000;;				RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;							MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Key:      "service",
0000000000000000000000000000000000000000;;									Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;									Values:   []string{"S1"},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						TopologyKey: "region",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod                   *v1.Pod
0000000000000000000000000000000000000000;;			pods                  []*v1.Pod
0000000000000000000000000000000000000000;;			nodes                 []*v1.Node
0000000000000000000000000000000000000000;;			hardPodAffinityWeight int
0000000000000000000000000000000000000000;;			expectedList          schedulerapi.HostPriorityList
0000000000000000000000000000000000000000;;			test                  string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{Spec: v1.PodSpec{NodeName: ""}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelServiceS1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine1", Affinity: hardPodAffinity}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine2", Affinity: hardPodAffinity}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: labelRgIndia}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine3", Labels: labelAzAz1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				hardPodAffinityWeight: v1.DefaultHardPodAffinitySymmetricWeight,
0000000000000000000000000000000000000000;;				expectedList:          []schedulerapi.HostPriority{{Host: "machine1", Score: 10}, {Host: "machine2", Score: 10}, {Host: "machine3", Score: 0}},
0000000000000000000000000000000000000000;;				test:                  "Hard Pod Affinity symmetry: hard pod affinity symmetry weights 1 by default, then nodes that match the hard pod affinity symmetry rules, get a high score",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{Spec: v1.PodSpec{NodeName: ""}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelServiceS1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine1", Affinity: hardPodAffinity}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine2", Affinity: hardPodAffinity}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: labelRgIndia}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine3", Labels: labelAzAz1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				hardPodAffinityWeight: 0,
0000000000000000000000000000000000000000;;				expectedList:          []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 0}, {Host: "machine3", Score: 0}},
0000000000000000000000000000000000000000;;				test:                  "Hard Pod Affinity symmetry: hard pod affinity symmetry is closed(weights 0), then nodes that match the hard pod affinity symmetry rules, get same score with those not match",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			nodeNameToInfo := schedulercache.CreateNodeNameToInfoMap(test.pods, test.nodes)
0000000000000000000000000000000000000000;;			ipa := InterPodAffinity{
0000000000000000000000000000000000000000;;				info:                  FakeNodeListInfo(test.nodes),
0000000000000000000000000000000000000000;;				nodeLister:            schedulertesting.FakeNodeLister(test.nodes),
0000000000000000000000000000000000000000;;				podLister:             schedulertesting.FakePodLister(test.pods),
0000000000000000000000000000000000000000;;				hardPodAffinityWeight: test.hardPodAffinityWeight,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			list, err := ipa.CalculateInterPodAffinityPriority(test.pod, nodeNameToInfo, test.nodes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.expectedList, list) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: \nexpected \n\t%#v, \ngot \n\t%#v\n", test.test, test.expectedList, list)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
