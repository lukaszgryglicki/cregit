0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
78824adc6c70db7dd39fc3eaa1ac1a440accfd89;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetNamespacesFromPodAffinityTerm returns a set of names
0000000000000000000000000000000000000000;;	// according to the namespaces indicated in podAffinityTerm.
0000000000000000000000000000000000000000;;	// If namespaces is empty it considers the given pod's namespace.
0000000000000000000000000000000000000000;;	func GetNamespacesFromPodAffinityTerm(pod *v1.Pod, podAffinityTerm *v1.PodAffinityTerm) sets.String {
0000000000000000000000000000000000000000;;		names := sets.String{}
0000000000000000000000000000000000000000;;		if len(podAffinityTerm.Namespaces) == 0 {
0000000000000000000000000000000000000000;;			names.Insert(pod.Namespace)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			names.Insert(podAffinityTerm.Namespaces...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return names
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodMatchesTermsNamespaceAndSelector returns true if the given <pod>
0000000000000000000000000000000000000000;;	// matches the namespace and selector defined by <affinityPod>`s <term>.
0000000000000000000000000000000000000000;;	func PodMatchesTermsNamespaceAndSelector(pod *v1.Pod, namespaces sets.String, selector labels.Selector) bool {
0000000000000000000000000000000000000000;;		if !namespaces.Has(pod.Namespace) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !selector.Matches(labels.Set(pod.Labels)) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodesHaveSameTopologyKey checks if nodeA and nodeB have same label value with given topologyKey as label key.
0000000000000000000000000000000000000000;;	// Returns false if topologyKey is empty.
0000000000000000000000000000000000000000;;	func NodesHaveSameTopologyKey(nodeA, nodeB *v1.Node, topologyKey string) bool {
0000000000000000000000000000000000000000;;		if len(topologyKey) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if nodeA.Labels == nil || nodeB.Labels == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeALabel, okA := nodeA.Labels[topologyKey]
0000000000000000000000000000000000000000;;		nodeBLabel, okB := nodeB.Labels[topologyKey]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If found label in both nodes, check the label
0000000000000000000000000000000000000000;;		if okB && okA {
0000000000000000000000000000000000000000;;			return nodeALabel == nodeBLabel
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Topologies struct {
0000000000000000000000000000000000000000;;		DefaultKeys []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodesHaveSameTopologyKey checks if nodeA and nodeB have same label value with given topologyKey as label key.
0000000000000000000000000000000000000000;;	// If the topologyKey is empty, check if the two nodes have any of the default topologyKeys, and have same corresponding label value.
0000000000000000000000000000000000000000;;	func (tps *Topologies) NodesHaveSameTopologyKey(nodeA, nodeB *v1.Node, topologyKey string) bool {
0000000000000000000000000000000000000000;;		return NodesHaveSameTopologyKey(nodeA, nodeB, topologyKey)
0000000000000000000000000000000000000000;;	}
