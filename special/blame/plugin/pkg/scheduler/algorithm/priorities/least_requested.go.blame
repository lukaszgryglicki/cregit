0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d5f46aea2c93b1de0a123b5726fce7d84b42e456;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package priorities
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		schedulerapi "k8s.io/kubernetes/plugin/pkg/scheduler/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/schedulercache"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LeastRequestedPriority is a priority function that favors nodes with fewer requested resources.
0000000000000000000000000000000000000000;;	// It calculates the percentage of memory and CPU requested by pods scheduled on the node, and prioritizes
0000000000000000000000000000000000000000;;	// based on the minimum of the average of the fraction of requested to capacity.
0000000000000000000000000000000000000000;;	// Details: cpu((capacity - sum(requested)) * 10 / capacity) + memory((capacity - sum(requested)) * 10 / capacity) / 2
0000000000000000000000000000000000000000;;	func LeastRequestedPriorityMap(pod *v1.Pod, meta interface{}, nodeInfo *schedulercache.NodeInfo) (schedulerapi.HostPriority, error) {
0000000000000000000000000000000000000000;;		var nonZeroRequest *schedulercache.Resource
0000000000000000000000000000000000000000;;		if priorityMeta, ok := meta.(*priorityMetadata); ok {
0000000000000000000000000000000000000000;;			nonZeroRequest = priorityMeta.nonZeroRequest
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// We couldn't parse metadata - fallback to computing it.
0000000000000000000000000000000000000000;;			nonZeroRequest = getNonZeroRequests(pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return calculateUnusedPriority(pod, nonZeroRequest, nodeInfo)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The unused capacity is calculated on a scale of 0-10
0000000000000000000000000000000000000000;;	// 0 being the lowest priority and 10 being the highest.
0000000000000000000000000000000000000000;;	// The more unused resources the higher the score is.
0000000000000000000000000000000000000000;;	func calculateUnusedScore(requested int64, capacity int64, node string) int64 {
0000000000000000000000000000000000000000;;		if capacity == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if requested > capacity {
0000000000000000000000000000000000000000;;			glog.V(10).Infof("Combined requested resources %d from existing pods exceeds capacity %d on node %s",
0000000000000000000000000000000000000000;;				requested, capacity, node)
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ((capacity - requested) * 10) / capacity
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calculates host priority based on the amount of unused resources.
0000000000000000000000000000000000000000;;	// 'node' has information about the resources on the node.
0000000000000000000000000000000000000000;;	// 'pods' is a list of pods currently scheduled on the node.
0000000000000000000000000000000000000000;;	func calculateUnusedPriority(pod *v1.Pod, podRequests *schedulercache.Resource, nodeInfo *schedulercache.NodeInfo) (schedulerapi.HostPriority, error) {
0000000000000000000000000000000000000000;;		node := nodeInfo.Node()
0000000000000000000000000000000000000000;;		if node == nil {
0000000000000000000000000000000000000000;;			return schedulerapi.HostPriority{}, fmt.Errorf("node not found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allocatableResources := nodeInfo.AllocatableResource()
0000000000000000000000000000000000000000;;		totalResources := *podRequests
0000000000000000000000000000000000000000;;		totalResources.MilliCPU += nodeInfo.NonZeroRequest().MilliCPU
0000000000000000000000000000000000000000;;		totalResources.Memory += nodeInfo.NonZeroRequest().Memory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cpuScore := calculateUnusedScore(totalResources.MilliCPU, allocatableResources.MilliCPU, node.Name)
0000000000000000000000000000000000000000;;		memoryScore := calculateUnusedScore(totalResources.Memory, allocatableResources.Memory, node.Name)
0000000000000000000000000000000000000000;;		if glog.V(10) {
0000000000000000000000000000000000000000;;			// We explicitly don't do glog.V(10).Infof() to avoid computing all the parameters if this is
0000000000000000000000000000000000000000;;			// not logged. There is visible performance gain from it.
0000000000000000000000000000000000000000;;			glog.V(10).Infof(
0000000000000000000000000000000000000000;;				"%v -> %v: Least Requested Priority, capacity %d millicores %d memory bytes, total request %d millicores %d memory bytes, score %d CPU %d memory",
0000000000000000000000000000000000000000;;				pod.Name, node.Name,
0000000000000000000000000000000000000000;;				allocatableResources.MilliCPU, allocatableResources.Memory,
0000000000000000000000000000000000000000;;				totalResources.MilliCPU, totalResources.Memory,
0000000000000000000000000000000000000000;;				cpuScore, memoryScore,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;			Host:  node.Name,
0000000000000000000000000000000000000000;;			Score: int((cpuScore + memoryScore) / 2),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
