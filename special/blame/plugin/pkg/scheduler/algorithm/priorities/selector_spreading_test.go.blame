0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
15cb1f713ffa0a0d4a81f56e9845d133f87e1375;pkg/scheduler/spreading_scheduler_test.go[pkg/scheduler/spreading_scheduler_test.go][plugin/pkg/scheduler/algorithm/priorities/selector_spreading_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package priorities
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apps "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		kubeletapis "k8s.io/kubernetes/pkg/kubelet/apis"
0000000000000000000000000000000000000000;;		schedulerapi "k8s.io/kubernetes/plugin/pkg/scheduler/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/schedulercache"
0000000000000000000000000000000000000000;;		schedulertesting "k8s.io/kubernetes/plugin/pkg/scheduler/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func controllerRef(kind, name, uid string) []metav1.OwnerReference {
0000000000000000000000000000000000000000;;		// TODO: When ControllerRef will be implemented uncomment code below.
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;		//trueVar := true
0000000000000000000000000000000000000000;;		//return []metav1.OwnerReference{
0000000000000000000000000000000000000000;;		//	{Kind: kind, Name: name, UID: types.UID(uid), Controller: &trueVar},
0000000000000000000000000000000000000000;;		//}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSelectorSpreadPriority(t *testing.T) {
0000000000000000000000000000000000000000;;		labels1 := map[string]string{
0000000000000000000000000000000000000000;;			"foo": "bar",
0000000000000000000000000000000000000000;;			"baz": "blah",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labels2 := map[string]string{
0000000000000000000000000000000000000000;;			"bar": "foo",
0000000000000000000000000000000000000000;;			"baz": "blah",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		zone1Spec := v1.PodSpec{
0000000000000000000000000000000000000000;;			NodeName: "machine1",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		zone2Spec := v1.PodSpec{
0000000000000000000000000000000000000000;;			NodeName: "machine2",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod          *v1.Pod
0000000000000000000000000000000000000000;;			pods         []*v1.Pod
0000000000000000000000000000000000000000;;			nodes        []string
0000000000000000000000000000000000000000;;			rcs          []*v1.ReplicationController
0000000000000000000000000000000000000000;;			rss          []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;			services     []*v1.Service
0000000000000000000000000000000000000000;;			sss          []*apps.StatefulSet
0000000000000000000000000000000000000000;;			expectedList schedulerapi.HostPriorityList
0000000000000000000000000000000000000000;;			test         string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:          new(v1.Pod),
0000000000000000000000000000000000000000;;				nodes:        []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 10}, {Host: "machine2", Score: 10}},
0000000000000000000000000000000000000000;;				test:         "nothing scheduled",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:          &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				pods:         []*v1.Pod{{Spec: zone1Spec}},
0000000000000000000000000000000000000000;;				nodes:        []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 10}, {Host: "machine2", Score: 10}},
0000000000000000000000000000000000000000;;				test:         "no services",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:          &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				pods:         []*v1.Pod{{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}}},
0000000000000000000000000000000000000000;;				nodes:        []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				services:     []*v1.Service{{Spec: v1.ServiceSpec{Selector: map[string]string{"key": "value"}}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 10}, {Host: "machine2", Score: 10}},
0000000000000000000000000000000000000000;;				test:         "different services",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes:        []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				services:     []*v1.Service{{Spec: v1.ServiceSpec{Selector: labels1}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 10}, {Host: "machine2", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "two pods, one service pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, Namespace: metav1.NamespaceDefault}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, Namespace: "ns1"}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes:        []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				services:     []*v1.Service{{Spec: v1.ServiceSpec{Selector: labels1}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 10}, {Host: "machine2", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "five pods, one service pod in no namespace",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1, Namespace: metav1.NamespaceDefault}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, Namespace: "ns1"}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, Namespace: metav1.NamespaceDefault}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes:        []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				services:     []*v1.Service{{Spec: v1.ServiceSpec{Selector: labels1}, ObjectMeta: metav1.ObjectMeta{Namespace: metav1.NamespaceDefault}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 10}, {Host: "machine2", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "four pods, one service pod in default namespace",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1, Namespace: "ns1"}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, Namespace: metav1.NamespaceDefault}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, Namespace: "ns2"}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, Namespace: "ns1"}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes:        []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				services:     []*v1.Service{{Spec: v1.ServiceSpec{Selector: labels1}, ObjectMeta: metav1.ObjectMeta{Namespace: "ns1"}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 10}, {Host: "machine2", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "five pods, one service pod in specific namespace",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes:        []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				services:     []*v1.Service{{Spec: v1.ServiceSpec{Selector: labels1}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "three pods, two service pods on different machines",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes:        []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				services:     []*v1.Service{{Spec: v1.ServiceSpec{Selector: labels1}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 5}, {Host: "machine2", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "four pods, three service pods",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes:        []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				services:     []*v1.Service{{Spec: v1.ServiceSpec{Selector: map[string]string{"baz": "blah"}}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 5}},
0000000000000000000000000000000000000000;;				test:         "service with partial pod label matches",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicationController", "name", "abc123")}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicationController", "name", "abc123")}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicationController", "name", "abc123")}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes:    []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				rcs:      []*v1.ReplicationController{{Spec: v1.ReplicationControllerSpec{Selector: map[string]string{"foo": "bar"}}}},
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: map[string]string{"baz": "blah"}}}},
0000000000000000000000000000000000000000;;				// "baz=blah" matches both labels1 and labels2, and "foo=bar" matches only labels 1. This means that we assume that we want to
0000000000000000000000000000000000000000;;				// do spreading between all pods. The result should be exactly as above.
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 5}},
0000000000000000000000000000000000000000;;				test:         "service with partial pod label matches with service and replication controller",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicaSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicaSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicaSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes:    []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: map[string]string{"baz": "blah"}}}},
0000000000000000000000000000000000000000;;				rss:      []*extensions.ReplicaSet{{Spec: extensions.ReplicaSetSpec{Selector: &metav1.LabelSelector{MatchLabels: map[string]string{"foo": "bar"}}}}},
0000000000000000000000000000000000000000;;				// We use ReplicaSet, instead of ReplicationController. The result should be exactly as above.
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 5}},
0000000000000000000000000000000000000000;;				test:         "service with partial pod label matches with service and replica set",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("StatefulSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("StatefulSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("StatefulSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes:        []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				services:     []*v1.Service{{Spec: v1.ServiceSpec{Selector: map[string]string{"baz": "blah"}}}},
0000000000000000000000000000000000000000;;				sss:          []*apps.StatefulSet{{Spec: apps.StatefulSetSpec{Selector: &metav1.LabelSelector{MatchLabels: map[string]string{"foo": "bar"}}}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 5}},
0000000000000000000000000000000000000000;;				test:         "service with partial pod label matches with service and replica set",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: map[string]string{"foo": "bar", "bar": "foo"}, OwnerReferences: controllerRef("ReplicationController", "name", "abc123")}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicationController", "name", "abc123")}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicationController", "name", "abc123")}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes:    []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				rcs:      []*v1.ReplicationController{{Spec: v1.ReplicationControllerSpec{Selector: map[string]string{"foo": "bar"}}}},
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: map[string]string{"bar": "foo"}}}},
0000000000000000000000000000000000000000;;				// Taken together Service and Replication Controller should match all Pods, hence result should be equal to one above.
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 5}},
0000000000000000000000000000000000000000;;				test:         "disjoined service and replication controller should be treated equally",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: map[string]string{"foo": "bar", "bar": "foo"}, OwnerReferences: controllerRef("ReplicaSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicaSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicaSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes:    []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: map[string]string{"bar": "foo"}}}},
0000000000000000000000000000000000000000;;				rss:      []*extensions.ReplicaSet{{Spec: extensions.ReplicaSetSpec{Selector: &metav1.LabelSelector{MatchLabels: map[string]string{"foo": "bar"}}}}},
0000000000000000000000000000000000000000;;				// We use ReplicaSet, instead of ReplicationController. The result should be exactly as above.
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 5}},
0000000000000000000000000000000000000000;;				test:         "disjoined service and replica set should be treated equally",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: map[string]string{"foo": "bar", "bar": "foo"}, OwnerReferences: controllerRef("StatefulSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("StatefulSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("StatefulSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes:        []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				services:     []*v1.Service{{Spec: v1.ServiceSpec{Selector: map[string]string{"bar": "foo"}}}},
0000000000000000000000000000000000000000;;				sss:          []*apps.StatefulSet{{Spec: apps.StatefulSetSpec{Selector: &metav1.LabelSelector{MatchLabels: map[string]string{"foo": "bar"}}}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 5}},
0000000000000000000000000000000000000000;;				test:         "disjoined service and replica set should be treated equally",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicationController", "name", "abc123")}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicationController", "name", "abc123")}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicationController", "name", "abc123")}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				rcs:   []*v1.ReplicationController{{Spec: v1.ReplicationControllerSpec{Selector: map[string]string{"foo": "bar"}}}},
0000000000000000000000000000000000000000;;				// Both Nodes have one pod from the given RC, hence both get 0 score.
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "Replication controller with partial pod label matches",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicaSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicaSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicaSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				rss:   []*extensions.ReplicaSet{{Spec: extensions.ReplicaSetSpec{Selector: &metav1.LabelSelector{MatchLabels: map[string]string{"foo": "bar"}}}}},
0000000000000000000000000000000000000000;;				// We use ReplicaSet, instead of ReplicationController. The result should be exactly as above.
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "Replica set with partial pod label matches",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("StatefulSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("StatefulSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("StatefulSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				sss:   []*apps.StatefulSet{{Spec: apps.StatefulSetSpec{Selector: &metav1.LabelSelector{MatchLabels: map[string]string{"foo": "bar"}}}}},
0000000000000000000000000000000000000000;;				// We use StatefulSet, instead of ReplicationController. The result should be exactly as above.
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "StatefulSet with partial pod label matches",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicationController", "name", "abc123")}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2, OwnerReferences: controllerRef("ReplicationController", "name", "abc123")}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicationController", "name", "abc123")}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicationController", "name", "abc123")}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes:        []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				rcs:          []*v1.ReplicationController{{Spec: v1.ReplicationControllerSpec{Selector: map[string]string{"baz": "blah"}}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 5}},
0000000000000000000000000000000000000000;;				test:         "Another replication controller with partial pod label matches",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicaSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2, OwnerReferences: controllerRef("ReplicaSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicaSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("ReplicaSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				rss:   []*extensions.ReplicaSet{{Spec: extensions.ReplicaSetSpec{Selector: &metav1.LabelSelector{MatchLabels: map[string]string{"baz": "blah"}}}}},
0000000000000000000000000000000000000000;;				// We use ReplicaSet, instead of ReplicationController. The result should be exactly as above.
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 5}},
0000000000000000000000000000000000000000;;				test:         "Another replication set with partial pod label matches",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("StatefulSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2, OwnerReferences: controllerRef("StatefulSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("StatefulSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, OwnerReferences: controllerRef("StatefulSet", "name", "abc123")}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []string{"machine1", "machine2"},
0000000000000000000000000000000000000000;;				sss:   []*apps.StatefulSet{{Spec: apps.StatefulSetSpec{Selector: &metav1.LabelSelector{MatchLabels: map[string]string{"baz": "blah"}}}}},
0000000000000000000000000000000000000000;;				// We use StatefulSet, instead of ReplicationController. The result should be exactly as above.
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 5}},
0000000000000000000000000000000000000000;;				test:         "Another stateful set with partial pod label matches",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			nodeNameToInfo := schedulercache.CreateNodeNameToInfoMap(test.pods, nil)
0000000000000000000000000000000000000000;;			selectorSpread := SelectorSpread{
0000000000000000000000000000000000000000;;				serviceLister:     schedulertesting.FakeServiceLister(test.services),
0000000000000000000000000000000000000000;;				controllerLister:  schedulertesting.FakeControllerLister(test.rcs),
0000000000000000000000000000000000000000;;				replicaSetLister:  schedulertesting.FakeReplicaSetLister(test.rss),
0000000000000000000000000000000000000000;;				statefulSetLister: schedulertesting.FakeStatefulSetLister(test.sss),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			list, err := selectorSpread.CalculateSpreadPriority(test.pod, nodeNameToInfo, makeNodeList(test.nodes))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.expectedList, list) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %#v, got %#v", test.test, test.expectedList, list)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildPod(nodeName string, labels map[string]string, ownerRefs []metav1.OwnerReference) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Labels: labels, OwnerReferences: ownerRefs},
0000000000000000000000000000000000000000;;			Spec:       v1.PodSpec{NodeName: nodeName},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestZoneSelectorSpreadPriority(t *testing.T) {
0000000000000000000000000000000000000000;;		labels1 := map[string]string{
0000000000000000000000000000000000000000;;			"label1": "l1",
0000000000000000000000000000000000000000;;			"baz":    "blah",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labels2 := map[string]string{
0000000000000000000000000000000000000000;;			"label2": "l2",
0000000000000000000000000000000000000000;;			"baz":    "blah",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const nodeMachine1Zone1 = "machine1.zone1"
0000000000000000000000000000000000000000;;		const nodeMachine1Zone2 = "machine1.zone2"
0000000000000000000000000000000000000000;;		const nodeMachine2Zone2 = "machine2.zone2"
0000000000000000000000000000000000000000;;		const nodeMachine1Zone3 = "machine1.zone3"
0000000000000000000000000000000000000000;;		const nodeMachine2Zone3 = "machine2.zone3"
0000000000000000000000000000000000000000;;		const nodeMachine3Zone3 = "machine3.zone3"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buildNodeLabels := func(failureDomain string) map[string]string {
0000000000000000000000000000000000000000;;			labels := map[string]string{
0000000000000000000000000000000000000000;;				kubeletapis.LabelZoneFailureDomain: failureDomain,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return labels
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labeledNodes := map[string]map[string]string{
0000000000000000000000000000000000000000;;			nodeMachine1Zone1: buildNodeLabels("zone1"),
0000000000000000000000000000000000000000;;			nodeMachine1Zone2: buildNodeLabels("zone2"),
0000000000000000000000000000000000000000;;			nodeMachine2Zone2: buildNodeLabels("zone2"),
0000000000000000000000000000000000000000;;			nodeMachine1Zone3: buildNodeLabels("zone3"),
0000000000000000000000000000000000000000;;			nodeMachine2Zone3: buildNodeLabels("zone3"),
0000000000000000000000000000000000000000;;			nodeMachine3Zone3: buildNodeLabels("zone3"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod          *v1.Pod
0000000000000000000000000000000000000000;;			pods         []*v1.Pod
0000000000000000000000000000000000000000;;			nodes        []string
0000000000000000000000000000000000000000;;			rcs          []*v1.ReplicationController
0000000000000000000000000000000000000000;;			rss          []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;			services     []*v1.Service
0000000000000000000000000000000000000000;;			sss          []*apps.StatefulSet
0000000000000000000000000000000000000000;;			expectedList schedulerapi.HostPriorityList
0000000000000000000000000000000000000000;;			test         string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: new(v1.Pod),
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone1, Score: 10},
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone2, Score: 10},
0000000000000000000000000000000000000000;;					{Host: nodeMachine2Zone2, Score: 10},
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone3, Score: 10},
0000000000000000000000000000000000000000;;					{Host: nodeMachine2Zone3, Score: 10},
0000000000000000000000000000000000000000;;					{Host: nodeMachine3Zone3, Score: 10},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				test: "nothing scheduled",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:  buildPod("", labels1, nil),
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{buildPod(nodeMachine1Zone1, nil, nil)},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone1, Score: 10},
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone2, Score: 10},
0000000000000000000000000000000000000000;;					{Host: nodeMachine2Zone2, Score: 10},
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone3, Score: 10},
0000000000000000000000000000000000000000;;					{Host: nodeMachine2Zone3, Score: 10},
0000000000000000000000000000000000000000;;					{Host: nodeMachine3Zone3, Score: 10},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				test: "no services",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      buildPod("", labels1, nil),
0000000000000000000000000000000000000000;;				pods:     []*v1.Pod{buildPod(nodeMachine1Zone1, labels2, nil)},
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: map[string]string{"key": "value"}}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone1, Score: 10},
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone2, Score: 10},
0000000000000000000000000000000000000000;;					{Host: nodeMachine2Zone2, Score: 10},
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone3, Score: 10},
0000000000000000000000000000000000000000;;					{Host: nodeMachine2Zone3, Score: 10},
0000000000000000000000000000000000000000;;					{Host: nodeMachine3Zone3, Score: 10},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				test: "different services",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: buildPod("", labels1, nil),
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					buildPod(nodeMachine1Zone1, labels2, nil),
0000000000000000000000000000000000000000;;					buildPod(nodeMachine1Zone2, labels1, nil),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: labels1}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone1, Score: 10},
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone2, Score: 0}, // Already have pod on machine
0000000000000000000000000000000000000000;;					{Host: nodeMachine2Zone2, Score: 3}, // Already have pod in zone
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone3, Score: 10},
0000000000000000000000000000000000000000;;					{Host: nodeMachine2Zone3, Score: 10},
0000000000000000000000000000000000000000;;					{Host: nodeMachine3Zone3, Score: 10},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				test: "two pods, 1 matching (in z2)",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: buildPod("", labels1, nil),
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					buildPod(nodeMachine1Zone1, labels2, nil),
0000000000000000000000000000000000000000;;					buildPod(nodeMachine1Zone2, labels1, nil),
0000000000000000000000000000000000000000;;					buildPod(nodeMachine2Zone2, labels1, nil),
0000000000000000000000000000000000000000;;					buildPod(nodeMachine1Zone3, labels2, nil),
0000000000000000000000000000000000000000;;					buildPod(nodeMachine2Zone3, labels1, nil),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: labels1}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone1, Score: 10},
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone2, Score: 0}, // Pod on node
0000000000000000000000000000000000000000;;					{Host: nodeMachine2Zone2, Score: 0}, // Pod on node
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone3, Score: 6}, // Pod in zone
0000000000000000000000000000000000000000;;					{Host: nodeMachine2Zone3, Score: 3}, // Pod on node
0000000000000000000000000000000000000000;;					{Host: nodeMachine3Zone3, Score: 6}, // Pod in zone
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				test: "five pods, 3 matching (z2=2, z3=1)",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: buildPod("", labels1, nil),
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					buildPod(nodeMachine1Zone1, labels1, nil),
0000000000000000000000000000000000000000;;					buildPod(nodeMachine1Zone2, labels1, nil),
0000000000000000000000000000000000000000;;					buildPod(nodeMachine2Zone2, labels2, nil),
0000000000000000000000000000000000000000;;					buildPod(nodeMachine1Zone3, labels1, nil),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: labels1}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone1, Score: 0}, // Pod on node
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone2, Score: 0}, // Pod on node
0000000000000000000000000000000000000000;;					{Host: nodeMachine2Zone2, Score: 3}, // Pod in zone
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone3, Score: 0}, // Pod on node
0000000000000000000000000000000000000000;;					{Host: nodeMachine2Zone3, Score: 3}, // Pod in zone
0000000000000000000000000000000000000000;;					{Host: nodeMachine3Zone3, Score: 3}, // Pod in zone
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				test: "four pods, 3 matching (z1=1, z2=1, z3=1)",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: buildPod("", labels1, nil),
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					buildPod(nodeMachine1Zone1, labels1, nil),
0000000000000000000000000000000000000000;;					buildPod(nodeMachine1Zone2, labels1, nil),
0000000000000000000000000000000000000000;;					buildPod(nodeMachine1Zone3, labels1, nil),
0000000000000000000000000000000000000000;;					buildPod(nodeMachine2Zone2, labels2, nil),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: labels1}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone1, Score: 0}, // Pod on node
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone2, Score: 0}, // Pod on node
0000000000000000000000000000000000000000;;					{Host: nodeMachine2Zone2, Score: 3}, // Pod in zone
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone3, Score: 0}, // Pod on node
0000000000000000000000000000000000000000;;					{Host: nodeMachine2Zone3, Score: 3}, // Pod in zone
0000000000000000000000000000000000000000;;					{Host: nodeMachine3Zone3, Score: 3}, // Pod in zone
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				test: "four pods, 3 matching (z1=1, z2=1, z3=1)",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: buildPod("", labels1, controllerRef("ReplicationController", "name", "abc123")),
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					buildPod(nodeMachine1Zone3, labels1, controllerRef("ReplicationController", "name", "abc123")),
0000000000000000000000000000000000000000;;					buildPod(nodeMachine1Zone2, labels1, controllerRef("ReplicationController", "name", "abc123")),
0000000000000000000000000000000000000000;;					buildPod(nodeMachine1Zone3, labels1, controllerRef("ReplicationController", "name", "abc123")),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				rcs: []*v1.ReplicationController{{Spec: v1.ReplicationControllerSpec{Selector: labels1}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;					// Note that because we put two pods on the same node (nodeMachine1Zone3),
0000000000000000000000000000000000000000;;					// the values here are questionable for zone2, in particular for nodeMachine1Zone2.
0000000000000000000000000000000000000000;;					// However they kind of make sense; zone1 is still most-highly favored.
0000000000000000000000000000000000000000;;					// zone3 is in general least favored, and m1.z3 particularly low priority.
0000000000000000000000000000000000000000;;					// We would probably prefer to see a bigger gap between putting a second
0000000000000000000000000000000000000000;;					// pod on m1.z2 and putting a pod on m2.z2, but the ordering is correct.
0000000000000000000000000000000000000000;;					// This is also consistent with what we have already.
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone1, Score: 10}, // No pods in zone
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone2, Score: 5},  // Pod on node
0000000000000000000000000000000000000000;;					{Host: nodeMachine2Zone2, Score: 6},  // Pod in zone
0000000000000000000000000000000000000000;;					{Host: nodeMachine1Zone3, Score: 0},  // Two pods on node
0000000000000000000000000000000000000000;;					{Host: nodeMachine2Zone3, Score: 3},  // Pod in zone
0000000000000000000000000000000000000000;;					{Host: nodeMachine3Zone3, Score: 3},  // Pod in zone
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				test: "Replication controller spreading (z1=0, z2=1, z3=2)",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			nodeNameToInfo := schedulercache.CreateNodeNameToInfoMap(test.pods, nil)
0000000000000000000000000000000000000000;;			selectorSpread := SelectorSpread{
0000000000000000000000000000000000000000;;				serviceLister:     schedulertesting.FakeServiceLister(test.services),
0000000000000000000000000000000000000000;;				controllerLister:  schedulertesting.FakeControllerLister(test.rcs),
0000000000000000000000000000000000000000;;				replicaSetLister:  schedulertesting.FakeReplicaSetLister(test.rss),
0000000000000000000000000000000000000000;;				statefulSetLister: schedulertesting.FakeStatefulSetLister(test.sss),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			list, err := selectorSpread.CalculateSpreadPriority(test.pod, nodeNameToInfo, makeLabeledNodeList(labeledNodes))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// sort the two lists to avoid failures on account of different ordering
0000000000000000000000000000000000000000;;			sort.Sort(test.expectedList)
0000000000000000000000000000000000000000;;			sort.Sort(list)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.expectedList, list) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %#v, got %#v", test.test, test.expectedList, list)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestZoneSpreadPriority(t *testing.T) {
0000000000000000000000000000000000000000;;		labels1 := map[string]string{
0000000000000000000000000000000000000000;;			"foo": "bar",
0000000000000000000000000000000000000000;;			"baz": "blah",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labels2 := map[string]string{
0000000000000000000000000000000000000000;;			"bar": "foo",
0000000000000000000000000000000000000000;;			"baz": "blah",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		zone1 := map[string]string{
0000000000000000000000000000000000000000;;			"zone": "zone1",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		zone2 := map[string]string{
0000000000000000000000000000000000000000;;			"zone": "zone2",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nozone := map[string]string{
0000000000000000000000000000000000000000;;			"name": "value",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		zone0Spec := v1.PodSpec{
0000000000000000000000000000000000000000;;			NodeName: "machine01",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		zone1Spec := v1.PodSpec{
0000000000000000000000000000000000000000;;			NodeName: "machine11",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		zone2Spec := v1.PodSpec{
0000000000000000000000000000000000000000;;			NodeName: "machine21",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labeledNodes := map[string]map[string]string{
0000000000000000000000000000000000000000;;			"machine01": nozone, "machine02": nozone,
0000000000000000000000000000000000000000;;			"machine11": zone1, "machine12": zone1,
0000000000000000000000000000000000000000;;			"machine21": zone2, "machine22": zone2,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod          *v1.Pod
0000000000000000000000000000000000000000;;			pods         []*v1.Pod
0000000000000000000000000000000000000000;;			nodes        map[string]map[string]string
0000000000000000000000000000000000000000;;			services     []*v1.Service
0000000000000000000000000000000000000000;;			expectedList schedulerapi.HostPriorityList
0000000000000000000000000000000000000000;;			test         string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:   new(v1.Pod),
0000000000000000000000000000000000000000;;				nodes: labeledNodes,
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine11", Score: 10}, {Host: "machine12", Score: 10},
0000000000000000000000000000000000000000;;					{Host: "machine21", Score: 10}, {Host: "machine22", Score: 10},
0000000000000000000000000000000000000000;;					{Host: "machine01", Score: 0}, {Host: "machine02", Score: 0}},
0000000000000000000000000000000000000000;;				test: "nothing scheduled",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:   &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				pods:  []*v1.Pod{{Spec: zone1Spec}},
0000000000000000000000000000000000000000;;				nodes: labeledNodes,
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine11", Score: 10}, {Host: "machine12", Score: 10},
0000000000000000000000000000000000000000;;					{Host: "machine21", Score: 10}, {Host: "machine22", Score: 10},
0000000000000000000000000000000000000000;;					{Host: "machine01", Score: 0}, {Host: "machine02", Score: 0}},
0000000000000000000000000000000000000000;;				test: "no services",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				pods:     []*v1.Pod{{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}}},
0000000000000000000000000000000000000000;;				nodes:    labeledNodes,
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: map[string]string{"key": "value"}}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine11", Score: 10}, {Host: "machine12", Score: 10},
0000000000000000000000000000000000000000;;					{Host: "machine21", Score: 10}, {Host: "machine22", Score: 10},
0000000000000000000000000000000000000000;;					{Host: "machine01", Score: 0}, {Host: "machine02", Score: 0}},
0000000000000000000000000000000000000000;;				test: "different services",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone0Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes:    labeledNodes,
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: labels1}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine11", Score: 10}, {Host: "machine12", Score: 10},
0000000000000000000000000000000000000000;;					{Host: "machine21", Score: 0}, {Host: "machine22", Score: 0},
0000000000000000000000000000000000000000;;					{Host: "machine01", Score: 0}, {Host: "machine02", Score: 0}},
0000000000000000000000000000000000000000;;				test: "three pods, one service pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes:    labeledNodes,
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: labels1}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine11", Score: 5}, {Host: "machine12", Score: 5},
0000000000000000000000000000000000000000;;					{Host: "machine21", Score: 5}, {Host: "machine22", Score: 5},
0000000000000000000000000000000000000000;;					{Host: "machine01", Score: 0}, {Host: "machine02", Score: 0}},
0000000000000000000000000000000000000000;;				test: "three pods, two service pods on different machines",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1, Namespace: metav1.NamespaceDefault}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, Namespace: metav1.NamespaceDefault}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1, Namespace: "ns1"}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes:    labeledNodes,
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: labels1}, ObjectMeta: metav1.ObjectMeta{Namespace: metav1.NamespaceDefault}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine11", Score: 0}, {Host: "machine12", Score: 0},
0000000000000000000000000000000000000000;;					{Host: "machine21", Score: 10}, {Host: "machine22", Score: 10},
0000000000000000000000000000000000000000;;					{Host: "machine01", Score: 0}, {Host: "machine02", Score: 0}},
0000000000000000000000000000000000000000;;				test: "three service label match pods in different namespaces",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes:    labeledNodes,
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: labels1}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine11", Score: 6}, {Host: "machine12", Score: 6},
0000000000000000000000000000000000000000;;					{Host: "machine21", Score: 3}, {Host: "machine22", Score: 3},
0000000000000000000000000000000000000000;;					{Host: "machine01", Score: 0}, {Host: "machine02", Score: 0}},
0000000000000000000000000000000000000000;;				test: "four pods, three service pods",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels2}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes:    labeledNodes,
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: map[string]string{"baz": "blah"}}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine11", Score: 3}, {Host: "machine12", Score: 3},
0000000000000000000000000000000000000000;;					{Host: "machine21", Score: 6}, {Host: "machine22", Score: 6},
0000000000000000000000000000000000000000;;					{Host: "machine01", Score: 0}, {Host: "machine02", Score: 0}},
0000000000000000000000000000000000000000;;				test: "service with partial pod label matches",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: zone0Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;					{Spec: zone1Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;					{Spec: zone2Spec, ObjectMeta: metav1.ObjectMeta{Labels: labels1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes:    labeledNodes,
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: labels1}}},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine11", Score: 7}, {Host: "machine12", Score: 7},
0000000000000000000000000000000000000000;;					{Host: "machine21", Score: 5}, {Host: "machine22", Score: 5},
0000000000000000000000000000000000000000;;					{Host: "machine01", Score: 0}, {Host: "machine02", Score: 0}},
0000000000000000000000000000000000000000;;				test: "service pod on non-zoned node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			nodeNameToInfo := schedulercache.CreateNodeNameToInfoMap(test.pods, nil)
0000000000000000000000000000000000000000;;			zoneSpread := ServiceAntiAffinity{podLister: schedulertesting.FakePodLister(test.pods), serviceLister: schedulertesting.FakeServiceLister(test.services), label: "zone"}
0000000000000000000000000000000000000000;;			list, err := zoneSpread.CalculateAntiAffinityPriority(test.pod, nodeNameToInfo, makeLabeledNodeList(test.nodes))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// sort the two lists to avoid failures on account of different ordering
0000000000000000000000000000000000000000;;			sort.Sort(test.expectedList)
0000000000000000000000000000000000000000;;			sort.Sort(list)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.expectedList, list) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %#v, got %#v", test.test, test.expectedList, list)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetNodeClassificationByLabels(t *testing.T) {
0000000000000000000000000000000000000000;;		const machine01 = "machine01"
0000000000000000000000000000000000000000;;		const machine02 = "machine02"
0000000000000000000000000000000000000000;;		const zoneA = "zoneA"
0000000000000000000000000000000000000000;;		zone1 := map[string]string{
0000000000000000000000000000000000000000;;			"zone": zoneA,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labeledNodes := map[string]map[string]string{
0000000000000000000000000000000000000000;;			machine01: zone1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedNonLabeledNodes := []string{machine02}
0000000000000000000000000000000000000000;;		serviceAffinity := ServiceAntiAffinity{label: "zone"}
0000000000000000000000000000000000000000;;		newLabeledNodes, noNonLabeledNodes := serviceAffinity.getNodeClassificationByLabels(makeLabeledNodeList(labeledNodes))
0000000000000000000000000000000000000000;;		noLabeledNodes, newnonLabeledNodes := serviceAffinity.getNodeClassificationByLabels(makeNodeList(expectedNonLabeledNodes))
0000000000000000000000000000000000000000;;		label, _ := newLabeledNodes[machine01]
0000000000000000000000000000000000000000;;		if label != zoneA && len(noNonLabeledNodes) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected only labeled node with label zoneA and no noNonLabeledNodes")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(noLabeledNodes) != 0 && newnonLabeledNodes[0] != machine02 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected only non labled nodes")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeLabeledNodeList(nodeMap map[string]map[string]string) []*v1.Node {
0000000000000000000000000000000000000000;;		nodes := make([]*v1.Node, 0, len(nodeMap))
0000000000000000000000000000000000000000;;		for nodeName, labels := range nodeMap {
0000000000000000000000000000000000000000;;			nodes = append(nodes, &v1.Node{ObjectMeta: metav1.ObjectMeta{Name: nodeName, Labels: labels}})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeNodeList(nodeNames []string) []*v1.Node {
0000000000000000000000000000000000000000;;		nodes := make([]*v1.Node, 0, len(nodeNames))
0000000000000000000000000000000000000000;;		for _, nodeName := range nodeNames {
0000000000000000000000000000000000000000;;			nodes = append(nodes, &v1.Node{ObjectMeta: metav1.ObjectMeta{Name: nodeName}})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodes
0000000000000000000000000000000000000000;;	}
