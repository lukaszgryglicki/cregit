0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
a9f57888e41fd7f93946a9dfbf2eb68f6f97207d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package priorities
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		schedulerapi "k8s.io/kubernetes/plugin/pkg/scheduler/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/schedulercache"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNodeAffinityPriority(t *testing.T) {
0000000000000000000000000000000000000000;;		label1 := map[string]string{"foo": "bar"}
0000000000000000000000000000000000000000;;		label2 := map[string]string{"key": "value"}
0000000000000000000000000000000000000000;;		label3 := map[string]string{"az": "az1"}
0000000000000000000000000000000000000000;;		label4 := map[string]string{"abc": "az11", "def": "az22"}
0000000000000000000000000000000000000000;;		label5 := map[string]string{"foo": "bar", "key": "value", "az": "az1"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		affinity1 := &v1.Affinity{
0000000000000000000000000000000000000000;;			NodeAffinity: &v1.NodeAffinity{
0000000000000000000000000000000000000000;;				PreferredDuringSchedulingIgnoredDuringExecution: []v1.PreferredSchedulingTerm{{
0000000000000000000000000000000000000000;;					Weight: 2,
0000000000000000000000000000000000000000;;					Preference: v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;						MatchExpressions: []v1.NodeSelectorRequirement{{
0000000000000000000000000000000000000000;;							Key:      "foo",
0000000000000000000000000000000000000000;;							Operator: v1.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;							Values:   []string{"bar"},
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		affinity2 := &v1.Affinity{
0000000000000000000000000000000000000000;;			NodeAffinity: &v1.NodeAffinity{
0000000000000000000000000000000000000000;;				PreferredDuringSchedulingIgnoredDuringExecution: []v1.PreferredSchedulingTerm{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Weight: 2,
0000000000000000000000000000000000000000;;						Preference: v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;							MatchExpressions: []v1.NodeSelectorRequirement{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Key:      "foo",
0000000000000000000000000000000000000000;;									Operator: v1.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;									Values:   []string{"bar"},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Weight: 4,
0000000000000000000000000000000000000000;;						Preference: v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;							MatchExpressions: []v1.NodeSelectorRequirement{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Key:      "key",
0000000000000000000000000000000000000000;;									Operator: v1.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;									Values:   []string{"value"},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Weight: 5,
0000000000000000000000000000000000000000;;						Preference: v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;							MatchExpressions: []v1.NodeSelectorRequirement{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Key:      "foo",
0000000000000000000000000000000000000000;;									Operator: v1.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;									Values:   []string{"bar"},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Key:      "key",
0000000000000000000000000000000000000000;;									Operator: v1.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;									Values:   []string{"value"},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Key:      "az",
0000000000000000000000000000000000000000;;									Operator: v1.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;									Values:   []string{"az1"},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod          *v1.Pod
0000000000000000000000000000000000000000;;			nodes        []*v1.Node
0000000000000000000000000000000000000000;;			expectedList schedulerapi.HostPriorityList
0000000000000000000000000000000000000000;;			test         string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: label1}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: label2}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine3", Labels: label3}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 0}, {Host: "machine3", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "all machines are same priority as NodeAffinity is nil",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: affinity1,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: label4}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: label2}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine3", Labels: label3}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 0}, {Host: "machine2", Score: 0}, {Host: "machine3", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "no machine macthes preferred scheduling requirements in NodeAffinity of pod so all machines' priority is zero",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: affinity1,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: label1}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: label2}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine3", Labels: label3}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 10}, {Host: "machine2", Score: 0}, {Host: "machine3", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "only machine1 matches the preferred scheduling requirements of pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: affinity2,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: label1}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine5", Labels: label5}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: label2}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 1}, {Host: "machine5", Score: 10}, {Host: "machine2", Score: 3}},
0000000000000000000000000000000000000000;;				test:         "all machines matches the preferred scheduling requirements of pod but with different priorities ",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			nodeNameToInfo := schedulercache.CreateNodeNameToInfoMap(nil, test.nodes)
0000000000000000000000000000000000000000;;			nap := priorityFunction(CalculateNodeAffinityPriorityMap, CalculateNodeAffinityPriorityReduce)
0000000000000000000000000000000000000000;;			list, err := nap(test.pod, nodeNameToInfo, test.nodes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.expectedList, list) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: \nexpected %#v, \ngot      %#v", test.test, test.expectedList, list)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
