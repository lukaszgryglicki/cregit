0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d5f46aea2c93b1de0a123b5726fce7d84b42e456;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package priorities
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		schedulerapi "k8s.io/kubernetes/plugin/pkg/scheduler/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/schedulercache"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ImageLocalityPriority is a priority function that favors nodes that already have requested pod container's images.
0000000000000000000000000000000000000000;;	// It will detect whether the requested images are present on a node, and then calculate a score ranging from 0 to 10
0000000000000000000000000000000000000000;;	// based on the total size of those images.
0000000000000000000000000000000000000000;;	// - If none of the images are present, this node will be given the lowest priority.
0000000000000000000000000000000000000000;;	// - If some of the images are present on a node, the larger their sizes' sum, the higher the node's priority.
0000000000000000000000000000000000000000;;	func ImageLocalityPriorityMap(pod *v1.Pod, meta interface{}, nodeInfo *schedulercache.NodeInfo) (schedulerapi.HostPriority, error) {
0000000000000000000000000000000000000000;;		node := nodeInfo.Node()
0000000000000000000000000000000000000000;;		if node == nil {
0000000000000000000000000000000000000000;;			return schedulerapi.HostPriority{}, fmt.Errorf("node not found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var sumSize int64
0000000000000000000000000000000000000000;;		for i := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			sumSize += checkContainerImageOnNode(node, &pod.Spec.Containers[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;			Host:  node.Name,
0000000000000000000000000000000000000000;;			Score: calculateScoreFromSize(sumSize),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// calculateScoreFromSize calculates the priority of a node. sumSize is sum size of requested images on this node.
0000000000000000000000000000000000000000;;	// 1. Split image size range into 10 buckets.
0000000000000000000000000000000000000000;;	// 2. Decide the priority of a given sumSize based on which bucket it belongs to.
0000000000000000000000000000000000000000;;	func calculateScoreFromSize(sumSize int64) int {
0000000000000000000000000000000000000000;;		var score int
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case sumSize == 0 || sumSize < minImgSize:
0000000000000000000000000000000000000000;;			// score == 0 means none of the images required by this pod are present on this
0000000000000000000000000000000000000000;;			// node or the total size of the images present is too small to be taken into further consideration.
0000000000000000000000000000000000000000;;			score = 0
0000000000000000000000000000000000000000;;		// If existing images' total size is larger than max, just make it highest priority.
0000000000000000000000000000000000000000;;		case sumSize >= maxImgSize:
0000000000000000000000000000000000000000;;			score = 10
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			score = int((10 * (sumSize - minImgSize) / (maxImgSize - minImgSize)) + 1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Return which bucket the given size belongs to
0000000000000000000000000000000000000000;;		return score
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkContainerImageOnNode checks if a container image is present on a node and returns its size.
0000000000000000000000000000000000000000;;	func checkContainerImageOnNode(node *v1.Node, container *v1.Container) int64 {
0000000000000000000000000000000000000000;;		for _, image := range node.Status.Images {
0000000000000000000000000000000000000000;;			for _, name := range image.Names {
0000000000000000000000000000000000000000;;				if container.Image == name {
0000000000000000000000000000000000000000;;					// Should return immediately.
0000000000000000000000000000000000000000;;					return image.SizeBytes
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
