0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d5f46aea2c93b1de0a123b5726fce7d84b42e456;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package priorities
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		priorityutil "k8s.io/kubernetes/plugin/pkg/scheduler/algorithm/priorities/util"
0000000000000000000000000000000000000000;;		schedulerapi "k8s.io/kubernetes/plugin/pkg/scheduler/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/schedulercache"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is a reasonable size range of all container images. 90%ile of images on dockerhub drops into this range.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		mb         int64 = 1024 * 1024
0000000000000000000000000000000000000000;;		minImgSize int64 = 23 * mb
0000000000000000000000000000000000000000;;		maxImgSize int64 = 1000 * mb
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Also used in most/least_requested nad metadata.
0000000000000000000000000000000000000000;;	// TODO: despaghettify it
0000000000000000000000000000000000000000;;	func getNonZeroRequests(pod *v1.Pod) *schedulercache.Resource {
0000000000000000000000000000000000000000;;		result := &schedulercache.Resource{}
0000000000000000000000000000000000000000;;		for i := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			container := &pod.Spec.Containers[i]
0000000000000000000000000000000000000000;;			cpu, memory := priorityutil.GetNonzeroRequests(&container.Resources.Requests)
0000000000000000000000000000000000000000;;			result.MilliCPU += cpu
0000000000000000000000000000000000000000;;			result.Memory += memory
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func calculateBalancedResourceAllocation(pod *v1.Pod, podRequests *schedulercache.Resource, nodeInfo *schedulercache.NodeInfo) (schedulerapi.HostPriority, error) {
0000000000000000000000000000000000000000;;		node := nodeInfo.Node()
0000000000000000000000000000000000000000;;		if node == nil {
0000000000000000000000000000000000000000;;			return schedulerapi.HostPriority{}, fmt.Errorf("node not found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allocatableResources := nodeInfo.AllocatableResource()
0000000000000000000000000000000000000000;;		totalResources := *podRequests
0000000000000000000000000000000000000000;;		totalResources.MilliCPU += nodeInfo.NonZeroRequest().MilliCPU
0000000000000000000000000000000000000000;;		totalResources.Memory += nodeInfo.NonZeroRequest().Memory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cpuFraction := fractionOfCapacity(totalResources.MilliCPU, allocatableResources.MilliCPU)
0000000000000000000000000000000000000000;;		memoryFraction := fractionOfCapacity(totalResources.Memory, allocatableResources.Memory)
0000000000000000000000000000000000000000;;		score := int(0)
0000000000000000000000000000000000000000;;		if cpuFraction >= 1 || memoryFraction >= 1 {
0000000000000000000000000000000000000000;;			// if requested >= capacity, the corresponding host should never be preferred.
0000000000000000000000000000000000000000;;			score = 0
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Upper and lower boundary of difference between cpuFraction and memoryFraction are -1 and 1
0000000000000000000000000000000000000000;;			// respectively. Multilying the absolute value of the difference by 10 scales the value to
0000000000000000000000000000000000000000;;			// 0-10 with 0 representing well balanced allocation and 10 poorly balanced. Subtracting it from
0000000000000000000000000000000000000000;;			// 10 leads to the score which also scales from 0 to 10 while 10 representing well balanced.
0000000000000000000000000000000000000000;;			diff := math.Abs(cpuFraction - memoryFraction)
0000000000000000000000000000000000000000;;			score = int(10 - diff*10)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if glog.V(10) {
0000000000000000000000000000000000000000;;			// We explicitly don't do glog.V(10).Infof() to avoid computing all the parameters if this is
0000000000000000000000000000000000000000;;			// not logged. There is visible performance gain from it.
0000000000000000000000000000000000000000;;			glog.V(10).Infof(
0000000000000000000000000000000000000000;;				"%v -> %v: Balanced Resource Allocation, capacity %d millicores %d memory bytes, total request %d millicores %d memory bytes, score %d",
0000000000000000000000000000000000000000;;				pod.Name, node.Name,
0000000000000000000000000000000000000000;;				allocatableResources.MilliCPU, allocatableResources.Memory,
0000000000000000000000000000000000000000;;				totalResources.MilliCPU, totalResources.Memory,
0000000000000000000000000000000000000000;;				score,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;			Host:  node.Name,
0000000000000000000000000000000000000000;;			Score: score,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fractionOfCapacity(requested, capacity int64) float64 {
0000000000000000000000000000000000000000;;		if capacity == 0 {
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return float64(requested) / float64(capacity)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BalancedResourceAllocation favors nodes with balanced resource usage rate.
0000000000000000000000000000000000000000;;	// BalancedResourceAllocation should **NOT** be used alone, and **MUST** be used together with LeastRequestedPriority.
0000000000000000000000000000000000000000;;	// It calculates the difference between the cpu and memory fracion of capacity, and prioritizes the host based on how
0000000000000000000000000000000000000000;;	// close the two metrics are to each other.
0000000000000000000000000000000000000000;;	// Detail: score = 10 - abs(cpuFraction-memoryFraction)*10. The algorithm is partly inspired by:
0000000000000000000000000000000000000000;;	// "Wei Huang et al. An Energy Efficient Virtual Machine Placement Algorithm with Balanced Resource Utilization"
0000000000000000000000000000000000000000;;	func BalancedResourceAllocationMap(pod *v1.Pod, meta interface{}, nodeInfo *schedulercache.NodeInfo) (schedulerapi.HostPriority, error) {
0000000000000000000000000000000000000000;;		var nonZeroRequest *schedulercache.Resource
0000000000000000000000000000000000000000;;		if priorityMeta, ok := meta.(*priorityMetadata); ok {
0000000000000000000000000000000000000000;;			nonZeroRequest = priorityMeta.nonZeroRequest
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// We couldn't parse metadatat - fallback to computing it.
0000000000000000000000000000000000000000;;			nonZeroRequest = getNonZeroRequests(pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return calculateBalancedResourceAllocation(pod, nonZeroRequest, nodeInfo)
0000000000000000000000000000000000000000;;	}
