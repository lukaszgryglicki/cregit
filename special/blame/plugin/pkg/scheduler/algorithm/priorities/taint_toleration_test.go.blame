0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f9d18465d02f51f1518cc71090b0582fe383aad6;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package priorities
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		schedulerapi "k8s.io/kubernetes/plugin/pkg/scheduler/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/schedulercache"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nodeWithTaints(nodeName string, taints []v1.Taint) *v1.Node {
0000000000000000000000000000000000000000;;		return &v1.Node{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: nodeName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;				Taints: taints,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func podWithTolerations(tolerations []v1.Toleration) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Tolerations: tolerations,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This function will create a set of nodes and pods and test the priority
0000000000000000000000000000000000000000;;	// Nodes with zero,one,two,three,four and hundred taints are created
0000000000000000000000000000000000000000;;	// Pods with zero,one,two,three,four and hundred tolerations are created
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTaintAndToleration(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod          *v1.Pod
0000000000000000000000000000000000000000;;			nodes        []*v1.Node
0000000000000000000000000000000000000000;;			expectedList schedulerapi.HostPriorityList
0000000000000000000000000000000000000000;;			test         string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// basic test case
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test: "node with taints tolerated by the pod, gets a higher score than those node with intolerable taints",
0000000000000000000000000000000000000000;;				pod: podWithTolerations([]v1.Toleration{{
0000000000000000000000000000000000000000;;					Key:      "foo",
0000000000000000000000000000000000000000;;					Operator: v1.TolerationOpEqual,
0000000000000000000000000000000000000000;;					Value:    "bar",
0000000000000000000000000000000000000000;;					Effect:   v1.TaintEffectPreferNoSchedule,
0000000000000000000000000000000000000000;;				}}),
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					nodeWithTaints("nodeA", []v1.Taint{{
0000000000000000000000000000000000000000;;						Key:    "foo",
0000000000000000000000000000000000000000;;						Value:  "bar",
0000000000000000000000000000000000000000;;						Effect: v1.TaintEffectPreferNoSchedule,
0000000000000000000000000000000000000000;;					}}),
0000000000000000000000000000000000000000;;					nodeWithTaints("nodeB", []v1.Taint{{
0000000000000000000000000000000000000000;;						Key:    "foo",
0000000000000000000000000000000000000000;;						Value:  "blah",
0000000000000000000000000000000000000000;;						Effect: v1.TaintEffectPreferNoSchedule,
0000000000000000000000000000000000000000;;					}}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;					{Host: "nodeA", Score: 10},
0000000000000000000000000000000000000000;;					{Host: "nodeB", Score: 0},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// the count of taints that are tolerated by pod, does not matter.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test: "the nodes that all of their taints are tolerated by the pod, get the same score, no matter how many tolerable taints a node has",
0000000000000000000000000000000000000000;;				pod: podWithTolerations([]v1.Toleration{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Key:      "cpu-type",
0000000000000000000000000000000000000000;;						Operator: v1.TolerationOpEqual,
0000000000000000000000000000000000000000;;						Value:    "arm64",
0000000000000000000000000000000000000000;;						Effect:   v1.TaintEffectPreferNoSchedule,
0000000000000000000000000000000000000000;;					}, {
0000000000000000000000000000000000000000;;						Key:      "disk-type",
0000000000000000000000000000000000000000;;						Operator: v1.TolerationOpEqual,
0000000000000000000000000000000000000000;;						Value:    "ssd",
0000000000000000000000000000000000000000;;						Effect:   v1.TaintEffectPreferNoSchedule,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					nodeWithTaints("nodeA", []v1.Taint{}),
0000000000000000000000000000000000000000;;					nodeWithTaints("nodeB", []v1.Taint{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Key:    "cpu-type",
0000000000000000000000000000000000000000;;							Value:  "arm64",
0000000000000000000000000000000000000000;;							Effect: v1.TaintEffectPreferNoSchedule,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;					nodeWithTaints("nodeC", []v1.Taint{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Key:    "cpu-type",
0000000000000000000000000000000000000000;;							Value:  "arm64",
0000000000000000000000000000000000000000;;							Effect: v1.TaintEffectPreferNoSchedule,
0000000000000000000000000000000000000000;;						}, {
0000000000000000000000000000000000000000;;							Key:    "disk-type",
0000000000000000000000000000000000000000;;							Value:  "ssd",
0000000000000000000000000000000000000000;;							Effect: v1.TaintEffectPreferNoSchedule,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;					{Host: "nodeA", Score: 10},
0000000000000000000000000000000000000000;;					{Host: "nodeB", Score: 10},
0000000000000000000000000000000000000000;;					{Host: "nodeC", Score: 10},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// the count of taints on a node that are not tolerated by pod, matters.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test: "the more intolerable taints a node has, the lower score it gets.",
0000000000000000000000000000000000000000;;				pod: podWithTolerations([]v1.Toleration{{
0000000000000000000000000000000000000000;;					Key:      "foo",
0000000000000000000000000000000000000000;;					Operator: v1.TolerationOpEqual,
0000000000000000000000000000000000000000;;					Value:    "bar",
0000000000000000000000000000000000000000;;					Effect:   v1.TaintEffectPreferNoSchedule,
0000000000000000000000000000000000000000;;				}}),
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					nodeWithTaints("nodeA", []v1.Taint{}),
0000000000000000000000000000000000000000;;					nodeWithTaints("nodeB", []v1.Taint{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Key:    "cpu-type",
0000000000000000000000000000000000000000;;							Value:  "arm64",
0000000000000000000000000000000000000000;;							Effect: v1.TaintEffectPreferNoSchedule,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;					nodeWithTaints("nodeC", []v1.Taint{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Key:    "cpu-type",
0000000000000000000000000000000000000000;;							Value:  "arm64",
0000000000000000000000000000000000000000;;							Effect: v1.TaintEffectPreferNoSchedule,
0000000000000000000000000000000000000000;;						}, {
0000000000000000000000000000000000000000;;							Key:    "disk-type",
0000000000000000000000000000000000000000;;							Value:  "ssd",
0000000000000000000000000000000000000000;;							Effect: v1.TaintEffectPreferNoSchedule,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;					{Host: "nodeA", Score: 10},
0000000000000000000000000000000000000000;;					{Host: "nodeB", Score: 5},
0000000000000000000000000000000000000000;;					{Host: "nodeC", Score: 0},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// taints-tolerations priority only takes care about the taints and tolerations that have effect PreferNoSchedule
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test: "only taints and tolerations that have effect PreferNoSchedule are checked by taints-tolerations priority function",
0000000000000000000000000000000000000000;;				pod: podWithTolerations([]v1.Toleration{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Key:      "cpu-type",
0000000000000000000000000000000000000000;;						Operator: v1.TolerationOpEqual,
0000000000000000000000000000000000000000;;						Value:    "arm64",
0000000000000000000000000000000000000000;;						Effect:   v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;					}, {
0000000000000000000000000000000000000000;;						Key:      "disk-type",
0000000000000000000000000000000000000000;;						Operator: v1.TolerationOpEqual,
0000000000000000000000000000000000000000;;						Value:    "ssd",
0000000000000000000000000000000000000000;;						Effect:   v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					nodeWithTaints("nodeA", []v1.Taint{}),
0000000000000000000000000000000000000000;;					nodeWithTaints("nodeB", []v1.Taint{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Key:    "cpu-type",
0000000000000000000000000000000000000000;;							Value:  "arm64",
0000000000000000000000000000000000000000;;							Effect: v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;					nodeWithTaints("nodeC", []v1.Taint{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Key:    "cpu-type",
0000000000000000000000000000000000000000;;							Value:  "arm64",
0000000000000000000000000000000000000000;;							Effect: v1.TaintEffectPreferNoSchedule,
0000000000000000000000000000000000000000;;						}, {
0000000000000000000000000000000000000000;;							Key:    "disk-type",
0000000000000000000000000000000000000000;;							Value:  "ssd",
0000000000000000000000000000000000000000;;							Effect: v1.TaintEffectPreferNoSchedule,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;					{Host: "nodeA", Score: 10},
0000000000000000000000000000000000000000;;					{Host: "nodeB", Score: 10},
0000000000000000000000000000000000000000;;					{Host: "nodeC", Score: 0},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test: "Default behaviour No taints and tolerations, lands on node with no taints",
0000000000000000000000000000000000000000;;				//pod without tolerations
0000000000000000000000000000000000000000;;				pod: podWithTolerations([]v1.Toleration{}),
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					//Node without taints
0000000000000000000000000000000000000000;;					nodeWithTaints("nodeA", []v1.Taint{}),
0000000000000000000000000000000000000000;;					nodeWithTaints("nodeB", []v1.Taint{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Key:    "cpu-type",
0000000000000000000000000000000000000000;;							Value:  "arm64",
0000000000000000000000000000000000000000;;							Effect: v1.TaintEffectPreferNoSchedule,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;					{Host: "nodeA", Score: 10},
0000000000000000000000000000000000000000;;					{Host: "nodeB", Score: 0},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			nodeNameToInfo := schedulercache.CreateNodeNameToInfoMap(nil, test.nodes)
0000000000000000000000000000000000000000;;			ttp := priorityFunction(ComputeTaintTolerationPriorityMap, ComputeTaintTolerationPriorityReduce)
0000000000000000000000000000000000000000;;			list, err := ttp(test.pod, nodeNameToInfo, test.nodes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s, unexpected error: %v", test.test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.expectedList, list) {
0000000000000000000000000000000000000000;;				t.Errorf("%s,\nexpected:\n\t%+v,\ngot:\n\t%+v", test.test, test.expectedList, list)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
