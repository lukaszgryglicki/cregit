0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d5f46aea2c93b1de0a123b5726fce7d84b42e456;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package priorities
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		schedulerapi "k8s.io/kubernetes/plugin/pkg/scheduler/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/schedulercache"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestImageLocalityPriority(t *testing.T) {
0000000000000000000000000000000000000000;;		test_40_250 := v1.PodSpec{
0000000000000000000000000000000000000000;;			Containers: []v1.Container{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Image: "gcr.io/40",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Image: "gcr.io/250",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		test_40_140 := v1.PodSpec{
0000000000000000000000000000000000000000;;			Containers: []v1.Container{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Image: "gcr.io/40",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Image: "gcr.io/140",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		test_min_max := v1.PodSpec{
0000000000000000000000000000000000000000;;			Containers: []v1.Container{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Image: "gcr.io/10",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Image: "gcr.io/2000",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node_40_140_2000 := v1.NodeStatus{
0000000000000000000000000000000000000000;;			Images: []v1.ContainerImage{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Names: []string{
0000000000000000000000000000000000000000;;						"gcr.io/40",
0000000000000000000000000000000000000000;;						"gcr.io/40:v1",
0000000000000000000000000000000000000000;;						"gcr.io/40:v1",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					SizeBytes: int64(40 * mb),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Names: []string{
0000000000000000000000000000000000000000;;						"gcr.io/140",
0000000000000000000000000000000000000000;;						"gcr.io/140:v1",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					SizeBytes: int64(140 * mb),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Names: []string{
0000000000000000000000000000000000000000;;						"gcr.io/2000",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					SizeBytes: int64(2000 * mb),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node_250_10 := v1.NodeStatus{
0000000000000000000000000000000000000000;;			Images: []v1.ContainerImage{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Names: []string{
0000000000000000000000000000000000000000;;						"gcr.io/250",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					SizeBytes: int64(250 * mb),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Names: []string{
0000000000000000000000000000000000000000;;						"gcr.io/10",
0000000000000000000000000000000000000000;;						"gcr.io/10:v1",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					SizeBytes: int64(10 * mb),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod          *v1.Pod
0000000000000000000000000000000000000000;;			pods         []*v1.Pod
0000000000000000000000000000000000000000;;			nodes        []*v1.Node
0000000000000000000000000000000000000000;;			expectedList schedulerapi.HostPriorityList
0000000000000000000000000000000000000000;;			test         string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Pod: gcr.io/40 gcr.io/250
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Node1
0000000000000000000000000000000000000000;;				// Image: gcr.io/40 40MB
0000000000000000000000000000000000000000;;				// Score: (40M-23M)/97.7M + 1 = 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Node2
0000000000000000000000000000000000000000;;				// Image: gcr.io/250 250MB
0000000000000000000000000000000000000000;;				// Score: (250M-23M)/97.7M + 1 = 3
0000000000000000000000000000000000000000;;				pod:          &v1.Pod{Spec: test_40_250},
0000000000000000000000000000000000000000;;				nodes:        []*v1.Node{makeImageNode("machine1", node_40_140_2000), makeImageNode("machine2", node_250_10)},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 1}, {Host: "machine2", Score: 3}},
0000000000000000000000000000000000000000;;				test:         "two images spread on two nodes, prefer the larger image one",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Pod: gcr.io/40 gcr.io/140
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Node1
0000000000000000000000000000000000000000;;				// Image: gcr.io/40 40MB, gcr.io/140 140MB
0000000000000000000000000000000000000000;;				// Score: (40M+140M-23M)/97.7M + 1 = 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Node2
0000000000000000000000000000000000000000;;				// Image: not present
0000000000000000000000000000000000000000;;				// Score: 0
0000000000000000000000000000000000000000;;				pod:          &v1.Pod{Spec: test_40_140},
0000000000000000000000000000000000000000;;				nodes:        []*v1.Node{makeImageNode("machine1", node_40_140_2000), makeImageNode("machine2", node_250_10)},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 2}, {Host: "machine2", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "two images on one node, prefer this node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Pod: gcr.io/2000 gcr.io/10
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Node1
0000000000000000000000000000000000000000;;				// Image: gcr.io/2000 2000MB
0000000000000000000000000000000000000000;;				// Score: 2000 > max score = 10
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Node2
0000000000000000000000000000000000000000;;				// Image: gcr.io/10 10MB
0000000000000000000000000000000000000000;;				// Score: 10 < min score = 0
0000000000000000000000000000000000000000;;				pod:          &v1.Pod{Spec: test_min_max},
0000000000000000000000000000000000000000;;				nodes:        []*v1.Node{makeImageNode("machine1", node_40_140_2000), makeImageNode("machine2", node_250_10)},
0000000000000000000000000000000000000000;;				expectedList: []schedulerapi.HostPriority{{Host: "machine1", Score: 10}, {Host: "machine2", Score: 0}},
0000000000000000000000000000000000000000;;				test:         "if exceed limit, use limit",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			nodeNameToInfo := schedulercache.CreateNodeNameToInfoMap(test.pods, test.nodes)
0000000000000000000000000000000000000000;;			list, err := priorityFunction(ImageLocalityPriorityMap, nil)(test.pod, nodeNameToInfo, test.nodes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			sort.Sort(test.expectedList)
0000000000000000000000000000000000000000;;			sort.Sort(list)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.expectedList, list) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %#v, got %#v", test.test, test.expectedList, list)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeImageNode(node string, status v1.NodeStatus) *v1.Node {
0000000000000000000000000000000000000000;;		return &v1.Node{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: node},
0000000000000000000000000000000000000000;;			Status:     status,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
