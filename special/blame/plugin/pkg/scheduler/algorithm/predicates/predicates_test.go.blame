0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f3c02f37857893ba7cd243453c58d27e33395de4;pkg/scheduler/predicates_test.go[pkg/scheduler/predicates_test.go][plugin/pkg/scheduler/algorithm/predicates/predicates_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package predicates
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		kubeletapis "k8s.io/kubernetes/pkg/kubelet/apis"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/schedulercache"
0000000000000000000000000000000000000000;;		schedulertesting "k8s.io/kubernetes/plugin/pkg/scheduler/testing"
0000000000000000000000000000000000000000;;		schedutil "k8s.io/kubernetes/plugin/pkg/scheduler/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeNodeInfo v1.Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n FakeNodeInfo) GetNodeInfo(nodeName string) (*v1.Node, error) {
0000000000000000000000000000000000000000;;		node := v1.Node(n)
0000000000000000000000000000000000000000;;		return &node, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeNodeListInfo []v1.Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (nodes FakeNodeListInfo) GetNodeInfo(nodeName string) (*v1.Node, error) {
0000000000000000000000000000000000000000;;		for _, node := range nodes {
0000000000000000000000000000000000000000;;			if node.Name == nodeName {
0000000000000000000000000000000000000000;;				return &node, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Unable to find node: %s", nodeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakePersistentVolumeClaimInfo []v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pvcs FakePersistentVolumeClaimInfo) GetPersistentVolumeClaimInfo(namespace string, pvcID string) (*v1.PersistentVolumeClaim, error) {
0000000000000000000000000000000000000000;;		for _, pvc := range pvcs {
0000000000000000000000000000000000000000;;			if pvc.Name == pvcID && pvc.Namespace == namespace {
0000000000000000000000000000000000000000;;				return &pvc, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Unable to find persistent volume claim: %s/%s", namespace, pvcID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakePersistentVolumeInfo []v1.PersistentVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pvs FakePersistentVolumeInfo) GetPersistentVolumeInfo(pvID string) (*v1.PersistentVolume, error) {
0000000000000000000000000000000000000000;;		for _, pv := range pvs {
0000000000000000000000000000000000000000;;			if pv.Name == pvID {
0000000000000000000000000000000000000000;;				return &pv, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Unable to find persistent volume: %s", pvID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		opaqueResourceA = v1helper.OpaqueIntResourceName("AAA")
0000000000000000000000000000000000000000;;		opaqueResourceB = v1helper.OpaqueIntResourceName("BBB")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeResources(milliCPU, memory, nvidiaGPUs, pods, opaqueA, storage int64) v1.NodeResources {
0000000000000000000000000000000000000000;;		return v1.NodeResources{
0000000000000000000000000000000000000000;;			Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;				v1.ResourceCPU:       *resource.NewMilliQuantity(milliCPU, resource.DecimalSI),
0000000000000000000000000000000000000000;;				v1.ResourceMemory:    *resource.NewQuantity(memory, resource.BinarySI),
0000000000000000000000000000000000000000;;				v1.ResourcePods:      *resource.NewQuantity(pods, resource.DecimalSI),
0000000000000000000000000000000000000000;;				v1.ResourceNvidiaGPU: *resource.NewQuantity(nvidiaGPUs, resource.DecimalSI),
0000000000000000000000000000000000000000;;				opaqueResourceA:      *resource.NewQuantity(opaqueA, resource.DecimalSI),
0000000000000000000000000000000000000000;;				v1.ResourceStorage:   *resource.NewQuantity(storage, resource.BinarySI),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeAllocatableResources(milliCPU, memory, nvidiaGPUs, pods, opaqueA, storage int64) v1.ResourceList {
0000000000000000000000000000000000000000;;		return v1.ResourceList{
0000000000000000000000000000000000000000;;			v1.ResourceCPU:       *resource.NewMilliQuantity(milliCPU, resource.DecimalSI),
0000000000000000000000000000000000000000;;			v1.ResourceMemory:    *resource.NewQuantity(memory, resource.BinarySI),
0000000000000000000000000000000000000000;;			v1.ResourcePods:      *resource.NewQuantity(pods, resource.DecimalSI),
0000000000000000000000000000000000000000;;			v1.ResourceNvidiaGPU: *resource.NewQuantity(nvidiaGPUs, resource.DecimalSI),
0000000000000000000000000000000000000000;;			opaqueResourceA:      *resource.NewQuantity(opaqueA, resource.DecimalSI),
0000000000000000000000000000000000000000;;			v1.ResourceStorage:   *resource.NewQuantity(storage, resource.BinarySI),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newResourcePod(usage ...schedulercache.Resource) *v1.Pod {
0000000000000000000000000000000000000000;;		containers := []v1.Container{}
0000000000000000000000000000000000000000;;		for _, req := range usage {
0000000000000000000000000000000000000000;;			containers = append(containers, v1.Container{
0000000000000000000000000000000000000000;;				Resources: v1.ResourceRequirements{Requests: req.ResourceList()},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: containers,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addStorageLimit(pod *v1.Pod, sizeLimit int64, medium v1.StorageMedium) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: pod.Spec.Containers,
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "emptyDirVolumeName",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							EmptyDir: &v1.EmptyDirVolumeSource{
0000000000000000000000000000000000000000;;								SizeLimit: *resource.NewQuantity(sizeLimit, resource.BinarySI),
0000000000000000000000000000000000000000;;								Medium:    medium,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newResourceInitPod(pod *v1.Pod, usage ...schedulercache.Resource) *v1.Pod {
0000000000000000000000000000000000000000;;		pod.Spec.InitContainers = newResourcePod(usage...).Spec.Containers
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PredicateMetadata(p *v1.Pod, nodeInfo map[string]*schedulercache.NodeInfo) interface{} {
0000000000000000000000000000000000000000;;		pm := PredicateMetadataFactory{schedulertesting.FakePodLister{p}}
0000000000000000000000000000000000000000;;		return pm.GetMetadata(p, nodeInfo)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodFitsResources(t *testing.T) {
0000000000000000000000000000000000000000;;		enoughPodsTests := []struct {
0000000000000000000000000000000000000000;;			pod      *v1.Pod
0000000000000000000000000000000000000000;;			nodeInfo *schedulercache.NodeInfo
0000000000000000000000000000000000000000;;			fits     bool
0000000000000000000000000000000000000000;;			test     string
0000000000000000000000000000000000000000;;			reasons  []algorithm.PredicateFailureReason
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{},
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 10, Memory: 20})),
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "no resources requested always fits",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourcePod(schedulercache.Resource{MilliCPU: 1, Memory: 1}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 10, Memory: 20})),
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "too many resources fails",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{
0000000000000000000000000000000000000000;;					NewInsufficientResourceError(v1.ResourceCPU, 1, 10, 10),
0000000000000000000000000000000000000000;;					NewInsufficientResourceError(v1.ResourceMemory, 1, 20, 20),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourceInitPod(newResourcePod(schedulercache.Resource{MilliCPU: 1, Memory: 1}), schedulercache.Resource{MilliCPU: 3, Memory: 1}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 8, Memory: 19})),
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				test:    "too many resources fails due to init container cpu",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{NewInsufficientResourceError(v1.ResourceCPU, 3, 8, 10)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourceInitPod(newResourcePod(schedulercache.Resource{MilliCPU: 1, Memory: 1}), schedulercache.Resource{MilliCPU: 3, Memory: 1}, schedulercache.Resource{MilliCPU: 2, Memory: 1}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 8, Memory: 19})),
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				test:    "too many resources fails due to highest init container cpu",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{NewInsufficientResourceError(v1.ResourceCPU, 3, 8, 10)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourceInitPod(newResourcePod(schedulercache.Resource{MilliCPU: 1, Memory: 1}), schedulercache.Resource{MilliCPU: 1, Memory: 3}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 9, Memory: 19})),
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				test:    "too many resources fails due to init container memory",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{NewInsufficientResourceError(v1.ResourceMemory, 3, 19, 20)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourceInitPod(newResourcePod(schedulercache.Resource{MilliCPU: 1, Memory: 1}), schedulercache.Resource{MilliCPU: 1, Memory: 3}, schedulercache.Resource{MilliCPU: 1, Memory: 2}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 9, Memory: 19})),
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				test:    "too many resources fails due to highest init container memory",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{NewInsufficientResourceError(v1.ResourceMemory, 3, 19, 20)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourceInitPod(newResourcePod(schedulercache.Resource{MilliCPU: 1, Memory: 1}), schedulercache.Resource{MilliCPU: 1, Memory: 1}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 9, Memory: 19})),
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "init container fits because it's the max, not sum, of containers and init containers",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourceInitPod(newResourcePod(schedulercache.Resource{MilliCPU: 1, Memory: 1}), schedulercache.Resource{MilliCPU: 1, Memory: 1}, schedulercache.Resource{MilliCPU: 1, Memory: 1}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 9, Memory: 19})),
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "multiple init containers fit because it's the max, not sum, of containers and init containers",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourcePod(schedulercache.Resource{MilliCPU: 1, Memory: 1}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 5, Memory: 5})),
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "both resources fit",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourcePod(schedulercache.Resource{MilliCPU: 2, Memory: 1}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 9, Memory: 5})),
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				test:    "one resource memory fits",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{NewInsufficientResourceError(v1.ResourceCPU, 2, 9, 10)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourcePod(schedulercache.Resource{MilliCPU: 1, Memory: 2}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 5, Memory: 19})),
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				test:    "one resource cpu fits",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{NewInsufficientResourceError(v1.ResourceMemory, 2, 19, 20)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourcePod(schedulercache.Resource{MilliCPU: 5, Memory: 1}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 5, Memory: 19})),
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "equal edge case",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourceInitPod(newResourcePod(schedulercache.Resource{MilliCPU: 4, Memory: 1}), schedulercache.Resource{MilliCPU: 5, Memory: 1}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 5, Memory: 19})),
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "equal edge case for init container",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      newResourcePod(schedulercache.Resource{OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceA: 1}}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(newResourcePod(schedulercache.Resource{})),
0000000000000000000000000000000000000000;;				fits:     true,
0000000000000000000000000000000000000000;;				test:     "opaque resource fits",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      newResourceInitPod(newResourcePod(schedulercache.Resource{}), schedulercache.Resource{OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceA: 1}}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(newResourcePod(schedulercache.Resource{})),
0000000000000000000000000000000000000000;;				fits:     true,
0000000000000000000000000000000000000000;;				test:     "opaque resource fits for init container",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourcePod(
0000000000000000000000000000000000000000;;					schedulercache.Resource{MilliCPU: 1, Memory: 1, OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceA: 10}}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 0, Memory: 0, OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceA: 0}})),
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				test:    "opaque resource capacity enforced",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{NewInsufficientResourceError(opaqueResourceA, 10, 0, 5)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourceInitPod(newResourcePod(schedulercache.Resource{}),
0000000000000000000000000000000000000000;;					schedulercache.Resource{MilliCPU: 1, Memory: 1, OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceA: 10}}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 0, Memory: 0, OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceA: 0}})),
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				test:    "opaque resource capacity enforced for init container",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{NewInsufficientResourceError(opaqueResourceA, 10, 0, 5)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourcePod(
0000000000000000000000000000000000000000;;					schedulercache.Resource{MilliCPU: 1, Memory: 1, OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceA: 1}}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 0, Memory: 0, OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceA: 5}})),
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				test:    "opaque resource allocatable enforced",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{NewInsufficientResourceError(opaqueResourceA, 1, 5, 5)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourceInitPod(newResourcePod(schedulercache.Resource{}),
0000000000000000000000000000000000000000;;					schedulercache.Resource{MilliCPU: 1, Memory: 1, OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceA: 1}}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 0, Memory: 0, OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceA: 5}})),
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				test:    "opaque resource allocatable enforced for init container",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{NewInsufficientResourceError(opaqueResourceA, 1, 5, 5)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourcePod(
0000000000000000000000000000000000000000;;					schedulercache.Resource{MilliCPU: 1, Memory: 1, OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceA: 3}},
0000000000000000000000000000000000000000;;					schedulercache.Resource{MilliCPU: 1, Memory: 1, OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceA: 3}}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 0, Memory: 0, OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceA: 2}})),
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				test:    "opaque resource allocatable enforced for multiple containers",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{NewInsufficientResourceError(opaqueResourceA, 6, 2, 5)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourceInitPod(newResourcePod(schedulercache.Resource{}),
0000000000000000000000000000000000000000;;					schedulercache.Resource{MilliCPU: 1, Memory: 1, OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceA: 3}},
0000000000000000000000000000000000000000;;					schedulercache.Resource{MilliCPU: 1, Memory: 1, OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceA: 3}}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 0, Memory: 0, OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceA: 2}})),
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "opaque resource allocatable admits multiple init containers",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourceInitPod(newResourcePod(schedulercache.Resource{}),
0000000000000000000000000000000000000000;;					schedulercache.Resource{MilliCPU: 1, Memory: 1, OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceA: 6}},
0000000000000000000000000000000000000000;;					schedulercache.Resource{MilliCPU: 1, Memory: 1, OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceA: 3}}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 0, Memory: 0, OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceA: 2}})),
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				test:    "opaque resource allocatable enforced for multiple init containers",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{NewInsufficientResourceError(opaqueResourceA, 6, 2, 5)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourcePod(
0000000000000000000000000000000000000000;;					schedulercache.Resource{MilliCPU: 1, Memory: 1, OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceB: 1}}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 0, Memory: 0})),
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				test:    "opaque resource allocatable enforced for unknown resource",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{NewInsufficientResourceError(opaqueResourceB, 1, 0, 0)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourceInitPod(newResourcePod(schedulercache.Resource{}),
0000000000000000000000000000000000000000;;					schedulercache.Resource{MilliCPU: 1, Memory: 1, OpaqueIntResources: map[v1.ResourceName]int64{opaqueResourceB: 1}}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 0, Memory: 0})),
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				test:    "opaque resource allocatable enforced for unknown resource for init container",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{NewInsufficientResourceError(opaqueResourceB, 1, 0, 0)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range enoughPodsTests {
0000000000000000000000000000000000000000;;			node := v1.Node{Status: v1.NodeStatus{Capacity: makeResources(10, 20, 0, 32, 5, 20).Capacity, Allocatable: makeAllocatableResources(10, 20, 0, 32, 5, 20)}}
0000000000000000000000000000000000000000;;			test.nodeInfo.SetNode(&node)
0000000000000000000000000000000000000000;;			fits, reasons, err := PodFitsResources(test.pod, PredicateMetadata(test.pod, nil), test.nodeInfo)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !fits && !reflect.DeepEqual(reasons, test.reasons) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected failure reasons: %v, want: %v", test.test, reasons, test.reasons)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fits != test.fits {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected: %v got %v", test.test, test.fits, fits)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		notEnoughPodsTests := []struct {
0000000000000000000000000000000000000000;;			pod      *v1.Pod
0000000000000000000000000000000000000000;;			nodeInfo *schedulercache.NodeInfo
0000000000000000000000000000000000000000;;			fits     bool
0000000000000000000000000000000000000000;;			test     string
0000000000000000000000000000000000000000;;			reasons  []algorithm.PredicateFailureReason
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{},
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 10, Memory: 20})),
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				test:    "even without specified resources predicate fails when there's no space for additional pod",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{NewInsufficientResourceError(v1.ResourcePods, 1, 1, 1)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourcePod(schedulercache.Resource{MilliCPU: 1, Memory: 1}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 5, Memory: 5})),
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				test:    "even if both resources fit predicate fails when there's no space for additional pod",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{NewInsufficientResourceError(v1.ResourcePods, 1, 1, 1)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourcePod(schedulercache.Resource{MilliCPU: 5, Memory: 1}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 5, Memory: 19})),
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				test:    "even for equal edge case predicate fails when there's no space for additional pod",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{NewInsufficientResourceError(v1.ResourcePods, 1, 1, 1)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourceInitPod(newResourcePod(schedulercache.Resource{MilliCPU: 5, Memory: 1}), schedulercache.Resource{MilliCPU: 5, Memory: 1}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 5, Memory: 19})),
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				test:    "even for equal edge case predicate fails when there's no space for additional pod due to init container",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{NewInsufficientResourceError(v1.ResourcePods, 1, 1, 1)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range notEnoughPodsTests {
0000000000000000000000000000000000000000;;			node := v1.Node{Status: v1.NodeStatus{Capacity: v1.ResourceList{}, Allocatable: makeAllocatableResources(10, 20, 0, 1, 0, 0)}}
0000000000000000000000000000000000000000;;			test.nodeInfo.SetNode(&node)
0000000000000000000000000000000000000000;;			fits, reasons, err := PodFitsResources(test.pod, PredicateMetadata(test.pod, nil), test.nodeInfo)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !fits && !reflect.DeepEqual(reasons, test.reasons) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected failure reasons: %v, want: %v", test.test, reasons, test.reasons)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fits != test.fits {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected: %v got %v", test.test, test.fits, fits)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storagePodsTests := []struct {
0000000000000000000000000000000000000000;;			pod           *v1.Pod
0000000000000000000000000000000000000000;;			emptyDirLimit int64
0000000000000000000000000000000000000000;;			storageMedium v1.StorageMedium
0000000000000000000000000000000000000000;;			nodeInfo      *schedulercache.NodeInfo
0000000000000000000000000000000000000000;;			fits          bool
0000000000000000000000000000000000000000;;			test          string
0000000000000000000000000000000000000000;;			reasons       []algorithm.PredicateFailureReason
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourcePod(schedulercache.Resource{MilliCPU: 1, Memory: 1, StorageOverlay: 1}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 10, Memory: 10, StorageOverlay: 20})),
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "due to container scratch disk",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{
0000000000000000000000000000000000000000;;					NewInsufficientResourceError(v1.ResourceCPU, 1, 10, 10),
0000000000000000000000000000000000000000;;					NewInsufficientResourceError(v1.ResourceStorageScratch, 1, 20, 20),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourcePod(schedulercache.Resource{MilliCPU: 1, Memory: 1, StorageOverlay: 10}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 2, Memory: 10})),
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "pod fit",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourcePod(schedulercache.Resource{MilliCPU: 1, Memory: 1, StorageOverlay: 18}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 2, Memory: 2, StorageOverlay: 5})),
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "request exceeds allocatable overlay storage resource",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{
0000000000000000000000000000000000000000;;					NewInsufficientResourceError(v1.ResourceStorageScratch, 18, 5, 20),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourcePod(schedulercache.Resource{StorageOverlay: 18}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 2, Memory: 2, StorageOverlay: 5})),
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "request exceeds allocatable overlay storage resource",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{
0000000000000000000000000000000000000000;;					NewInsufficientResourceError(v1.ResourceStorageScratch, 18, 5, 20),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:           newResourcePod(schedulercache.Resource{MilliCPU: 1, Memory: 1, StorageOverlay: 10}),
0000000000000000000000000000000000000000;;				emptyDirLimit: 15,
0000000000000000000000000000000000000000;;				storageMedium: v1.StorageMediumDefault,
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 2, Memory: 2, StorageOverlay: 5})),
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "storage scratchrequest exceeds allocatable",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{
0000000000000000000000000000000000000000;;					NewInsufficientResourceError(v1.ResourceStorageScratch, 25, 5, 20),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:           newResourcePod(schedulercache.Resource{}),
0000000000000000000000000000000000000000;;				emptyDirLimit: 25,
0000000000000000000000000000000000000000;;				storageMedium: v1.StorageMediumDefault,
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 2, Memory: 2, StorageOverlay: 5})),
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "storage scratchrequest exceeds allocatable",
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{
0000000000000000000000000000000000000000;;					NewInsufficientResourceError(v1.ResourceStorageScratch, 25, 5, 20),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:           newResourcePod(schedulercache.Resource{MilliCPU: 1, Memory: 1, StorageOverlay: 10}),
0000000000000000000000000000000000000000;;				emptyDirLimit: 15,
0000000000000000000000000000000000000000;;				storageMedium: v1.StorageMediumMemory,
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 2, Memory: 2, StorageOverlay: 5})),
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "pod fit with memory medium",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range storagePodsTests {
0000000000000000000000000000000000000000;;			node := v1.Node{Status: v1.NodeStatus{Capacity: makeResources(10, 20, 0, 32, 5, 20).Capacity, Allocatable: makeAllocatableResources(10, 20, 0, 32, 5, 20)}}
0000000000000000000000000000000000000000;;			test.nodeInfo.SetNode(&node)
0000000000000000000000000000000000000000;;			pod := addStorageLimit(test.pod, test.emptyDirLimit, test.storageMedium)
0000000000000000000000000000000000000000;;			fits, reasons, err := PodFitsResources(pod, PredicateMetadata(pod, nil), test.nodeInfo)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !fits && !reflect.DeepEqual(reasons, test.reasons) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected failure reasons: %v, want: %v", test.test, reasons, test.reasons)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fits != test.fits {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected: %v got %v", test.test, test.fits, fits)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodFitsHost(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod  *v1.Pod
0000000000000000000000000000000000000000;;			node *v1.Node
0000000000000000000000000000000000000000;;			fits bool
0000000000000000000000000000000000000000;;			test string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:  &v1.Pod{},
0000000000000000000000000000000000000000;;				node: &v1.Node{},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "no host specified",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						NodeName: "foo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "foo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "host matches",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						NodeName: "bar",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "foo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "host doesn't match",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedFailureReasons := []algorithm.PredicateFailureReason{ErrPodNotMatchHostName}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			nodeInfo := schedulercache.NewNodeInfo()
0000000000000000000000000000000000000000;;			nodeInfo.SetNode(test.node)
0000000000000000000000000000000000000000;;			fits, reasons, err := PodFitsHost(test.pod, PredicateMetadata(test.pod, nil), nodeInfo)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !fits && !reflect.DeepEqual(reasons, expectedFailureReasons) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected failure reasons: %v, want: %v", test.test, reasons, expectedFailureReasons)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fits != test.fits {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected difference: expected: %v got %v", test.test, test.fits, fits)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPod(host string, hostPorts ...int) *v1.Pod {
0000000000000000000000000000000000000000;;		networkPorts := []v1.ContainerPort{}
0000000000000000000000000000000000000000;;		for _, port := range hostPorts {
0000000000000000000000000000000000000000;;			networkPorts = append(networkPorts, v1.ContainerPort{HostPort: int32(port)})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				NodeName: host,
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Ports: networkPorts,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodFitsHostPorts(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod      *v1.Pod
0000000000000000000000000000000000000000;;			nodeInfo *schedulercache.NodeInfo
0000000000000000000000000000000000000000;;			fits     bool
0000000000000000000000000000000000000000;;			test     string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      &v1.Pod{},
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(),
0000000000000000000000000000000000000000;;				fits:     true,
0000000000000000000000000000000000000000;;				test:     "nothing running",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newPod("m1", 8080),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newPod("m1", 9090)),
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "other port",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newPod("m1", 8080),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newPod("m1", 8080)),
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "same port",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newPod("m1", 8000, 8080),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newPod("m1", 8080)),
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "second port",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newPod("m1", 8000, 8080),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newPod("m1", 8001, 8080)),
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "second port",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedFailureReasons := []algorithm.PredicateFailureReason{ErrPodNotFitsHostPorts}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			fits, reasons, err := PodFitsHostPorts(test.pod, PredicateMetadata(test.pod, nil), test.nodeInfo)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !fits && !reflect.DeepEqual(reasons, expectedFailureReasons) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected failure reasons: %v, want: %v", test.test, reasons, expectedFailureReasons)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.fits != fits {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, saw %v", test.test, test.fits, fits)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetUsedPorts(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pods []*v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ports map[int]bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				[]*v1.Pod{
0000000000000000000000000000000000000000;;					newPod("m1", 9090),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				map[int]bool{9090: true},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				[]*v1.Pod{
0000000000000000000000000000000000000000;;					newPod("m1", 9090),
0000000000000000000000000000000000000000;;					newPod("m1", 9091),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				map[int]bool{9090: true, 9091: true},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				[]*v1.Pod{
0000000000000000000000000000000000000000;;					newPod("m1", 9090),
0000000000000000000000000000000000000000;;					newPod("m2", 9091),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				map[int]bool{9090: true, 9091: true},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			ports := schedutil.GetUsedPorts(test.pods...)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.ports, ports) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", "test get used ports", test.ports, ports)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDiskConflicts(t *testing.T) {
0000000000000000000000000000000000000000;;		volState := v1.PodSpec{
0000000000000000000000000000000000000000;;			Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;							PDName: "foo",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volState2 := v1.PodSpec{
0000000000000000000000000000000000000000;;			Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;							PDName: "bar",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod      *v1.Pod
0000000000000000000000000000000000000000;;			nodeInfo *schedulercache.NodeInfo
0000000000000000000000000000000000000000;;			isOk     bool
0000000000000000000000000000000000000000;;			test     string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{&v1.Pod{}, schedulercache.NewNodeInfo(), true, "nothing"},
0000000000000000000000000000000000000000;;			{&v1.Pod{}, schedulercache.NewNodeInfo(&v1.Pod{Spec: volState}), true, "one state"},
0000000000000000000000000000000000000000;;			{&v1.Pod{Spec: volState}, schedulercache.NewNodeInfo(&v1.Pod{Spec: volState}), false, "same state"},
0000000000000000000000000000000000000000;;			{&v1.Pod{Spec: volState2}, schedulercache.NewNodeInfo(&v1.Pod{Spec: volState}), true, "different state"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedFailureReasons := []algorithm.PredicateFailureReason{ErrDiskConflict}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			ok, reasons, err := NoDiskConflict(test.pod, PredicateMetadata(test.pod, nil), test.nodeInfo)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !ok && !reflect.DeepEqual(reasons, expectedFailureReasons) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected failure reasons: %v, want: %v", test.test, reasons, expectedFailureReasons)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.isOk && !ok {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected ok, got none.  %v %s %s", test.test, test.pod, test.nodeInfo, test.test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.isOk && ok {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected no ok, got one.  %v %s %s", test.test, test.pod, test.nodeInfo, test.test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAWSDiskConflicts(t *testing.T) {
0000000000000000000000000000000000000000;;		volState := v1.PodSpec{
0000000000000000000000000000000000000000;;			Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						AWSElasticBlockStore: &v1.AWSElasticBlockStoreVolumeSource{
0000000000000000000000000000000000000000;;							VolumeID: "foo",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volState2 := v1.PodSpec{
0000000000000000000000000000000000000000;;			Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						AWSElasticBlockStore: &v1.AWSElasticBlockStoreVolumeSource{
0000000000000000000000000000000000000000;;							VolumeID: "bar",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod      *v1.Pod
0000000000000000000000000000000000000000;;			nodeInfo *schedulercache.NodeInfo
0000000000000000000000000000000000000000;;			isOk     bool
0000000000000000000000000000000000000000;;			test     string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{&v1.Pod{}, schedulercache.NewNodeInfo(), true, "nothing"},
0000000000000000000000000000000000000000;;			{&v1.Pod{}, schedulercache.NewNodeInfo(&v1.Pod{Spec: volState}), true, "one state"},
0000000000000000000000000000000000000000;;			{&v1.Pod{Spec: volState}, schedulercache.NewNodeInfo(&v1.Pod{Spec: volState}), false, "same state"},
0000000000000000000000000000000000000000;;			{&v1.Pod{Spec: volState2}, schedulercache.NewNodeInfo(&v1.Pod{Spec: volState}), true, "different state"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedFailureReasons := []algorithm.PredicateFailureReason{ErrDiskConflict}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			ok, reasons, err := NoDiskConflict(test.pod, PredicateMetadata(test.pod, nil), test.nodeInfo)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !ok && !reflect.DeepEqual(reasons, expectedFailureReasons) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected failure reasons: %v, want: %v", test.test, reasons, expectedFailureReasons)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.isOk && !ok {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected ok, got none.  %v %s %s", test.test, test.pod, test.nodeInfo, test.test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.isOk && ok {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected no ok, got one.  %v %s %s", test.test, test.pod, test.nodeInfo, test.test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRBDDiskConflicts(t *testing.T) {
0000000000000000000000000000000000000000;;		volState := v1.PodSpec{
0000000000000000000000000000000000000000;;			Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						RBD: &v1.RBDVolumeSource{
0000000000000000000000000000000000000000;;							CephMonitors: []string{"a", "b"},
0000000000000000000000000000000000000000;;							RBDPool:      "foo",
0000000000000000000000000000000000000000;;							RBDImage:     "bar",
0000000000000000000000000000000000000000;;							FSType:       "ext4",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volState2 := v1.PodSpec{
0000000000000000000000000000000000000000;;			Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						RBD: &v1.RBDVolumeSource{
0000000000000000000000000000000000000000;;							CephMonitors: []string{"c", "d"},
0000000000000000000000000000000000000000;;							RBDPool:      "foo",
0000000000000000000000000000000000000000;;							RBDImage:     "bar",
0000000000000000000000000000000000000000;;							FSType:       "ext4",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod      *v1.Pod
0000000000000000000000000000000000000000;;			nodeInfo *schedulercache.NodeInfo
0000000000000000000000000000000000000000;;			isOk     bool
0000000000000000000000000000000000000000;;			test     string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{&v1.Pod{}, schedulercache.NewNodeInfo(), true, "nothing"},
0000000000000000000000000000000000000000;;			{&v1.Pod{}, schedulercache.NewNodeInfo(&v1.Pod{Spec: volState}), true, "one state"},
0000000000000000000000000000000000000000;;			{&v1.Pod{Spec: volState}, schedulercache.NewNodeInfo(&v1.Pod{Spec: volState}), false, "same state"},
0000000000000000000000000000000000000000;;			{&v1.Pod{Spec: volState2}, schedulercache.NewNodeInfo(&v1.Pod{Spec: volState}), true, "different state"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedFailureReasons := []algorithm.PredicateFailureReason{ErrDiskConflict}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			ok, reasons, err := NoDiskConflict(test.pod, PredicateMetadata(test.pod, nil), test.nodeInfo)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !ok && !reflect.DeepEqual(reasons, expectedFailureReasons) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected failure reasons: %v, want: %v", test.test, reasons, expectedFailureReasons)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.isOk && !ok {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected ok, got none.  %v %s %s", test.test, test.pod, test.nodeInfo, test.test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.isOk && ok {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected no ok, got one.  %v %s %s", test.test, test.pod, test.nodeInfo, test.test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestISCSIDiskConflicts(t *testing.T) {
0000000000000000000000000000000000000000;;		volState := v1.PodSpec{
0000000000000000000000000000000000000000;;			Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						ISCSI: &v1.ISCSIVolumeSource{
0000000000000000000000000000000000000000;;							TargetPortal: "127.0.0.1:3260",
0000000000000000000000000000000000000000;;							IQN:          "iqn.2016-12.server:storage.target01",
0000000000000000000000000000000000000000;;							FSType:       "ext4",
0000000000000000000000000000000000000000;;							Lun:          0,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volState2 := v1.PodSpec{
0000000000000000000000000000000000000000;;			Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						ISCSI: &v1.ISCSIVolumeSource{
0000000000000000000000000000000000000000;;							TargetPortal: "127.0.0.1:3260",
0000000000000000000000000000000000000000;;							IQN:          "iqn.2017-12.server:storage.target01",
0000000000000000000000000000000000000000;;							FSType:       "ext4",
0000000000000000000000000000000000000000;;							Lun:          0,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod      *v1.Pod
0000000000000000000000000000000000000000;;			nodeInfo *schedulercache.NodeInfo
0000000000000000000000000000000000000000;;			isOk     bool
0000000000000000000000000000000000000000;;			test     string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{&v1.Pod{}, schedulercache.NewNodeInfo(), true, "nothing"},
0000000000000000000000000000000000000000;;			{&v1.Pod{}, schedulercache.NewNodeInfo(&v1.Pod{Spec: volState}), true, "one state"},
0000000000000000000000000000000000000000;;			{&v1.Pod{Spec: volState}, schedulercache.NewNodeInfo(&v1.Pod{Spec: volState}), false, "same state"},
0000000000000000000000000000000000000000;;			{&v1.Pod{Spec: volState2}, schedulercache.NewNodeInfo(&v1.Pod{Spec: volState}), true, "different state"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedFailureReasons := []algorithm.PredicateFailureReason{ErrDiskConflict}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			ok, reasons, err := NoDiskConflict(test.pod, PredicateMetadata(test.pod, nil), test.nodeInfo)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !ok && !reflect.DeepEqual(reasons, expectedFailureReasons) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected failure reasons: %v, want: %v", test.test, reasons, expectedFailureReasons)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.isOk && !ok {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected ok, got none.  %v %s %s", test.test, test.pod, test.nodeInfo, test.test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.isOk && ok {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected no ok, got one.  %v %s %s", test.test, test.pod, test.nodeInfo, test.test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodFitsSelector(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod    *v1.Pod
0000000000000000000000000000000000000000;;			labels map[string]string
0000000000000000000000000000000000000000;;			fits   bool
0000000000000000000000000000000000000000;;			test   string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:  &v1.Pod{},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "no selector",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						NodeSelector: map[string]string{
0000000000000000000000000000000000000000;;							"foo": "bar",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "missing labels",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						NodeSelector: map[string]string{
0000000000000000000000000000000000000000;;							"foo": "bar",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"foo": "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "same labels",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						NodeSelector: map[string]string{
0000000000000000000000000000000000000000;;							"foo": "bar",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"foo": "bar",
0000000000000000000000000000000000000000;;					"baz": "blah",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "node labels are superset",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						NodeSelector: map[string]string{
0000000000000000000000000000000000000000;;							"foo": "bar",
0000000000000000000000000000000000000000;;							"baz": "blah",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"foo": "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "node labels are subset",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							NodeAffinity: &v1.NodeAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: &v1.NodeSelector{
0000000000000000000000000000000000000000;;									NodeSelectorTerms: []v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											MatchExpressions: []v1.NodeSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "foo",
0000000000000000000000000000000000000000;;													Operator: v1.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"bar", "value2"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"foo": "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "Pod with matchExpressions using In operator that matches the existing node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							NodeAffinity: &v1.NodeAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: &v1.NodeSelector{
0000000000000000000000000000000000000000;;									NodeSelectorTerms: []v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											MatchExpressions: []v1.NodeSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "kernel-version",
0000000000000000000000000000000000000000;;													Operator: v1.NodeSelectorOpGt,
0000000000000000000000000000000000000000;;													Values:   []string{"0204"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					// We use two digit to denote major version and two digit for minor version.
0000000000000000000000000000000000000000;;					"kernel-version": "0206",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "Pod with matchExpressions using Gt operator that matches the existing node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							NodeAffinity: &v1.NodeAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: &v1.NodeSelector{
0000000000000000000000000000000000000000;;									NodeSelectorTerms: []v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											MatchExpressions: []v1.NodeSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "mem-type",
0000000000000000000000000000000000000000;;													Operator: v1.NodeSelectorOpNotIn,
0000000000000000000000000000000000000000;;													Values:   []string{"DDR", "DDR2"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"mem-type": "DDR3",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "Pod with matchExpressions using NotIn operator that matches the existing node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							NodeAffinity: &v1.NodeAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: &v1.NodeSelector{
0000000000000000000000000000000000000000;;									NodeSelectorTerms: []v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											MatchExpressions: []v1.NodeSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "GPU",
0000000000000000000000000000000000000000;;													Operator: v1.NodeSelectorOpExists,
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"GPU": "NVIDIA-GRID-K1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "Pod with matchExpressions using Exists operator that matches the existing node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							NodeAffinity: &v1.NodeAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: &v1.NodeSelector{
0000000000000000000000000000000000000000;;									NodeSelectorTerms: []v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											MatchExpressions: []v1.NodeSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "foo",
0000000000000000000000000000000000000000;;													Operator: v1.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"value1", "value2"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"foo": "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "Pod with affinity that don't match node's labels won't schedule onto the node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							NodeAffinity: &v1.NodeAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: &v1.NodeSelector{
0000000000000000000000000000000000000000;;									NodeSelectorTerms: nil,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"foo": "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "Pod with a nil []NodeSelectorTerm in affinity, can't match the node's labels and won't schedule onto the node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							NodeAffinity: &v1.NodeAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: &v1.NodeSelector{
0000000000000000000000000000000000000000;;									NodeSelectorTerms: []v1.NodeSelectorTerm{},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"foo": "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "Pod with an empty []NodeSelectorTerm in affinity, can't match the node's labels and won't schedule onto the node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							NodeAffinity: &v1.NodeAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: &v1.NodeSelector{
0000000000000000000000000000000000000000;;									NodeSelectorTerms: []v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											MatchExpressions: []v1.NodeSelectorRequirement{},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"foo": "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "Pod with empty MatchExpressions is not a valid value will match no objects and won't schedule onto the node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"foo": "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "Pod with no Affinity will schedule onto a node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							NodeAffinity: &v1.NodeAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: nil,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"foo": "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "Pod with Affinity but nil NodeSelector will schedule onto a node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							NodeAffinity: &v1.NodeAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: &v1.NodeSelector{
0000000000000000000000000000000000000000;;									NodeSelectorTerms: []v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											MatchExpressions: []v1.NodeSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "GPU",
0000000000000000000000000000000000000000;;													Operator: v1.NodeSelectorOpExists,
0000000000000000000000000000000000000000;;												}, {
0000000000000000000000000000000000000000;;													Key:      "GPU",
0000000000000000000000000000000000000000;;													Operator: v1.NodeSelectorOpNotIn,
0000000000000000000000000000000000000000;;													Values:   []string{"AMD", "INTER"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"GPU": "NVIDIA-GRID-K1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "Pod with multiple matchExpressions ANDed that matches the existing node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							NodeAffinity: &v1.NodeAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: &v1.NodeSelector{
0000000000000000000000000000000000000000;;									NodeSelectorTerms: []v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											MatchExpressions: []v1.NodeSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "GPU",
0000000000000000000000000000000000000000;;													Operator: v1.NodeSelectorOpExists,
0000000000000000000000000000000000000000;;												}, {
0000000000000000000000000000000000000000;;													Key:      "GPU",
0000000000000000000000000000000000000000;;													Operator: v1.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"AMD", "INTER"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"GPU": "NVIDIA-GRID-K1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "Pod with multiple matchExpressions ANDed that doesn't match the existing node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							NodeAffinity: &v1.NodeAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: &v1.NodeSelector{
0000000000000000000000000000000000000000;;									NodeSelectorTerms: []v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											MatchExpressions: []v1.NodeSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "foo",
0000000000000000000000000000000000000000;;													Operator: v1.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"bar", "value2"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											MatchExpressions: []v1.NodeSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "diffkey",
0000000000000000000000000000000000000000;;													Operator: v1.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"wrong", "value2"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"foo": "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "Pod with multiple NodeSelectorTerms ORed in affinity, matches the node's labels and will schedule onto the node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// TODO: Uncomment this test when implement RequiredDuringSchedulingRequiredDuringExecution
0000000000000000000000000000000000000000;;			//		{
0000000000000000000000000000000000000000;;			//			pod: &v1.Pod{
0000000000000000000000000000000000000000;;			//				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;			//					Annotations: map[string]string{
0000000000000000000000000000000000000000;;			//						v1.AffinityAnnotationKey: `
0000000000000000000000000000000000000000;;			//						{"nodeAffinity": {
0000000000000000000000000000000000000000;;			//							"requiredDuringSchedulingRequiredDuringExecution": {
0000000000000000000000000000000000000000;;			//								"nodeSelectorTerms": [{
0000000000000000000000000000000000000000;;			//									"matchExpressions": [{
0000000000000000000000000000000000000000;;			//										"key": "foo",
0000000000000000000000000000000000000000;;			//										"operator": "In",
0000000000000000000000000000000000000000;;			//										"values": ["bar", "value2"]
0000000000000000000000000000000000000000;;			//									}]
0000000000000000000000000000000000000000;;			//								}]
0000000000000000000000000000000000000000;;			//							},
0000000000000000000000000000000000000000;;			//							"requiredDuringSchedulingIgnoredDuringExecution": {
0000000000000000000000000000000000000000;;			//								"nodeSelectorTerms": [{
0000000000000000000000000000000000000000;;			//									"matchExpressions": [{
0000000000000000000000000000000000000000;;			//										"key": "foo",
0000000000000000000000000000000000000000;;			//										"operator": "NotIn",
0000000000000000000000000000000000000000;;			//										"values": ["bar", "value2"]
0000000000000000000000000000000000000000;;			//									}]
0000000000000000000000000000000000000000;;			//								}]
0000000000000000000000000000000000000000;;			//							}
0000000000000000000000000000000000000000;;			//						}}`,
0000000000000000000000000000000000000000;;			//					},
0000000000000000000000000000000000000000;;			//				},
0000000000000000000000000000000000000000;;			//			},
0000000000000000000000000000000000000000;;			//			labels: map[string]string{
0000000000000000000000000000000000000000;;			//				"foo": "bar",
0000000000000000000000000000000000000000;;			//			},
0000000000000000000000000000000000000000;;			//			fits: false,
0000000000000000000000000000000000000000;;			//			test: "Pod with an Affinity both requiredDuringSchedulingRequiredDuringExecution and " +
0000000000000000000000000000000000000000;;			//				"requiredDuringSchedulingIgnoredDuringExecution indicated that don't match node's labels and won't schedule onto the node",
0000000000000000000000000000000000000000;;			//		},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						NodeSelector: map[string]string{
0000000000000000000000000000000000000000;;							"foo": "bar",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							NodeAffinity: &v1.NodeAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: &v1.NodeSelector{
0000000000000000000000000000000000000000;;									NodeSelectorTerms: []v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											MatchExpressions: []v1.NodeSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "foo",
0000000000000000000000000000000000000000;;													Operator: v1.NodeSelectorOpExists,
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"foo": "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "Pod with an Affinity and a PodSpec.NodeSelector(the old thing that we are deprecating) " +
0000000000000000000000000000000000000000;;					"both are satisfied, will schedule onto the node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						NodeSelector: map[string]string{
0000000000000000000000000000000000000000;;							"foo": "bar",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							NodeAffinity: &v1.NodeAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: &v1.NodeSelector{
0000000000000000000000000000000000000000;;									NodeSelectorTerms: []v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											MatchExpressions: []v1.NodeSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "foo",
0000000000000000000000000000000000000000;;													Operator: v1.NodeSelectorOpExists,
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"foo": "barrrrrr",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "Pod with an Affinity matches node's labels but the PodSpec.NodeSelector(the old thing that we are deprecating) " +
0000000000000000000000000000000000000000;;					"is not satisfied, won't schedule onto the node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedFailureReasons := []algorithm.PredicateFailureReason{ErrNodeSelectorNotMatch}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			node := v1.Node{ObjectMeta: metav1.ObjectMeta{Labels: test.labels}}
0000000000000000000000000000000000000000;;			nodeInfo := schedulercache.NewNodeInfo()
0000000000000000000000000000000000000000;;			nodeInfo.SetNode(&node)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fits, reasons, err := PodMatchNodeSelector(test.pod, PredicateMetadata(test.pod, nil), nodeInfo)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !fits && !reflect.DeepEqual(reasons, expectedFailureReasons) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected failure reasons: %v, want: %v", test.test, reasons, expectedFailureReasons)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fits != test.fits {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected: %v got %v", test.test, test.fits, fits)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNodeLabelPresence(t *testing.T) {
0000000000000000000000000000000000000000;;		label := map[string]string{"foo": "bar", "bar": "foo"}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod      *v1.Pod
0000000000000000000000000000000000000000;;			labels   []string
0000000000000000000000000000000000000000;;			presence bool
0000000000000000000000000000000000000000;;			fits     bool
0000000000000000000000000000000000000000;;			test     string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels:   []string{"baz"},
0000000000000000000000000000000000000000;;				presence: true,
0000000000000000000000000000000000000000;;				fits:     false,
0000000000000000000000000000000000000000;;				test:     "label does not match, presence true",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels:   []string{"baz"},
0000000000000000000000000000000000000000;;				presence: false,
0000000000000000000000000000000000000000;;				fits:     true,
0000000000000000000000000000000000000000;;				test:     "label does not match, presence false",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels:   []string{"foo", "baz"},
0000000000000000000000000000000000000000;;				presence: true,
0000000000000000000000000000000000000000;;				fits:     false,
0000000000000000000000000000000000000000;;				test:     "one label matches, presence true",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels:   []string{"foo", "baz"},
0000000000000000000000000000000000000000;;				presence: false,
0000000000000000000000000000000000000000;;				fits:     false,
0000000000000000000000000000000000000000;;				test:     "one label matches, presence false",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels:   []string{"foo", "bar"},
0000000000000000000000000000000000000000;;				presence: true,
0000000000000000000000000000000000000000;;				fits:     true,
0000000000000000000000000000000000000000;;				test:     "all labels match, presence true",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels:   []string{"foo", "bar"},
0000000000000000000000000000000000000000;;				presence: false,
0000000000000000000000000000000000000000;;				fits:     false,
0000000000000000000000000000000000000000;;				test:     "all labels match, presence false",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedFailureReasons := []algorithm.PredicateFailureReason{ErrNodeLabelPresenceViolated}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			node := v1.Node{ObjectMeta: metav1.ObjectMeta{Labels: label}}
0000000000000000000000000000000000000000;;			nodeInfo := schedulercache.NewNodeInfo()
0000000000000000000000000000000000000000;;			nodeInfo.SetNode(&node)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			labelChecker := NodeLabelChecker{test.labels, test.presence}
0000000000000000000000000000000000000000;;			fits, reasons, err := labelChecker.CheckNodeLabelPresence(test.pod, PredicateMetadata(test.pod, nil), nodeInfo)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !fits && !reflect.DeepEqual(reasons, expectedFailureReasons) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected failure reasons: %v, want: %v", test.test, reasons, expectedFailureReasons)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fits != test.fits {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected: %v got %v", test.test, test.fits, fits)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceAffinity(t *testing.T) {
0000000000000000000000000000000000000000;;		selector := map[string]string{"foo": "bar"}
0000000000000000000000000000000000000000;;		labels1 := map[string]string{
0000000000000000000000000000000000000000;;			"region": "r1",
0000000000000000000000000000000000000000;;			"zone":   "z11",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labels2 := map[string]string{
0000000000000000000000000000000000000000;;			"region": "r1",
0000000000000000000000000000000000000000;;			"zone":   "z12",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labels3 := map[string]string{
0000000000000000000000000000000000000000;;			"region": "r2",
0000000000000000000000000000000000000000;;			"zone":   "z21",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labels4 := map[string]string{
0000000000000000000000000000000000000000;;			"region": "r2",
0000000000000000000000000000000000000000;;			"zone":   "z22",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		node1 := v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: labels1}}
0000000000000000000000000000000000000000;;		node2 := v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: labels2}}
0000000000000000000000000000000000000000;;		node3 := v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "machine3", Labels: labels3}}
0000000000000000000000000000000000000000;;		node4 := v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "machine4", Labels: labels4}}
0000000000000000000000000000000000000000;;		node5 := v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "machine5", Labels: labels4}}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod      *v1.Pod
0000000000000000000000000000000000000000;;			pods     []*v1.Pod
0000000000000000000000000000000000000000;;			services []*v1.Service
0000000000000000000000000000000000000000;;			node     *v1.Node
0000000000000000000000000000000000000000;;			labels   []string
0000000000000000000000000000000000000000;;			fits     bool
0000000000000000000000000000000000000000;;			test     string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:    new(v1.Pod),
0000000000000000000000000000000000000000;;				node:   &node1,
0000000000000000000000000000000000000000;;				fits:   true,
0000000000000000000000000000000000000000;;				labels: []string{"region"},
0000000000000000000000000000000000000000;;				test:   "nothing scheduled",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:    &v1.Pod{Spec: v1.PodSpec{NodeSelector: map[string]string{"region": "r1"}}},
0000000000000000000000000000000000000000;;				node:   &node1,
0000000000000000000000000000000000000000;;				fits:   true,
0000000000000000000000000000000000000000;;				labels: []string{"region"},
0000000000000000000000000000000000000000;;				test:   "pod with region label match",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:    &v1.Pod{Spec: v1.PodSpec{NodeSelector: map[string]string{"region": "r2"}}},
0000000000000000000000000000000000000000;;				node:   &node1,
0000000000000000000000000000000000000000;;				fits:   false,
0000000000000000000000000000000000000000;;				labels: []string{"region"},
0000000000000000000000000000000000000000;;				test:   "pod with region label mismatch",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: selector}},
0000000000000000000000000000000000000000;;				pods:     []*v1.Pod{{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: selector}}},
0000000000000000000000000000000000000000;;				node:     &node1,
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: selector}}},
0000000000000000000000000000000000000000;;				fits:     true,
0000000000000000000000000000000000000000;;				labels:   []string{"region"},
0000000000000000000000000000000000000000;;				test:     "service pod on same node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: selector}},
0000000000000000000000000000000000000000;;				pods:     []*v1.Pod{{Spec: v1.PodSpec{NodeName: "machine2"}, ObjectMeta: metav1.ObjectMeta{Labels: selector}}},
0000000000000000000000000000000000000000;;				node:     &node1,
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: selector}}},
0000000000000000000000000000000000000000;;				fits:     true,
0000000000000000000000000000000000000000;;				labels:   []string{"region"},
0000000000000000000000000000000000000000;;				test:     "service pod on different node, region match",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: selector}},
0000000000000000000000000000000000000000;;				pods:     []*v1.Pod{{Spec: v1.PodSpec{NodeName: "machine3"}, ObjectMeta: metav1.ObjectMeta{Labels: selector}}},
0000000000000000000000000000000000000000;;				node:     &node1,
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: selector}}},
0000000000000000000000000000000000000000;;				fits:     false,
0000000000000000000000000000000000000000;;				labels:   []string{"region"},
0000000000000000000000000000000000000000;;				test:     "service pod on different node, region mismatch",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: selector, Namespace: "ns1"}},
0000000000000000000000000000000000000000;;				pods:     []*v1.Pod{{Spec: v1.PodSpec{NodeName: "machine3"}, ObjectMeta: metav1.ObjectMeta{Labels: selector, Namespace: "ns1"}}},
0000000000000000000000000000000000000000;;				node:     &node1,
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: selector}, ObjectMeta: metav1.ObjectMeta{Namespace: "ns2"}}},
0000000000000000000000000000000000000000;;				fits:     true,
0000000000000000000000000000000000000000;;				labels:   []string{"region"},
0000000000000000000000000000000000000000;;				test:     "service in different namespace, region mismatch",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: selector, Namespace: "ns1"}},
0000000000000000000000000000000000000000;;				pods:     []*v1.Pod{{Spec: v1.PodSpec{NodeName: "machine3"}, ObjectMeta: metav1.ObjectMeta{Labels: selector, Namespace: "ns2"}}},
0000000000000000000000000000000000000000;;				node:     &node1,
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: selector}, ObjectMeta: metav1.ObjectMeta{Namespace: "ns1"}}},
0000000000000000000000000000000000000000;;				fits:     true,
0000000000000000000000000000000000000000;;				labels:   []string{"region"},
0000000000000000000000000000000000000000;;				test:     "pod in different namespace, region mismatch",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: selector, Namespace: "ns1"}},
0000000000000000000000000000000000000000;;				pods:     []*v1.Pod{{Spec: v1.PodSpec{NodeName: "machine3"}, ObjectMeta: metav1.ObjectMeta{Labels: selector, Namespace: "ns1"}}},
0000000000000000000000000000000000000000;;				node:     &node1,
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: selector}, ObjectMeta: metav1.ObjectMeta{Namespace: "ns1"}}},
0000000000000000000000000000000000000000;;				fits:     false,
0000000000000000000000000000000000000000;;				labels:   []string{"region"},
0000000000000000000000000000000000000000;;				test:     "service and pod in same namespace, region mismatch",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: selector}},
0000000000000000000000000000000000000000;;				pods:     []*v1.Pod{{Spec: v1.PodSpec{NodeName: "machine2"}, ObjectMeta: metav1.ObjectMeta{Labels: selector}}},
0000000000000000000000000000000000000000;;				node:     &node1,
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: selector}}},
0000000000000000000000000000000000000000;;				fits:     false,
0000000000000000000000000000000000000000;;				labels:   []string{"region", "zone"},
0000000000000000000000000000000000000000;;				test:     "service pod on different node, multiple labels, not all match",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      &v1.Pod{ObjectMeta: metav1.ObjectMeta{Labels: selector}},
0000000000000000000000000000000000000000;;				pods:     []*v1.Pod{{Spec: v1.PodSpec{NodeName: "machine5"}, ObjectMeta: metav1.ObjectMeta{Labels: selector}}},
0000000000000000000000000000000000000000;;				node:     &node4,
0000000000000000000000000000000000000000;;				services: []*v1.Service{{Spec: v1.ServiceSpec{Selector: selector}}},
0000000000000000000000000000000000000000;;				fits:     true,
0000000000000000000000000000000000000000;;				labels:   []string{"region", "zone"},
0000000000000000000000000000000000000000;;				test:     "service pod on different node, multiple labels, all match",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedFailureReasons := []algorithm.PredicateFailureReason{ErrServiceAffinityViolated}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			testIt := func(skipPrecompute bool) {
0000000000000000000000000000000000000000;;				nodes := []v1.Node{node1, node2, node3, node4, node5}
0000000000000000000000000000000000000000;;				nodeInfo := schedulercache.NewNodeInfo()
0000000000000000000000000000000000000000;;				nodeInfo.SetNode(test.node)
0000000000000000000000000000000000000000;;				nodeInfoMap := map[string]*schedulercache.NodeInfo{test.node.Name: nodeInfo}
0000000000000000000000000000000000000000;;				// Reimplementing the logic that the scheduler implements: Any time it makes a predicate, it registers any precomputations.
0000000000000000000000000000000000000000;;				predicate, precompute := NewServiceAffinityPredicate(schedulertesting.FakePodLister(test.pods), schedulertesting.FakeServiceLister(test.services), FakeNodeListInfo(nodes), test.labels)
0000000000000000000000000000000000000000;;				// Register a precomputation or Rewrite the precomputation to a no-op, depending on the state we want to test.
0000000000000000000000000000000000000000;;				RegisterPredicatePrecomputation("checkServiceAffinity-unitTestPredicate", func(pm *predicateMetadata) {
0000000000000000000000000000000000000000;;					if !skipPrecompute {
0000000000000000000000000000000000000000;;						precompute(pm)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				if pmeta, ok := (PredicateMetadata(test.pod, nodeInfoMap)).(*predicateMetadata); ok {
0000000000000000000000000000000000000000;;					fits, reasons, err := predicate(test.pod, pmeta, nodeInfo)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("%s: unexpected error: %v", test.test, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !fits && !reflect.DeepEqual(reasons, expectedFailureReasons) {
0000000000000000000000000000000000000000;;						t.Errorf("%s: unexpected failure reasons: %v, want: %v", test.test, reasons, expectedFailureReasons)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if fits != test.fits {
0000000000000000000000000000000000000000;;						t.Errorf("%s: expected: %v got %v", test.test, test.fits, fits)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					t.Errorf("Error casting.")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			testIt(false) // Confirm that the predicate works without precomputed data (resilience)
0000000000000000000000000000000000000000;;			testIt(true)  // Confirm that the predicate works with the precomputed data (better performance)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEBSVolumeCountConflicts(t *testing.T) {
0000000000000000000000000000000000000000;;		oneVolPod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							AWSElasticBlockStore: &v1.AWSElasticBlockStoreVolumeSource{VolumeID: "ovp"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ebsPVCPod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							PersistentVolumeClaim: &v1.PersistentVolumeClaimVolumeSource{
0000000000000000000000000000000000000000;;								ClaimName: "someEBSVol",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		splitPVCPod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							PersistentVolumeClaim: &v1.PersistentVolumeClaimVolumeSource{
0000000000000000000000000000000000000000;;								ClaimName: "someNonEBSVol",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							PersistentVolumeClaim: &v1.PersistentVolumeClaimVolumeSource{
0000000000000000000000000000000000000000;;								ClaimName: "someEBSVol",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		twoVolPod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							AWSElasticBlockStore: &v1.AWSElasticBlockStoreVolumeSource{VolumeID: "tvp1"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							AWSElasticBlockStore: &v1.AWSElasticBlockStoreVolumeSource{VolumeID: "tvp2"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		splitVolsPod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							HostPath: &v1.HostPathVolumeSource{},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							AWSElasticBlockStore: &v1.AWSElasticBlockStoreVolumeSource{VolumeID: "svp"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nonApplicablePod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							HostPath: &v1.HostPathVolumeSource{},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deletedPVCPod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							PersistentVolumeClaim: &v1.PersistentVolumeClaimVolumeSource{
0000000000000000000000000000000000000000;;								ClaimName: "deletedPVC",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deletedPVPod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							PersistentVolumeClaim: &v1.PersistentVolumeClaimVolumeSource{
0000000000000000000000000000000000000000;;								ClaimName: "pvcWithDeletedPV",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		emptyPod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			newPod       *v1.Pod
0000000000000000000000000000000000000000;;			existingPods []*v1.Pod
0000000000000000000000000000000000000000;;			maxVols      int
0000000000000000000000000000000000000000;;			fits         bool
0000000000000000000000000000000000000000;;			test         string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				newPod:       oneVolPod,
0000000000000000000000000000000000000000;;				existingPods: []*v1.Pod{twoVolPod, oneVolPod},
0000000000000000000000000000000000000000;;				maxVols:      4,
0000000000000000000000000000000000000000;;				fits:         true,
0000000000000000000000000000000000000000;;				test:         "fits when node capacity >= new pod's EBS volumes",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				newPod:       twoVolPod,
0000000000000000000000000000000000000000;;				existingPods: []*v1.Pod{oneVolPod},
0000000000000000000000000000000000000000;;				maxVols:      2,
0000000000000000000000000000000000000000;;				fits:         false,
0000000000000000000000000000000000000000;;				test:         "doesn't fit when node capacity < new pod's EBS volumes",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				newPod:       splitVolsPod,
0000000000000000000000000000000000000000;;				existingPods: []*v1.Pod{twoVolPod},
0000000000000000000000000000000000000000;;				maxVols:      3,
0000000000000000000000000000000000000000;;				fits:         true,
0000000000000000000000000000000000000000;;				test:         "new pod's count ignores non-EBS volumes",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				newPod:       twoVolPod,
0000000000000000000000000000000000000000;;				existingPods: []*v1.Pod{splitVolsPod, nonApplicablePod, emptyPod},
0000000000000000000000000000000000000000;;				maxVols:      3,
0000000000000000000000000000000000000000;;				fits:         true,
0000000000000000000000000000000000000000;;				test:         "existing pods' counts ignore non-EBS volumes",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				newPod:       ebsPVCPod,
0000000000000000000000000000000000000000;;				existingPods: []*v1.Pod{splitVolsPod, nonApplicablePod, emptyPod},
0000000000000000000000000000000000000000;;				maxVols:      3,
0000000000000000000000000000000000000000;;				fits:         true,
0000000000000000000000000000000000000000;;				test:         "new pod's count considers PVCs backed by EBS volumes",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				newPod:       splitPVCPod,
0000000000000000000000000000000000000000;;				existingPods: []*v1.Pod{splitVolsPod, oneVolPod},
0000000000000000000000000000000000000000;;				maxVols:      3,
0000000000000000000000000000000000000000;;				fits:         true,
0000000000000000000000000000000000000000;;				test:         "new pod's count ignores PVCs not backed by EBS volumes",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				newPod:       twoVolPod,
0000000000000000000000000000000000000000;;				existingPods: []*v1.Pod{oneVolPod, ebsPVCPod},
0000000000000000000000000000000000000000;;				maxVols:      3,
0000000000000000000000000000000000000000;;				fits:         false,
0000000000000000000000000000000000000000;;				test:         "existing pods' counts considers PVCs backed by EBS volumes",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				newPod:       twoVolPod,
0000000000000000000000000000000000000000;;				existingPods: []*v1.Pod{oneVolPod, twoVolPod, ebsPVCPod},
0000000000000000000000000000000000000000;;				maxVols:      4,
0000000000000000000000000000000000000000;;				fits:         true,
0000000000000000000000000000000000000000;;				test:         "already-mounted EBS volumes are always ok to allow",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				newPod:       splitVolsPod,
0000000000000000000000000000000000000000;;				existingPods: []*v1.Pod{oneVolPod, oneVolPod, ebsPVCPod},
0000000000000000000000000000000000000000;;				maxVols:      3,
0000000000000000000000000000000000000000;;				fits:         true,
0000000000000000000000000000000000000000;;				test:         "the same EBS volumes are not counted multiple times",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				newPod:       ebsPVCPod,
0000000000000000000000000000000000000000;;				existingPods: []*v1.Pod{oneVolPod, deletedPVCPod},
0000000000000000000000000000000000000000;;				maxVols:      2,
0000000000000000000000000000000000000000;;				fits:         false,
0000000000000000000000000000000000000000;;				test:         "pod with missing PVC is counted towards the PV limit",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				newPod:       ebsPVCPod,
0000000000000000000000000000000000000000;;				existingPods: []*v1.Pod{oneVolPod, deletedPVCPod},
0000000000000000000000000000000000000000;;				maxVols:      3,
0000000000000000000000000000000000000000;;				fits:         true,
0000000000000000000000000000000000000000;;				test:         "pod with missing PVC is counted towards the PV limit",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				newPod:       ebsPVCPod,
0000000000000000000000000000000000000000;;				existingPods: []*v1.Pod{oneVolPod, deletedPVPod},
0000000000000000000000000000000000000000;;				maxVols:      2,
0000000000000000000000000000000000000000;;				fits:         false,
0000000000000000000000000000000000000000;;				test:         "pod with missing PV is counted towards the PV limit",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				newPod:       ebsPVCPod,
0000000000000000000000000000000000000000;;				existingPods: []*v1.Pod{oneVolPod, deletedPVPod},
0000000000000000000000000000000000000000;;				maxVols:      3,
0000000000000000000000000000000000000000;;				fits:         true,
0000000000000000000000000000000000000000;;				test:         "pod with missing PV is counted towards the PV limit",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pvInfo := FakePersistentVolumeInfo{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "someEBSVol"},
0000000000000000000000000000000000000000;;				Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						AWSElasticBlockStore: &v1.AWSElasticBlockStoreVolumeSource{VolumeID: "ebsVol"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "someNonEBSVol"},
0000000000000000000000000000000000000000;;				Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pvcInfo := FakePersistentVolumeClaimInfo{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "someEBSVol"},
0000000000000000000000000000000000000000;;				Spec:       v1.PersistentVolumeClaimSpec{VolumeName: "someEBSVol"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "someNonEBSVol"},
0000000000000000000000000000000000000000;;				Spec:       v1.PersistentVolumeClaimSpec{VolumeName: "someNonEBSVol"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "pvcWithDeletedPV"},
0000000000000000000000000000000000000000;;				Spec:       v1.PersistentVolumeClaimSpec{VolumeName: "pvcWithDeletedPV"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		filter := VolumeFilter{
0000000000000000000000000000000000000000;;			FilterVolume: func(vol *v1.Volume) (string, bool) {
0000000000000000000000000000000000000000;;				if vol.AWSElasticBlockStore != nil {
0000000000000000000000000000000000000000;;					return vol.AWSElasticBlockStore.VolumeID, true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return "", false
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			FilterPersistentVolume: func(pv *v1.PersistentVolume) (string, bool) {
0000000000000000000000000000000000000000;;				if pv.Spec.AWSElasticBlockStore != nil {
0000000000000000000000000000000000000000;;					return pv.Spec.AWSElasticBlockStore.VolumeID, true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return "", false
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedFailureReasons := []algorithm.PredicateFailureReason{ErrMaxVolumeCountExceeded}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			pred := NewMaxPDVolumeCountPredicate(filter, test.maxVols, pvInfo, pvcInfo)
0000000000000000000000000000000000000000;;			fits, reasons, err := pred(test.newPod, PredicateMetadata(test.newPod, nil), schedulercache.NewNodeInfo(test.existingPods...))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !fits && !reflect.DeepEqual(reasons, expectedFailureReasons) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected failure reasons: %v, want: %v", test.test, reasons, expectedFailureReasons)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fits != test.fits {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", test.test, test.fits, fits)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPodWithPort(hostPorts ...int) *v1.Pod {
0000000000000000000000000000000000000000;;		networkPorts := []v1.ContainerPort{}
0000000000000000000000000000000000000000;;		for _, port := range hostPorts {
0000000000000000000000000000000000000000;;			networkPorts = append(networkPorts, v1.ContainerPort{HostPort: int32(port)})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Ports: networkPorts,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRunGeneralPredicates(t *testing.T) {
0000000000000000000000000000000000000000;;		resourceTests := []struct {
0000000000000000000000000000000000000000;;			pod      *v1.Pod
0000000000000000000000000000000000000000;;			nodeInfo *schedulercache.NodeInfo
0000000000000000000000000000000000000000;;			node     *v1.Node
0000000000000000000000000000000000000000;;			fits     bool
0000000000000000000000000000000000000000;;			test     string
0000000000000000000000000000000000000000;;			wErr     error
0000000000000000000000000000000000000000;;			reasons  []algorithm.PredicateFailureReason
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{},
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 9, Memory: 19})),
0000000000000000000000000000000000000000;;				node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "machine1"},
0000000000000000000000000000000000000000;;					Status:     v1.NodeStatus{Capacity: makeResources(10, 20, 0, 32, 0, 0).Capacity, Allocatable: makeAllocatableResources(10, 20, 0, 32, 0, 0)},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				wErr: nil,
0000000000000000000000000000000000000000;;				test: "no resources/port/host requested always fits",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourcePod(schedulercache.Resource{MilliCPU: 8, Memory: 10}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 5, Memory: 19})),
0000000000000000000000000000000000000000;;				node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "machine1"},
0000000000000000000000000000000000000000;;					Status:     v1.NodeStatus{Capacity: makeResources(10, 20, 0, 32, 0, 0).Capacity, Allocatable: makeAllocatableResources(10, 20, 0, 32, 0, 0)},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				wErr: nil,
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{
0000000000000000000000000000000000000000;;					NewInsufficientResourceError(v1.ResourceCPU, 8, 5, 10),
0000000000000000000000000000000000000000;;					NewInsufficientResourceError(v1.ResourceMemory, 10, 19, 20),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				test: "not enough cpu and memory resource",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{},
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 9, Memory: 19})),
0000000000000000000000000000000000000000;;				node: &v1.Node{Status: v1.NodeStatus{Capacity: makeResources(10, 20, 1, 32, 0, 0).Capacity, Allocatable: makeAllocatableResources(10, 20, 1, 32, 0, 0)}},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				wErr: nil,
0000000000000000000000000000000000000000;;				test: "no resources/port/host requested always fits on GPU machine",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourcePod(schedulercache.Resource{MilliCPU: 3, Memory: 1, NvidiaGPU: 1}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 5, Memory: 10, NvidiaGPU: 1})),
0000000000000000000000000000000000000000;;				node:    &v1.Node{Status: v1.NodeStatus{Capacity: makeResources(10, 20, 1, 32, 0, 0).Capacity, Allocatable: makeAllocatableResources(10, 20, 1, 32, 0, 0)}},
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				wErr:    nil,
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{NewInsufficientResourceError(v1.ResourceNvidiaGPU, 1, 1, 1)},
0000000000000000000000000000000000000000;;				test:    "not enough GPU resource",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: newResourcePod(schedulercache.Resource{MilliCPU: 3, Memory: 1, NvidiaGPU: 1}),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(
0000000000000000000000000000000000000000;;					newResourcePod(schedulercache.Resource{MilliCPU: 5, Memory: 10, NvidiaGPU: 0})),
0000000000000000000000000000000000000000;;				node: &v1.Node{Status: v1.NodeStatus{Capacity: makeResources(10, 20, 1, 32, 0, 0).Capacity, Allocatable: makeAllocatableResources(10, 20, 1, 32, 0, 0)}},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				wErr: nil,
0000000000000000000000000000000000000000;;				test: "enough GPU resource",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						NodeName: "machine2",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(),
0000000000000000000000000000000000000000;;				node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "machine1"},
0000000000000000000000000000000000000000;;					Status:     v1.NodeStatus{Capacity: makeResources(10, 20, 0, 32, 0, 0).Capacity, Allocatable: makeAllocatableResources(10, 20, 0, 32, 0, 0)},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				wErr:    nil,
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{ErrPodNotMatchHostName},
0000000000000000000000000000000000000000;;				test:    "host not match",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      newPodWithPort(123),
0000000000000000000000000000000000000000;;				nodeInfo: schedulercache.NewNodeInfo(newPodWithPort(123)),
0000000000000000000000000000000000000000;;				node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "machine1"},
0000000000000000000000000000000000000000;;					Status:     v1.NodeStatus{Capacity: makeResources(10, 20, 0, 32, 0, 0).Capacity, Allocatable: makeAllocatableResources(10, 20, 0, 32, 0, 0)},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits:    false,
0000000000000000000000000000000000000000;;				wErr:    nil,
0000000000000000000000000000000000000000;;				reasons: []algorithm.PredicateFailureReason{ErrPodNotFitsHostPorts},
0000000000000000000000000000000000000000;;				test:    "hostport conflict",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range resourceTests {
0000000000000000000000000000000000000000;;			test.nodeInfo.SetNode(test.node)
0000000000000000000000000000000000000000;;			fits, reasons, err := GeneralPredicates(test.pod, PredicateMetadata(test.pod, nil), test.nodeInfo)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !fits && !reflect.DeepEqual(reasons, test.reasons) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected failure reasons: %v, want: %v", test.test, reasons, test.reasons)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fits != test.fits {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected: %v got %v", test.test, test.fits, fits)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInterPodAffinity(t *testing.T) {
0000000000000000000000000000000000000000;;		podLabel := map[string]string{"service": "securityscan"}
0000000000000000000000000000000000000000;;		labels1 := map[string]string{
0000000000000000000000000000000000000000;;			"region": "r1",
0000000000000000000000000000000000000000;;			"zone":   "z11",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podLabel2 := map[string]string{"security": "S1"}
0000000000000000000000000000000000000000;;		node1 := v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: labels1}}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod  *v1.Pod
0000000000000000000000000000000000000000;;			pods []*v1.Pod
0000000000000000000000000000000000000000;;			node *v1.Node
0000000000000000000000000000000000000000;;			fits bool
0000000000000000000000000000000000000000;;			test string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:  new(v1.Pod),
0000000000000000000000000000000000000000;;				node: &node1,
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "A pod that has no required pod affinity scheduling rules can schedule onto a node with no existing pods",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: podLabel2,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							PodAffinity: &v1.PodAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "service",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"securityscan", "value2"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "region",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabel}}},
0000000000000000000000000000000000000000;;				node: &node1,
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "satisfies with requiredDuringSchedulingIgnoredDuringExecution in PodAffinity using In operator that matches the existing pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: podLabel2,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							PodAffinity: &v1.PodAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "service",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpNotIn,
0000000000000000000000000000000000000000;;													Values:   []string{"securityscan3", "value3"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "region",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabel}}},
0000000000000000000000000000000000000000;;				node: &node1,
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "satisfies the pod with requiredDuringSchedulingIgnoredDuringExecution in PodAffinity using not in operator in labelSelector that matches the existing pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: podLabel2,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							PodAffinity: &v1.PodAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "service",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"securityscan", "value2"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										Namespaces: []string{"DiffNameSpace"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabel, Namespace: "ns"}}},
0000000000000000000000000000000000000000;;				node: &node1,
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "Does not satisfy the PodAffinity with labelSelector because of diff Namespace",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: podLabel,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							PodAffinity: &v1.PodAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "service",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"antivirusscan", "value2"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabel}}},
0000000000000000000000000000000000000000;;				node: &node1,
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "Doesn't satisfy the PodAffinity because of unmatching labelSelector with the existing pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: podLabel2,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							PodAffinity: &v1.PodAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "service",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpExists,
0000000000000000000000000000000000000000;;												}, {
0000000000000000000000000000000000000000;;													Key:      "wrongkey",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpDoesNotExist,
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "region",
0000000000000000000000000000000000000000;;									}, {
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "service",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"securityscan"},
0000000000000000000000000000000000000000;;												}, {
0000000000000000000000000000000000000000;;													Key:      "service",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpNotIn,
0000000000000000000000000000000000000000;;													Values:   []string{"WrongValue"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "region",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabel}}},
0000000000000000000000000000000000000000;;				node: &node1,
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "satisfies the PodAffinity with different label Operators in multiple RequiredDuringSchedulingIgnoredDuringExecution ",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: podLabel2,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							PodAffinity: &v1.PodAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "service",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpExists,
0000000000000000000000000000000000000000;;												}, {
0000000000000000000000000000000000000000;;													Key:      "wrongkey",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpDoesNotExist,
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "region",
0000000000000000000000000000000000000000;;									}, {
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "service",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"securityscan2"},
0000000000000000000000000000000000000000;;												}, {
0000000000000000000000000000000000000000;;													Key:      "service",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpNotIn,
0000000000000000000000000000000000000000;;													Values:   []string{"WrongValue"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "region",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabel}}},
0000000000000000000000000000000000000000;;				node: &node1,
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "The labelSelector requirements(items of matchExpressions) are ANDed, the pod cannot schedule onto the node because one of the matchExpression item don't match.",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: podLabel2,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							PodAffinity: &v1.PodAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "service",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"securityscan", "value2"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "region",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							PodAntiAffinity: &v1.PodAntiAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "service",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"antivirusscan", "value2"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "node",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabel}}},
0000000000000000000000000000000000000000;;				node: &node1,
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "satisfies the PodAffinity and PodAntiAffinity with the existing pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// TODO: Uncomment this block when implement RequiredDuringSchedulingRequiredDuringExecution.
0000000000000000000000000000000000000000;;			//{
0000000000000000000000000000000000000000;;			//	 pod: &v1.Pod{
0000000000000000000000000000000000000000;;			//		ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;			//			Labels: podLabel2,
0000000000000000000000000000000000000000;;			//			Annotations: map[string]string{
0000000000000000000000000000000000000000;;			//				v1.AffinityAnnotationKey: `
0000000000000000000000000000000000000000;;			//				{"podAffinity": {
0000000000000000000000000000000000000000;;			//					"requiredDuringSchedulingRequiredDuringExecution": [
0000000000000000000000000000000000000000;;			//						{
0000000000000000000000000000000000000000;;			//							"labelSelector": {
0000000000000000000000000000000000000000;;			//								"matchExpressions": [{
0000000000000000000000000000000000000000;;			//									"key": "service",
0000000000000000000000000000000000000000;;			//									"operator": "Exists"
0000000000000000000000000000000000000000;;			//								}, {
0000000000000000000000000000000000000000;;			//									"key": "wrongkey",
0000000000000000000000000000000000000000;;			//									"operator": "DoesNotExist"
0000000000000000000000000000000000000000;;			//								}]
0000000000000000000000000000000000000000;;			//							},
0000000000000000000000000000000000000000;;			//							"topologyKey": "region"
0000000000000000000000000000000000000000;;			//						}, {
0000000000000000000000000000000000000000;;			//							"labelSelector": {
0000000000000000000000000000000000000000;;			//								"matchExpressions": [{
0000000000000000000000000000000000000000;;			//									"key": "service",
0000000000000000000000000000000000000000;;			//									"operator": "In",
0000000000000000000000000000000000000000;;			//									"values": ["securityscan"]
0000000000000000000000000000000000000000;;			//								}, {
0000000000000000000000000000000000000000;;			//									"key": "service",
0000000000000000000000000000000000000000;;			//									"operator": "NotIn",
0000000000000000000000000000000000000000;;			//									"values": ["WrongValue"]
0000000000000000000000000000000000000000;;			//								}]
0000000000000000000000000000000000000000;;			//							},
0000000000000000000000000000000000000000;;			//							"topologyKey": "region"
0000000000000000000000000000000000000000;;			//						}
0000000000000000000000000000000000000000;;			//					]
0000000000000000000000000000000000000000;;			//				}}`,
0000000000000000000000000000000000000000;;			//			},
0000000000000000000000000000000000000000;;			//		},
0000000000000000000000000000000000000000;;			//	},
0000000000000000000000000000000000000000;;			//	pods: []*v1.Pod{{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podlabel}}},
0000000000000000000000000000000000000000;;			//	node: &node1,
0000000000000000000000000000000000000000;;			//	fits: true,
0000000000000000000000000000000000000000;;			//	test: "satisfies the PodAffinity with different Label Operators in multiple RequiredDuringSchedulingRequiredDuringExecution ",
0000000000000000000000000000000000000000;;			//},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: podLabel2,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							PodAffinity: &v1.PodAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "service",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"securityscan", "value2"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "region",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							PodAntiAffinity: &v1.PodAntiAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "service",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"antivirusscan", "value2"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "node",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;							NodeName: "machine1",
0000000000000000000000000000000000000000;;							Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;								PodAntiAffinity: &v1.PodAntiAffinity{
0000000000000000000000000000000000000000;;									RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;												MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;													{
0000000000000000000000000000000000000000;;														Key:      "service",
0000000000000000000000000000000000000000;;														Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;														Values:   []string{"antivirusscan", "value2"},
0000000000000000000000000000000000000000;;													},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;											TopologyKey: "node",
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{Labels: podLabel},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				node: &node1,
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "satisfies the PodAffinity and PodAntiAffinity and PodAntiAffinity symmetry with the existing pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: podLabel2,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							PodAffinity: &v1.PodAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "service",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"securityscan", "value2"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "region",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							PodAntiAffinity: &v1.PodAntiAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "service",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"securityscan", "value2"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "zone",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabel}}},
0000000000000000000000000000000000000000;;				node: &node1,
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "satisfies the PodAffinity but doesn't satisfies the PodAntiAffinity with the existing pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: podLabel,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							PodAffinity: &v1.PodAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "service",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"securityscan", "value2"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "region",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							PodAntiAffinity: &v1.PodAntiAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "service",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"antivirusscan", "value2"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "node",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;							NodeName: "machine1",
0000000000000000000000000000000000000000;;							Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;								PodAntiAffinity: &v1.PodAntiAffinity{
0000000000000000000000000000000000000000;;									RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;												MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;													{
0000000000000000000000000000000000000000;;														Key:      "service",
0000000000000000000000000000000000000000;;														Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;														Values:   []string{"securityscan", "value2"},
0000000000000000000000000000000000000000;;													},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;											TopologyKey: "zone",
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{Labels: podLabel},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				node: &node1,
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "satisfies the PodAffinity and PodAntiAffinity but doesn't satisfies PodAntiAffinity symmetry with the existing pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: podLabel,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							PodAffinity: &v1.PodAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "service",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpNotIn,
0000000000000000000000000000000000000000;;													Values:   []string{"securityscan", "value2"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "region",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{{Spec: v1.PodSpec{NodeName: "machine2"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabel}}},
0000000000000000000000000000000000000000;;				node: &node1,
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "pod matches its own Label in PodAffinity and that matches the existing pod Labels",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: podLabel,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Spec: v1.PodSpec{NodeName: "machine1",
0000000000000000000000000000000000000000;;							Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;								PodAntiAffinity: &v1.PodAntiAffinity{
0000000000000000000000000000000000000000;;									RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;												MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;													{
0000000000000000000000000000000000000000;;														Key:      "service",
0000000000000000000000000000000000000000;;														Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;														Values:   []string{"securityscan", "value2"},
0000000000000000000000000000000000000000;;													},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;											TopologyKey: "zone",
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{Labels: podLabel},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				node: &node1,
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "verify that PodAntiAffinity from existing pod is respected when pod has no AntiAffinity constraints. doesn't satisfy PodAntiAffinity symmetry with the existing pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: podLabel,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Spec: v1.PodSpec{NodeName: "machine1",
0000000000000000000000000000000000000000;;							Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;								PodAntiAffinity: &v1.PodAntiAffinity{
0000000000000000000000000000000000000000;;									RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;												MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;													{
0000000000000000000000000000000000000000;;														Key:      "service",
0000000000000000000000000000000000000000;;														Operator: metav1.LabelSelectorOpNotIn,
0000000000000000000000000000000000000000;;														Values:   []string{"securityscan", "value2"},
0000000000000000000000000000000000000000;;													},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;											TopologyKey: "zone",
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{Labels: podLabel},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				node: &node1,
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "verify that PodAntiAffinity from existing pod is respected when pod has no AntiAffinity constraints. satisfy PodAntiAffinity symmetry with the existing pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedFailureReasons := []algorithm.PredicateFailureReason{ErrPodAffinityNotMatch}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			node := test.node
0000000000000000000000000000000000000000;;			var podsOnNode []*v1.Pod
0000000000000000000000000000000000000000;;			for _, pod := range test.pods {
0000000000000000000000000000000000000000;;				if pod.Spec.NodeName == node.Name {
0000000000000000000000000000000000000000;;					podsOnNode = append(podsOnNode, pod)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fit := PodAffinityChecker{
0000000000000000000000000000000000000000;;				info:      FakeNodeInfo(*node),
0000000000000000000000000000000000000000;;				podLister: schedulertesting.FakePodLister(test.pods),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nodeInfo := schedulercache.NewNodeInfo(podsOnNode...)
0000000000000000000000000000000000000000;;			nodeInfo.SetNode(test.node)
0000000000000000000000000000000000000000;;			nodeInfoMap := map[string]*schedulercache.NodeInfo{test.node.Name: nodeInfo}
0000000000000000000000000000000000000000;;			fits, reasons, err := fit.InterPodAffinityMatches(test.pod, PredicateMetadata(test.pod, nodeInfoMap), nodeInfo)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error %v", test.test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !fits && !reflect.DeepEqual(reasons, expectedFailureReasons) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected failure reasons: %v, want: %v", test.test, reasons, expectedFailureReasons)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fits != test.fits {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v got %v", test.test, test.fits, fits)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInterPodAffinityWithMultipleNodes(t *testing.T) {
0000000000000000000000000000000000000000;;		podLabelA := map[string]string{
0000000000000000000000000000000000000000;;			"foo": "bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labelRgChina := map[string]string{
0000000000000000000000000000000000000000;;			"region": "China",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labelRgChinaAzAz1 := map[string]string{
0000000000000000000000000000000000000000;;			"region": "China",
0000000000000000000000000000000000000000;;			"az":     "az1",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labelRgIndia := map[string]string{
0000000000000000000000000000000000000000;;			"region": "India",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labelRgUS := map[string]string{
0000000000000000000000000000000000000000;;			"region": "US",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod    *v1.Pod
0000000000000000000000000000000000000000;;			pods   []*v1.Pod
0000000000000000000000000000000000000000;;			nodes  []v1.Node
0000000000000000000000000000000000000000;;			fits   map[string]bool
0000000000000000000000000000000000000000;;			test   string
0000000000000000000000000000000000000000;;			nometa bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							PodAffinity: &v1.PodAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "foo",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"bar"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "region",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "machine1"}, ObjectMeta: metav1.ObjectMeta{Labels: podLabelA}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine1", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine2", Labels: labelRgChinaAzAz1}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "machine3", Labels: labelRgIndia}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: map[string]bool{
0000000000000000000000000000000000000000;;					"machine1": true,
0000000000000000000000000000000000000000;;					"machine2": true,
0000000000000000000000000000000000000000;;					"machine3": false,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				test: "A pod can be scheduled onto all the nodes that have the same topology key & label value with one of them has an existing pod that match the affinity rules",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							NodeAffinity: &v1.NodeAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: &v1.NodeSelector{
0000000000000000000000000000000000000000;;									NodeSelectorTerms: []v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											MatchExpressions: []v1.NodeSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "hostname",
0000000000000000000000000000000000000000;;													Operator: v1.NodeSelectorOpNotIn,
0000000000000000000000000000000000000000;;													Values:   []string{"h1"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							PodAffinity: &v1.PodAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "foo",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"abc"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "region",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "nodeA"}, ObjectMeta: metav1.ObjectMeta{Labels: map[string]string{"foo": "abc"}}},
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "nodeB"}, ObjectMeta: metav1.ObjectMeta{Labels: map[string]string{"foo": "def"}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "nodeA", Labels: map[string]string{"region": "r1", "hostname": "h1"}}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "nodeB", Labels: map[string]string{"region": "r1", "hostname": "h2"}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: map[string]bool{
0000000000000000000000000000000000000000;;					"nodeA": false,
0000000000000000000000000000000000000000;;					"nodeB": true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				test: "NodeA and nodeB have same topologyKey and label value. NodeA does not satisfy node affinity rule, but has an existing pod that match the inter pod affinity rule. The pod can be scheduled onto nodeB.",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"foo": "bar",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							PodAffinity: &v1.PodAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "foo",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"bar"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "zone",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{},
0000000000000000000000000000000000000000;;				nodes: []v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "nodeA", Labels: map[string]string{"zone": "az1", "hostname": "h1"}}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "nodeB", Labels: map[string]string{"zone": "az2", "hostname": "h2"}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: map[string]bool{
0000000000000000000000000000000000000000;;					"nodeA": true,
0000000000000000000000000000000000000000;;					"nodeB": true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				test: "The affinity rule is to schedule all of the pods of this collection to the same zone. The first pod of the collection " +
0000000000000000000000000000000000000000;;					"should not be blocked from being scheduled onto any node, even there's no existing pod that match the rule anywhere.",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							PodAntiAffinity: &v1.PodAntiAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "foo",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"abc"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "region",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "nodeA"}, ObjectMeta: metav1.ObjectMeta{Labels: map[string]string{"foo": "abc"}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "nodeA", Labels: map[string]string{"region": "r1", "hostname": "nodeA"}}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "nodeB", Labels: map[string]string{"region": "r1", "hostname": "nodeB"}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: map[string]bool{
0000000000000000000000000000000000000000;;					"nodeA": false,
0000000000000000000000000000000000000000;;					"nodeB": false,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				test: "NodeA and nodeB have same topologyKey and label value. NodeA has an existing pod that match the inter pod affinity rule. The pod can not be scheduled onto nodeA and nodeB.",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							PodAntiAffinity: &v1.PodAntiAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "foo",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"abc"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "region",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "nodeA"}, ObjectMeta: metav1.ObjectMeta{Labels: map[string]string{"foo": "abc"}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "nodeA", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "nodeB", Labels: labelRgChinaAzAz1}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "nodeC", Labels: labelRgIndia}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: map[string]bool{
0000000000000000000000000000000000000000;;					"nodeA": false,
0000000000000000000000000000000000000000;;					"nodeB": false,
0000000000000000000000000000000000000000;;					"nodeC": true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				test: "NodeA and nodeB have same topologyKey and label value. NodeA has an existing pod that match the inter pod affinity rule. The pod can not be scheduled onto nodeA and nodeB but can be schedulerd onto nodeC",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Labels: map[string]string{"foo": "123"}},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							PodAntiAffinity: &v1.PodAntiAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "foo",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"bar"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "region",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{Spec: v1.PodSpec{NodeName: "nodeA"}, ObjectMeta: metav1.ObjectMeta{Labels: map[string]string{"foo": "bar"}}},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;							NodeName: "nodeC",
0000000000000000000000000000000000000000;;							Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;								PodAntiAffinity: &v1.PodAntiAffinity{
0000000000000000000000000000000000000000;;									RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;												MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;													{
0000000000000000000000000000000000000000;;														Key:      "foo",
0000000000000000000000000000000000000000;;														Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;														Values:   []string{"123"},
0000000000000000000000000000000000000000;;													},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;											TopologyKey: "region",
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "nodeA", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "nodeB", Labels: labelRgChinaAzAz1}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "nodeC", Labels: labelRgIndia}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "nodeD", Labels: labelRgUS}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: map[string]bool{
0000000000000000000000000000000000000000;;					"nodeA": false,
0000000000000000000000000000000000000000;;					"nodeB": false,
0000000000000000000000000000000000000000;;					"nodeC": false,
0000000000000000000000000000000000000000;;					"nodeD": true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				test:   "NodeA and nodeB have same topologyKey and label value. NodeA has an existing pod that match the inter pod affinity rule. NodeC has an existing pod that match the inter pod affinity rule. The pod can not be scheduled onto nodeA, nodeB and nodeC but can be schedulerd onto nodeD",
0000000000000000000000000000000000000000;;				nometa: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels:    map[string]string{"foo": "123"},
0000000000000000000000000000000000000000;;						Namespace: "NS1",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;							PodAntiAffinity: &v1.PodAntiAffinity{
0000000000000000000000000000000000000000;;								RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;											MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:      "foo",
0000000000000000000000000000000000000000;;													Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;													Values:   []string{"bar"},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										TopologyKey: "region",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Labels:    map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;							Namespace: "NS1",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Spec: v1.PodSpec{NodeName: "nodeA"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{Namespace: "NS2"},
0000000000000000000000000000000000000000;;						Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;							NodeName: "nodeC",
0000000000000000000000000000000000000000;;							Affinity: &v1.Affinity{
0000000000000000000000000000000000000000;;								PodAntiAffinity: &v1.PodAntiAffinity{
0000000000000000000000000000000000000000;;									RequiredDuringSchedulingIgnoredDuringExecution: []v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											LabelSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;												MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;													{
0000000000000000000000000000000000000000;;														Key:      "foo",
0000000000000000000000000000000000000000;;														Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;														Values:   []string{"123"},
0000000000000000000000000000000000000000;;													},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;											TopologyKey: "region",
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nodes: []v1.Node{
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "nodeA", Labels: labelRgChina}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "nodeB", Labels: labelRgChinaAzAz1}},
0000000000000000000000000000000000000000;;					{ObjectMeta: metav1.ObjectMeta{Name: "nodeC", Labels: labelRgIndia}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: map[string]bool{
0000000000000000000000000000000000000000;;					"nodeA": false,
0000000000000000000000000000000000000000;;					"nodeB": false,
0000000000000000000000000000000000000000;;					"nodeC": true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				test: "NodeA and nodeB have same topologyKey and label value. NodeA has an existing pod that match the inter pod affinity rule. The pod can not be scheduled onto nodeA, nodeB, but can be schedulerd onto nodeC (NodeC has an existing pod that match the inter pod affinity rule but in different namespace)",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		affinityExpectedFailureReasons := []algorithm.PredicateFailureReason{ErrPodAffinityNotMatch}
0000000000000000000000000000000000000000;;		selectorExpectedFailureReasons := []algorithm.PredicateFailureReason{ErrNodeSelectorNotMatch}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			nodeListInfo := FakeNodeListInfo(test.nodes)
0000000000000000000000000000000000000000;;			for _, node := range test.nodes {
0000000000000000000000000000000000000000;;				var podsOnNode []*v1.Pod
0000000000000000000000000000000000000000;;				for _, pod := range test.pods {
0000000000000000000000000000000000000000;;					if pod.Spec.NodeName == node.Name {
0000000000000000000000000000000000000000;;						podsOnNode = append(podsOnNode, pod)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				testFit := PodAffinityChecker{
0000000000000000000000000000000000000000;;					info:      nodeListInfo,
0000000000000000000000000000000000000000;;					podLister: schedulertesting.FakePodLister(test.pods),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				nodeInfo := schedulercache.NewNodeInfo(podsOnNode...)
0000000000000000000000000000000000000000;;				nodeInfo.SetNode(&node)
0000000000000000000000000000000000000000;;				nodeInfoMap := map[string]*schedulercache.NodeInfo{node.Name: nodeInfo}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var meta interface{} = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !test.nometa {
0000000000000000000000000000000000000000;;					meta = PredicateMetadata(test.pod, nodeInfoMap)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				fits, reasons, err := testFit.InterPodAffinityMatches(test.pod, meta, nodeInfo)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: unexpected error %v", test.test, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !fits && !reflect.DeepEqual(reasons, affinityExpectedFailureReasons) {
0000000000000000000000000000000000000000;;					t.Errorf("%s: unexpected failure reasons: %v", test.test, reasons)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				affinity := test.pod.Spec.Affinity
0000000000000000000000000000000000000000;;				if affinity != nil && affinity.NodeAffinity != nil {
0000000000000000000000000000000000000000;;					nodeInfo := schedulercache.NewNodeInfo()
0000000000000000000000000000000000000000;;					nodeInfo.SetNode(&node)
0000000000000000000000000000000000000000;;					nodeInfoMap := map[string]*schedulercache.NodeInfo{node.Name: nodeInfo}
0000000000000000000000000000000000000000;;					fits2, reasons, err := PodMatchNodeSelector(test.pod, PredicateMetadata(test.pod, nodeInfoMap), nodeInfo)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("%s: unexpected error: %v", test.test, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !fits2 && !reflect.DeepEqual(reasons, selectorExpectedFailureReasons) {
0000000000000000000000000000000000000000;;						t.Errorf("%s: unexpected failure reasons: %v, want: %v", test.test, reasons, selectorExpectedFailureReasons)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					fits = fits && fits2
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if fits != test.fits[node.Name] {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected %v for %s got %v", test.test, test.fits[node.Name], node.Name, fits)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodToleratesTaints(t *testing.T) {
0000000000000000000000000000000000000000;;		podTolerateTaintsTests := []struct {
0000000000000000000000000000000000000000;;			pod  *v1.Pod
0000000000000000000000000000000000000000;;			node v1.Node
0000000000000000000000000000000000000000;;			fits bool
0000000000000000000000000000000000000000;;			test string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "pod0",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				node: v1.Node{
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;						Taints: []v1.Taint{{Key: "dedicated", Value: "user1", Effect: "NoSchedule"}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "a pod having no tolerations can't be scheduled onto a node with nonempty taints",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "pod1",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers:  []v1.Container{{Image: "pod1:V1"}},
0000000000000000000000000000000000000000;;						Tolerations: []v1.Toleration{{Key: "dedicated", Value: "user1", Effect: "NoSchedule"}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				node: v1.Node{
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;						Taints: []v1.Taint{{Key: "dedicated", Value: "user1", Effect: "NoSchedule"}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "a pod which can be scheduled on a dedicated node assigned to user1 with effect NoSchedule",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "pod2",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers:  []v1.Container{{Image: "pod2:V1"}},
0000000000000000000000000000000000000000;;						Tolerations: []v1.Toleration{{Key: "dedicated", Operator: "Equal", Value: "user2", Effect: "NoSchedule"}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				node: v1.Node{
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;						Taints: []v1.Taint{{Key: "dedicated", Value: "user1", Effect: "NoSchedule"}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "a pod which can't be scheduled on a dedicated node assigned to user2 with effect NoSchedule",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "pod2",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers:  []v1.Container{{Image: "pod2:V1"}},
0000000000000000000000000000000000000000;;						Tolerations: []v1.Toleration{{Key: "foo", Operator: "Exists", Effect: "NoSchedule"}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				node: v1.Node{
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;						Taints: []v1.Taint{{Key: "foo", Value: "bar", Effect: "NoSchedule"}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "a pod can be scheduled onto the node, with a toleration uses operator Exists that tolerates the taints on the node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "pod2",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{{Image: "pod2:V1"}},
0000000000000000000000000000000000000000;;						Tolerations: []v1.Toleration{
0000000000000000000000000000000000000000;;							{Key: "dedicated", Operator: "Equal", Value: "user2", Effect: "NoSchedule"},
0000000000000000000000000000000000000000;;							{Key: "foo", Operator: "Exists", Effect: "NoSchedule"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				node: v1.Node{
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;						Taints: []v1.Taint{
0000000000000000000000000000000000000000;;							{Key: "dedicated", Value: "user2", Effect: "NoSchedule"},
0000000000000000000000000000000000000000;;							{Key: "foo", Value: "bar", Effect: "NoSchedule"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "a pod has multiple tolerations, node has multiple taints, all the taints are tolerated, pod can be scheduled onto the node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "pod2",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers:  []v1.Container{{Image: "pod2:V1"}},
0000000000000000000000000000000000000000;;						Tolerations: []v1.Toleration{{Key: "foo", Operator: "Equal", Value: "bar", Effect: "PreferNoSchedule"}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				node: v1.Node{
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;						Taints: []v1.Taint{
0000000000000000000000000000000000000000;;							{Key: "foo", Value: "bar", Effect: "NoSchedule"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: false,
0000000000000000000000000000000000000000;;				test: "a pod has a toleration that keys and values match the taint on the node, but (non-empty) effect doesn't match, " +
0000000000000000000000000000000000000000;;					"can't be scheduled onto the node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "pod2",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers:  []v1.Container{{Image: "pod2:V1"}},
0000000000000000000000000000000000000000;;						Tolerations: []v1.Toleration{{Key: "foo", Operator: "Equal", Value: "bar"}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				node: v1.Node{
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;						Taints: []v1.Taint{
0000000000000000000000000000000000000000;;							{Key: "foo", Value: "bar", Effect: "NoSchedule"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "The pod has a toleration that keys and values match the taint on the node, the effect of toleration is empty, " +
0000000000000000000000000000000000000000;;					"and the effect of taint is NoSchedule. Pod can be scheduled onto the node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "pod2",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers:  []v1.Container{{Image: "pod2:V1"}},
0000000000000000000000000000000000000000;;						Tolerations: []v1.Toleration{{Key: "dedicated", Operator: "Equal", Value: "user2", Effect: "NoSchedule"}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				node: v1.Node{
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;						Taints: []v1.Taint{
0000000000000000000000000000000000000000;;							{Key: "dedicated", Value: "user1", Effect: "PreferNoSchedule"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "The pod has a toleration that key and value don't match the taint on the node, " +
0000000000000000000000000000000000000000;;					"but the effect of taint on node is PreferNochedule. Pod can be scheduled onto the node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "pod2",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{{Image: "pod2:V1"}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				node: v1.Node{
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;						Taints: []v1.Taint{
0000000000000000000000000000000000000000;;							{Key: "dedicated", Value: "user1", Effect: "PreferNoSchedule"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fits: true,
0000000000000000000000000000000000000000;;				test: "The pod has no toleration, " +
0000000000000000000000000000000000000000;;					"but the effect of taint on node is PreferNochedule. Pod can be scheduled onto the node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedFailureReasons := []algorithm.PredicateFailureReason{ErrTaintsTolerationsNotMatch}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range podTolerateTaintsTests {
0000000000000000000000000000000000000000;;			nodeInfo := schedulercache.NewNodeInfo()
0000000000000000000000000000000000000000;;			nodeInfo.SetNode(&test.node)
0000000000000000000000000000000000000000;;			fits, reasons, err := PodToleratesNodeTaints(test.pod, PredicateMetadata(test.pod, nil), nodeInfo)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s, unexpected error: %v", test.test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !fits && !reflect.DeepEqual(reasons, expectedFailureReasons) {
0000000000000000000000000000000000000000;;				t.Errorf("%s, unexpected failure reason: %v, want: %v", test.test, reasons, expectedFailureReasons)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fits != test.fits {
0000000000000000000000000000000000000000;;				t.Errorf("%s, expected: %v got %v", test.test, test.fits, fits)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeEmptyNodeInfo(node *v1.Node) *schedulercache.NodeInfo {
0000000000000000000000000000000000000000;;		nodeInfo := schedulercache.NewNodeInfo()
0000000000000000000000000000000000000000;;		nodeInfo.SetNode(node)
0000000000000000000000000000000000000000;;		return nodeInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodSchedulesOnNodeWithMemoryPressureCondition(t *testing.T) {
0000000000000000000000000000000000000000;;		// specify best-effort pod
0000000000000000000000000000000000000000;;		bestEffortPod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:            "container",
0000000000000000000000000000000000000000;;						Image:           "image",
0000000000000000000000000000000000000000;;						ImagePullPolicy: "Always",
0000000000000000000000000000000000000000;;						// no requirements -> best effort pod
0000000000000000000000000000000000000000;;						Resources: v1.ResourceRequirements{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// specify non-best-effort pod
0000000000000000000000000000000000000000;;		nonBestEffortPod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:            "container",
0000000000000000000000000000000000000000;;						Image:           "image",
0000000000000000000000000000000000000000;;						ImagePullPolicy: "Always",
0000000000000000000000000000000000000000;;						// at least one requirement -> burstable pod
0000000000000000000000000000000000000000;;						Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;							Requests: makeAllocatableResources(100, 100, 100, 100, 0, 0),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// specify a node with no memory pressure condition on
0000000000000000000000000000000000000000;;		noMemoryPressureNode := &v1.Node{
0000000000000000000000000000000000000000;;			Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;				Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:   "Ready",
0000000000000000000000000000000000000000;;						Status: "True",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// specify a node with memory pressure condition on
0000000000000000000000000000000000000000;;		memoryPressureNode := &v1.Node{
0000000000000000000000000000000000000000;;			Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;				Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:   "MemoryPressure",
0000000000000000000000000000000000000000;;						Status: "True",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod      *v1.Pod
0000000000000000000000000000000000000000;;			nodeInfo *schedulercache.NodeInfo
0000000000000000000000000000000000000000;;			fits     bool
0000000000000000000000000000000000000000;;			name     string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      bestEffortPod,
0000000000000000000000000000000000000000;;				nodeInfo: makeEmptyNodeInfo(noMemoryPressureNode),
0000000000000000000000000000000000000000;;				fits:     true,
0000000000000000000000000000000000000000;;				name:     "best-effort pod schedulable on node without memory pressure condition on",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      bestEffortPod,
0000000000000000000000000000000000000000;;				nodeInfo: makeEmptyNodeInfo(memoryPressureNode),
0000000000000000000000000000000000000000;;				fits:     false,
0000000000000000000000000000000000000000;;				name:     "best-effort pod not schedulable on node with memory pressure condition on",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      nonBestEffortPod,
0000000000000000000000000000000000000000;;				nodeInfo: makeEmptyNodeInfo(memoryPressureNode),
0000000000000000000000000000000000000000;;				fits:     true,
0000000000000000000000000000000000000000;;				name:     "non best-effort pod schedulable on node with memory pressure condition on",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      nonBestEffortPod,
0000000000000000000000000000000000000000;;				nodeInfo: makeEmptyNodeInfo(noMemoryPressureNode),
0000000000000000000000000000000000000000;;				fits:     true,
0000000000000000000000000000000000000000;;				name:     "non best-effort pod schedulable on node without memory pressure condition on",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedFailureReasons := []algorithm.PredicateFailureReason{ErrNodeUnderMemoryPressure}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			fits, reasons, err := CheckNodeMemoryPressurePredicate(test.pod, PredicateMetadata(test.pod, nil), test.nodeInfo)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !fits && !reflect.DeepEqual(reasons, expectedFailureReasons) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected failure reasons: %v, want: %v", test.name, reasons, expectedFailureReasons)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fits != test.fits {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v got %v", test.name, test.fits, fits)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodSchedulesOnNodeWithDiskPressureCondition(t *testing.T) {
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:            "container",
0000000000000000000000000000000000000000;;						Image:           "image",
0000000000000000000000000000000000000000;;						ImagePullPolicy: "Always",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// specify a node with no disk pressure condition on
0000000000000000000000000000000000000000;;		noPressureNode := &v1.Node{
0000000000000000000000000000000000000000;;			Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;				Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:   "Ready",
0000000000000000000000000000000000000000;;						Status: "True",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// specify a node with pressure condition on
0000000000000000000000000000000000000000;;		pressureNode := &v1.Node{
0000000000000000000000000000000000000000;;			Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;				Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:   "DiskPressure",
0000000000000000000000000000000000000000;;						Status: "True",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod      *v1.Pod
0000000000000000000000000000000000000000;;			nodeInfo *schedulercache.NodeInfo
0000000000000000000000000000000000000000;;			fits     bool
0000000000000000000000000000000000000000;;			name     string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      pod,
0000000000000000000000000000000000000000;;				nodeInfo: makeEmptyNodeInfo(noPressureNode),
0000000000000000000000000000000000000000;;				fits:     true,
0000000000000000000000000000000000000000;;				name:     "pod schedulable on node without pressure condition on",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:      pod,
0000000000000000000000000000000000000000;;				nodeInfo: makeEmptyNodeInfo(pressureNode),
0000000000000000000000000000000000000000;;				fits:     false,
0000000000000000000000000000000000000000;;				name:     "pod not schedulable on node with pressure condition on",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedFailureReasons := []algorithm.PredicateFailureReason{ErrNodeUnderDiskPressure}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			fits, reasons, err := CheckNodeDiskPressurePredicate(test.pod, PredicateMetadata(test.pod, nil), test.nodeInfo)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !fits && !reflect.DeepEqual(reasons, expectedFailureReasons) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected failure reasons: %v, want: %v", test.name, reasons, expectedFailureReasons)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fits != test.fits {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v got %v", test.name, test.fits, fits)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPodWithVolume(pod, pv, pvc string) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: pod, Namespace: "default"},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: pv,
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							PersistentVolumeClaim: &v1.PersistentVolumeClaimVolumeSource{
0000000000000000000000000000000000000000;;								ClaimName: pvc,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestVolumeZonePredicate(t *testing.T) {
0000000000000000000000000000000000000000;;		pvInfo := FakePersistentVolumeInfo{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "Vol_1", Labels: map[string]string{kubeletapis.LabelZoneFailureDomain: "zone_1"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "Vol_2", Labels: map[string]string{kubeletapis.LabelZoneRegion: "zone_2", "uselessLabel": "none"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "Vol_3", Labels: map[string]string{kubeletapis.LabelZoneRegion: "zone_3"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pvcInfo := FakePersistentVolumeClaimInfo{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "PVC_1", Namespace: "default"},
0000000000000000000000000000000000000000;;				Spec:       v1.PersistentVolumeClaimSpec{VolumeName: "Vol_1"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "PVC_2", Namespace: "default"},
0000000000000000000000000000000000000000;;				Spec:       v1.PersistentVolumeClaimSpec{VolumeName: "Vol_2"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "PVC_3", Namespace: "default"},
0000000000000000000000000000000000000000;;				Spec:       v1.PersistentVolumeClaimSpec{VolumeName: "Vol_3"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "PVC_4", Namespace: "default"},
0000000000000000000000000000000000000000;;				Spec:       v1.PersistentVolumeClaimSpec{VolumeName: "Vol_not_exist"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			Name string
0000000000000000000000000000000000000000;;			Pod  *v1.Pod
0000000000000000000000000000000000000000;;			Fits bool
0000000000000000000000000000000000000000;;			Node *v1.Node
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "pod without volume",
0000000000000000000000000000000000000000;;				Pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "pod_1", Namespace: "default"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:   "host1",
0000000000000000000000000000000000000000;;						Labels: map[string]string{kubeletapis.LabelZoneFailureDomain: "zone_1"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Fits: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "node without labels",
0000000000000000000000000000000000000000;;				Pod:  createPodWithVolume("pod_1", "vol_1", "PVC_1"),
0000000000000000000000000000000000000000;;				Node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "host1",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Fits: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "label zone failure domain matched",
0000000000000000000000000000000000000000;;				Pod:  createPodWithVolume("pod_1", "vol_1", "PVC_1"),
0000000000000000000000000000000000000000;;				Node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:   "host1",
0000000000000000000000000000000000000000;;						Labels: map[string]string{kubeletapis.LabelZoneFailureDomain: "zone_1", "uselessLabel": "none"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Fits: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "label zone region matched",
0000000000000000000000000000000000000000;;				Pod:  createPodWithVolume("pod_1", "vol_1", "PVC_2"),
0000000000000000000000000000000000000000;;				Node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:   "host1",
0000000000000000000000000000000000000000;;						Labels: map[string]string{kubeletapis.LabelZoneRegion: "zone_2", "uselessLabel": "none"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Fits: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "label zone region failed match",
0000000000000000000000000000000000000000;;				Pod:  createPodWithVolume("pod_1", "vol_1", "PVC_2"),
0000000000000000000000000000000000000000;;				Node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:   "host1",
0000000000000000000000000000000000000000;;						Labels: map[string]string{kubeletapis.LabelZoneRegion: "no_zone_2", "uselessLabel": "none"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Fits: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "label zone failure domain failed match",
0000000000000000000000000000000000000000;;				Pod:  createPodWithVolume("pod_1", "vol_1", "PVC_1"),
0000000000000000000000000000000000000000;;				Node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:   "host1",
0000000000000000000000000000000000000000;;						Labels: map[string]string{kubeletapis.LabelZoneFailureDomain: "no_zone_1", "uselessLabel": "none"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Fits: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedFailureReasons := []algorithm.PredicateFailureReason{ErrVolumeZoneConflict}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			fit := NewVolumeZonePredicate(pvInfo, pvcInfo)
0000000000000000000000000000000000000000;;			node := &schedulercache.NodeInfo{}
0000000000000000000000000000000000000000;;			node.SetNode(test.Node)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fits, reasons, err := fit(test.Pod, nil, node)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !fits && !reflect.DeepEqual(reasons, expectedFailureReasons) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected failure reasons: %v, want: %v", test.Name, reasons, expectedFailureReasons)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fits != test.Fits {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v got %v", test.Name, test.Fits, fits)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
