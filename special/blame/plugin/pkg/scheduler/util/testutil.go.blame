0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
2d50955b3454400b0b7b8f0b02b0afb88a059f18;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"mime"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/api/install"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TestGroup struct {
0000000000000000000000000000000000000000;;		externalGroupVersion schema.GroupVersion
0000000000000000000000000000000000000000;;		internalGroupVersion schema.GroupVersion
0000000000000000000000000000000000000000;;		internalTypes        map[string]reflect.Type
0000000000000000000000000000000000000000;;		externalTypes        map[string]reflect.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		Groups = make(map[string]TestGroup)
0000000000000000000000000000000000000000;;		Test   TestGroup
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serializer runtime.SerializerInfo
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		if apiMediaType := os.Getenv("KUBE_TEST_API_TYPE"); len(apiMediaType) > 0 {
0000000000000000000000000000000000000000;;			var ok bool
0000000000000000000000000000000000000000;;			mediaType, _, err := mime.ParseMediaType(apiMediaType)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			serializer, ok = runtime.SerializerInfoForMediaType(api.Codecs.SupportedMediaTypes(), mediaType)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("no serializer for %s", apiMediaType))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeTestAPI := os.Getenv("KUBE_TEST_API")
0000000000000000000000000000000000000000;;		if len(kubeTestAPI) != 0 {
0000000000000000000000000000000000000000;;			// priority is "first in list preferred", so this has to run in reverse order
0000000000000000000000000000000000000000;;			testGroupVersions := strings.Split(kubeTestAPI, ",")
0000000000000000000000000000000000000000;;			for i := len(testGroupVersions) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;				gvString := testGroupVersions[i]
0000000000000000000000000000000000000000;;				groupVersion, err := schema.ParseGroupVersion(gvString)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					panic(fmt.Sprintf("Error parsing groupversion %v: %v", gvString, err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				internalGroupVersion := schema.GroupVersion{Group: groupVersion.Group, Version: runtime.APIVersionInternal}
0000000000000000000000000000000000000000;;				Groups[groupVersion.Group] = TestGroup{
0000000000000000000000000000000000000000;;					externalGroupVersion: groupVersion,
0000000000000000000000000000000000000000;;					internalGroupVersion: internalGroupVersion,
0000000000000000000000000000000000000000;;					internalTypes:        api.Scheme.KnownTypes(internalGroupVersion),
0000000000000000000000000000000000000000;;					externalTypes:        api.Scheme.KnownTypes(groupVersion),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok := Groups[api.GroupName]; !ok {
0000000000000000000000000000000000000000;;			externalGroupVersion := schema.GroupVersion{Group: api.GroupName, Version: api.Registry.GroupOrDie(api.GroupName).GroupVersion.Version}
0000000000000000000000000000000000000000;;			Groups[api.GroupName] = TestGroup{
0000000000000000000000000000000000000000;;				externalGroupVersion: externalGroupVersion,
0000000000000000000000000000000000000000;;				internalGroupVersion: api.SchemeGroupVersion,
0000000000000000000000000000000000000000;;				internalTypes:        api.Scheme.KnownTypes(api.SchemeGroupVersion),
0000000000000000000000000000000000000000;;				externalTypes:        api.Scheme.KnownTypes(externalGroupVersion),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Test = Groups[api.GroupName]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Codec returns the codec for the API version to test against, as set by the
0000000000000000000000000000000000000000;;	// KUBE_TEST_API_TYPE env var.
0000000000000000000000000000000000000000;;	func (g TestGroup) Codec() runtime.Codec {
0000000000000000000000000000000000000000;;		if serializer.Serializer == nil {
0000000000000000000000000000000000000000;;			return api.Codecs.LegacyCodec(g.externalGroupVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return api.Codecs.CodecForVersions(serializer.Serializer, api.Codecs.UniversalDeserializer(), schema.GroupVersions{g.externalGroupVersion}, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SelfLink returns a self link that will appear to be for the version Version().
0000000000000000000000000000000000000000;;	// 'resource' should be the resource path, e.g. "pods" for the Pod type. 'name' should be
0000000000000000000000000000000000000000;;	// empty for lists.
0000000000000000000000000000000000000000;;	func (g TestGroup) SelfLink(resource, name string) string {
0000000000000000000000000000000000000000;;		if g.externalGroupVersion.Group == api.GroupName {
0000000000000000000000000000000000000000;;			if name == "" {
0000000000000000000000000000000000000000;;				return fmt.Sprintf("/api/%s/%s", g.externalGroupVersion.Version, resource)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Sprintf("/api/%s/%s/%s", g.externalGroupVersion.Version, resource, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: will need a /apis prefix once we have proper multi-group
0000000000000000000000000000000000000000;;		// support
0000000000000000000000000000000000000000;;		if name == "" {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("/apis/%s/%s/%s", g.externalGroupVersion.Group, g.externalGroupVersion.Version, resource)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("/apis/%s/%s/%s/%s", g.externalGroupVersion.Group, g.externalGroupVersion.Version, resource, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourcePathWithPrefix returns the appropriate path for the given prefix (watch, proxy, redirect, etc), resource, namespace and name.
0000000000000000000000000000000000000000;;	// For ex, this is of the form:
0000000000000000000000000000000000000000;;	// /api/v1/watch/namespaces/foo/pods/pod0 for v1.
0000000000000000000000000000000000000000;;	func (g TestGroup) ResourcePathWithPrefix(prefix, resource, namespace, name string) string {
0000000000000000000000000000000000000000;;		var path string
0000000000000000000000000000000000000000;;		if g.externalGroupVersion.Group == api.GroupName {
0000000000000000000000000000000000000000;;			path = "/api/" + g.externalGroupVersion.Version
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// TODO: switch back once we have proper multiple group support
0000000000000000000000000000000000000000;;			// path = "/apis/" + g.Group + "/" + Version(group...)
0000000000000000000000000000000000000000;;			path = "/apis/" + g.externalGroupVersion.Group + "/" + g.externalGroupVersion.Version
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if prefix != "" {
0000000000000000000000000000000000000000;;			path = path + "/" + prefix
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if namespace != "" {
0000000000000000000000000000000000000000;;			path = path + "/namespaces/" + namespace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Resource names are lower case.
0000000000000000000000000000000000000000;;		resource = strings.ToLower(resource)
0000000000000000000000000000000000000000;;		if resource != "" {
0000000000000000000000000000000000000000;;			path = path + "/" + resource
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if name != "" {
0000000000000000000000000000000000000000;;			path = path + "/" + name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourcePath returns the appropriate path for the given resource, namespace and name.
0000000000000000000000000000000000000000;;	// For example, this is of the form:
0000000000000000000000000000000000000000;;	// /api/v1/namespaces/foo/pods/pod0 for v1.
0000000000000000000000000000000000000000;;	func (g TestGroup) ResourcePath(resource, namespace, name string) string {
0000000000000000000000000000000000000000;;		return g.ResourcePathWithPrefix("", resource, namespace, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SubResourcePath returns the appropriate path for the given resource, namespace,
0000000000000000000000000000000000000000;;	// name and subresource.
0000000000000000000000000000000000000000;;	func (g TestGroup) SubResourcePath(resource, namespace, name, sub string) string {
0000000000000000000000000000000000000000;;		path := g.ResourcePathWithPrefix("", resource, namespace, name)
0000000000000000000000000000000000000000;;		if sub != "" {
0000000000000000000000000000000000000000;;			path = path + "/" + sub
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return path
0000000000000000000000000000000000000000;;	}
