0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
0d256681b018e44f017644355f370d62a449a621;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		ktypes "k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type clock interface {
0000000000000000000000000000000000000000;;		Now() time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type realClock struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (realClock) Now() time.Time {
0000000000000000000000000000000000000000;;		return time.Now()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// backoffEntry is single threaded.  in particular, it only allows a single action to be waiting on backoff at a time.
0000000000000000000000000000000000000000;;	// It is expected that all users will only use the public TryWait(...) method
0000000000000000000000000000000000000000;;	// It is also not safe to copy this object.
0000000000000000000000000000000000000000;;	type backoffEntry struct {
0000000000000000000000000000000000000000;;		backoff     time.Duration
0000000000000000000000000000000000000000;;		lastUpdate  time.Time
0000000000000000000000000000000000000000;;		reqInFlight int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tryLock attempts to acquire a lock via atomic compare and swap.
0000000000000000000000000000000000000000;;	// returns true if the lock was acquired, false otherwise
0000000000000000000000000000000000000000;;	func (b *backoffEntry) tryLock() bool {
0000000000000000000000000000000000000000;;		return atomic.CompareAndSwapInt32(&b.reqInFlight, 0, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unlock returns the lock.  panics if the lock isn't held
0000000000000000000000000000000000000000;;	func (b *backoffEntry) unlock() {
0000000000000000000000000000000000000000;;		if !atomic.CompareAndSwapInt32(&b.reqInFlight, 1, 0) {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("unexpected state on unlocking: %+v", b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TryWait tries to acquire the backoff lock, maxDuration is the maximum allowed period to wait for.
0000000000000000000000000000000000000000;;	func (b *backoffEntry) TryWait(maxDuration time.Duration) bool {
0000000000000000000000000000000000000000;;		if !b.tryLock() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer b.unlock()
0000000000000000000000000000000000000000;;		b.wait(maxDuration)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *backoffEntry) getBackoff(maxDuration time.Duration) time.Duration {
0000000000000000000000000000000000000000;;		duration := entry.backoff
0000000000000000000000000000000000000000;;		newDuration := time.Duration(duration) * 2
0000000000000000000000000000000000000000;;		if newDuration > maxDuration {
0000000000000000000000000000000000000000;;			newDuration = maxDuration
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		entry.backoff = newDuration
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Backing off %s for pod %+v", duration.String(), entry)
0000000000000000000000000000000000000000;;		return duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *backoffEntry) wait(maxDuration time.Duration) {
0000000000000000000000000000000000000000;;		time.Sleep(entry.getBackoff(maxDuration))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PodBackoff struct {
0000000000000000000000000000000000000000;;		perPodBackoff   map[ktypes.NamespacedName]*backoffEntry
0000000000000000000000000000000000000000;;		lock            sync.Mutex
0000000000000000000000000000000000000000;;		clock           clock
0000000000000000000000000000000000000000;;		defaultDuration time.Duration
0000000000000000000000000000000000000000;;		maxDuration     time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *PodBackoff) MaxDuration() time.Duration {
0000000000000000000000000000000000000000;;		return p.maxDuration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreateDefaultPodBackoff() *PodBackoff {
0000000000000000000000000000000000000000;;		return CreatePodBackoff(1*time.Second, 60*time.Second)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreatePodBackoff(defaultDuration, maxDuration time.Duration) *PodBackoff {
0000000000000000000000000000000000000000;;		return CreatePodBackoffWithClock(defaultDuration, maxDuration, realClock{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreatePodBackoffWithClock(defaultDuration, maxDuration time.Duration, clock clock) *PodBackoff {
0000000000000000000000000000000000000000;;		return &PodBackoff{
0000000000000000000000000000000000000000;;			perPodBackoff:   map[ktypes.NamespacedName]*backoffEntry{},
0000000000000000000000000000000000000000;;			clock:           clock,
0000000000000000000000000000000000000000;;			defaultDuration: defaultDuration,
0000000000000000000000000000000000000000;;			maxDuration:     maxDuration,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *PodBackoff) GetEntry(podID ktypes.NamespacedName) *backoffEntry {
0000000000000000000000000000000000000000;;		p.lock.Lock()
0000000000000000000000000000000000000000;;		defer p.lock.Unlock()
0000000000000000000000000000000000000000;;		entry, ok := p.perPodBackoff[podID]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			entry = &backoffEntry{backoff: p.defaultDuration}
0000000000000000000000000000000000000000;;			p.perPodBackoff[podID] = entry
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		entry.lastUpdate = p.clock.Now()
0000000000000000000000000000000000000000;;		return entry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *PodBackoff) Gc() {
0000000000000000000000000000000000000000;;		p.lock.Lock()
0000000000000000000000000000000000000000;;		defer p.lock.Unlock()
0000000000000000000000000000000000000000;;		now := p.clock.Now()
0000000000000000000000000000000000000000;;		for podID, entry := range p.perPodBackoff {
0000000000000000000000000000000000000000;;			if now.Sub(entry.lastUpdate) > p.maxDuration {
0000000000000000000000000000000000000000;;				delete(p.perPodBackoff, podID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
