0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
c8eb0c0f6b1c2ebd7c2e9f2da2e82b1e23ce59c2;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package scheduler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm"
0000000000000000000000000000000000000000;;		schedulerapi "k8s.io/kubernetes/plugin/pkg/scheduler/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/core"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/metrics"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/schedulercache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/util"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Binder knows how to write a binding.
0000000000000000000000000000000000000000;;	type Binder interface {
0000000000000000000000000000000000000000;;		Bind(binding *v1.Binding) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodConditionUpdater updates the condition of a pod based on the passed
0000000000000000000000000000000000000000;;	// PodCondition
0000000000000000000000000000000000000000;;	type PodConditionUpdater interface {
0000000000000000000000000000000000000000;;		Update(pod *v1.Pod, podCondition *v1.PodCondition) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scheduler watches for new unscheduled pods. It attempts to find
0000000000000000000000000000000000000000;;	// nodes that they fit on and writes bindings back to the api server.
0000000000000000000000000000000000000000;;	type Scheduler struct {
0000000000000000000000000000000000000000;;		config *Config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StopEverything closes the scheduler config's StopEverything channel, to shut
0000000000000000000000000000000000000000;;	// down the Scheduler.
0000000000000000000000000000000000000000;;	func (sched *Scheduler) StopEverything() {
0000000000000000000000000000000000000000;;		close(sched.config.StopEverything)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Configurator defines I/O, caching, and other functionality needed to
0000000000000000000000000000000000000000;;	// construct a new scheduler. An implementation of this can be seen in
0000000000000000000000000000000000000000;;	// factory.go.
0000000000000000000000000000000000000000;;	type Configurator interface {
0000000000000000000000000000000000000000;;		GetPriorityFunctionConfigs(priorityKeys sets.String) ([]algorithm.PriorityConfig, error)
0000000000000000000000000000000000000000;;		GetPriorityMetadataProducer() (algorithm.MetadataProducer, error)
0000000000000000000000000000000000000000;;		GetPredicateMetadataProducer() (algorithm.MetadataProducer, error)
0000000000000000000000000000000000000000;;		GetPredicates(predicateKeys sets.String) (map[string]algorithm.FitPredicate, error)
0000000000000000000000000000000000000000;;		GetHardPodAffinitySymmetricWeight() int
0000000000000000000000000000000000000000;;		GetSchedulerName() string
0000000000000000000000000000000000000000;;		MakeDefaultErrorFunc(backoff *util.PodBackoff, podQueue *cache.FIFO) func(pod *v1.Pod, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Probably doesn't need to be public.  But exposed for now in case.
0000000000000000000000000000000000000000;;		ResponsibleForPod(pod *v1.Pod) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Needs to be exposed for things like integration tests where we want to make fake nodes.
0000000000000000000000000000000000000000;;		GetNodeLister() corelisters.NodeLister
0000000000000000000000000000000000000000;;		GetClient() clientset.Interface
0000000000000000000000000000000000000000;;		GetScheduledPodLister() corelisters.PodLister
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Create() (*Config, error)
0000000000000000000000000000000000000000;;		CreateFromProvider(providerName string) (*Config, error)
0000000000000000000000000000000000000000;;		CreateFromConfig(policy schedulerapi.Policy) (*Config, error)
0000000000000000000000000000000000000000;;		CreateFromKeys(predicateKeys, priorityKeys sets.String, extenders []algorithm.SchedulerExtender) (*Config, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config is an implementation of the Scheduler's configured input data.
0000000000000000000000000000000000000000;;	// TODO over time we should make this struct a hidden implementation detail of the scheduler.
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		// It is expected that changes made via SchedulerCache will be observed
0000000000000000000000000000000000000000;;		// by NodeLister and Algorithm.
0000000000000000000000000000000000000000;;		SchedulerCache schedulercache.Cache
0000000000000000000000000000000000000000;;		// Ecache is used for optimistically invalid affected cache items after
0000000000000000000000000000000000000000;;		// successfully binding a pod
0000000000000000000000000000000000000000;;		Ecache     *core.EquivalenceCache
0000000000000000000000000000000000000000;;		NodeLister algorithm.NodeLister
0000000000000000000000000000000000000000;;		Algorithm  algorithm.ScheduleAlgorithm
0000000000000000000000000000000000000000;;		Binder     Binder
0000000000000000000000000000000000000000;;		// PodConditionUpdater is used only in case of scheduling errors. If we succeed
0000000000000000000000000000000000000000;;		// with scheduling, PodScheduled condition will be updated in apiserver in /bind
0000000000000000000000000000000000000000;;		// handler so that binding and setting PodCondition it is atomic.
0000000000000000000000000000000000000000;;		PodConditionUpdater PodConditionUpdater
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NextPod should be a function that blocks until the next pod
0000000000000000000000000000000000000000;;		// is available. We don't use a channel for this, because scheduling
0000000000000000000000000000000000000000;;		// a pod may take some amount of time and we don't want pods to get
0000000000000000000000000000000000000000;;		// stale while they sit in a channel.
0000000000000000000000000000000000000000;;		NextPod func() *v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WaitForCacheSync waits for scheduler cache to populate.
0000000000000000000000000000000000000000;;		// It returns true if it was successful, false if the controller should shutdown.
0000000000000000000000000000000000000000;;		WaitForCacheSync func() bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Error is called if there is an error. It is passed the pod in
0000000000000000000000000000000000000000;;		// question, and the error
0000000000000000000000000000000000000000;;		Error func(*v1.Pod, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Recorder is the EventRecorder to use
0000000000000000000000000000000000000000;;		Recorder record.EventRecorder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close this to shut down the scheduler.
0000000000000000000000000000000000000000;;		StopEverything chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFromConfigurator returns a new scheduler that is created entirely by the Configurator.  Assumes Create() is implemented.
0000000000000000000000000000000000000000;;	// Supports intermediate Config mutation for now if you provide modifier functions which will run after Config is created.
0000000000000000000000000000000000000000;;	func NewFromConfigurator(c Configurator, modifiers ...func(c *Config)) (*Scheduler, error) {
0000000000000000000000000000000000000000;;		cfg, err := c.Create()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Mutate it if any functions were provided, changes might be required for certain types of tests (i.e. change the recorder).
0000000000000000000000000000000000000000;;		for _, modifier := range modifiers {
0000000000000000000000000000000000000000;;			modifier(cfg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// From this point on the config is immutable to the outside.
0000000000000000000000000000000000000000;;		s := &Scheduler{
0000000000000000000000000000000000000000;;			config: cfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metrics.Register()
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run begins watching and scheduling. It waits for cache to be synced, then starts a goroutine and returns immediately.
0000000000000000000000000000000000000000;;	func (sched *Scheduler) Run() {
0000000000000000000000000000000000000000;;		if !sched.config.WaitForCacheSync() {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go wait.Until(sched.scheduleOne, 0, sched.config.StopEverything)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config return scheduler's config pointer. It is exposed for testing purposes.
0000000000000000000000000000000000000000;;	func (sched *Scheduler) Config() *Config {
0000000000000000000000000000000000000000;;		return sched.config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// schedule implements the scheduling algorithm and returns the suggested host.
0000000000000000000000000000000000000000;;	func (sched *Scheduler) schedule(pod *v1.Pod) (string, error) {
0000000000000000000000000000000000000000;;		host, err := sched.config.Algorithm.Schedule(pod, sched.config.NodeLister)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(1).Infof("Failed to schedule pod: %v/%v", pod.Namespace, pod.Name)
0000000000000000000000000000000000000000;;			copied, cerr := api.Scheme.Copy(pod)
0000000000000000000000000000000000000000;;			if cerr != nil {
0000000000000000000000000000000000000000;;				runtime.HandleError(err)
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod = copied.(*v1.Pod)
0000000000000000000000000000000000000000;;			sched.config.Error(pod, err)
0000000000000000000000000000000000000000;;			sched.config.Recorder.Eventf(pod, v1.EventTypeWarning, "FailedScheduling", "%v", err)
0000000000000000000000000000000000000000;;			sched.config.PodConditionUpdater.Update(pod, &v1.PodCondition{
0000000000000000000000000000000000000000;;				Type:    v1.PodScheduled,
0000000000000000000000000000000000000000;;				Status:  v1.ConditionFalse,
0000000000000000000000000000000000000000;;				Reason:  v1.PodReasonUnschedulable,
0000000000000000000000000000000000000000;;				Message: err.Error(),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return host, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// assume signals to the cache that a pod is already in the cache, so that binding can be asnychronous.
0000000000000000000000000000000000000000;;	func (sched *Scheduler) assume(pod *v1.Pod, host string) error {
0000000000000000000000000000000000000000;;		// Optimistically assume that the binding will succeed and send it to apiserver
0000000000000000000000000000000000000000;;		// in the background.
0000000000000000000000000000000000000000;;		// If the binding fails, scheduler will release resources allocated to assumed pod
0000000000000000000000000000000000000000;;		// immediately.
0000000000000000000000000000000000000000;;		assumed := *pod
0000000000000000000000000000000000000000;;		assumed.Spec.NodeName = host
0000000000000000000000000000000000000000;;		if err := sched.config.SchedulerCache.AssumePod(&assumed); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("scheduler cache AssumePod failed: %v", err)
0000000000000000000000000000000000000000;;			// TODO: This means that a given pod is already in cache (which means it
0000000000000000000000000000000000000000;;			// is either assumed or already added). This is most probably result of a
0000000000000000000000000000000000000000;;			// BUG in retrying logic. As a temporary workaround (which doesn't fully
0000000000000000000000000000000000000000;;			// fix the problem, but should reduce its impact), we simply return here,
0000000000000000000000000000000000000000;;			// as binding doesn't make sense anyway.
0000000000000000000000000000000000000000;;			// This should be fixed properly though.
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Optimistically assume that the binding will succeed, so we need to invalidate affected
0000000000000000000000000000000000000000;;		// predicates in equivalence cache.
0000000000000000000000000000000000000000;;		// If the binding fails, these invalidated item will not break anything.
0000000000000000000000000000000000000000;;		if sched.config.Ecache != nil {
0000000000000000000000000000000000000000;;			sched.config.Ecache.InvalidateCachedPredicateItemForPodAdd(pod, host)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bind binds a pod to a given node defined in a binding object.  We expect this to run asynchronously, so we
0000000000000000000000000000000000000000;;	// handle binding metrics internally.
0000000000000000000000000000000000000000;;	func (sched *Scheduler) bind(assumed *v1.Pod, b *v1.Binding) error {
0000000000000000000000000000000000000000;;		bindingStart := time.Now()
0000000000000000000000000000000000000000;;		// If binding succeeded then PodScheduled condition will be updated in apiserver so that
0000000000000000000000000000000000000000;;		// it's atomic with setting host.
0000000000000000000000000000000000000000;;		err := sched.config.Binder.Bind(b)
0000000000000000000000000000000000000000;;		if err := sched.config.SchedulerCache.FinishBinding(assumed); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("scheduler cache FinishBinding failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(1).Infof("Failed to bind pod: %v/%v", assumed.Namespace, assumed.Name)
0000000000000000000000000000000000000000;;			if err := sched.config.SchedulerCache.ForgetPod(assumed); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("scheduler cache ForgetPod failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sched.config.Error(assumed, err)
0000000000000000000000000000000000000000;;			sched.config.Recorder.Eventf(assumed, v1.EventTypeWarning, "FailedScheduling", "Binding rejected: %v", err)
0000000000000000000000000000000000000000;;			sched.config.PodConditionUpdater.Update(assumed, &v1.PodCondition{
0000000000000000000000000000000000000000;;				Type:   v1.PodScheduled,
0000000000000000000000000000000000000000;;				Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;				Reason: "BindingRejected",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metrics.BindingLatency.Observe(metrics.SinceInMicroseconds(bindingStart))
0000000000000000000000000000000000000000;;		sched.config.Recorder.Eventf(assumed, v1.EventTypeNormal, "Scheduled", "Successfully assigned %v to %v", assumed.Name, b.Target.Name)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scheduleOne does the entire scheduling workflow for a single pod.  It is serialized on the scheduling algorithm's host fitting.
0000000000000000000000000000000000000000;;	func (sched *Scheduler) scheduleOne() {
0000000000000000000000000000000000000000;;		pod := sched.config.NextPod()
0000000000000000000000000000000000000000;;		if pod.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;			sched.config.Recorder.Eventf(pod, v1.EventTypeWarning, "FailedScheduling", "skip schedule deleting pod: %v/%v", pod.Namespace, pod.Name)
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Skip schedule deleting pod: %v/%v", pod.Namespace, pod.Name)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Attempting to schedule pod: %v/%v", pod.Namespace, pod.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Synchronously attempt to find a fit for the pod.
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;		suggestedHost, err := sched.schedule(pod)
0000000000000000000000000000000000000000;;		metrics.SchedulingAlgorithmLatency.Observe(metrics.SinceInMicroseconds(start))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Tell the cache to assume that a pod now is running on a given node, even though it hasn't been bound yet.
0000000000000000000000000000000000000000;;		// This allows us to keep scheduling without waiting on binding to occur.
0000000000000000000000000000000000000000;;		err = sched.assume(pod, suggestedHost)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// bind the pod to its host asynchronously (we can do this b/c of the assumption step above).
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			err := sched.bind(pod, &v1.Binding{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Namespace: pod.Namespace, Name: pod.Name, UID: pod.UID},
0000000000000000000000000000000000000000;;				Target: v1.ObjectReference{
0000000000000000000000000000000000000000;;					Kind: "Node",
0000000000000000000000000000000000000000;;					Name: suggestedHost,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			metrics.E2eSchedulingLatency.Observe(metrics.SinceInMicroseconds(start))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Internal error binding pod: (%v)", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
