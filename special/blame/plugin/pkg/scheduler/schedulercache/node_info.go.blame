0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
2d7d08c28018dc2d8cb131a6a2bb1cf354ea4b29;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package schedulercache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		clientcache "k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		priorityutil "k8s.io/kubernetes/plugin/pkg/scheduler/algorithm/priorities/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var emptyResource = Resource{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeInfo is node level aggregated information.
0000000000000000000000000000000000000000;;	type NodeInfo struct {
0000000000000000000000000000000000000000;;		// Overall node information.
0000000000000000000000000000000000000000;;		node *v1.Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods             []*v1.Pod
0000000000000000000000000000000000000000;;		podsWithAffinity []*v1.Pod
0000000000000000000000000000000000000000;;		usedPorts        map[int]bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Total requested resource of all pods on this node.
0000000000000000000000000000000000000000;;		// It includes assumed pods which scheduler sends binding to apiserver but
0000000000000000000000000000000000000000;;		// didn't get it as scheduled yet.
0000000000000000000000000000000000000000;;		requestedResource *Resource
0000000000000000000000000000000000000000;;		nonzeroRequest    *Resource
0000000000000000000000000000000000000000;;		// We store allocatedResources (which is Node.Status.Allocatable.*) explicitly
0000000000000000000000000000000000000000;;		// as int64, to avoid conversions and accessing map.
0000000000000000000000000000000000000000;;		allocatableResource *Resource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Cached tains of the node for faster lookup.
0000000000000000000000000000000000000000;;		taints    []v1.Taint
0000000000000000000000000000000000000000;;		taintsErr error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Cached conditions of node for faster lookup.
0000000000000000000000000000000000000000;;		memoryPressureCondition v1.ConditionStatus
0000000000000000000000000000000000000000;;		diskPressureCondition   v1.ConditionStatus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Whenever NodeInfo changes, generation is bumped.
0000000000000000000000000000000000000000;;		// This is used to avoid cloning it if the object didn't change.
0000000000000000000000000000000000000000;;		generation int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Resource is a collection of compute resource.
0000000000000000000000000000000000000000;;	type Resource struct {
0000000000000000000000000000000000000000;;		MilliCPU       int64
0000000000000000000000000000000000000000;;		Memory         int64
0000000000000000000000000000000000000000;;		NvidiaGPU      int64
0000000000000000000000000000000000000000;;		StorageScratch int64
0000000000000000000000000000000000000000;;		StorageOverlay int64
0000000000000000000000000000000000000000;;		// We store allowedPodNumber (which is Node.Status.Allocatable.Pods().Value())
0000000000000000000000000000000000000000;;		// explicitly as int, to avoid conversions and improve performance.
0000000000000000000000000000000000000000;;		AllowedPodNumber   int
0000000000000000000000000000000000000000;;		OpaqueIntResources map[v1.ResourceName]int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a Resource from ResourceList
0000000000000000000000000000000000000000;;	func NewResource(rl v1.ResourceList) *Resource {
0000000000000000000000000000000000000000;;		r := &Resource{}
0000000000000000000000000000000000000000;;		r.Add(rl)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds ResourceList into Resource.
0000000000000000000000000000000000000000;;	func (r *Resource) Add(rl v1.ResourceList) {
0000000000000000000000000000000000000000;;		if r == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for rName, rQuant := range rl {
0000000000000000000000000000000000000000;;			switch rName {
0000000000000000000000000000000000000000;;			case v1.ResourceCPU:
0000000000000000000000000000000000000000;;				r.MilliCPU += rQuant.MilliValue()
0000000000000000000000000000000000000000;;			case v1.ResourceMemory:
0000000000000000000000000000000000000000;;				r.Memory += rQuant.Value()
0000000000000000000000000000000000000000;;			case v1.ResourceNvidiaGPU:
0000000000000000000000000000000000000000;;				r.NvidiaGPU += rQuant.Value()
0000000000000000000000000000000000000000;;			case v1.ResourcePods:
0000000000000000000000000000000000000000;;				r.AllowedPodNumber += int(rQuant.Value())
0000000000000000000000000000000000000000;;			case v1.ResourceStorage:
0000000000000000000000000000000000000000;;				r.StorageScratch += rQuant.Value()
0000000000000000000000000000000000000000;;			case v1.ResourceStorageOverlay:
0000000000000000000000000000000000000000;;				r.StorageOverlay += rQuant.Value()
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if v1helper.IsOpaqueIntResourceName(rName) {
0000000000000000000000000000000000000000;;					r.AddOpaque(rName, rQuant.Value())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Resource) ResourceList() v1.ResourceList {
0000000000000000000000000000000000000000;;		result := v1.ResourceList{
0000000000000000000000000000000000000000;;			v1.ResourceCPU:            *resource.NewMilliQuantity(r.MilliCPU, resource.DecimalSI),
0000000000000000000000000000000000000000;;			v1.ResourceMemory:         *resource.NewQuantity(r.Memory, resource.BinarySI),
0000000000000000000000000000000000000000;;			v1.ResourceNvidiaGPU:      *resource.NewQuantity(r.NvidiaGPU, resource.DecimalSI),
0000000000000000000000000000000000000000;;			v1.ResourcePods:           *resource.NewQuantity(int64(r.AllowedPodNumber), resource.BinarySI),
0000000000000000000000000000000000000000;;			v1.ResourceStorageOverlay: *resource.NewQuantity(r.StorageOverlay, resource.BinarySI),
0000000000000000000000000000000000000000;;			v1.ResourceStorage:        *resource.NewQuantity(r.StorageScratch, resource.BinarySI),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for rName, rQuant := range r.OpaqueIntResources {
0000000000000000000000000000000000000000;;			result[rName] = *resource.NewQuantity(rQuant, resource.DecimalSI)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Resource) Clone() *Resource {
0000000000000000000000000000000000000000;;		res := &Resource{
0000000000000000000000000000000000000000;;			MilliCPU:         r.MilliCPU,
0000000000000000000000000000000000000000;;			Memory:           r.Memory,
0000000000000000000000000000000000000000;;			NvidiaGPU:        r.NvidiaGPU,
0000000000000000000000000000000000000000;;			AllowedPodNumber: r.AllowedPodNumber,
0000000000000000000000000000000000000000;;			StorageOverlay:   r.StorageOverlay,
0000000000000000000000000000000000000000;;			StorageScratch:   r.StorageScratch,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.OpaqueIntResources != nil {
0000000000000000000000000000000000000000;;			res.OpaqueIntResources = make(map[v1.ResourceName]int64)
0000000000000000000000000000000000000000;;			for k, v := range r.OpaqueIntResources {
0000000000000000000000000000000000000000;;				res.OpaqueIntResources[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Resource) AddOpaque(name v1.ResourceName, quantity int64) {
0000000000000000000000000000000000000000;;		r.SetOpaque(name, r.OpaqueIntResources[name]+quantity)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Resource) SetOpaque(name v1.ResourceName, quantity int64) {
0000000000000000000000000000000000000000;;		// Lazily allocate opaque integer resource map.
0000000000000000000000000000000000000000;;		if r.OpaqueIntResources == nil {
0000000000000000000000000000000000000000;;			r.OpaqueIntResources = map[v1.ResourceName]int64{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.OpaqueIntResources[name] = quantity
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewNodeInfo returns a ready to use empty NodeInfo object.
0000000000000000000000000000000000000000;;	// If any pods are given in arguments, their information will be aggregated in
0000000000000000000000000000000000000000;;	// the returned object.
0000000000000000000000000000000000000000;;	func NewNodeInfo(pods ...*v1.Pod) *NodeInfo {
0000000000000000000000000000000000000000;;		ni := &NodeInfo{
0000000000000000000000000000000000000000;;			requestedResource:   &Resource{},
0000000000000000000000000000000000000000;;			nonzeroRequest:      &Resource{},
0000000000000000000000000000000000000000;;			allocatableResource: &Resource{},
0000000000000000000000000000000000000000;;			generation:          0,
0000000000000000000000000000000000000000;;			usedPorts:           make(map[int]bool),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			ni.addPod(pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ni
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns overall information about this node.
0000000000000000000000000000000000000000;;	func (n *NodeInfo) Node() *v1.Node {
0000000000000000000000000000000000000000;;		if n == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.node
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pods return all pods scheduled (including assumed to be) on this node.
0000000000000000000000000000000000000000;;	func (n *NodeInfo) Pods() []*v1.Pod {
0000000000000000000000000000000000000000;;		if n == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.pods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *NodeInfo) UsedPorts() map[int]bool {
0000000000000000000000000000000000000000;;		if n == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.usedPorts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodsWithAffinity return all pods with (anti)affinity constraints on this node.
0000000000000000000000000000000000000000;;	func (n *NodeInfo) PodsWithAffinity() []*v1.Pod {
0000000000000000000000000000000000000000;;		if n == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.podsWithAffinity
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *NodeInfo) AllowedPodNumber() int {
0000000000000000000000000000000000000000;;		if n == nil || n.allocatableResource == nil {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.allocatableResource.AllowedPodNumber
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *NodeInfo) Taints() ([]v1.Taint, error) {
0000000000000000000000000000000000000000;;		if n == nil {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.taints, n.taintsErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *NodeInfo) MemoryPressureCondition() v1.ConditionStatus {
0000000000000000000000000000000000000000;;		if n == nil {
0000000000000000000000000000000000000000;;			return v1.ConditionUnknown
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.memoryPressureCondition
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *NodeInfo) DiskPressureCondition() v1.ConditionStatus {
0000000000000000000000000000000000000000;;		if n == nil {
0000000000000000000000000000000000000000;;			return v1.ConditionUnknown
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.diskPressureCondition
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequestedResource returns aggregated resource request of pods on this node.
0000000000000000000000000000000000000000;;	func (n *NodeInfo) RequestedResource() Resource {
0000000000000000000000000000000000000000;;		if n == nil {
0000000000000000000000000000000000000000;;			return emptyResource
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *n.requestedResource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NonZeroRequest returns aggregated nonzero resource request of pods on this node.
0000000000000000000000000000000000000000;;	func (n *NodeInfo) NonZeroRequest() Resource {
0000000000000000000000000000000000000000;;		if n == nil {
0000000000000000000000000000000000000000;;			return emptyResource
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *n.nonzeroRequest
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllocatableResource returns allocatable resources on a given node.
0000000000000000000000000000000000000000;;	func (n *NodeInfo) AllocatableResource() Resource {
0000000000000000000000000000000000000000;;		if n == nil {
0000000000000000000000000000000000000000;;			return emptyResource
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *n.allocatableResource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *NodeInfo) Clone() *NodeInfo {
0000000000000000000000000000000000000000;;		clone := &NodeInfo{
0000000000000000000000000000000000000000;;			node:                    n.node,
0000000000000000000000000000000000000000;;			requestedResource:       n.requestedResource.Clone(),
0000000000000000000000000000000000000000;;			nonzeroRequest:          n.nonzeroRequest.Clone(),
0000000000000000000000000000000000000000;;			allocatableResource:     n.allocatableResource.Clone(),
0000000000000000000000000000000000000000;;			taintsErr:               n.taintsErr,
0000000000000000000000000000000000000000;;			memoryPressureCondition: n.memoryPressureCondition,
0000000000000000000000000000000000000000;;			diskPressureCondition:   n.diskPressureCondition,
0000000000000000000000000000000000000000;;			usedPorts:               make(map[int]bool),
0000000000000000000000000000000000000000;;			generation:              n.generation,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(n.pods) > 0 {
0000000000000000000000000000000000000000;;			clone.pods = append([]*v1.Pod(nil), n.pods...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(n.usedPorts) > 0 {
0000000000000000000000000000000000000000;;			for k, v := range n.usedPorts {
0000000000000000000000000000000000000000;;				clone.usedPorts[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(n.podsWithAffinity) > 0 {
0000000000000000000000000000000000000000;;			clone.podsWithAffinity = append([]*v1.Pod(nil), n.podsWithAffinity...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(n.taints) > 0 {
0000000000000000000000000000000000000000;;			clone.taints = append([]v1.Taint(nil), n.taints...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clone
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns representation of human readable format of this NodeInfo.
0000000000000000000000000000000000000000;;	func (n *NodeInfo) String() string {
0000000000000000000000000000000000000000;;		podKeys := make([]string, len(n.pods))
0000000000000000000000000000000000000000;;		for i, pod := range n.pods {
0000000000000000000000000000000000000000;;			podKeys[i] = pod.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("&NodeInfo{Pods:%v, RequestedResource:%#v, NonZeroRequest: %#v, UsedPort: %#v, AllocatableResource:%#v}",
0000000000000000000000000000000000000000;;			podKeys, n.requestedResource, n.nonzeroRequest, n.usedPorts, n.allocatableResource)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasPodAffinityConstraints(pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		affinity := pod.Spec.Affinity
0000000000000000000000000000000000000000;;		return affinity != nil && (affinity.PodAffinity != nil || affinity.PodAntiAffinity != nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addPod adds pod information to this NodeInfo.
0000000000000000000000000000000000000000;;	func (n *NodeInfo) addPod(pod *v1.Pod) {
0000000000000000000000000000000000000000;;		res, non0_cpu, non0_mem := calculateResource(pod)
0000000000000000000000000000000000000000;;		n.requestedResource.MilliCPU += res.MilliCPU
0000000000000000000000000000000000000000;;		n.requestedResource.Memory += res.Memory
0000000000000000000000000000000000000000;;		n.requestedResource.NvidiaGPU += res.NvidiaGPU
0000000000000000000000000000000000000000;;		n.requestedResource.StorageOverlay += res.StorageOverlay
0000000000000000000000000000000000000000;;		n.requestedResource.StorageScratch += res.StorageScratch
0000000000000000000000000000000000000000;;		if n.requestedResource.OpaqueIntResources == nil && len(res.OpaqueIntResources) > 0 {
0000000000000000000000000000000000000000;;			n.requestedResource.OpaqueIntResources = map[v1.ResourceName]int64{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for rName, rQuant := range res.OpaqueIntResources {
0000000000000000000000000000000000000000;;			n.requestedResource.OpaqueIntResources[rName] += rQuant
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n.nonzeroRequest.MilliCPU += non0_cpu
0000000000000000000000000000000000000000;;		n.nonzeroRequest.Memory += non0_mem
0000000000000000000000000000000000000000;;		n.pods = append(n.pods, pod)
0000000000000000000000000000000000000000;;		if hasPodAffinityConstraints(pod) {
0000000000000000000000000000000000000000;;			n.podsWithAffinity = append(n.podsWithAffinity, pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Consume ports when pods added.
0000000000000000000000000000000000000000;;		n.updateUsedPorts(pod, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n.generation++
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removePod subtracts pod information to this NodeInfo.
0000000000000000000000000000000000000000;;	func (n *NodeInfo) removePod(pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		k1, err := getPodKey(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range n.podsWithAffinity {
0000000000000000000000000000000000000000;;			k2, err := getPodKey(n.podsWithAffinity[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Cannot get pod key, err: %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if k1 == k2 {
0000000000000000000000000000000000000000;;				// delete the element
0000000000000000000000000000000000000000;;				n.podsWithAffinity[i] = n.podsWithAffinity[len(n.podsWithAffinity)-1]
0000000000000000000000000000000000000000;;				n.podsWithAffinity = n.podsWithAffinity[:len(n.podsWithAffinity)-1]
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range n.pods {
0000000000000000000000000000000000000000;;			k2, err := getPodKey(n.pods[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Cannot get pod key, err: %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if k1 == k2 {
0000000000000000000000000000000000000000;;				// delete the element
0000000000000000000000000000000000000000;;				n.pods[i] = n.pods[len(n.pods)-1]
0000000000000000000000000000000000000000;;				n.pods = n.pods[:len(n.pods)-1]
0000000000000000000000000000000000000000;;				// reduce the resource data
0000000000000000000000000000000000000000;;				res, non0_cpu, non0_mem := calculateResource(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				n.requestedResource.MilliCPU -= res.MilliCPU
0000000000000000000000000000000000000000;;				n.requestedResource.Memory -= res.Memory
0000000000000000000000000000000000000000;;				n.requestedResource.NvidiaGPU -= res.NvidiaGPU
0000000000000000000000000000000000000000;;				if len(res.OpaqueIntResources) > 0 && n.requestedResource.OpaqueIntResources == nil {
0000000000000000000000000000000000000000;;					n.requestedResource.OpaqueIntResources = map[v1.ResourceName]int64{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for rName, rQuant := range res.OpaqueIntResources {
0000000000000000000000000000000000000000;;					n.requestedResource.OpaqueIntResources[rName] -= rQuant
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				n.nonzeroRequest.MilliCPU -= non0_cpu
0000000000000000000000000000000000000000;;				n.nonzeroRequest.Memory -= non0_mem
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Release ports when remove Pods.
0000000000000000000000000000000000000000;;				n.updateUsedPorts(pod, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				n.generation++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("no corresponding pod %s in pods of node %s", pod.Name, n.node.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func calculateResource(pod *v1.Pod) (res Resource, non0_cpu int64, non0_mem int64) {
0000000000000000000000000000000000000000;;		resPtr := &res
0000000000000000000000000000000000000000;;		for _, c := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			resPtr.Add(c.Resources.Requests)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			non0_cpu_req, non0_mem_req := priorityutil.GetNonzeroRequests(&c.Resources.Requests)
0000000000000000000000000000000000000000;;			non0_cpu += non0_cpu_req
0000000000000000000000000000000000000000;;			non0_mem += non0_mem_req
0000000000000000000000000000000000000000;;			// No non-zero resources for GPUs or opaque resources.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Account for storage requested by emptydir volumes
0000000000000000000000000000000000000000;;		// If the storage medium is memory, should exclude the size
0000000000000000000000000000000000000000;;		for _, vol := range pod.Spec.Volumes {
0000000000000000000000000000000000000000;;			if vol.EmptyDir != nil && vol.EmptyDir.Medium != v1.StorageMediumMemory {
0000000000000000000000000000000000000000;;				res.StorageScratch += vol.EmptyDir.SizeLimit.Value()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *NodeInfo) updateUsedPorts(pod *v1.Pod, used bool) {
0000000000000000000000000000000000000000;;		for j := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			container := &pod.Spec.Containers[j]
0000000000000000000000000000000000000000;;			for k := range container.Ports {
0000000000000000000000000000000000000000;;				podPort := &container.Ports[k]
0000000000000000000000000000000000000000;;				// "0" is explicitly ignored in PodFitsHostPorts,
0000000000000000000000000000000000000000;;				// which is the only function that uses this value.
0000000000000000000000000000000000000000;;				if podPort.HostPort != 0 {
0000000000000000000000000000000000000000;;					n.usedPorts[int(podPort.HostPort)] = used
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sets the overall node information.
0000000000000000000000000000000000000000;;	func (n *NodeInfo) SetNode(node *v1.Node) error {
0000000000000000000000000000000000000000;;		n.node = node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n.allocatableResource = NewResource(node.Status.Allocatable)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n.taints = node.Spec.Taints
0000000000000000000000000000000000000000;;		for i := range node.Status.Conditions {
0000000000000000000000000000000000000000;;			cond := &node.Status.Conditions[i]
0000000000000000000000000000000000000000;;			switch cond.Type {
0000000000000000000000000000000000000000;;			case v1.NodeMemoryPressure:
0000000000000000000000000000000000000000;;				n.memoryPressureCondition = cond.Status
0000000000000000000000000000000000000000;;			case v1.NodeDiskPressure:
0000000000000000000000000000000000000000;;				n.diskPressureCondition = cond.Status
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// We ignore other conditions.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n.generation++
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Removes the overall information about the node.
0000000000000000000000000000000000000000;;	func (n *NodeInfo) RemoveNode(node *v1.Node) error {
0000000000000000000000000000000000000000;;		// We don't remove NodeInfo for because there can still be some pods on this node -
0000000000000000000000000000000000000000;;		// this is because notifications about pods are delivered in a different watch,
0000000000000000000000000000000000000000;;		// and thus can potentially be observed later, even though they happened before
0000000000000000000000000000000000000000;;		// node removal. This is handled correctly in cache.go file.
0000000000000000000000000000000000000000;;		n.node = nil
0000000000000000000000000000000000000000;;		n.allocatableResource = &Resource{}
0000000000000000000000000000000000000000;;		n.taints, n.taintsErr = nil, nil
0000000000000000000000000000000000000000;;		n.memoryPressureCondition = v1.ConditionUnknown
0000000000000000000000000000000000000000;;		n.diskPressureCondition = v1.ConditionUnknown
0000000000000000000000000000000000000000;;		n.generation++
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodKey returns the string key of a pod.
0000000000000000000000000000000000000000;;	func getPodKey(pod *v1.Pod) (string, error) {
0000000000000000000000000000000000000000;;		return clientcache.MetaNamespaceKeyFunc(pod)
0000000000000000000000000000000000000000;;	}
