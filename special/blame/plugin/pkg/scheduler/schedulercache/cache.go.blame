0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
85a0fa3b63d2dc05e722b20ea2071ba9f955019d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package schedulercache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		cleanAssumedPeriod = 1 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a Cache implementation.
0000000000000000000000000000000000000000;;	// It automatically starts a go routine that manages expiration of assumed pods.
0000000000000000000000000000000000000000;;	// "ttl" is how long the assumed pod will get expired.
0000000000000000000000000000000000000000;;	// "stop" is the channel that would close the background goroutine.
0000000000000000000000000000000000000000;;	func New(ttl time.Duration, stop <-chan struct{}) Cache {
0000000000000000000000000000000000000000;;		cache := newSchedulerCache(ttl, cleanAssumedPeriod, stop)
0000000000000000000000000000000000000000;;		cache.run()
0000000000000000000000000000000000000000;;		return cache
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type schedulerCache struct {
0000000000000000000000000000000000000000;;		stop   <-chan struct{}
0000000000000000000000000000000000000000;;		ttl    time.Duration
0000000000000000000000000000000000000000;;		period time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This mutex guards all fields within this cache struct.
0000000000000000000000000000000000000000;;		mu sync.Mutex
0000000000000000000000000000000000000000;;		// a set of assumed pod keys.
0000000000000000000000000000000000000000;;		// The key could further be used to get an entry in podStates.
0000000000000000000000000000000000000000;;		assumedPods map[string]bool
0000000000000000000000000000000000000000;;		// a map from pod key to podState.
0000000000000000000000000000000000000000;;		podStates map[string]*podState
0000000000000000000000000000000000000000;;		nodes     map[string]*NodeInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type podState struct {
0000000000000000000000000000000000000000;;		pod *v1.Pod
0000000000000000000000000000000000000000;;		// Used by assumedPod to determinate expiration.
0000000000000000000000000000000000000000;;		deadline *time.Time
0000000000000000000000000000000000000000;;		// Used to block cache from expiring assumedPod if binding still runs
0000000000000000000000000000000000000000;;		bindingFinished bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSchedulerCache(ttl, period time.Duration, stop <-chan struct{}) *schedulerCache {
0000000000000000000000000000000000000000;;		return &schedulerCache{
0000000000000000000000000000000000000000;;			ttl:    ttl,
0000000000000000000000000000000000000000;;			period: period,
0000000000000000000000000000000000000000;;			stop:   stop,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nodes:       make(map[string]*NodeInfo),
0000000000000000000000000000000000000000;;			assumedPods: make(map[string]bool),
0000000000000000000000000000000000000000;;			podStates:   make(map[string]*podState),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cache *schedulerCache) UpdateNodeNameToInfoMap(nodeNameToInfo map[string]*NodeInfo) error {
0000000000000000000000000000000000000000;;		cache.mu.Lock()
0000000000000000000000000000000000000000;;		defer cache.mu.Unlock()
0000000000000000000000000000000000000000;;		for name, info := range cache.nodes {
0000000000000000000000000000000000000000;;			if current, ok := nodeNameToInfo[name]; !ok || current.generation != info.generation {
0000000000000000000000000000000000000000;;				nodeNameToInfo[name] = info.Clone()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for name := range nodeNameToInfo {
0000000000000000000000000000000000000000;;			if _, ok := cache.nodes[name]; !ok {
0000000000000000000000000000000000000000;;				delete(nodeNameToInfo, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cache *schedulerCache) List(selector labels.Selector) ([]*v1.Pod, error) {
0000000000000000000000000000000000000000;;		cache.mu.Lock()
0000000000000000000000000000000000000000;;		defer cache.mu.Unlock()
0000000000000000000000000000000000000000;;		var pods []*v1.Pod
0000000000000000000000000000000000000000;;		for _, info := range cache.nodes {
0000000000000000000000000000000000000000;;			for _, pod := range info.pods {
0000000000000000000000000000000000000000;;				if selector.Matches(labels.Set(pod.Labels)) {
0000000000000000000000000000000000000000;;					pods = append(pods, pod)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pods, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cache *schedulerCache) AssumePod(pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		key, err := getPodKey(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cache.mu.Lock()
0000000000000000000000000000000000000000;;		defer cache.mu.Unlock()
0000000000000000000000000000000000000000;;		if _, ok := cache.podStates[key]; ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("pod %v state wasn't initial but get assumed", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cache.addPod(pod)
0000000000000000000000000000000000000000;;		ps := &podState{
0000000000000000000000000000000000000000;;			pod: pod,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cache.podStates[key] = ps
0000000000000000000000000000000000000000;;		cache.assumedPods[key] = true
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cache *schedulerCache) FinishBinding(pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		return cache.finishBinding(pod, time.Now())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// finishBinding exists to make tests determinitistic by injecting now as an argument
0000000000000000000000000000000000000000;;	func (cache *schedulerCache) finishBinding(pod *v1.Pod, now time.Time) error {
0000000000000000000000000000000000000000;;		key, err := getPodKey(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cache.mu.Lock()
0000000000000000000000000000000000000000;;		defer cache.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Finished binding for pod %v. Can be expired.", key)
0000000000000000000000000000000000000000;;		currState, ok := cache.podStates[key]
0000000000000000000000000000000000000000;;		if ok && cache.assumedPods[key] {
0000000000000000000000000000000000000000;;			dl := now.Add(cache.ttl)
0000000000000000000000000000000000000000;;			currState.bindingFinished = true
0000000000000000000000000000000000000000;;			currState.deadline = &dl
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cache *schedulerCache) ForgetPod(pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		key, err := getPodKey(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cache.mu.Lock()
0000000000000000000000000000000000000000;;		defer cache.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currState, ok := cache.podStates[key]
0000000000000000000000000000000000000000;;		if ok && currState.pod.Spec.NodeName != pod.Spec.NodeName {
0000000000000000000000000000000000000000;;			return fmt.Errorf("pod %v state was assumed on a different node", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		// Only assumed pod can be forgotten.
0000000000000000000000000000000000000000;;		case ok && cache.assumedPods[key]:
0000000000000000000000000000000000000000;;			err := cache.removePod(pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			delete(cache.assumedPods, key)
0000000000000000000000000000000000000000;;			delete(cache.podStates, key)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("pod %v state wasn't assumed but get forgotten", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Assumes that lock is already acquired.
0000000000000000000000000000000000000000;;	func (cache *schedulerCache) addPod(pod *v1.Pod) {
0000000000000000000000000000000000000000;;		n, ok := cache.nodes[pod.Spec.NodeName]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			n = NewNodeInfo()
0000000000000000000000000000000000000000;;			cache.nodes[pod.Spec.NodeName] = n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n.addPod(pod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Assumes that lock is already acquired.
0000000000000000000000000000000000000000;;	func (cache *schedulerCache) updatePod(oldPod, newPod *v1.Pod) error {
0000000000000000000000000000000000000000;;		if err := cache.removePod(oldPod); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cache.addPod(newPod)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Assumes that lock is already acquired.
0000000000000000000000000000000000000000;;	func (cache *schedulerCache) removePod(pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		n := cache.nodes[pod.Spec.NodeName]
0000000000000000000000000000000000000000;;		if err := n.removePod(pod); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(n.pods) == 0 && n.node == nil {
0000000000000000000000000000000000000000;;			delete(cache.nodes, pod.Spec.NodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cache *schedulerCache) AddPod(pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		key, err := getPodKey(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cache.mu.Lock()
0000000000000000000000000000000000000000;;		defer cache.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currState, ok := cache.podStates[key]
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case ok && cache.assumedPods[key]:
0000000000000000000000000000000000000000;;			if currState.pod.Spec.NodeName != pod.Spec.NodeName {
0000000000000000000000000000000000000000;;				// The pod was added to a different node than it was assumed to.
0000000000000000000000000000000000000000;;				glog.Warningf("Pod %v assumed to a different node than added to.", key)
0000000000000000000000000000000000000000;;				// Clean this up.
0000000000000000000000000000000000000000;;				cache.removePod(currState.pod)
0000000000000000000000000000000000000000;;				cache.addPod(pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			delete(cache.assumedPods, key)
0000000000000000000000000000000000000000;;			cache.podStates[key].deadline = nil
0000000000000000000000000000000000000000;;		case !ok:
0000000000000000000000000000000000000000;;			// Pod was expired. We should add it back.
0000000000000000000000000000000000000000;;			cache.addPod(pod)
0000000000000000000000000000000000000000;;			ps := &podState{
0000000000000000000000000000000000000000;;				pod: pod,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cache.podStates[key] = ps
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("pod was already in added state. Pod key: %v", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cache *schedulerCache) UpdatePod(oldPod, newPod *v1.Pod) error {
0000000000000000000000000000000000000000;;		key, err := getPodKey(oldPod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cache.mu.Lock()
0000000000000000000000000000000000000000;;		defer cache.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currState, ok := cache.podStates[key]
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		// An assumed pod won't have Update/Remove event. It needs to have Add event
0000000000000000000000000000000000000000;;		// before Update event, in which case the state would change from Assumed to Added.
0000000000000000000000000000000000000000;;		case ok && !cache.assumedPods[key]:
0000000000000000000000000000000000000000;;			if currState.pod.Spec.NodeName != newPod.Spec.NodeName {
0000000000000000000000000000000000000000;;				glog.Errorf("Pod %v updated on a different node than previously added to.", key)
0000000000000000000000000000000000000000;;				glog.Fatalf("Schedulercache is corrupted and can badly affect scheduling decisions")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := cache.updatePod(oldPod, newPod); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("pod %v state wasn't added but get updated", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cache *schedulerCache) RemovePod(pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		key, err := getPodKey(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cache.mu.Lock()
0000000000000000000000000000000000000000;;		defer cache.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currState, ok := cache.podStates[key]
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		// An assumed pod won't have Delete/Remove event. It needs to have Add event
0000000000000000000000000000000000000000;;		// before Remove event, in which case the state would change from Assumed to Added.
0000000000000000000000000000000000000000;;		case ok && !cache.assumedPods[key]:
0000000000000000000000000000000000000000;;			if currState.pod.Spec.NodeName != pod.Spec.NodeName {
0000000000000000000000000000000000000000;;				glog.Errorf("Pod %v removed from a different node than previously added to.", key)
0000000000000000000000000000000000000000;;				glog.Fatalf("Schedulercache is corrupted and can badly affect scheduling decisions")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := cache.removePod(currState.pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			delete(cache.podStates, key)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("pod state wasn't added but get removed. Pod key: %v", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cache *schedulerCache) AddNode(node *v1.Node) error {
0000000000000000000000000000000000000000;;		cache.mu.Lock()
0000000000000000000000000000000000000000;;		defer cache.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, ok := cache.nodes[node.Name]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			n = NewNodeInfo()
0000000000000000000000000000000000000000;;			cache.nodes[node.Name] = n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.SetNode(node)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cache *schedulerCache) UpdateNode(oldNode, newNode *v1.Node) error {
0000000000000000000000000000000000000000;;		cache.mu.Lock()
0000000000000000000000000000000000000000;;		defer cache.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, ok := cache.nodes[newNode.Name]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			n = NewNodeInfo()
0000000000000000000000000000000000000000;;			cache.nodes[newNode.Name] = n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.SetNode(newNode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cache *schedulerCache) RemoveNode(node *v1.Node) error {
0000000000000000000000000000000000000000;;		cache.mu.Lock()
0000000000000000000000000000000000000000;;		defer cache.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := cache.nodes[node.Name]
0000000000000000000000000000000000000000;;		if err := n.RemoveNode(node); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We remove NodeInfo for this node only if there aren't any pods on this node.
0000000000000000000000000000000000000000;;		// We can't do it unconditionally, because notifications about pods are delivered
0000000000000000000000000000000000000000;;		// in a different watch, and thus can potentially be observed later, even though
0000000000000000000000000000000000000000;;		// they happened before node removal.
0000000000000000000000000000000000000000;;		if len(n.pods) == 0 && n.node == nil {
0000000000000000000000000000000000000000;;			delete(cache.nodes, node.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cache *schedulerCache) run() {
0000000000000000000000000000000000000000;;		go wait.Until(cache.cleanupExpiredAssumedPods, cache.period, cache.stop)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cache *schedulerCache) cleanupExpiredAssumedPods() {
0000000000000000000000000000000000000000;;		cache.cleanupAssumedPods(time.Now())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cleanupAssumedPods exists for making test deterministic by taking time as input argument.
0000000000000000000000000000000000000000;;	func (cache *schedulerCache) cleanupAssumedPods(now time.Time) {
0000000000000000000000000000000000000000;;		cache.mu.Lock()
0000000000000000000000000000000000000000;;		defer cache.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The size of assumedPods should be small
0000000000000000000000000000000000000000;;		for key := range cache.assumedPods {
0000000000000000000000000000000000000000;;			ps, ok := cache.podStates[key]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				panic("Key found in assumed set but not in podStates. Potentially a logical error.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !ps.bindingFinished {
0000000000000000000000000000000000000000;;				glog.Warningf("Couldn't expire cache for pod %v/%v. Binding is still in progress.",
0000000000000000000000000000000000000000;;					ps.pod.Namespace, ps.pod.Name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if now.After(*ps.deadline) {
0000000000000000000000000000000000000000;;				glog.Warningf("Pod %s/%s expired", ps.pod.Namespace, ps.pod.Name)
0000000000000000000000000000000000000000;;				if err := cache.expirePod(key, ps); err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("ExpirePod failed for %s: %v", key, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cache *schedulerCache) expirePod(key string, ps *podState) error {
0000000000000000000000000000000000000000;;		if err := cache.removePod(ps.pod); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(cache.assumedPods, key)
0000000000000000000000000000000000000000;;		delete(cache.podStates, key)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
