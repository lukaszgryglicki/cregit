0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
85a0fa3b63d2dc05e722b20ea2071ba9f955019d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package schedulercache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		priorityutil "k8s.io/kubernetes/plugin/pkg/scheduler/algorithm/priorities/util"
0000000000000000000000000000000000000000;;		schedutil "k8s.io/kubernetes/plugin/pkg/scheduler/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deepEqualWithoutGeneration(t *testing.T, testcase int, actual, expected *NodeInfo) {
0000000000000000000000000000000000000000;;		// Ignore generation field.
0000000000000000000000000000000000000000;;		if actual != nil {
0000000000000000000000000000000000000000;;			actual.generation = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(actual, expected) {
0000000000000000000000000000000000000000;;			t.Errorf("#%d: node info get=%s, want=%s", testcase, actual, expected)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAssumePodScheduled tests that after a pod is assumed, its information is aggregated
0000000000000000000000000000000000000000;;	// on node level.
0000000000000000000000000000000000000000;;	func TestAssumePodScheduled(t *testing.T) {
0000000000000000000000000000000000000000;;		nodeName := "node"
0000000000000000000000000000000000000000;;		testPods := []*v1.Pod{
0000000000000000000000000000000000000000;;			makeBasePod(nodeName, "test", "100m", "500", []v1.ContainerPort{{HostPort: 80}}),
0000000000000000000000000000000000000000;;			makeBasePod(nodeName, "test-1", "100m", "500", []v1.ContainerPort{{HostPort: 80}}),
0000000000000000000000000000000000000000;;			makeBasePod(nodeName, "test-2", "200m", "1Ki", []v1.ContainerPort{{HostPort: 8080}}),
0000000000000000000000000000000000000000;;			makeBasePod(nodeName, "test-nonzero", "", "", []v1.ContainerPort{{HostPort: 80}}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pods []*v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			wNodeInfo *NodeInfo
0000000000000000000000000000000000000000;;		}{{
0000000000000000000000000000000000000000;;			pods: []*v1.Pod{testPods[0]},
0000000000000000000000000000000000000000;;			wNodeInfo: &NodeInfo{
0000000000000000000000000000000000000000;;				requestedResource: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 100,
0000000000000000000000000000000000000000;;					Memory:   500,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nonzeroRequest: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 100,
0000000000000000000000000000000000000000;;					Memory:   500,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				allocatableResource: &Resource{},
0000000000000000000000000000000000000000;;				pods:                []*v1.Pod{testPods[0]},
0000000000000000000000000000000000000000;;				usedPorts:           map[int]bool{80: true},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			pods: []*v1.Pod{testPods[1], testPods[2]},
0000000000000000000000000000000000000000;;			wNodeInfo: &NodeInfo{
0000000000000000000000000000000000000000;;				requestedResource: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 300,
0000000000000000000000000000000000000000;;					Memory:   1524,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nonzeroRequest: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 300,
0000000000000000000000000000000000000000;;					Memory:   1524,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				allocatableResource: &Resource{},
0000000000000000000000000000000000000000;;				pods:                []*v1.Pod{testPods[1], testPods[2]},
0000000000000000000000000000000000000000;;				usedPorts:           map[int]bool{80: true, 8080: true},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, { // test non-zero request
0000000000000000000000000000000000000000;;			pods: []*v1.Pod{testPods[3]},
0000000000000000000000000000000000000000;;			wNodeInfo: &NodeInfo{
0000000000000000000000000000000000000000;;				requestedResource: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 0,
0000000000000000000000000000000000000000;;					Memory:   0,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nonzeroRequest: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: priorityutil.DefaultMilliCpuRequest,
0000000000000000000000000000000000000000;;					Memory:   priorityutil.DefaultMemoryRequest,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				allocatableResource: &Resource{},
0000000000000000000000000000000000000000;;				pods:                []*v1.Pod{testPods[3]},
0000000000000000000000000000000000000000;;				usedPorts:           map[int]bool{80: true},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			cache := newSchedulerCache(time.Second, time.Second, nil)
0000000000000000000000000000000000000000;;			for _, pod := range tt.pods {
0000000000000000000000000000000000000000;;				if err := cache.AssumePod(pod); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("AssumePod failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n := cache.nodes[nodeName]
0000000000000000000000000000000000000000;;			deepEqualWithoutGeneration(t, i, n, tt.wNodeInfo)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, pod := range tt.pods {
0000000000000000000000000000000000000000;;				if err := cache.ForgetPod(pod); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("ForgetPod failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cache.nodes[nodeName] != nil {
0000000000000000000000000000000000000000;;				t.Errorf("NodeInfo should be cleaned for %s", nodeName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testExpirePodStruct struct {
0000000000000000000000000000000000000000;;		pod         *v1.Pod
0000000000000000000000000000000000000000;;		assumedTime time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func assumeAndFinishBinding(cache *schedulerCache, pod *v1.Pod, assumedTime time.Time) error {
0000000000000000000000000000000000000000;;		if err := cache.AssumePod(pod); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cache.finishBinding(pod, assumedTime)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestExpirePod tests that assumed pods will be removed if expired.
0000000000000000000000000000000000000000;;	// The removal will be reflected in node info.
0000000000000000000000000000000000000000;;	func TestExpirePod(t *testing.T) {
0000000000000000000000000000000000000000;;		nodeName := "node"
0000000000000000000000000000000000000000;;		testPods := []*v1.Pod{
0000000000000000000000000000000000000000;;			makeBasePod(nodeName, "test-1", "100m", "500", []v1.ContainerPort{{HostPort: 80}}),
0000000000000000000000000000000000000000;;			makeBasePod(nodeName, "test-2", "200m", "1Ki", []v1.ContainerPort{{HostPort: 8080}}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		ttl := 10 * time.Second
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pods        []*testExpirePodStruct
0000000000000000000000000000000000000000;;			cleanupTime time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			wNodeInfo *NodeInfo
0000000000000000000000000000000000000000;;		}{{ // assumed pod would expires
0000000000000000000000000000000000000000;;			pods: []*testExpirePodStruct{
0000000000000000000000000000000000000000;;				{pod: testPods[0], assumedTime: now},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			cleanupTime: now.Add(2 * ttl),
0000000000000000000000000000000000000000;;			wNodeInfo:   nil,
0000000000000000000000000000000000000000;;		}, { // first one would expire, second one would not.
0000000000000000000000000000000000000000;;			pods: []*testExpirePodStruct{
0000000000000000000000000000000000000000;;				{pod: testPods[0], assumedTime: now},
0000000000000000000000000000000000000000;;				{pod: testPods[1], assumedTime: now.Add(3 * ttl / 2)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			cleanupTime: now.Add(2 * ttl),
0000000000000000000000000000000000000000;;			wNodeInfo: &NodeInfo{
0000000000000000000000000000000000000000;;				requestedResource: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 200,
0000000000000000000000000000000000000000;;					Memory:   1024,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nonzeroRequest: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 200,
0000000000000000000000000000000000000000;;					Memory:   1024,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				allocatableResource: &Resource{},
0000000000000000000000000000000000000000;;				pods:                []*v1.Pod{testPods[1]},
0000000000000000000000000000000000000000;;				usedPorts:           map[int]bool{80: false, 8080: true},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			cache := newSchedulerCache(ttl, time.Second, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, pod := range tt.pods {
0000000000000000000000000000000000000000;;				if err := assumeAndFinishBinding(cache, pod.pod, pod.assumedTime); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("assumePod failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// pods that have assumedTime + ttl < cleanupTime will get expired and removed
0000000000000000000000000000000000000000;;			cache.cleanupAssumedPods(tt.cleanupTime)
0000000000000000000000000000000000000000;;			n := cache.nodes[nodeName]
0000000000000000000000000000000000000000;;			deepEqualWithoutGeneration(t, i, n, tt.wNodeInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAddPodWillConfirm tests that a pod being Add()ed will be confirmed if assumed.
0000000000000000000000000000000000000000;;	// The pod info should still exist after manually expiring unconfirmed pods.
0000000000000000000000000000000000000000;;	func TestAddPodWillConfirm(t *testing.T) {
0000000000000000000000000000000000000000;;		nodeName := "node"
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		ttl := 10 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testPods := []*v1.Pod{
0000000000000000000000000000000000000000;;			makeBasePod(nodeName, "test-1", "100m", "500", []v1.ContainerPort{{HostPort: 80}}),
0000000000000000000000000000000000000000;;			makeBasePod(nodeName, "test-2", "200m", "1Ki", []v1.ContainerPort{{HostPort: 8080}}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			podsToAssume []*v1.Pod
0000000000000000000000000000000000000000;;			podsToAdd    []*v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			wNodeInfo *NodeInfo
0000000000000000000000000000000000000000;;		}{{ // two pod were assumed at same time. But first one is called Add() and gets confirmed.
0000000000000000000000000000000000000000;;			podsToAssume: []*v1.Pod{testPods[0], testPods[1]},
0000000000000000000000000000000000000000;;			podsToAdd:    []*v1.Pod{testPods[0]},
0000000000000000000000000000000000000000;;			wNodeInfo: &NodeInfo{
0000000000000000000000000000000000000000;;				requestedResource: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 100,
0000000000000000000000000000000000000000;;					Memory:   500,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nonzeroRequest: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 100,
0000000000000000000000000000000000000000;;					Memory:   500,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				allocatableResource: &Resource{},
0000000000000000000000000000000000000000;;				pods:                []*v1.Pod{testPods[0]},
0000000000000000000000000000000000000000;;				usedPorts:           map[int]bool{80: true, 8080: false},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			cache := newSchedulerCache(ttl, time.Second, nil)
0000000000000000000000000000000000000000;;			for _, podToAssume := range tt.podsToAssume {
0000000000000000000000000000000000000000;;				if err := assumeAndFinishBinding(cache, podToAssume, now); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("assumePod failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, podToAdd := range tt.podsToAdd {
0000000000000000000000000000000000000000;;				if err := cache.AddPod(podToAdd); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("AddPod failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cache.cleanupAssumedPods(now.Add(2 * ttl))
0000000000000000000000000000000000000000;;			// check after expiration. confirmed pods shouldn't be expired.
0000000000000000000000000000000000000000;;			n := cache.nodes[nodeName]
0000000000000000000000000000000000000000;;			deepEqualWithoutGeneration(t, i, n, tt.wNodeInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAddPodAfterExpiration tests that a pod being Add()ed will be added back if expired.
0000000000000000000000000000000000000000;;	func TestAddPodAfterExpiration(t *testing.T) {
0000000000000000000000000000000000000000;;		nodeName := "node"
0000000000000000000000000000000000000000;;		ttl := 10 * time.Second
0000000000000000000000000000000000000000;;		basePod := makeBasePod(nodeName, "test", "100m", "500", []v1.ContainerPort{{HostPort: 80}})
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod *v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			wNodeInfo *NodeInfo
0000000000000000000000000000000000000000;;		}{{
0000000000000000000000000000000000000000;;			pod: basePod,
0000000000000000000000000000000000000000;;			wNodeInfo: &NodeInfo{
0000000000000000000000000000000000000000;;				requestedResource: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 100,
0000000000000000000000000000000000000000;;					Memory:   500,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nonzeroRequest: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 100,
0000000000000000000000000000000000000000;;					Memory:   500,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				allocatableResource: &Resource{},
0000000000000000000000000000000000000000;;				pods:                []*v1.Pod{basePod},
0000000000000000000000000000000000000000;;				usedPorts:           map[int]bool{80: true},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			cache := newSchedulerCache(ttl, time.Second, nil)
0000000000000000000000000000000000000000;;			if err := assumeAndFinishBinding(cache, tt.pod, now); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("assumePod failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cache.cleanupAssumedPods(now.Add(2 * ttl))
0000000000000000000000000000000000000000;;			// It should be expired and removed.
0000000000000000000000000000000000000000;;			n := cache.nodes[nodeName]
0000000000000000000000000000000000000000;;			if n != nil {
0000000000000000000000000000000000000000;;				t.Errorf("#%d: expecting nil node info, but get=%v", i, n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := cache.AddPod(tt.pod); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("AddPod failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// check after expiration. confirmed pods shouldn't be expired.
0000000000000000000000000000000000000000;;			n = cache.nodes[nodeName]
0000000000000000000000000000000000000000;;			deepEqualWithoutGeneration(t, i, n, tt.wNodeInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestUpdatePod tests that a pod will be updated if added before.
0000000000000000000000000000000000000000;;	func TestUpdatePod(t *testing.T) {
0000000000000000000000000000000000000000;;		nodeName := "node"
0000000000000000000000000000000000000000;;		ttl := 10 * time.Second
0000000000000000000000000000000000000000;;		testPods := []*v1.Pod{
0000000000000000000000000000000000000000;;			makeBasePod(nodeName, "test", "100m", "500", []v1.ContainerPort{{HostPort: 80}}),
0000000000000000000000000000000000000000;;			makeBasePod(nodeName, "test", "200m", "1Ki", []v1.ContainerPort{{HostPort: 8080}}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			podsToAssume []*v1.Pod
0000000000000000000000000000000000000000;;			podsToAdd    []*v1.Pod
0000000000000000000000000000000000000000;;			podsToUpdate []*v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			wNodeInfo []*NodeInfo
0000000000000000000000000000000000000000;;		}{{ // add a pod and then update it twice
0000000000000000000000000000000000000000;;			podsToAdd:    []*v1.Pod{testPods[0]},
0000000000000000000000000000000000000000;;			podsToUpdate: []*v1.Pod{testPods[0], testPods[1], testPods[0]},
0000000000000000000000000000000000000000;;			wNodeInfo: []*NodeInfo{{
0000000000000000000000000000000000000000;;				requestedResource: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 200,
0000000000000000000000000000000000000000;;					Memory:   1024,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nonzeroRequest: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 200,
0000000000000000000000000000000000000000;;					Memory:   1024,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				allocatableResource: &Resource{},
0000000000000000000000000000000000000000;;				pods:                []*v1.Pod{testPods[1]},
0000000000000000000000000000000000000000;;				usedPorts:           map[int]bool{8080: true},
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				requestedResource: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 100,
0000000000000000000000000000000000000000;;					Memory:   500,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nonzeroRequest: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 100,
0000000000000000000000000000000000000000;;					Memory:   500,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				allocatableResource: &Resource{},
0000000000000000000000000000000000000000;;				pods:                []*v1.Pod{testPods[0]},
0000000000000000000000000000000000000000;;				usedPorts:           map[int]bool{80: true},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tt := range tests {
0000000000000000000000000000000000000000;;			cache := newSchedulerCache(ttl, time.Second, nil)
0000000000000000000000000000000000000000;;			for _, podToAdd := range tt.podsToAdd {
0000000000000000000000000000000000000000;;				if err := cache.AddPod(podToAdd); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("AddPod failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i := range tt.podsToUpdate {
0000000000000000000000000000000000000000;;				if i == 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := cache.UpdatePod(tt.podsToUpdate[i-1], tt.podsToUpdate[i]); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("UpdatePod failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check after expiration. confirmed pods shouldn't be expired.
0000000000000000000000000000000000000000;;				n := cache.nodes[nodeName]
0000000000000000000000000000000000000000;;				deepEqualWithoutGeneration(t, i, n, tt.wNodeInfo[i-1])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestExpireAddUpdatePod test the sequence that a pod is expired, added, then updated
0000000000000000000000000000000000000000;;	func TestExpireAddUpdatePod(t *testing.T) {
0000000000000000000000000000000000000000;;		nodeName := "node"
0000000000000000000000000000000000000000;;		ttl := 10 * time.Second
0000000000000000000000000000000000000000;;		testPods := []*v1.Pod{
0000000000000000000000000000000000000000;;			makeBasePod(nodeName, "test", "100m", "500", []v1.ContainerPort{{HostPort: 80}}),
0000000000000000000000000000000000000000;;			makeBasePod(nodeName, "test", "200m", "1Ki", []v1.ContainerPort{{HostPort: 8080}}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			podsToAssume []*v1.Pod
0000000000000000000000000000000000000000;;			podsToAdd    []*v1.Pod
0000000000000000000000000000000000000000;;			podsToUpdate []*v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			wNodeInfo []*NodeInfo
0000000000000000000000000000000000000000;;		}{{ // Pod is assumed, expired, and added. Then it would be updated twice.
0000000000000000000000000000000000000000;;			podsToAssume: []*v1.Pod{testPods[0]},
0000000000000000000000000000000000000000;;			podsToAdd:    []*v1.Pod{testPods[0]},
0000000000000000000000000000000000000000;;			podsToUpdate: []*v1.Pod{testPods[0], testPods[1], testPods[0]},
0000000000000000000000000000000000000000;;			wNodeInfo: []*NodeInfo{{
0000000000000000000000000000000000000000;;				requestedResource: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 200,
0000000000000000000000000000000000000000;;					Memory:   1024,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nonzeroRequest: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 200,
0000000000000000000000000000000000000000;;					Memory:   1024,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				allocatableResource: &Resource{},
0000000000000000000000000000000000000000;;				pods:                []*v1.Pod{testPods[1]},
0000000000000000000000000000000000000000;;				usedPorts:           map[int]bool{8080: true},
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				requestedResource: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 100,
0000000000000000000000000000000000000000;;					Memory:   500,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nonzeroRequest: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 100,
0000000000000000000000000000000000000000;;					Memory:   500,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				allocatableResource: &Resource{},
0000000000000000000000000000000000000000;;				pods:                []*v1.Pod{testPods[0]},
0000000000000000000000000000000000000000;;				usedPorts:           map[int]bool{80: true},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		for _, tt := range tests {
0000000000000000000000000000000000000000;;			cache := newSchedulerCache(ttl, time.Second, nil)
0000000000000000000000000000000000000000;;			for _, podToAssume := range tt.podsToAssume {
0000000000000000000000000000000000000000;;				if err := assumeAndFinishBinding(cache, podToAssume, now); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("assumePod failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cache.cleanupAssumedPods(now.Add(2 * ttl))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, podToAdd := range tt.podsToAdd {
0000000000000000000000000000000000000000;;				if err := cache.AddPod(podToAdd); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("AddPod failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i := range tt.podsToUpdate {
0000000000000000000000000000000000000000;;				if i == 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := cache.UpdatePod(tt.podsToUpdate[i-1], tt.podsToUpdate[i]); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("UpdatePod failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check after expiration. confirmed pods shouldn't be expired.
0000000000000000000000000000000000000000;;				n := cache.nodes[nodeName]
0000000000000000000000000000000000000000;;				deepEqualWithoutGeneration(t, i, n, tt.wNodeInfo[i-1])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestRemovePod tests after added pod is removed, its information should also be subtracted.
0000000000000000000000000000000000000000;;	func TestRemovePod(t *testing.T) {
0000000000000000000000000000000000000000;;		nodeName := "node"
0000000000000000000000000000000000000000;;		basePod := makeBasePod(nodeName, "test", "100m", "500", []v1.ContainerPort{{HostPort: 80}})
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod       *v1.Pod
0000000000000000000000000000000000000000;;			wNodeInfo *NodeInfo
0000000000000000000000000000000000000000;;		}{{
0000000000000000000000000000000000000000;;			pod: basePod,
0000000000000000000000000000000000000000;;			wNodeInfo: &NodeInfo{
0000000000000000000000000000000000000000;;				requestedResource: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 100,
0000000000000000000000000000000000000000;;					Memory:   500,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nonzeroRequest: &Resource{
0000000000000000000000000000000000000000;;					MilliCPU: 100,
0000000000000000000000000000000000000000;;					Memory:   500,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				allocatableResource: &Resource{},
0000000000000000000000000000000000000000;;				pods:                []*v1.Pod{basePod},
0000000000000000000000000000000000000000;;				usedPorts:           map[int]bool{80: true},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			cache := newSchedulerCache(time.Second, time.Second, nil)
0000000000000000000000000000000000000000;;			if err := cache.AddPod(tt.pod); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("AddPod failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n := cache.nodes[nodeName]
0000000000000000000000000000000000000000;;			deepEqualWithoutGeneration(t, i, n, tt.wNodeInfo)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := cache.RemovePod(tt.pod); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("RemovePod failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			n = cache.nodes[nodeName]
0000000000000000000000000000000000000000;;			if n != nil {
0000000000000000000000000000000000000000;;				t.Errorf("#%d: expecting pod deleted and nil node info, get=%s", i, n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestForgetPod(t *testing.T) {
0000000000000000000000000000000000000000;;		nodeName := "node"
0000000000000000000000000000000000000000;;		basePod := makeBasePod(nodeName, "test", "100m", "500", []v1.ContainerPort{{HostPort: 80}})
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pods []*v1.Pod
0000000000000000000000000000000000000000;;		}{{
0000000000000000000000000000000000000000;;			pods: []*v1.Pod{basePod},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		ttl := 10 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			cache := newSchedulerCache(ttl, time.Second, nil)
0000000000000000000000000000000000000000;;			for _, pod := range tt.pods {
0000000000000000000000000000000000000000;;				if err := assumeAndFinishBinding(cache, pod, now); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("assumePod failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, pod := range tt.pods {
0000000000000000000000000000000000000000;;				if err := cache.ForgetPod(pod); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("ForgetPod failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cache.cleanupAssumedPods(now.Add(2 * ttl))
0000000000000000000000000000000000000000;;			if n := cache.nodes[nodeName]; n != nil {
0000000000000000000000000000000000000000;;				t.Errorf("#%d: expecting pod deleted and nil node info, get=%s", i, n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getResourceRequest returns the resource request of all containers in Pods;
0000000000000000000000000000000000000000;;	// excuding initContainers.
0000000000000000000000000000000000000000;;	func getResourceRequest(pod *v1.Pod) v1.ResourceList {
0000000000000000000000000000000000000000;;		result := &Resource{}
0000000000000000000000000000000000000000;;		for _, container := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			result.Add(container.Resources.Requests)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result.ResourceList()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildNodeInfo creates a NodeInfo by simulating node operations in cache.
0000000000000000000000000000000000000000;;	func buildNodeInfo(node *v1.Node, pods []*v1.Pod) *NodeInfo {
0000000000000000000000000000000000000000;;		expected := NewNodeInfo()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Simulate SetNode.
0000000000000000000000000000000000000000;;		expected.node = node
0000000000000000000000000000000000000000;;		expected.allocatableResource = NewResource(node.Status.Allocatable)
0000000000000000000000000000000000000000;;		expected.taints = node.Spec.Taints
0000000000000000000000000000000000000000;;		expected.generation++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			// Simulate AddPod
0000000000000000000000000000000000000000;;			expected.pods = append(expected.pods, pod)
0000000000000000000000000000000000000000;;			expected.requestedResource.Add(getResourceRequest(pod))
0000000000000000000000000000000000000000;;			expected.nonzeroRequest.Add(getResourceRequest(pod))
0000000000000000000000000000000000000000;;			expected.usedPorts = schedutil.GetUsedPorts(pod)
0000000000000000000000000000000000000000;;			expected.generation++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return expected
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestNodeOperators tests node operations of cache, including add, update
0000000000000000000000000000000000000000;;	// and remove.
0000000000000000000000000000000000000000;;	func TestNodeOperators(t *testing.T) {
0000000000000000000000000000000000000000;;		// Test datas
0000000000000000000000000000000000000000;;		nodeName := "test-node"
0000000000000000000000000000000000000000;;		cpu_1 := resource.MustParse("1000m")
0000000000000000000000000000000000000000;;		mem_100m := resource.MustParse("100m")
0000000000000000000000000000000000000000;;		cpu_half := resource.MustParse("500m")
0000000000000000000000000000000000000000;;		mem_50m := resource.MustParse("50m")
0000000000000000000000000000000000000000;;		resourceFooName := "pod.alpha.kubernetes.io/opaque-int-resource-foo"
0000000000000000000000000000000000000000;;		resourceFoo := resource.MustParse("1")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			node *v1.Node
0000000000000000000000000000000000000000;;			pods []*v1.Pod
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: nodeName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;						Allocatable: v1.ResourceList{
0000000000000000000000000000000000000000;;							v1.ResourceCPU:                   cpu_1,
0000000000000000000000000000000000000000;;							v1.ResourceMemory:                mem_100m,
0000000000000000000000000000000000000000;;							v1.ResourceName(resourceFooName): resourceFoo,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;						Taints: []v1.Taint{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Key:    "test-key",
0000000000000000000000000000000000000000;;								Value:  "test-value",
0000000000000000000000000000000000000000;;								Effect: v1.TaintEffectPreferNoSchedule,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name: "pod1",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;							NodeName: nodeName,
0000000000000000000000000000000000000000;;							Containers: []v1.Container{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;										Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;											v1.ResourceCPU:    cpu_half,
0000000000000000000000000000000000000000;;											v1.ResourceMemory: mem_50m,
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									Ports: []v1.ContainerPort{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											Name:          "http",
0000000000000000000000000000000000000000;;											HostPort:      80,
0000000000000000000000000000000000000000;;											ContainerPort: 80,
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: nodeName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;						Allocatable: v1.ResourceList{
0000000000000000000000000000000000000000;;							v1.ResourceCPU:                   cpu_1,
0000000000000000000000000000000000000000;;							v1.ResourceMemory:                mem_100m,
0000000000000000000000000000000000000000;;							v1.ResourceName(resourceFooName): resourceFoo,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;						Taints: []v1.Taint{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Key:    "test-key",
0000000000000000000000000000000000000000;;								Value:  "test-value",
0000000000000000000000000000000000000000;;								Effect: v1.TaintEffectPreferNoSchedule,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pods: []*v1.Pod{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name: "pod1",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;							NodeName: nodeName,
0000000000000000000000000000000000000000;;							Containers: []v1.Container{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;										Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;											v1.ResourceCPU:    cpu_half,
0000000000000000000000000000000000000000;;											v1.ResourceMemory: mem_50m,
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name: "pod2",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;							NodeName: nodeName,
0000000000000000000000000000000000000000;;							Containers: []v1.Container{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;										Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;											v1.ResourceCPU:    cpu_half,
0000000000000000000000000000000000000000;;											v1.ResourceMemory: mem_50m,
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			expected := buildNodeInfo(test.node, test.pods)
0000000000000000000000000000000000000000;;			node := test.node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cache := newSchedulerCache(time.Second, time.Second, nil)
0000000000000000000000000000000000000000;;			cache.AddNode(node)
0000000000000000000000000000000000000000;;			for _, pod := range test.pods {
0000000000000000000000000000000000000000;;				cache.AddPod(pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Case 1: the node was added into cache successfully.
0000000000000000000000000000000000000000;;			got, found := cache.nodes[node.Name]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				t.Errorf("Failed to find node %v in schedulercache.", node.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(got, expected) {
0000000000000000000000000000000000000000;;				t.Errorf("Failed to add node into schedulercache:\n got: %+v \nexpected: %+v", got, expected)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Case 2: dump cached nodes successfully.
0000000000000000000000000000000000000000;;			cachedNodes := map[string]*NodeInfo{}
0000000000000000000000000000000000000000;;			cache.UpdateNodeNameToInfoMap(cachedNodes)
0000000000000000000000000000000000000000;;			newNode, found := cachedNodes[node.Name]
0000000000000000000000000000000000000000;;			if !found || len(cachedNodes) != 1 {
0000000000000000000000000000000000000000;;				t.Errorf("failed to dump cached nodes:\n got: %v \nexpected: %v", cachedNodes, cache.nodes)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(newNode, expected) {
0000000000000000000000000000000000000000;;				t.Errorf("Failed to clone node:\n got: %+v, \n expected: %+v", newNode, expected)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Case 3: update node attribute successfully.
0000000000000000000000000000000000000000;;			node.Status.Allocatable[v1.ResourceMemory] = mem_50m
0000000000000000000000000000000000000000;;			expected.allocatableResource.Memory = mem_50m.Value()
0000000000000000000000000000000000000000;;			expected.generation++
0000000000000000000000000000000000000000;;			cache.UpdateNode(nil, node)
0000000000000000000000000000000000000000;;			got, found = cache.nodes[node.Name]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				t.Errorf("Failed to find node %v in schedulercache after UpdateNode.", node.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(got, expected) {
0000000000000000000000000000000000000000;;				t.Errorf("Failed to update node in schedulercache:\n got: %+v \nexpected: %+v", got, expected)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Case 4: the node can not be removed if pods is not empty.
0000000000000000000000000000000000000000;;			cache.RemoveNode(node)
0000000000000000000000000000000000000000;;			if _, found := cache.nodes[node.Name]; !found {
0000000000000000000000000000000000000000;;				t.Errorf("The node %v should not be removed if pods is not empty.", node.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkList1kNodes30kPods(b *testing.B) {
0000000000000000000000000000000000000000;;		cache := setupCacheOf1kNodes30kPods(b)
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for n := 0; n < b.N; n++ {
0000000000000000000000000000000000000000;;			cache.List(labels.Everything())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkExpire100Pods(b *testing.B) {
0000000000000000000000000000000000000000;;		benchmarkExpire(b, 100)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkExpire1kPods(b *testing.B) {
0000000000000000000000000000000000000000;;		benchmarkExpire(b, 1000)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkExpire10kPods(b *testing.B) {
0000000000000000000000000000000000000000;;		benchmarkExpire(b, 10000)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func benchmarkExpire(b *testing.B, podNum int) {
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		for n := 0; n < b.N; n++ {
0000000000000000000000000000000000000000;;			b.StopTimer()
0000000000000000000000000000000000000000;;			cache := setupCacheWithAssumedPods(b, podNum, now)
0000000000000000000000000000000000000000;;			b.StartTimer()
0000000000000000000000000000000000000000;;			cache.cleanupAssumedPods(now.Add(2 * time.Second))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeBasePod(nodeName, objName, cpu, mem string, ports []v1.ContainerPort) *v1.Pod {
0000000000000000000000000000000000000000;;		req := v1.ResourceList{}
0000000000000000000000000000000000000000;;		if cpu != "" {
0000000000000000000000000000000000000000;;			req = v1.ResourceList{
0000000000000000000000000000000000000000;;				v1.ResourceCPU:    resource.MustParse(cpu),
0000000000000000000000000000000000000000;;				v1.ResourceMemory: resource.MustParse(mem),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: "node_info_cache_test",
0000000000000000000000000000000000000000;;				Name:      objName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{{
0000000000000000000000000000000000000000;;					Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;						Requests: req,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Ports: ports,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				NodeName: nodeName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setupCacheOf1kNodes30kPods(b *testing.B) Cache {
0000000000000000000000000000000000000000;;		cache := newSchedulerCache(time.Second, time.Second, nil)
0000000000000000000000000000000000000000;;		for i := 0; i < 1000; i++ {
0000000000000000000000000000000000000000;;			nodeName := fmt.Sprintf("node-%d", i)
0000000000000000000000000000000000000000;;			for j := 0; j < 30; j++ {
0000000000000000000000000000000000000000;;				objName := fmt.Sprintf("%s-pod-%d", nodeName, j)
0000000000000000000000000000000000000000;;				pod := makeBasePod(nodeName, objName, "0", "0", nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := cache.AddPod(pod); err != nil {
0000000000000000000000000000000000000000;;					b.Fatalf("AddPod failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cache
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setupCacheWithAssumedPods(b *testing.B, podNum int, assumedTime time.Time) *schedulerCache {
0000000000000000000000000000000000000000;;		cache := newSchedulerCache(time.Second, time.Second, nil)
0000000000000000000000000000000000000000;;		for i := 0; i < podNum; i++ {
0000000000000000000000000000000000000000;;			nodeName := fmt.Sprintf("node-%d", i/10)
0000000000000000000000000000000000000000;;			objName := fmt.Sprintf("%s-pod-%d", nodeName, i%10)
0000000000000000000000000000000000000000;;			pod := makeBasePod(nodeName, objName, "0", "0", nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := assumeAndFinishBinding(cache, pod, assumedTime)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.Fatalf("assumePod failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cache
0000000000000000000000000000000000000000;;	}
