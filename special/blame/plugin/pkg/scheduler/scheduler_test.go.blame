0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
c8eb0c0f6b1c2ebd7c2e9f2da2e82b1e23ce59c2;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package scheduler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		clientcache "k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm/predicates"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/core"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/schedulercache"
0000000000000000000000000000000000000000;;		schedulertesting "k8s.io/kubernetes/plugin/pkg/scheduler/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeBinder struct {
0000000000000000000000000000000000000000;;		b func(binding *v1.Binding) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fb fakeBinder) Bind(binding *v1.Binding) error { return fb.b(binding) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakePodConditionUpdater struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fc fakePodConditionUpdater) Update(pod *v1.Pod, podCondition *v1.PodCondition) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func podWithID(id, desiredHost string) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: id, SelfLink: util.Test.SelfLink("pods", id)},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				NodeName: desiredHost,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deletingPod(id string) *v1.Pod {
0000000000000000000000000000000000000000;;		deletionTimestamp := metav1.Now()
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: id, SelfLink: util.Test.SelfLink("pods", id), DeletionTimestamp: &deletionTimestamp},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				NodeName: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func podWithPort(id, desiredHost string, port int) *v1.Pod {
0000000000000000000000000000000000000000;;		pod := podWithID(id, desiredHost)
0000000000000000000000000000000000000000;;		pod.Spec.Containers = []v1.Container{
0000000000000000000000000000000000000000;;			{Name: "ctr", Ports: []v1.ContainerPort{{HostPort: int32(port)}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func podWithResources(id, desiredHost string, limits v1.ResourceList, requests v1.ResourceList) *v1.Pod {
0000000000000000000000000000000000000000;;		pod := podWithID(id, desiredHost)
0000000000000000000000000000000000000000;;		pod.Spec.Containers = []v1.Container{
0000000000000000000000000000000000000000;;			{Name: "ctr", Resources: v1.ResourceRequirements{Limits: limits, Requests: requests}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mockScheduler struct {
0000000000000000000000000000000000000000;;		machine string
0000000000000000000000000000000000000000;;		err     error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (es mockScheduler) Schedule(pod *v1.Pod, ml algorithm.NodeLister) (string, error) {
0000000000000000000000000000000000000000;;		return es.machine, es.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (es mockScheduler) Predicates() map[string]algorithm.FitPredicate {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (es mockScheduler) Prioritizers() []algorithm.PriorityConfig {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScheduler(t *testing.T) {
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(t.Logf).Stop()
0000000000000000000000000000000000000000;;		errS := errors.New("scheduler")
0000000000000000000000000000000000000000;;		errB := errors.New("binder")
0000000000000000000000000000000000000000;;		testNode := v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "machine1"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			injectBindError  error
0000000000000000000000000000000000000000;;			sendPod          *v1.Pod
0000000000000000000000000000000000000000;;			algo             algorithm.ScheduleAlgorithm
0000000000000000000000000000000000000000;;			expectErrorPod   *v1.Pod
0000000000000000000000000000000000000000;;			expectAssumedPod *v1.Pod
0000000000000000000000000000000000000000;;			expectError      error
0000000000000000000000000000000000000000;;			expectBind       *v1.Binding
0000000000000000000000000000000000000000;;			eventReason      string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				sendPod:          podWithID("foo", ""),
0000000000000000000000000000000000000000;;				algo:             mockScheduler{testNode.Name, nil},
0000000000000000000000000000000000000000;;				expectBind:       &v1.Binding{ObjectMeta: metav1.ObjectMeta{Name: "foo"}, Target: v1.ObjectReference{Kind: "Node", Name: testNode.Name}},
0000000000000000000000000000000000000000;;				expectAssumedPod: podWithID("foo", testNode.Name),
0000000000000000000000000000000000000000;;				eventReason:      "Scheduled",
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				sendPod:        podWithID("foo", ""),
0000000000000000000000000000000000000000;;				algo:           mockScheduler{testNode.Name, errS},
0000000000000000000000000000000000000000;;				expectError:    errS,
0000000000000000000000000000000000000000;;				expectErrorPod: podWithID("foo", ""),
0000000000000000000000000000000000000000;;				eventReason:    "FailedScheduling",
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				sendPod:          podWithID("foo", ""),
0000000000000000000000000000000000000000;;				algo:             mockScheduler{testNode.Name, nil},
0000000000000000000000000000000000000000;;				expectBind:       &v1.Binding{ObjectMeta: metav1.ObjectMeta{Name: "foo"}, Target: v1.ObjectReference{Kind: "Node", Name: testNode.Name}},
0000000000000000000000000000000000000000;;				expectAssumedPod: podWithID("foo", testNode.Name),
0000000000000000000000000000000000000000;;				injectBindError:  errB,
0000000000000000000000000000000000000000;;				expectError:      errB,
0000000000000000000000000000000000000000;;				expectErrorPod:   podWithID("foo", ""),
0000000000000000000000000000000000000000;;				eventReason:      "FailedScheduling",
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				sendPod:     deletingPod("foo"),
0000000000000000000000000000000000000000;;				algo:        mockScheduler{"", nil},
0000000000000000000000000000000000000000;;				eventReason: "FailedScheduling",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, item := range table {
0000000000000000000000000000000000000000;;			var gotError error
0000000000000000000000000000000000000000;;			var gotPod *v1.Pod
0000000000000000000000000000000000000000;;			var gotAssumedPod *v1.Pod
0000000000000000000000000000000000000000;;			var gotBinding *v1.Binding
0000000000000000000000000000000000000000;;			configurator := &FakeConfigurator{
0000000000000000000000000000000000000000;;				Config: &Config{
0000000000000000000000000000000000000000;;					SchedulerCache: &schedulertesting.FakeCache{
0000000000000000000000000000000000000000;;						AssumeFunc: func(pod *v1.Pod) {
0000000000000000000000000000000000000000;;							gotAssumedPod = pod
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					NodeLister: schedulertesting.FakeNodeLister(
0000000000000000000000000000000000000000;;						[]*v1.Node{&testNode},
0000000000000000000000000000000000000000;;					),
0000000000000000000000000000000000000000;;					Algorithm: item.algo,
0000000000000000000000000000000000000000;;					Binder: fakeBinder{func(b *v1.Binding) error {
0000000000000000000000000000000000000000;;						gotBinding = b
0000000000000000000000000000000000000000;;						return item.injectBindError
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;					PodConditionUpdater: fakePodConditionUpdater{},
0000000000000000000000000000000000000000;;					Error: func(p *v1.Pod, err error) {
0000000000000000000000000000000000000000;;						gotPod = p
0000000000000000000000000000000000000000;;						gotError = err
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					NextPod: func() *v1.Pod {
0000000000000000000000000000000000000000;;						return item.sendPod
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Recorder: eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "scheduler"}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s, _ := NewFromConfigurator(configurator, nil...)
0000000000000000000000000000000000000000;;			called := make(chan struct{})
0000000000000000000000000000000000000000;;			events := eventBroadcaster.StartEventWatcher(func(e *clientv1.Event) {
0000000000000000000000000000000000000000;;				if e, a := item.eventReason, e.Reason; e != a {
0000000000000000000000000000000000000000;;					t.Errorf("%v: expected %v, got %v", i, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				close(called)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			s.scheduleOne()
0000000000000000000000000000000000000000;;			<-called
0000000000000000000000000000000000000000;;			if e, a := item.expectAssumedPod, gotAssumedPod; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("%v: assumed pod: wanted %v, got %v", i, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := item.expectErrorPod, gotPod; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("%v: error pod: wanted %v, got %v", i, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := item.expectError, gotError; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("%v: error: wanted %v, got %v", i, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := item.expectBind, gotBinding; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("%v: error: %s", i, diff.ObjectDiff(e, a))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			events.Stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSchedulerNoPhantomPodAfterExpire(t *testing.T) {
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stop)
0000000000000000000000000000000000000000;;		queuedPodStore := clientcache.NewFIFO(clientcache.MetaNamespaceKeyFunc)
0000000000000000000000000000000000000000;;		scache := schedulercache.New(100*time.Millisecond, stop)
0000000000000000000000000000000000000000;;		pod := podWithPort("pod.Name", "", 8080)
0000000000000000000000000000000000000000;;		node := v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "machine1"}}
0000000000000000000000000000000000000000;;		scache.AddNode(&node)
0000000000000000000000000000000000000000;;		nodeLister := schedulertesting.FakeNodeLister([]*v1.Node{&node})
0000000000000000000000000000000000000000;;		predicateMap := map[string]algorithm.FitPredicate{"PodFitsHostPorts": predicates.PodFitsHostPorts}
0000000000000000000000000000000000000000;;		scheduler, bindingChan, _ := setupTestSchedulerWithOnePodOnNode(t, queuedPodStore, scache, nodeLister, predicateMap, pod, &node)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitPodExpireChan := make(chan struct{})
0000000000000000000000000000000000000000;;		timeout := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-timeout:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pods, err := scache.List(labels.Everything())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("cache.List failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(pods) == 0 {
0000000000000000000000000000000000000000;;					close(waitPodExpireChan)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				time.Sleep(100 * time.Millisecond)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		// waiting for the assumed pod to expire
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-waitPodExpireChan:
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			close(timeout)
0000000000000000000000000000000000000000;;			t.Fatalf("timeout after %v", wait.ForeverTestTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We use conflicted pod ports to incur fit predicate failure if first pod not removed.
0000000000000000000000000000000000000000;;		secondPod := podWithPort("bar", "", 8080)
0000000000000000000000000000000000000000;;		queuedPodStore.Add(secondPod)
0000000000000000000000000000000000000000;;		scheduler.scheduleOne()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case b := <-bindingChan:
0000000000000000000000000000000000000000;;			expectBinding := &v1.Binding{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "bar"},
0000000000000000000000000000000000000000;;				Target:     v1.ObjectReference{Kind: "Node", Name: node.Name},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(expectBinding, b) {
0000000000000000000000000000000000000000;;				t.Errorf("binding want=%v, get=%v", expectBinding, b)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Fatalf("timeout after %v", wait.ForeverTestTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSchedulerNoPhantomPodAfterDelete(t *testing.T) {
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stop)
0000000000000000000000000000000000000000;;		queuedPodStore := clientcache.NewFIFO(clientcache.MetaNamespaceKeyFunc)
0000000000000000000000000000000000000000;;		scache := schedulercache.New(10*time.Minute, stop)
0000000000000000000000000000000000000000;;		firstPod := podWithPort("pod.Name", "", 8080)
0000000000000000000000000000000000000000;;		node := v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "machine1"}}
0000000000000000000000000000000000000000;;		scache.AddNode(&node)
0000000000000000000000000000000000000000;;		nodeLister := schedulertesting.FakeNodeLister([]*v1.Node{&node})
0000000000000000000000000000000000000000;;		predicateMap := map[string]algorithm.FitPredicate{"PodFitsHostPorts": predicates.PodFitsHostPorts}
0000000000000000000000000000000000000000;;		scheduler, bindingChan, errChan := setupTestSchedulerWithOnePodOnNode(t, queuedPodStore, scache, nodeLister, predicateMap, firstPod, &node)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We use conflicted pod ports to incur fit predicate failure.
0000000000000000000000000000000000000000;;		secondPod := podWithPort("bar", "", 8080)
0000000000000000000000000000000000000000;;		queuedPodStore.Add(secondPod)
0000000000000000000000000000000000000000;;		// queuedPodStore: [bar:8080]
0000000000000000000000000000000000000000;;		// cache: [(assumed)foo:8080]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scheduler.scheduleOne()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case err := <-errChan:
0000000000000000000000000000000000000000;;			expectErr := &core.FitError{
0000000000000000000000000000000000000000;;				Pod:              secondPod,
0000000000000000000000000000000000000000;;				FailedPredicates: core.FailedPredicateMap{node.Name: []algorithm.PredicateFailureReason{predicates.ErrPodNotFitsHostPorts}},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(expectErr, err) {
0000000000000000000000000000000000000000;;				t.Errorf("err want=%v, get=%v", expectErr, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Fatalf("timeout after %v", wait.ForeverTestTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We mimic the workflow of cache behavior when a pod is removed by user.
0000000000000000000000000000000000000000;;		// Note: if the schedulercache timeout would be super short, the first pod would expire
0000000000000000000000000000000000000000;;		// and would be removed itself (without any explicit actions on schedulercache). Even in that case,
0000000000000000000000000000000000000000;;		// explicitly AddPod will as well correct the behavior.
0000000000000000000000000000000000000000;;		firstPod.Spec.NodeName = node.Name
0000000000000000000000000000000000000000;;		if err := scache.AddPod(firstPod); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("err: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := scache.RemovePod(firstPod); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("err: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		queuedPodStore.Add(secondPod)
0000000000000000000000000000000000000000;;		scheduler.scheduleOne()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case b := <-bindingChan:
0000000000000000000000000000000000000000;;			expectBinding := &v1.Binding{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "bar"},
0000000000000000000000000000000000000000;;				Target:     v1.ObjectReference{Kind: "Node", Name: node.Name},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(expectBinding, b) {
0000000000000000000000000000000000000000;;				t.Errorf("binding want=%v, get=%v", expectBinding, b)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Fatalf("timeout after %v", wait.ForeverTestTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scheduler should preserve predicate constraint even if binding was longer
0000000000000000000000000000000000000000;;	// than cache ttl
0000000000000000000000000000000000000000;;	func TestSchedulerErrorWithLongBinding(t *testing.T) {
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		firstPod := podWithPort("foo", "", 8080)
0000000000000000000000000000000000000000;;		conflictPod := podWithPort("bar", "", 8080)
0000000000000000000000000000000000000000;;		pods := map[string]*v1.Pod{firstPod.Name: firstPod, conflictPod.Name: conflictPod}
0000000000000000000000000000000000000000;;		for _, test := range []struct {
0000000000000000000000000000000000000000;;			Expected        map[string]bool
0000000000000000000000000000000000000000;;			CacheTTL        time.Duration
0000000000000000000000000000000000000000;;			BindingDuration time.Duration
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Expected:        map[string]bool{firstPod.Name: true},
0000000000000000000000000000000000000000;;				CacheTTL:        100 * time.Millisecond,
0000000000000000000000000000000000000000;;				BindingDuration: 300 * time.Millisecond,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Expected:        map[string]bool{firstPod.Name: true},
0000000000000000000000000000000000000000;;				CacheTTL:        10 * time.Second,
0000000000000000000000000000000000000000;;				BindingDuration: 300 * time.Millisecond,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			queuedPodStore := clientcache.NewFIFO(clientcache.MetaNamespaceKeyFunc)
0000000000000000000000000000000000000000;;			scache := schedulercache.New(test.CacheTTL, stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			node := v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "machine1"}}
0000000000000000000000000000000000000000;;			scache.AddNode(&node)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nodeLister := schedulertesting.FakeNodeLister([]*v1.Node{&node})
0000000000000000000000000000000000000000;;			predicateMap := map[string]algorithm.FitPredicate{"PodFitsHostPorts": predicates.PodFitsHostPorts}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			scheduler, bindingChan := setupTestSchedulerLongBindingWithRetry(
0000000000000000000000000000000000000000;;				queuedPodStore, scache, nodeLister, predicateMap, stop, test.BindingDuration)
0000000000000000000000000000000000000000;;			scheduler.Run()
0000000000000000000000000000000000000000;;			queuedPodStore.Add(firstPod)
0000000000000000000000000000000000000000;;			queuedPodStore.Add(conflictPod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resultBindings := map[string]bool{}
0000000000000000000000000000000000000000;;			waitChan := time.After(5 * time.Second)
0000000000000000000000000000000000000000;;			for finished := false; !finished; {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case b := <-bindingChan:
0000000000000000000000000000000000000000;;					resultBindings[b.Name] = true
0000000000000000000000000000000000000000;;					p := pods[b.Name]
0000000000000000000000000000000000000000;;					p.Spec.NodeName = b.Target.Name
0000000000000000000000000000000000000000;;					scache.AddPod(p)
0000000000000000000000000000000000000000;;				case <-waitChan:
0000000000000000000000000000000000000000;;					finished = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(resultBindings, test.Expected) {
0000000000000000000000000000000000000000;;				t.Errorf("Result binding are not equal to expected. %v != %v", resultBindings, test.Expected)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// queuedPodStore: pods queued before processing.
0000000000000000000000000000000000000000;;	// cache: scheduler cache that might contain assumed pods.
0000000000000000000000000000000000000000;;	func setupTestSchedulerWithOnePodOnNode(t *testing.T, queuedPodStore *clientcache.FIFO, scache schedulercache.Cache,
0000000000000000000000000000000000000000;;		nodeLister schedulertesting.FakeNodeLister, predicateMap map[string]algorithm.FitPredicate, pod *v1.Pod, node *v1.Node) (*Scheduler, chan *v1.Binding, chan error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scheduler, bindingChan, errChan := setupTestScheduler(queuedPodStore, scache, nodeLister, predicateMap)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		queuedPodStore.Add(pod)
0000000000000000000000000000000000000000;;		// queuedPodStore: [foo:8080]
0000000000000000000000000000000000000000;;		// cache: []
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scheduler.scheduleOne()
0000000000000000000000000000000000000000;;		// queuedPodStore: []
0000000000000000000000000000000000000000;;		// cache: [(assumed)foo:8080]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case b := <-bindingChan:
0000000000000000000000000000000000000000;;			expectBinding := &v1.Binding{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: pod.Name},
0000000000000000000000000000000000000000;;				Target:     v1.ObjectReference{Kind: "Node", Name: node.Name},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(expectBinding, b) {
0000000000000000000000000000000000000000;;				t.Errorf("binding want=%v, get=%v", expectBinding, b)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Fatalf("timeout after %v", wait.ForeverTestTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return scheduler, bindingChan, errChan
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSchedulerFailedSchedulingReasons(t *testing.T) {
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stop)
0000000000000000000000000000000000000000;;		queuedPodStore := clientcache.NewFIFO(clientcache.MetaNamespaceKeyFunc)
0000000000000000000000000000000000000000;;		scache := schedulercache.New(10*time.Minute, stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Design the baseline for the pods, and we will make nodes that dont fit it later.
0000000000000000000000000000000000000000;;		var cpu = int64(4)
0000000000000000000000000000000000000000;;		var mem = int64(500)
0000000000000000000000000000000000000000;;		podWithTooBigResourceRequests := podWithResources("bar", "", v1.ResourceList{
0000000000000000000000000000000000000000;;			v1.ResourceCPU:    *(resource.NewQuantity(cpu, resource.DecimalSI)),
0000000000000000000000000000000000000000;;			v1.ResourceMemory: *(resource.NewQuantity(mem, resource.DecimalSI)),
0000000000000000000000000000000000000000;;		}, v1.ResourceList{
0000000000000000000000000000000000000000;;			v1.ResourceCPU:    *(resource.NewQuantity(cpu, resource.DecimalSI)),
0000000000000000000000000000000000000000;;			v1.ResourceMemory: *(resource.NewQuantity(mem, resource.DecimalSI)),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create several nodes which cannot schedule the above pod
0000000000000000000000000000000000000000;;		nodes := []*v1.Node{}
0000000000000000000000000000000000000000;;		for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;			node := v1.Node{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: fmt.Sprintf("machine%v", i)},
0000000000000000000000000000000000000000;;				Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;					Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceCPU:    *(resource.NewQuantity(cpu/2, resource.DecimalSI)),
0000000000000000000000000000000000000000;;						v1.ResourceMemory: *(resource.NewQuantity(mem/5, resource.DecimalSI)),
0000000000000000000000000000000000000000;;						v1.ResourcePods:   *(resource.NewQuantity(10, resource.DecimalSI)),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Allocatable: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceCPU:    *(resource.NewQuantity(cpu/2, resource.DecimalSI)),
0000000000000000000000000000000000000000;;						v1.ResourceMemory: *(resource.NewQuantity(mem/5, resource.DecimalSI)),
0000000000000000000000000000000000000000;;						v1.ResourcePods:   *(resource.NewQuantity(10, resource.DecimalSI)),
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			scache.AddNode(&node)
0000000000000000000000000000000000000000;;			nodes = append(nodes, &node)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeLister := schedulertesting.FakeNodeLister(nodes)
0000000000000000000000000000000000000000;;		predicateMap := map[string]algorithm.FitPredicate{
0000000000000000000000000000000000000000;;			"PodFitsResources": predicates.PodFitsResources,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create expected failure reasons for all the nodes.  Hopefully they will get rolled up into a non-spammy summary.
0000000000000000000000000000000000000000;;		failedPredicatesMap := core.FailedPredicateMap{}
0000000000000000000000000000000000000000;;		for _, node := range nodes {
0000000000000000000000000000000000000000;;			failedPredicatesMap[node.Name] = []algorithm.PredicateFailureReason{
0000000000000000000000000000000000000000;;				predicates.NewInsufficientResourceError(v1.ResourceCPU, 4000, 0, 2000),
0000000000000000000000000000000000000000;;				predicates.NewInsufficientResourceError(v1.ResourceMemory, 500, 0, 100),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		scheduler, _, errChan := setupTestScheduler(queuedPodStore, scache, nodeLister, predicateMap)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		queuedPodStore.Add(podWithTooBigResourceRequests)
0000000000000000000000000000000000000000;;		scheduler.scheduleOne()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case err := <-errChan:
0000000000000000000000000000000000000000;;			expectErr := &core.FitError{
0000000000000000000000000000000000000000;;				Pod:              podWithTooBigResourceRequests,
0000000000000000000000000000000000000000;;				FailedPredicates: failedPredicatesMap,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(fmt.Sprint(expectErr)) > 150 {
0000000000000000000000000000000000000000;;				t.Errorf("message is too spammy ! %v ", len(fmt.Sprint(expectErr)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(expectErr, err) {
0000000000000000000000000000000000000000;;				t.Errorf("\n err \nWANT=%+v,\nGOT=%+v", expectErr, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Fatalf("timeout after %v", wait.ForeverTestTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// queuedPodStore: pods queued before processing.
0000000000000000000000000000000000000000;;	// scache: scheduler cache that might contain assumed pods.
0000000000000000000000000000000000000000;;	func setupTestScheduler(queuedPodStore *clientcache.FIFO, scache schedulercache.Cache, nodeLister schedulertesting.FakeNodeLister, predicateMap map[string]algorithm.FitPredicate) (*Scheduler, chan *v1.Binding, chan error) {
0000000000000000000000000000000000000000;;		algo := core.NewGenericScheduler(
0000000000000000000000000000000000000000;;			scache,
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;			predicateMap,
0000000000000000000000000000000000000000;;			algorithm.EmptyMetadataProducer,
0000000000000000000000000000000000000000;;			[]algorithm.PriorityConfig{},
0000000000000000000000000000000000000000;;			algorithm.EmptyMetadataProducer,
0000000000000000000000000000000000000000;;			[]algorithm.SchedulerExtender{})
0000000000000000000000000000000000000000;;		bindingChan := make(chan *v1.Binding, 1)
0000000000000000000000000000000000000000;;		errChan := make(chan error, 1)
0000000000000000000000000000000000000000;;		configurator := &FakeConfigurator{
0000000000000000000000000000000000000000;;			Config: &Config{
0000000000000000000000000000000000000000;;				SchedulerCache: scache,
0000000000000000000000000000000000000000;;				NodeLister:     nodeLister,
0000000000000000000000000000000000000000;;				Algorithm:      algo,
0000000000000000000000000000000000000000;;				Binder: fakeBinder{func(b *v1.Binding) error {
0000000000000000000000000000000000000000;;					bindingChan <- b
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				NextPod: func() *v1.Pod {
0000000000000000000000000000000000000000;;					return clientcache.Pop(queuedPodStore).(*v1.Pod)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Error: func(p *v1.Pod, err error) {
0000000000000000000000000000000000000000;;					errChan <- err
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Recorder:            &record.FakeRecorder{},
0000000000000000000000000000000000000000;;				PodConditionUpdater: fakePodConditionUpdater{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sched, _ := NewFromConfigurator(configurator, nil...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sched, bindingChan, errChan
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setupTestSchedulerLongBindingWithRetry(queuedPodStore *clientcache.FIFO, scache schedulercache.Cache, nodeLister schedulertesting.FakeNodeLister, predicateMap map[string]algorithm.FitPredicate, stop chan struct{}, bindingTime time.Duration) (*Scheduler, chan *v1.Binding) {
0000000000000000000000000000000000000000;;		algo := core.NewGenericScheduler(
0000000000000000000000000000000000000000;;			scache,
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;			predicateMap,
0000000000000000000000000000000000000000;;			algorithm.EmptyMetadataProducer,
0000000000000000000000000000000000000000;;			[]algorithm.PriorityConfig{},
0000000000000000000000000000000000000000;;			algorithm.EmptyMetadataProducer,
0000000000000000000000000000000000000000;;			[]algorithm.SchedulerExtender{})
0000000000000000000000000000000000000000;;		bindingChan := make(chan *v1.Binding, 2)
0000000000000000000000000000000000000000;;		configurator := &FakeConfigurator{
0000000000000000000000000000000000000000;;			Config: &Config{
0000000000000000000000000000000000000000;;				SchedulerCache: scache,
0000000000000000000000000000000000000000;;				NodeLister:     nodeLister,
0000000000000000000000000000000000000000;;				Algorithm:      algo,
0000000000000000000000000000000000000000;;				Binder: fakeBinder{func(b *v1.Binding) error {
0000000000000000000000000000000000000000;;					time.Sleep(bindingTime)
0000000000000000000000000000000000000000;;					bindingChan <- b
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				WaitForCacheSync: func() bool {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				NextPod: func() *v1.Pod {
0000000000000000000000000000000000000000;;					return clientcache.Pop(queuedPodStore).(*v1.Pod)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Error: func(p *v1.Pod, err error) {
0000000000000000000000000000000000000000;;					queuedPodStore.AddIfNotPresent(p)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Recorder:            &record.FakeRecorder{},
0000000000000000000000000000000000000000;;				PodConditionUpdater: fakePodConditionUpdater{},
0000000000000000000000000000000000000000;;				StopEverything:      stop,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sched, _ := NewFromConfigurator(configurator, nil...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sched, bindingChan
0000000000000000000000000000000000000000;;	}
