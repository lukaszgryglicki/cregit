0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
9cbd106cb4cbbc8ff46b7aac17f7a48d678a6c21;plugin/pkg/scheduler/server/server.go[plugin/pkg/scheduler/server/server.go][plugin/cmd/kube-scheduler/app/server.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package app implements a Server object for running the scheduler.
0000000000000000000000000000000000000000;;	package app
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/pprof"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		goruntime "runtime"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/healthz"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/leaderelection"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/leaderelection/resourcelock"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/configz"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/cmd/kube-scheduler/app/options"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/plugin/pkg/scheduler/algorithmprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/factory"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/prometheus/client_golang/prometheus"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSchedulerCommand creates a *cobra.Command object with default parameters
0000000000000000000000000000000000000000;;	func NewSchedulerCommand() *cobra.Command {
0000000000000000000000000000000000000000;;		s := options.NewSchedulerServer()
0000000000000000000000000000000000000000;;		s.AddFlags(pflag.CommandLine)
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use: "kube-scheduler",
0000000000000000000000000000000000000000;;			Long: `The Kubernetes scheduler is a policy-rich, topology-aware,
0000000000000000000000000000000000000000;;	workload-specific function that significantly impacts availability, performance,
0000000000000000000000000000000000000000;;	and capacity. The scheduler needs to take into account individual and collective
0000000000000000000000000000000000000000;;	resource requirements, quality of service requirements, hardware/software/policy
0000000000000000000000000000000000000000;;	constraints, affinity and anti-affinity specifications, data locality, inter-workload
0000000000000000000000000000000000000000;;	interference, deadlines, and so on. Workload-specific requirements will be exposed
0000000000000000000000000000000000000000;;	through the API as necessary.`,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run runs the specified SchedulerServer.  This should never exit.
0000000000000000000000000000000000000000;;	func Run(s *options.SchedulerServer) error {
0000000000000000000000000000000000000000;;		kubecli, clientgoCli, err := createClient(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to create kube client: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		recorder := createRecorder(kubecli, s)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubecli, 0)
0000000000000000000000000000000000000000;;		// cache only non-terminal pods
0000000000000000000000000000000000000000;;		podInformer := factory.NewPodInformer(kubecli, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sched, err := CreateScheduler(
0000000000000000000000000000000000000000;;			s,
0000000000000000000000000000000000000000;;			kubecli,
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			podInformer,
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumeClaims(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().ReplicationControllers(),
0000000000000000000000000000000000000000;;			informerFactory.Extensions().V1beta1().ReplicaSets(),
0000000000000000000000000000000000000000;;			informerFactory.Apps().V1beta1().StatefulSets(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Services(),
0000000000000000000000000000000000000000;;			recorder,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error creating scheduler: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go startHTTP(s)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stop)
0000000000000000000000000000000000000000;;		go podInformer.Informer().Run(stop)
0000000000000000000000000000000000000000;;		informerFactory.Start(stop)
0000000000000000000000000000000000000000;;		// Waiting for all cache to sync before scheduling.
0000000000000000000000000000000000000000;;		informerFactory.WaitForCacheSync(stop)
0000000000000000000000000000000000000000;;		controller.WaitForCacheSync("scheduler", stop, podInformer.Informer().HasSynced)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		run := func(_ <-chan struct{}) {
0000000000000000000000000000000000000000;;			sched.Run()
0000000000000000000000000000000000000000;;			select {}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.LeaderElection.LeaderElect {
0000000000000000000000000000000000000000;;			run(nil)
0000000000000000000000000000000000000000;;			panic("unreachable")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		id, err := os.Hostname()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to get hostname: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rl, err := resourcelock.New(s.LeaderElection.ResourceLock,
0000000000000000000000000000000000000000;;			s.LockObjectNamespace,
0000000000000000000000000000000000000000;;			s.LockObjectName,
0000000000000000000000000000000000000000;;			clientgoCli,
0000000000000000000000000000000000000000;;			resourcelock.ResourceLockConfig{
0000000000000000000000000000000000000000;;				Identity:      id,
0000000000000000000000000000000000000000;;				EventRecorder: recorder,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("error creating lock: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		leaderelection.RunOrDie(leaderelection.LeaderElectionConfig{
0000000000000000000000000000000000000000;;			Lock:          rl,
0000000000000000000000000000000000000000;;			LeaseDuration: s.LeaderElection.LeaseDuration.Duration,
0000000000000000000000000000000000000000;;			RenewDeadline: s.LeaderElection.RenewDeadline.Duration,
0000000000000000000000000000000000000000;;			RetryPeriod:   s.LeaderElection.RetryPeriod.Duration,
0000000000000000000000000000000000000000;;			Callbacks: leaderelection.LeaderCallbacks{
0000000000000000000000000000000000000000;;				OnStartedLeading: run,
0000000000000000000000000000000000000000;;				OnStoppedLeading: func() {
0000000000000000000000000000000000000000;;					glog.Fatalf("lost master")
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		panic("unreachable")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startHTTP(s *options.SchedulerServer) {
0000000000000000000000000000000000000000;;		mux := http.NewServeMux()
0000000000000000000000000000000000000000;;		healthz.InstallHandler(mux)
0000000000000000000000000000000000000000;;		if s.EnableProfiling {
0000000000000000000000000000000000000000;;			mux.HandleFunc("/debug/pprof/", pprof.Index)
0000000000000000000000000000000000000000;;			mux.HandleFunc("/debug/pprof/profile", pprof.Profile)
0000000000000000000000000000000000000000;;			mux.HandleFunc("/debug/pprof/symbol", pprof.Symbol)
0000000000000000000000000000000000000000;;			mux.HandleFunc("/debug/pprof/trace", pprof.Trace)
0000000000000000000000000000000000000000;;			if s.EnableContentionProfiling {
0000000000000000000000000000000000000000;;				goruntime.SetBlockProfileRate(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c, err := configz.New("componentconfig"); err == nil {
0000000000000000000000000000000000000000;;			c.Set(s.KubeSchedulerConfiguration)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Errorf("unable to register configz: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		configz.InstallHandler(mux)
0000000000000000000000000000000000000000;;		mux.Handle("/metrics", prometheus.Handler())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server := &http.Server{
0000000000000000000000000000000000000000;;			Addr:    net.JoinHostPort(s.Address, strconv.Itoa(int(s.Port))),
0000000000000000000000000000000000000000;;			Handler: mux,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Fatal(server.ListenAndServe())
0000000000000000000000000000000000000000;;	}
