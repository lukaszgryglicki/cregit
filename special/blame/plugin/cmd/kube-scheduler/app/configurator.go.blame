0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
8f712e406d0704963dc9b103d84b874007afb796;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package app
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		appsinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/apps/v1beta1"
0000000000000000000000000000000000000000;;		coreinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/core/v1"
0000000000000000000000000000000000000000;;		extensionsinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/cmd/kube-scheduler/app/options"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		v1core "k8s.io/client-go/kubernetes/typed/core/v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/plugin/pkg/scheduler/algorithmprovider"
0000000000000000000000000000000000000000;;		schedulerapi "k8s.io/kubernetes/plugin/pkg/scheduler/api"
0000000000000000000000000000000000000000;;		latestschedulerapi "k8s.io/kubernetes/plugin/pkg/scheduler/api/latest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/factory"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createRecorder(kubecli *clientset.Clientset, s *options.SchedulerServer) record.EventRecorder {
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(glog.Infof)
0000000000000000000000000000000000000000;;		eventBroadcaster.StartRecordingToSink(&v1core.EventSinkImpl{Interface: v1core.New(kubecli.Core().RESTClient()).Events("")})
0000000000000000000000000000000000000000;;		return eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: s.SchedulerName})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: convert scheduler to only use client-go's clientset.
0000000000000000000000000000000000000000;;	func createClient(s *options.SchedulerServer) (*clientset.Clientset, *kubernetes.Clientset, error) {
0000000000000000000000000000000000000000;;		kubeconfig, err := clientcmd.BuildConfigFromFlags(s.Master, s.Kubeconfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("unable to build config from flags: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeconfig.ContentType = s.ContentType
0000000000000000000000000000000000000000;;		// Override kubeconfig qps/burst settings from flags
0000000000000000000000000000000000000000;;		kubeconfig.QPS = s.KubeAPIQPS
0000000000000000000000000000000000000000;;		kubeconfig.Burst = int(s.KubeAPIBurst)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cli, err := clientset.NewForConfig(restclient.AddUserAgent(kubeconfig, "leader-election"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("invalid API configuration: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clientgoCli, err := kubernetes.NewForConfig(restclient.AddUserAgent(kubeconfig, "leader-election"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("invalid API configuration: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cli, clientgoCli, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateScheduler encapsulates the entire creation of a runnable scheduler.
0000000000000000000000000000000000000000;;	func CreateScheduler(
0000000000000000000000000000000000000000;;		s *options.SchedulerServer,
0000000000000000000000000000000000000000;;		kubecli *clientset.Clientset,
0000000000000000000000000000000000000000;;		nodeInformer coreinformers.NodeInformer,
0000000000000000000000000000000000000000;;		podInformer coreinformers.PodInformer,
0000000000000000000000000000000000000000;;		pvInformer coreinformers.PersistentVolumeInformer,
0000000000000000000000000000000000000000;;		pvcInformer coreinformers.PersistentVolumeClaimInformer,
0000000000000000000000000000000000000000;;		replicationControllerInformer coreinformers.ReplicationControllerInformer,
0000000000000000000000000000000000000000;;		replicaSetInformer extensionsinformers.ReplicaSetInformer,
0000000000000000000000000000000000000000;;		statefulSetInformer appsinformers.StatefulSetInformer,
0000000000000000000000000000000000000000;;		serviceInformer coreinformers.ServiceInformer,
0000000000000000000000000000000000000000;;		recorder record.EventRecorder,
0000000000000000000000000000000000000000;;	) (*scheduler.Scheduler, error) {
0000000000000000000000000000000000000000;;		configurator := factory.NewConfigFactory(
0000000000000000000000000000000000000000;;			s.SchedulerName,
0000000000000000000000000000000000000000;;			kubecli,
0000000000000000000000000000000000000000;;			nodeInformer,
0000000000000000000000000000000000000000;;			podInformer,
0000000000000000000000000000000000000000;;			pvInformer,
0000000000000000000000000000000000000000;;			pvcInformer,
0000000000000000000000000000000000000000;;			replicationControllerInformer,
0000000000000000000000000000000000000000;;			replicaSetInformer,
0000000000000000000000000000000000000000;;			statefulSetInformer,
0000000000000000000000000000000000000000;;			serviceInformer,
0000000000000000000000000000000000000000;;			s.HardPodAffinitySymmetricWeight,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rebuild the configurator with a default Create(...) method.
0000000000000000000000000000000000000000;;		configurator = &schedulerConfigurator{
0000000000000000000000000000000000000000;;			configurator,
0000000000000000000000000000000000000000;;			s.PolicyConfigFile,
0000000000000000000000000000000000000000;;			s.AlgorithmProvider,
0000000000000000000000000000000000000000;;			s.PolicyConfigMapName,
0000000000000000000000000000000000000000;;			s.PolicyConfigMapNamespace,
0000000000000000000000000000000000000000;;			s.UseLegacyPolicyConfig,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return scheduler.NewFromConfigurator(configurator, func(cfg *scheduler.Config) {
0000000000000000000000000000000000000000;;			cfg.Recorder = recorder
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// schedulerConfigurator is an interface wrapper that provides a way to create
0000000000000000000000000000000000000000;;	// a scheduler from a user provided config file or ConfigMap object.
0000000000000000000000000000000000000000;;	type schedulerConfigurator struct {
0000000000000000000000000000000000000000;;		scheduler.Configurator
0000000000000000000000000000000000000000;;		policyFile               string
0000000000000000000000000000000000000000;;		algorithmProvider        string
0000000000000000000000000000000000000000;;		policyConfigMap          string
0000000000000000000000000000000000000000;;		policyConfigMapNamespace string
0000000000000000000000000000000000000000;;		useLegacyPolicyConfig    bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getSchedulerPolicyConfig finds and decodes scheduler's policy config. If no
0000000000000000000000000000000000000000;;	// such policy is found, it returns nil, nil.
0000000000000000000000000000000000000000;;	func (sc schedulerConfigurator) getSchedulerPolicyConfig() (*schedulerapi.Policy, error) {
0000000000000000000000000000000000000000;;		var configData []byte
0000000000000000000000000000000000000000;;		var policyConfigMapFound bool
0000000000000000000000000000000000000000;;		var policy schedulerapi.Policy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If not in legacy mode, try to find policy ConfigMap.
0000000000000000000000000000000000000000;;		if !sc.useLegacyPolicyConfig && len(sc.policyConfigMap) != 0 {
0000000000000000000000000000000000000000;;			namespace := sc.policyConfigMapNamespace
0000000000000000000000000000000000000000;;			policyConfigMap, err := sc.GetClient().CoreV1().ConfigMaps(namespace).Get(sc.policyConfigMap, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Error getting scheduler policy ConfigMap: %v.", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if policyConfigMap != nil {
0000000000000000000000000000000000000000;;				var configString string
0000000000000000000000000000000000000000;;				configString, policyConfigMapFound = policyConfigMap.Data[options.SchedulerPolicyConfigMapKey]
0000000000000000000000000000000000000000;;				if !policyConfigMapFound {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("No element with key = '%v' is found in the ConfigMap 'Data'.", options.SchedulerPolicyConfigMapKey)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Scheduler policy ConfigMap: %v", configString)
0000000000000000000000000000000000000000;;				configData = []byte(configString)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we are in legacy mode or ConfigMap name is empty, try to use policy
0000000000000000000000000000000000000000;;		// config file.
0000000000000000000000000000000000000000;;		if !policyConfigMapFound {
0000000000000000000000000000000000000000;;			if _, err := os.Stat(sc.policyFile); err != nil {
0000000000000000000000000000000000000000;;				// No config file is found.
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			configData, err = ioutil.ReadFile(sc.policyFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unable to read policy config: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := runtime.DecodeInto(latestschedulerapi.Codec, configData, &policy); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid configuration: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &policy, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create implements the interface for the Configurator, hence it is exported
0000000000000000000000000000000000000000;;	// even though the struct is not.
0000000000000000000000000000000000000000;;	func (sc schedulerConfigurator) Create() (*scheduler.Config, error) {
0000000000000000000000000000000000000000;;		policy, err := sc.getSchedulerPolicyConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If no policy is found, create scheduler from algorithm provider.
0000000000000000000000000000000000000000;;		if policy == nil {
0000000000000000000000000000000000000000;;			if sc.Configurator != nil {
0000000000000000000000000000000000000000;;				return sc.Configurator.CreateFromProvider(sc.algorithmProvider)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Configurator was nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sc.CreateFromConfig(*policy)
0000000000000000000000000000000000000000;;	}
