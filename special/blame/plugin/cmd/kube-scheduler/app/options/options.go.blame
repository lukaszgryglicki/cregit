0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f9aa0fba8058f597f99add168f2f0d59539e1816;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package options provides the scheduler flags
0000000000000000000000000000000000000000;;	package options
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilfeature "k8s.io/apiserver/pkg/util/feature"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/leaderelectionconfig"
0000000000000000000000000000000000000000;;		kubeletapis "k8s.io/kubernetes/pkg/kubelet/apis"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/factory"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// add the kubernetes feature gates
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/features"
0000000000000000000000000000000000000000;;		// install the componentconfig api so we get its defaulting and conversion functions
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/componentconfig/install"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SchedulerPolicyConfigMapKey defines the key of the element in the
0000000000000000000000000000000000000000;;	// scheduler's policy ConfigMap that contains scheduler's policy config.
0000000000000000000000000000000000000000;;	const SchedulerPolicyConfigMapKey string = "policy.cfg"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SchedulerServer has all the context and params needed to run a Scheduler
0000000000000000000000000000000000000000;;	type SchedulerServer struct {
0000000000000000000000000000000000000000;;		componentconfig.KubeSchedulerConfiguration
0000000000000000000000000000000000000000;;		// Master is the address of the Kubernetes API server (overrides any
0000000000000000000000000000000000000000;;		// value in kubeconfig).
0000000000000000000000000000000000000000;;		Master string
0000000000000000000000000000000000000000;;		// Kubeconfig is Path to kubeconfig file with authorization and master
0000000000000000000000000000000000000000;;		// location information.
0000000000000000000000000000000000000000;;		Kubeconfig string
0000000000000000000000000000000000000000;;		// Dynamic conifguration for scheduler features.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSchedulerServer creates a new SchedulerServer with default parameters
0000000000000000000000000000000000000000;;	func NewSchedulerServer() *SchedulerServer {
0000000000000000000000000000000000000000;;		versioned := &v1alpha1.KubeSchedulerConfiguration{}
0000000000000000000000000000000000000000;;		api.Scheme.Default(versioned)
0000000000000000000000000000000000000000;;		cfg := componentconfig.KubeSchedulerConfiguration{}
0000000000000000000000000000000000000000;;		api.Scheme.Convert(versioned, &cfg, nil)
0000000000000000000000000000000000000000;;		cfg.LeaderElection.LeaderElect = true
0000000000000000000000000000000000000000;;		s := SchedulerServer{
0000000000000000000000000000000000000000;;			KubeSchedulerConfiguration: cfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddFlags adds flags for a specific SchedulerServer to the specified FlagSet
0000000000000000000000000000000000000000;;	func (s *SchedulerServer) AddFlags(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		fs.Int32Var(&s.Port, "port", s.Port, "The port that the scheduler's http service runs on")
0000000000000000000000000000000000000000;;		fs.StringVar(&s.Address, "address", s.Address, "The IP address to serve on (set to 0.0.0.0 for all interfaces)")
0000000000000000000000000000000000000000;;		fs.StringVar(&s.AlgorithmProvider, "algorithm-provider", s.AlgorithmProvider, "The scheduling algorithm provider to use, one of: "+factory.ListAlgorithmProviders())
0000000000000000000000000000000000000000;;		fs.StringVar(&s.PolicyConfigFile, "policy-config-file", s.PolicyConfigFile, "File with scheduler policy configuration. This file is used if policy ConfigMap is not provided or --use-legacy-policy-config==true")
0000000000000000000000000000000000000000;;		usage := fmt.Sprintf("Name of the ConfigMap object that contains scheduler's policy configuration. It must exist in the system namespace before scheduler initialization if --use-legacy-policy-config==false. The config must be provided as the value of an element in 'Data' map with the key='%v'", SchedulerPolicyConfigMapKey)
0000000000000000000000000000000000000000;;		fs.StringVar(&s.PolicyConfigMapName, "policy-configmap", s.PolicyConfigMapName, usage)
0000000000000000000000000000000000000000;;		fs.StringVar(&s.PolicyConfigMapNamespace, "policy-configmap-namespace", s.PolicyConfigMapNamespace, "The namespace where policy ConfigMap is located. The system namespace will be used if this is not provided or is empty.")
0000000000000000000000000000000000000000;;		fs.BoolVar(&s.UseLegacyPolicyConfig, "use-legacy-policy-config", false, "When set to true, scheduler will ignore policy ConfigMap and uses policy config file")
0000000000000000000000000000000000000000;;		fs.BoolVar(&s.EnableProfiling, "profiling", true, "Enable profiling via web interface host:port/debug/pprof/")
0000000000000000000000000000000000000000;;		fs.BoolVar(&s.EnableContentionProfiling, "contention-profiling", false, "Enable lock contention profiling, if profiling is enabled")
0000000000000000000000000000000000000000;;		fs.StringVar(&s.Master, "master", s.Master, "The address of the Kubernetes API server (overrides any value in kubeconfig)")
0000000000000000000000000000000000000000;;		fs.StringVar(&s.Kubeconfig, "kubeconfig", s.Kubeconfig, "Path to kubeconfig file with authorization and master location information.")
0000000000000000000000000000000000000000;;		fs.StringVar(&s.ContentType, "kube-api-content-type", s.ContentType, "Content type of requests sent to apiserver.")
0000000000000000000000000000000000000000;;		fs.Float32Var(&s.KubeAPIQPS, "kube-api-qps", s.KubeAPIQPS, "QPS to use while talking with kubernetes apiserver")
0000000000000000000000000000000000000000;;		fs.Int32Var(&s.KubeAPIBurst, "kube-api-burst", s.KubeAPIBurst, "Burst to use while talking with kubernetes apiserver")
0000000000000000000000000000000000000000;;		fs.StringVar(&s.SchedulerName, "scheduler-name", s.SchedulerName, "Name of the scheduler, used to select which pods will be processed by this scheduler, based on pod's \"spec.SchedulerName\".")
0000000000000000000000000000000000000000;;		fs.StringVar(&s.LockObjectNamespace, "lock-object-namespace", s.LockObjectNamespace, "Define the namespace of the lock object.")
0000000000000000000000000000000000000000;;		fs.StringVar(&s.LockObjectName, "lock-object-name", s.LockObjectName, "Define the name of the lock object.")
0000000000000000000000000000000000000000;;		fs.IntVar(&s.HardPodAffinitySymmetricWeight, "hard-pod-affinity-symmetric-weight", api.DefaultHardPodAffinitySymmetricWeight,
0000000000000000000000000000000000000000;;			"RequiredDuringScheduling affinity is not symmetric, but there is an implicit PreferredDuringScheduling affinity rule corresponding "+
0000000000000000000000000000000000000000;;				"to every RequiredDuringScheduling affinity rule. --hard-pod-affinity-symmetric-weight represents the weight of implicit PreferredDuringScheduling affinity rule.")
0000000000000000000000000000000000000000;;		fs.MarkDeprecated("hard-pod-affinity-symmetric-weight", "This option was moved to the policy configuration file")
0000000000000000000000000000000000000000;;		fs.StringVar(&s.FailureDomains, "failure-domains", kubeletapis.DefaultFailureDomains, "Indicate the \"all topologies\" set for an empty topologyKey when it's used for PreferredDuringScheduling pod anti-affinity.")
0000000000000000000000000000000000000000;;		fs.MarkDeprecated("failure-domains", "Doesn't have any effect. Will be removed in future version.")
0000000000000000000000000000000000000000;;		leaderelectionconfig.BindFlags(&s.LeaderElection, fs)
0000000000000000000000000000000000000000;;		utilfeature.DefaultFeatureGate.AddFlag(fs)
0000000000000000000000000000000000000000;;	}
