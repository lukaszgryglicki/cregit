0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2014 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Validates that the cluster is healthy.
0000000000000000000000000000000000000000;;	# Error codes are:
0000000000000000000000000000000000000000;;	# 0 - success
0000000000000000000000000000000000000000;;	# 1 - fatal (cluster is unlikely to work)
0000000000000000000000000000000000000000;;	# 2 - non-fatal (encountered some errors, but cluster should be working correctly)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	set -o errexit
0000000000000000000000000000000000000000;;	set -o nounset
0000000000000000000000000000000000000000;;	set -o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_ROOT=$(dirname "${BASH_SOURCE}")/..
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [ -f "${KUBE_ROOT}/cluster/env.sh" ]; then
0000000000000000000000000000000000000000;;	  source "${KUBE_ROOT}/cluster/env.sh"
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/hack/lib/util.sh"
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/cluster/kube-util.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Run kubectl and retry upon failure.
0000000000000000000000000000000000000000;;	function kubectl_retry() {
0000000000000000000000000000000000000000;;	  tries=3
0000000000000000000000000000000000000000;;	  while ! "${KUBE_ROOT}/cluster/kubectl.sh" "$@"; do
0000000000000000000000000000000000000000;;	    tries=$((tries-1))
0000000000000000000000000000000000000000;;	    if [[ ${tries} -le 0 ]]; then
0000000000000000000000000000000000000000;;	      echo "('kubectl $@' failed, giving up)" >&2
0000000000000000000000000000000000000000;;	      return 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    echo "(kubectl failed, will retry ${tries} times)" >&2
0000000000000000000000000000000000000000;;	    sleep 1
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	ALLOWED_NOTREADY_NODES="${ALLOWED_NOTREADY_NODES:-0}"
0000000000000000000000000000000000000000;;	CLUSTER_READY_ADDITIONAL_TIME_SECONDS="${CLUSTER_READY_ADDITIONAL_TIME_SECONDS:-30}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	EXPECTED_NUM_NODES="${NUM_NODES}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "${KUBERNETES_PROVIDER:-}" == "gce" ]]; then
0000000000000000000000000000000000000000;;	  echo "Validating gce cluster, MULTIZONE=${MULTIZONE:-}"
0000000000000000000000000000000000000000;;	  # In multizone mode we need to add instances for all nodes in the region.
0000000000000000000000000000000000000000;;	  if [[ "${MULTIZONE:-}" == "true" ]]; then
0000000000000000000000000000000000000000;;	    EXPECTED_NUM_NODES=$(gcloud -q compute instances list --project="${PROJECT}" --format=[no-heading] --regexp="${NODE_INSTANCE_PREFIX}.*" \
0000000000000000000000000000000000000000;;	      --zones=$(gcloud -q compute zones list --project="${PROJECT}" --filter=region=${REGION} --format=csv[no-heading]\(name\) | tr "\n" "," | sed  "s/,$//") | wc -l)
0000000000000000000000000000000000000000;;	    echo "Computing number of nodes, NODE_INSTANCE_PREFIX=${NODE_INSTANCE_PREFIX}, REGION=${REGION}, EXPECTED_NUM_NODES=${EXPECTED_NUM_NODES}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "${REGISTER_MASTER_KUBELET:-}" == "true" ]]; then
0000000000000000000000000000000000000000;;	  if [[ "${KUBERNETES_PROVIDER:-}" == "gce" ]]; then
0000000000000000000000000000000000000000;;	    NUM_MASTERS=$(get-master-replicas-count)
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    NUM_MASTERS=1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  EXPECTED_NUM_NODES=$((EXPECTED_NUM_NODES+NUM_MASTERS))
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	REQUIRED_NUM_NODES=$((EXPECTED_NUM_NODES - ALLOWED_NOTREADY_NODES))
0000000000000000000000000000000000000000;;	# Make several attempts to deal with slow cluster birth.
0000000000000000000000000000000000000000;;	return_value=0
0000000000000000000000000000000000000000;;	attempt=0
0000000000000000000000000000000000000000;;	# Set the timeout to ~25minutes (100 x 15 second) to avoid timeouts for 1000-node clusters.
0000000000000000000000000000000000000000;;	PAUSE_BETWEEN_ITERATIONS_SECONDS=15
0000000000000000000000000000000000000000;;	MAX_ATTEMPTS=100
0000000000000000000000000000000000000000;;	ADDITIONAL_ITERATIONS=$(((CLUSTER_READY_ADDITIONAL_TIME_SECONDS + PAUSE_BETWEEN_ITERATIONS_SECONDS - 1)/PAUSE_BETWEEN_ITERATIONS_SECONDS))
0000000000000000000000000000000000000000;;	while true; do
0000000000000000000000000000000000000000;;	  # Pause between iterations of this large outer loop.
0000000000000000000000000000000000000000;;	  if [[ ${attempt} -gt 0 ]]; then
0000000000000000000000000000000000000000;;	    sleep 15
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  attempt=$((attempt+1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # The "kubectl get nodes -o template" exports node information.
0000000000000000000000000000000000000000;;	  #
0000000000000000000000000000000000000000;;	  # Echo the output and gather 2 counts:
0000000000000000000000000000000000000000;;	  #  - Total number of nodes.
0000000000000000000000000000000000000000;;	  #  - Number of "ready" nodes.
0000000000000000000000000000000000000000;;	  #
0000000000000000000000000000000000000000;;	  # Suppress errors from kubectl output because during cluster bootstrapping
0000000000000000000000000000000000000000;;	  # for clusters where the master node is registered, the apiserver will become
0000000000000000000000000000000000000000;;	  # available and then get restarted as the kubelet configures the docker bridge.
0000000000000000000000000000000000000000;;	  #
0000000000000000000000000000000000000000;;	  # We are assigning the result of kubectl_retry get nodes operation to the res
0000000000000000000000000000000000000000;;	  # varaible in that way, to prevent stopping the whole script on an error.
0000000000000000000000000000000000000000;;	  node=$(kubectl_retry get nodes) && res="$?" || res="$?"
0000000000000000000000000000000000000000;;	  if [ "${res}" -ne "0" ]; then
0000000000000000000000000000000000000000;;	    if [[ "${attempt}" -gt "${last_run:-$MAX_ATTEMPTS}" ]]; then
0000000000000000000000000000000000000000;;	      echo -e "${color_red} Failed to get nodes.${color_norm}"
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      continue
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  found=$(($(echo "${node}" | wc -l) - 1))
0000000000000000000000000000000000000000;;	  ready=$(($(echo "${node}" | grep -v "NotReady" | wc -l ) - 1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if (( "${found}" == "${EXPECTED_NUM_NODES}" )) && (( "${ready}" == "${EXPECTED_NUM_NODES}")); then
0000000000000000000000000000000000000000;;	    break
0000000000000000000000000000000000000000;;	  elif (( "${found}" > "${EXPECTED_NUM_NODES}" )); then
0000000000000000000000000000000000000000;;	    if [[ "${KUBE_USE_EXISTING_MASTER:-}" != "true" ]]; then
0000000000000000000000000000000000000000;;	      echo -e "${color_red}Found ${found} nodes, but expected ${EXPECTED_NUM_NODES}. Your cluster may not behave correctly.${color_norm}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    break
0000000000000000000000000000000000000000;;	  elif (( "${ready}" > "${EXPECTED_NUM_NODES}")); then
0000000000000000000000000000000000000000;;	    echo -e "${color_red}Found ${ready} ready nodes, but expected ${EXPECTED_NUM_NODES}. Your cluster may not behave correctly.${color_norm}"
0000000000000000000000000000000000000000;;	    break
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    if [[ "${REQUIRED_NUM_NODES}" -le "${ready}" ]]; then
0000000000000000000000000000000000000000;;	      echo -e "${color_green}Found ${REQUIRED_NUM_NODES} Nodes, allowing additional ${ADDITIONAL_ITERATIONS} iterations for other Nodes to join.${color_norm}"
0000000000000000000000000000000000000000;;	      last_run="${last_run:-$((attempt + ADDITIONAL_ITERATIONS - 1))}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [[ "${attempt}" -gt "${last_run:-$MAX_ATTEMPTS}" ]]; then
0000000000000000000000000000000000000000;;	      echo -e "${color_yellow}Detected ${ready} ready nodes, found ${found} nodes out of expected ${EXPECTED_NUM_NODES}. Your cluster may not be fully functional.${color_norm}"
0000000000000000000000000000000000000000;;	      kubectl_retry get nodes
0000000000000000000000000000000000000000;;	      if [[ "${REQUIRED_NUM_NODES}" -gt "${ready}" ]]; then
0000000000000000000000000000000000000000;;	        exit 1
0000000000000000000000000000000000000000;;	      else
0000000000000000000000000000000000000000;;	        return_value=2
0000000000000000000000000000000000000000;;	        break
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      echo -e "${color_yellow}Waiting for ${EXPECTED_NUM_NODES} ready nodes. ${ready} ready nodes, ${found} registered. Retrying.${color_norm}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	echo "Found ${found} node(s)."
0000000000000000000000000000000000000000;;	kubectl_retry get nodes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	attempt=0
0000000000000000000000000000000000000000;;	while true; do
0000000000000000000000000000000000000000;;	  # The "kubectl componentstatuses -o template" exports components health information.
0000000000000000000000000000000000000000;;	  #
0000000000000000000000000000000000000000;;	  # Echo the output and gather 2 counts:
0000000000000000000000000000000000000000;;	  #  - Total number of componentstatuses.
0000000000000000000000000000000000000000;;	  #  - Number of "healthy" components.
0000000000000000000000000000000000000000;;	  cs_status=$(kubectl_retry get componentstatuses -o template --template='{{range .items}}{{with index .conditions 0}}{{.type}}:{{.status}}{{end}}{{"\n"}}{{end}}') || true
0000000000000000000000000000000000000000;;	  componentstatuses=$(echo "${cs_status}" | grep -c 'Healthy:') || true
0000000000000000000000000000000000000000;;	  healthy=$(echo "${cs_status}" | grep -c 'Healthy:True') || true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if ((componentstatuses > healthy)) || ((componentstatuses == 0)); then
0000000000000000000000000000000000000000;;	    if ((attempt < 5)); then
0000000000000000000000000000000000000000;;	      echo -e "${color_yellow}Cluster not working yet.${color_norm}"
0000000000000000000000000000000000000000;;	      attempt=$((attempt+1))
0000000000000000000000000000000000000000;;	      sleep 30
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      echo -e " ${color_yellow}Validate output:${color_norm}"
0000000000000000000000000000000000000000;;	      kubectl_retry get cs
0000000000000000000000000000000000000000;;	      echo -e "${color_red}Validation returned one or more failed components. Cluster is probably broken.${color_norm}"
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    break
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo "Validate output:"
0000000000000000000000000000000000000000;;	kubectl_retry get cs || true
0000000000000000000000000000000000000000;;	if [ "${return_value}" == "0" ]; then
0000000000000000000000000000000000000000;;	  echo -e "${color_green}Cluster validation succeeded${color_norm}"
0000000000000000000000000000000000000000;;	else
0000000000000000000000000000000000000000;;	  echo -e "${color_yellow}Cluster validation encountered some problems, but cluster should be in working order${color_norm}"
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	exit "${return_value}"
