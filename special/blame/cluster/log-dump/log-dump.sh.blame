0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2017 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Call this to dump all master and node logs into the folder specified in $1
0000000000000000000000000000000000000000;;	# (defaults to _artifacts). Only works if the provider supports SSH.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	set -o errexit
0000000000000000000000000000000000000000;;	set -o nounset
0000000000000000000000000000000000000000;;	set -o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	readonly report_dir="${1:-_artifacts}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# In order to more trivially extend log-dump for custom deployments,
0000000000000000000000000000000000000000;;	# check for a function named log_dump_custom_get_instances. If it's
0000000000000000000000000000000000000000;;	# defined, we assume the function can me called with one argument, the
0000000000000000000000000000000000000000;;	# role, which is either "master" or "node".
0000000000000000000000000000000000000000;;	if [[ $(type -t log_dump_custom_get_instances) == "function" ]]; then
0000000000000000000000000000000000000000;;	  readonly use_custom_instance_list=yes
0000000000000000000000000000000000000000;;	else
0000000000000000000000000000000000000000;;	  readonly use_custom_instance_list=
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	readonly master_ssh_supported_providers="gce aws kubemark"
0000000000000000000000000000000000000000;;	readonly node_ssh_supported_providers="gce gke aws kubemark"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	readonly master_logfiles="kube-apiserver kube-scheduler rescheduler kube-controller-manager etcd etcd-events glbc cluster-autoscaler kube-addon-manager fluentd"
0000000000000000000000000000000000000000;;	readonly node_logfiles="kube-proxy fluentd node-problem-detector"
0000000000000000000000000000000000000000;;	readonly node_systemd_services="node-problem-detector"
0000000000000000000000000000000000000000;;	readonly hollow_node_logfiles="kubelet-hollow-node-* kubeproxy-hollow-node-* npd-*"
0000000000000000000000000000000000000000;;	readonly aws_logfiles="cloud-init-output"
0000000000000000000000000000000000000000;;	readonly gce_logfiles="startupscript"
0000000000000000000000000000000000000000;;	readonly kern_logfile="kern"
0000000000000000000000000000000000000000;;	readonly initd_logfiles="docker"
0000000000000000000000000000000000000000;;	readonly supervisord_logfiles="kubelet supervisor/supervisord supervisor/kubelet-stdout supervisor/kubelet-stderr supervisor/docker-stdout supervisor/docker-stderr"
0000000000000000000000000000000000000000;;	readonly systemd_services="kubelet docker"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Limit the number of concurrent node connections so that we don't run out of
0000000000000000000000000000000000000000;;	# file descriptors for large clusters.
0000000000000000000000000000000000000000;;	readonly max_scp_processes=25
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This template spits out the external IPs and images for each node in the cluster in a format like so:
0000000000000000000000000000000000000000;;	# 52.32.7.85 gcr.io/google_containers/kube-apiserver:1355c18c32d7bef16125120bce194fad gcr.io/google_containers/kube-controller-manager:46365cdd8d28b8207950c3c21d1f3900 [...]
0000000000000000000000000000000000000000;;	readonly ips_and_images='{range .items[*]}{@.status.addresses[?(@.type == "ExternalIP")].address} {@.status.images[*].names[*]}{"\n"}{end}'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function setup() {
0000000000000000000000000000000000000000;;	  if [[ -z "${use_custom_instance_list}" ]]; then
0000000000000000000000000000000000000000;;	    KUBE_ROOT=$(dirname "${BASH_SOURCE}")/../..
0000000000000000000000000000000000000000;;	    : ${KUBE_CONFIG_FILE:="config-test.sh"}
0000000000000000000000000000000000000000;;	    source "${KUBE_ROOT}/cluster/kube-util.sh"
0000000000000000000000000000000000000000;;	    detect-project &> /dev/null
0000000000000000000000000000000000000000;;	  elif [[ -z "${LOG_DUMP_SSH_KEY:-}" ]]; then
0000000000000000000000000000000000000000;;	    echo "LOG_DUMP_SSH_KEY not set, but required when using log_dump_custom_get_instances"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  elif [[ -z "${LOG_DUMP_SSH_USER:-}" ]]; then
0000000000000000000000000000000000000000;;	    echo "LOG_DUMP_SSH_USER not set, but required when using log_dump_custom_get_instances"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function log-dump-ssh() {
0000000000000000000000000000000000000000;;	  if [[ -z "${use_custom_instance_list}" ]]; then
0000000000000000000000000000000000000000;;	    ssh-to-node "$@"
0000000000000000000000000000000000000000;;	    return
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local host="$1"
0000000000000000000000000000000000000000;;	  local cmd="$2"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  ssh -oLogLevel=quiet -oConnectTimeout=30 -oStrictHostKeyChecking=no -i "${LOG_DUMP_SSH_KEY}" "${LOG_DUMP_SSH_USER}@${host}" "${cmd}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copy all files /var/log/{$3}.log on node $1 into local dir $2.
0000000000000000000000000000000000000000;;	# $3 should be a space-separated string of files.
0000000000000000000000000000000000000000;;	# This function shouldn't ever trigger errexit, but doesn't block stderr.
0000000000000000000000000000000000000000;;	function copy-logs-from-node() {
0000000000000000000000000000000000000000;;	    local -r node="${1}"
0000000000000000000000000000000000000000;;	    local -r dir="${2}"
0000000000000000000000000000000000000000;;	    local files=( ${3} )
0000000000000000000000000000000000000000;;	    # Append ".log*"
0000000000000000000000000000000000000000;;	    # The * at the end is needed to also copy rotated logs (which happens
0000000000000000000000000000000000000000;;	    # in large clusters and long runs).
0000000000000000000000000000000000000000;;	    files=( "${files[@]/%/.log*}" )
0000000000000000000000000000000000000000;;	    # Prepend "/var/log/"
0000000000000000000000000000000000000000;;	    files=( "${files[@]/#/\/var\/log\/}" )
0000000000000000000000000000000000000000;;	    # Comma delimit (even the singleton, or scp does the wrong thing), surround by braces.
0000000000000000000000000000000000000000;;	    local -r scp_files="{$(printf "%s," "${files[@]}")}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if [[ -n "${use_custom_instance_list}" ]]; then
0000000000000000000000000000000000000000;;	      scp -oLogLevel=quiet -oConnectTimeout=30 -oStrictHostKeyChecking=no -i "${LOG_DUMP_SSH_KEY}" "${LOG_DUMP_SSH_USER}@${node}:${scp_files}" "${dir}" > /dev/null || true
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      case "${KUBERNETES_PROVIDER}" in
0000000000000000000000000000000000000000;;	        gce|gke|kubemark)
0000000000000000000000000000000000000000;;	          # get-serial-port-output lets you ask for ports 1-4, but currently (11/21/2016) only port 1 contains useful information
0000000000000000000000000000000000000000;;	          gcloud compute instances get-serial-port-output --project "${PROJECT}" --zone "${ZONE}" --port 1 "${node}" > "${dir}/serial-1.log" || true
0000000000000000000000000000000000000000;;	          gcloud compute scp --recurse --project "${PROJECT}" --zone "${ZONE}" "${node}:${scp_files}" "${dir}" > /dev/null || true
0000000000000000000000000000000000000000;;	          ;;
0000000000000000000000000000000000000000;;	        aws)
0000000000000000000000000000000000000000;;	          local ip=$(get_ssh_hostname "${node}")
0000000000000000000000000000000000000000;;	          scp -oLogLevel=quiet -oConnectTimeout=30 -oStrictHostKeyChecking=no -i "${AWS_SSH_KEY}" "${SSH_USER}@${ip}:${scp_files}" "${dir}" > /dev/null || true
0000000000000000000000000000000000000000;;	          ;;
0000000000000000000000000000000000000000;;	      esac
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Save logs for node $1 into directory $2. Pass in any non-common files in $3.
0000000000000000000000000000000000000000;;	# Pass in any non-common systemd services in $4.
0000000000000000000000000000000000000000;;	# $3 and $4 should be a space-separated list of files.
0000000000000000000000000000000000000000;;	# This function shouldn't ever trigger errexit
0000000000000000000000000000000000000000;;	function save-logs() {
0000000000000000000000000000000000000000;;	    local -r node_name="${1}"
0000000000000000000000000000000000000000;;	    local -r dir="${2}"
0000000000000000000000000000000000000000;;	    local files="${3}"
0000000000000000000000000000000000000000;;	    local opt_systemd_services="${4:-""}"
0000000000000000000000000000000000000000;;	    if [[ -n "${use_custom_instance_list}" ]]; then
0000000000000000000000000000000000000000;;	      if [[ -n "${LOG_DUMP_SAVE_LOGS:-}" ]]; then
0000000000000000000000000000000000000000;;	        files="${files} ${LOG_DUMP_SAVE_LOGS:-}"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      case "${KUBERNETES_PROVIDER}" in
0000000000000000000000000000000000000000;;	        gce|gke|kubemark)
0000000000000000000000000000000000000000;;	          files="${files} ${gce_logfiles}"
0000000000000000000000000000000000000000;;	          if [[ "${KUBERNETES_PROVIDER}" == "kubemark" && "${ENABLE_HOLLOW_NODE_LOGS:-}" == "true" ]]; then
0000000000000000000000000000000000000000;;	            files="${files} ${hollow_node_logfiles}"
0000000000000000000000000000000000000000;;	          fi
0000000000000000000000000000000000000000;;	          ;;
0000000000000000000000000000000000000000;;	        aws)
0000000000000000000000000000000000000000;;	          files="${files} ${aws_logfiles}"
0000000000000000000000000000000000000000;;	          ;;
0000000000000000000000000000000000000000;;	      esac
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    local -r services=( ${systemd_services} ${opt_systemd_services} ${LOG_DUMP_SAVE_SERVICES:-} )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if log-dump-ssh "${node_name}" "command -v journalctl" &> /dev/null; then
0000000000000000000000000000000000000000;;	        log-dump-ssh "${node_name}" "sudo journalctl --output=short-precise -u kube-node-installation.service" > "${dir}/kube-node-installation.log" || true
0000000000000000000000000000000000000000;;	        log-dump-ssh "${node_name}" "sudo journalctl --output=short-precise -u kube-node-configuration.service" > "${dir}/kube-node-configuration.log" || true
0000000000000000000000000000000000000000;;	        log-dump-ssh "${node_name}" "sudo journalctl --output=short-precise -k" > "${dir}/kern.log" || true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	        for svc in "${services[@]}"; do
0000000000000000000000000000000000000000;;	            log-dump-ssh "${node_name}" "sudo journalctl --output=cat -u ${svc}.service" > "${dir}/${svc}.log" || true
0000000000000000000000000000000000000000;;	        done
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	        files="${kern_logfile} ${files} ${initd_logfiles} ${supervisord_logfiles}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    echo "Changing logfiles to be world-readable for download"
0000000000000000000000000000000000000000;;	    log-dump-ssh "${node_name}" "sudo chmod -R a+r /var/log" || true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    echo "Copying '${files}' from ${node_name}"
0000000000000000000000000000000000000000;;	    copy-logs-from-node "${node_name}" "${dir}" "${files}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function dump_masters() {
0000000000000000000000000000000000000000;;	  local master_names
0000000000000000000000000000000000000000;;	  if [[ -n "${use_custom_instance_list}" ]]; then
0000000000000000000000000000000000000000;;	    master_names=( $(log_dump_custom_get_instances master) )
0000000000000000000000000000000000000000;;	  elif [[ ! "${master_ssh_supported_providers}" =~ "${KUBERNETES_PROVIDER}" ]]; then
0000000000000000000000000000000000000000;;	    echo "Master SSH not supported for ${KUBERNETES_PROVIDER}"
0000000000000000000000000000000000000000;;	    return
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    if ! (detect-master &> /dev/null); then
0000000000000000000000000000000000000000;;	      echo "Master not detected. Is the cluster up?"
0000000000000000000000000000000000000000;;	      return
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    master_names=( "${MASTER_NAME}" )
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "${#master_names[@]}" == 0 ]]; then
0000000000000000000000000000000000000000;;	    echo "No masters found?"
0000000000000000000000000000000000000000;;	    return
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  proc=${max_scp_processes}
0000000000000000000000000000000000000000;;	  for master_name in "${master_names[@]}"; do
0000000000000000000000000000000000000000;;	    master_dir="${report_dir}/${master_name}"
0000000000000000000000000000000000000000;;	    mkdir -p "${master_dir}"
0000000000000000000000000000000000000000;;	    save-logs "${master_name}" "${master_dir}" "${master_logfiles}" &
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # We don't want to run more than ${max_scp_processes} at a time, so
0000000000000000000000000000000000000000;;	    # wait once we hit that many nodes. This isn't ideal, since one might
0000000000000000000000000000000000000000;;	    # take much longer than the others, but it should help.
0000000000000000000000000000000000000000;;	    proc=$((proc - 1))
0000000000000000000000000000000000000000;;	    if [[ proc -eq 0 ]]; then
0000000000000000000000000000000000000000;;	      proc=${max_scp_processes}
0000000000000000000000000000000000000000;;	      wait
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  # Wait for any remaining processes.
0000000000000000000000000000000000000000;;	  if [[ proc -gt 0 && proc -lt ${max_scp_processes} ]]; then
0000000000000000000000000000000000000000;;	    wait
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function dump_nodes() {
0000000000000000000000000000000000000000;;	  local node_names
0000000000000000000000000000000000000000;;	  if [[ -n "$1" ]]; then
0000000000000000000000000000000000000000;;	    echo "Dumping logs for nodes provided as args to dump_nodes() function"
0000000000000000000000000000000000000000;;	    node_names=( "$@" )
0000000000000000000000000000000000000000;;	  elif [[ -n "${use_custom_instance_list}" ]]; then
0000000000000000000000000000000000000000;;	    echo "Dumping logs for nodes provided by log_dump_custom_get_instances() function"
0000000000000000000000000000000000000000;;	    node_names=( $(log_dump_custom_get_instances node) )
0000000000000000000000000000000000000000;;	  elif [[ ! "${node_ssh_supported_providers}" =~ "${KUBERNETES_PROVIDER}" ]]; then
0000000000000000000000000000000000000000;;	    echo "Node SSH not supported for ${KUBERNETES_PROVIDER}"
0000000000000000000000000000000000000000;;	    return
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    echo "Detecting nodes in the cluster"
0000000000000000000000000000000000000000;;	    detect-node-names &> /dev/null
0000000000000000000000000000000000000000;;	    node_names=( "${NODE_NAMES[@]}" )
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "${#node_names[@]}" == 0 ]]; then
0000000000000000000000000000000000000000;;	    echo "No nodes found!"
0000000000000000000000000000000000000000;;	    return
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  nodes_selected_for_logs=()
0000000000000000000000000000000000000000;;	  if [[ -n "${LOGDUMP_ONLY_N_RANDOM_NODES:-}" ]]; then
0000000000000000000000000000000000000000;;	    # We randomly choose 'LOGDUMP_ONLY_N_RANDOM_NODES' many nodes for fetching logs.
0000000000000000000000000000000000000000;;	    for index in `shuf -i 0-$(( ${#node_names[*]} - 1 )) -n ${LOGDUMP_ONLY_N_RANDOM_NODES}`
0000000000000000000000000000000000000000;;	    do
0000000000000000000000000000000000000000;;	      nodes_selected_for_logs+=("${node_names[$index]}")
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    nodes_selected_for_logs=( "${node_names[@]}" )
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  proc=${max_scp_processes}
0000000000000000000000000000000000000000;;	  for node_name in "${nodes_selected_for_logs[@]}"; do
0000000000000000000000000000000000000000;;	    node_dir="${report_dir}/${node_name}"
0000000000000000000000000000000000000000;;	    mkdir -p "${node_dir}"
0000000000000000000000000000000000000000;;	    # Save logs in the background. This speeds up things when there are
0000000000000000000000000000000000000000;;	    # many nodes.
0000000000000000000000000000000000000000;;	    save-logs "${node_name}" "${node_dir}" "${node_logfiles}" "${node_systemd_services}" &
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # We don't want to run more than ${max_scp_processes} at a time, so
0000000000000000000000000000000000000000;;	    # wait once we hit that many nodes. This isn't ideal, since one might
0000000000000000000000000000000000000000;;	    # take much longer than the others, but it should help.
0000000000000000000000000000000000000000;;	    proc=$((proc - 1))
0000000000000000000000000000000000000000;;	    if [[ proc -eq 0 ]]; then
0000000000000000000000000000000000000000;;	      proc=${max_scp_processes}
0000000000000000000000000000000000000000;;	      wait
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  # Wait for any remaining processes.
0000000000000000000000000000000000000000;;	  if [[ proc -gt 0 && proc -lt ${max_scp_processes} ]]; then
0000000000000000000000000000000000000000;;	    wait
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function dump_nodes_with_logexporter() {
0000000000000000000000000000000000000000;;	  echo "Detecting nodes in the cluster"
0000000000000000000000000000000000000000;;	  detect-node-names &> /dev/null
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "${#NODE_NAMES[@]}" == 0 ]]; then
0000000000000000000000000000000000000000;;	    echo "No nodes found!"
0000000000000000000000000000000000000000;;	    return
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Obtain parameters required by logexporter.
0000000000000000000000000000000000000000;;	  local -r service_account_credentials="$(cat ${GOOGLE_APPLICATION_CREDENTIALS} | base64)"
0000000000000000000000000000000000000000;;	  local -r cloud_provider="${KUBERNETES_PROVIDER}"
0000000000000000000000000000000000000000;;	  local -r gcs_artifacts_dir="${GCS_ARTIFACTS_DIR}"
0000000000000000000000000000000000000000;;	  local -r enable_hollow_node_logs="${ENABLE_HOLLOW_NODE_LOGS:-false}"
0000000000000000000000000000000000000000;;	  local -r logexport_timeout_seconds="$(( 30 + NUM_NODES / 10 ))"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Fill in the parameters in the logexporter daemonset template.
0000000000000000000000000000000000000000;;	  sed -i'' -e "s/{{.ServiceAccountCredentials}}/${service_account_credentials}/g" "${KUBE_ROOT}/cluster/log-dump/logexporter-daemonset.yaml"
0000000000000000000000000000000000000000;;	  sed -i'' -e "s/{{.CloudProvider}}/${cloud_provider}/g" "${KUBE_ROOT}/cluster/log-dump/logexporter-daemonset.yaml"
0000000000000000000000000000000000000000;;	  sed -i'' -e "s/{{.GCSPath}}/${gcs_artifacts_dir}/g" "${KUBE_ROOT}/cluster/log-dump/logexporter-daemonset.yaml"
0000000000000000000000000000000000000000;;	  sed -i'' -e "s/{{.EnableHollowNodeLogs}}/${enable_hollow_node_logs}/g" "${KUBE_ROOT}/cluster/log-dump/logexporter-daemonset.yaml"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Create the logexporter namespace, service-account secret and the logexporter daemonset within that namespace.
0000000000000000000000000000000000000000;;	  KUBECTL="${KUBECTL:-${KUBE_ROOT}/cluster/kubectl.sh}"
0000000000000000000000000000000000000000;;	  "${KUBECTL}" create -f "${KUBE_ROOT}/cluster/log-dump/logexporter-daemonset.yaml"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Give some time for the pods to finish uploading logs.
0000000000000000000000000000000000000000;;	  sleep "${logexport_sleep_seconds}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # List the logexporter pods created and their corresponding nodes.
0000000000000000000000000000000000000000;;	  pods_and_nodes=()
0000000000000000000000000000000000000000;;	  for retry in {1..5}; do
0000000000000000000000000000000000000000;;	    pods_and_nodes=$(${KUBECTL} get pods -n logexporter -o=custom-columns=NAME:.metadata.name,NODE:.spec.nodeName | tail -n +2)
0000000000000000000000000000000000000000;;	    if [[ -n "${pods_and_nodes}" ]]; then
0000000000000000000000000000000000000000;;	      echo -e "List of logexporter pods found:\n${pods_and_nodes}"
0000000000000000000000000000000000000000;;	      break
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [[ "${retry}" == 5 ]]; then
0000000000000000000000000000000000000000;;	      echo "Failed to list any logexporter pods after multiple retries.. falling back to logdump for nodes through SSH"
0000000000000000000000000000000000000000;;	      "${KUBECTL}" delete namespace logexporter
0000000000000000000000000000000000000000;;	      dump_nodes "${NODE_NAMES[@]}"
0000000000000000000000000000000000000000;;	      return
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Collect names of nodes we didn't find a logexporter pod on.
0000000000000000000000000000000000000000;;	  # Note: This step is O(#nodes^2) as we check if each node is present in the list of nodes running logexporter.
0000000000000000000000000000000000000000;;	  # Making it linear would add code complexity without much benefit (as it just takes < 1s for 5k nodes anyway).
0000000000000000000000000000000000000000;;	  failed_nodes=()
0000000000000000000000000000000000000000;;	  for node in "${NODE_NAMES[@]}"; do
0000000000000000000000000000000000000000;;	    if [[ ! "${pods_and_nodes}" =~ "${node}" ]]; then
0000000000000000000000000000000000000000;;	      failed_nodes+=("${node}")
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Collect names of nodes whose logexporter pod didn't succeed.
0000000000000000000000000000000000000000;;	  # TODO(shyamjvs): Parallelize the for loop below to make it faster (if needed).
0000000000000000000000000000000000000000;;	  logexporter_pods=( $(echo "${pods_and_nodes}" | awk '{print $1}') )
0000000000000000000000000000000000000000;;	  logexporter_nodes=( $(echo "${pods_and_nodes}" | awk '{print $2}') )
0000000000000000000000000000000000000000;;	  for index in "${!logexporter_pods[@]}"; do
0000000000000000000000000000000000000000;;	    pod="${logexporter_pods[$index]}"
0000000000000000000000000000000000000000;;	    node="${logexporter_nodes[$index]}"
0000000000000000000000000000000000000000;;	    # TODO(shyamjvs): Use a /status endpoint on the pod instead of checking its logs if that's faster.
0000000000000000000000000000000000000000;;	    pod_success_log=$(${KUBECTL} get logs ${pod} -n logexporter 2>&1 | grep "Logs successfully uploaded") || true
0000000000000000000000000000000000000000;;	    if [[ -z "${pod_success_log}" ]]; then
0000000000000000000000000000000000000000;;	      failed_nodes+=("${node}")
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Delete the logexporter resources and dump logs for the failed nodes (if any) through SSH.
0000000000000000000000000000000000000000;;	  "${KUBECTL}" delete namespace logexporter
0000000000000000000000000000000000000000;;	  if [[ "${#failed_nodes[@]}" != 0 ]]; then
0000000000000000000000000000000000000000;;	    echo -e "Dumping logs through SSH for nodes logexporter failed to succeed on:\n${failed_nodes[@]}"
0000000000000000000000000000000000000000;;	    dump_nodes "${failed_nodes[@]}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function main() {
0000000000000000000000000000000000000000;;	  setup
0000000000000000000000000000000000000000;;	  # Copy master logs to artifacts dir locally (through SSH).
0000000000000000000000000000000000000000;;	  echo "Dumping logs from master locally to '${report_dir}'"
0000000000000000000000000000000000000000;;	  dump_masters
0000000000000000000000000000000000000000;;	  if [[ "${DUMP_ONLY_MASTER_LOGS:-}" == "true" ]]; then
0000000000000000000000000000000000000000;;	    echo "Skipping dumping of node logs"
0000000000000000000000000000000000000000;;	    return
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Copy logs from nodes to GCS directly or to artifacts dir locally (through SSH).
0000000000000000000000000000000000000000;;	  if [[ "${ENABLE_LOGEXPORTER:-}" == "true" ]]; then
0000000000000000000000000000000000000000;;	    if [[ -z "${GCS_ARTIFACTS_DIR:-}" ]]; then
0000000000000000000000000000000000000000;;	      echo "Env var GCS_ARTIFACTS_DIR is empty. Failed to dump node logs to GCS."
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    echo "Dumping logs from nodes to GCS directly at '${GCS_ARTIFACTS_DIR}'"
0000000000000000000000000000000000000000;;	    dump_nodes_with_logexporter
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    echo "Dumping logs from nodes locally to '${report_dir}'"
0000000000000000000000000000000000000000;;	    dump_nodes
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	main
