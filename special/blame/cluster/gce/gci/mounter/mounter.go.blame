0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
642dbab5c8d40ef7c3fd974f77b9350481ceb90d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Location of the mount file to use
0000000000000000000000000000000000000000;;		chrootCmd        = "chroot"
0000000000000000000000000000000000000000;;		mountCmd         = "mount"
0000000000000000000000000000000000000000;;		rootfs           = "rootfs"
0000000000000000000000000000000000000000;;		nfsRPCBindErrMsg = "mount.nfs: rpc.statd is not running but is required for remote locking.\nmount.nfs: Either use '-o nolock' to keep locks local, or start statd.\nmount.nfs: an incorrect mount option was specified\n"
0000000000000000000000000000000000000000;;		rpcBindCmd       = "/sbin/rpcbind"
0000000000000000000000000000000000000000;;		defaultRootfs    = "/home/kubernetes/containerized_mounter/rootfs"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(os.Args) < 2 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "Command failed: must provide a command to run.\n")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		path, _ := filepath.Split(os.Args[0])
0000000000000000000000000000000000000000;;		rootfsPath := filepath.Join(path, rootfs)
0000000000000000000000000000000000000000;;		if _, err := os.Stat(rootfsPath); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			rootfsPath = defaultRootfs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		command := os.Args[1]
0000000000000000000000000000000000000000;;		switch command {
0000000000000000000000000000000000000000;;		case mountCmd:
0000000000000000000000000000000000000000;;			mountErr := mountInChroot(rootfsPath, os.Args[2:])
0000000000000000000000000000000000000000;;			if mountErr != nil {
0000000000000000000000000000000000000000;;				fmt.Fprintf(os.Stderr, "Mount failed: %v", mountErr)
0000000000000000000000000000000000000000;;				os.Exit(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "Unknown command, must be %s", mountCmd)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MountInChroot is to run mount within chroot with the passing root directory
0000000000000000000000000000000000000000;;	func mountInChroot(rootfsPath string, args []string) error {
0000000000000000000000000000000000000000;;		if _, err := os.Stat(rootfsPath); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("path <%s> does not exist", rootfsPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		args = append([]string{rootfsPath, mountCmd}, args...)
0000000000000000000000000000000000000000;;		output, err := exec.Command(chrootCmd, args...).CombinedOutput()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !strings.EqualFold(string(output), nfsRPCBindErrMsg) {
0000000000000000000000000000000000000000;;			// Mount failed but not because of RPC bind error
0000000000000000000000000000000000000000;;			return fmt.Errorf("mount failed: %v\nMounting command: %s\nMounting arguments: %v\nOutput: %s", err, chrootCmd, args, string(output))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Mount failed because it is NFS V3 and we need to run rpcBind
0000000000000000000000000000000000000000;;		output, err = exec.Command(chrootCmd, rootfsPath, rpcBindCmd, "-w").CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Mount issued for NFS V3 but unable to run rpcbind:\n Output: %s\n Error: %v", string(output), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rpcbind is running, try mounting again
0000000000000000000000000000000000000000;;		output, err = exec.Command(chrootCmd, args...).CombinedOutput()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Mount failed for NFS V3 even after running rpcBind %s, %v", string(output), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
