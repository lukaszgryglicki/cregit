0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2017 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# A library of helper functions and constant for the local config.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Use the config file specified in $KUBE_CONFIG_FILE, or default to
0000000000000000000000000000000000000000;;	# config-default.sh.
0000000000000000000000000000000000000000;;	KUBE_ROOT=$(dirname "${BASH_SOURCE}")/../..
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/cluster/gce/${KUBE_CONFIG_FILE-"config-default.sh"}"
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/cluster/common.sh"
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/hack/lib/util.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "${NODE_OS_DISTRIBUTION}" == "debian" || "${NODE_OS_DISTRIBUTION}" == "container-linux" || "${NODE_OS_DISTRIBUTION}" == "trusty" || "${NODE_OS_DISTRIBUTION}" == "gci" || "${NODE_OS_DISTRIBUTION}" == "ubuntu" ]]; then
0000000000000000000000000000000000000000;;	  source "${KUBE_ROOT}/cluster/gce/${NODE_OS_DISTRIBUTION}/node-helper.sh"
0000000000000000000000000000000000000000;;	else
0000000000000000000000000000000000000000;;	  echo "Cannot operate on cluster using node os distro: ${NODE_OS_DISTRIBUTION}" >&2
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "${MASTER_OS_DISTRIBUTION}" == "container-linux" || "${MASTER_OS_DISTRIBUTION}" == "trusty" || "${MASTER_OS_DISTRIBUTION}" == "gci" || "${MASTER_OS_DISTRIBUTION}" == "ubuntu" ]]; then
0000000000000000000000000000000000000000;;	  source "${KUBE_ROOT}/cluster/gce/${MASTER_OS_DISTRIBUTION}/master-helper.sh"
0000000000000000000000000000000000000000;;	else
0000000000000000000000000000000000000000;;	  echo "Cannot operate on cluster using master os distro: ${MASTER_OS_DISTRIBUTION}" >&2
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "${MASTER_OS_DISTRIBUTION}" == "gci" ]]; then
0000000000000000000000000000000000000000;;	    DEFAULT_GCI_PROJECT=google-containers
0000000000000000000000000000000000000000;;	    if [[ "${GCI_VERSION}" == "cos"* ]]; then
0000000000000000000000000000000000000000;;	        DEFAULT_GCI_PROJECT=cos-cloud
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    MASTER_IMAGE_PROJECT=${KUBE_GCE_MASTER_PROJECT:-${DEFAULT_GCI_PROJECT}}
0000000000000000000000000000000000000000;;	    # If the master image is not set, we use the latest GCI image.
0000000000000000000000000000000000000000;;	    # Otherwise, we respect whatever is set by the user.
0000000000000000000000000000000000000000;;	    MASTER_IMAGE=${KUBE_GCE_MASTER_IMAGE:-${GCI_VERSION}}
0000000000000000000000000000000000000000;;	elif [[ "${MASTER_OS_DISTRIBUTION}" == "debian" ]]; then
0000000000000000000000000000000000000000;;	    MASTER_IMAGE=${KUBE_GCE_MASTER_IMAGE:-${CVM_VERSION}}
0000000000000000000000000000000000000000;;	    MASTER_IMAGE_PROJECT=${KUBE_GCE_MASTER_PROJECT:-google-containers}
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Sets node image based on the specified os distro. Currently this function only
0000000000000000000000000000000000000000;;	# supports gci and debian.
0000000000000000000000000000000000000000;;	function set-node-image() {
0000000000000000000000000000000000000000;;	    if [[ "${NODE_OS_DISTRIBUTION}" == "gci" ]]; then
0000000000000000000000000000000000000000;;	        DEFAULT_GCI_PROJECT=google-containers
0000000000000000000000000000000000000000;;	        if [[ "${GCI_VERSION}" == "cos"* ]]; then
0000000000000000000000000000000000000000;;	            DEFAULT_GCI_PROJECT=cos-cloud
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	        # If the node image is not set, we use the latest GCI image.
0000000000000000000000000000000000000000;;	        # Otherwise, we respect whatever is set by the user.
0000000000000000000000000000000000000000;;	        NODE_IMAGE=${KUBE_GCE_NODE_IMAGE:-${GCI_VERSION}}
0000000000000000000000000000000000000000;;	        NODE_IMAGE_PROJECT=${KUBE_GCE_NODE_PROJECT:-${DEFAULT_GCI_PROJECT}}
0000000000000000000000000000000000000000;;	    elif [[ "${NODE_OS_DISTRIBUTION}" == "debian" ]]; then
0000000000000000000000000000000000000000;;	        NODE_IMAGE=${KUBE_GCE_NODE_IMAGE:-${CVM_VERSION}}
0000000000000000000000000000000000000000;;	        NODE_IMAGE_PROJECT=${KUBE_GCE_NODE_PROJECT:-google-containers}
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	set-node-image
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Verfiy cluster autoscaler configuration.
0000000000000000000000000000000000000000;;	if [[ "${ENABLE_CLUSTER_AUTOSCALER}" == "true" ]]; then
0000000000000000000000000000000000000000;;	  if [[ -z $AUTOSCALER_MIN_NODES ]]; then
0000000000000000000000000000000000000000;;	    echo "AUTOSCALER_MIN_NODES not set."
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [[ -z $AUTOSCALER_MAX_NODES ]]; then
0000000000000000000000000000000000000000;;	    echo "AUTOSCALER_MAX_NODES not set."
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	NODE_INSTANCE_PREFIX="${INSTANCE_PREFIX}-minion"
0000000000000000000000000000000000000000;;	NODE_TAGS="${NODE_TAG}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	ALLOCATE_NODE_CIDRS=true
0000000000000000000000000000000000000000;;	PREEXISTING_NETWORK=false
0000000000000000000000000000000000000000;;	PREEXISTING_NETWORK_MODE=""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_PROMPT_FOR_UPDATE=${KUBE_PROMPT_FOR_UPDATE:-"n"}
0000000000000000000000000000000000000000;;	# How long (in seconds) to wait for cluster initialization.
0000000000000000000000000000000000000000;;	KUBE_CLUSTER_INITIALIZATION_TIMEOUT=${KUBE_CLUSTER_INITIALIZATION_TIMEOUT:-300}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function join_csv() {
0000000000000000000000000000000000000000;;	  local IFS=','; echo "$*";
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This function returns the first string before the comma
0000000000000000000000000000000000000000;;	function split_csv() {
0000000000000000000000000000000000000000;;	  echo "$*" | cut -d',' -f1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Verify prereqs
0000000000000000000000000000000000000000;;	function verify-prereqs() {
0000000000000000000000000000000000000000;;	  local cmd
0000000000000000000000000000000000000000;;	  for cmd in gcloud gsutil; do
0000000000000000000000000000000000000000;;	    if ! which "${cmd}" >/dev/null; then
0000000000000000000000000000000000000000;;	      local resp="n"
0000000000000000000000000000000000000000;;	      if [[ "${KUBE_PROMPT_FOR_UPDATE}" == "y" ]]; then
0000000000000000000000000000000000000000;;	        echo "Can't find ${cmd} in PATH.  Do you wish to install the Google Cloud SDK? [Y/n]"
0000000000000000000000000000000000000000;;	        read resp
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	      if [[ "${resp}" != "n" && "${resp}" != "N" ]]; then
0000000000000000000000000000000000000000;;	        curl https://sdk.cloud.google.com | bash
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	      if ! which "${cmd}" >/dev/null; then
0000000000000000000000000000000000000000;;	        echo "Can't find ${cmd} in PATH, please fix and retry. The Google Cloud " >&2
0000000000000000000000000000000000000000;;	        echo "SDK can be downloaded from https://cloud.google.com/sdk/." >&2
0000000000000000000000000000000000000000;;	        exit 1
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  update-or-verify-gcloud
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Use the gcloud defaults to find the project.  If it is already set in the
0000000000000000000000000000000000000000;;	# environment then go with that.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   PROJECT
0000000000000000000000000000000000000000;;	#   PROJECT_REPORTED
0000000000000000000000000000000000000000;;	function detect-project() {
0000000000000000000000000000000000000000;;	  if [[ -z "${PROJECT-}" ]]; then
0000000000000000000000000000000000000000;;	    PROJECT=$(gcloud config list project --format 'value(core.project)')
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ -z "${PROJECT-}" ]]; then
0000000000000000000000000000000000000000;;	    echo "Could not detect Google Cloud Platform project.  Set the default project using " >&2
0000000000000000000000000000000000000000;;	    echo "'gcloud config set project <PROJECT>'" >&2
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [[ -z "${PROJECT_REPORTED-}" ]]; then
0000000000000000000000000000000000000000;;	    echo "Project: ${PROJECT}" >&2
0000000000000000000000000000000000000000;;	    echo "Zone: ${ZONE}" >&2
0000000000000000000000000000000000000000;;	    PROJECT_REPORTED=true
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Use gsutil to get the md5 hash for a particular tar
0000000000000000000000000000000000000000;;	function gsutil_get_tar_md5() {
0000000000000000000000000000000000000000;;	  # location_tar could be local or in the cloud
0000000000000000000000000000000000000000;;	  # local tar_location example ./_output/release-tars/kubernetes-server-linux-amd64.tar.gz
0000000000000000000000000000000000000000;;	  # cloud tar_location example gs://kubernetes-staging-PROJECT/kubernetes-devel/kubernetes-server-linux-amd64.tar.gz
0000000000000000000000000000000000000000;;	  local -r tar_location=$1
0000000000000000000000000000000000000000;;	  #parse the output and return the md5 hash
0000000000000000000000000000000000000000;;	  #the sed command at the end removes whitespace
0000000000000000000000000000000000000000;;	  local -r tar_md5=$(gsutil hash -h -m ${tar_location} 2>/dev/null | grep "Hash (md5):" | awk -F ':' '{print $2}' | sed 's/^[[:space:]]*//g')
0000000000000000000000000000000000000000;;	  echo "${tar_md5}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copy a release tar and its accompanying hash.
0000000000000000000000000000000000000000;;	function copy-to-staging() {
0000000000000000000000000000000000000000;;	  local -r staging_path=$1
0000000000000000000000000000000000000000;;	  local -r gs_url=$2
0000000000000000000000000000000000000000;;	  local -r tar=$3
0000000000000000000000000000000000000000;;	  local -r hash=$4
0000000000000000000000000000000000000000;;	  local -r basename_tar=$(basename ${tar})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  #check whether this tar alread exists and has the same hash
0000000000000000000000000000000000000000;;	  #if it matches, then don't bother uploading it again
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  #remote_tar_md5 checks the remote location for the existing tarball and its md5
0000000000000000000000000000000000000000;;	  #staging_path example gs://kubernetes-staging-PROJECT/kubernetes-devel
0000000000000000000000000000000000000000;;	  #basename_tar example kubernetes-server-linux-amd64.tar.gz
0000000000000000000000000000000000000000;;	  local -r remote_tar_md5=$(gsutil_get_tar_md5 "${staging_path}/${basename_tar}")
0000000000000000000000000000000000000000;;	  if [[ -n ${remote_tar_md5} ]]; then
0000000000000000000000000000000000000000;;	    #local_tar_md5 checks the remote location for the existing tarball and its md5 hash
0000000000000000000000000000000000000000;;	    #tar example ./_output/release-tars/kubernetes-server-linux-amd64.tar.gz
0000000000000000000000000000000000000000;;	    local -r local_tar_md5=$(gsutil_get_tar_md5 "${tar}")
0000000000000000000000000000000000000000;;	    if [[ "${remote_tar_md5}" == "${local_tar_md5}" ]]; then
0000000000000000000000000000000000000000;;	      echo "+++ ${basename_tar} uploaded earlier, cloud and local file md5 match (md5 = ${local_tar_md5})"
0000000000000000000000000000000000000000;;	      return 0
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "${hash}" > "${tar}.sha1"
0000000000000000000000000000000000000000;;	  gsutil -m -q -h "Cache-Control:private, max-age=0" cp "${tar}" "${tar}.sha1" "${staging_path}"
0000000000000000000000000000000000000000;;	  gsutil -m acl ch -g all:R "${gs_url}" "${gs_url}.sha1" >/dev/null 2>&1
0000000000000000000000000000000000000000;;	  echo "+++ ${basename_tar} uploaded (sha1 = ${hash})"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Given the cluster zone, return the list of regional GCS release
0000000000000000000000000000000000000000;;	# bucket suffixes for the release in preference order. GCS doesn't
0000000000000000000000000000000000000000;;	# give us an API for this, so we hardcode it.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   RELEASE_REGION_FALLBACK
0000000000000000000000000000000000000000;;	#   REGIONAL_KUBE_ADDONS
0000000000000000000000000000000000000000;;	#   ZONE
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   PREFERRED_REGION
0000000000000000000000000000000000000000;;	#   KUBE_ADDON_REGISTRY
0000000000000000000000000000000000000000;;	function set-preferred-region() {
0000000000000000000000000000000000000000;;	  case ${ZONE} in
0000000000000000000000000000000000000000;;	    asia-*)
0000000000000000000000000000000000000000;;	      PREFERRED_REGION=("asia" "us" "eu")
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	    europe-*)
0000000000000000000000000000000000000000;;	      PREFERRED_REGION=("eu" "us" "asia")
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	    *)
0000000000000000000000000000000000000000;;	      PREFERRED_REGION=("us" "eu" "asia")
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	  esac
0000000000000000000000000000000000000000;;	  local -r preferred="${PREFERRED_REGION[0]}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "${RELEASE_REGION_FALLBACK}" != "true" ]]; then
0000000000000000000000000000000000000000;;	    PREFERRED_REGION=( "${preferred}" )
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # If we're using regional GCR, and we're outside the US, go to the
0000000000000000000000000000000000000000;;	  # regional registry. The gcr.io/google_containers registry is
0000000000000000000000000000000000000000;;	  # appropriate for US (for now).
0000000000000000000000000000000000000000;;	  if [[ "${REGIONAL_KUBE_ADDONS}" == "true" ]] && [[ "${preferred}" != "us" ]]; then
0000000000000000000000000000000000000000;;	    KUBE_ADDON_REGISTRY="${preferred}.gcr.io/google_containers"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    KUBE_ADDON_REGISTRY="gcr.io/google_containers"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "${ENABLE_DOCKER_REGISTRY_CACHE:-}" == "true" ]]; then
0000000000000000000000000000000000000000;;	    DOCKER_REGISTRY_MIRROR_URL="https://${preferred}-mirror.gcr.io"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Take the local tar files and upload them to Google Storage.  They will then be
0000000000000000000000000000000000000000;;	# downloaded by the master as part of the start up script for the master.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   PROJECT
0000000000000000000000000000000000000000;;	#   SERVER_BINARY_TAR
0000000000000000000000000000000000000000;;	#   SALT_TAR
0000000000000000000000000000000000000000;;	#   KUBE_MANIFESTS_TAR
0000000000000000000000000000000000000000;;	#   ZONE
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   SERVER_BINARY_TAR_URL
0000000000000000000000000000000000000000;;	#   SERVER_BINARY_TAR_HASH
0000000000000000000000000000000000000000;;	#   SALT_TAR_URL
0000000000000000000000000000000000000000;;	#   SALT_TAR_HASH
0000000000000000000000000000000000000000;;	#   KUBE_MANIFESTS_TAR_URL
0000000000000000000000000000000000000000;;	#   KUBE_MANIFESTS_TAR_HASH
0000000000000000000000000000000000000000;;	function upload-server-tars() {
0000000000000000000000000000000000000000;;	  SERVER_BINARY_TAR_URL=
0000000000000000000000000000000000000000;;	  SERVER_BINARY_TAR_HASH=
0000000000000000000000000000000000000000;;	  SALT_TAR_URL=
0000000000000000000000000000000000000000;;	  SALT_TAR_HASH=
0000000000000000000000000000000000000000;;	  KUBE_MANIFESTS_TAR_URL=
0000000000000000000000000000000000000000;;	  KUBE_MANIFESTS_TAR_HASH=
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local project_hash
0000000000000000000000000000000000000000;;	  if which md5 > /dev/null 2>&1; then
0000000000000000000000000000000000000000;;	    project_hash=$(md5 -q -s "$PROJECT")
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    project_hash=$(echo -n "$PROJECT" | md5sum | awk '{ print $1 }')
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # This requires 1 million projects before the probability of collision is 50%
0000000000000000000000000000000000000000;;	  # that's probably good enough for now :P
0000000000000000000000000000000000000000;;	  project_hash=${project_hash:0:10}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  set-preferred-region
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  SERVER_BINARY_TAR_HASH=$(sha1sum-file "${SERVER_BINARY_TAR}")
0000000000000000000000000000000000000000;;	  SALT_TAR_HASH=$(sha1sum-file "${SALT_TAR}")
0000000000000000000000000000000000000000;;	  if [[ -n "${KUBE_MANIFESTS_TAR:-}" ]]; then
0000000000000000000000000000000000000000;;	    KUBE_MANIFESTS_TAR_HASH=$(sha1sum-file "${KUBE_MANIFESTS_TAR}")
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local server_binary_tar_urls=()
0000000000000000000000000000000000000000;;	  local salt_tar_urls=()
0000000000000000000000000000000000000000;;	  local kube_manifest_tar_urls=()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for region in "${PREFERRED_REGION[@]}"; do
0000000000000000000000000000000000000000;;	    suffix="-${region}"
0000000000000000000000000000000000000000;;	    if [[ "${suffix}" == "-us" ]]; then
0000000000000000000000000000000000000000;;	      suffix=""
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    local staging_bucket="gs://kubernetes-staging-${project_hash}${suffix}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Ensure the buckets are created
0000000000000000000000000000000000000000;;	    if ! gsutil ls "${staging_bucket}" >/dev/null; then
0000000000000000000000000000000000000000;;	      echo "Creating ${staging_bucket}"
0000000000000000000000000000000000000000;;	      gsutil mb -l "${region}" "${staging_bucket}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    local staging_path="${staging_bucket}/${INSTANCE_PREFIX}-devel"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    echo "+++ Staging server tars to Google Storage: ${staging_path}"
0000000000000000000000000000000000000000;;	    local server_binary_gs_url="${staging_path}/${SERVER_BINARY_TAR##*/}"
0000000000000000000000000000000000000000;;	    local salt_gs_url="${staging_path}/${SALT_TAR##*/}"
0000000000000000000000000000000000000000;;	    copy-to-staging "${staging_path}" "${server_binary_gs_url}" "${SERVER_BINARY_TAR}" "${SERVER_BINARY_TAR_HASH}"
0000000000000000000000000000000000000000;;	    copy-to-staging "${staging_path}" "${salt_gs_url}" "${SALT_TAR}" "${SALT_TAR_HASH}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Convert from gs:// URL to an https:// URL
0000000000000000000000000000000000000000;;	    server_binary_tar_urls+=("${server_binary_gs_url/gs:\/\//https://storage.googleapis.com/}")
0000000000000000000000000000000000000000;;	    salt_tar_urls+=("${salt_gs_url/gs:\/\//https://storage.googleapis.com/}")
0000000000000000000000000000000000000000;;	    if [[ -n "${KUBE_MANIFESTS_TAR:-}" ]]; then
0000000000000000000000000000000000000000;;	      local kube_manifests_gs_url="${staging_path}/${KUBE_MANIFESTS_TAR##*/}"
0000000000000000000000000000000000000000;;	      copy-to-staging "${staging_path}" "${kube_manifests_gs_url}" "${KUBE_MANIFESTS_TAR}" "${KUBE_MANIFESTS_TAR_HASH}"
0000000000000000000000000000000000000000;;	      # Convert from gs:// URL to an https:// URL
0000000000000000000000000000000000000000;;	      kube_manifests_tar_urls+=("${kube_manifests_gs_url/gs:\/\//https://storage.googleapis.com/}")
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  SERVER_BINARY_TAR_URL=$(join_csv "${server_binary_tar_urls[@]}")
0000000000000000000000000000000000000000;;	  SALT_TAR_URL=$(join_csv "${salt_tar_urls[@]}")
0000000000000000000000000000000000000000;;	  if [[ -n "${KUBE_MANIFESTS_TAR:-}" ]]; then
0000000000000000000000000000000000000000;;	    KUBE_MANIFESTS_TAR_URL=$(join_csv "${kube_manifests_tar_urls[@]}")
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Detect minions created in the minion group
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   NODE_INSTANCE_PREFIX
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   NODE_NAMES
0000000000000000000000000000000000000000;;	#   INSTANCE_GROUPS
0000000000000000000000000000000000000000;;	function detect-node-names() {
0000000000000000000000000000000000000000;;	  detect-project
0000000000000000000000000000000000000000;;	  INSTANCE_GROUPS=()
0000000000000000000000000000000000000000;;	  INSTANCE_GROUPS+=($(gcloud compute instance-groups managed list \
0000000000000000000000000000000000000000;;	    --zones "${ZONE}" --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --regexp "${NODE_INSTANCE_PREFIX}-.+" \
0000000000000000000000000000000000000000;;	    --format='value(instanceGroup)' || true))
0000000000000000000000000000000000000000;;	  NODE_NAMES=()
0000000000000000000000000000000000000000;;	  if [[ -n "${INSTANCE_GROUPS[@]:-}" ]]; then
0000000000000000000000000000000000000000;;	    for group in "${INSTANCE_GROUPS[@]}"; do
0000000000000000000000000000000000000000;;	      NODE_NAMES+=($(gcloud compute instance-groups managed list-instances \
0000000000000000000000000000000000000000;;	        "${group}" --zone "${ZONE}" --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	        --format='value(instance)'))
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  # Add heapster node name to the list too (if it exists).
0000000000000000000000000000000000000000;;	  if [[ -n "${HEAPSTER_MACHINE_TYPE:-}" ]]; then
0000000000000000000000000000000000000000;;	    NODE_NAMES+=("${NODE_INSTANCE_PREFIX}-heapster")
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "INSTANCE_GROUPS=${INSTANCE_GROUPS[*]:-}" >&2
0000000000000000000000000000000000000000;;	  echo "NODE_NAMES=${NODE_NAMES[*]:-}" >&2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Detect the information about the minions
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   ZONE
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   NODE_NAMES
0000000000000000000000000000000000000000;;	#   KUBE_NODE_IP_ADDRESSES (array)
0000000000000000000000000000000000000000;;	function detect-nodes() {
0000000000000000000000000000000000000000;;	  detect-project
0000000000000000000000000000000000000000;;	  detect-node-names
0000000000000000000000000000000000000000;;	  KUBE_NODE_IP_ADDRESSES=()
0000000000000000000000000000000000000000;;	  for (( i=0; i<${#NODE_NAMES[@]}; i++)); do
0000000000000000000000000000000000000000;;	    local node_ip=$(gcloud compute instances describe --project "${PROJECT}" --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	      "${NODE_NAMES[$i]}" --format='value(networkInterfaces[0].accessConfigs[0].natIP)')
0000000000000000000000000000000000000000;;	    if [[ -z "${node_ip-}" ]] ; then
0000000000000000000000000000000000000000;;	      echo "Did not find ${NODE_NAMES[$i]}" >&2
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      echo "Found ${NODE_NAMES[$i]} at ${node_ip}"
0000000000000000000000000000000000000000;;	      KUBE_NODE_IP_ADDRESSES+=("${node_ip}")
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  if [[ -z "${KUBE_NODE_IP_ADDRESSES-}" ]]; then
0000000000000000000000000000000000000000;;	    echo "Could not detect Kubernetes minion nodes.  Make sure you've launched a cluster with 'kube-up.sh'" >&2
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Detect the IP for the master
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   MASTER_NAME
0000000000000000000000000000000000000000;;	#   ZONE
0000000000000000000000000000000000000000;;	#   REGION
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   KUBE_MASTER
0000000000000000000000000000000000000000;;	#   KUBE_MASTER_IP
0000000000000000000000000000000000000000;;	function detect-master() {
0000000000000000000000000000000000000000;;	  detect-project
0000000000000000000000000000000000000000;;	  KUBE_MASTER=${MASTER_NAME}
0000000000000000000000000000000000000000;;	  echo "Trying to find master named '${MASTER_NAME}'" >&2
0000000000000000000000000000000000000000;;	  if [[ -z "${KUBE_MASTER_IP-}" ]]; then
0000000000000000000000000000000000000000;;	    local master_address_name="${MASTER_NAME}-ip"
0000000000000000000000000000000000000000;;	    echo "Looking for address '${master_address_name}'" >&2
0000000000000000000000000000000000000000;;	    KUBE_MASTER_IP=$(gcloud compute addresses describe "${master_address_name}" \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" --region "${REGION}" -q --format='value(address)')
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [[ -z "${KUBE_MASTER_IP-}" ]]; then
0000000000000000000000000000000000000000;;	    echo "Could not detect Kubernetes master node.  Make sure you've launched a cluster with 'kube-up.sh'" >&2
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  echo "Using master: $KUBE_MASTER (external IP: $KUBE_MASTER_IP)" >&2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Reads kube-env metadata from master
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   KUBE_MASTER
0000000000000000000000000000000000000000;;	#   PROJECT
0000000000000000000000000000000000000000;;	#   ZONE
0000000000000000000000000000000000000000;;	function get-master-env() {
0000000000000000000000000000000000000000;;	  # TODO(zmerlynn): Make this more reliable with retries.
0000000000000000000000000000000000000000;;	  gcloud compute --project ${PROJECT} ssh --zone ${ZONE} ${KUBE_MASTER} --command \
0000000000000000000000000000000000000000;;	    "curl --fail --silent -H 'Metadata-Flavor: Google' \
0000000000000000000000000000000000000000;;	      'http://metadata/computeMetadata/v1/instance/attributes/kube-env'" 2>/dev/null
0000000000000000000000000000000000000000;;	  gcloud compute --project ${PROJECT} ssh --zone ${ZONE} ${KUBE_MASTER} --command \
0000000000000000000000000000000000000000;;	    "curl --fail --silent -H 'Metadata-Flavor: Google' \
0000000000000000000000000000000000000000;;	      'http://metadata/computeMetadata/v1/instance/attributes/kube-master-certs'" 2>/dev/null
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Robustly try to create a static ip.
0000000000000000000000000000000000000000;;	# $1: The name of the ip to create
0000000000000000000000000000000000000000;;	# $2: The name of the region to create the ip in.
0000000000000000000000000000000000000000;;	function create-static-ip() {
0000000000000000000000000000000000000000;;	  detect-project
0000000000000000000000000000000000000000;;	  local attempt=0
0000000000000000000000000000000000000000;;	  local REGION="$2"
0000000000000000000000000000000000000000;;	  while true; do
0000000000000000000000000000000000000000;;	    if gcloud compute addresses create "$1" \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	      --region "${REGION}" -q > /dev/null; then
0000000000000000000000000000000000000000;;	      # successful operation - wait until it's visible
0000000000000000000000000000000000000000;;	      start="$(date +%s)"
0000000000000000000000000000000000000000;;	      while true; do
0000000000000000000000000000000000000000;;	        now="$(date +%s)"
0000000000000000000000000000000000000000;;	        # Timeout set to 15 minutes
0000000000000000000000000000000000000000;;	        if [[ $((now - start)) -gt 900 ]]; then
0000000000000000000000000000000000000000;;	          echo "Timeout while waiting for master IP visibility"
0000000000000000000000000000000000000000;;	          exit 2
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	        if gcloud compute addresses describe "$1" --project "${PROJECT}" --region "${REGION}" >/dev/null 2>&1; then
0000000000000000000000000000000000000000;;	          break
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	        echo "Master IP not visible yet. Waiting..."
0000000000000000000000000000000000000000;;	        sleep 5
0000000000000000000000000000000000000000;;	      done
0000000000000000000000000000000000000000;;	      break
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if gcloud compute addresses describe "$1" \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	      --region "${REGION}" >/dev/null 2>&1; then
0000000000000000000000000000000000000000;;	      # it exists - postcondition satisfied
0000000000000000000000000000000000000000;;	      break
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if (( attempt > 4 )); then
0000000000000000000000000000000000000000;;	      echo -e "${color_red}Failed to create static ip $1 ${color_norm}" >&2
0000000000000000000000000000000000000000;;	      exit 2
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    attempt=$(($attempt+1))
0000000000000000000000000000000000000000;;	    echo -e "${color_yellow}Attempt $attempt failed to create static ip $1. Retrying.${color_norm}" >&2
0000000000000000000000000000000000000000;;	    sleep $(($attempt * 5))
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Robustly try to create a firewall rule.
0000000000000000000000000000000000000000;;	# $1: The name of firewall rule.
0000000000000000000000000000000000000000;;	# $2: IP ranges.
0000000000000000000000000000000000000000;;	# $3: Target tags for this firewall rule.
0000000000000000000000000000000000000000;;	function create-firewall-rule() {
0000000000000000000000000000000000000000;;	  detect-project
0000000000000000000000000000000000000000;;	  local attempt=0
0000000000000000000000000000000000000000;;	  while true; do
0000000000000000000000000000000000000000;;	    if ! gcloud compute firewall-rules create "$1" \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	      --network "${NETWORK}" \
0000000000000000000000000000000000000000;;	      --source-ranges "$2" \
0000000000000000000000000000000000000000;;	      --target-tags "$3" \
0000000000000000000000000000000000000000;;	      --allow tcp,udp,icmp,esp,ah,sctp; then
0000000000000000000000000000000000000000;;	      if (( attempt > 4 )); then
0000000000000000000000000000000000000000;;	        echo -e "${color_red}Failed to create firewall rule $1 ${color_norm}" >&2
0000000000000000000000000000000000000000;;	        exit 2
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	      echo -e "${color_yellow}Attempt $(($attempt+1)) failed to create firewall rule $1. Retrying.${color_norm}" >&2
0000000000000000000000000000000000000000;;	      attempt=$(($attempt+1))
0000000000000000000000000000000000000000;;	      sleep $(($attempt * 5))
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	        break
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Format the string argument for gcloud network.
0000000000000000000000000000000000000000;;	function make-gcloud-network-argument() {
0000000000000000000000000000000000000000;;	  local network="$1"
0000000000000000000000000000000000000000;;	  local address="$2"          # optional
0000000000000000000000000000000000000000;;	  local enable_ip_alias="$3"  # optional
0000000000000000000000000000000000000000;;	  local alias_subnetwork="$4" # optional
0000000000000000000000000000000000000000;;	  local alias_size="$5"       # optional
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local ret=""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "${enable_ip_alias}" == 'true' ]]; then
0000000000000000000000000000000000000000;;	    ret="--network-interface"
0000000000000000000000000000000000000000;;	    ret="${ret} network=${network}"
0000000000000000000000000000000000000000;;	    # If address is omitted, instance will not receive an external IP.
0000000000000000000000000000000000000000;;	    ret="${ret},address=${address:-}"
0000000000000000000000000000000000000000;;	    ret="${ret},subnet=${alias_subnetwork}"
0000000000000000000000000000000000000000;;	    ret="${ret},aliases=pods-default:${alias_size}"
0000000000000000000000000000000000000000;;	    ret="${ret} --no-can-ip-forward"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    if [[ ${ENABLE_BIG_CLUSTER_SUBNETS} != "true" || (${PREEXISTING_NETWORK} = "true" && "${PREEXISTING_NETWORK_MODE}" != "custom") ]]; then
0000000000000000000000000000000000000000;;	      ret="--network ${network}"
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      ret="--subnet=${network}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    ret="${ret} --can-ip-forward"
0000000000000000000000000000000000000000;;	    if [[ -n ${address:-} ]]; then
0000000000000000000000000000000000000000;;	      ret="${ret} --address ${address}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "${ret}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# $1: version (required)
0000000000000000000000000000000000000000;;	function get-template-name-from-version() {
0000000000000000000000000000000000000000;;	  # trim template name to pass gce name validation
0000000000000000000000000000000000000000;;	  echo "${NODE_INSTANCE_PREFIX}-template-${1}" | cut -c 1-63 | sed 's/[\.\+]/-/g;s/-*$//g'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Robustly try to create an instance template.
0000000000000000000000000000000000000000;;	# $1: The name of the instance template.
0000000000000000000000000000000000000000;;	# $2: The scopes flag.
0000000000000000000000000000000000000000;;	# $3: String of comma-separated metadata entries (must all be from a file).
0000000000000000000000000000000000000000;;	function create-node-template() {
0000000000000000000000000000000000000000;;	  detect-project
0000000000000000000000000000000000000000;;	  local template_name="$1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # First, ensure the template doesn't exist.
0000000000000000000000000000000000000000;;	  # TODO(zmerlynn): To make this really robust, we need to parse the output and
0000000000000000000000000000000000000000;;	  #                 add retries. Just relying on a non-zero exit code doesn't
0000000000000000000000000000000000000000;;	  #                 distinguish an ephemeral failed call from a "not-exists".
0000000000000000000000000000000000000000;;	  if gcloud compute instance-templates describe "$template_name" --project "${PROJECT}" &>/dev/null; then
0000000000000000000000000000000000000000;;	    echo "Instance template ${1} already exists; deleting." >&2
0000000000000000000000000000000000000000;;	    if ! gcloud compute instance-templates delete "$template_name" --project "${PROJECT}" --quiet &>/dev/null; then
0000000000000000000000000000000000000000;;	      echo -e "${color_yellow}Failed to delete existing instance template${color_norm}" >&2
0000000000000000000000000000000000000000;;	      exit 2
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local gcloud="gcloud"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local accelerator_args=""
0000000000000000000000000000000000000000;;	  # VMs with Accelerators cannot be live migrated.
0000000000000000000000000000000000000000;;	  # More details here - https://cloud.google.com/compute/docs/gpus/add-gpus#create-new-gpu-instance
0000000000000000000000000000000000000000;;	  if [[ ! -z "${NODE_ACCELERATORS}" ]]; then
0000000000000000000000000000000000000000;;	    accelerator_args="--maintenance-policy TERMINATE --restart-on-failure --accelerator ${NODE_ACCELERATORS}"
0000000000000000000000000000000000000000;;	    gcloud="gcloud beta"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "${ENABLE_IP_ALIASES:-}" == 'true' ]]; then
0000000000000000000000000000000000000000;;	    gcloud="gcloud beta"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local preemptible_minions=""
0000000000000000000000000000000000000000;;	  if [[ "${PREEMPTIBLE_NODE}" == "true" ]]; then
0000000000000000000000000000000000000000;;	    preemptible_minions="--preemptible --maintenance-policy TERMINATE"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local local_ssds=""
0000000000000000000000000000000000000000;;	  if [[ ! -z ${NODE_LOCAL_SSDS+x} ]]; then
0000000000000000000000000000000000000000;;	      for i in $(seq ${NODE_LOCAL_SSDS}); do
0000000000000000000000000000000000000000;;	          local_ssds="$local_ssds--local-ssd=interface=SCSI "
0000000000000000000000000000000000000000;;	      done
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local network=$(make-gcloud-network-argument \
0000000000000000000000000000000000000000;;	    "${NETWORK}" "" \
0000000000000000000000000000000000000000;;	    "${ENABLE_IP_ALIASES:-}" \
0000000000000000000000000000000000000000;;	    "${IP_ALIAS_SUBNETWORK:-}" \
0000000000000000000000000000000000000000;;	    "${IP_ALIAS_SIZE:-}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local attempt=1
0000000000000000000000000000000000000000;;	  while true; do
0000000000000000000000000000000000000000;;	    echo "Attempt ${attempt} to create ${1}" >&2
0000000000000000000000000000000000000000;;	    if ! ${gcloud} compute instance-templates create \
0000000000000000000000000000000000000000;;	      "$template_name" \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	      --machine-type "${NODE_SIZE}" \
0000000000000000000000000000000000000000;;	      --boot-disk-type "${NODE_DISK_TYPE}" \
0000000000000000000000000000000000000000;;	      --boot-disk-size "${NODE_DISK_SIZE}" \
0000000000000000000000000000000000000000;;	      --image-project="${NODE_IMAGE_PROJECT}" \
0000000000000000000000000000000000000000;;	      --image "${NODE_IMAGE}" \
0000000000000000000000000000000000000000;;	      --tags "${NODE_TAG}" \
0000000000000000000000000000000000000000;;	      ${accelerator_args} \
0000000000000000000000000000000000000000;;	      ${local_ssds} \
0000000000000000000000000000000000000000;;	      --region "${REGION}" \
0000000000000000000000000000000000000000;;	      ${network} \
0000000000000000000000000000000000000000;;	      ${preemptible_minions} \
0000000000000000000000000000000000000000;;	      $2 \
0000000000000000000000000000000000000000;;	      --metadata-from-file $3 >&2; then
0000000000000000000000000000000000000000;;	        if (( attempt > 5 )); then
0000000000000000000000000000000000000000;;	          echo -e "${color_red}Failed to create instance template $template_name ${color_norm}" >&2
0000000000000000000000000000000000000000;;	          exit 2
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	        echo -e "${color_yellow}Attempt ${attempt} failed to create instance template $template_name. Retrying.${color_norm}" >&2
0000000000000000000000000000000000000000;;	        attempt=$(($attempt+1))
0000000000000000000000000000000000000000;;	        sleep $(($attempt * 5))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	        # In case the previous attempt failed with something like a
0000000000000000000000000000000000000000;;	        # Backend Error and left the entry laying around, delete it
0000000000000000000000000000000000000000;;	        # before we try again.
0000000000000000000000000000000000000000;;	        gcloud compute instance-templates delete "$template_name" --project "${PROJECT}" &>/dev/null || true
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	        break
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Robustly try to add metadata on an instance.
0000000000000000000000000000000000000000;;	# $1: The name of the instance.
0000000000000000000000000000000000000000;;	# $2...$n: The metadata key=value pairs to add.
0000000000000000000000000000000000000000;;	function add-instance-metadata() {
0000000000000000000000000000000000000000;;	  local -r instance=$1
0000000000000000000000000000000000000000;;	  shift 1
0000000000000000000000000000000000000000;;	  local -r kvs=( "$@" )
0000000000000000000000000000000000000000;;	  detect-project
0000000000000000000000000000000000000000;;	  local attempt=0
0000000000000000000000000000000000000000;;	  while true; do
0000000000000000000000000000000000000000;;	    if ! gcloud compute instances add-metadata "${instance}" \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	      --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	      --metadata "${kvs[@]}"; then
0000000000000000000000000000000000000000;;	        if (( attempt > 5 )); then
0000000000000000000000000000000000000000;;	          echo -e "${color_red}Failed to add instance metadata in ${instance} ${color_norm}" >&2
0000000000000000000000000000000000000000;;	          exit 2
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	        echo -e "${color_yellow}Attempt $(($attempt+1)) failed to add metadata in ${instance}. Retrying.${color_norm}" >&2
0000000000000000000000000000000000000000;;	        attempt=$(($attempt+1))
0000000000000000000000000000000000000000;;	        sleep $((5 * $attempt))
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	        break
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Robustly try to add metadata on an instance, from a file.
0000000000000000000000000000000000000000;;	# $1: The name of the instance.
0000000000000000000000000000000000000000;;	# $2...$n: The metadata key=file pairs to add.
0000000000000000000000000000000000000000;;	function add-instance-metadata-from-file() {
0000000000000000000000000000000000000000;;	  local -r instance=$1
0000000000000000000000000000000000000000;;	  shift 1
0000000000000000000000000000000000000000;;	  local -r kvs=( "$@" )
0000000000000000000000000000000000000000;;	  detect-project
0000000000000000000000000000000000000000;;	  local attempt=0
0000000000000000000000000000000000000000;;	  while true; do
0000000000000000000000000000000000000000;;	    echo "${kvs[@]}"
0000000000000000000000000000000000000000;;	    if ! gcloud compute instances add-metadata "${instance}" \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	      --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	      --metadata-from-file "$(join_csv ${kvs[@]})"; then
0000000000000000000000000000000000000000;;	        if (( attempt > 5 )); then
0000000000000000000000000000000000000000;;	          echo -e "${color_red}Failed to add instance metadata in ${instance} ${color_norm}" >&2
0000000000000000000000000000000000000000;;	          exit 2
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	        echo -e "${color_yellow}Attempt $(($attempt+1)) failed to add metadata in ${instance}. Retrying.${color_norm}" >&2
0000000000000000000000000000000000000000;;	        attempt=$(($attempt+1))
0000000000000000000000000000000000000000;;	        sleep $(($attempt * 5))
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	        break
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Instantiate a kubernetes cluster
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars
0000000000000000000000000000000000000000;;	#   KUBE_ROOT
0000000000000000000000000000000000000000;;	#   <Various vars set in config file>
0000000000000000000000000000000000000000;;	function kube-up() {
0000000000000000000000000000000000000000;;	  kube::util::ensure-temp-dir
0000000000000000000000000000000000000000;;	  detect-project
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  load-or-gen-kube-basicauth
0000000000000000000000000000000000000000;;	  load-or-gen-kube-bearertoken
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Make sure we have the tar files staged on Google Storage
0000000000000000000000000000000000000000;;	  find-release-tars
0000000000000000000000000000000000000000;;	  upload-server-tars
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # ensure that environmental variables specifying number of migs to create
0000000000000000000000000000000000000000;;	  set_num_migs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ ${KUBE_USE_EXISTING_MASTER:-} == "true" ]]; then
0000000000000000000000000000000000000000;;	    detect-master
0000000000000000000000000000000000000000;;	    parse-master-env
0000000000000000000000000000000000000000;;	    create-subnetworks
0000000000000000000000000000000000000000;;	    create-nodes
0000000000000000000000000000000000000000;;	  elif [[ ${KUBE_REPLICATE_EXISTING_MASTER:-} == "true" ]]; then
0000000000000000000000000000000000000000;;	    if  [[ "${MASTER_OS_DISTRIBUTION}" != "gci" && "${MASTER_OS_DISTRIBUTION}" != "debian" && "${MASTER_OS_DISTRIBUTION}" != "ubuntu" ]]; then
0000000000000000000000000000000000000000;;	      echo "Master replication supported only for gci, debian, and ubuntu"
0000000000000000000000000000000000000000;;	      return 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    create-loadbalancer
0000000000000000000000000000000000000000;;	    # If replication of master fails, we need to ensure that the replica is removed from etcd clusters.
0000000000000000000000000000000000000000;;	    if ! replicate-master; then
0000000000000000000000000000000000000000;;	      remove-replica-from-etcd 2379 || true
0000000000000000000000000000000000000000;;	      remove-replica-from-etcd 4002 || true
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    check-existing
0000000000000000000000000000000000000000;;	    create-network
0000000000000000000000000000000000000000;;	    create-subnetworks
0000000000000000000000000000000000000000;;	    write-cluster-name
0000000000000000000000000000000000000000;;	    create-autoscaler-config
0000000000000000000000000000000000000000;;	    create-master
0000000000000000000000000000000000000000;;	    create-nodes-firewall
0000000000000000000000000000000000000000;;	    create-nodes-template
0000000000000000000000000000000000000000;;	    create-nodes
0000000000000000000000000000000000000000;;	    check-cluster
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function check-existing() {
0000000000000000000000000000000000000000;;	  local running_in_terminal=false
0000000000000000000000000000000000000000;;	  # May be false if tty is not allocated (for example with ssh -T).
0000000000000000000000000000000000000000;;	  if [[ -t 1 ]]; then
0000000000000000000000000000000000000000;;	    running_in_terminal=true
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ ${running_in_terminal} == "true" || ${KUBE_UP_AUTOMATIC_CLEANUP} == "true" ]]; then
0000000000000000000000000000000000000000;;	    if ! check-resources; then
0000000000000000000000000000000000000000;;	      local run_kube_down="n"
0000000000000000000000000000000000000000;;	      echo "${KUBE_RESOURCE_FOUND} found." >&2
0000000000000000000000000000000000000000;;	      # Get user input only if running in terminal.
0000000000000000000000000000000000000000;;	      if [[ ${running_in_terminal} == "true" && ${KUBE_UP_AUTOMATIC_CLEANUP} == "false" ]]; then
0000000000000000000000000000000000000000;;	        read -p "Would you like to shut down the old cluster (call kube-down)? [y/N] " run_kube_down
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	      if [[ ${run_kube_down} == "y" || ${run_kube_down} == "Y" || ${KUBE_UP_AUTOMATIC_CLEANUP} == "true" ]]; then
0000000000000000000000000000000000000000;;	        echo "... calling kube-down" >&2
0000000000000000000000000000000000000000;;	        kube-down
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function create-network() {
0000000000000000000000000000000000000000;;	  if ! gcloud compute networks --project "${PROJECT}" describe "${NETWORK}" &>/dev/null; then
0000000000000000000000000000000000000000;;	    echo "Creating new network: ${NETWORK}"
0000000000000000000000000000000000000000;;	    # The network needs to be created synchronously or we have a race. The
0000000000000000000000000000000000000000;;	    # firewalls can be added concurrent with instance creation.
0000000000000000000000000000000000000000;;	    gcloud compute networks create --project "${PROJECT}" "${NETWORK}" --mode=auto
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    PREEXISTING_NETWORK=true
0000000000000000000000000000000000000000;;	    PREEXISTING_NETWORK_MODE="$(gcloud compute networks list ${NETWORK} --format='value(x_gcloud_mode)' || true)"
0000000000000000000000000000000000000000;;	    echo "Found existing network ${NETWORK} in ${PREEXISTING_NETWORK_MODE} mode."
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if ! gcloud compute firewall-rules --project "${PROJECT}" describe "${CLUSTER_NAME}-default-internal-master" &>/dev/null; then
0000000000000000000000000000000000000000;;	    gcloud compute firewall-rules create "${CLUSTER_NAME}-default-internal-master" \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	      --network "${NETWORK}" \
0000000000000000000000000000000000000000;;	      --source-ranges "10.0.0.0/8" \
0000000000000000000000000000000000000000;;	      --allow "tcp:1-2379,tcp:2382-65535,udp:1-65535,icmp" \
0000000000000000000000000000000000000000;;	      --target-tags "${MASTER_TAG}"&
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if ! gcloud compute firewall-rules --project "${PROJECT}" describe "${CLUSTER_NAME}-default-internal-node" &>/dev/null; then
0000000000000000000000000000000000000000;;	    gcloud compute firewall-rules create "${CLUSTER_NAME}-default-internal-node" \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	      --network "${NETWORK}" \
0000000000000000000000000000000000000000;;	      --source-ranges "10.0.0.0/8" \
0000000000000000000000000000000000000000;;	      --allow "tcp:1-65535,udp:1-65535,icmp" \
0000000000000000000000000000000000000000;;	      --target-tags "${NODE_TAG}"&
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if ! gcloud compute firewall-rules describe --project "${PROJECT}" "${NETWORK}-default-ssh" &>/dev/null; then
0000000000000000000000000000000000000000;;	    gcloud compute firewall-rules create "${NETWORK}-default-ssh" \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	      --network "${NETWORK}" \
0000000000000000000000000000000000000000;;	      --source-ranges "0.0.0.0/0" \
0000000000000000000000000000000000000000;;	      --allow "tcp:22" &
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function expand-default-subnetwork() {
0000000000000000000000000000000000000000;;	  gcloud compute networks switch-mode "${NETWORK}" \
0000000000000000000000000000000000000000;;	    --mode custom \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --quiet || true
0000000000000000000000000000000000000000;;	  gcloud compute networks subnets expand-ip-range "${NETWORK}" \
0000000000000000000000000000000000000000;;	    --region="${REGION}" \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --prefix-length=19 \
0000000000000000000000000000000000000000;;	    --quiet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function create-subnetworks() {
0000000000000000000000000000000000000000;;	  case ${ENABLE_IP_ALIASES} in
0000000000000000000000000000000000000000;;	    true) echo "IP aliases are enabled. Creating subnetworks.";;
0000000000000000000000000000000000000000;;	    false)
0000000000000000000000000000000000000000;;	      echo "IP aliases are disabled."
0000000000000000000000000000000000000000;;	      if [[ "${ENABLE_BIG_CLUSTER_SUBNETS}" = "true" ]]; then 
0000000000000000000000000000000000000000;;	        if [[  "${PREEXISTING_NETWORK}" != "true" ]]; then
0000000000000000000000000000000000000000;;	          expand-default-subnetwork
0000000000000000000000000000000000000000;;	        else
0000000000000000000000000000000000000000;;	          echo "${color_yellow}Using pre-existing network ${NETWORK}, subnets won't be expanded to /19!${color_norm}"
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	      return;;
0000000000000000000000000000000000000000;;	    *) echo "${color_red}Invalid argument to ENABLE_IP_ALIASES${color_norm}"
0000000000000000000000000000000000000000;;	       exit 1;;
0000000000000000000000000000000000000000;;	  esac
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Look for the alias subnet, it must exist and have a secondary
0000000000000000000000000000000000000000;;	  # range configured.
0000000000000000000000000000000000000000;;	  local subnet=$(gcloud beta compute networks subnets describe \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --region ${REGION} \
0000000000000000000000000000000000000000;;	    ${IP_ALIAS_SUBNETWORK} 2>/dev/null)
0000000000000000000000000000000000000000;;	  if [[ -z ${subnet} ]]; then
0000000000000000000000000000000000000000;;	    # Only allow auto-creation for default subnets
0000000000000000000000000000000000000000;;	    if [[ ${IP_ALIAS_SUBNETWORK} != ${INSTANCE_PREFIX}-subnet-default ]]; then
0000000000000000000000000000000000000000;;	      echo "${color_red}Subnetwork ${NETWORK}:${IP_ALIAS_SUBNETWORK} does not exist${color_norm}"
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if [[ -z ${NODE_IP_RANGE:-} ]]; then
0000000000000000000000000000000000000000;;	      echo "${color_red}NODE_IP_RANGE must be specified{color_norm}"
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    echo "Creating subnet ${NETWORK}:${IP_ALIAS_SUBNETWORK}"
0000000000000000000000000000000000000000;;	    gcloud beta compute networks subnets create \
0000000000000000000000000000000000000000;;	      ${IP_ALIAS_SUBNETWORK} \
0000000000000000000000000000000000000000;;	      --description "Automatically generated subnet for ${INSTANCE_PREFIX} cluster. This will be removed on cluster teardown." \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	      --network ${NETWORK} \
0000000000000000000000000000000000000000;;	      --region ${REGION} \
0000000000000000000000000000000000000000;;	      --range ${NODE_IP_RANGE} \
0000000000000000000000000000000000000000;;	      --secondary-range "pods-default=${CLUSTER_IP_RANGE}"
0000000000000000000000000000000000000000;;	    echo "Created subnetwork ${IP_ALIAS_SUBNETWORK}"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    if ! echo ${subnet} | grep --quiet secondaryIpRanges ${subnet}; then
0000000000000000000000000000000000000000;;	      echo "${color_red}Subnet ${IP_ALIAS_SUBNETWORK} does not have a secondary range${color_norm}"
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Services subnetwork.
0000000000000000000000000000000000000000;;	  local subnet=$(gcloud beta compute networks subnets describe \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --region ${REGION} \
0000000000000000000000000000000000000000;;	    ${SERVICE_CLUSTER_IP_SUBNETWORK} 2>/dev/null)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ -z ${subnet} ]]; then
0000000000000000000000000000000000000000;;	    if [[ ${SERVICE_CLUSTER_IP_SUBNETWORK} != ${INSTANCE_PREFIX}-subnet-services ]]; then
0000000000000000000000000000000000000000;;	      echo "${color_red}Subnetwork ${NETWORK}:${SERVICE_CLUSTER_IP_SUBNETWORK} does not exist${color_norm}"
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    echo "Creating subnet for reserving service cluster IPs ${NETWORK}:${SERVICE_CLUSTER_IP_SUBNETWORK}"
0000000000000000000000000000000000000000;;	    gcloud beta compute networks subnets create \
0000000000000000000000000000000000000000;;	      ${SERVICE_CLUSTER_IP_SUBNETWORK} \
0000000000000000000000000000000000000000;;	      --description "Automatically generated subnet for ${INSTANCE_PREFIX} cluster. This will be removed on cluster teardown." \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	      --network ${NETWORK} \
0000000000000000000000000000000000000000;;	      --region ${REGION} \
0000000000000000000000000000000000000000;;	      --range ${SERVICE_CLUSTER_IP_RANGE}
0000000000000000000000000000000000000000;;	    echo "Created subnetwork ${SERVICE_CLUSTER_IP_SUBNETWORK}"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    echo "Subnet ${SERVICE_CLUSTER_IP_SUBNETWORK} already exists"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function delete-firewall-rules() {
0000000000000000000000000000000000000000;;	  for fw in $@; do
0000000000000000000000000000000000000000;;	    if [[ -n $(gcloud compute firewall-rules --project "${PROJECT}" describe "${fw}" --format='value(name)' 2>/dev/null || true) ]]; then
0000000000000000000000000000000000000000;;	      gcloud compute firewall-rules delete --project "${PROJECT}" --quiet "${fw}" &
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  kube::util::wait-for-jobs || {
0000000000000000000000000000000000000000;;	    echo -e "${color_red}Failed to delete firewall rules.${color_norm}" >&2
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function delete-network() {
0000000000000000000000000000000000000000;;	  if [[ -n $(gcloud compute networks --project "${PROJECT}" describe "${NETWORK}" --format='value(name)' 2>/dev/null || true) ]]; then
0000000000000000000000000000000000000000;;	    if ! gcloud compute networks delete --project "${PROJECT}" --quiet "${NETWORK}"; then
0000000000000000000000000000000000000000;;	      echo "Failed to delete network '${NETWORK}'. Listing firewall-rules:"
0000000000000000000000000000000000000000;;	      gcloud compute firewall-rules --project "${PROJECT}" list --filter="network=${NETWORK}"
0000000000000000000000000000000000000000;;	      return 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function delete-subnetworks() {
0000000000000000000000000000000000000000;;	  if [[ ${ENABLE_IP_ALIASES:-} != "true" ]]; then
0000000000000000000000000000000000000000;;	    if [[ "${ENABLE_BIG_CLUSTER_SUBNETS}" = "true" ]]; then
0000000000000000000000000000000000000000;;	      # If running in custom mode network we need to delete subnets
0000000000000000000000000000000000000000;;	      mode="$(gcloud compute networks list ${NETWORK} --format='value(x_gcloud_mode)' || true)"
0000000000000000000000000000000000000000;;	      if [[ "${mode}" == "custom" ]]; then
0000000000000000000000000000000000000000;;	        echo "Deleting default subnets..."
0000000000000000000000000000000000000000;;	        # This value should be kept in sync with number of regions.
0000000000000000000000000000000000000000;;	        local parallelism=9
0000000000000000000000000000000000000000;;	        gcloud compute networks subnets list --network="${NETWORK}" --format='value(region.basename())' | \
0000000000000000000000000000000000000000;;	          xargs -i -P ${parallelism} gcloud --quiet compute networks subnets delete "${NETWORK}" --region="{}" || true
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    return
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Only delete automatically created subnets.
0000000000000000000000000000000000000000;;	  if [[ ${IP_ALIAS_SUBNETWORK} == ${INSTANCE_PREFIX}-subnet-default ]]; then
0000000000000000000000000000000000000000;;	    echo "Removing auto-created subnet ${NETWORK}:${IP_ALIAS_SUBNETWORK}"
0000000000000000000000000000000000000000;;	    if [[ -n $(gcloud beta compute networks subnets describe \
0000000000000000000000000000000000000000;;	          --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	          --region ${REGION} \
0000000000000000000000000000000000000000;;	          ${IP_ALIAS_SUBNETWORK} 2>/dev/null) ]]; then
0000000000000000000000000000000000000000;;	      gcloud beta --quiet compute networks subnets delete \
0000000000000000000000000000000000000000;;	        --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	        --region ${REGION} \
0000000000000000000000000000000000000000;;	        ${IP_ALIAS_SUBNETWORK}
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ ${SERVICE_CLUSTER_IP_SUBNETWORK} == ${INSTANCE_PREFIX}-subnet-services ]]; then
0000000000000000000000000000000000000000;;	    echo "Removing auto-created subnet ${NETWORK}:${SERVICE_CLUSTER_IP_SUBNETWORK}"
0000000000000000000000000000000000000000;;	    if [[ -n $(gcloud beta compute networks subnets describe \
0000000000000000000000000000000000000000;;	          --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	          --region ${REGION} \
0000000000000000000000000000000000000000;;	          ${SERVICE_CLUSTER_IP_SUBNETWORK} 2>/dev/null) ]]; then
0000000000000000000000000000000000000000;;	      gcloud --quiet beta compute networks subnets delete \
0000000000000000000000000000000000000000;;	        --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	        --region ${REGION} \
0000000000000000000000000000000000000000;;	        ${SERVICE_CLUSTER_IP_SUBNETWORK}
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Assumes:
0000000000000000000000000000000000000000;;	#   NUM_NODES
0000000000000000000000000000000000000000;;	# Sets:
0000000000000000000000000000000000000000;;	#   MASTER_ROOT_DISK_SIZE
0000000000000000000000000000000000000000;;	function get-master-root-disk-size() {
0000000000000000000000000000000000000000;;	  if [[ "${NUM_NODES}" -le "1000" ]]; then
0000000000000000000000000000000000000000;;	    export MASTER_ROOT_DISK_SIZE="20"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    export MASTER_ROOT_DISK_SIZE="50"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Assumes:
0000000000000000000000000000000000000000;;	#   NUM_NODES
0000000000000000000000000000000000000000;;	# Sets:
0000000000000000000000000000000000000000;;	#   MASTER_DISK_SIZE
0000000000000000000000000000000000000000;;	function get-master-disk-size() {
0000000000000000000000000000000000000000;;	  if [[ "${NUM_NODES}" -le "1000" ]]; then
0000000000000000000000000000000000000000;;	    export MASTER_DISK_SIZE="20GB"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    export MASTER_DISK_SIZE="100GB"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Generates SSL certificates for etcd cluster. Uses cfssl program.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   KUBE_TEMP: temporary directory
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Args:
0000000000000000000000000000000000000000;;	#  $1: host name
0000000000000000000000000000000000000000;;	#  $2: CA certificate
0000000000000000000000000000000000000000;;	#  $3: CA key
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# If CA cert/key is empty, the function will also generate certs for CA.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   ETCD_CA_KEY_BASE64
0000000000000000000000000000000000000000;;	#   ETCD_CA_CERT_BASE64
0000000000000000000000000000000000000000;;	#   ETCD_PEER_KEY_BASE64
0000000000000000000000000000000000000000;;	#   ETCD_PEER_CERT_BASE64
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function create-etcd-certs {
0000000000000000000000000000000000000000;;	  local host=${1}
0000000000000000000000000000000000000000;;	  local ca_cert=${2:-}
0000000000000000000000000000000000000000;;	  local ca_key=${3:-}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  GEN_ETCD_CA_CERT="${ca_cert}" GEN_ETCD_CA_KEY="${ca_key}" \
0000000000000000000000000000000000000000;;	    generate-etcd-cert "${KUBE_TEMP}/cfssl" "${host}" "peer" "peer"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  pushd "${KUBE_TEMP}/cfssl"
0000000000000000000000000000000000000000;;	  ETCD_CA_KEY_BASE64=$(cat "ca-key.pem" | base64 | tr -d '\r\n')
0000000000000000000000000000000000000000;;	  ETCD_CA_CERT_BASE64=$(cat "ca.pem" | gzip | base64 | tr -d '\r\n')
0000000000000000000000000000000000000000;;	  ETCD_PEER_KEY_BASE64=$(cat "peer-key.pem" | base64 | tr -d '\r\n')
0000000000000000000000000000000000000000;;	  ETCD_PEER_CERT_BASE64=$(cat "peer.pem" | gzip | base64 | tr -d '\r\n')
0000000000000000000000000000000000000000;;	  popd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function create-master() {
0000000000000000000000000000000000000000;;	  echo "Starting master and configuring firewalls"
0000000000000000000000000000000000000000;;	  gcloud compute firewall-rules create "${MASTER_NAME}-https" \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --network "${NETWORK}" \
0000000000000000000000000000000000000000;;	    --target-tags "${MASTER_TAG}" \
0000000000000000000000000000000000000000;;	    --allow tcp:443 &
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # We have to make sure the disk is created before creating the master VM, so
0000000000000000000000000000000000000000;;	  # run this in the foreground.
0000000000000000000000000000000000000000;;	  get-master-disk-size
0000000000000000000000000000000000000000;;	  gcloud compute disks create "${MASTER_NAME}-pd" \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	    --type "${MASTER_DISK_TYPE}" \
0000000000000000000000000000000000000000;;	    --size "${MASTER_DISK_SIZE}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Create disk for cluster registry if enabled
0000000000000000000000000000000000000000;;	  if [[ "${ENABLE_CLUSTER_REGISTRY}" == true && -n "${CLUSTER_REGISTRY_DISK}" ]]; then
0000000000000000000000000000000000000000;;	    gcloud compute disks create "${CLUSTER_REGISTRY_DISK}" \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	      --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	      --type "${CLUSTER_REGISTRY_DISK_TYPE_GCE}" \
0000000000000000000000000000000000000000;;	      --size "${CLUSTER_REGISTRY_DISK_SIZE}" &
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Create rule for accessing and securing etcd servers.
0000000000000000000000000000000000000000;;	  if ! gcloud compute firewall-rules --project "${PROJECT}" describe "${MASTER_NAME}-etcd" &>/dev/null; then
0000000000000000000000000000000000000000;;	    gcloud compute firewall-rules create "${MASTER_NAME}-etcd" \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	      --network "${NETWORK}" \
0000000000000000000000000000000000000000;;	      --source-tags "${MASTER_TAG}" \
0000000000000000000000000000000000000000;;	      --allow "tcp:2380,tcp:2381" \
0000000000000000000000000000000000000000;;	      --target-tags "${MASTER_TAG}" &
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Generate a bearer token for this cluster. We push this separately
0000000000000000000000000000000000000000;;	  # from the other cluster variables so that the client (this
0000000000000000000000000000000000000000;;	  # computer) can forget it later. This should disappear with
0000000000000000000000000000000000000000;;	  # http://issue.k8s.io/3168
0000000000000000000000000000000000000000;;	  KUBELET_TOKEN=$(dd if=/dev/urandom bs=128 count=1 2>/dev/null | base64 | tr -d "=+/" | dd bs=32 count=1 2>/dev/null)
0000000000000000000000000000000000000000;;	  KUBE_PROXY_TOKEN=$(dd if=/dev/urandom bs=128 count=1 2>/dev/null | base64 | tr -d "=+/" | dd bs=32 count=1 2>/dev/null)
0000000000000000000000000000000000000000;;	  if [[ "${ENABLE_NODE_PROBLEM_DETECTOR:-}" == "standalone" ]]; then
0000000000000000000000000000000000000000;;	    NODE_PROBLEM_DETECTOR_TOKEN=$(dd if=/dev/urandom bs=128 count=1 2>/dev/null | base64 | tr -d "=+/" | dd bs=32 count=1 2>/dev/null)
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Reserve the master's IP so that it can later be transferred to another VM
0000000000000000000000000000000000000000;;	  # without disrupting the kubelets.
0000000000000000000000000000000000000000;;	  create-static-ip "${MASTER_NAME}-ip" "${REGION}"
0000000000000000000000000000000000000000;;	  MASTER_RESERVED_IP=$(gcloud compute addresses describe "${MASTER_NAME}-ip" \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" --region "${REGION}" -q --format='value(address)')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "${REGISTER_MASTER_KUBELET:-}" == "true" ]]; then
0000000000000000000000000000000000000000;;	    KUBELET_APISERVER="${MASTER_RESERVED_IP}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  KUBERNETES_MASTER_NAME="${MASTER_RESERVED_IP}"
0000000000000000000000000000000000000000;;	  MASTER_ADVERTISE_ADDRESS="${MASTER_RESERVED_IP}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  create-certs "${MASTER_RESERVED_IP}"
0000000000000000000000000000000000000000;;	  create-etcd-certs ${MASTER_NAME}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Sets MASTER_ROOT_DISK_SIZE that is used by create-master-instance
0000000000000000000000000000000000000000;;	  get-master-root-disk-size
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  create-master-instance "${MASTER_RESERVED_IP}" &
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Adds master replica to etcd cluster.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   REPLICA_NAME
0000000000000000000000000000000000000000;;	#   PROJECT
0000000000000000000000000000000000000000;;	#   EXISTING_MASTER_NAME
0000000000000000000000000000000000000000;;	#   EXISTING_MASTER_ZONE
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# $1: etcd client port
0000000000000000000000000000000000000000;;	# $2: etcd internal port
0000000000000000000000000000000000000000;;	# returns the result of ssh command which adds replica
0000000000000000000000000000000000000000;;	function add-replica-to-etcd() {
0000000000000000000000000000000000000000;;	  local -r client_port="${1}"
0000000000000000000000000000000000000000;;	  local -r internal_port="${2}"
0000000000000000000000000000000000000000;;	  gcloud compute ssh "${EXISTING_MASTER_NAME}" \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --zone "${EXISTING_MASTER_ZONE}" \
0000000000000000000000000000000000000000;;	    --command \
0000000000000000000000000000000000000000;;	      "curl localhost:${client_port}/v2/members -XPOST -H \"Content-Type: application/json\" -d '{\"peerURLs\":[\"https://${REPLICA_NAME}:${internal_port}\"]}' -s"
0000000000000000000000000000000000000000;;	  return $?
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Sets EXISTING_MASTER_NAME and EXISTING_MASTER_ZONE variables.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   PROJECT
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# NOTE: Must be in sync with get-replica-name-regexp
0000000000000000000000000000000000000000;;	function set-existing-master() {
0000000000000000000000000000000000000000;;	  local existing_master=$(gcloud compute instances list \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --regexp "$(get-replica-name-regexp)" \
0000000000000000000000000000000000000000;;	    --format "value(name,zone)" | head -n1)
0000000000000000000000000000000000000000;;	  EXISTING_MASTER_NAME="$(echo "${existing_master}" | cut -f1)"
0000000000000000000000000000000000000000;;	  EXISTING_MASTER_ZONE="$(echo "${existing_master}" | cut -f2)"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function replicate-master() {
0000000000000000000000000000000000000000;;	  set-replica-name
0000000000000000000000000000000000000000;;	  set-existing-master
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "Experimental: replicating existing master ${EXISTING_MASTER_ZONE}/${EXISTING_MASTER_NAME} as ${ZONE}/${REPLICA_NAME}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Before we do anything else, we should configure etcd to expect more replicas.
0000000000000000000000000000000000000000;;	  if ! add-replica-to-etcd 2379 2380; then
0000000000000000000000000000000000000000;;	    echo "Failed to add master replica to etcd cluster."
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if ! add-replica-to-etcd 4002 2381; then
0000000000000000000000000000000000000000;;	    echo "Failed to add master replica to etcd events cluster."
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # We have to make sure the disk is created before creating the master VM, so
0000000000000000000000000000000000000000;;	  # run this in the foreground.
0000000000000000000000000000000000000000;;	  get-master-disk-size
0000000000000000000000000000000000000000;;	  gcloud compute disks create "${REPLICA_NAME}-pd" \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	    --type "${MASTER_DISK_TYPE}" \
0000000000000000000000000000000000000000;;	    --size "${MASTER_DISK_SIZE}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Sets MASTER_ROOT_DISK_SIZE that is used by create-master-instance
0000000000000000000000000000000000000000;;	  get-master-root-disk-size
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local existing_master_replicas="$(get-all-replica-names)"
0000000000000000000000000000000000000000;;	  replicate-master-instance "${EXISTING_MASTER_ZONE}" "${EXISTING_MASTER_NAME}" "${existing_master_replicas}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Add new replica to the load balancer.
0000000000000000000000000000000000000000;;	  gcloud compute target-pools add-instances "${MASTER_NAME}" \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	    --instances "${REPLICA_NAME}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Detaches old and ataches new external IP to a VM.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Arguments:
0000000000000000000000000000000000000000;;	#   $1 - VM name
0000000000000000000000000000000000000000;;	#   $2 - VM zone
0000000000000000000000000000000000000000;;	#   $3 - external static IP; if empty will use an ephemeral IP address.
0000000000000000000000000000000000000000;;	function attach-external-ip() {
0000000000000000000000000000000000000000;;	  local NAME=${1}
0000000000000000000000000000000000000000;;	  local ZONE=${2}
0000000000000000000000000000000000000000;;	  local IP_ADDR=${3:-}
0000000000000000000000000000000000000000;;	  local ACCESS_CONFIG_NAME=$(gcloud compute instances describe "${NAME}" \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	    --format="value(networkInterfaces[0].accessConfigs[0].name)")
0000000000000000000000000000000000000000;;	  gcloud compute instances delete-access-config "${NAME}" \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	    --access-config-name "${ACCESS_CONFIG_NAME}"
0000000000000000000000000000000000000000;;	  if [[ -z ${IP_ADDR} ]]; then
0000000000000000000000000000000000000000;;	    gcloud compute instances add-access-config "${NAME}" \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	      --access-config-name "${ACCESS_CONFIG_NAME}"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    gcloud compute instances add-access-config "${NAME}" \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	      --access-config-name "${ACCESS_CONFIG_NAME}" \
0000000000000000000000000000000000000000;;	      --address "${IP_ADDR}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Creates load balancer in front of apiserver if it doesn't exists already. Assumes there's only one
0000000000000000000000000000000000000000;;	# existing master replica.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumes:
0000000000000000000000000000000000000000;;	#   PROJECT
0000000000000000000000000000000000000000;;	#   MASTER_NAME
0000000000000000000000000000000000000000;;	#   ZONE
0000000000000000000000000000000000000000;;	#   REGION
0000000000000000000000000000000000000000;;	function create-loadbalancer() {
0000000000000000000000000000000000000000;;	  detect-master
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Step 0: Return early if LB is already configured.
0000000000000000000000000000000000000000;;	  if gcloud compute forwarding-rules describe ${MASTER_NAME} \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" --region ${REGION} > /dev/null 2>&1; then
0000000000000000000000000000000000000000;;	    echo "Load balancer already exists"
0000000000000000000000000000000000000000;;	    return
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local EXISTING_MASTER_NAME="$(get-all-replica-names)"
0000000000000000000000000000000000000000;;	  local EXISTING_MASTER_ZONE=$(gcloud compute instances list "${EXISTING_MASTER_NAME}" \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" --format="value(zone)")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "Creating load balancer in front of an already existing master in ${EXISTING_MASTER_ZONE}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Step 1: Detach master IP address and attach ephemeral address to the existing master
0000000000000000000000000000000000000000;;	  attach-external-ip "${EXISTING_MASTER_NAME}" "${EXISTING_MASTER_ZONE}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Step 2: Create target pool.
0000000000000000000000000000000000000000;;	  gcloud compute target-pools create "${MASTER_NAME}" --project "${PROJECT}" --region "${REGION}"
0000000000000000000000000000000000000000;;	  # TODO: We should also add master instances with suffixes
0000000000000000000000000000000000000000;;	  gcloud compute target-pools add-instances "${MASTER_NAME}" --instances "${EXISTING_MASTER_NAME}" --project "${PROJECT}" --zone "${EXISTING_MASTER_ZONE}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Step 3: Create forwarding rule.
0000000000000000000000000000000000000000;;	  # TODO: This step can take up to 20 min. We need to speed this up...
0000000000000000000000000000000000000000;;	  gcloud compute forwarding-rules create ${MASTER_NAME} \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" --region ${REGION} \
0000000000000000000000000000000000000000;;	    --target-pool ${MASTER_NAME} --address=${KUBE_MASTER_IP} --ports=443
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo -n "Waiting for the load balancer configuration to propagate..."
0000000000000000000000000000000000000000;;	  local counter=0
0000000000000000000000000000000000000000;;	  until $(curl -k -m1 https://${KUBE_MASTER_IP} &> /dev/null); do
0000000000000000000000000000000000000000;;	    counter=$((counter+1))
0000000000000000000000000000000000000000;;	    echo -n .
0000000000000000000000000000000000000000;;	    if [[ ${counter} -ge 1800 ]]; then
0000000000000000000000000000000000000000;;	      echo -e "${color_red}TIMEOUT${color_norm}" >&2
0000000000000000000000000000000000000000;;	      echo -e "${color_red}Load balancer failed to initialize within ${counter} seconds.${color_norm}" >&2
0000000000000000000000000000000000000000;;	      exit 2
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  echo "DONE"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function create-nodes-firewall() {
0000000000000000000000000000000000000000;;	  # Create a single firewall rule for all minions.
0000000000000000000000000000000000000000;;	  create-firewall-rule "${NODE_TAG}-all" "${CLUSTER_IP_RANGE}" "${NODE_TAG}" &
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Report logging choice (if any).
0000000000000000000000000000000000000000;;	  if [[ "${ENABLE_NODE_LOGGING-}" == "true" ]]; then
0000000000000000000000000000000000000000;;	    echo "+++ Logging using Fluentd to ${LOGGING_DESTINATION:-unknown}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Wait for last batch of jobs
0000000000000000000000000000000000000000;;	  kube::util::wait-for-jobs || {
0000000000000000000000000000000000000000;;	    echo -e "${color_red}Some commands failed.${color_norm}" >&2
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function get-scope-flags() {
0000000000000000000000000000000000000000;;	  local scope_flags=
0000000000000000000000000000000000000000;;	  if [[ -n "${NODE_SCOPES}" ]]; then
0000000000000000000000000000000000000000;;	    scope_flags="--scopes ${NODE_SCOPES}"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    scope_flags="--no-scopes"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  echo "${scope_flags}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function create-nodes-template() {
0000000000000000000000000000000000000000;;	  echo "Creating nodes."
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local scope_flags=$(get-scope-flags)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  write-node-env
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local template_name="${NODE_INSTANCE_PREFIX}-template"
0000000000000000000000000000000000000000;;	  create-node-instance-template $template_name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Assumes:
0000000000000000000000000000000000000000;;	# - MAX_INSTANCES_PER_MIG
0000000000000000000000000000000000000000;;	# - NUM_NODES
0000000000000000000000000000000000000000;;	# exports:
0000000000000000000000000000000000000000;;	# - NUM_MIGS
0000000000000000000000000000000000000000;;	function set_num_migs() {
0000000000000000000000000000000000000000;;	  local defaulted_max_instances_per_mig=${MAX_INSTANCES_PER_MIG:-1000}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ ${defaulted_max_instances_per_mig} -le "0" ]]; then
0000000000000000000000000000000000000000;;	    echo "MAX_INSTANCES_PER_MIG cannot be negative. Assuming default 1000"
0000000000000000000000000000000000000000;;	    defaulted_max_instances_per_mig=1000
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  export NUM_MIGS=$(((${NUM_NODES} + ${defaulted_max_instances_per_mig} - 1) / ${defaulted_max_instances_per_mig}))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Assumes:
0000000000000000000000000000000000000000;;	# - NUM_MIGS
0000000000000000000000000000000000000000;;	# - NODE_INSTANCE_PREFIX
0000000000000000000000000000000000000000;;	# - NUM_NODES
0000000000000000000000000000000000000000;;	# - PROJECT
0000000000000000000000000000000000000000;;	# - ZONE
0000000000000000000000000000000000000000;;	function create-nodes() {
0000000000000000000000000000000000000000;;	  local template_name="${NODE_INSTANCE_PREFIX}-template"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ -z "${HEAPSTER_MACHINE_TYPE:-}" ]]; then
0000000000000000000000000000000000000000;;	    local -r nodes="${NUM_NODES}"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    local -r nodes=$(( NUM_NODES - 1 ))
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local instances_left=${nodes}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  #TODO: parallelize this loop to speed up the process
0000000000000000000000000000000000000000;;	  for ((i=1; i<=${NUM_MIGS}; i++)); do
0000000000000000000000000000000000000000;;	    local group_name="${NODE_INSTANCE_PREFIX}-group-$i"
0000000000000000000000000000000000000000;;	    if [[ $i == ${NUM_MIGS} ]]; then
0000000000000000000000000000000000000000;;	      # TODO: We don't add a suffix for the last group to keep backward compatibility when there's only one MIG.
0000000000000000000000000000000000000000;;	      # We should change it at some point, but note #18545 when changing this.
0000000000000000000000000000000000000000;;	      group_name="${NODE_INSTANCE_PREFIX}-group"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    # Spread the remaining number of nodes evenly
0000000000000000000000000000000000000000;;	    this_mig_size=$((${instances_left} / (${NUM_MIGS}-${i}+1)))
0000000000000000000000000000000000000000;;	    instances_left=$((instances_left-${this_mig_size}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    gcloud compute instance-groups managed \
0000000000000000000000000000000000000000;;	        create "${group_name}" \
0000000000000000000000000000000000000000;;	        --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	        --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	        --base-instance-name "${group_name}" \
0000000000000000000000000000000000000000;;	        --size "${this_mig_size}" \
0000000000000000000000000000000000000000;;	        --template "$template_name" || true;
0000000000000000000000000000000000000000;;	    gcloud compute instance-groups managed wait-until-stable \
0000000000000000000000000000000000000000;;	        "${group_name}" \
0000000000000000000000000000000000000000;;	        --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	        --project "${PROJECT}" || true;
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ -n "${HEAPSTER_MACHINE_TYPE:-}" ]]; then
0000000000000000000000000000000000000000;;	    echo "Creating a special node for heapster with machine-type ${HEAPSTER_MACHINE_TYPE}"
0000000000000000000000000000000000000000;;	    create-heapster-node
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Assumes:
0000000000000000000000000000000000000000;;	# - NODE_INSTANCE_PREFIX
0000000000000000000000000000000000000000;;	# - PROJECT
0000000000000000000000000000000000000000;;	# - ZONE
0000000000000000000000000000000000000000;;	# - HEAPSTER_MACHINE_TYPE
0000000000000000000000000000000000000000;;	# - NODE_DISK_TYPE
0000000000000000000000000000000000000000;;	# - NODE_DISK_SIZE
0000000000000000000000000000000000000000;;	# - NODE_IMAGE_PROJECT
0000000000000000000000000000000000000000;;	# - NODE_IMAGE
0000000000000000000000000000000000000000;;	# - NODE_TAG
0000000000000000000000000000000000000000;;	# - NETWORK
0000000000000000000000000000000000000000;;	# - ENABLE_IP_ALIASES
0000000000000000000000000000000000000000;;	# - IP_ALIAS_SUBNETWORK
0000000000000000000000000000000000000000;;	# - IP_ALIAS_SIZE
0000000000000000000000000000000000000000;;	function create-heapster-node() {
0000000000000000000000000000000000000000;;	  local network=$(make-gcloud-network-argument \
0000000000000000000000000000000000000000;;	      "${NETWORK}" "" \
0000000000000000000000000000000000000000;;	      "${ENABLE_IP_ALIASES:-}" \
0000000000000000000000000000000000000000;;	      "${IP_ALIAS_SUBNETWORK:-}" \
0000000000000000000000000000000000000000;;	      "${IP_ALIAS_SIZE:-}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  gcloud compute instances \
0000000000000000000000000000000000000000;;	      create "${NODE_INSTANCE_PREFIX}-heapster" \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	      --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	      --machine-type="${HEAPSTER_MACHINE_TYPE}" \
0000000000000000000000000000000000000000;;	      --boot-disk-type "${NODE_DISK_TYPE}" \
0000000000000000000000000000000000000000;;	      --boot-disk-size "${NODE_DISK_SIZE}" \
0000000000000000000000000000000000000000;;	      --image-project="${NODE_IMAGE_PROJECT}" \
0000000000000000000000000000000000000000;;	      --image "${NODE_IMAGE}" \
0000000000000000000000000000000000000000;;	      --tags "${NODE_TAG}" \
0000000000000000000000000000000000000000;;	      ${network} \
0000000000000000000000000000000000000000;;	      $(get-scope-flags) \
0000000000000000000000000000000000000000;;	      --metadata-from-file "$(get-node-instance-metadata)"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Assumes:
0000000000000000000000000000000000000000;;	# - NUM_MIGS
0000000000000000000000000000000000000000;;	# - NODE_INSTANCE_PREFIX
0000000000000000000000000000000000000000;;	# - PROJECT
0000000000000000000000000000000000000000;;	# - ZONE
0000000000000000000000000000000000000000;;	# - AUTOSCALER_MAX_NODES
0000000000000000000000000000000000000000;;	# - AUTOSCALER_MIN_NODES
0000000000000000000000000000000000000000;;	# Exports
0000000000000000000000000000000000000000;;	# - AUTOSCALER_MIG_CONFIG
0000000000000000000000000000000000000000;;	function create-cluster-autoscaler-mig-config() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Each MIG must have at least one node, so the min number of nodes
0000000000000000000000000000000000000000;;	  # must be greater or equal to the number of migs.
0000000000000000000000000000000000000000;;	  if [[ ${AUTOSCALER_MIN_NODES} -lt 0 ]]; then
0000000000000000000000000000000000000000;;	    echo "AUTOSCALER_MIN_NODES must be greater or equal 0"
0000000000000000000000000000000000000000;;	    exit 2
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Each MIG must have at least one node, so the min number of nodes
0000000000000000000000000000000000000000;;	  # must be greater or equal to the number of migs.
0000000000000000000000000000000000000000;;	  if [[ ${AUTOSCALER_MAX_NODES} -lt ${NUM_MIGS} ]]; then
0000000000000000000000000000000000000000;;	    echo "AUTOSCALER_MAX_NODES must be greater or equal ${NUM_MIGS}"
0000000000000000000000000000000000000000;;	    exit 2
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # The code assumes that the migs were created with create-nodes
0000000000000000000000000000000000000000;;	  # function which tries to evenly spread nodes across the migs.
0000000000000000000000000000000000000000;;	  AUTOSCALER_MIG_CONFIG=""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local left_min=${AUTOSCALER_MIN_NODES}
0000000000000000000000000000000000000000;;	  local left_max=${AUTOSCALER_MAX_NODES}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for ((i=1; i<=${NUM_MIGS}; i++)); do
0000000000000000000000000000000000000000;;	    local group_name="${NODE_INSTANCE_PREFIX}-group-$i"
0000000000000000000000000000000000000000;;	    if [[ $i == ${NUM_MIGS} ]]; then
0000000000000000000000000000000000000000;;	      # TODO: We don't add a suffix for the last group to keep backward compatibility when there's only one MIG.
0000000000000000000000000000000000000000;;	      # We should change it at some point, but note #18545 when changing this.
0000000000000000000000000000000000000000;;	      group_name="${NODE_INSTANCE_PREFIX}-group"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    this_mig_min=$((${left_min}/(${NUM_MIGS}-${i}+1)))
0000000000000000000000000000000000000000;;	    this_mig_max=$((${left_max}/(${NUM_MIGS}-${i}+1)))
0000000000000000000000000000000000000000;;	    left_min=$((left_min-$this_mig_min))
0000000000000000000000000000000000000000;;	    left_max=$((left_max-$this_mig_max))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    local mig_url="https://www.googleapis.com/compute/v1/projects/${PROJECT}/zones/${ZONE}/instanceGroups/${group_name}"
0000000000000000000000000000000000000000;;	    AUTOSCALER_MIG_CONFIG="${AUTOSCALER_MIG_CONFIG} --nodes=${this_mig_min}:${this_mig_max}:${mig_url}"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  AUTOSCALER_MIG_CONFIG="${AUTOSCALER_MIG_CONFIG} --scale-down-enabled=${AUTOSCALER_ENABLE_SCALE_DOWN}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Assumes:
0000000000000000000000000000000000000000;;	# - NUM_MIGS
0000000000000000000000000000000000000000;;	# - NODE_INSTANCE_PREFIX
0000000000000000000000000000000000000000;;	# - PROJECT
0000000000000000000000000000000000000000;;	# - ZONE
0000000000000000000000000000000000000000;;	# - ENABLE_CLUSTER_AUTOSCALER
0000000000000000000000000000000000000000;;	# - AUTOSCALER_MAX_NODES
0000000000000000000000000000000000000000;;	# - AUTOSCALER_MIN_NODES
0000000000000000000000000000000000000000;;	function create-autoscaler-config() {
0000000000000000000000000000000000000000;;	  # Create autoscaler for nodes configuration if requested
0000000000000000000000000000000000000000;;	  if [[ "${ENABLE_CLUSTER_AUTOSCALER}" == "true" ]]; then
0000000000000000000000000000000000000000;;	    create-cluster-autoscaler-mig-config
0000000000000000000000000000000000000000;;	    echo "Using autoscaler config: ${AUTOSCALER_MIG_CONFIG} ${AUTOSCALER_EXPANDER_CONFIG}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function check-cluster() {
0000000000000000000000000000000000000000;;	  detect-node-names
0000000000000000000000000000000000000000;;	  detect-master
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "Waiting up to ${KUBE_CLUSTER_INITIALIZATION_TIMEOUT} seconds for cluster initialization."
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo "  This will continually check to see if the API for kubernetes is reachable."
0000000000000000000000000000000000000000;;	  echo "  This may time out if there was some uncaught error during start up."
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # curl in mavericks is borked.
0000000000000000000000000000000000000000;;	  secure=""
0000000000000000000000000000000000000000;;	  if which sw_vers >& /dev/null; then
0000000000000000000000000000000000000000;;	    if [[ $(sw_vers | grep ProductVersion | awk '{print $2}') = "10.9."* ]]; then
0000000000000000000000000000000000000000;;	      secure="--insecure"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local start_time=$(date +%s)
0000000000000000000000000000000000000000;;	  until curl --cacert "${CERT_DIR}/pki/ca.crt" \
0000000000000000000000000000000000000000;;	          -H "Authorization: Bearer ${KUBE_BEARER_TOKEN}" \
0000000000000000000000000000000000000000;;	          ${secure} \
0000000000000000000000000000000000000000;;	          --max-time 5 --fail --output /dev/null --silent \
0000000000000000000000000000000000000000;;	          "https://${KUBE_MASTER_IP}/api/v1/pods"; do
0000000000000000000000000000000000000000;;	      local elapsed=$(($(date +%s) - ${start_time}))
0000000000000000000000000000000000000000;;	      if [[ ${elapsed} -gt ${KUBE_CLUSTER_INITIALIZATION_TIMEOUT} ]]; then
0000000000000000000000000000000000000000;;	          echo -e "${color_red}Cluster failed to initialize within ${KUBE_CLUSTER_INITIALIZATION_TIMEOUT} seconds.${color_norm}" >&2
0000000000000000000000000000000000000000;;	          exit 2
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	      printf "."
0000000000000000000000000000000000000000;;	      sleep 2
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "Kubernetes cluster created."
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  export KUBE_CERT="${CERT_DIR}/pki/issued/kubecfg.crt"
0000000000000000000000000000000000000000;;	  export KUBE_KEY="${CERT_DIR}/pki/private/kubecfg.key"
0000000000000000000000000000000000000000;;	  export CA_CERT="${CERT_DIR}/pki/ca.crt"
0000000000000000000000000000000000000000;;	  export CONTEXT="${PROJECT}_${INSTANCE_PREFIX}"
0000000000000000000000000000000000000000;;	  (
0000000000000000000000000000000000000000;;	   umask 077
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	   # Update the user's kubeconfig to include credentials for this apiserver.
0000000000000000000000000000000000000000;;	   create-kubeconfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	   create-kubeconfig-for-federation
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # ensures KUBECONFIG is set
0000000000000000000000000000000000000000;;	  get-kubeconfig-basicauth
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo -e "${color_green}Kubernetes cluster is running.  The master is running at:"
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo -e "${color_yellow}  https://${KUBE_MASTER_IP}"
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo -e "${color_green}The user name and password to use is located in ${KUBECONFIG}.${color_norm}"
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Removes master replica from etcd cluster.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   REPLICA_NAME
0000000000000000000000000000000000000000;;	#   PROJECT
0000000000000000000000000000000000000000;;	#   EXISTING_MASTER_NAME
0000000000000000000000000000000000000000;;	#   EXISTING_MASTER_ZONE
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# $1: etcd client port
0000000000000000000000000000000000000000;;	# returns the result of ssh command which removes replica
0000000000000000000000000000000000000000;;	function remove-replica-from-etcd() {
0000000000000000000000000000000000000000;;	  local -r port="${1}"
0000000000000000000000000000000000000000;;	  [[ -n "${EXISTING_MASTER_NAME}" ]] || return
0000000000000000000000000000000000000000;;	  gcloud compute ssh "${EXISTING_MASTER_NAME}" \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --zone "${EXISTING_MASTER_ZONE}" \
0000000000000000000000000000000000000000;;	    --command \
0000000000000000000000000000000000000000;;	    "curl -s localhost:${port}/v2/members/\$(curl -s localhost:${port}/v2/members -XGET | sed 's/{\\\"id/\n/g' | grep ${REPLICA_NAME}\\\" | cut -f 3 -d \\\") -XDELETE -L 2>/dev/null"
0000000000000000000000000000000000000000;;	  local -r res=$?
0000000000000000000000000000000000000000;;	  echo "Removing etcd replica, name: ${REPLICA_NAME}, port: ${port}, result: ${res}"
0000000000000000000000000000000000000000;;	  return "${res}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Delete a kubernetes cluster. This is called from test-teardown.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   MASTER_NAME
0000000000000000000000000000000000000000;;	#   NODE_INSTANCE_PREFIX
0000000000000000000000000000000000000000;;	#   ZONE
0000000000000000000000000000000000000000;;	# This function tears down cluster resources 10 at a time to avoid issuing too many
0000000000000000000000000000000000000000;;	# API calls and exceeding API quota. It is important to bring down the instances before bringing
0000000000000000000000000000000000000000;;	# down the firewall rules and routes.
0000000000000000000000000000000000000000;;	function kube-down() {
0000000000000000000000000000000000000000;;	  local -r batch=200
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  detect-project
0000000000000000000000000000000000000000;;	  detect-node-names # For INSTANCE_GROUPS
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "Bringing down cluster"
0000000000000000000000000000000000000000;;	  set +e  # Do not stop on error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "${KUBE_DELETE_NODES:-}" != "false" ]]; then
0000000000000000000000000000000000000000;;	    # Get the name of the managed instance group template before we delete the
0000000000000000000000000000000000000000;;	    # managed instance group. (The name of the managed instance group template may
0000000000000000000000000000000000000000;;	    # change during a cluster upgrade.)
0000000000000000000000000000000000000000;;	    local templates=$(get-template "${PROJECT}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    for group in ${INSTANCE_GROUPS[@]:-}; do
0000000000000000000000000000000000000000;;	      if gcloud compute instance-groups managed describe "${group}" --project "${PROJECT}" --zone "${ZONE}" &>/dev/null; then
0000000000000000000000000000000000000000;;	        gcloud compute instance-groups managed delete \
0000000000000000000000000000000000000000;;	          --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	          --quiet \
0000000000000000000000000000000000000000;;	          --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	          "${group}" &
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Wait for last batch of jobs
0000000000000000000000000000000000000000;;	    kube::util::wait-for-jobs || {
0000000000000000000000000000000000000000;;	      echo -e "Failed to delete instance group(s)." >&2
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    for template in ${templates[@]:-}; do
0000000000000000000000000000000000000000;;	      if gcloud compute instance-templates describe --project "${PROJECT}" "${template}" &>/dev/null; then
0000000000000000000000000000000000000000;;	        gcloud compute instance-templates delete \
0000000000000000000000000000000000000000;;	          --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	          --quiet \
0000000000000000000000000000000000000000;;	          "${template}"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Delete the special heapster node (if it exists).
0000000000000000000000000000000000000000;;	    if [[ -n "${HEAPSTER_MACHINE_TYPE:-}" ]]; then
0000000000000000000000000000000000000000;;	      local -r heapster_machine_name="${NODE_INSTANCE_PREFIX}-heapster"
0000000000000000000000000000000000000000;;	      if gcloud compute instances describe "${heapster_machine_name}" --zone "${ZONE}" --project "${PROJECT}" &>/dev/null; then
0000000000000000000000000000000000000000;;	        # Now we can safely delete the VM.
0000000000000000000000000000000000000000;;	        gcloud compute instances delete \
0000000000000000000000000000000000000000;;	          --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	          --quiet \
0000000000000000000000000000000000000000;;	          --delete-disks all \
0000000000000000000000000000000000000000;;	          --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	          "${heapster_machine_name}"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local -r REPLICA_NAME="${KUBE_REPLICA_NAME:-$(get-replica-name)}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  set-existing-master
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Un-register the master replica from etcd and events etcd.
0000000000000000000000000000000000000000;;	  remove-replica-from-etcd 2379
0000000000000000000000000000000000000000;;	  remove-replica-from-etcd 4002
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Delete the master replica (if it exists).
0000000000000000000000000000000000000000;;	  if gcloud compute instances describe "${REPLICA_NAME}" --zone "${ZONE}" --project "${PROJECT}" &>/dev/null; then
0000000000000000000000000000000000000000;;	    # If there is a load balancer in front of apiservers we need to first update its configuration.
0000000000000000000000000000000000000000;;	    if gcloud compute target-pools describe "${MASTER_NAME}" --region "${REGION}" --project "${PROJECT}" &>/dev/null; then
0000000000000000000000000000000000000000;;	      gcloud compute target-pools remove-instances "${MASTER_NAME}" \
0000000000000000000000000000000000000000;;	        --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	        --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	        --instances "${REPLICA_NAME}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    # Now we can safely delete the VM.
0000000000000000000000000000000000000000;;	    gcloud compute instances delete \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	      --quiet \
0000000000000000000000000000000000000000;;	      --delete-disks all \
0000000000000000000000000000000000000000;;	      --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	      "${REPLICA_NAME}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Delete the master replica pd (possibly leaked by kube-up if master create failed).
0000000000000000000000000000000000000000;;	  # TODO(jszczepkowski): remove also possibly leaked replicas' pds
0000000000000000000000000000000000000000;;	  local -r replica_pd="${REPLICA_NAME:-${MASTER_NAME}}-pd"
0000000000000000000000000000000000000000;;	  if gcloud compute disks describe "${replica_pd}" --zone "${ZONE}" --project "${PROJECT}" &>/dev/null; then
0000000000000000000000000000000000000000;;	    gcloud compute disks delete \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	      --quiet \
0000000000000000000000000000000000000000;;	      --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	      "${replica_pd}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Delete disk for cluster registry if enabled
0000000000000000000000000000000000000000;;	  if [[ "${ENABLE_CLUSTER_REGISTRY}" == true && -n "${CLUSTER_REGISTRY_DISK}" ]]; then
0000000000000000000000000000000000000000;;	    if gcloud compute disks describe "${CLUSTER_REGISTRY_DISK}" --zone "${ZONE}" --project "${PROJECT}" &>/dev/null; then
0000000000000000000000000000000000000000;;	      gcloud compute disks delete \
0000000000000000000000000000000000000000;;	        --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	        --quiet \
0000000000000000000000000000000000000000;;	        --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	        "${CLUSTER_REGISTRY_DISK}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Check if this are any remaining master replicas.
0000000000000000000000000000000000000000;;	  local REMAINING_MASTER_COUNT=$(gcloud compute instances list \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --regexp "$(get-replica-name-regexp)" \
0000000000000000000000000000000000000000;;	    --format "value(zone)" | wc -l)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # In the replicated scenario, if there's only a single master left, we should also delete load balancer in front of it.
0000000000000000000000000000000000000000;;	  if [[ "${REMAINING_MASTER_COUNT}" -eq 1 ]]; then
0000000000000000000000000000000000000000;;	    if gcloud compute forwarding-rules describe "${MASTER_NAME}" --region "${REGION}" --project "${PROJECT}" &>/dev/null; then
0000000000000000000000000000000000000000;;	      detect-master
0000000000000000000000000000000000000000;;	      local REMAINING_REPLICA_NAME="$(get-all-replica-names)"
0000000000000000000000000000000000000000;;	      local REMAINING_REPLICA_ZONE=$(gcloud compute instances list "${REMAINING_REPLICA_NAME}" \
0000000000000000000000000000000000000000;;	        --project "${PROJECT}" --format="value(zone)")
0000000000000000000000000000000000000000;;	      gcloud compute forwarding-rules delete \
0000000000000000000000000000000000000000;;	        --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	        --region "${REGION}" \
0000000000000000000000000000000000000000;;	        --quiet \
0000000000000000000000000000000000000000;;	        "${MASTER_NAME}"
0000000000000000000000000000000000000000;;	      attach-external-ip "${REMAINING_REPLICA_NAME}" "${REMAINING_REPLICA_ZONE}" "${KUBE_MASTER_IP}"
0000000000000000000000000000000000000000;;	      gcloud compute target-pools delete \
0000000000000000000000000000000000000000;;	        --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	        --region "${REGION}" \
0000000000000000000000000000000000000000;;	        --quiet \
0000000000000000000000000000000000000000;;	        "${MASTER_NAME}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # If there are no more remaining master replicas, we should delete all remaining network resources.
0000000000000000000000000000000000000000;;	  if [[ "${REMAINING_MASTER_COUNT}" -eq 0 ]]; then
0000000000000000000000000000000000000000;;	    # Delete firewall rule for the master, etcd servers, and nodes.
0000000000000000000000000000000000000000;;	    delete-firewall-rules "${MASTER_NAME}-https" "${MASTER_NAME}-etcd" "${NODE_TAG}-all"
0000000000000000000000000000000000000000;;	    # Delete the master's reserved IP
0000000000000000000000000000000000000000;;	    if gcloud compute addresses describe "${MASTER_NAME}-ip" --region "${REGION}" --project "${PROJECT}" &>/dev/null; then
0000000000000000000000000000000000000000;;	      gcloud compute addresses delete \
0000000000000000000000000000000000000000;;	        --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	        --region "${REGION}" \
0000000000000000000000000000000000000000;;	        --quiet \
0000000000000000000000000000000000000000;;	        "${MASTER_NAME}-ip"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "${KUBE_DELETE_NODES:-}" != "false" ]]; then
0000000000000000000000000000000000000000;;	    # Find out what minions are running.
0000000000000000000000000000000000000000;;	    local -a minions
0000000000000000000000000000000000000000;;	    minions=( $(gcloud compute instances list \
0000000000000000000000000000000000000000;;	                  --project "${PROJECT}" --zones "${ZONE}" \
0000000000000000000000000000000000000000;;	                  --regexp "${NODE_INSTANCE_PREFIX}-.+" \
0000000000000000000000000000000000000000;;	                  --format='value(name)') )
0000000000000000000000000000000000000000;;	    # If any minions are running, delete them in batches.
0000000000000000000000000000000000000000;;	    while (( "${#minions[@]}" > 0 )); do
0000000000000000000000000000000000000000;;	      echo Deleting nodes "${minions[*]::${batch}}"
0000000000000000000000000000000000000000;;	      gcloud compute instances delete \
0000000000000000000000000000000000000000;;	        --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	        --quiet \
0000000000000000000000000000000000000000;;	        --delete-disks boot \
0000000000000000000000000000000000000000;;	        --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	        "${minions[@]::${batch}}"
0000000000000000000000000000000000000000;;	      minions=( "${minions[@]:${batch}}" )
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # If there are no more remaining master replicas: delete routes, pd for influxdb and update kubeconfig
0000000000000000000000000000000000000000;;	  if [[ "${REMAINING_MASTER_COUNT}" -eq 0 ]]; then
0000000000000000000000000000000000000000;;	    # Delete routes.
0000000000000000000000000000000000000000;;	    local -a routes
0000000000000000000000000000000000000000;;	    # Clean up all routes w/ names like "<cluster-name>-<node-GUID>"
0000000000000000000000000000000000000000;;	    # e.g. "kubernetes-12345678-90ab-cdef-1234-567890abcdef". The name is
0000000000000000000000000000000000000000;;	    # determined by the node controller on the master.
0000000000000000000000000000000000000000;;	    # Note that this is currently a noop, as synchronously deleting the node MIG
0000000000000000000000000000000000000000;;	    # first allows the master to cleanup routes itself.
0000000000000000000000000000000000000000;;	    local TRUNCATED_PREFIX="${INSTANCE_PREFIX:0:26}"
0000000000000000000000000000000000000000;;	    routes=( $(gcloud compute routes list --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	      --regexp "${TRUNCATED_PREFIX}-.{8}-.{4}-.{4}-.{4}-.{12}"  \
0000000000000000000000000000000000000000;;	      --format='value(name)') )
0000000000000000000000000000000000000000;;	    while (( "${#routes[@]}" > 0 )); do
0000000000000000000000000000000000000000;;	      echo Deleting routes "${routes[*]::${batch}}"
0000000000000000000000000000000000000000;;	      gcloud compute routes delete \
0000000000000000000000000000000000000000;;	        --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	        --quiet \
0000000000000000000000000000000000000000;;	        "${routes[@]::${batch}}"
0000000000000000000000000000000000000000;;	      routes=( "${routes[@]:${batch}}" )
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Delete persistent disk for influx-db.
0000000000000000000000000000000000000000;;	    if gcloud compute disks describe "${INSTANCE_PREFIX}"-influxdb-pd --zone "${ZONE}" --project "${PROJECT}" &>/dev/null; then
0000000000000000000000000000000000000000;;	      gcloud compute disks delete \
0000000000000000000000000000000000000000;;	        --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	        --quiet \
0000000000000000000000000000000000000000;;	        --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	        "${INSTANCE_PREFIX}"-influxdb-pd
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Delete all remaining firewall rules and network.
0000000000000000000000000000000000000000;;	    delete-firewall-rules \
0000000000000000000000000000000000000000;;	      "${CLUSTER_NAME}-default-internal-master" \
0000000000000000000000000000000000000000;;	      "${CLUSTER_NAME}-default-internal-node" \
0000000000000000000000000000000000000000;;	      "${NETWORK}-default-ssh" \
0000000000000000000000000000000000000000;;	      "${NETWORK}-default-internal"  # Pre-1.5 clusters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if [[ "${KUBE_DELETE_NETWORK}" == "true" ]]; then
0000000000000000000000000000000000000000;;	      delete-subnetworks || true
0000000000000000000000000000000000000000;;	      delete-network || true  # might fail if there are leaked firewall rules
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # If there are no more remaining master replicas, we should update kubeconfig.
0000000000000000000000000000000000000000;;	    export CONTEXT="${PROJECT}_${INSTANCE_PREFIX}"
0000000000000000000000000000000000000000;;	    clear-kubeconfig
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	  # If some master replicas remain: cluster has been changed, we need to re-validate it.
0000000000000000000000000000000000000000;;	    echo "... calling validate-cluster" >&2
0000000000000000000000000000000000000000;;	    # Override errexit
0000000000000000000000000000000000000000;;	    (validate-cluster) && validate_result="$?" || validate_result="$?"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # We have two different failure modes from validate cluster:
0000000000000000000000000000000000000000;;	    # - 1: fatal error - cluster won't be working correctly
0000000000000000000000000000000000000000;;	    # - 2: weak error - something went wrong, but cluster probably will be working correctly
0000000000000000000000000000000000000000;;	    # We just print an error message in case 2).
0000000000000000000000000000000000000000;;	    if [[ "${validate_result}" -eq 1 ]]; then
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    elif [[ "${validate_result}" -eq 2 ]]; then
0000000000000000000000000000000000000000;;	      echo "...ignoring non-fatal errors in validate-cluster" >&2
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  set -e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Prints name of one of the master replicas in the current zone. It will be either
0000000000000000000000000000000000000000;;	# just MASTER_NAME or MASTER_NAME with a suffix for a replica (see get-replica-name-regexp).
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   PROJECT
0000000000000000000000000000000000000000;;	#   ZONE
0000000000000000000000000000000000000000;;	#   MASTER_NAME
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# NOTE: Must be in sync with get-replica-name-regexp and set-replica-name.
0000000000000000000000000000000000000000;;	function get-replica-name() {
0000000000000000000000000000000000000000;;	  echo $(gcloud compute instances list \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --zones "${ZONE}" \
0000000000000000000000000000000000000000;;	    --regexp "$(get-replica-name-regexp)" \
0000000000000000000000000000000000000000;;	    --format "value(name)" | head -n1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Prints comma-separated names of all of the master replicas in all zones.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   PROJECT
0000000000000000000000000000000000000000;;	#   MASTER_NAME
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# NOTE: Must be in sync with get-replica-name-regexp and set-replica-name.
0000000000000000000000000000000000000000;;	function get-all-replica-names() {
0000000000000000000000000000000000000000;;	  echo $(gcloud compute instances list \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --regexp "$(get-replica-name-regexp)" \
0000000000000000000000000000000000000000;;	    --format "value(name)" | tr "\n" "," | sed 's/,$//')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Prints the number of all of the master replicas in all zones.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   MASTER_NAME
0000000000000000000000000000000000000000;;	function get-master-replicas-count() {
0000000000000000000000000000000000000000;;	  detect-project
0000000000000000000000000000000000000000;;	  local num_masters=$(gcloud compute instances list \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --regexp "$(get-replica-name-regexp)" \
0000000000000000000000000000000000000000;;	    --format "value(zone)" | wc -l)
0000000000000000000000000000000000000000;;	  echo -n "${num_masters}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Prints regexp for full master machine name. In a cluster with replicated master,
0000000000000000000000000000000000000000;;	# VM names may either be MASTER_NAME or MASTER_NAME with a suffix for a replica.
0000000000000000000000000000000000000000;;	function get-replica-name-regexp() {
0000000000000000000000000000000000000000;;	  echo "${MASTER_NAME}(-...)?"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Sets REPLICA_NAME to a unique name for a master replica that will match
0000000000000000000000000000000000000000;;	# expected regexp (see get-replica-name-regexp).
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   PROJECT
0000000000000000000000000000000000000000;;	#   ZONE
0000000000000000000000000000000000000000;;	#   MASTER_NAME
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Sets:
0000000000000000000000000000000000000000;;	#   REPLICA_NAME
0000000000000000000000000000000000000000;;	function set-replica-name() {
0000000000000000000000000000000000000000;;	  local instances=$(gcloud compute instances list \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --regexp "$(get-replica-name-regexp)" \
0000000000000000000000000000000000000000;;	    --format "value(name)")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  suffix=""
0000000000000000000000000000000000000000;;	  while echo "${instances}" | grep "${suffix}" &>/dev/null; do
0000000000000000000000000000000000000000;;	    suffix="$(date | md5sum | head -c3)"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  REPLICA_NAME="${MASTER_NAME}-${suffix}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Gets the instance template for given NODE_INSTANCE_PREFIX. It echos the template name so that the function
0000000000000000000000000000000000000000;;	# output can be used.
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   NODE_INSTANCE_PREFIX
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# $1: project
0000000000000000000000000000000000000000;;	function get-template() {
0000000000000000000000000000000000000000;;	  gcloud compute instance-templates list -r "${NODE_INSTANCE_PREFIX}-template(-(${KUBE_RELEASE_VERSION_DASHED_REGEX}|${KUBE_CI_VERSION_DASHED_REGEX}))?" \
0000000000000000000000000000000000000000;;	    --project="${1}" --format='value(name)'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Checks if there are any present resources related kubernetes cluster.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   MASTER_NAME
0000000000000000000000000000000000000000;;	#   NODE_INSTANCE_PREFIX
0000000000000000000000000000000000000000;;	#   ZONE
0000000000000000000000000000000000000000;;	#   REGION
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   KUBE_RESOURCE_FOUND
0000000000000000000000000000000000000000;;	function check-resources() {
0000000000000000000000000000000000000000;;	  detect-project
0000000000000000000000000000000000000000;;	  detect-node-names
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "Looking for already existing resources"
0000000000000000000000000000000000000000;;	  KUBE_RESOURCE_FOUND=""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ -n "${INSTANCE_GROUPS[@]:-}" ]]; then
0000000000000000000000000000000000000000;;	    KUBE_RESOURCE_FOUND="Managed instance groups ${INSTANCE_GROUPS[@]}"
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if gcloud compute instance-templates describe --project "${PROJECT}" "${NODE_INSTANCE_PREFIX}-template" &>/dev/null; then
0000000000000000000000000000000000000000;;	    KUBE_RESOURCE_FOUND="Instance template ${NODE_INSTANCE_PREFIX}-template"
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if gcloud compute instances describe --project "${PROJECT}" "${MASTER_NAME}" --zone "${ZONE}" &>/dev/null; then
0000000000000000000000000000000000000000;;	    KUBE_RESOURCE_FOUND="Kubernetes master ${MASTER_NAME}"
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if gcloud compute disks describe --project "${PROJECT}" "${MASTER_NAME}"-pd --zone "${ZONE}" &>/dev/null; then
0000000000000000000000000000000000000000;;	    KUBE_RESOURCE_FOUND="Persistent disk ${MASTER_NAME}-pd"
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if gcloud compute disks describe --project "${PROJECT}" "${CLUSTER_REGISTRY_DISK}" --zone "${ZONE}" &>/dev/null; then
0000000000000000000000000000000000000000;;	    KUBE_RESOURCE_FOUND="Persistent disk ${CLUSTER_REGISTRY_DISK}"
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Find out what minions are running.
0000000000000000000000000000000000000000;;	  local -a minions
0000000000000000000000000000000000000000;;	  minions=( $(gcloud compute instances list \
0000000000000000000000000000000000000000;;	                --project "${PROJECT}" --zones "${ZONE}" \
0000000000000000000000000000000000000000;;	                --regexp "${NODE_INSTANCE_PREFIX}-.+" \
0000000000000000000000000000000000000000;;	                --format='value(name)') )
0000000000000000000000000000000000000000;;	  if (( "${#minions[@]}" > 0 )); then
0000000000000000000000000000000000000000;;	    KUBE_RESOURCE_FOUND="${#minions[@]} matching matching ${NODE_INSTANCE_PREFIX}-.+"
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if gcloud compute firewall-rules describe --project "${PROJECT}" "${MASTER_NAME}-https" &>/dev/null; then
0000000000000000000000000000000000000000;;	    KUBE_RESOURCE_FOUND="Firewall rules for ${MASTER_NAME}-https"
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if gcloud compute firewall-rules describe --project "${PROJECT}" "${NODE_TAG}-all" &>/dev/null; then
0000000000000000000000000000000000000000;;	    KUBE_RESOURCE_FOUND="Firewall rules for ${MASTER_NAME}-all"
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local -a routes
0000000000000000000000000000000000000000;;	  routes=( $(gcloud compute routes list --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --regexp "${INSTANCE_PREFIX}-minion-.{4}" --format='value(name)') )
0000000000000000000000000000000000000000;;	  if (( "${#routes[@]}" > 0 )); then
0000000000000000000000000000000000000000;;	    KUBE_RESOURCE_FOUND="${#routes[@]} routes matching ${INSTANCE_PREFIX}-minion-.{4}"
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if gcloud compute addresses describe --project "${PROJECT}" "${MASTER_NAME}-ip" --region "${REGION}" &>/dev/null; then
0000000000000000000000000000000000000000;;	    KUBE_RESOURCE_FOUND="Master's reserved IP"
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # No resources found.
0000000000000000000000000000000000000000;;	  return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Prepare to push new binaries to kubernetes cluster
0000000000000000000000000000000000000000;;	#  $1 - whether prepare push to node
0000000000000000000000000000000000000000;;	function prepare-push() {
0000000000000000000000000000000000000000;;	  local node="${1-}"
0000000000000000000000000000000000000000;;	  #TODO(dawnchen): figure out how to upgrade a Container Linux node
0000000000000000000000000000000000000000;;	  if [[ "${node}" == "true" && "${NODE_OS_DISTRIBUTION}" != "debian" ]]; then
0000000000000000000000000000000000000000;;	    echo "Updating nodes in a kubernetes cluster with ${NODE_OS_DISTRIBUTION} is not supported yet." >&2
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [[ "${node}" != "true" && "${MASTER_OS_DISTRIBUTION}" != "debian" ]]; then
0000000000000000000000000000000000000000;;	    echo "Updating the master in a kubernetes cluster with ${MASTER_OS_DISTRIBUTION} is not supported yet." >&2
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  OUTPUT=${KUBE_ROOT}/_output/logs
0000000000000000000000000000000000000000;;	  mkdir -p ${OUTPUT}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::util::ensure-temp-dir
0000000000000000000000000000000000000000;;	  detect-project
0000000000000000000000000000000000000000;;	  detect-master
0000000000000000000000000000000000000000;;	  detect-node-names
0000000000000000000000000000000000000000;;	  get-kubeconfig-basicauth
0000000000000000000000000000000000000000;;	  get-kubeconfig-bearertoken
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Make sure we have the tar files staged on Google Storage
0000000000000000000000000000000000000000;;	  tars_from_version
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Prepare node env vars and update MIG template
0000000000000000000000000000000000000000;;	  if [[ "${node}" == "true" ]]; then
0000000000000000000000000000000000000000;;	    write-node-env
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    local scope_flags=$(get-scope-flags)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Ugly hack: Since it is not possible to delete instance-template that is currently
0000000000000000000000000000000000000000;;	    # being used, create a temp one, then delete the old one and recreate it once again.
0000000000000000000000000000000000000000;;	    local tmp_template_name="${NODE_INSTANCE_PREFIX}-template-tmp"
0000000000000000000000000000000000000000;;	    create-node-instance-template $tmp_template_name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    local template_name="${NODE_INSTANCE_PREFIX}-template"
0000000000000000000000000000000000000000;;	    for group in ${INSTANCE_GROUPS[@]:-}; do
0000000000000000000000000000000000000000;;	      gcloud compute instance-groups managed \
0000000000000000000000000000000000000000;;	        set-instance-template "${group}" \
0000000000000000000000000000000000000000;;	        --template "$tmp_template_name" \
0000000000000000000000000000000000000000;;	        --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	        --project "${PROJECT}" || true;
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    gcloud compute instance-templates delete \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	      --quiet \
0000000000000000000000000000000000000000;;	      "$template_name" || true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    create-node-instance-template "$template_name"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    for group in ${INSTANCE_GROUPS[@]:-}; do
0000000000000000000000000000000000000000;;	      gcloud compute instance-groups managed \
0000000000000000000000000000000000000000;;	        set-instance-template "${group}" \
0000000000000000000000000000000000000000;;	        --template "$template_name" \
0000000000000000000000000000000000000000;;	        --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	        --project "${PROJECT}" || true;
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    gcloud compute instance-templates delete \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	      --quiet \
0000000000000000000000000000000000000000;;	      "$tmp_template_name" || true
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Push binaries to kubernetes master
0000000000000000000000000000000000000000;;	function push-master() {
0000000000000000000000000000000000000000;;	  echo "Updating master metadata ..."
0000000000000000000000000000000000000000;;	  write-master-env
0000000000000000000000000000000000000000;;	  prepare-startup-script
0000000000000000000000000000000000000000;;	  add-instance-metadata-from-file "${KUBE_MASTER}" "kube-env=${KUBE_TEMP}/master-kube-env.yaml" "startup-script=${KUBE_TEMP}/configure-vm.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "Pushing to master (log at ${OUTPUT}/push-${KUBE_MASTER}.log) ..."
0000000000000000000000000000000000000000;;	  cat ${KUBE_TEMP}/configure-vm.sh | gcloud compute ssh --ssh-flag="-o LogLevel=quiet" --project "${PROJECT}" --zone "${ZONE}" "${KUBE_MASTER}" --command "sudo bash -s -- --push" &> ${OUTPUT}/push-"${KUBE_MASTER}".log
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Push binaries to kubernetes node
0000000000000000000000000000000000000000;;	function push-node() {
0000000000000000000000000000000000000000;;	  node=${1}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "Updating node ${node} metadata... "
0000000000000000000000000000000000000000;;	  prepare-startup-script
0000000000000000000000000000000000000000;;	  add-instance-metadata-from-file "${node}" "kube-env=${KUBE_TEMP}/node-kube-env.yaml" "startup-script=${KUBE_TEMP}/configure-vm.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "Start upgrading node ${node} (log at ${OUTPUT}/push-${node}.log) ..."
0000000000000000000000000000000000000000;;	  cat ${KUBE_TEMP}/configure-vm.sh | gcloud compute ssh --ssh-flag="-o LogLevel=quiet" --project "${PROJECT}" --zone "${ZONE}" "${node}" --command "sudo bash -s -- --push" &> ${OUTPUT}/push-"${node}".log
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Push binaries to kubernetes cluster
0000000000000000000000000000000000000000;;	function kube-push() {
0000000000000000000000000000000000000000;;	  # Disable this until it's fixed.
0000000000000000000000000000000000000000;;	  # See https://github.com/kubernetes/kubernetes/issues/17397
0000000000000000000000000000000000000000;;	  echo "./cluster/kube-push.sh is currently not supported in GCE."
0000000000000000000000000000000000000000;;	  echo "Please use ./cluster/gce/upgrade.sh."
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  prepare-push true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  push-master
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for (( i=0; i<${#NODE_NAMES[@]}; i++)); do
0000000000000000000000000000000000000000;;	    push-node "${NODE_NAMES[$i]}" &
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::util::wait-for-jobs || {
0000000000000000000000000000000000000000;;	    echo -e "${color_red}Some commands failed.${color_norm}" >&2
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # TODO(zmerlynn): Re-create instance-template with the new
0000000000000000000000000000000000000000;;	  # node-kube-env. This isn't important until the node-ip-range issue
0000000000000000000000000000000000000000;;	  # is solved (because that's blocking automatic dynamic nodes from
0000000000000000000000000000000000000000;;	  # working). The node-kube-env has to be composed with the KUBELET_TOKEN
0000000000000000000000000000000000000000;;	  # and KUBE_PROXY_TOKEN.  Ideally we would have
0000000000000000000000000000000000000000;;	  # http://issue.k8s.io/3168
0000000000000000000000000000000000000000;;	  # implemented before then, though, so avoiding this mess until then.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo "Kubernetes cluster is running.  The master is running at:"
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo "  https://${KUBE_MASTER_IP}"
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo "The user name and password to use is located in ~/.kube/config"
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# -----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	# Cluster specific test helpers used from hack/e2e.go
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Execute prior to running tests to build a release if required for env.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed Vars:
0000000000000000000000000000000000000000;;	#   KUBE_ROOT
0000000000000000000000000000000000000000;;	function test-build-release() {
0000000000000000000000000000000000000000;;	  # Make a release
0000000000000000000000000000000000000000;;	  "${KUBE_ROOT}/build/release.sh"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Execute prior to running tests to initialize required structure. This is
0000000000000000000000000000000000000000;;	# called from hack/e2e.go only when running -up.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   Variables from config.sh
0000000000000000000000000000000000000000;;	function test-setup() {
0000000000000000000000000000000000000000;;	  # Detect the project into $PROJECT if it isn't set
0000000000000000000000000000000000000000;;	  detect-project
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ ${MULTIZONE:-} == "true" && -n ${E2E_ZONES:-} ]]; then
0000000000000000000000000000000000000000;;	    for KUBE_GCE_ZONE in ${E2E_ZONES}
0000000000000000000000000000000000000000;;	    do
0000000000000000000000000000000000000000;;	      KUBE_GCE_ZONE="${KUBE_GCE_ZONE}" KUBE_USE_EXISTING_MASTER="${KUBE_USE_EXISTING_MASTER:-}" "${KUBE_ROOT}/cluster/kube-up.sh"
0000000000000000000000000000000000000000;;	      KUBE_USE_EXISTING_MASTER="true" # For subsequent zones we use the existing master
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    "${KUBE_ROOT}/cluster/kube-up.sh"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Open up port 80 & 8080 so common containers on minions can be reached
0000000000000000000000000000000000000000;;	  # TODO(roberthbailey): Remove this once we are no longer relying on hostPorts.
0000000000000000000000000000000000000000;;	  local start=`date +%s`
0000000000000000000000000000000000000000;;	  gcloud compute firewall-rules create \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --target-tags "${NODE_TAG}" \
0000000000000000000000000000000000000000;;	    --allow tcp:80,tcp:8080 \
0000000000000000000000000000000000000000;;	    --network "${NETWORK}" \
0000000000000000000000000000000000000000;;	    "${NODE_TAG}-${INSTANCE_PREFIX}-http-alt" 2> /dev/null || true
0000000000000000000000000000000000000000;;	  # As there is no simple way to wait longer for this operation we need to manually
0000000000000000000000000000000000000000;;	  # wait some additional time (20 minutes altogether).
0000000000000000000000000000000000000000;;	  while ! gcloud compute firewall-rules describe --project "${PROJECT}" "${NODE_TAG}-${INSTANCE_PREFIX}-http-alt" 2> /dev/null; do
0000000000000000000000000000000000000000;;	    if [[ $(($start + 1200)) -lt `date +%s` ]]; then
0000000000000000000000000000000000000000;;	      echo -e "${color_red}Failed to create firewall ${NODE_TAG}-${INSTANCE_PREFIX}-http-alt in ${PROJECT}" >&2
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    sleep 5
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Open up the NodePort range
0000000000000000000000000000000000000000;;	  # TODO(justinsb): Move to main setup, if we decide whether we want to do this by default.
0000000000000000000000000000000000000000;;	  start=`date +%s`
0000000000000000000000000000000000000000;;	  gcloud compute firewall-rules create \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --target-tags "${NODE_TAG}" \
0000000000000000000000000000000000000000;;	    --allow tcp:30000-32767,udp:30000-32767 \
0000000000000000000000000000000000000000;;	    --network "${NETWORK}" \
0000000000000000000000000000000000000000;;	    "${NODE_TAG}-${INSTANCE_PREFIX}-nodeports" 2> /dev/null || true
0000000000000000000000000000000000000000;;	  # As there is no simple way to wait longer for this operation we need to manually
0000000000000000000000000000000000000000;;	  # wait some additional time (20 minutes altogether).
0000000000000000000000000000000000000000;;	  while ! gcloud compute firewall-rules describe --project "${PROJECT}" "${NODE_TAG}-${INSTANCE_PREFIX}-nodeports" 2> /dev/null; do
0000000000000000000000000000000000000000;;	    if [[ $(($start + 1200)) -lt `date +%s` ]]; then
0000000000000000000000000000000000000000;;	      echo -e "${color_red}Failed to create firewall ${NODE_TAG}-${INSTANCE_PREFIX}-nodeports in ${PROJECT}" >&2
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    sleep 5
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Execute after running tests to perform any required clean-up. This is called
0000000000000000000000000000000000000000;;	# from hack/e2e.go
0000000000000000000000000000000000000000;;	function test-teardown() {
0000000000000000000000000000000000000000;;	  detect-project
0000000000000000000000000000000000000000;;	  echo "Shutting down test cluster in background."
0000000000000000000000000000000000000000;;	  delete-firewall-rules \
0000000000000000000000000000000000000000;;	    "${NODE_TAG}-${INSTANCE_PREFIX}-http-alt" \
0000000000000000000000000000000000000000;;	    "${NODE_TAG}-${INSTANCE_PREFIX}-nodeports"
0000000000000000000000000000000000000000;;	  if [[ ${MULTIZONE:-} == "true" && -n ${E2E_ZONES:-} ]]; then
0000000000000000000000000000000000000000;;	      local zones=( ${E2E_ZONES} )
0000000000000000000000000000000000000000;;	      # tear them down in reverse order, finally tearing down the master too.
0000000000000000000000000000000000000000;;	      for ((zone_num=${#zones[@]}-1; zone_num>0; zone_num--))
0000000000000000000000000000000000000000;;	      do
0000000000000000000000000000000000000000;;		  KUBE_GCE_ZONE="${zones[zone_num]}" KUBE_USE_EXISTING_MASTER="true" "${KUBE_ROOT}/cluster/kube-down.sh"
0000000000000000000000000000000000000000;;	      done
0000000000000000000000000000000000000000;;	      KUBE_GCE_ZONE="${zones[0]}" KUBE_USE_EXISTING_MASTER="false" "${KUBE_ROOT}/cluster/kube-down.sh"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	      "${KUBE_ROOT}/cluster/kube-down.sh"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# SSH to a node by name ($1) and run a command ($2).
0000000000000000000000000000000000000000;;	function ssh-to-node() {
0000000000000000000000000000000000000000;;	  local node="$1"
0000000000000000000000000000000000000000;;	  local cmd="$2"
0000000000000000000000000000000000000000;;	  # Loop until we can successfully ssh into the box
0000000000000000000000000000000000000000;;	  for try in {1..5}; do
0000000000000000000000000000000000000000;;	    if gcloud compute ssh --ssh-flag="-o LogLevel=quiet" --ssh-flag="-o ConnectTimeout=30" --project "${PROJECT}" --zone="${ZONE}" "${node}" --command "echo test > /dev/null"; then
0000000000000000000000000000000000000000;;	      break
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    sleep 5
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  # Then actually try the command.
0000000000000000000000000000000000000000;;	  gcloud compute ssh --ssh-flag="-o LogLevel=quiet" --ssh-flag="-o ConnectTimeout=30" --project "${PROJECT}" --zone="${ZONE}" "${node}" --command "${cmd}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Perform preparations required to run e2e tests
0000000000000000000000000000000000000000;;	function prepare-e2e() {
0000000000000000000000000000000000000000;;	  detect-project
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Writes configure-vm.sh to a temporary location with comments stripped. GCE
0000000000000000000000000000000000000000;;	# limits the size of metadata fields to 32K, and stripping comments is the
0000000000000000000000000000000000000000;;	# easiest way to buy us a little more room.
0000000000000000000000000000000000000000;;	function prepare-startup-script() {
0000000000000000000000000000000000000000;;	  # Find a standard sed instance (and ensure that the command works as expected on a Mac).
0000000000000000000000000000000000000000;;	  SED=sed
0000000000000000000000000000000000000000;;	  if which gsed &>/dev/null; then
0000000000000000000000000000000000000000;;	    SED=gsed
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if ! ($SED --version 2>&1 | grep -q GNU); then
0000000000000000000000000000000000000000;;	    echo "!!! GNU sed is required.  If on OS X, use 'brew install gnu-sed'."
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  $SED '/^\s*#\([^!].*\)*$/ d' ${KUBE_ROOT}/cluster/gce/configure-vm.sh > ${KUBE_TEMP}/configure-vm.sh
0000000000000000000000000000000000000000;;	}
