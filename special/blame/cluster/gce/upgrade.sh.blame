0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2015 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# !!!EXPERIMENTAL !!! Upgrade script for GCE. Expect this to get
0000000000000000000000000000000000000000;;	# rewritten in Go in relatively short order, but it allows us to start
0000000000000000000000000000000000000000;;	# testing the concepts.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	set -o errexit
0000000000000000000000000000000000000000;;	set -o nounset
0000000000000000000000000000000000000000;;	set -o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "${KUBERNETES_PROVIDER:-gce}" != "gce" ]]; then
0000000000000000000000000000000000000000;;	  echo "!!! ${1} only works on GCE" >&2
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_ROOT=$(dirname "${BASH_SOURCE}")/../..
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/hack/lib/util.sh"
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/cluster/kube-util.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function usage() {
0000000000000000000000000000000000000000;;	  echo "!!! EXPERIMENTAL !!!"
0000000000000000000000000000000000000000;;	  echo ""
0000000000000000000000000000000000000000;;	  echo "${0} [-M | -N | -P] [-o] (-l | <version number or publication>)"
0000000000000000000000000000000000000000;;	  echo "  Upgrades master and nodes by default"
0000000000000000000000000000000000000000;;	  echo "  -M:  Upgrade master only"
0000000000000000000000000000000000000000;;	  echo "  -N:  Upgrade nodes only"
0000000000000000000000000000000000000000;;	  echo "  -P:  Node upgrade prerequisites only (create a new instance template)"
0000000000000000000000000000000000000000;;	  echo "  -o:  Use os distro sepcified in KUBE_NODE_OS_DISTRIBUTION for new nodes. Options include 'debian' or 'gci'"
0000000000000000000000000000000000000000;;	  echo "  -l:  Use local(dev) binaries. This is only supported for master upgrades."
0000000000000000000000000000000000000000;;	  echo ""
0000000000000000000000000000000000000000;;	  echo '  Version number or publication is either a proper version number'
0000000000000000000000000000000000000000;;	  echo '  (e.g. "v1.0.6", "v1.2.0-alpha.1.881+376438b69c7612") or a version'
0000000000000000000000000000000000000000;;	  echo '  publication of the form <bucket>/<version> (e.g. "release/stable",'
0000000000000000000000000000000000000000;;	  echo '  "ci/latest-1").  Some common ones are:'
0000000000000000000000000000000000000000;;	  echo '    - "release/stable"'
0000000000000000000000000000000000000000;;	  echo '    - "release/latest"'
0000000000000000000000000000000000000000;;	  echo '    - "ci/latest"'
0000000000000000000000000000000000000000;;	  echo '  See the docs on getting builds for more information about version publication.'
0000000000000000000000000000000000000000;;	  echo ""
0000000000000000000000000000000000000000;;	  echo "(... Fetching current release versions ...)"
0000000000000000000000000000000000000000;;	  echo ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # NOTE: IF YOU CHANGE THE FOLLOWING LIST, ALSO UPDATE test/e2e/cluster_upgrade.go
0000000000000000000000000000000000000000;;	  local release_stable
0000000000000000000000000000000000000000;;	  local release_latest
0000000000000000000000000000000000000000;;	  local ci_latest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  release_stable=$(gsutil cat gs://kubernetes-release/release/stable.txt)
0000000000000000000000000000000000000000;;	  release_latest=$(gsutil cat gs://kubernetes-release/release/latest.txt)
0000000000000000000000000000000000000000;;	  ci_latest=$(gsutil cat gs://kubernetes-release-dev/ci/latest.txt)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "Right now, versions are as follows:"
0000000000000000000000000000000000000000;;	  echo "  release/stable: ${0} ${release_stable}"
0000000000000000000000000000000000000000;;	  echo "  release/latest: ${0} ${release_latest}"
0000000000000000000000000000000000000000;;	  echo "  ci/latest:      ${0} ${ci_latest}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function print-node-version-info() {
0000000000000000000000000000000000000000;;	  echo "== $1 Node OS and Kubelet Versions =="
0000000000000000000000000000000000000000;;	  "${KUBE_ROOT}/cluster/kubectl.sh" get nodes -o=jsonpath='{range .items[*]}name: "{.metadata.name}", osImage: "{.status.nodeInfo.osImage}", kubeletVersion: "{.status.nodeInfo.kubeletVersion}"{"\n"}{end}'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function upgrade-master() {
0000000000000000000000000000000000000000;;	  local num_masters
0000000000000000000000000000000000000000;;	  num_masters=$(get-master-replicas-count)
0000000000000000000000000000000000000000;;	  if [[ "${num_masters}" -gt 1 ]]; then
0000000000000000000000000000000000000000;;	    echo "Upgrade of master not supported if more than one master replica present. The current number of master replicas: ${num_masters}"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "== Upgrading master to '${SERVER_BINARY_TAR_URL}'. Do not interrupt, deleting master instance. =="
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Tries to figure out KUBE_USER/KUBE_PASSWORD by first looking under
0000000000000000000000000000000000000000;;	  # kubeconfig:username, and then under kubeconfig:username-basic-auth.
0000000000000000000000000000000000000000;;	  # TODO: KUBE_USER is used in generating ABAC policy which the
0000000000000000000000000000000000000000;;	  # apiserver may not have enabled. If it's enabled, we must have a user
0000000000000000000000000000000000000000;;	  # to generate a valid ABAC policy. If the username changes, should
0000000000000000000000000000000000000000;;	  # the script fail? Should we generate a default username and password
0000000000000000000000000000000000000000;;	  # if the section is missing in kubeconfig? Handle this better in 1.5.
0000000000000000000000000000000000000000;;	  get-kubeconfig-basicauth
0000000000000000000000000000000000000000;;	  get-kubeconfig-bearertoken
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  detect-master
0000000000000000000000000000000000000000;;	  parse-master-env
0000000000000000000000000000000000000000;;	  upgrade-master-env
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  backfile-kubeletauth-certs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Delete the master instance. Note that the master-pd is created
0000000000000000000000000000000000000000;;	  # with auto-delete=no, so it should not be deleted.
0000000000000000000000000000000000000000;;	  gcloud compute instances delete \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --quiet \
0000000000000000000000000000000000000000;;	    --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	    "${MASTER_NAME}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  create-master-instance "${MASTER_NAME}-ip"
0000000000000000000000000000000000000000;;	  wait-for-master
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function upgrade-master-env() {
0000000000000000000000000000000000000000;;	  echo "== Upgrading master environment variables. =="
0000000000000000000000000000000000000000;;	  # Generate the node problem detector token if it isn't present on the original
0000000000000000000000000000000000000000;;	  # master.
0000000000000000000000000000000000000000;;	 if [[ "${ENABLE_NODE_PROBLEM_DETECTOR:-}" == "standalone" && "${NODE_PROBLEM_DETECTOR_TOKEN:-}" == "" ]]; then
0000000000000000000000000000000000000000;;	    NODE_PROBLEM_DETECTOR_TOKEN=$(dd if=/dev/urandom bs=128 count=1 2>/dev/null | base64 | tr -d "=+/" | dd bs=32 count=1 2>/dev/null)
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# TODO(mikedanese): delete when we don't support < 1.6
0000000000000000000000000000000000000000;;	function backfile-kubeletauth-certs() {
0000000000000000000000000000000000000000;;	  if [[ ! -z "${KUBEAPISERVER_CERT_BASE64:-}" && ! -z "${KUBEAPISERVER_CERT_BASE64:-}" ]]; then
0000000000000000000000000000000000000000;;	    return 0
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  mkdir -p "${KUBE_TEMP}/pki"
0000000000000000000000000000000000000000;;	  echo "${CA_KEY_BASE64}" | base64 -d > "${KUBE_TEMP}/pki/ca.key"
0000000000000000000000000000000000000000;;	  echo "${CA_CERT_BASE64}" | base64 -d > "${KUBE_TEMP}/pki/ca.crt"
0000000000000000000000000000000000000000;;	  (cd "${KUBE_TEMP}/pki"
0000000000000000000000000000000000000000;;	    kube::util::ensure-cfssl "${KUBE_TEMP}/cfssl"
0000000000000000000000000000000000000000;;	    cat <<EOF > ca-config.json
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	  "signing": {
0000000000000000000000000000000000000000;;	    "client": {
0000000000000000000000000000000000000000;;	      "expiry": "43800h",
0000000000000000000000000000000000000000;;	      "usages": [
0000000000000000000000000000000000000000;;	        "signing",
0000000000000000000000000000000000000000;;	        "key encipherment",
0000000000000000000000000000000000000000;;	        "client auth"
0000000000000000000000000000000000000000;;	      ]
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    # the name kube-apiserver is bound to the node proxy
0000000000000000000000000000000000000000;;	    # subpaths required for the apiserver to hit proxy
0000000000000000000000000000000000000000;;	    # endpoints on the kubelet's handler.
0000000000000000000000000000000000000000;;	    cat <<EOF \
0000000000000000000000000000000000000000;;	      | "${CFSSL_BIN}" gencert \
0000000000000000000000000000000000000000;;	        -ca=ca.crt \
0000000000000000000000000000000000000000;;	        -ca-key=ca.key \
0000000000000000000000000000000000000000;;	        -config=ca-config.json \
0000000000000000000000000000000000000000;;	        -profile=client \
0000000000000000000000000000000000000000;;	        - \
0000000000000000000000000000000000000000;;	      | "${CFSSLJSON_BIN}" -bare kube-apiserver
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	  "CN": "kube-apiserver"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	  KUBEAPISERVER_CERT_BASE64=$(cat "${KUBE_TEMP}/pki/kube-apiserver.pem" | base64 | tr -d '\r\n')
0000000000000000000000000000000000000000;;	  KUBEAPISERVER_KEY_BASE64=$(cat "${KUBE_TEMP}/pki/kube-apiserver-key.pem" | base64 | tr -d '\r\n')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function wait-for-master() {
0000000000000000000000000000000000000000;;	  echo "== Waiting for new master to respond to API requests =="
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local curl_auth_arg
0000000000000000000000000000000000000000;;	  if [[ -n ${KUBE_BEARER_TOKEN:-} ]]; then
0000000000000000000000000000000000000000;;	    curl_auth_arg=(-H "Authorization: Bearer ${KUBE_BEARER_TOKEN}")
0000000000000000000000000000000000000000;;	  elif [[ -n ${KUBE_PASSWORD:-} ]]; then
0000000000000000000000000000000000000000;;	    curl_auth_arg=(--user "${KUBE_USER}:${KUBE_PASSWORD}")
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    echo "can't get auth credentials for the current master"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  until curl --insecure "${curl_auth_arg[@]}" --max-time 5 \
0000000000000000000000000000000000000000;;	    --fail --output /dev/null --silent "https://${KUBE_MASTER_IP}/healthz"; do
0000000000000000000000000000000000000000;;	    printf "."
0000000000000000000000000000000000000000;;	    sleep 2
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "== Done =="
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Perform common upgrade setup tasks
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars
0000000000000000000000000000000000000000;;	#   KUBE_VERSION
0000000000000000000000000000000000000000;;	function prepare-upgrade() {
0000000000000000000000000000000000000000;;	  kube::util::ensure-temp-dir
0000000000000000000000000000000000000000;;	  detect-project
0000000000000000000000000000000000000000;;	  detect-node-names # sets INSTANCE_GROUPS
0000000000000000000000000000000000000000;;	  write-cluster-name
0000000000000000000000000000000000000000;;	  tars_from_version
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Reads kube-env metadata from first node in NODE_NAMES.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   NODE_NAMES
0000000000000000000000000000000000000000;;	#   PROJECT
0000000000000000000000000000000000000000;;	#   ZONE
0000000000000000000000000000000000000000;;	function get-node-env() {
0000000000000000000000000000000000000000;;	  # TODO(zmerlynn): Make this more reliable with retries.
0000000000000000000000000000000000000000;;	  gcloud compute --project ${PROJECT} ssh --zone ${ZONE} ${NODE_NAMES[0]} --command \
0000000000000000000000000000000000000000;;	    "curl --fail --silent -H 'Metadata-Flavor: Google' \
0000000000000000000000000000000000000000;;	      'http://metadata/computeMetadata/v1/instance/attributes/kube-env'" 2>/dev/null
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Read os distro information from /os/release on node.
0000000000000000000000000000000000000000;;	# $1: The name of node
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   PROJECT
0000000000000000000000000000000000000000;;	#   ZONE
0000000000000000000000000000000000000000;;	function get-node-os() {
0000000000000000000000000000000000000000;;	  gcloud compute ssh "$1" \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	    --command \
0000000000000000000000000000000000000000;;	    "cat /etc/os-release | grep \"^ID=.*\" | cut -c 4-"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   KUBE_VERSION
0000000000000000000000000000000000000000;;	#   NODE_SCOPES
0000000000000000000000000000000000000000;;	#   NODE_INSTANCE_PREFIX
0000000000000000000000000000000000000000;;	#   PROJECT
0000000000000000000000000000000000000000;;	#   ZONE
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   KUBELET_TOKEN
0000000000000000000000000000000000000000;;	#   KUBE_PROXY_TOKEN
0000000000000000000000000000000000000000;;	#   NODE_PROBLEM_DETECTOR_TOKEN
0000000000000000000000000000000000000000;;	#   CA_CERT_BASE64
0000000000000000000000000000000000000000;;	#   EXTRA_DOCKER_OPTS
0000000000000000000000000000000000000000;;	#   KUBELET_CERT_BASE64
0000000000000000000000000000000000000000;;	#   KUBELET_KEY_BASE64
0000000000000000000000000000000000000000;;	function upgrade-nodes() {
0000000000000000000000000000000000000000;;	  prepare-node-upgrade
0000000000000000000000000000000000000000;;	  do-node-upgrade
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function setup-base-image() {
0000000000000000000000000000000000000000;;	  if [[ "${env_os_distro}" == "false" ]]; then
0000000000000000000000000000000000000000;;	    echo "== Ensuring that new Node base OS image matched the existing Node base OS image"
0000000000000000000000000000000000000000;;	    NODE_OS_DISTRIBUTION=$(get-node-os "${NODE_NAMES[0]}")
0000000000000000000000000000000000000000;;	    source "${KUBE_ROOT}/cluster/gce/${NODE_OS_DISTRIBUTION}/node-helper.sh"
0000000000000000000000000000000000000000;;	    # Reset the node image based on current os distro
0000000000000000000000000000000000000000;;	    set-node-image
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# prepare-node-upgrade creates a new instance template suitable for upgrading
0000000000000000000000000000000000000000;;	# to KUBE_VERSION and echos a single line with the name of the new template.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   KUBE_VERSION
0000000000000000000000000000000000000000;;	#   NODE_SCOPES
0000000000000000000000000000000000000000;;	#   NODE_INSTANCE_PREFIX
0000000000000000000000000000000000000000;;	#   PROJECT
0000000000000000000000000000000000000000;;	#   ZONE
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   SANITIZED_VERSION
0000000000000000000000000000000000000000;;	#   INSTANCE_GROUPS
0000000000000000000000000000000000000000;;	#   KUBELET_TOKEN
0000000000000000000000000000000000000000;;	#   KUBE_PROXY_TOKEN
0000000000000000000000000000000000000000;;	#   NODE_PROBLEM_DETECTOR_TOKEN
0000000000000000000000000000000000000000;;	#   CA_CERT_BASE64
0000000000000000000000000000000000000000;;	#   EXTRA_DOCKER_OPTS
0000000000000000000000000000000000000000;;	#   KUBELET_CERT_BASE64
0000000000000000000000000000000000000000;;	#   KUBELET_KEY_BASE64
0000000000000000000000000000000000000000;;	function prepare-node-upgrade() {
0000000000000000000000000000000000000000;;	  echo "== Preparing node upgrade (to ${KUBE_VERSION}). ==" >&2
0000000000000000000000000000000000000000;;	  setup-base-image
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  SANITIZED_VERSION=$(echo ${KUBE_VERSION} | sed 's/[\.\+]/-/g')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # TODO(zmerlynn): Refactor setting scope flags.
0000000000000000000000000000000000000000;;	  local scope_flags=
0000000000000000000000000000000000000000;;	  if [ -n "${NODE_SCOPES}" ]; then
0000000000000000000000000000000000000000;;	    scope_flags="--scopes ${NODE_SCOPES}"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    scope_flags="--no-scopes"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Get required node env vars from exiting template.
0000000000000000000000000000000000000000;;	  local node_env=$(get-node-env)
0000000000000000000000000000000000000000;;	  KUBELET_TOKEN=$(get-env-val "${node_env}" "KUBELET_TOKEN")
0000000000000000000000000000000000000000;;	  KUBE_PROXY_TOKEN=$(get-env-val "${node_env}" "KUBE_PROXY_TOKEN")
0000000000000000000000000000000000000000;;	  NODE_PROBLEM_DETECTOR_TOKEN=$(get-env-val "${node_env}" "NODE_PROBLEM_DETECTOR_TOKEN")
0000000000000000000000000000000000000000;;	  CA_CERT_BASE64=$(get-env-val "${node_env}" "CA_CERT")
0000000000000000000000000000000000000000;;	  EXTRA_DOCKER_OPTS=$(get-env-val "${node_env}" "EXTRA_DOCKER_OPTS")
0000000000000000000000000000000000000000;;	  KUBELET_CERT_BASE64=$(get-env-val "${node_env}" "KUBELET_CERT")
0000000000000000000000000000000000000000;;	  KUBELET_KEY_BASE64=$(get-env-val "${node_env}" "KUBELET_KEY")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  upgrade-node-env
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # TODO(zmerlynn): How do we ensure kube-env is written in a ${version}-
0000000000000000000000000000000000000000;;	  #                 compatible way?
0000000000000000000000000000000000000000;;	  write-node-env
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # TODO(zmerlynn): Get configure-vm script from ${version}. (Must plumb this
0000000000000000000000000000000000000000;;	  #                 through all create-node-instance-template implementations).
0000000000000000000000000000000000000000;;	  local template_name=$(get-template-name-from-version ${SANITIZED_VERSION})
0000000000000000000000000000000000000000;;	  create-node-instance-template "${template_name}"
0000000000000000000000000000000000000000;;	  # The following is echo'd so that callers can get the template name.
0000000000000000000000000000000000000000;;	  echo "Instance template name: ${template_name}"
0000000000000000000000000000000000000000;;	  echo "== Finished preparing node upgrade (to ${KUBE_VERSION}). ==" >&2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function upgrade-node-env() {
0000000000000000000000000000000000000000;;	  echo "== Upgrading node environment variables. =="
0000000000000000000000000000000000000000;;	  # Get the node problem detector token from master if it isn't present on
0000000000000000000000000000000000000000;;	  # the original node.
0000000000000000000000000000000000000000;;	  if [[ "${ENABLE_NODE_PROBLEM_DETECTOR:-}" == "standalone" && "${NODE_PROBLEM_DETECTOR_TOKEN:-}" == "" ]]; then
0000000000000000000000000000000000000000;;	    detect-master
0000000000000000000000000000000000000000;;	    local master_env=$(get-master-env)
0000000000000000000000000000000000000000;;	    NODE_PROBLEM_DETECTOR_TOKEN=$(get-env-val "${master_env}" "NODE_PROBLEM_DETECTOR_TOKEN")
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Prereqs:
0000000000000000000000000000000000000000;;	# - prepare-node-upgrade should have been called successfully
0000000000000000000000000000000000000000;;	function do-node-upgrade() {
0000000000000000000000000000000000000000;;	  echo "== Upgrading nodes to ${KUBE_VERSION}. ==" >&2
0000000000000000000000000000000000000000;;	  # Do the actual upgrade.
0000000000000000000000000000000000000000;;	  # NOTE(zmerlynn): If you are changing this gcloud command, update
0000000000000000000000000000000000000000;;	  #                 test/e2e/cluster_upgrade.go to match this EXACTLY.
0000000000000000000000000000000000000000;;	  local template_name=$(get-template-name-from-version ${SANITIZED_VERSION})
0000000000000000000000000000000000000000;;	  local old_templates=()
0000000000000000000000000000000000000000;;	  local updates=()
0000000000000000000000000000000000000000;;	  for group in ${INSTANCE_GROUPS[@]}; do
0000000000000000000000000000000000000000;;	    old_templates+=($(gcloud compute instance-groups managed list \
0000000000000000000000000000000000000000;;	        --project="${PROJECT}" \
0000000000000000000000000000000000000000;;	        --zones="${ZONE}" \
0000000000000000000000000000000000000000;;	        --regexp="${group}" \
0000000000000000000000000000000000000000;;	        --format='value(instanceTemplate)' || true))
0000000000000000000000000000000000000000;;	    set_instance_template_out=$(gcloud compute instance-groups managed set-instance-template "${group}" \
0000000000000000000000000000000000000000;;	      --template="${template_name}" \
0000000000000000000000000000000000000000;;	      --project="${PROJECT}" \
0000000000000000000000000000000000000000;;	      --zone="${ZONE}" 2>&1) && set_instance_template_rc=$? || set_instance_template_rc=$?
0000000000000000000000000000000000000000;;	    if [[ "${set_instance_template_rc}" != 0 ]]; then
0000000000000000000000000000000000000000;;	      echo "== FAILED to set-instance-template for ${group} to ${template_name} =="
0000000000000000000000000000000000000000;;	      echo "${set_instance_template_out}"
0000000000000000000000000000000000000000;;	      return ${set_instance_template_rc}
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    instances=()
0000000000000000000000000000000000000000;;	    instances+=($(gcloud compute instance-groups managed list-instances "${group}" \
0000000000000000000000000000000000000000;;	        --format='value(instance)' \
0000000000000000000000000000000000000000;;	        --project="${PROJECT}" \
0000000000000000000000000000000000000000;;	        --zone="${ZONE}" 2>&1)) && list_instances_rc=$? || list_instances_rc=$?
0000000000000000000000000000000000000000;;	    if [[ "${list_instances_rc}" != 0 ]]; then
0000000000000000000000000000000000000000;;	      echo "== FAILED to list instances in group ${group} =="
0000000000000000000000000000000000000000;;	      echo "${instances}"
0000000000000000000000000000000000000000;;	      return ${list_instances_rc}
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    for instance in ${instances[@]}; do
0000000000000000000000000000000000000000;;	      # Cache instance id for later
0000000000000000000000000000000000000000;;	      instance_id=$(gcloud compute instances describe "${instance}" \
0000000000000000000000000000000000000000;;	        --format='get(id)' \
0000000000000000000000000000000000000000;;	        --project="${PROJECT}" \
0000000000000000000000000000000000000000;;	        --zone="${ZONE}" 2>&1) && describe_rc=$? || describe_rc=$?
0000000000000000000000000000000000000000;;	      if [[ "${describe_rc}" != 0 ]]; then
0000000000000000000000000000000000000000;;	        echo "== FAILED to describe ${instance} =="
0000000000000000000000000000000000000000;;	        echo "${instance_id}"
0000000000000000000000000000000000000000;;	        return ${describe_rc}
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      # Drain node
0000000000000000000000000000000000000000;;	      echo "== Draining ${instance}. == " >&2
0000000000000000000000000000000000000000;;	      "${KUBE_ROOT}/cluster/kubectl.sh" drain --delete-local-data --force --ignore-daemonsets "${instance}" \
0000000000000000000000000000000000000000;;	        && drain_rc=$? || drain_rc=$?
0000000000000000000000000000000000000000;;	      if [[ "${drain_rc}" != 0 ]]; then
0000000000000000000000000000000000000000;;	        echo "== FAILED to drain ${instance} =="
0000000000000000000000000000000000000000;;	        return ${drain_rc}
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      # Recreate instance
0000000000000000000000000000000000000000;;	      echo "== Recreating instance ${instance}. ==" >&2
0000000000000000000000000000000000000000;;	      recreate=$(gcloud compute instance-groups managed recreate-instances "${group}" \
0000000000000000000000000000000000000000;;	        --project="${PROJECT}" \
0000000000000000000000000000000000000000;;	        --zone="${ZONE}" \
0000000000000000000000000000000000000000;;	        --instances="${instance}" 2>&1) && recreate_rc=$? || recreate_rc=$?
0000000000000000000000000000000000000000;;	      if [[ "${recreate_rc}" != 0 ]]; then
0000000000000000000000000000000000000000;;	        echo "== FAILED to recreate ${instance} =="
0000000000000000000000000000000000000000;;	        echo "${recreate}"
0000000000000000000000000000000000000000;;	        return ${recreate_rc}
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      # Wait for instance to be recreated
0000000000000000000000000000000000000000;;	      echo "== Waiting for instance ${instance} to be recreated. ==" >&2
0000000000000000000000000000000000000000;;	      while true; do
0000000000000000000000000000000000000000;;	        new_instance_id=$(gcloud compute instances describe "${instance}" \
0000000000000000000000000000000000000000;;	          --format='get(id)' \
0000000000000000000000000000000000000000;;	          --project="${PROJECT}" \
0000000000000000000000000000000000000000;;	          --zone="${ZONE}" 2>&1) && describe_rc=$? || describe_rc=$?
0000000000000000000000000000000000000000;;	        if [[ "${describe_rc}" != 0 ]]; then
0000000000000000000000000000000000000000;;	          echo "== FAILED to describe ${instance} =="
0000000000000000000000000000000000000000;;	          echo "${new_instance_id}"
0000000000000000000000000000000000000000;;	          echo "  (Will retry.)"
0000000000000000000000000000000000000000;;	        elif [[ "${new_instance_id}" == "${instance_id}" ]]; then
0000000000000000000000000000000000000000;;	          echo -n .
0000000000000000000000000000000000000000;;	        else
0000000000000000000000000000000000000000;;	          echo "Instance ${instance} recreated."
0000000000000000000000000000000000000000;;	          break
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	        sleep 1
0000000000000000000000000000000000000000;;	      done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      # Wait for k8s node object to reflect new instance id
0000000000000000000000000000000000000000;;	      echo "== Waiting for new node to be added to k8s.  ==" >&2
0000000000000000000000000000000000000000;;	      while true; do
0000000000000000000000000000000000000000;;	        external_id=$("${KUBE_ROOT}/cluster/kubectl.sh" get node "${instance}" --output=jsonpath='{.spec.externalID}' 2>&1) && kubectl_rc=$? || kubectl_rc=$?
0000000000000000000000000000000000000000;;	        if [[ "${kubectl_rc}" != 0 ]]; then
0000000000000000000000000000000000000000;;	          echo "== FAILED to get node ${instance} =="
0000000000000000000000000000000000000000;;	          echo "${external_id}"
0000000000000000000000000000000000000000;;	          echo "  (Will retry.)"
0000000000000000000000000000000000000000;;	        elif [[ "${external_id}" == "${new_instance_id}" ]]; then
0000000000000000000000000000000000000000;;	          echo "Node ${instance} recreated."
0000000000000000000000000000000000000000;;	          break
0000000000000000000000000000000000000000;;	        elif [[ "${external_id}" == "${instance_id}" ]]; then
0000000000000000000000000000000000000000;;	          echo -n .
0000000000000000000000000000000000000000;;	        else
0000000000000000000000000000000000000000;;	          echo "Unexpected external_id '${external_id}' matches neither old ('${instance_id}') nor new ('${new_instance_id}')."
0000000000000000000000000000000000000000;;	          echo "  (Will retry.)"
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	        sleep 1
0000000000000000000000000000000000000000;;	      done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      # Wait for the node to not have SchedulingDisabled=True and also to have
0000000000000000000000000000000000000000;;	      # Ready=True.
0000000000000000000000000000000000000000;;	      echo "== Waiting for ${instance} to become ready. ==" >&2
0000000000000000000000000000000000000000;;	      while true; do
0000000000000000000000000000000000000000;;	        cordoned=$("${KUBE_ROOT}/cluster/kubectl.sh" get node "${instance}" --output='jsonpath={.status.conditions[?(@.type == "SchedulingDisabled")].status}')
0000000000000000000000000000000000000000;;	        ready=$("${KUBE_ROOT}/cluster/kubectl.sh" get node "${instance}" --output='jsonpath={.status.conditions[?(@.type == "Ready")].status}')
0000000000000000000000000000000000000000;;	        if [[ "${cordoned}" == 'True' ]]; then
0000000000000000000000000000000000000000;;	          echo "Node ${instance} is still not ready: SchedulingDisabled=${ready}"
0000000000000000000000000000000000000000;;	        elif [[ "${ready}" != 'True' ]]; then
0000000000000000000000000000000000000000;;	          echo "Node ${instance} is still not ready: Ready=${ready}"
0000000000000000000000000000000000000000;;	        else
0000000000000000000000000000000000000000;;	          echo "Node ${instance} Ready=${ready}"
0000000000000000000000000000000000000000;;	          break
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	        sleep 1
0000000000000000000000000000000000000000;;	      done
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Remove the old templates.
0000000000000000000000000000000000000000;;	  echo "== Deleting old templates in ${PROJECT}. ==" >&2
0000000000000000000000000000000000000000;;	  for tmpl in ${old_templates[@]}; do
0000000000000000000000000000000000000000;;	    gcloud compute instance-templates delete \
0000000000000000000000000000000000000000;;	        --quiet \
0000000000000000000000000000000000000000;;	        --project="${PROJECT}" \
0000000000000000000000000000000000000000;;	        "${tmpl}" || true
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "== Finished upgrading nodes to ${KUBE_VERSION}. ==" >&2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	master_upgrade=true
0000000000000000000000000000000000000000;;	node_upgrade=true
0000000000000000000000000000000000000000;;	node_prereqs=false
0000000000000000000000000000000000000000;;	local_binaries=false
0000000000000000000000000000000000000000;;	env_os_distro=false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	while getopts ":MNPlho" opt; do
0000000000000000000000000000000000000000;;	  case ${opt} in
0000000000000000000000000000000000000000;;	    M)
0000000000000000000000000000000000000000;;	      node_upgrade=false
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	    N)
0000000000000000000000000000000000000000;;	      master_upgrade=false
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	    P)
0000000000000000000000000000000000000000;;	      node_prereqs=true
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	    l)
0000000000000000000000000000000000000000;;	      local_binaries=true
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	    o)
0000000000000000000000000000000000000000;;	      env_os_distro=true
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	    h)
0000000000000000000000000000000000000000;;	      usage
0000000000000000000000000000000000000000;;	      exit 0
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	    \?)
0000000000000000000000000000000000000000;;	      echo "Invalid option: -$OPTARG" >&2
0000000000000000000000000000000000000000;;	      usage
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	  esac
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	shift $((OPTIND-1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ $# -gt 1 ]]; then
0000000000000000000000000000000000000000;;	  echo "Error: Only one parameter (<version number or publication>) may be passed after the set of flags!" >&2
0000000000000000000000000000000000000000;;	  usage
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ $# -lt 1 ]] && [[ "${local_binaries}" == "false" ]]; then
0000000000000000000000000000000000000000;;	  usage
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "${master_upgrade}" == "false" ]] && [[ "${node_upgrade}" == "false" ]]; then
0000000000000000000000000000000000000000;;	  echo "Can't specify both -M and -N" >&2
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# prompt if etcd storage media type isn't set unless using etcd2 when doing master upgrade
0000000000000000000000000000000000000000;;	if [[ -z "${STORAGE_MEDIA_TYPE:-}" ]] && [[ "${STORAGE_BACKEND:-}" != "etcd2" ]] && [[ "${master_upgrade}" == "true" ]]; then
0000000000000000000000000000000000000000;;	  echo "The default etcd storage media type in 1.6 has changed from application/json to application/vnd.kubernetes.protobuf."
0000000000000000000000000000000000000000;;	  echo "Documentation about the change can be found at https://kubernetes.io/docs/admin/etcd_upgrade."
0000000000000000000000000000000000000000;;	  echo ""
0000000000000000000000000000000000000000;;	  echo "ETCD2 DOES NOT SUPPORT PROTOBUF: If you wish to have to ability to downgrade to etcd2 later application/json must be used."
0000000000000000000000000000000000000000;;	  echo ""
0000000000000000000000000000000000000000;;	  echo "It's HIGHLY recommended that etcd be backed up before this step!!"
0000000000000000000000000000000000000000;;	  echo ""
0000000000000000000000000000000000000000;;	  echo "To enable using json, before running this script set:"
0000000000000000000000000000000000000000;;	  echo "export STORAGE_MEDIA_TYPE=application/json"
0000000000000000000000000000000000000000;;	  echo ""
0000000000000000000000000000000000000000;;	  if [ -t 0 ] && [ -t 1 ]; then
0000000000000000000000000000000000000000;;	    read -p "Would you like to continue with the new default, and lose the ability to downgrade to etcd2? [y/N] " confirm
0000000000000000000000000000000000000000;;	    if [[ "${confirm}" != "y" ]]; then
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    echo "To enable using protobuf, before running this script set:"
0000000000000000000000000000000000000000;;	    echo "export STORAGE_MEDIA_TYPE=application/vnd.kubernetes.protobuf"
0000000000000000000000000000000000000000;;	    echo ""
0000000000000000000000000000000000000000;;	    echo "STORAGE_MEDIA_TYPE must be specified when run non-interactively." >&2
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	print-node-version-info "Pre-Upgrade"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "${local_binaries}" == "false" ]]; then
0000000000000000000000000000000000000000;;	  set_binary_version ${1}
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	prepare-upgrade
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "${node_prereqs}" == "true" ]]; then
0000000000000000000000000000000000000000;;	  prepare-node-upgrade
0000000000000000000000000000000000000000;;	  exit 0
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "${master_upgrade}" == "true" ]]; then
0000000000000000000000000000000000000000;;	  upgrade-master
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "${node_upgrade}" == "true" ]]; then
0000000000000000000000000000000000000000;;	  if [[ "${local_binaries}" == "true" ]]; then
0000000000000000000000000000000000000000;;	    echo "Upgrading nodes to local binaries is not yet supported." >&2
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    upgrade-nodes
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo "== Validating cluster post-upgrade =="
0000000000000000000000000000000000000000;;	"${KUBE_ROOT}/cluster/validate-cluster.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	print-node-version-info "Post-Upgrade"
