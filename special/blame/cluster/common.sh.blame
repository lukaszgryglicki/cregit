0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2017 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Common utilites for kube-up/kube-down
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	set -o errexit
0000000000000000000000000000000000000000;;	set -o nounset
0000000000000000000000000000000000000000;;	set -o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_ROOT=$(cd $(dirname "${BASH_SOURCE}")/.. && pwd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	DEFAULT_KUBECONFIG="${HOME}/.kube/config"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/hack/lib/util.sh"
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/cluster/lib/logging.sh"
0000000000000000000000000000000000000000;;	# KUBE_RELEASE_VERSION_REGEX matches things like "v1.2.3" or "v1.2.3-alpha.4"
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# NOTE This must match the version_regex in build/common.sh
0000000000000000000000000000000000000000;;	# kube::release::parse_and_validate_release_version()
0000000000000000000000000000000000000000;;	KUBE_RELEASE_VERSION_REGEX="^v(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)(-([a-zA-Z0-9]+)\\.(0|[1-9][0-9]*))?$"
0000000000000000000000000000000000000000;;	KUBE_RELEASE_VERSION_DASHED_REGEX="v(0|[1-9][0-9]*)-(0|[1-9][0-9]*)-(0|[1-9][0-9]*)(-([a-zA-Z0-9]+)-(0|[1-9][0-9]*))?"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# KUBE_CI_VERSION_REGEX matches things like "v1.2.3-alpha.4.56+abcdefg" This
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# NOTE This must match the version_regex in build/common.sh
0000000000000000000000000000000000000000;;	# kube::release::parse_and_validate_ci_version()
0000000000000000000000000000000000000000;;	KUBE_CI_VERSION_REGEX="^v(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)-([a-zA-Z0-9]+)\\.(0|[1-9][0-9]*)(\\.(0|[1-9][0-9]*)\\+[-0-9a-z]*)?$"
0000000000000000000000000000000000000000;;	KUBE_CI_VERSION_DASHED_REGEX="^v(0|[1-9][0-9]*)-(0|[1-9][0-9]*)-(0|[1-9][0-9]*)-([a-zA-Z0-9]+)-(0|[1-9][0-9]*)(-(0|[1-9][0-9]*)\\+[-0-9a-z]*)?"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Generate kubeconfig data for the created cluster.
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   KUBE_USER
0000000000000000000000000000000000000000;;	#   KUBE_PASSWORD
0000000000000000000000000000000000000000;;	#   KUBE_MASTER_IP
0000000000000000000000000000000000000000;;	#   KUBECONFIG
0000000000000000000000000000000000000000;;	#   CONTEXT
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# If the apiserver supports bearer auth, also provide:
0000000000000000000000000000000000000000;;	#   KUBE_BEARER_TOKEN
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# If the kubeconfig context being created should NOT be set as the current context
0000000000000000000000000000000000000000;;	# SECONDARY_KUBECONFIG=true
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# To explicitly name the context being created, use OVERRIDE_CONTEXT
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# The following can be omitted for --insecure-skip-tls-verify
0000000000000000000000000000000000000000;;	#   KUBE_CERT
0000000000000000000000000000000000000000;;	#   KUBE_KEY
0000000000000000000000000000000000000000;;	#   CA_CERT
0000000000000000000000000000000000000000;;	function create-kubeconfig() {
0000000000000000000000000000000000000000;;	  KUBECONFIG=${KUBECONFIG:-$DEFAULT_KUBECONFIG}
0000000000000000000000000000000000000000;;	  local kubectl="${KUBE_ROOT}/cluster/kubectl.sh"
0000000000000000000000000000000000000000;;	  SECONDARY_KUBECONFIG=${SECONDARY_KUBECONFIG:-}
0000000000000000000000000000000000000000;;	  OVERRIDE_CONTEXT=${OVERRIDE_CONTEXT:-}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "$OVERRIDE_CONTEXT" != "" ]];then
0000000000000000000000000000000000000000;;	      CONTEXT=$OVERRIDE_CONTEXT
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # KUBECONFIG determines the file we write to, but it may not exist yet
0000000000000000000000000000000000000000;;	  OLD_IFS=$IFS
0000000000000000000000000000000000000000;;	  IFS=':'
0000000000000000000000000000000000000000;;	  for cfg in ${KUBECONFIG} ; do
0000000000000000000000000000000000000000;;	    if [[ ! -e "${cfg}" ]]; then
0000000000000000000000000000000000000000;;	      mkdir -p "$(dirname "${cfg}")"
0000000000000000000000000000000000000000;;	      touch "${cfg}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  IFS=$OLD_IFS
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local cluster_args=(
0000000000000000000000000000000000000000;;	      "--server=${KUBE_SERVER:-https://${KUBE_MASTER_IP}}"
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	  if [[ -z "${CA_CERT:-}" ]]; then
0000000000000000000000000000000000000000;;	    cluster_args+=("--insecure-skip-tls-verify=true")
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    cluster_args+=(
0000000000000000000000000000000000000000;;	      "--certificate-authority=${CA_CERT}"
0000000000000000000000000000000000000000;;	      "--embed-certs=true"
0000000000000000000000000000000000000000;;	    )
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local user_args=()
0000000000000000000000000000000000000000;;	  if [[ ! -z "${KUBE_BEARER_TOKEN:-}" ]]; then
0000000000000000000000000000000000000000;;	    user_args+=(
0000000000000000000000000000000000000000;;	     "--token=${KUBE_BEARER_TOKEN}"
0000000000000000000000000000000000000000;;	    )
0000000000000000000000000000000000000000;;	  elif [[ ! -z "${KUBE_USER:-}" && ! -z "${KUBE_PASSWORD:-}" ]]; then
0000000000000000000000000000000000000000;;	    user_args+=(
0000000000000000000000000000000000000000;;	     "--username=${KUBE_USER}"
0000000000000000000000000000000000000000;;	     "--password=${KUBE_PASSWORD}"
0000000000000000000000000000000000000000;;	    )
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [[ ! -z "${KUBE_CERT:-}" && ! -z "${KUBE_KEY:-}" ]]; then
0000000000000000000000000000000000000000;;	    user_args+=(
0000000000000000000000000000000000000000;;	     "--client-certificate=${KUBE_CERT}"
0000000000000000000000000000000000000000;;	     "--client-key=${KUBE_KEY}"
0000000000000000000000000000000000000000;;	     "--embed-certs=true"
0000000000000000000000000000000000000000;;	    )
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  KUBECONFIG="${KUBECONFIG}" "${kubectl}" config set-cluster "${CONTEXT}" "${cluster_args[@]}"
0000000000000000000000000000000000000000;;	  if [[ -n "${user_args[@]:-}" ]]; then
0000000000000000000000000000000000000000;;	    KUBECONFIG="${KUBECONFIG}" "${kubectl}" config set-credentials "${CONTEXT}" "${user_args[@]}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  KUBECONFIG="${KUBECONFIG}" "${kubectl}" config set-context "${CONTEXT}" --cluster="${CONTEXT}" --user="${CONTEXT}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "${SECONDARY_KUBECONFIG}" != "true" ]];then
0000000000000000000000000000000000000000;;	      KUBECONFIG="${KUBECONFIG}" "${kubectl}" config use-context "${CONTEXT}"  --cluster="${CONTEXT}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # If we have a bearer token, also create a credential entry with basic auth
0000000000000000000000000000000000000000;;	  # so that it is easy to discover the basic auth password for your cluster
0000000000000000000000000000000000000000;;	  # to use in a web browser.
0000000000000000000000000000000000000000;;	  if [[ ! -z "${KUBE_BEARER_TOKEN:-}" && ! -z "${KUBE_USER:-}" && ! -z "${KUBE_PASSWORD:-}" ]]; then
0000000000000000000000000000000000000000;;	    KUBECONFIG="${KUBECONFIG}" "${kubectl}" config set-credentials "${CONTEXT}-basic-auth" "--username=${KUBE_USER}" "--password=${KUBE_PASSWORD}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	   echo "Wrote config for ${CONTEXT} to ${KUBECONFIG}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Clear kubeconfig data for a context
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   KUBECONFIG
0000000000000000000000000000000000000000;;	#   CONTEXT
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# To explicitly name the context being removed, use OVERRIDE_CONTEXT
0000000000000000000000000000000000000000;;	function clear-kubeconfig() {
0000000000000000000000000000000000000000;;	  export KUBECONFIG=${KUBECONFIG:-$DEFAULT_KUBECONFIG}
0000000000000000000000000000000000000000;;	  OVERRIDE_CONTEXT=${OVERRIDE_CONTEXT:-}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "$OVERRIDE_CONTEXT" != "" ]];then
0000000000000000000000000000000000000000;;	      CONTEXT=$OVERRIDE_CONTEXT
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local kubectl="${KUBE_ROOT}/cluster/kubectl.sh"
0000000000000000000000000000000000000000;;	  # Unset the current-context before we delete it, as otherwise kubectl errors.
0000000000000000000000000000000000000000;;	  local cc=$("${kubectl}" config view -o jsonpath='{.current-context}')
0000000000000000000000000000000000000000;;	  if [[ "${cc}" == "${CONTEXT}" ]]; then
0000000000000000000000000000000000000000;;	    "${kubectl}" config unset current-context
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  "${kubectl}" config unset "clusters.${CONTEXT}"
0000000000000000000000000000000000000000;;	  "${kubectl}" config unset "users.${CONTEXT}"
0000000000000000000000000000000000000000;;	  "${kubectl}" config unset "users.${CONTEXT}-basic-auth"
0000000000000000000000000000000000000000;;	  "${kubectl}" config unset "contexts.${CONTEXT}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "Cleared config for ${CONTEXT} from ${KUBECONFIG}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Creates a kubeconfig file with the credentials for only the current-context
0000000000000000000000000000000000000000;;	# cluster. This is used by federation to create secrets in test setup.
0000000000000000000000000000000000000000;;	function create-kubeconfig-for-federation() {
0000000000000000000000000000000000000000;;	  if [[ "${FEDERATION:-}" == "true" ]]; then
0000000000000000000000000000000000000000;;	    echo "creating kubeconfig for federation secret"
0000000000000000000000000000000000000000;;	    local kubectl="${KUBE_ROOT}/cluster/kubectl.sh"
0000000000000000000000000000000000000000;;	    local cc=$("${kubectl}" config view -o jsonpath='{.current-context}')
0000000000000000000000000000000000000000;;	    KUBECONFIG_DIR=$(dirname ${KUBECONFIG:-$DEFAULT_KUBECONFIG})
0000000000000000000000000000000000000000;;	    KUBECONFIG_PATH="${KUBECONFIG_DIR}/federation/kubernetes-apiserver/${cc}"
0000000000000000000000000000000000000000;;	    mkdir -p "${KUBECONFIG_PATH}"
0000000000000000000000000000000000000000;;	    "${kubectl}" config view --minify --flatten > "${KUBECONFIG_PATH}/kubeconfig"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function tear_down_alive_resources() {
0000000000000000000000000000000000000000;;	  local kubectl="${KUBE_ROOT}/cluster/kubectl.sh"
0000000000000000000000000000000000000000;;	  "${kubectl}" delete deployments --all || true
0000000000000000000000000000000000000000;;	  "${kubectl}" delete rc --all || true
0000000000000000000000000000000000000000;;	  "${kubectl}" delete pods --all || true
0000000000000000000000000000000000000000;;	  "${kubectl}" delete svc --all || true
0000000000000000000000000000000000000000;;	  "${kubectl}" delete pvc --all || true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Gets username, password for the current-context in kubeconfig, if they exist.
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   KUBECONFIG  # if unset, defaults to global
0000000000000000000000000000000000000000;;	#   KUBE_CONTEXT  # if unset, defaults to current-context
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   KUBE_USER
0000000000000000000000000000000000000000;;	#   KUBE_PASSWORD
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# KUBE_USER,KUBE_PASSWORD will be empty if no current-context is set, or
0000000000000000000000000000000000000000;;	# the current-context user does not exist or contain basicauth entries.
0000000000000000000000000000000000000000;;	function get-kubeconfig-basicauth() {
0000000000000000000000000000000000000000;;	  export KUBECONFIG=${KUBECONFIG:-$DEFAULT_KUBECONFIG}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local cc=$("${KUBE_ROOT}/cluster/kubectl.sh" config view -o jsonpath="{.current-context}")
0000000000000000000000000000000000000000;;	  if [[ ! -z "${KUBE_CONTEXT:-}" ]]; then
0000000000000000000000000000000000000000;;	    cc="${KUBE_CONTEXT}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  local user=$("${KUBE_ROOT}/cluster/kubectl.sh" config view -o jsonpath="{.contexts[?(@.name == \"${cc}\")].context.user}")
0000000000000000000000000000000000000000;;	  get-kubeconfig-user-basicauth "${user}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ -z "${KUBE_USER:-}" || -z "${KUBE_PASSWORD:-}" ]]; then
0000000000000000000000000000000000000000;;	    # kube-up stores username/password in a an additional kubeconfig section
0000000000000000000000000000000000000000;;	    # suffixed with "-basic-auth". Cloudproviders like GKE store in directly
0000000000000000000000000000000000000000;;	    # in the top level section along with the other credential information.
0000000000000000000000000000000000000000;;	    # TODO: Handle this uniformly, either get rid of "basic-auth" or
0000000000000000000000000000000000000000;;	    # consolidate its usage into a function across scripts in cluster/
0000000000000000000000000000000000000000;;	    get-kubeconfig-user-basicauth "${user}-basic-auth"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Sets KUBE_USER and KUBE_PASSWORD to the username and password specified in
0000000000000000000000000000000000000000;;	# the kubeconfig section corresponding to $1.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Args:
0000000000000000000000000000000000000000;;	#   $1 kubeconfig section to look for basic auth (eg: user or user-basic-auth).
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   KUBE_ROOT
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   KUBE_USER
0000000000000000000000000000000000000000;;	#   KUBE_PASSWORD
0000000000000000000000000000000000000000;;	function get-kubeconfig-user-basicauth() {
0000000000000000000000000000000000000000;;	  KUBE_USER=$("${KUBE_ROOT}/cluster/kubectl.sh" config view -o jsonpath="{.users[?(@.name == \"$1\")].user.username}")
0000000000000000000000000000000000000000;;	  KUBE_PASSWORD=$("${KUBE_ROOT}/cluster/kubectl.sh" config view -o jsonpath="{.users[?(@.name == \"$1\")].user.password}")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Generate basic auth user and password.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   KUBE_USER
0000000000000000000000000000000000000000;;	#   KUBE_PASSWORD
0000000000000000000000000000000000000000;;	function gen-kube-basicauth() {
0000000000000000000000000000000000000000;;	    KUBE_USER=admin
0000000000000000000000000000000000000000;;	    KUBE_PASSWORD=$(python -c 'import string,random; print("".join(random.SystemRandom().choice(string.ascii_letters + string.digits) for _ in range(16)))')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Get the bearer token for the current-context in kubeconfig if one exists.
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   KUBECONFIG  # if unset, defaults to global
0000000000000000000000000000000000000000;;	#   KUBE_CONTEXT  # if unset, defaults to current-context
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   KUBE_BEARER_TOKEN
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# KUBE_BEARER_TOKEN will be empty if no current-context is set, or the
0000000000000000000000000000000000000000;;	# current-context user does not exist or contain a bearer token entry.
0000000000000000000000000000000000000000;;	function get-kubeconfig-bearertoken() {
0000000000000000000000000000000000000000;;	  export KUBECONFIG=${KUBECONFIG:-$DEFAULT_KUBECONFIG}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local cc=$("${KUBE_ROOT}/cluster/kubectl.sh" config view -o jsonpath="{.current-context}")
0000000000000000000000000000000000000000;;	  if [[ ! -z "${KUBE_CONTEXT:-}" ]]; then
0000000000000000000000000000000000000000;;	    cc="${KUBE_CONTEXT}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  local user=$("${KUBE_ROOT}/cluster/kubectl.sh" config view -o jsonpath="{.contexts[?(@.name == \"${cc}\")].context.user}")
0000000000000000000000000000000000000000;;	  KUBE_BEARER_TOKEN=$("${KUBE_ROOT}/cluster/kubectl.sh" config view -o jsonpath="{.users[?(@.name == \"${user}\")].user.token}")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Generate bearer token.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   KUBE_BEARER_TOKEN
0000000000000000000000000000000000000000;;	function gen-kube-bearertoken() {
0000000000000000000000000000000000000000;;	    KUBE_BEARER_TOKEN=$(dd if=/dev/urandom bs=128 count=1 2>/dev/null | base64 | tr -d "=+/" | dd bs=32 count=1 2>/dev/null)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Generate uid
0000000000000000000000000000000000000000;;	# This function only works on systems with python. It generates a time based
0000000000000000000000000000000000000000;;	# UID instead of a UUID because GCE has a name length limit.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   KUBE_UID
0000000000000000000000000000000000000000;;	function gen-uid {
0000000000000000000000000000000000000000;;	    KUBE_UID=$(python -c 'import uuid; print(uuid.uuid1().fields[0])')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function load-or-gen-kube-basicauth() {
0000000000000000000000000000000000000000;;	  if [[ ! -z "${KUBE_CONTEXT:-}" ]]; then
0000000000000000000000000000000000000000;;	    get-kubeconfig-basicauth
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ -z "${KUBE_USER:-}" || -z "${KUBE_PASSWORD:-}" ]]; then
0000000000000000000000000000000000000000;;	    gen-kube-basicauth
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Make sure they don't contain any funny characters.
0000000000000000000000000000000000000000;;	  if ! [[ "${KUBE_USER}" =~ ^[-._@a-zA-Z0-9]+$ ]]; then
0000000000000000000000000000000000000000;;	    echo "Bad KUBE_USER string."
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if ! [[ "${KUBE_PASSWORD}" =~ ^[-._@#%/a-zA-Z0-9]+$ ]]; then
0000000000000000000000000000000000000000;;	    echo "Bad KUBE_PASSWORD string."
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function load-or-gen-kube-bearertoken() {
0000000000000000000000000000000000000000;;	  if [[ ! -z "${KUBE_CONTEXT:-}" ]]; then
0000000000000000000000000000000000000000;;	    get-kubeconfig-bearertoken
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [[ -z "${KUBE_BEARER_TOKEN:-}" ]]; then
0000000000000000000000000000000000000000;;	    gen-kube-bearertoken
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Get the master IP for the current-context in kubeconfig if one exists.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   KUBECONFIG  # if unset, defaults to global
0000000000000000000000000000000000000000;;	#   KUBE_CONTEXT  # if unset, defaults to current-context
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   KUBE_MASTER_URL
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# KUBE_MASTER_URL will be empty if no current-context is set, or the
0000000000000000000000000000000000000000;;	# current-context user does not exist or contain a server entry.
0000000000000000000000000000000000000000;;	function detect-master-from-kubeconfig() {
0000000000000000000000000000000000000000;;	  export KUBECONFIG=${KUBECONFIG:-$DEFAULT_KUBECONFIG}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local cc=$("${KUBE_ROOT}/cluster/kubectl.sh" config view -o jsonpath="{.current-context}")
0000000000000000000000000000000000000000;;	  if [[ ! -z "${KUBE_CONTEXT:-}" ]]; then
0000000000000000000000000000000000000000;;	    cc="${KUBE_CONTEXT}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  local cluster=$("${KUBE_ROOT}/cluster/kubectl.sh" config view -o jsonpath="{.contexts[?(@.name == \"${cc}\")].context.cluster}")
0000000000000000000000000000000000000000;;	  KUBE_MASTER_URL=$("${KUBE_ROOT}/cluster/kubectl.sh" config view -o jsonpath="{.clusters[?(@.name == \"${cluster}\")].cluster.server}")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Sets KUBE_VERSION variable to the proper version number (e.g. "v1.0.6",
0000000000000000000000000000000000000000;;	# "v1.2.0-alpha.1.881+376438b69c7612") or a version' publication of the form
0000000000000000000000000000000000000000;;	# <path>/<version> (e.g. "release/stable",' "ci/latest-1").
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# See the docs on getting builds for more information about version
0000000000000000000000000000000000000000;;	# publication.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Args:
0000000000000000000000000000000000000000;;	#   $1 version string from command line
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   KUBE_VERSION
0000000000000000000000000000000000000000;;	function set_binary_version() {
0000000000000000000000000000000000000000;;	  if [[ "${1}" =~ "/" ]]; then
0000000000000000000000000000000000000000;;	    IFS='/' read -a path <<< "${1}"
0000000000000000000000000000000000000000;;	    if [[ "${path[0]}" == "release" ]]; then
0000000000000000000000000000000000000000;;	      KUBE_VERSION=$(gsutil cat "gs://kubernetes-release/${1}.txt")
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      KUBE_VERSION=$(gsutil cat "gs://kubernetes-release-dev/${1}.txt")
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    KUBE_VERSION=${1}
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Figure out which binary use on the server and assure it is available.
0000000000000000000000000000000000000000;;	# If KUBE_VERSION is specified use binaries specified by it, otherwise
0000000000000000000000000000000000000000;;	# use local dev binaries.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   KUBE_VERSION
0000000000000000000000000000000000000000;;	#   KUBE_RELEASE_VERSION_REGEX
0000000000000000000000000000000000000000;;	#   KUBE_CI_VERSION_REGEX
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   KUBE_TAR_HASH
0000000000000000000000000000000000000000;;	#   SERVER_BINARY_TAR_URL
0000000000000000000000000000000000000000;;	#   SERVER_BINARY_TAR_HASH
0000000000000000000000000000000000000000;;	#   SALT_TAR_URL
0000000000000000000000000000000000000000;;	#   SALT_TAR_HASH
0000000000000000000000000000000000000000;;	function tars_from_version() {
0000000000000000000000000000000000000000;;	  local sha1sum=""
0000000000000000000000000000000000000000;;	  if which sha1sum >/dev/null 2>&1; then
0000000000000000000000000000000000000000;;	    sha1sum="sha1sum"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    sha1sum="shasum -a1"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ -z "${KUBE_VERSION-}" ]]; then
0000000000000000000000000000000000000000;;	    find-release-tars
0000000000000000000000000000000000000000;;	    upload-server-tars
0000000000000000000000000000000000000000;;	  elif [[ ${KUBE_VERSION} =~ ${KUBE_RELEASE_VERSION_REGEX} ]]; then
0000000000000000000000000000000000000000;;	    SERVER_BINARY_TAR_URL="https://storage.googleapis.com/kubernetes-release/release/${KUBE_VERSION}/kubernetes-server-linux-amd64.tar.gz"
0000000000000000000000000000000000000000;;	    SALT_TAR_URL="https://storage.googleapis.com/kubernetes-release/release/${KUBE_VERSION}/kubernetes-salt.tar.gz"
0000000000000000000000000000000000000000;;	    # TODO: Clean this up.
0000000000000000000000000000000000000000;;	    KUBE_MANIFESTS_TAR_URL="${SERVER_BINARY_TAR_URL/server-linux-amd64/manifests}"
0000000000000000000000000000000000000000;;	    KUBE_MANIFESTS_TAR_HASH=$(curl ${KUBE_MANIFESTS_TAR_URL} --silent --show-error | ${sha1sum} | awk '{print $1}')
0000000000000000000000000000000000000000;;	  elif [[ ${KUBE_VERSION} =~ ${KUBE_CI_VERSION_REGEX} ]]; then
0000000000000000000000000000000000000000;;	    SERVER_BINARY_TAR_URL="https://storage.googleapis.com/kubernetes-release-dev/ci/${KUBE_VERSION}/kubernetes-server-linux-amd64.tar.gz"
0000000000000000000000000000000000000000;;	    SALT_TAR_URL="https://storage.googleapis.com/kubernetes-release-dev/ci/${KUBE_VERSION}/kubernetes-salt.tar.gz"
0000000000000000000000000000000000000000;;	    # TODO: Clean this up.
0000000000000000000000000000000000000000;;	    KUBE_MANIFESTS_TAR_URL="${SERVER_BINARY_TAR_URL/server-linux-amd64/manifests}"
0000000000000000000000000000000000000000;;	    KUBE_MANIFESTS_TAR_HASH=$(curl ${KUBE_MANIFESTS_TAR_URL} --silent --show-error | ${sha1sum} | awk '{print $1}')
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    echo "Version doesn't match regexp" >&2
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if ! SERVER_BINARY_TAR_HASH=$(curl -Ss --fail "${SERVER_BINARY_TAR_URL}.sha1"); then
0000000000000000000000000000000000000000;;	    echo "Failure trying to curl release .sha1"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if ! SALT_TAR_HASH=$(curl -Ss --fail "${SALT_TAR_URL}.sha1"); then
0000000000000000000000000000000000000000;;	    echo "Failure trying to curl Salt tar .sha1"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if ! curl -Ss --head "${SERVER_BINARY_TAR_URL}" >&/dev/null; then
0000000000000000000000000000000000000000;;	    echo "Can't find release at ${SERVER_BINARY_TAR_URL}" >&2
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if ! curl -Ss --head "${SALT_TAR_URL}" >&/dev/null; then
0000000000000000000000000000000000000000;;	    echo "Can't find Salt tar at ${SALT_TAR_URL}" >&2
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Search for the specified tarball in the various known output locations,
0000000000000000000000000000000000000000;;	# echoing the location if found.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   KUBE_ROOT
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Args:
0000000000000000000000000000000000000000;;	#   $1 name of tarball to search for
0000000000000000000000000000000000000000;;	function find-tar() {
0000000000000000000000000000000000000000;;	  local -r tarball=$1
0000000000000000000000000000000000000000;;	  locations=(
0000000000000000000000000000000000000000;;	    "${KUBE_ROOT}/server/${tarball}"
0000000000000000000000000000000000000000;;	    "${KUBE_ROOT}/_output/release-tars/${tarball}"
0000000000000000000000000000000000000000;;	    "${KUBE_ROOT}/bazel-bin/build/release-tars/${tarball}"
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	  location=$( (ls -t "${locations[@]}" 2>/dev/null || true) | head -1 )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ ! -f "${location}" ]]; then
0000000000000000000000000000000000000000;;	    echo "!!! Cannot find ${tarball}" >&2
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  echo "${location}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Verify and find the various tar files that we are going to use on the server.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   KUBE_ROOT
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   SERVER_BINARY_TAR
0000000000000000000000000000000000000000;;	#   SALT_TAR
0000000000000000000000000000000000000000;;	#   KUBE_MANIFESTS_TAR
0000000000000000000000000000000000000000;;	function find-release-tars() {
0000000000000000000000000000000000000000;;	  SERVER_BINARY_TAR=$(find-tar kubernetes-server-linux-amd64.tar.gz)
0000000000000000000000000000000000000000;;	  SALT_TAR=$(find-tar kubernetes-salt.tar.gz)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # This tarball is used by GCI, Ubuntu Trusty, and Container Linux.
0000000000000000000000000000000000000000;;	  KUBE_MANIFESTS_TAR=
0000000000000000000000000000000000000000;;	  if [[ "${MASTER_OS_DISTRIBUTION:-}" == "trusty" || "${MASTER_OS_DISTRIBUTION:-}" == "gci" || "${MASTER_OS_DISTRIBUTION:-}" == "container-linux" || "${MASTER_OS_DISTRIBUTION:-}" == "ubuntu" ]] || \
0000000000000000000000000000000000000000;;	     [[ "${NODE_OS_DISTRIBUTION:-}" == "trusty" || "${NODE_OS_DISTRIBUTION:-}" == "gci" || "${NODE_OS_DISTRIBUTION:-}" == "container-linux" || "${NODE_OS_DISTRIBUTION:-}" == "ubuntu" ]] ; then
0000000000000000000000000000000000000000;;	    KUBE_MANIFESTS_TAR=$(find-tar kubernetes-manifests.tar.gz)
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Discover the git version of the current build package
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   KUBE_ROOT
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   KUBE_GIT_VERSION
0000000000000000000000000000000000000000;;	function find-release-version() {
0000000000000000000000000000000000000000;;	  KUBE_GIT_VERSION=""
0000000000000000000000000000000000000000;;	  if [[ -f "${KUBE_ROOT}/version" ]]; then
0000000000000000000000000000000000000000;;	    KUBE_GIT_VERSION="$(cat ${KUBE_ROOT}/version)"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [[ -f "${KUBE_ROOT}/_output/release-stage/full/kubernetes/version" ]]; then
0000000000000000000000000000000000000000;;	    KUBE_GIT_VERSION="$(cat ${KUBE_ROOT}/_output/release-stage/full/kubernetes/version)"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ -z "${KUBE_GIT_VERSION}" ]]; then
0000000000000000000000000000000000000000;;	    echo "!!! Cannot find release version"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function stage-images() {
0000000000000000000000000000000000000000;;	  find-release-version
0000000000000000000000000000000000000000;;	  find-release-tars
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  KUBE_IMAGE_TAG="$(echo """${KUBE_GIT_VERSION}""" | sed 's/+/-/g')"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local docker_wrapped_binaries=(
0000000000000000000000000000000000000000;;	    "kube-apiserver"
0000000000000000000000000000000000000000;;	    "kube-controller-manager"
0000000000000000000000000000000000000000;;	    "kube-scheduler"
0000000000000000000000000000000000000000;;	    "kube-proxy"
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local docker_cmd=("docker")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "${KUBE_DOCKER_REGISTRY}" == "gcr.io/"* ]]; then
0000000000000000000000000000000000000000;;	    local docker_push_cmd=("gcloud" "docker")
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    local docker_push_cmd=("${docker_cmd[@]}")
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local temp_dir="$(mktemp -d -t 'kube-server-XXXX')"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  tar xzfv "${SERVER_BINARY_TAR}" -C "${temp_dir}" &> /dev/null
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for binary in "${docker_wrapped_binaries[@]}"; do
0000000000000000000000000000000000000000;;	    local docker_tag="$(cat ${temp_dir}/kubernetes/server/bin/${binary}.docker_tag)"
0000000000000000000000000000000000000000;;	    (
0000000000000000000000000000000000000000;;	      "${docker_cmd[@]}" load -i "${temp_dir}/kubernetes/server/bin/${binary}.tar"
0000000000000000000000000000000000000000;;	      "${docker_cmd[@]}" rmi "${KUBE_DOCKER_REGISTRY}/${binary}:${KUBE_IMAGE_TAG}" 2>/dev/null || true
0000000000000000000000000000000000000000;;	      "${docker_cmd[@]}" tag "gcr.io/google_containers/${binary}:${docker_tag}" "${KUBE_DOCKER_REGISTRY}/${binary}:${KUBE_IMAGE_TAG}"
0000000000000000000000000000000000000000;;	      "${docker_push_cmd[@]}" push "${KUBE_DOCKER_REGISTRY}/${binary}:${KUBE_IMAGE_TAG}"
0000000000000000000000000000000000000000;;	    ) &> "${temp_dir}/${binary}-push.log" &
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::util::wait-for-jobs || {
0000000000000000000000000000000000000000;;	    kube::log::error "unable to push images. See ${temp_dir}/*.log for more info."
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  rm -rf "${temp_dir}"
0000000000000000000000000000000000000000;;	  return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Quote something appropriate for a yaml string.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# TODO(zmerlynn): Note that this function doesn't so much "quote" as
0000000000000000000000000000000000000000;;	# "strip out quotes", and we really should be using a YAML library for
0000000000000000000000000000000000000000;;	# this, but PyYAML isn't shipped by default, and *rant rant rant ... SIGH*
0000000000000000000000000000000000000000;;	function yaml-quote {
0000000000000000000000000000000000000000;;	  echo "'$(echo "${@:-}" | sed -e "s/'/''/g")'"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Builds the RUNTIME_CONFIG var from other feature enable options (such as
0000000000000000000000000000000000000000;;	# features in alpha)
0000000000000000000000000000000000000000;;	function build-runtime-config() {
0000000000000000000000000000000000000000;;	  # There is nothing to do here for now. Just using this function as a placeholder.
0000000000000000000000000000000000000000;;	  :
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Writes the cluster name into a temporary file.
0000000000000000000000000000000000000000;;	# Assumed vars
0000000000000000000000000000000000000000;;	#   CLUSTER_NAME
0000000000000000000000000000000000000000;;	function write-cluster-name {
0000000000000000000000000000000000000000;;	  cat >"${KUBE_TEMP}/cluster-name.txt" << EOF
0000000000000000000000000000000000000000;;	${CLUSTER_NAME}
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function write-master-env {
0000000000000000000000000000000000000000;;	  # If the user requested that the master be part of the cluster, set the
0000000000000000000000000000000000000000;;	  # environment variable to program the master kubelet to register itself.
0000000000000000000000000000000000000000;;	  if [[ "${REGISTER_MASTER_KUBELET:-}" == "true" && -z "${KUBELET_APISERVER:-}" ]]; then
0000000000000000000000000000000000000000;;	    KUBELET_APISERVER="${MASTER_NAME}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [[ -z "${KUBERNETES_MASTER_NAME:-}" ]]; then
0000000000000000000000000000000000000000;;	    KUBERNETES_MASTER_NAME="${MASTER_NAME}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  build-kube-env true "${KUBE_TEMP}/master-kube-env.yaml"
0000000000000000000000000000000000000000;;	  build-kube-master-certs "${KUBE_TEMP}/kube-master-certs.yaml"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function write-node-env {
0000000000000000000000000000000000000000;;	  if [[ -z "${KUBERNETES_MASTER_NAME:-}" ]]; then
0000000000000000000000000000000000000000;;	    KUBERNETES_MASTER_NAME="${MASTER_NAME}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  build-kube-env false "${KUBE_TEMP}/node-kube-env.yaml"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function build-kube-master-certs {
0000000000000000000000000000000000000000;;	  local file=$1
0000000000000000000000000000000000000000;;	  rm -f ${file}
0000000000000000000000000000000000000000;;	  cat >$file <<EOF
0000000000000000000000000000000000000000;;	KUBEAPISERVER_CERT: $(yaml-quote ${KUBEAPISERVER_CERT_BASE64:-})
0000000000000000000000000000000000000000;;	KUBEAPISERVER_KEY: $(yaml-quote ${KUBEAPISERVER_KEY_BASE64:-})
0000000000000000000000000000000000000000;;	CA_KEY: $(yaml-quote ${CA_KEY_BASE64:-})
0000000000000000000000000000000000000000;;	AGGREGATOR_CA_KEY: $(yaml-quote ${AGGREGATOR_CA_KEY_BASE64:-})
0000000000000000000000000000000000000000;;	REQUESTHEADER_CA_CERT: $(yaml-quote ${REQUESTHEADER_CA_CERT_BASE64:-})
0000000000000000000000000000000000000000;;	PROXY_CLIENT_CERT: $(yaml-quote ${PROXY_CLIENT_CERT_BASE64:-})
0000000000000000000000000000000000000000;;	PROXY_CLIENT_KEY: $(yaml-quote ${PROXY_CLIENT_KEY_BASE64:-})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# $1: if 'true', we're building a master yaml, else a node
0000000000000000000000000000000000000000;;	function build-kube-env {
0000000000000000000000000000000000000000;;	  local master=$1
0000000000000000000000000000000000000000;;	  local file=$2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local server_binary_tar_url=$SERVER_BINARY_TAR_URL
0000000000000000000000000000000000000000;;	  local salt_tar_url=$SALT_TAR_URL
0000000000000000000000000000000000000000;;	  local kube_manifests_tar_url="${KUBE_MANIFESTS_TAR_URL:-}"
0000000000000000000000000000000000000000;;	  if [[ "${master}" == "true" && "${MASTER_OS_DISTRIBUTION}" == "container-linux" ]] || \
0000000000000000000000000000000000000000;;	     [[ "${master}" == "false" && "${NODE_OS_DISTRIBUTION}" == "container-linux" ]] || \
0000000000000000000000000000000000000000;;	     [[ "${master}" == "true" && "${MASTER_OS_DISTRIBUTION}" == "ubuntu" ]] || \
0000000000000000000000000000000000000000;;	     [[ "${master}" == "false" && "${NODE_OS_DISTRIBUTION}" == "ubuntu" ]] ; then
0000000000000000000000000000000000000000;;	    # TODO: Support fallback .tar.gz settings on Container Linux
0000000000000000000000000000000000000000;;	    server_binary_tar_url=$(split_csv "${SERVER_BINARY_TAR_URL}")
0000000000000000000000000000000000000000;;	    salt_tar_url=$(split_csv "${SALT_TAR_URL}")
0000000000000000000000000000000000000000;;	    kube_manifests_tar_url=$(split_csv "${KUBE_MANIFESTS_TAR_URL}")
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  build-runtime-config
0000000000000000000000000000000000000000;;	  gen-uid
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  rm -f ${file}
0000000000000000000000000000000000000000;;	  cat >$file <<EOF
0000000000000000000000000000000000000000;;	CLUSTER_NAME: $(yaml-quote ${CLUSTER_NAME})
0000000000000000000000000000000000000000;;	ENV_TIMESTAMP: $(yaml-quote $(date -u +%Y-%m-%dT%T%z))
0000000000000000000000000000000000000000;;	INSTANCE_PREFIX: $(yaml-quote ${INSTANCE_PREFIX})
0000000000000000000000000000000000000000;;	NODE_INSTANCE_PREFIX: $(yaml-quote ${NODE_INSTANCE_PREFIX})
0000000000000000000000000000000000000000;;	NODE_TAGS: $(yaml-quote ${NODE_TAGS:-})
0000000000000000000000000000000000000000;;	CLUSTER_IP_RANGE: $(yaml-quote ${CLUSTER_IP_RANGE:-10.244.0.0/16})
0000000000000000000000000000000000000000;;	SERVER_BINARY_TAR_URL: $(yaml-quote ${server_binary_tar_url})
0000000000000000000000000000000000000000;;	SERVER_BINARY_TAR_HASH: $(yaml-quote ${SERVER_BINARY_TAR_HASH})
0000000000000000000000000000000000000000;;	SALT_TAR_URL: $(yaml-quote ${salt_tar_url})
0000000000000000000000000000000000000000;;	SALT_TAR_HASH: $(yaml-quote ${SALT_TAR_HASH})
0000000000000000000000000000000000000000;;	SERVICE_CLUSTER_IP_RANGE: $(yaml-quote ${SERVICE_CLUSTER_IP_RANGE})
0000000000000000000000000000000000000000;;	KUBERNETES_MASTER_NAME: $(yaml-quote ${KUBERNETES_MASTER_NAME})
0000000000000000000000000000000000000000;;	ALLOCATE_NODE_CIDRS: $(yaml-quote ${ALLOCATE_NODE_CIDRS:-false})
0000000000000000000000000000000000000000;;	ENABLE_CLUSTER_MONITORING: $(yaml-quote ${ENABLE_CLUSTER_MONITORING:-none})
0000000000000000000000000000000000000000;;	DOCKER_REGISTRY_MIRROR_URL: $(yaml-quote ${DOCKER_REGISTRY_MIRROR_URL:-})
0000000000000000000000000000000000000000;;	ENABLE_L7_LOADBALANCING: $(yaml-quote ${ENABLE_L7_LOADBALANCING:-none})
0000000000000000000000000000000000000000;;	ENABLE_CLUSTER_LOGGING: $(yaml-quote ${ENABLE_CLUSTER_LOGGING:-false})
0000000000000000000000000000000000000000;;	ENABLE_CLUSTER_UI: $(yaml-quote ${ENABLE_CLUSTER_UI:-false})
0000000000000000000000000000000000000000;;	ENABLE_NODE_PROBLEM_DETECTOR: $(yaml-quote ${ENABLE_NODE_PROBLEM_DETECTOR:-none})
0000000000000000000000000000000000000000;;	NODE_PROBLEM_DETECTOR_VERSION: $(yaml-quote ${NODE_PROBLEM_DETECTOR_VERSION:-})
0000000000000000000000000000000000000000;;	NODE_PROBLEM_DETECTOR_TAR_HASH: $(yaml-quote ${NODE_PROBLEM_DETECTOR_TAR_HASH:-})
0000000000000000000000000000000000000000;;	ENABLE_NODE_LOGGING: $(yaml-quote ${ENABLE_NODE_LOGGING:-false})
0000000000000000000000000000000000000000;;	ENABLE_RESCHEDULER: $(yaml-quote ${ENABLE_RESCHEDULER:-false})
0000000000000000000000000000000000000000;;	LOGGING_DESTINATION: $(yaml-quote ${LOGGING_DESTINATION:-})
0000000000000000000000000000000000000000;;	ELASTICSEARCH_LOGGING_REPLICAS: $(yaml-quote ${ELASTICSEARCH_LOGGING_REPLICAS:-})
0000000000000000000000000000000000000000;;	ENABLE_CLUSTER_DNS: $(yaml-quote ${ENABLE_CLUSTER_DNS:-false})
0000000000000000000000000000000000000000;;	ENABLE_CLUSTER_REGISTRY: $(yaml-quote ${ENABLE_CLUSTER_REGISTRY:-false})
0000000000000000000000000000000000000000;;	CLUSTER_REGISTRY_DISK: $(yaml-quote ${CLUSTER_REGISTRY_DISK:-})
0000000000000000000000000000000000000000;;	CLUSTER_REGISTRY_DISK_SIZE: $(yaml-quote ${CLUSTER_REGISTRY_DISK_SIZE:-})
0000000000000000000000000000000000000000;;	DNS_SERVER_IP: $(yaml-quote ${DNS_SERVER_IP:-})
0000000000000000000000000000000000000000;;	DNS_DOMAIN: $(yaml-quote ${DNS_DOMAIN:-})
0000000000000000000000000000000000000000;;	ENABLE_DNS_HORIZONTAL_AUTOSCALER: $(yaml-quote ${ENABLE_DNS_HORIZONTAL_AUTOSCALER:-false})
0000000000000000000000000000000000000000;;	KUBELET_TOKEN: $(yaml-quote ${KUBELET_TOKEN:-})
0000000000000000000000000000000000000000;;	KUBE_PROXY_TOKEN: $(yaml-quote ${KUBE_PROXY_TOKEN:-})
0000000000000000000000000000000000000000;;	NODE_PROBLEM_DETECTOR_TOKEN: $(yaml-quote ${NODE_PROBLEM_DETECTOR_TOKEN:-})
0000000000000000000000000000000000000000;;	ADMISSION_CONTROL: $(yaml-quote ${ADMISSION_CONTROL:-})
0000000000000000000000000000000000000000;;	MASTER_IP_RANGE: $(yaml-quote ${MASTER_IP_RANGE})
0000000000000000000000000000000000000000;;	RUNTIME_CONFIG: $(yaml-quote ${RUNTIME_CONFIG})
0000000000000000000000000000000000000000;;	CA_CERT: $(yaml-quote ${CA_CERT_BASE64:-})
0000000000000000000000000000000000000000;;	KUBELET_CERT: $(yaml-quote ${KUBELET_CERT_BASE64:-})
0000000000000000000000000000000000000000;;	KUBELET_KEY: $(yaml-quote ${KUBELET_KEY_BASE64:-})
0000000000000000000000000000000000000000;;	NETWORK_PROVIDER: $(yaml-quote ${NETWORK_PROVIDER:-})
0000000000000000000000000000000000000000;;	NETWORK_POLICY_PROVIDER: $(yaml-quote ${NETWORK_POLICY_PROVIDER:-})
0000000000000000000000000000000000000000;;	PREPULL_E2E_IMAGES: $(yaml-quote ${PREPULL_E2E_IMAGES:-})
0000000000000000000000000000000000000000;;	HAIRPIN_MODE: $(yaml-quote ${HAIRPIN_MODE:-})
0000000000000000000000000000000000000000;;	SOFTLOCKUP_PANIC: $(yaml-quote ${SOFTLOCKUP_PANIC:-})
0000000000000000000000000000000000000000;;	OPENCONTRAIL_TAG: $(yaml-quote ${OPENCONTRAIL_TAG:-})
0000000000000000000000000000000000000000;;	OPENCONTRAIL_KUBERNETES_TAG: $(yaml-quote ${OPENCONTRAIL_KUBERNETES_TAG:-})
0000000000000000000000000000000000000000;;	OPENCONTRAIL_PUBLIC_SUBNET: $(yaml-quote ${OPENCONTRAIL_PUBLIC_SUBNET:-})
0000000000000000000000000000000000000000;;	E2E_STORAGE_TEST_ENVIRONMENT: $(yaml-quote ${E2E_STORAGE_TEST_ENVIRONMENT:-})
0000000000000000000000000000000000000000;;	KUBE_IMAGE_TAG: $(yaml-quote ${KUBE_IMAGE_TAG:-})
0000000000000000000000000000000000000000;;	KUBE_DOCKER_REGISTRY: $(yaml-quote ${KUBE_DOCKER_REGISTRY:-})
0000000000000000000000000000000000000000;;	KUBE_ADDON_REGISTRY: $(yaml-quote ${KUBE_ADDON_REGISTRY:-})
0000000000000000000000000000000000000000;;	MULTIZONE: $(yaml-quote ${MULTIZONE:-})
0000000000000000000000000000000000000000;;	NON_MASQUERADE_CIDR: $(yaml-quote ${NON_MASQUERADE_CIDR:-})
0000000000000000000000000000000000000000;;	KUBE_UID: $(yaml-quote ${KUBE_UID:-})
0000000000000000000000000000000000000000;;	ENABLE_DEFAULT_STORAGE_CLASS: $(yaml-quote ${ENABLE_DEFAULT_STORAGE_CLASS:-})
0000000000000000000000000000000000000000;;	ENABLE_APISERVER_BASIC_AUDIT: $(yaml-quote ${ENABLE_APISERVER_BASIC_AUDIT:-})
0000000000000000000000000000000000000000;;	ENABLE_APISERVER_ADVANCED_AUDIT: $(yaml-quote ${ENABLE_APISERVER_ADVANCED_AUDIT:-})
0000000000000000000000000000000000000000;;	ENABLE_CACHE_MUTATION_DETECTOR: $(yaml-quote ${ENABLE_CACHE_MUTATION_DETECTOR:-false})
0000000000000000000000000000000000000000;;	ENABLE_PATCH_CONVERSION_DETECTOR: $(yaml-quote ${ENABLE_PATCH_CONVERSION_DETECTOR:-false})
0000000000000000000000000000000000000000;;	ADVANCED_AUDIT_BACKEND: $(yaml-quote ${ADVANCED_AUDIT_BACKEND:-log})
0000000000000000000000000000000000000000;;	GCE_API_ENDPOINT: $(yaml-quote ${GCE_API_ENDPOINT:-})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  if [ -n "${KUBELET_PORT:-}" ]; then
0000000000000000000000000000000000000000;;	    cat >>$file <<EOF
0000000000000000000000000000000000000000;;	KUBELET_PORT: $(yaml-quote ${KUBELET_PORT})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [ -n "${KUBE_APISERVER_REQUEST_TIMEOUT:-}" ]; then
0000000000000000000000000000000000000000;;	    cat >>$file <<EOF
0000000000000000000000000000000000000000;;	KUBE_APISERVER_REQUEST_TIMEOUT: $(yaml-quote ${KUBE_APISERVER_REQUEST_TIMEOUT})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [ -n "${TERMINATED_POD_GC_THRESHOLD:-}" ]; then
0000000000000000000000000000000000000000;;	    cat >>$file <<EOF
0000000000000000000000000000000000000000;;	TERMINATED_POD_GC_THRESHOLD: $(yaml-quote ${TERMINATED_POD_GC_THRESHOLD})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [[ "${master}" == "true" && ("${MASTER_OS_DISTRIBUTION}" == "trusty" || "${MASTER_OS_DISTRIBUTION}" == "gci" || "${MASTER_OS_DISTRIBUTION}" == "container-linux") || "${MASTER_OS_DISTRIBUTION}" == "ubuntu" ]] || \
0000000000000000000000000000000000000000;;	     [[ "${master}" == "false" && ("${NODE_OS_DISTRIBUTION}" == "trusty" || "${NODE_OS_DISTRIBUTION}" == "gci" || "${NODE_OS_DISTRIBUTION}" == "container-linux") || "${NODE_OS_DISTRIBUTION}" = "ubuntu" ]] ; then
0000000000000000000000000000000000000000;;	    cat >>$file <<EOF
0000000000000000000000000000000000000000;;	KUBE_MANIFESTS_TAR_URL: $(yaml-quote ${kube_manifests_tar_url})
0000000000000000000000000000000000000000;;	KUBE_MANIFESTS_TAR_HASH: $(yaml-quote ${KUBE_MANIFESTS_TAR_HASH})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [ -n "${TEST_CLUSTER:-}" ]; then
0000000000000000000000000000000000000000;;	    cat >>$file <<EOF
0000000000000000000000000000000000000000;;	TEST_CLUSTER: $(yaml-quote ${TEST_CLUSTER})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [ -n "${KUBELET_TEST_ARGS:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	KUBELET_TEST_ARGS: $(yaml-quote ${KUBELET_TEST_ARGS})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [ -n "${NODE_KUBELET_TEST_ARGS:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	NODE_KUBELET_TEST_ARGS: $(yaml-quote ${NODE_KUBELET_TEST_ARGS})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [ -n "${MASTER_KUBELET_TEST_ARGS:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	MASTER_KUBELET_TEST_ARGS: $(yaml-quote ${MASTER_KUBELET_TEST_ARGS})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [ -n "${KUBELET_TEST_LOG_LEVEL:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	KUBELET_TEST_LOG_LEVEL: $(yaml-quote ${KUBELET_TEST_LOG_LEVEL})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [ -n "${DOCKER_TEST_LOG_LEVEL:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	DOCKER_TEST_LOG_LEVEL: $(yaml-quote ${DOCKER_TEST_LOG_LEVEL})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [ -n "${DOCKER_LOG_DRIVER:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	DOCKER_LOG_DRIVER: $(yaml-quote ${DOCKER_LOG_DRIVER})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [ -n "${DOCKER_LOG_MAX_SIZE:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	DOCKER_LOG_MAX_SIZE: $(yaml-quote ${DOCKER_LOG_MAX_SIZE})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [ -n "${DOCKER_LOG_MAX_FILE:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	DOCKER_LOG_MAX_FILE: $(yaml-quote ${DOCKER_LOG_MAX_FILE})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [ -n "${ENABLE_CUSTOM_METRICS:-}" ]; then
0000000000000000000000000000000000000000;;	    cat >>$file <<EOF
0000000000000000000000000000000000000000;;	ENABLE_CUSTOM_METRICS: $(yaml-quote ${ENABLE_CUSTOM_METRICS})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [ -n "${FEATURE_GATES:-}" ]; then
0000000000000000000000000000000000000000;;	    cat >>$file <<EOF
0000000000000000000000000000000000000000;;	FEATURE_GATES: $(yaml-quote ${FEATURE_GATES})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [[ "${master}" == "true" && "${MASTER_OS_DISTRIBUTION}" == "gci" ]] ||
0000000000000000000000000000000000000000;;	     [[ "${master}" == "false" && "${NODE_OS_DISTRIBUTION}" == "gci" ]]; then
0000000000000000000000000000000000000000;;	    cat >>$file <<EOF
0000000000000000000000000000000000000000;;	VOLUME_PLUGIN_DIR: $(yaml-quote ${VOLUME_PLUGIN_DIR:-/home/kubernetes/flexvolume})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [ -n "${PROVIDER_VARS:-}" ]; then
0000000000000000000000000000000000000000;;	    local var_name
0000000000000000000000000000000000000000;;	    local var_value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    for var_name in ${PROVIDER_VARS}; do
0000000000000000000000000000000000000000;;	      eval "local var_value=\$(yaml-quote \${${var_name}})"
0000000000000000000000000000000000000000;;	      echo "${var_name}: ${var_value}" >>$file
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "${master}" == "true" ]]; then
0000000000000000000000000000000000000000;;	    # Master-only env vars.
0000000000000000000000000000000000000000;;	    cat >>$file <<EOF
0000000000000000000000000000000000000000;;	KUBERNETES_MASTER: $(yaml-quote "true")
0000000000000000000000000000000000000000;;	KUBE_USER: $(yaml-quote ${KUBE_USER})
0000000000000000000000000000000000000000;;	KUBE_PASSWORD: $(yaml-quote ${KUBE_PASSWORD})
0000000000000000000000000000000000000000;;	KUBE_BEARER_TOKEN: $(yaml-quote ${KUBE_BEARER_TOKEN})
0000000000000000000000000000000000000000;;	MASTER_CERT: $(yaml-quote ${MASTER_CERT_BASE64:-})
0000000000000000000000000000000000000000;;	MASTER_KEY: $(yaml-quote ${MASTER_KEY_BASE64:-})
0000000000000000000000000000000000000000;;	KUBECFG_CERT: $(yaml-quote ${KUBECFG_CERT_BASE64:-})
0000000000000000000000000000000000000000;;	KUBECFG_KEY: $(yaml-quote ${KUBECFG_KEY_BASE64:-})
0000000000000000000000000000000000000000;;	KUBELET_APISERVER: $(yaml-quote ${KUBELET_APISERVER:-})
0000000000000000000000000000000000000000;;	ENABLE_MANIFEST_URL: $(yaml-quote ${ENABLE_MANIFEST_URL:-false})
0000000000000000000000000000000000000000;;	MANIFEST_URL: $(yaml-quote ${MANIFEST_URL:-})
0000000000000000000000000000000000000000;;	MANIFEST_URL_HEADER: $(yaml-quote ${MANIFEST_URL_HEADER:-})
0000000000000000000000000000000000000000;;	NUM_NODES: $(yaml-quote ${NUM_NODES})
0000000000000000000000000000000000000000;;	STORAGE_BACKEND: $(yaml-quote ${STORAGE_BACKEND:-etcd3})
0000000000000000000000000000000000000000;;	STORAGE_MEDIA_TYPE: $(yaml-quote ${STORAGE_MEDIA_TYPE:-})
0000000000000000000000000000000000000000;;	ENABLE_GARBAGE_COLLECTOR: $(yaml-quote ${ENABLE_GARBAGE_COLLECTOR:-})
0000000000000000000000000000000000000000;;	ENABLE_LEGACY_ABAC: $(yaml-quote ${ENABLE_LEGACY_ABAC:-})
0000000000000000000000000000000000000000;;	MASTER_ADVERTISE_ADDRESS: $(yaml-quote ${MASTER_ADVERTISE_ADDRESS:-})
0000000000000000000000000000000000000000;;	ETCD_CA_KEY: $(yaml-quote ${ETCD_CA_KEY_BASE64:-})
0000000000000000000000000000000000000000;;	ETCD_CA_CERT: $(yaml-quote ${ETCD_CA_CERT_BASE64:-})
0000000000000000000000000000000000000000;;	ETCD_PEER_KEY: $(yaml-quote ${ETCD_PEER_KEY_BASE64:-})
0000000000000000000000000000000000000000;;	ETCD_PEER_CERT: $(yaml-quote ${ETCD_PEER_CERT_BASE64:-})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    # ETCD_IMAGE (if set) allows to use a custom etcd image.
0000000000000000000000000000000000000000;;	    if [ -n "${ETCD_IMAGE:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	ETCD_IMAGE: $(yaml-quote ${ETCD_IMAGE})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    # ETCD_VERSION (if set) allows you to use custom version of etcd.
0000000000000000000000000000000000000000;;	    # The main purpose of using it may be rollback of etcd v3 API,
0000000000000000000000000000000000000000;;	    # where we need 3.0.* image, but are rolling back to 2.3.7.
0000000000000000000000000000000000000000;;	    if [ -n "${ETCD_VERSION:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	ETCD_VERSION: $(yaml-quote ${ETCD_VERSION})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [ -n "${APISERVER_TEST_ARGS:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	APISERVER_TEST_ARGS: $(yaml-quote ${APISERVER_TEST_ARGS})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [ -n "${APISERVER_TEST_LOG_LEVEL:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	APISERVER_TEST_LOG_LEVEL: $(yaml-quote ${APISERVER_TEST_LOG_LEVEL})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [ -n "${CONTROLLER_MANAGER_TEST_ARGS:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	CONTROLLER_MANAGER_TEST_ARGS: $(yaml-quote ${CONTROLLER_MANAGER_TEST_ARGS})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [ -n "${CONTROLLER_MANAGER_TEST_LOG_LEVEL:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	CONTROLLER_MANAGER_TEST_LOG_LEVEL: $(yaml-quote ${CONTROLLER_MANAGER_TEST_LOG_LEVEL})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [ -n "${SCHEDULER_TEST_ARGS:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	SCHEDULER_TEST_ARGS: $(yaml-quote ${SCHEDULER_TEST_ARGS})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [ -n "${SCHEDULER_TEST_LOG_LEVEL:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	SCHEDULER_TEST_LOG_LEVEL: $(yaml-quote ${SCHEDULER_TEST_LOG_LEVEL})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [ -n "${INITIAL_ETCD_CLUSTER:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	INITIAL_ETCD_CLUSTER: $(yaml-quote ${INITIAL_ETCD_CLUSTER})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [ -n "${INITIAL_ETCD_CLUSTER_STATE:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	INITIAL_ETCD_CLUSTER_STATE: $(yaml-quote ${INITIAL_ETCD_CLUSTER_STATE})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [ -n "${ETCD_QUORUM_READ:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	ETCD_QUORUM_READ: $(yaml-quote ${ETCD_QUORUM_READ})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    # Node-only env vars.
0000000000000000000000000000000000000000;;	    cat >>$file <<EOF
0000000000000000000000000000000000000000;;	KUBERNETES_MASTER: $(yaml-quote "false")
0000000000000000000000000000000000000000;;	ZONE: $(yaml-quote ${ZONE})
0000000000000000000000000000000000000000;;	EXTRA_DOCKER_OPTS: $(yaml-quote ${EXTRA_DOCKER_OPTS:-})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    if [ -n "${KUBEPROXY_TEST_ARGS:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	KUBEPROXY_TEST_ARGS: $(yaml-quote ${KUBEPROXY_TEST_ARGS})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [ -n "${KUBEPROXY_TEST_LOG_LEVEL:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	KUBEPROXY_TEST_LOG_LEVEL: $(yaml-quote ${KUBEPROXY_TEST_LOG_LEVEL})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [ -n "${NODE_LABELS:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	NODE_LABELS: $(yaml-quote ${NODE_LABELS})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  if [ -n "${EVICTION_HARD:-}" ]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	EVICTION_HARD: $(yaml-quote ${EVICTION_HARD})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  if [[ "${master}" == "true" && "${MASTER_OS_DISTRIBUTION}" == "container-linux" ]] || \
0000000000000000000000000000000000000000;;	     [[ "${master}" == "false" && "${NODE_OS_DISTRIBUTION}" == "container-linux" ]]; then
0000000000000000000000000000000000000000;;	    # Container-Linux-only env vars. TODO(yifan): Make them available on other distros.
0000000000000000000000000000000000000000;;	    cat >>$file <<EOF
0000000000000000000000000000000000000000;;	KUBERNETES_CONTAINER_RUNTIME: $(yaml-quote ${CONTAINER_RUNTIME:-rkt})
0000000000000000000000000000000000000000;;	RKT_VERSION: $(yaml-quote ${RKT_VERSION:-})
0000000000000000000000000000000000000000;;	RKT_PATH: $(yaml-quote ${RKT_PATH:-})
0000000000000000000000000000000000000000;;	RKT_STAGE1_IMAGE: $(yaml-quote ${RKT_STAGE1_IMAGE:-})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [[ "${ENABLE_CLUSTER_AUTOSCALER}" == "true" ]]; then
0000000000000000000000000000000000000000;;	      cat >>$file <<EOF
0000000000000000000000000000000000000000;;	ENABLE_CLUSTER_AUTOSCALER: $(yaml-quote ${ENABLE_CLUSTER_AUTOSCALER})
0000000000000000000000000000000000000000;;	AUTOSCALER_MIG_CONFIG: $(yaml-quote ${AUTOSCALER_MIG_CONFIG})
0000000000000000000000000000000000000000;;	AUTOSCALER_EXPANDER_CONFIG: $(yaml-quote ${AUTOSCALER_EXPANDER_CONFIG})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Federation specific environment variables.
0000000000000000000000000000000000000000;;	  if [[ -n "${FEDERATION:-}" ]]; then
0000000000000000000000000000000000000000;;	    cat >>$file <<EOF
0000000000000000000000000000000000000000;;	FEDERATION: $(yaml-quote ${FEDERATION})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [ -n "${FEDERATION_NAME:-}" ]; then
0000000000000000000000000000000000000000;;	    cat >>$file <<EOF
0000000000000000000000000000000000000000;;	FEDERATION_NAME: $(yaml-quote ${FEDERATION_NAME})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [ -n "${DNS_ZONE_NAME:-}" ]; then
0000000000000000000000000000000000000000;;	    cat >>$file <<EOF
0000000000000000000000000000000000000000;;	DNS_ZONE_NAME: $(yaml-quote ${DNS_ZONE_NAME})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [ -n "${SCHEDULING_ALGORITHM_PROVIDER:-}" ]; then
0000000000000000000000000000000000000000;;	    cat >>$file <<EOF
0000000000000000000000000000000000000000;;	SCHEDULING_ALGORITHM_PROVIDER: $(yaml-quote ${SCHEDULING_ALGORITHM_PROVIDER})
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function sha1sum-file() {
0000000000000000000000000000000000000000;;	  if which sha1sum >/dev/null 2>&1; then
0000000000000000000000000000000000000000;;	    sha1sum "$1" | awk '{ print $1 }'
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    shasum -a1 "$1" | awk '{ print $1 }'
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Create certificate pairs for the cluster.
0000000000000000000000000000000000000000;;	# $1: The public IP for the master.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# These are used for static cert distribution (e.g. static clustering) at
0000000000000000000000000000000000000000;;	# cluster creation time. This will be obsoleted once we implement dynamic
0000000000000000000000000000000000000000;;	# clustering.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# The following certificate pairs are created:
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#  - ca (the cluster's certificate authority)
0000000000000000000000000000000000000000;;	#  - server
0000000000000000000000000000000000000000;;	#  - kubelet
0000000000000000000000000000000000000000;;	#  - kubecfg (for kubectl)
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# TODO(roberthbailey): Replace easyrsa with a simple Go program to generate
0000000000000000000000000000000000000000;;	# the certs that we need.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars
0000000000000000000000000000000000000000;;	#   KUBE_TEMP
0000000000000000000000000000000000000000;;	#   MASTER_NAME
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   CERT_DIR
0000000000000000000000000000000000000000;;	#   CA_CERT_BASE64
0000000000000000000000000000000000000000;;	#   MASTER_CERT_BASE64
0000000000000000000000000000000000000000;;	#   MASTER_KEY_BASE64
0000000000000000000000000000000000000000;;	#   KUBELET_CERT_BASE64
0000000000000000000000000000000000000000;;	#   KUBELET_KEY_BASE64
0000000000000000000000000000000000000000;;	#   KUBECFG_CERT_BASE64
0000000000000000000000000000000000000000;;	#   KUBECFG_KEY_BASE64
0000000000000000000000000000000000000000;;	function create-certs {
0000000000000000000000000000000000000000;;	  local -r primary_cn="${1}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Determine extra certificate names for master
0000000000000000000000000000000000000000;;	  local octets=($(echo "${SERVICE_CLUSTER_IP_RANGE}" | sed -e 's|/.*||' -e 's/\./ /g'))
0000000000000000000000000000000000000000;;	  ((octets[3]+=1))
0000000000000000000000000000000000000000;;	  local -r service_ip=$(echo "${octets[*]}" | sed 's/ /./g')
0000000000000000000000000000000000000000;;	  local sans=""
0000000000000000000000000000000000000000;;	  for extra in $@; do
0000000000000000000000000000000000000000;;	    if [[ -n "${extra}" ]]; then
0000000000000000000000000000000000000000;;	      sans="${sans}IP:${extra},"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  sans="${sans}IP:${service_ip},DNS:kubernetes,DNS:kubernetes.default,DNS:kubernetes.default.svc,DNS:kubernetes.default.svc.${DNS_DOMAIN},DNS:${MASTER_NAME}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "Generating certs for alternate-names: ${sans}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  setup-easyrsa
0000000000000000000000000000000000000000;;	  PRIMARY_CN="${primary_cn}" SANS="${sans}" generate-certs
0000000000000000000000000000000000000000;;	  AGGREGATOR_PRIMARY_CN="${primary_cn}" AGGREGATOR_SANS="${sans}" generate-aggregator-certs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  CERT_DIR="${KUBE_TEMP}/easy-rsa-master/easyrsa3"
0000000000000000000000000000000000000000;;	  # By default, linux wraps base64 output every 76 cols, so we use 'tr -d' to remove whitespaces.
0000000000000000000000000000000000000000;;	  # Note 'base64 -w0' doesn't work on Mac OS X, which has different flags.
0000000000000000000000000000000000000000;;	  CA_KEY_BASE64=$(cat "${CERT_DIR}/pki/private/ca.key" | base64 | tr -d '\r\n')
0000000000000000000000000000000000000000;;	  CA_CERT_BASE64=$(cat "${CERT_DIR}/pki/ca.crt" | base64 | tr -d '\r\n')
0000000000000000000000000000000000000000;;	  MASTER_CERT_BASE64=$(cat "${CERT_DIR}/pki/issued/${MASTER_NAME}.crt" | base64 | tr -d '\r\n')
0000000000000000000000000000000000000000;;	  MASTER_KEY_BASE64=$(cat "${CERT_DIR}/pki/private/${MASTER_NAME}.key" | base64 | tr -d '\r\n')
0000000000000000000000000000000000000000;;	  KUBELET_CERT_BASE64=$(cat "${CERT_DIR}/pki/issued/kubelet.crt" | base64 | tr -d '\r\n')
0000000000000000000000000000000000000000;;	  KUBELET_KEY_BASE64=$(cat "${CERT_DIR}/pki/private/kubelet.key" | base64 | tr -d '\r\n')
0000000000000000000000000000000000000000;;	  KUBECFG_CERT_BASE64=$(cat "${CERT_DIR}/pki/issued/kubecfg.crt" | base64 | tr -d '\r\n')
0000000000000000000000000000000000000000;;	  KUBECFG_KEY_BASE64=$(cat "${CERT_DIR}/pki/private/kubecfg.key" | base64 | tr -d '\r\n')
0000000000000000000000000000000000000000;;	  KUBEAPISERVER_CERT_BASE64=$(cat "${CERT_DIR}/pki/issued/kube-apiserver.crt" | base64 | tr -d '\r\n')
0000000000000000000000000000000000000000;;	  KUBEAPISERVER_KEY_BASE64=$(cat "${CERT_DIR}/pki/private/kube-apiserver.key" | base64 | tr -d '\r\n')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Setting up an addition directory (beyond pki) as it is the simplest way to
0000000000000000000000000000000000000000;;	  # ensure we get a different CA pair to sign the proxy-client certs and which
0000000000000000000000000000000000000000;;	  # we can send CA public key to the user-apiserver to validate communication.
0000000000000000000000000000000000000000;;	  AGGREGATOR_CERT_DIR="${KUBE_TEMP}/easy-rsa-master/aggregator"
0000000000000000000000000000000000000000;;	  AGGREGATOR_CA_KEY_BASE64=$(cat "${AGGREGATOR_CERT_DIR}/pki/private/ca.key" | base64 | tr -d '\r\n')
0000000000000000000000000000000000000000;;	  REQUESTHEADER_CA_CERT_BASE64=$(cat "${AGGREGATOR_CERT_DIR}/pki/ca.crt" | base64 | tr -d '\r\n')
0000000000000000000000000000000000000000;;	  PROXY_CLIENT_CERT_BASE64=$(cat "${AGGREGATOR_CERT_DIR}/pki/issued/proxy-client.crt" | base64 | tr -d '\r\n')
0000000000000000000000000000000000000000;;	  PROXY_CLIENT_KEY_BASE64=$(cat "${AGGREGATOR_CERT_DIR}/pki/private/proxy-client.key" | base64 | tr -d '\r\n')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function setup-easyrsa {
0000000000000000000000000000000000000000;;	  local -r cert_create_debug_output=$(mktemp "${KUBE_TEMP}/cert_create_debug_output.XXX")
0000000000000000000000000000000000000000;;	  # Note: This was heavily cribbed from make-ca-cert.sh
0000000000000000000000000000000000000000;;	  (set -x
0000000000000000000000000000000000000000;;	    cd "${KUBE_TEMP}"
0000000000000000000000000000000000000000;;	    curl -L -O --connect-timeout 20 --retry 6 --retry-delay 2 https://storage.googleapis.com/kubernetes-release/easy-rsa/easy-rsa.tar.gz
0000000000000000000000000000000000000000;;	    tar xzf easy-rsa.tar.gz
0000000000000000000000000000000000000000;;	    mkdir easy-rsa-master/kubelet
0000000000000000000000000000000000000000;;	    cp -r easy-rsa-master/easyrsa3/* easy-rsa-master/kubelet
0000000000000000000000000000000000000000;;	    mkdir easy-rsa-master/aggregator
0000000000000000000000000000000000000000;;	    cp -r easy-rsa-master/easyrsa3/* easy-rsa-master/aggregator) &>${cert_create_debug_output} || {
0000000000000000000000000000000000000000;;	    # If there was an error in the subshell, just die.
0000000000000000000000000000000000000000;;	    # TODO(roberthbailey): add better error handling here
0000000000000000000000000000000000000000;;	    cat "${cert_create_debug_output}" >&2
0000000000000000000000000000000000000000;;	    echo "=== Failed to setup easy-rsa: Aborting ===" >&2
0000000000000000000000000000000000000000;;	    exit 2
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Runs the easy RSA commands to generate certificate files.
0000000000000000000000000000000000000000;;	# The generated files are at ${KUBE_TEMP}/easy-rsa-master/easyrsa3
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars
0000000000000000000000000000000000000000;;	#   KUBE_TEMP
0000000000000000000000000000000000000000;;	#   MASTER_NAME
0000000000000000000000000000000000000000;;	#   PRIMARY_CN: Primary canonical name
0000000000000000000000000000000000000000;;	#   SANS: Subject alternate names
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function generate-certs {
0000000000000000000000000000000000000000;;	  local -r cert_create_debug_output=$(mktemp "${KUBE_TEMP}/cert_create_debug_output.XXX")
0000000000000000000000000000000000000000;;	  # Note: This was heavily cribbed from make-ca-cert.sh
0000000000000000000000000000000000000000;;	  (set -x
0000000000000000000000000000000000000000;;	    cd "${KUBE_TEMP}/easy-rsa-master/easyrsa3"
0000000000000000000000000000000000000000;;	    ./easyrsa init-pki
0000000000000000000000000000000000000000;;	    # this puts the cert into pki/ca.crt and the key into pki/private/ca.key
0000000000000000000000000000000000000000;;	    ./easyrsa --batch "--req-cn=${PRIMARY_CN}@$(date +%s)" build-ca nopass
0000000000000000000000000000000000000000;;	    ./easyrsa --subject-alt-name="${SANS}" build-server-full "${MASTER_NAME}" nopass
0000000000000000000000000000000000000000;;	    ./easyrsa build-client-full kube-apiserver nopass
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    kube::util::ensure-cfssl "${KUBE_TEMP}/cfssl"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # make the config for the signer
0000000000000000000000000000000000000000;;	    echo '{"signing":{"default":{"expiry":"43800h","usages":["signing","key encipherment","client auth"]}}}' > "ca-config.json"
0000000000000000000000000000000000000000;;	    # create the kubelet client cert with the correct groups
0000000000000000000000000000000000000000;;	    echo '{"CN":"kubelet","names":[{"O":"system:nodes"}],"hosts":[""],"key":{"algo":"rsa","size":2048}}' | "${CFSSL_BIN}" gencert -ca=pki/ca.crt -ca-key=pki/private/ca.key -config=ca-config.json - | "${CFSSLJSON_BIN}" -bare kubelet
0000000000000000000000000000000000000000;;	    mv "kubelet-key.pem" "pki/private/kubelet.key"
0000000000000000000000000000000000000000;;	    mv "kubelet.pem" "pki/issued/kubelet.crt"
0000000000000000000000000000000000000000;;	    rm -f "kubelet.csr"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Make a superuser client cert with subject "O=system:masters, CN=kubecfg"
0000000000000000000000000000000000000000;;	    ./easyrsa --dn-mode=org \
0000000000000000000000000000000000000000;;	      --req-cn=kubecfg --req-org=system:masters \
0000000000000000000000000000000000000000;;	      --req-c= --req-st= --req-city= --req-email= --req-ou= \
0000000000000000000000000000000000000000;;	      build-client-full kubecfg nopass) &>${cert_create_debug_output} || {
0000000000000000000000000000000000000000;;	    # If there was an error in the subshell, just die.
0000000000000000000000000000000000000000;;	    # TODO(roberthbailey): add better error handling here
0000000000000000000000000000000000000000;;	    cat "${cert_create_debug_output}" >&2
0000000000000000000000000000000000000000;;	    echo "=== Failed to generate master certificates: Aborting ===" >&2
0000000000000000000000000000000000000000;;	    exit 2
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Runs the easy RSA commands to generate aggregator certificate files.
0000000000000000000000000000000000000000;;	# The generated files are at ${KUBE_TEMP}/easy-rsa-master/aggregator
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars
0000000000000000000000000000000000000000;;	#   KUBE_TEMP
0000000000000000000000000000000000000000;;	#   AGGREGATOR_MASTER_NAME
0000000000000000000000000000000000000000;;	#   AGGREGATOR_PRIMARY_CN: Primary canonical name
0000000000000000000000000000000000000000;;	#   AGGREGATOR_SANS: Subject alternate names
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function generate-aggregator-certs {
0000000000000000000000000000000000000000;;	  local -r cert_create_debug_output=$(mktemp "${KUBE_TEMP}/cert_create_debug_output.XXX")
0000000000000000000000000000000000000000;;	  # Note: This was heavily cribbed from make-ca-cert.sh
0000000000000000000000000000000000000000;;	  (set -x
0000000000000000000000000000000000000000;;	    cd "${KUBE_TEMP}/easy-rsa-master/aggregator"
0000000000000000000000000000000000000000;;	    ./easyrsa init-pki
0000000000000000000000000000000000000000;;	    # this puts the cert into pki/ca.crt and the key into pki/private/ca.key
0000000000000000000000000000000000000000;;	    ./easyrsa --batch "--req-cn=${AGGREGATOR_PRIMARY_CN}@$(date +%s)" build-ca nopass
0000000000000000000000000000000000000000;;	    ./easyrsa --subject-alt-name="${AGGREGATOR_SANS}" build-server-full "${AGGREGATOR_MASTER_NAME}" nopass
0000000000000000000000000000000000000000;;	    ./easyrsa build-client-full aggregator-apiserver nopass
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    kube::util::ensure-cfssl "${KUBE_TEMP}/cfssl"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # make the config for the signer
0000000000000000000000000000000000000000;;	    echo '{"signing":{"default":{"expiry":"43800h","usages":["signing","key encipherment","client auth"]}}}' > "ca-config.json"
0000000000000000000000000000000000000000;;	    # create the aggregator client cert with the correct groups
0000000000000000000000000000000000000000;;	    echo '{"CN":"aggregator","hosts":[""],"key":{"algo":"rsa","size":2048}}' | "${CFSSL_BIN}" gencert -ca=pki/ca.crt -ca-key=pki/private/ca.key -config=ca-config.json - | "${CFSSLJSON_BIN}" -bare proxy-client
0000000000000000000000000000000000000000;;	    mv "proxy-client-key.pem" "pki/private/proxy-client.key"
0000000000000000000000000000000000000000;;	    mv "proxy-client.pem" "pki/issued/proxy-client.crt"
0000000000000000000000000000000000000000;;	    rm -f "proxy-client.csr"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Make a superuser client cert with subject "O=system:masters, CN=kubecfg"
0000000000000000000000000000000000000000;;	    ./easyrsa --dn-mode=org \
0000000000000000000000000000000000000000;;	      --req-cn=proxy-clientcfg --req-org=system:aggregator \
0000000000000000000000000000000000000000;;	      --req-c= --req-st= --req-city= --req-email= --req-ou= \
0000000000000000000000000000000000000000;;	      build-client-full proxy-clientcfg nopass) &>${cert_create_debug_output} || {
0000000000000000000000000000000000000000;;	    # If there was an error in the subshell, just die.
0000000000000000000000000000000000000000;;	    # TODO(roberthbailey): add better error handling here
0000000000000000000000000000000000000000;;	    cat "${cert_create_debug_output}" >&2
0000000000000000000000000000000000000000;;	    echo "=== Failed to generate aggregator certificates: Aborting ===" >&2
0000000000000000000000000000000000000000;;	    exit 2
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Run the cfssl command to generates certificate files for etcd service, the
0000000000000000000000000000000000000000;;	# certificate files will save in $1 directory.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Optional vars:
0000000000000000000000000000000000000000;;	#   GEN_ETCD_CA_CERT (CA cert encode with base64 and ZIP compression)
0000000000000000000000000000000000000000;;	#   GEN_ETCD_CA_KEY (CA key encode with base64)
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# If GEN_ETCD_CA_CERT or GEN_ETCD_CA_KEY is not specified, it will generates certs for CA.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Args:
0000000000000000000000000000000000000000;;	#   $1 (the directory that certificate files to save)
0000000000000000000000000000000000000000;;	#   $2 (the ip of etcd member)
0000000000000000000000000000000000000000;;	#   $3 (the type of etcd certificates, must be one of client, server, peer)
0000000000000000000000000000000000000000;;	#   $4 (the prefix of the certificate filename, default is $3)
0000000000000000000000000000000000000000;;	function generate-etcd-cert() {
0000000000000000000000000000000000000000;;	  local cert_dir=${1}
0000000000000000000000000000000000000000;;	  local member_ip=${2}
0000000000000000000000000000000000000000;;	  local type_cert=${3}
0000000000000000000000000000000000000000;;	  local prefix=${4:-"${type_cert}"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local GEN_ETCD_CA_CERT=${GEN_ETCD_CA_CERT:-}
0000000000000000000000000000000000000000;;	  local GEN_ETCD_CA_KEY=${GEN_ETCD_CA_KEY:-}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  mkdir -p "${cert_dir}"
0000000000000000000000000000000000000000;;	  pushd "${cert_dir}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::util::ensure-cfssl .
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [ ! -r "ca-config.json" ]; then
0000000000000000000000000000000000000000;;	    cat >ca-config.json <<EOF
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    "signing": {
0000000000000000000000000000000000000000;;	        "default": {
0000000000000000000000000000000000000000;;	            "expiry": "43800h"
0000000000000000000000000000000000000000;;	        },
0000000000000000000000000000000000000000;;	        "profiles": {
0000000000000000000000000000000000000000;;	            "server": {
0000000000000000000000000000000000000000;;	                "expiry": "43800h",
0000000000000000000000000000000000000000;;	                "usages": [
0000000000000000000000000000000000000000;;	                    "signing",
0000000000000000000000000000000000000000;;	                    "key encipherment",
0000000000000000000000000000000000000000;;	                    "server auth"
0000000000000000000000000000000000000000;;	                ]
0000000000000000000000000000000000000000;;	            },
0000000000000000000000000000000000000000;;	            "client": {
0000000000000000000000000000000000000000;;	                "expiry": "43800h",
0000000000000000000000000000000000000000;;	                "usages": [
0000000000000000000000000000000000000000;;	                    "signing",
0000000000000000000000000000000000000000;;	                    "key encipherment",
0000000000000000000000000000000000000000;;	                    "client auth"
0000000000000000000000000000000000000000;;	                ]
0000000000000000000000000000000000000000;;	            },
0000000000000000000000000000000000000000;;	            "peer": {
0000000000000000000000000000000000000000;;	                "expiry": "43800h",
0000000000000000000000000000000000000000;;	                "usages": [
0000000000000000000000000000000000000000;;	                    "signing",
0000000000000000000000000000000000000000;;	                    "key encipherment",
0000000000000000000000000000000000000000;;	                    "server auth",
0000000000000000000000000000000000000000;;	                    "client auth"
0000000000000000000000000000000000000000;;	                ]
0000000000000000000000000000000000000000;;	            }
0000000000000000000000000000000000000000;;	        }
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [ ! -r "ca-csr.json" ]; then
0000000000000000000000000000000000000000;;	    cat >ca-csr.json <<EOF
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    "CN": "Kubernetes",
0000000000000000000000000000000000000000;;	    "key": {
0000000000000000000000000000000000000000;;	        "algo": "ecdsa",
0000000000000000000000000000000000000000;;	        "size": 256
0000000000000000000000000000000000000000;;	    },
0000000000000000000000000000000000000000;;	    "names": [
0000000000000000000000000000000000000000;;	        {
0000000000000000000000000000000000000000;;	            "C": "US",
0000000000000000000000000000000000000000;;	            "L": "CA",
0000000000000000000000000000000000000000;;	            "O": "kubernetes.io"
0000000000000000000000000000000000000000;;	        }
0000000000000000000000000000000000000000;;	    ]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ -n "${GEN_ETCD_CA_CERT}" && -n "${GEN_ETCD_CA_KEY}" ]]; then
0000000000000000000000000000000000000000;;	    echo "${ca_cert}" | base64 --decode | gunzip > ca.pem
0000000000000000000000000000000000000000;;	    echo "${ca_key}" | base64 --decode > ca-key.pem
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ ! -r "ca.pem" || ! -r "ca-key.pem" ]]; then
0000000000000000000000000000000000000000;;	    ${CFSSL_BIN} gencert -initca ca-csr.json | ${CFSSLJSON_BIN} -bare ca -
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  case "${type_cert}" in
0000000000000000000000000000000000000000;;	    client)
0000000000000000000000000000000000000000;;	      echo "Generate client certificates..."
0000000000000000000000000000000000000000;;	      echo '{"CN":"client","hosts":["*"],"key":{"algo":"ecdsa","size":256}}' \
0000000000000000000000000000000000000000;;	       | ${CFSSL_BIN} gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=client - \
0000000000000000000000000000000000000000;;	       | ${CFSSLJSON_BIN} -bare "${prefix}"
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	    server)
0000000000000000000000000000000000000000;;	      echo "Generate server certificates..."
0000000000000000000000000000000000000000;;	      echo '{"CN":"'${member_ip}'","hosts":[""],"key":{"algo":"ecdsa","size":256}}' \
0000000000000000000000000000000000000000;;	       | ${CFSSL_BIN} gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=server -hostname="${member_ip},127.0.0.1" - \
0000000000000000000000000000000000000000;;	       | ${CFSSLJSON_BIN} -bare "${prefix}"
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	    peer)
0000000000000000000000000000000000000000;;	      echo "Generate peer certificates..."
0000000000000000000000000000000000000000;;	      echo '{"CN":"'${member_ip}'","hosts":[""],"key":{"algo":"ecdsa","size":256}}' \
0000000000000000000000000000000000000000;;	       | ${CFSSL_BIN} gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=peer -hostname="${member_ip},127.0.0.1" - \
0000000000000000000000000000000000000000;;	       | ${CFSSLJSON_BIN} -bare "${prefix}"
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	    *)
0000000000000000000000000000000000000000;;	      echo "Unknow, unsupported etcd certs type: ${type_cert}" >&2
0000000000000000000000000000000000000000;;	      echo "Supported type: client, server, peer" >&2
0000000000000000000000000000000000000000;;	      exit 2
0000000000000000000000000000000000000000;;	  esac
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  popd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Using provided master env, extracts value from provided key.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Args:
0000000000000000000000000000000000000000;;	# $1 master env (kube-env of master; result of calling get-master-env)
0000000000000000000000000000000000000000;;	# $2 env key to use
0000000000000000000000000000000000000000;;	function get-env-val() {
0000000000000000000000000000000000000000;;	  local match=`(echo "${1}" | grep -E "^${2}:") || echo ""`
0000000000000000000000000000000000000000;;	  if [[ -z ${match} ]]; then
0000000000000000000000000000000000000000;;	    echo ""
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  echo ${match} | cut -d : -f 2 | cut -d \' -f 2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Load the master env by calling get-master-env, and extract important values
0000000000000000000000000000000000000000;;	function parse-master-env() {
0000000000000000000000000000000000000000;;	  # Get required master env vars
0000000000000000000000000000000000000000;;	  local master_env=$(get-master-env)
0000000000000000000000000000000000000000;;	  KUBELET_TOKEN=$(get-env-val "${master_env}" "KUBELET_TOKEN")
0000000000000000000000000000000000000000;;	  KUBE_PROXY_TOKEN=$(get-env-val "${master_env}" "KUBE_PROXY_TOKEN")
0000000000000000000000000000000000000000;;	  NODE_PROBLEM_DETECTOR_TOKEN=$(get-env-val "${master_env}" "NODE_PROBLEM_DETECTOR_TOKEN")
0000000000000000000000000000000000000000;;	  CA_CERT_BASE64=$(get-env-val "${master_env}" "CA_CERT")
0000000000000000000000000000000000000000;;	  CA_KEY_BASE64=$(get-env-val "${master_env}" "CA_KEY")
0000000000000000000000000000000000000000;;	  KUBEAPISERVER_CERT_BASE64=$(get-env-val "${master_env}" "KUBEAPISERVER_CERT")
0000000000000000000000000000000000000000;;	  KUBEAPISERVER_KEY_BASE64=$(get-env-val "${master_env}" "KUBEAPISERVER_KEY")
0000000000000000000000000000000000000000;;	  EXTRA_DOCKER_OPTS=$(get-env-val "${master_env}" "EXTRA_DOCKER_OPTS")
0000000000000000000000000000000000000000;;	  KUBELET_CERT_BASE64=$(get-env-val "${master_env}" "KUBELET_CERT")
0000000000000000000000000000000000000000;;	  KUBELET_KEY_BASE64=$(get-env-val "${master_env}" "KUBELET_KEY")
0000000000000000000000000000000000000000;;	  MASTER_CERT_BASE64=$(get-env-val "${master_env}" "MASTER_CERT")
0000000000000000000000000000000000000000;;	  MASTER_KEY_BASE64=$(get-env-val "${master_env}" "MASTER_KEY")
0000000000000000000000000000000000000000;;	  AGGREGATOR_CA_KEY_BASE64=$(get-env-val "${master_env}" "AGGREGATOR_CA_KEY")
0000000000000000000000000000000000000000;;	  REQUESTHEADER_CA_CERT_BASE64=$(get-env-val "${master_env}" "REQUESTHEADER_CA_CERT")
0000000000000000000000000000000000000000;;	  PROXY_CLIENT_CERT_BASE64=$(get-env-val "${master_env}" "PROXY_CLIENT_CERT")
0000000000000000000000000000000000000000;;	  PROXY_CLIENT_KEY_BASE64=$(get-env-val "${master_env}" "PROXY_CLIENT_KEY")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Update or verify required gcloud components are installed
0000000000000000000000000000000000000000;;	# at minimum required version.
0000000000000000000000000000000000000000;;	# Assumed vars
0000000000000000000000000000000000000000;;	#   KUBE_PROMPT_FOR_UPDATE
0000000000000000000000000000000000000000;;	function update-or-verify-gcloud() {
0000000000000000000000000000000000000000;;	  local sudo_prefix=""
0000000000000000000000000000000000000000;;	  if [ ! -w $(dirname `which gcloud`) ]; then
0000000000000000000000000000000000000000;;	    sudo_prefix="sudo"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  # update and install components as needed
0000000000000000000000000000000000000000;;	  if [[ "${KUBE_PROMPT_FOR_UPDATE}" == "y" ]]; then
0000000000000000000000000000000000000000;;	    ${sudo_prefix} gcloud ${gcloud_prompt:-} components install alpha
0000000000000000000000000000000000000000;;	    ${sudo_prefix} gcloud ${gcloud_prompt:-} components install beta
0000000000000000000000000000000000000000;;	    ${sudo_prefix} gcloud ${gcloud_prompt:-} components update
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    local version=$(gcloud version --format=json)
0000000000000000000000000000000000000000;;	    python -c'
0000000000000000000000000000000000000000;;	import json,sys
0000000000000000000000000000000000000000;;	from distutils import version
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	minVersion = version.LooseVersion("1.3.0")
0000000000000000000000000000000000000000;;	required = [ "alpha", "beta", "core" ]
0000000000000000000000000000000000000000;;	data = json.loads(sys.argv[1])
0000000000000000000000000000000000000000;;	rel = data.get("Google Cloud SDK")
0000000000000000000000000000000000000000;;	if rel != "HEAD" and version.LooseVersion(rel) < minVersion:
0000000000000000000000000000000000000000;;	  print("gcloud version out of date ( < %s )" % minVersion)
0000000000000000000000000000000000000000;;	  exit(1)
0000000000000000000000000000000000000000;;	missing = []
0000000000000000000000000000000000000000;;	for c in required:
0000000000000000000000000000000000000000;;	  if not data.get(c):
0000000000000000000000000000000000000000;;	    missing += [c]
0000000000000000000000000000000000000000;;	if missing:
0000000000000000000000000000000000000000;;	  for c in missing:
0000000000000000000000000000000000000000;;	    print ("missing required gcloud component \"{0}\"".format(c))
0000000000000000000000000000000000000000;;	  exit(1)
0000000000000000000000000000000000000000;;	    ' """${version}"""
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Check whether required client and server binaries exist, prompting to download
0000000000000000000000000000000000000000;;	# if missing.
0000000000000000000000000000000000000000;;	# If KUBERNETES_SKIP_CONFIRM is set to y, we'll automatically download binaries
0000000000000000000000000000000000000000;;	# without prompting.
0000000000000000000000000000000000000000;;	function verify-kube-binaries() {
0000000000000000000000000000000000000000;;	  local missing_binaries=false
0000000000000000000000000000000000000000;;	  if ! "${KUBE_ROOT}/cluster/kubectl.sh" version --client >&/dev/null; then
0000000000000000000000000000000000000000;;	    echo "!!! kubectl appears to be broken or missing"
0000000000000000000000000000000000000000;;	    missing_binaries=true
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if ! $(find-release-tars); then
0000000000000000000000000000000000000000;;	    missing_binaries=true
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if ! "${missing_binaries}"; then
0000000000000000000000000000000000000000;;	    return
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  get_binaries_script="${KUBE_ROOT}/cluster/get-kube-binaries.sh"
0000000000000000000000000000000000000000;;	  local resp="y"
0000000000000000000000000000000000000000;;	  if [[ ! "${KUBERNETES_SKIP_CONFIRM:-n}" =~ ^[yY]$ ]]; then
0000000000000000000000000000000000000000;;	    echo "Required binaries appear to be missing. Do you wish to download them? [Y/n]"
0000000000000000000000000000000000000000;;	    read resp
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [[ "${resp}" =~ ^[nN]$ ]]; then
0000000000000000000000000000000000000000;;	    echo "You must download binaries to continue. You can use "
0000000000000000000000000000000000000000;;	    echo "  ${get_binaries_script}"
0000000000000000000000000000000000000000;;	    echo "to do this for your automatically."
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  "${get_binaries_script}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Run pushd without stack output
0000000000000000000000000000000000000000;;	function pushd() {
0000000000000000000000000000000000000000;;	  command pushd $@ > /dev/null
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Run popd without stack output
0000000000000000000000000000000000000000;;	function popd() {
0000000000000000000000000000000000000000;;	  command popd $@ > /dev/null
0000000000000000000000000000000000000000;;	}
