0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2014 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# A library of helper functions that each provider hosting Kubernetes must implement to use cluster/kube-*.sh scripts.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[ ! -z ${UTIL_SH_DEBUG+x} ] && set -x
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	command -v kubectl >/dev/null 2>&1 || { echo >&2 "kubectl not found in path. Aborting."; exit 1; }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_ROOT=$(dirname "${BASH_SOURCE}")/../..
0000000000000000000000000000000000000000;;	readonly ROOT=$(dirname "${BASH_SOURCE}")
0000000000000000000000000000000000000000;;	source "$ROOT/${KUBE_CONFIG_FILE:-"config-default.sh"}"
0000000000000000000000000000000000000000;;	source "$KUBE_ROOT/cluster/common.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	export LIBVIRT_DEFAULT_URI=qemu:///system
0000000000000000000000000000000000000000;;	export SERVICE_ACCOUNT_LOOKUP=${SERVICE_ACCOUNT_LOOKUP:-true}
0000000000000000000000000000000000000000;;	export ADMISSION_CONTROL=${ADMISSION_CONTROL:-Initializers,NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,ResourceQuota}
0000000000000000000000000000000000000000;;	readonly POOL=kubernetes
0000000000000000000000000000000000000000;;	readonly POOL_PATH=/var/lib/libvirt/images/kubernetes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[ ! -d "${POOL_PATH}" ] && (echo "$POOL_PATH" does not exist ; exit 1 )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# join <delim> <list...>
0000000000000000000000000000000000000000;;	# Concatenates the list elements with the delimiter passed as first parameter
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Ex: join , a b c
0000000000000000000000000000000000000000;;	#  -> a,b,c
0000000000000000000000000000000000000000;;	function join {
0000000000000000000000000000000000000000;;	  local IFS="$1"
0000000000000000000000000000000000000000;;	  shift
0000000000000000000000000000000000000000;;	  echo "$*"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Must ensure that the following ENV vars are set
0000000000000000000000000000000000000000;;	function detect-master {
0000000000000000000000000000000000000000;;	  KUBE_MASTER_IP=$MASTER_IP
0000000000000000000000000000000000000000;;	  KUBE_MASTER=$MASTER_NAME
0000000000000000000000000000000000000000;;	  export KUBERNETES_MASTER=http://$KUBE_MASTER_IP:8080
0000000000000000000000000000000000000000;;	  echo "KUBE_MASTER_IP: $KUBE_MASTER_IP"
0000000000000000000000000000000000000000;;	  echo "KUBE_MASTER: $KUBE_MASTER"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Get node IP addresses and store in KUBE_NODE_IP_ADDRESSES[]
0000000000000000000000000000000000000000;;	function detect-nodes {
0000000000000000000000000000000000000000;;	  KUBE_NODE_IP_ADDRESSES=("${NODE_IPS[@]}")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function generate_certs {
0000000000000000000000000000000000000000;;	    node_names=("${@}")
0000000000000000000000000000000000000000;;	    #Root-CA
0000000000000000000000000000000000000000;;	    tempdir=$(mktemp -d)
0000000000000000000000000000000000000000;;	    CA_KEY=${CA_KEY:-"$tempdir/ca-key.pem"}
0000000000000000000000000000000000000000;;	    CA_CERT=${CA_CERT:-"$tempdir/ca.pem"}
0000000000000000000000000000000000000000;;	    openssl genrsa -out "${CA_KEY}" 2048 2>/dev/null
0000000000000000000000000000000000000000;;	    openssl req -x509 -new -nodes -key "${CA_KEY}" -days 10000 -out "${CA_CERT}" -subj "/CN=kube-ca"  2>/dev/null
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    #API server key pair
0000000000000000000000000000000000000000;;	    KUBE_KEY=${KUBE_KEY:-"$tempdir/apiserver-key.pem"}
0000000000000000000000000000000000000000;;	    API_SERVER_CERT_REQ=${API_SERVER_CERT_REQ:-"$tempdir/apiserver.csr"}
0000000000000000000000000000000000000000;;	    openssl genrsa -out "${KUBE_KEY}" 2048 2>/dev/null
0000000000000000000000000000000000000000;;	    KUBERNETES_SVC=${SERVICE_CLUSTER_IP_RANGE%.*}.1 openssl req -new -key "${KUBE_KEY}" -out "${API_SERVER_CERT_REQ}" -subj "/CN=kube-apiserver" -config cluster/libvirt-coreos/openssl.cnf 2>/dev/null
0000000000000000000000000000000000000000;;	    KUBE_CERT=${KUBE_CERT:-"$tempdir/apiserver.pem"}
0000000000000000000000000000000000000000;;	    KUBERNETES_SVC=${SERVICE_CLUSTER_IP_RANGE%.*}.1 openssl x509 -req -in "${API_SERVER_CERT_REQ}" -CA "${CA_CERT}" -CAkey "${CA_KEY}" -CAcreateserial -out "${KUBE_CERT}" -days 365 -extensions v3_req -extfile  cluster/libvirt-coreos/openssl.cnf 2>/dev/null
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    #Copy apiserver and controller tsl assets
0000000000000000000000000000000000000000;;	    mkdir -p  "$POOL_PATH/kubernetes/certs"
0000000000000000000000000000000000000000;;	    cp "${KUBE_CERT}" "$POOL_PATH/kubernetes/certs"
0000000000000000000000000000000000000000;;	    cp "${KUBE_KEY}"  "$POOL_PATH/kubernetes/certs"
0000000000000000000000000000000000000000;;	    cp "${CA_CERT}" "$POOL_PATH/kubernetes/certs"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    #Generate nodes certificate
0000000000000000000000000000000000000000;;	    for (( i = 0 ; i < $NUM_NODES ; i++ )); do
0000000000000000000000000000000000000000;;	        openssl genrsa -out $tempdir/${node_names[$i]}-node-key.pem 2048 2>/dev/null
0000000000000000000000000000000000000000;;	        cp "$tempdir/${node_names[$i]}-node-key.pem" "$POOL_PATH/kubernetes/certs"
0000000000000000000000000000000000000000;;	        WORKER_IP=${NODE_IPS[$i]} openssl req -new -key $tempdir/${node_names[$i]}-node-key.pem -out $tempdir/${node_names[$i]}-node.csr -subj "/CN=${node_names[$i]}" -config  cluster/libvirt-coreos/node-openssl.cnf 2>/dev/null
0000000000000000000000000000000000000000;;	        WORKER_IP=${NODE_IPS[$i]} openssl x509 -req -in $tempdir/${node_names[$i]}-node.csr -CA "${CA_CERT}" -CAkey "${CA_KEY}" -CAcreateserial -out $tempdir/${node_names[$i]}-node.pem -days 365 -extensions v3_req -extfile  cluster/libvirt-coreos/node-openssl.cnf 2>/dev/null
0000000000000000000000000000000000000000;;	        cp "$tempdir/${node_names[$i]}-node.pem" "$POOL_PATH/kubernetes/certs"
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	    echo "TLS assets generated..."
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#Setup registry proxy
0000000000000000000000000000000000000000;;	function setup_registry_proxy {
0000000000000000000000000000000000000000;;	  if [[ "$ENABLE_CLUSTER_REGISTRY" == "true" ]]; then
0000000000000000000000000000000000000000;;	    cp "./cluster/saltbase/salt/kube-registry-proxy/kube-registry-proxy.yaml" "$POOL_PATH/kubernetes/manifests"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Verify prereqs on host machine
0000000000000000000000000000000000000000;;	function verify-prereqs {
0000000000000000000000000000000000000000;;	  if ! which virsh >/dev/null; then
0000000000000000000000000000000000000000;;	      echo "Can't find virsh in PATH, please fix and retry." >&2
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if ! virsh nodeinfo >/dev/null; then
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [[ "$(</sys/kernel/mm/ksm/run)" -ne "1" ]]; then
0000000000000000000000000000000000000000;;	      echo "KSM is not enabled" >&2
0000000000000000000000000000000000000000;;	      echo "Enabling it would reduce the memory footprint of large clusters" >&2
0000000000000000000000000000000000000000;;	      if [[ -t 0 ]]; then
0000000000000000000000000000000000000000;;	          read -t 5 -n 1 -p "Do you want to enable KSM (requires root password) (y/n)? " answer
0000000000000000000000000000000000000000;;	          echo ""
0000000000000000000000000000000000000000;;	          if [[ "$answer" == 'y' ]]; then
0000000000000000000000000000000000000000;;	              su -c 'echo 1 > /sys/kernel/mm/ksm/run'
0000000000000000000000000000000000000000;;	          fi
0000000000000000000000000000000000000000;;	      else
0000000000000000000000000000000000000000;;	        echo "You can enable it with (as root):" >&2
0000000000000000000000000000000000000000;;	        echo "" >&2
0000000000000000000000000000000000000000;;	        echo "  echo 1 > /sys/kernel/mm/ksm/run" >&2
0000000000000000000000000000000000000000;;	        echo "" >&2
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Destroy the libvirt storage pool and all the images inside
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# If 'keep_base_image' is passed as first parameter,
0000000000000000000000000000000000000000;;	# the base image is kept, as well as the storage pool.
0000000000000000000000000000000000000000;;	# All the other images are deleted.
0000000000000000000000000000000000000000;;	function destroy-pool {
0000000000000000000000000000000000000000;;	  virsh pool-info $POOL >/dev/null 2>&1 || return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  rm -rf "$POOL_PATH"/kubernetes/*
0000000000000000000000000000000000000000;;	  rm -rf "$POOL_PATH"/kubernetes_config*/*
0000000000000000000000000000000000000000;;	  local vol
0000000000000000000000000000000000000000;;	  virsh vol-list $POOL | awk 'NR>2 && !/^$/ && $1 ~ /^kubernetes/ {print $1}' | \
0000000000000000000000000000000000000000;;	      while read vol; do
0000000000000000000000000000000000000000;;	        virsh vol-delete $vol --pool $POOL
0000000000000000000000000000000000000000;;	      done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  [[ "$1" == 'keep_base_image' ]] && return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  set +e
0000000000000000000000000000000000000000;;	  virsh vol-delete coreos_base.img --pool $POOL
0000000000000000000000000000000000000000;;	  virsh pool-destroy $POOL
0000000000000000000000000000000000000000;;	  rmdir "$POOL_PATH"
0000000000000000000000000000000000000000;;	  set -e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Creates the libvirt storage pool and populate it with
0000000000000000000000000000000000000000;;	# - the CoreOS base image
0000000000000000000000000000000000000000;;	# - the kubernetes binaries
0000000000000000000000000000000000000000;;	function initialize-pool {
0000000000000000000000000000000000000000;;	  mkdir -p "$POOL_PATH"
0000000000000000000000000000000000000000;;	  if ! virsh pool-info $POOL >/dev/null 2>&1; then
0000000000000000000000000000000000000000;;	      virsh pool-create-as $POOL dir --target "$POOL_PATH"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  wget -N -P "$ROOT" https://${COREOS_CHANNEL:-alpha}.release.core-os.net/amd64-usr/current/coreos_production_qemu_image.img.bz2
0000000000000000000000000000000000000000;;	  if [[ "$ROOT/coreos_production_qemu_image.img.bz2" -nt "$POOL_PATH/coreos_base.img" ]]; then
0000000000000000000000000000000000000000;;	      bunzip2 -f -k "$ROOT/coreos_production_qemu_image.img.bz2"
0000000000000000000000000000000000000000;;	      virsh vol-delete coreos_base.img --pool $POOL 2> /dev/null || true
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if ! virsh vol-list $POOL | grep -q coreos_base.img; then
0000000000000000000000000000000000000000;;	      virsh vol-create-as $POOL coreos_base.img 10G --format qcow2
0000000000000000000000000000000000000000;;	      virsh vol-upload coreos_base.img "$ROOT/coreos_production_qemu_image.img" --pool $POOL
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  mkdir -p "$POOL_PATH/kubernetes"
0000000000000000000000000000000000000000;;	  kube-push-internal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  mkdir -p "$POOL_PATH/kubernetes/manifests"
0000000000000000000000000000000000000000;;	  if [[ "$ENABLE_NODE_LOGGING" == "true" ]]; then
0000000000000000000000000000000000000000;;	      if [[ "$LOGGING_DESTINATION" == "elasticsearch" ]]; then
0000000000000000000000000000000000000000;;	          cp "$KUBE_ROOT/cluster/saltbase/salt/fluentd-es/fluentd-es.manifest" "$POOL_PATH/kubernetes/manifests"
0000000000000000000000000000000000000000;;	      elif [[ "$LOGGING_DESTINATION" == "gcp" ]]; then
0000000000000000000000000000000000000000;;	          cp "$KUBE_ROOT/cluster/saltbase/salt/fluentd-gcp/fluentd-gcp.manifest" "$POOL_PATH/kubernetes/manifests"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  mkdir -p "$POOL_PATH/kubernetes/addons"
0000000000000000000000000000000000000000;;	  if [[ "$ENABLE_CLUSTER_DNS" == "true" ]]; then
0000000000000000000000000000000000000000;;	      render-template "$ROOT/namespace.yaml" > "$POOL_PATH/kubernetes/addons/namespace.yaml"
0000000000000000000000000000000000000000;;	      render-template "$ROOT/kubedns-svc.yaml" > "$POOL_PATH/kubernetes/addons/kubedns-svc.yaml"
0000000000000000000000000000000000000000;;	      render-template "$ROOT/kubedns-controller.yaml"  > "$POOL_PATH/kubernetes/addons/kubedns-controller.yaml"
0000000000000000000000000000000000000000;;	      render-template "$ROOT/kubedns-sa.yaml"  > "$POOL_PATH/kubernetes/addons/kubedns-sa.yaml"
0000000000000000000000000000000000000000;;	      render-template "$ROOT/kubedns-cm.yaml"  > "$POOL_PATH/kubernetes/addons/kubedns-cm.yaml"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  virsh pool-refresh $POOL
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function destroy-network {
0000000000000000000000000000000000000000;;	  set +e
0000000000000000000000000000000000000000;;	  virsh net-destroy kubernetes_global
0000000000000000000000000000000000000000;;	  virsh net-destroy kubernetes_pods
0000000000000000000000000000000000000000;;	  set -e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function initialize-network {
0000000000000000000000000000000000000000;;	  virsh net-create "$ROOT/network_kubernetes_global.xml"
0000000000000000000000000000000000000000;;	  virsh net-create "$ROOT/network_kubernetes_pods.xml"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function render-template {
0000000000000000000000000000000000000000;;	  eval "echo \"$(cat $1)\""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function wait-cluster-readiness {
0000000000000000000000000000000000000000;;	  echo "Wait for cluster readiness"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local timeout=120
0000000000000000000000000000000000000000;;	  while [[ $timeout -ne 0 ]]; do
0000000000000000000000000000000000000000;;	    nb_ready_nodes=$(kubectl get nodes -o go-template="{{range.items}}{{range.status.conditions}}{{.type}}{{end}}:{{end}}" 2>/dev/null | tr ':' '\n' | grep -c Ready || true)
0000000000000000000000000000000000000000;;	    echo "Nb ready nodes: $nb_ready_nodes / $NUM_NODES"
0000000000000000000000000000000000000000;;	    if [[ "$nb_ready_nodes" -eq "$NUM_NODES" ]]; then
0000000000000000000000000000000000000000;;	      return 0
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    timeout=$(($timeout-1))
0000000000000000000000000000000000000000;;	    sleep .5
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  return 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Instantiate a kubernetes cluster
0000000000000000000000000000000000000000;;	function kube-up {
0000000000000000000000000000000000000000;;	  detect-master
0000000000000000000000000000000000000000;;	  detect-nodes
0000000000000000000000000000000000000000;;	  initialize-pool keep_base_image
0000000000000000000000000000000000000000;;	  generate_certs "${NODE_NAMES[@]}"
0000000000000000000000000000000000000000;;	  setup_registry_proxy
0000000000000000000000000000000000000000;;	  initialize-network
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  readonly ssh_keys="$(cat ~/.ssh/*.pub | sed 's/^/  - /')"
0000000000000000000000000000000000000000;;	  readonly kubernetes_dir="$POOL_PATH/kubernetes"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local i
0000000000000000000000000000000000000000;;	  for (( i = 0 ; i <= $NUM_NODES ; i++ )); do
0000000000000000000000000000000000000000;;	    if [[ $i -eq $NUM_NODES ]]; then
0000000000000000000000000000000000000000;;	        etcd2_initial_cluster[$i]="${MASTER_NAME}=http://${MASTER_IP}:2380"
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	        etcd2_initial_cluster[$i]="${NODE_NAMES[$i]}=http://${NODE_IPS[$i]}:2380"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  etcd2_initial_cluster=$(join , "${etcd2_initial_cluster[@]}")
0000000000000000000000000000000000000000;;	  readonly machines=$(join , "${KUBE_NODE_IP_ADDRESSES[@]}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for (( i = 0 ; i <= $NUM_NODES ; i++ )); do
0000000000000000000000000000000000000000;;	    if [[ $i -eq $NUM_NODES ]]; then
0000000000000000000000000000000000000000;;	        type=master
0000000000000000000000000000000000000000;;	        name=$MASTER_NAME
0000000000000000000000000000000000000000;;	        public_ip=$MASTER_IP
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      type=node-$(printf "%02d" $i)
0000000000000000000000000000000000000000;;	      name=${NODE_NAMES[$i]}
0000000000000000000000000000000000000000;;	      public_ip=${NODE_IPS[$i]}
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    image=$name.img
0000000000000000000000000000000000000000;;	    config=kubernetes_config_$type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    virsh vol-create-as $POOL $image 10G --format qcow2 --backing-vol coreos_base.img --backing-vol-format qcow2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    mkdir -p "$POOL_PATH/$config/openstack/latest"
0000000000000000000000000000000000000000;;	    render-template "$ROOT/user_data.yml" > "$POOL_PATH/$config/openstack/latest/user_data"
0000000000000000000000000000000000000000;;	    virsh pool-refresh $POOL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    domain_xml=$(mktemp)
0000000000000000000000000000000000000000;;	    render-template $ROOT/coreos.xml > $domain_xml
0000000000000000000000000000000000000000;;	    virsh create $domain_xml
0000000000000000000000000000000000000000;;	    rm $domain_xml
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  export KUBE_SERVER="http://192.168.10.1:8080"
0000000000000000000000000000000000000000;;	  export CONTEXT="libvirt-coreos"
0000000000000000000000000000000000000000;;	  create-kubeconfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  wait-cluster-readiness
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "Kubernetes cluster is running. The master is running at:"
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo "  http://${KUBE_MASTER_IP}:8080"
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo "You can control the Kubernetes cluster with: 'kubectl'"
0000000000000000000000000000000000000000;;	  echo "You can connect on the master with: 'ssh core@${KUBE_MASTER_IP}'"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  wait-registry-readiness
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function create_registry_rc() {
0000000000000000000000000000000000000000;;	  echo " Create registry replication controller"
0000000000000000000000000000000000000000;;	  kubectl create -f $ROOT/registry-rc.yaml
0000000000000000000000000000000000000000;;	  local timeout=120
0000000000000000000000000000000000000000;;	  while [[ $timeout -ne 0 ]]; do
0000000000000000000000000000000000000000;;	    phase=$(kubectl get pods -n kube-system -lk8s-app=kube-registry --output='jsonpath={.items..status.phase}')
0000000000000000000000000000000000000000;;	    if [ "$phase" = "Running" ]; then
0000000000000000000000000000000000000000;;	      return 0
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    timeout=$(($timeout-1))
0000000000000000000000000000000000000000;;	    sleep .5
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function create_registry_svc() {
0000000000000000000000000000000000000000;;	  echo " Create registry service"
0000000000000000000000000000000000000000;;	  kubectl create -f "${KUBE_ROOT}/cluster/addons/registry/registry-svc.yaml"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function wait-registry-readiness() {
0000000000000000000000000000000000000000;;	  if [[ "$ENABLE_CLUSTER_REGISTRY" != "true" ]]; then
0000000000000000000000000000000000000000;;	    return 0
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  echo "Wait for registry readiness..."
0000000000000000000000000000000000000000;;	  local timeout=120
0000000000000000000000000000000000000000;;	  while [[ $timeout -ne 0 ]]; do
0000000000000000000000000000000000000000;;	    phase=$(kubectl get namespaces --output=jsonpath='{.items[?(@.metadata.name=="kube-system")].status.phase}')
0000000000000000000000000000000000000000;;	    if [ "$phase" = "Active" ]; then
0000000000000000000000000000000000000000;;	      create_registry_rc
0000000000000000000000000000000000000000;;	      create_registry_svc
0000000000000000000000000000000000000000;;	      return 0
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    echo "waiting for namespace kube-system"
0000000000000000000000000000000000000000;;	    timeout=$(($timeout-1))
0000000000000000000000000000000000000000;;	    sleep .5
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Delete a kubernetes cluster
0000000000000000000000000000000000000000;;	function kube-down {
0000000000000000000000000000000000000000;;	  virsh list | awk 'NR>2 && !/^$/ && $2 ~ /^kubernetes/ {print $2}' | \
0000000000000000000000000000000000000000;;	      while read dom; do
0000000000000000000000000000000000000000;;	        virsh destroy $dom
0000000000000000000000000000000000000000;;	      done
0000000000000000000000000000000000000000;;	  destroy-pool keep_base_image
0000000000000000000000000000000000000000;;	  destroy-network
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# The kubernetes binaries are pushed to a host directory which is exposed to the VM
0000000000000000000000000000000000000000;;	function upload-server-tars {
0000000000000000000000000000000000000000;;	  tar -x -C "$POOL_PATH/kubernetes" -f "$SERVER_BINARY_TAR" kubernetes
0000000000000000000000000000000000000000;;	  rm -rf "$POOL_PATH/kubernetes/bin"
0000000000000000000000000000000000000000;;	  mv "$POOL_PATH/kubernetes/kubernetes/server/bin" "$POOL_PATH/kubernetes/bin"
0000000000000000000000000000000000000000;;	  chmod -R 755 "$POOL_PATH/kubernetes/bin"
0000000000000000000000000000000000000000;;	  rm -fr "$POOL_PATH/kubernetes/kubernetes"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Update a kubernetes cluster with latest source
0000000000000000000000000000000000000000;;	function kube-push {
0000000000000000000000000000000000000000;;	  kube-push-internal
0000000000000000000000000000000000000000;;	  ssh-to-node "$MASTER_NAME" "sudo systemctl restart kube-apiserver kube-controller-manager kube-scheduler"
0000000000000000000000000000000000000000;;	  for ((i=0; i < NUM_NODES; i++)); do
0000000000000000000000000000000000000000;;	    ssh-to-node "${NODE_NAMES[$i]}" "sudo systemctl restart kubelet kube-proxy"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  wait-cluster-readiness
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube-push-internal {
0000000000000000000000000000000000000000;;	  case "${KUBE_PUSH:-release}" in
0000000000000000000000000000000000000000;;	    release)
0000000000000000000000000000000000000000;;	      kube-push-release;;
0000000000000000000000000000000000000000;;	    local)
0000000000000000000000000000000000000000;;	      kube-push-local;;
0000000000000000000000000000000000000000;;	    *)
0000000000000000000000000000000000000000;;	      echo "The only known push methods are \"release\" to use the release tarball or \"local\" to use the binaries built by make. KUBE_PUSH is set \"$KUBE_PUSH\"" >&2
0000000000000000000000000000000000000000;;	      return 1;;
0000000000000000000000000000000000000000;;	  esac
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube-push-release {
0000000000000000000000000000000000000000;;	  find-release-tars
0000000000000000000000000000000000000000;;	  upload-server-tars
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube-push-local {
0000000000000000000000000000000000000000;;	  rm -rf "$POOL_PATH/kubernetes/bin/*"
0000000000000000000000000000000000000000;;	  mkdir -p "$POOL_PATH/kubernetes/bin"
0000000000000000000000000000000000000000;;	  cp "${KUBE_ROOT}/_output/local/go/bin"/* "$POOL_PATH/kubernetes/bin"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Execute prior to running tests to build a release if required for env
0000000000000000000000000000000000000000;;	function test-build-release {
0000000000000000000000000000000000000000;;	  echo "TODO"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Execute prior to running tests to initialize required structure
0000000000000000000000000000000000000000;;	function test-setup {
0000000000000000000000000000000000000000;;	  "${KUBE_ROOT}/cluster/kube-up.sh"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Execute after running tests to perform any required clean-up
0000000000000000000000000000000000000000;;	function test-teardown {
0000000000000000000000000000000000000000;;	  kube-down
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# SSH to a node by name or IP ($1) and run a command ($2).
0000000000000000000000000000000000000000;;	function ssh-to-node {
0000000000000000000000000000000000000000;;	  local node="$1"
0000000000000000000000000000000000000000;;	  local cmd="$2"
0000000000000000000000000000000000000000;;	  local machine
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "$node" == "$MASTER_IP" ]] || [[ "$node" =~ ^"$NODE_IP_BASE" ]]; then
0000000000000000000000000000000000000000;;	      machine="$node"
0000000000000000000000000000000000000000;;	  elif [[ "$node" == "$MASTER_NAME" ]]; then
0000000000000000000000000000000000000000;;	      machine="$MASTER_IP"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    for ((i=0; i < NUM_NODES; i++)); do
0000000000000000000000000000000000000000;;	        if [[ "$node" == "${NODE_NAMES[$i]}" ]]; then
0000000000000000000000000000000000000000;;	            machine="${NODE_IPS[$i]}"
0000000000000000000000000000000000000000;;	            break
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [[ -z "$machine" ]]; then
0000000000000000000000000000000000000000;;	      echo "$node is an unknown machine to ssh to" >&2
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  ssh -o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ControlMaster=no "core@$machine" "$cmd"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Perform preparations required to run e2e tests
0000000000000000000000000000000000000000;;	function prepare-e2e() {
0000000000000000000000000000000000000000;;	    echo "libvirt-coreos doesn't need special preparations for e2e tests" 1>&2
0000000000000000000000000000000000000000;;	}
