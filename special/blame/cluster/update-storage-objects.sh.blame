0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2015 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Script to update etcd objects as per the latest API Version.
0000000000000000000000000000000000000000;;	# This just reads all objects and then writes them back as is to ensure that
0000000000000000000000000000000000000000;;	# they are written using the latest API version.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Steps to use this script to upgrade the cluster to a new version:
0000000000000000000000000000000000000000;;	# https://github.com/kubernetes/kubernetes/blob/master/docs/cluster_management.md#updgrading-to-a-different-api-version
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	set -o errexit
0000000000000000000000000000000000000000;;	set -o nounset
0000000000000000000000000000000000000000;;	set -o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_ROOT=$(dirname "${BASH_SOURCE}")/..
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/hack/lib/init.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBECTL="${KUBE_OUTPUT_HOSTBIN}/kubectl"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# List of resources to be updated.
0000000000000000000000000000000000000000;;	# TODO: Get this list of resources from server once
0000000000000000000000000000000000000000;;	# http://issue.k8s.io/2057 is fixed.
0000000000000000000000000000000000000000;;	declare -a resources=(
0000000000000000000000000000000000000000;;	    "endpoints"
0000000000000000000000000000000000000000;;	    "events"
0000000000000000000000000000000000000000;;	    "limitranges"
0000000000000000000000000000000000000000;;	    "namespaces"
0000000000000000000000000000000000000000;;	    "nodes"
0000000000000000000000000000000000000000;;	    "pods"
0000000000000000000000000000000000000000;;	    "persistentvolumes"
0000000000000000000000000000000000000000;;	    "persistentvolumeclaims"
0000000000000000000000000000000000000000;;	    "replicationcontrollers"
0000000000000000000000000000000000000000;;	    "resourcequotas"
0000000000000000000000000000000000000000;;	    "secrets"
0000000000000000000000000000000000000000;;	    "services"
0000000000000000000000000000000000000000;;	    "jobs"
0000000000000000000000000000000000000000;;	    "horizontalpodautoscalers"
0000000000000000000000000000000000000000;;	    "storageclasses"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Find all the namespaces.
0000000000000000000000000000000000000000;;	namespaces=( $("${KUBECTL}" get namespaces -o go-template="{{range.items}}{{.metadata.name}} {{end}}"))
0000000000000000000000000000000000000000;;	if [ -z "${namespaces:-}" ]
0000000000000000000000000000000000000000;;	then
0000000000000000000000000000000000000000;;	  echo "Unexpected: No namespace found. Nothing to do."
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	all_failed=1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	for resource in "${resources[@]}"
0000000000000000000000000000000000000000;;	do
0000000000000000000000000000000000000000;;	  for namespace in "${namespaces[@]}"
0000000000000000000000000000000000000000;;	  do
0000000000000000000000000000000000000000;;	    # If get fails, assume it's because the resource hasn't been installed in the apiserver.
0000000000000000000000000000000000000000;;	    # TODO hopefully we can remove this once we use dynamic discovery of gettable/updateable
0000000000000000000000000000000000000000;;	    # resources.
0000000000000000000000000000000000000000;;	    set +e
0000000000000000000000000000000000000000;;	    instances=( $("${KUBECTL}" get "${resource}" --namespace="${namespace}" -o go-template="{{range.items}}{{.metadata.name}} {{end}}"))
0000000000000000000000000000000000000000;;	    result=$?
0000000000000000000000000000000000000000;;	    set -e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if [[ "${all_failed}" -eq 1 && "${result}" -eq 0 ]]; then
0000000000000000000000000000000000000000;;	      all_failed=0
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Nothing to do if there is no instance of that resource.
0000000000000000000000000000000000000000;;	    if [[ -z "${instances:-}" ]]
0000000000000000000000000000000000000000;;	    then
0000000000000000000000000000000000000000;;	      continue
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    for instance in "${instances[@]}"
0000000000000000000000000000000000000000;;	    do
0000000000000000000000000000000000000000;;	      # Read and then write it back as is.
0000000000000000000000000000000000000000;;	      # Update can fail if the object was updated after we fetched the
0000000000000000000000000000000000000000;;	      # object, but before we could update it. We, hence, try the update
0000000000000000000000000000000000000000;;	      # operation multiple times. But 5 continuous failures indicate some other
0000000000000000000000000000000000000000;;	      # problem.
0000000000000000000000000000000000000000;;	      success=0
0000000000000000000000000000000000000000;;	      for (( tries=0; tries<5; ++tries ))
0000000000000000000000000000000000000000;;	      do
0000000000000000000000000000000000000000;;	        filename="/tmp/k8s-${namespace}-${resource}-${instance}.json"
0000000000000000000000000000000000000000;;	        ( "${KUBECTL}" get "${resource}" "${instance}" --namespace="${namespace}" -o json > "${filename}" ) || true
0000000000000000000000000000000000000000;;	        if [[ ! -s "${filename}" ]]
0000000000000000000000000000000000000000;;	        then
0000000000000000000000000000000000000000;;	          # This happens when the instance has been deleted. We can hence ignore
0000000000000000000000000000000000000000;;	          # this instance.
0000000000000000000000000000000000000000;;	          echo "Looks like ${instance} got deleted. Ignoring it"
0000000000000000000000000000000000000000;;	          continue
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	        output=$("${KUBECTL}" replace -f "${filename}" --namespace="${namespace}") || true
0000000000000000000000000000000000000000;;	        rm "${filename}"
0000000000000000000000000000000000000000;;	        if [ -n "${output:-}" ]
0000000000000000000000000000000000000000;;	        then
0000000000000000000000000000000000000000;;	          success=1
0000000000000000000000000000000000000000;;	          break
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	      done
0000000000000000000000000000000000000000;;	      if [[ "${success}" -eq 0 ]]
0000000000000000000000000000000000000000;;	      then
0000000000000000000000000000000000000000;;	        echo "Error: failed to update ${resource}/${instance} in ${namespace} namespace after 5 tries"
0000000000000000000000000000000000000000;;	        exit 1
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	    if [[ "${resource}" == "namespaces" ]] || [[ "${resource}" == "nodes" ]]
0000000000000000000000000000000000000000;;	    then
0000000000000000000000000000000000000000;;	      # These resources are namespace agnostic. No need to update them for every
0000000000000000000000000000000000000000;;	      # namespace.
0000000000000000000000000000000000000000;;	      break
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "${all_failed}" -eq 1 ]]; then
0000000000000000000000000000000000000000;;	  echo "kubectl get failed for all resources"
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo "All objects updated successfully!!"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	exit 0
