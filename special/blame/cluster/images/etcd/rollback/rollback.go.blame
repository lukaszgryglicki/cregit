0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
8e0baad43ffa22210a0a62f59380b0698c2962cf;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Uncomment when you want to rollback to 2.2.1 version.
0000000000000000000000000000000000000000;;		oldwal "k8s.io/kubernetes/third_party/forked/etcd221/wal"
0000000000000000000000000000000000000000;;		// Uncomment when you want to rollback to 2.3.7 version.
0000000000000000000000000000000000000000;;		// oldwal "k8s.io/kubernetes/third_party/forked/etcd237/wal"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver"
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/membership"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/mvcc/backend"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/mvcc/mvccpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/pbutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/snap"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/store"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/wal"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/wal/walpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/go-semver/semver"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const rollbackVersion = "2.2.0"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		migrateDatadir = flag.String("data-dir", "", "Path to the data directory")
0000000000000000000000000000000000000000;;		ttl            = flag.Duration("ttl", time.Hour, "TTL of event keys (default 1 hour)")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;		if len(*migrateDatadir) == 0 {
0000000000000000000000000000000000000000;;			glog.Fatal("need to set '--data-dir'")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dbpath := path.Join(*migrateDatadir, "member", "snap", "db")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// etcd3 store backend. We will use it to parse v3 data files and extract information.
0000000000000000000000000000000000000000;;		be := backend.NewDefaultBackend(dbpath)
0000000000000000000000000000000000000000;;		tx := be.BatchTx()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// etcd2 store backend. We will use v3 data to update this and then save snapshot to disk.
0000000000000000000000000000000000000000;;		st := store.New(etcdserver.StoreClusterPrefix, etcdserver.StoreKeysPrefix)
0000000000000000000000000000000000000000;;		expireTime := time.Now().Add(*ttl)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		err := tx.UnsafeForEach([]byte("key"), func(k, v []byte) error {
0000000000000000000000000000000000000000;;			kv := &mvccpb.KeyValue{}
0000000000000000000000000000000000000000;;			kv.Unmarshal(v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// This is compact key.
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(string(kv.Key), "/") {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ttlOpt := store.TTLOptionSet{}
0000000000000000000000000000000000000000;;			if kv.Lease != 0 {
0000000000000000000000000000000000000000;;				ttlOpt = store.TTLOptionSet{ExpireTime: expireTime}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !isTombstone(k) {
0000000000000000000000000000000000000000;;				sk := path.Join(strings.Trim(etcdserver.StoreKeysPrefix, "/"), string(kv.Key))
0000000000000000000000000000000000000000;;				_, err := st.Set(sk, false, string(kv.Value), ttlOpt)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				st.Delete(string(kv.Key), false, false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := traverseAndDeleteEmptyDir(st, "/"); err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// rebuild cluster state.
0000000000000000000000000000000000000000;;		metadata, hardstate, oldSt, err := rebuild(*migrateDatadir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// In the following, it's low level logic that saves metadata and data into v2 snapshot.
0000000000000000000000000000000000000000;;		backupPath := *migrateDatadir + ".rollback.backup"
0000000000000000000000000000000000000000;;		if err := os.Rename(*migrateDatadir, backupPath); err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(path.Join(*migrateDatadir, "member", "snap"), 0700); err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		walDir := path.Join(*migrateDatadir, "member", "wal")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w, err := oldwal.Create(walDir, metadata)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = w.SaveSnapshot(walpb.Snapshot{Index: hardstate.Commit, Term: hardstate.Term})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		event, err := oldSt.Get(etcdserver.StoreClusterPrefix, true, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// nodes (members info) for ConfState
0000000000000000000000000000000000000000;;		nodes := []uint64{}
0000000000000000000000000000000000000000;;		traverseMetadata(event.Node, func(n *store.NodeExtern) {
0000000000000000000000000000000000000000;;			if n.Key != etcdserver.StoreClusterPrefix {
0000000000000000000000000000000000000000;;				// update store metadata
0000000000000000000000000000000000000000;;				v := ""
0000000000000000000000000000000000000000;;				if !n.Dir {
0000000000000000000000000000000000000000;;					v = *n.Value
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if n.Key == path.Join(etcdserver.StoreClusterPrefix, "version") {
0000000000000000000000000000000000000000;;					v = rollbackVersion
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, err := st.Set(n.Key, n.Dir, v, store.TTLOptionSet{}); err != nil {
0000000000000000000000000000000000000000;;					glog.Fatal(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// update nodes
0000000000000000000000000000000000000000;;				fields := strings.Split(n.Key, "/")
0000000000000000000000000000000000000000;;				if len(fields) == 4 && fields[2] == "members" {
0000000000000000000000000000000000000000;;					nodeID, err := strconv.ParseUint(fields[3], 16, 64)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						glog.Fatalf("failed to parse member ID (%s): %v", fields[3], err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					nodes = append(nodes, nodeID)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err := st.Save()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		raftSnap := raftpb.Snapshot{
0000000000000000000000000000000000000000;;			Data: data,
0000000000000000000000000000000000000000;;			Metadata: raftpb.SnapshotMetadata{
0000000000000000000000000000000000000000;;				Index: hardstate.Commit,
0000000000000000000000000000000000000000;;				Term:  hardstate.Term,
0000000000000000000000000000000000000000;;				ConfState: raftpb.ConfState{
0000000000000000000000000000000000000000;;					Nodes: nodes,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		snapshotter := snap.New(path.Join(*migrateDatadir, "member", "snap"))
0000000000000000000000000000000000000000;;		if err := snapshotter.SaveSnap(raftSnap); err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Println("Finished successfully")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func traverseMetadata(head *store.NodeExtern, handleFunc func(*store.NodeExtern)) {
0000000000000000000000000000000000000000;;		q := []*store.NodeExtern{head}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for len(q) > 0 {
0000000000000000000000000000000000000000;;			n := q[0]
0000000000000000000000000000000000000000;;			q = q[1:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			handleFunc(n)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, next := range n.Nodes {
0000000000000000000000000000000000000000;;				q = append(q, next)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		revBytesLen       = 8 + 1 + 8
0000000000000000000000000000000000000000;;		markedRevBytesLen = revBytesLen + 1
0000000000000000000000000000000000000000;;		markBytePosition  = markedRevBytesLen - 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		markTombstone byte = 't'
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isTombstone(b []byte) bool {
0000000000000000000000000000000000000000;;		return len(b) == markedRevBytesLen && b[markBytePosition] == markTombstone
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func traverseAndDeleteEmptyDir(st store.Store, dir string) error {
0000000000000000000000000000000000000000;;		e, err := st.Get(dir, true, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(e.Node.Nodes) == 0 {
0000000000000000000000000000000000000000;;			st.Delete(dir, true, true)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, node := range e.Node.Nodes {
0000000000000000000000000000000000000000;;			if !node.Dir {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("key: %s", node.Key[len(etcdserver.StoreKeysPrefix):])
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				err := traverseAndDeleteEmptyDir(st, node.Key)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func rebuild(datadir string) ([]byte, *raftpb.HardState, store.Store, error) {
0000000000000000000000000000000000000000;;		waldir := path.Join(datadir, "member", "wal")
0000000000000000000000000000000000000000;;		snapdir := path.Join(datadir, "member", "snap")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ss := snap.New(snapdir)
0000000000000000000000000000000000000000;;		snapshot, err := ss.Load()
0000000000000000000000000000000000000000;;		if err != nil && err != snap.ErrNoSnapshot {
0000000000000000000000000000000000000000;;			return nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var walsnap walpb.Snapshot
0000000000000000000000000000000000000000;;		if snapshot != nil {
0000000000000000000000000000000000000000;;			walsnap.Index, walsnap.Term = snapshot.Metadata.Index, snapshot.Metadata.Term
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w, err := wal.OpenForRead(waldir, walsnap)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer w.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		meta, hardstate, ents, err := w.ReadAll()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		st := store.New(etcdserver.StoreClusterPrefix, etcdserver.StoreKeysPrefix)
0000000000000000000000000000000000000000;;		if snapshot != nil {
0000000000000000000000000000000000000000;;			err := st.Recovery(snapshot.Data)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cluster := membership.NewCluster("")
0000000000000000000000000000000000000000;;		cluster.SetStore(st)
0000000000000000000000000000000000000000;;		cluster.Recover(func(*semver.Version) {})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		applier := etcdserver.NewApplierV2(st, cluster)
0000000000000000000000000000000000000000;;		for _, ent := range ents {
0000000000000000000000000000000000000000;;			if ent.Type == raftpb.EntryConfChange {
0000000000000000000000000000000000000000;;				var cc raftpb.ConfChange
0000000000000000000000000000000000000000;;				pbutil.MustUnmarshal(&cc, ent.Data)
0000000000000000000000000000000000000000;;				switch cc.Type {
0000000000000000000000000000000000000000;;				case raftpb.ConfChangeAddNode:
0000000000000000000000000000000000000000;;					m := new(membership.Member)
0000000000000000000000000000000000000000;;					if err := json.Unmarshal(cc.Context, m); err != nil {
0000000000000000000000000000000000000000;;						return nil, nil, nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					cluster.AddMember(m)
0000000000000000000000000000000000000000;;				case raftpb.ConfChangeRemoveNode:
0000000000000000000000000000000000000000;;					id := types.ID(cc.NodeID)
0000000000000000000000000000000000000000;;					cluster.RemoveMember(id)
0000000000000000000000000000000000000000;;				case raftpb.ConfChangeUpdateNode:
0000000000000000000000000000000000000000;;					m := new(membership.Member)
0000000000000000000000000000000000000000;;					if err := json.Unmarshal(cc.Context, m); err != nil {
0000000000000000000000000000000000000000;;						return nil, nil, nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					cluster.UpdateRaftAttributes(m.ID, m.RaftAttributes)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var raftReq pb.InternalRaftRequest
0000000000000000000000000000000000000000;;			if !pbutil.MaybeUnmarshal(&raftReq, ent.Data) { // backward compatible
0000000000000000000000000000000000000000;;				var r pb.Request
0000000000000000000000000000000000000000;;				pbutil.MustUnmarshal(&r, ent.Data)
0000000000000000000000000000000000000000;;				applyRequest(&r, applier)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if raftReq.V2 != nil {
0000000000000000000000000000000000000000;;					req := raftReq.V2
0000000000000000000000000000000000000000;;					applyRequest(req, applier)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return meta, &hardstate, st, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toTTLOptions(r *pb.Request) store.TTLOptionSet {
0000000000000000000000000000000000000000;;		refresh, _ := pbutil.GetBool(r.Refresh)
0000000000000000000000000000000000000000;;		ttlOptions := store.TTLOptionSet{Refresh: refresh}
0000000000000000000000000000000000000000;;		if r.Expiration != 0 {
0000000000000000000000000000000000000000;;			ttlOptions.ExpireTime = time.Unix(0, r.Expiration)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ttlOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func applyRequest(r *pb.Request, applyV2 etcdserver.ApplierV2) {
0000000000000000000000000000000000000000;;		toTTLOptions(r)
0000000000000000000000000000000000000000;;		switch r.Method {
0000000000000000000000000000000000000000;;		case "PUT":
0000000000000000000000000000000000000000;;			applyV2.Put(r)
0000000000000000000000000000000000000000;;		case "DELETE":
0000000000000000000000000000000000000000;;			applyV2.Delete(r)
0000000000000000000000000000000000000000;;		case "POST", "QGET", "SYNC":
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			glog.Fatal("unknown command")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
