0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
c6c482998fcc61c262349a61799096965148e768;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		goflag "flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/prometheus/client_golang/prometheus"
0000000000000000000000000000000000000000;;		"github.com/prometheus/common/expfmt"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Initialize the prometheus instrumentation and client related flags.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		listenAddress        string
0000000000000000000000000000000000000000;;		metricsPath          string
0000000000000000000000000000000000000000;;		etcdVersionScrapeURI string
0000000000000000000000000000000000000000;;		etcdMetricsScrapeURI string
0000000000000000000000000000000000000000;;		scrapeTimeout        time.Duration
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func registerFlags(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		fs.StringVar(&listenAddress, "listen-address", "localhost:9101", "Address to listen on for serving prometheus metrics")
0000000000000000000000000000000000000000;;		fs.StringVar(&metricsPath, "metrics-path", "/metrics", "Path under which prometheus metrics are to be served")
0000000000000000000000000000000000000000;;		fs.StringVar(&etcdVersionScrapeURI, "etcd-version-scrape-uri", "http://localhost:2379/version", "URI to scrape etcd version info")
0000000000000000000000000000000000000000;;		fs.StringVar(&etcdMetricsScrapeURI, "etcd-metrics-scrape-uri", "http://localhost:2379/metrics", "URI to scrape etcd metrics")
0000000000000000000000000000000000000000;;		fs.DurationVar(&scrapeTimeout, "scrape-timeout", 15*time.Second, "Timeout for trying to get stats from etcd")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		namespace = "etcd" // For prefixing prometheus metrics
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Initialize prometheus metrics to be exported.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		etcdVersion = prometheus.NewGaugeVec(
0000000000000000000000000000000000000000;;			prometheus.GaugeOpts{
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Name:      "version_info",
0000000000000000000000000000000000000000;;				Help:      "Etcd server's binary version",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			[]string{"binary_version"})
0000000000000000000000000000000000000000;;		etcdGRPCRequestsTotal = prometheus.NewCounterVec(
0000000000000000000000000000000000000000;;			prometheus.CounterOpts{
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Name:      "grpc_requests_total",
0000000000000000000000000000000000000000;;				Help:      "Counter of received grpc requests, labeled by the grpc method and service names",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			[]string{"method", "service"})
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Struct for unmarshalling the json response from etcd's /version endpoint.
0000000000000000000000000000000000000000;;	type EtcdVersion struct {
0000000000000000000000000000000000000000;;		BinaryVersion  string `json:"etcdserver"`
0000000000000000000000000000000000000000;;		ClusterVersion string `json:"etcdcluster"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Function for fetching etcd version info and feeding it to the prometheus metric.
0000000000000000000000000000000000000000;;	func getVersion(lastSeenBinaryVersion *string) error {
0000000000000000000000000000000000000000;;		// Create the get request for the etcd version endpoint.
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("GET", etcdVersionScrapeURI, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to create GET request for etcd version: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Send the get request and receive a response.
0000000000000000000000000000000000000000;;		client := &http.Client{}
0000000000000000000000000000000000000000;;		resp, err := client.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to receive GET response for etcd version: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Obtain EtcdVersion from the JSON response.
0000000000000000000000000000000000000000;;		var version EtcdVersion
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(resp.Body).Decode(&version); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to decode etcd version JSON: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return without updating the version if it stayed the same since last time.
0000000000000000000000000000000000000000;;		if *lastSeenBinaryVersion == version.BinaryVersion {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete the metric for the previous version.
0000000000000000000000000000000000000000;;		if *lastSeenBinaryVersion != "" {
0000000000000000000000000000000000000000;;			deleted := etcdVersion.Delete(prometheus.Labels{"binary_version": *lastSeenBinaryVersion})
0000000000000000000000000000000000000000;;			if !deleted {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Failed to delete previous version's metric")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Record the new version in a metric.
0000000000000000000000000000000000000000;;		etcdVersion.With(prometheus.Labels{
0000000000000000000000000000000000000000;;			"binary_version": version.BinaryVersion,
0000000000000000000000000000000000000000;;		}).Set(0)
0000000000000000000000000000000000000000;;		*lastSeenBinaryVersion = version.BinaryVersion
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Periodically fetches etcd version info.
0000000000000000000000000000000000000000;;	func getVersionPeriodically(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		lastSeenBinaryVersion := ""
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if err := getVersion(&lastSeenBinaryVersion); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to fetch etcd version: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-stopCh:
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			case <-time.After(scrapeTimeout):
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Struct for storing labels for gRPC request types.
0000000000000000000000000000000000000000;;	type GRPCRequestLabels struct {
0000000000000000000000000000000000000000;;		Method  string
0000000000000000000000000000000000000000;;		Service string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Function for fetching etcd grpc request counts and feeding it to the prometheus metric.
0000000000000000000000000000000000000000;;	func getGRPCRequestCount(lastRecordedCount *map[GRPCRequestLabels]float64) error {
0000000000000000000000000000000000000000;;		// Create the get request for the etcd metrics endpoint.
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("GET", etcdMetricsScrapeURI, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to create GET request for etcd metrics: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Send the get request and receive a response.
0000000000000000000000000000000000000000;;		client := &http.Client{}
0000000000000000000000000000000000000000;;		resp, err := client.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to receive GET response for etcd metrics: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Parse the metrics in text format to a MetricFamily struct.
0000000000000000000000000000000000000000;;		var textParser expfmt.TextParser
0000000000000000000000000000000000000000;;		metricFamilies, err := textParser.TextToMetricFamilies(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to parse etcd metrics: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Look through the grpc requests metric family and update our promotheus metric.
0000000000000000000000000000000000000000;;		for _, metric := range metricFamilies["etcd_grpc_requests_total"].GetMetric() {
0000000000000000000000000000000000000000;;			var grpcRequestLabels GRPCRequestLabels
0000000000000000000000000000000000000000;;			for _, label := range metric.GetLabel() {
0000000000000000000000000000000000000000;;				if label.GetName() == "grpc_method" {
0000000000000000000000000000000000000000;;					grpcRequestLabels.Method = label.GetValue()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if label.GetName() == "grpc_service" {
0000000000000000000000000000000000000000;;					grpcRequestLabels.Service = label.GetValue()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if grpcRequestLabels.Method == "" || grpcRequestLabels.Service == "" {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Could not get value for grpc_method and/or grpc_service label")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get last recorded value and new value of the metric and update it suitably.
0000000000000000000000000000000000000000;;			previousMetricValue := 0.0
0000000000000000000000000000000000000000;;			if value, ok := (*lastRecordedCount)[grpcRequestLabels]; ok {
0000000000000000000000000000000000000000;;				previousMetricValue = value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newMetricValue := metric.GetCounter().GetValue()
0000000000000000000000000000000000000000;;			(*lastRecordedCount)[grpcRequestLabels] = newMetricValue
0000000000000000000000000000000000000000;;			if newMetricValue >= previousMetricValue {
0000000000000000000000000000000000000000;;				etcdGRPCRequestsTotal.With(prometheus.Labels{
0000000000000000000000000000000000000000;;					"method":  grpcRequestLabels.Method,
0000000000000000000000000000000000000000;;					"service": grpcRequestLabels.Service,
0000000000000000000000000000000000000000;;				}).Add(newMetricValue - previousMetricValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Function for periodically fetching etcd GRPC request counts.
0000000000000000000000000000000000000000;;	func getGRPCRequestCountPeriodically(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		// This map stores last recorded count for a given grpc request type.
0000000000000000000000000000000000000000;;		lastRecordedCount := make(map[GRPCRequestLabels]float64)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if err := getGRPCRequestCount(&lastRecordedCount); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to fetch etcd grpc request counts: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-stopCh:
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			case <-time.After(scrapeTimeout):
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		// Register the commandline flags passed to the tool.
0000000000000000000000000000000000000000;;		registerFlags(pflag.CommandLine)
0000000000000000000000000000000000000000;;		pflag.CommandLine.AddGoFlagSet(goflag.CommandLine)
0000000000000000000000000000000000000000;;		pflag.Parse()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Register the metrics we defined above with prometheus.
0000000000000000000000000000000000000000;;		prometheus.MustRegister(etcdVersion)
0000000000000000000000000000000000000000;;		prometheus.MustRegister(etcdGRPCRequestsTotal)
0000000000000000000000000000000000000000;;		prometheus.Unregister(prometheus.NewGoCollector())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spawn threads for periodically scraping etcd version metrics.
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;		go getVersionPeriodically(stopCh)
0000000000000000000000000000000000000000;;		go getGRPCRequestCountPeriodically(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Serve our metrics on listenAddress/metricsPath.
0000000000000000000000000000000000000000;;		glog.Infof("Listening on: %v", listenAddress)
0000000000000000000000000000000000000000;;		http.Handle(metricsPath, prometheus.UninstrumentedHandler())
0000000000000000000000000000000000000000;;		glog.Errorf("Stopped listening/serving metrics: %v", http.ListenAndServe(listenAddress, nil))
0000000000000000000000000000000000000000;;	}
