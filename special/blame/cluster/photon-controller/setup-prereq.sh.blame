0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2016 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This sets up a Photon Controller with the tenant, project, flavors
0000000000000000000000000000000000000000;;	# and image that are needed to deploy Kubernetes with kube-up.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# This is not meant to be used in production: it creates resource tickets
0000000000000000000000000000000000000000;;	# (quotas) that are arbitrary and not likely to work in your environment.
0000000000000000000000000000000000000000;;	# However, it may be a quick way to get your environment set up to try out
0000000000000000000000000000000000000000;;	# a Kubernetes installation.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# It uses the names for the tenant, project, and flavors as specified in the
0000000000000000000000000000000000000000;;	# config-common.sh file
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# If you want to do this by hand, this script is equivalent to the following
0000000000000000000000000000000000000000;;	# Photon Controller commands (assuming you haven't edited config-common.sh
0000000000000000000000000000000000000000;;	# to change the names)
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# photon target set https://192.0.2.2
0000000000000000000000000000000000000000;;	# photon tenant create kube-tenant
0000000000000000000000000000000000000000;;	# photon tenant set kube-tenant
0000000000000000000000000000000000000000;;	# photon resource-ticket create --tenant kube-tenant --name kube-resources --limits "vm.memory 1000 GB, vm 1000 COUNT"
0000000000000000000000000000000000000000;;	# photon project create --tenant kube-tenant --resource-ticket kube-resources --name kube-project --limits "vm.memory 1000 GB, vm 1000 COUNT"
0000000000000000000000000000000000000000;;	# photon project set kube-project
0000000000000000000000000000000000000000;;	# photon -n flavor create --name "kube-vm" --kind "vm" --cost "vm 1 COUNT, vm.cpu 1 COUNT, vm.memory 2 GB"
0000000000000000000000000000000000000000;;	# photon -n flavor create --name "kube-disk" --kind "ephemeral-disk" --cost "ephemeral-disk 1 COUNT"
0000000000000000000000000000000000000000;;	# photon image create kube.vmdk -n kube-image -i EAGER
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Note that the kube.vmdk can be downloaded as specified in the documentation.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	set -o errexit
0000000000000000000000000000000000000000;;	set -o nounset
0000000000000000000000000000000000000000;;	set -o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_ROOT=$(dirname "${BASH_SOURCE[0]}")/../..
0000000000000000000000000000000000000000;;	# shellcheck source=./util.sh
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/cluster/photon-controller/util.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function main {
0000000000000000000000000000000000000000;;	  verify-cmd-in-path photon
0000000000000000000000000000000000000000;;	  set-target
0000000000000000000000000000000000000000;;	  create-tenant
0000000000000000000000000000000000000000;;	  create-project
0000000000000000000000000000000000000000;;	  create-vm-flavor "${PHOTON_MASTER_FLAVOR}" "${SETUP_MASTER_FLAVOR_SPEC}"
0000000000000000000000000000000000000000;;	  if [ "${PHOTON_MASTER_FLAVOR}" != "${PHOTON_NODE_FLAVOR}" ]; then
0000000000000000000000000000000000000000;;	    create-vm-flavor "${PHOTON_NODE_FLAVOR}" "${SETUP_NODE_FLAVOR_SPEC}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  create-disk-flavor
0000000000000000000000000000000000000000;;	  create-image
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function parse-cmd-line {
0000000000000000000000000000000000000000;;	  PHOTON_TARGET=${1:-""}
0000000000000000000000000000000000000000;;	  PHOTON_VMDK=${2:-""}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "${PHOTON_TARGET}" = "" || "${PHOTON_VMDK}" = "" ]]; then
0000000000000000000000000000000000000000;;	    echo "Usage: setup-prereq <photon target> <path-to-kube-vmdk>"
0000000000000000000000000000000000000000;;	    echo "Target should be a URL like https://192.0.2.1"
0000000000000000000000000000000000000000;;	    echo ""
0000000000000000000000000000000000000000;;	    echo "This will create the following, based on the configuration in config-common.sh"
0000000000000000000000000000000000000000;;	    echo "    * A tenant named ${PHOTON_TENANT}"
0000000000000000000000000000000000000000;;	    echo "    * A project named ${PHOTON_PROJECT}"
0000000000000000000000000000000000000000;;	    echo "    * A VM flavor named ${PHOTON_MASTER_FLAVOR}"
0000000000000000000000000000000000000000;;	    echo "    * A disk flavor named ${PHOTON_DISK_FLAVOR}"
0000000000000000000000000000000000000000;;	    echo "It will also upload the Kube VMDK"
0000000000000000000000000000000000000000;;	    echo ""
0000000000000000000000000000000000000000;;	    echo "It creates the tenant with a resource ticket (quota) that may"
0000000000000000000000000000000000000000;;	    echo "be inappropriate for your environment. For a production"
0000000000000000000000000000000000000000;;	    echo "environment, you should configure these to match your"
0000000000000000000000000000000000000000;;	    echo "environment."
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "Photon Target: ${PHOTON_TARGET}"
0000000000000000000000000000000000000000;;	  echo "Photon VMDK: ${PHOTON_VMDK}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function set-target {
0000000000000000000000000000000000000000;;	  ${PHOTON} target set "${PHOTON_TARGET}" > /dev/null 2>&1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function create-tenant {
0000000000000000000000000000000000000000;;	  local rc=0
0000000000000000000000000000000000000000;;	  local output
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  ${PHOTON} tenant list | grep -q "\t${PHOTON_TENANT}$" > /dev/null 2>&1 || rc=$?
0000000000000000000000000000000000000000;;	  if [[ ${rc} -eq 0 ]]; then
0000000000000000000000000000000000000000;;	    echo "Tenant ${PHOTON_TENANT} already made, skipping"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    echo "Making tenant ${PHOTON_TENANT}"
0000000000000000000000000000000000000000;;	    rc=0
0000000000000000000000000000000000000000;;	    output=$(${PHOTON} tenant create "${PHOTON_TENANT}" 2>&1) || {
0000000000000000000000000000000000000000;;	      echo "ERROR: Could not create tenant \"${PHOTON_TENANT}\", exiting"
0000000000000000000000000000000000000000;;	      echo "Output from tenant creation:"
0000000000000000000000000000000000000000;;	      echo "${output}"
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  ${PHOTON} tenant set "${PHOTON_TENANT}" > /dev/null 2>&1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function create-project {
0000000000000000000000000000000000000000;;	  local rc=0
0000000000000000000000000000000000000000;;	  local output
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  ${PHOTON} project list | grep -q "\t${PHOTON_PROJECT}\t" > /dev/null 2>&1  || rc=$?
0000000000000000000000000000000000000000;;	  if [[ ${rc} -eq 0 ]]; then
0000000000000000000000000000000000000000;;	    echo "Project ${PHOTON_PROJECT} already made, skipping"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    echo "Making project ${PHOTON_PROJECT}"
0000000000000000000000000000000000000000;;	    rc=0
0000000000000000000000000000000000000000;;	    output=$(${PHOTON} resource-ticket create --tenant "${PHOTON_TENANT}" --name "${PHOTON_TENANT}-resources" --limits "${SETUP_TICKET_SPEC}" 2>&1) || {
0000000000000000000000000000000000000000;;	      echo "ERROR: Could not create resource ticket, exiting"
0000000000000000000000000000000000000000;;	      echo "Output from resource ticket creation:"
0000000000000000000000000000000000000000;;	      echo "${output}"
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    rc=0
0000000000000000000000000000000000000000;;	    output=$(${PHOTON} project create --tenant "${PHOTON_TENANT}" --resource-ticket "${PHOTON_TENANT}-resources" --name "${PHOTON_PROJECT}" --limits "${SETUP_PROJECT_SPEC}" 2>&1) || {
0000000000000000000000000000000000000000;;	      echo "ERROR: Could not create project \"${PHOTON_PROJECT}\", exiting"
0000000000000000000000000000000000000000;;	      echo "Output from project creation:"
0000000000000000000000000000000000000000;;	      echo "${output}"
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  ${PHOTON} project set "${PHOTON_PROJECT}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function create-vm-flavor {
0000000000000000000000000000000000000000;;	  local flavor_name=${1}
0000000000000000000000000000000000000000;;	  local flavor_spec=${2}
0000000000000000000000000000000000000000;;	  local rc=0
0000000000000000000000000000000000000000;;	  local output
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  ${PHOTON} flavor list | grep -q "\t${flavor_name}\t" > /dev/null 2>&1 || rc=$?
0000000000000000000000000000000000000000;;	  if [[ ${rc} -eq 0 ]]; then
0000000000000000000000000000000000000000;;	    check-flavor-ready "${flavor_name}"
0000000000000000000000000000000000000000;;	    echo "Flavor ${flavor_name} already made, skipping"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    echo "Making VM flavor ${flavor_name}"
0000000000000000000000000000000000000000;;	    rc=0
0000000000000000000000000000000000000000;;	    output=$(${PHOTON} -n flavor create --name "${flavor_name}" --kind "vm" --cost "${flavor_spec}" 2>&1) || {
0000000000000000000000000000000000000000;;	      echo "ERROR: Could not create vm flavor \"${flavor_name}\", exiting"
0000000000000000000000000000000000000000;;	      echo "Output from flavor creation:"
0000000000000000000000000000000000000000;;	      echo "${output}"
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function create-disk-flavor {
0000000000000000000000000000000000000000;;	  local rc=0
0000000000000000000000000000000000000000;;	  local output
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  ${PHOTON} flavor list | grep -q "\t${PHOTON_DISK_FLAVOR}\t" > /dev/null 2>&1  || rc=$?
0000000000000000000000000000000000000000;;	  if [[ ${rc} -eq 0 ]]; then
0000000000000000000000000000000000000000;;	    check-flavor-ready "${PHOTON_DISK_FLAVOR}"
0000000000000000000000000000000000000000;;	    echo "Flavor ${PHOTON_DISK_FLAVOR} already made, skipping"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    echo "Making disk flavor ${PHOTON_DISK_FLAVOR}"
0000000000000000000000000000000000000000;;	    rc=0
0000000000000000000000000000000000000000;;	    output=$(${PHOTON} -n flavor create --name "${PHOTON_DISK_FLAVOR}" --kind "ephemeral-disk" --cost "${SETUP_DISK_FLAVOR_SPEC}" 2>&1) || {
0000000000000000000000000000000000000000;;	      echo "ERROR: Could not create disk flavor \"${PHOTON_DISK_FLAVOR}\", exiting"
0000000000000000000000000000000000000000;;	      echo "Output from flavor creation:"
0000000000000000000000000000000000000000;;	      echo "${output}"
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function check-flavor-ready {
0000000000000000000000000000000000000000;;	  local flavor_name=${1}
0000000000000000000000000000000000000000;;	  local rc=0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local flavor_id
0000000000000000000000000000000000000000;;	  flavor_id=$(${PHOTON} flavor list | grep  "\t${flavor_name}\t" | awk '{print $1}') || {
0000000000000000000000000000000000000000;;	    echo "ERROR: Found ${flavor_name} but cannot find it's id"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  ${PHOTON} flavor show "${flavor_id}" | grep "\tREADY\$" > /dev/null 2>&1  || {
0000000000000000000000000000000000000000;;	    echo "ERROR: Flavor \"${flavor_name}\" already exists but is not READY. Please delete or fix it."
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function create-image {
0000000000000000000000000000000000000000;;	  local rc=0
0000000000000000000000000000000000000000;;	  local num_images
0000000000000000000000000000000000000000;;	  local output
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  ${PHOTON} image list | grep "\t${PHOTON_IMAGE}\t" | grep -q ERROR > /dev/null 2>&1 || rc=$?
0000000000000000000000000000000000000000;;	  if [[ ${rc} -eq 0 ]]; then
0000000000000000000000000000000000000000;;	    echo "Warning: You have at least one ${PHOTON_IMAGE} image in the ERROR state. You may want to investigate."
0000000000000000000000000000000000000000;;	    echo "Images in the ERROR state will be ignored."
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  rc=0
0000000000000000000000000000000000000000;;	  # We don't use grep -c because it exists non-zero when there are no matches, tell shellcheck
0000000000000000000000000000000000000000;;	  # shellcheck disable=SC2126 
0000000000000000000000000000000000000000;;	  num_images=$(${PHOTON} image list | grep "\t${PHOTON_IMAGE}\t" | grep READY | wc -l)
0000000000000000000000000000000000000000;;	  if [[ "${num_images}" -gt 1 ]]; then
0000000000000000000000000000000000000000;;	    echo "Warning: You have more than one good ${PHOTON_IMAGE} image. You may want to remove duplicates."
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  ${PHOTON} image list | grep "\t${PHOTON_IMAGE}\t" | grep -q READY > /dev/null 2>&1 || rc=$?
0000000000000000000000000000000000000000;;	  if [[ ${rc} -eq 0 ]]; then
0000000000000000000000000000000000000000;;	    echo "Image ${PHOTON_VMDK} already uploaded, skipping"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    echo "Uploading image ${PHOTON_VMDK}"
0000000000000000000000000000000000000000;;	    rc=0
0000000000000000000000000000000000000000;;	    output=$(${PHOTON} image create "${PHOTON_VMDK}" -n "${PHOTON_IMAGE}" -i EAGER 2>&1) || {
0000000000000000000000000000000000000000;;	      echo "ERROR: Could not upload image, exiting"
0000000000000000000000000000000000000000;;	      echo "Output from image create:"
0000000000000000000000000000000000000000;;	      echo "${output}"
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# We don't want silent pipeline failure: we check for failure
0000000000000000000000000000000000000000;;	set +o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	parse-cmd-line "$@"
0000000000000000000000000000000000000000;;	main
