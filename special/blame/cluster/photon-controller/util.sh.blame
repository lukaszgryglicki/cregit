0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2016 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	set -o errexit
0000000000000000000000000000000000000000;;	set -o nounset
0000000000000000000000000000000000000000;;	set -o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# A library of helper functions that each provider hosting Kubernetes must implement to use cluster/kube-*.sh scripts.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_ROOT=$(dirname "${BASH_SOURCE[0]}")/../..
0000000000000000000000000000000000000000;;	# shellcheck source=./config-common.sh
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/cluster/photon-controller/config-common.sh"
0000000000000000000000000000000000000000;;	# shellcheck source=./config-default.sh
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/cluster/photon-controller/${KUBE_CONFIG_FILE-"config-default.sh"}"
0000000000000000000000000000000000000000;;	# shellcheck source=../common.sh
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/cluster/common.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	readonly PHOTON="photon -n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Naming scheme for VMs (masters & nodes)
0000000000000000000000000000000000000000;;	readonly MASTER_NAME="${INSTANCE_PREFIX}-master"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# shell check claims this doesn't work because you can't use a variable in a brace
0000000000000000000000000000000000000000;;	# range. It does work because we're calling eval. 
0000000000000000000000000000000000000000;;	# shellcheck disable=SC2051 
0000000000000000000000000000000000000000;;	readonly NODE_NAMES=($(eval echo "${INSTANCE_PREFIX}"-node-{1.."${NUM_NODES}"}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#####################################################################
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Public API
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#####################################################################
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# detect-master will query Photon Controller for the Kubernetes master.
0000000000000000000000000000000000000000;;	# It assumes that the VM name for the master is unique.
0000000000000000000000000000000000000000;;	# It will set KUBE_MASTER_ID to be the VM ID of the master
0000000000000000000000000000000000000000;;	# It will set KUBE_MASTER_IP to be the IP address of the master
0000000000000000000000000000000000000000;;	# If the silent parameter is passed, it will not print when the master
0000000000000000000000000000000000000000;;	# is found: this is used internally just to find the MASTER
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function detect-master {
0000000000000000000000000000000000000000;;	  local silent=${1:-""}
0000000000000000000000000000000000000000;;	  local tenant_args="--tenant ${PHOTON_TENANT} --project ${PHOTON_PROJECT}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  KUBE_MASTER=${MASTER_NAME}
0000000000000000000000000000000000000000;;	  KUBE_MASTER_ID=${KUBE_MASTER_ID:-""}
0000000000000000000000000000000000000000;;	  KUBE_MASTER_IP=${KUBE_MASTER_IP:-""}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # We don't want silent failure: we check for failure
0000000000000000000000000000000000000000;;	  set +o pipefail
0000000000000000000000000000000000000000;;	  if [[ -z ${KUBE_MASTER_ID} ]]; then
0000000000000000000000000000000000000000;;	    KUBE_MASTER_ID=$(${PHOTON} vm list ${tenant_args} | grep $'\t'"kubernetes-master"$'\t' | awk '{print $1}')
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [[ -z ${KUBE_MASTER_ID} ]]; then
0000000000000000000000000000000000000000;;	    kube::log::error "Could not find Kubernetes master node ID. Make sure you've launched a cluster with kube-up.sh"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ -z "${KUBE_MASTER_IP-}" ]]; then
0000000000000000000000000000000000000000;;	      # Pick out the NICs that have a MAC address owned VMware (with OUI 00:0C:29)
0000000000000000000000000000000000000000;;	      # Make sure to ignore lines that have a network interface but no address
0000000000000000000000000000000000000000;;	    KUBE_MASTER_IP=$(${PHOTON} vm networks "${KUBE_MASTER_ID}" | grep -i $'\t'"00:0C:29" | grep -E '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' | head -1 | awk -F'\t' '{print $3}')
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [[ -z "${KUBE_MASTER_IP-}" ]]; then
0000000000000000000000000000000000000000;;	    kube::log::error "Could not find Kubernetes master node IP. Make sure you've launched a cluster with 'kube-up.sh'" >&2
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [[ -z ${silent} ]]; then
0000000000000000000000000000000000000000;;	    kube::log::status "Master: $KUBE_MASTER ($KUBE_MASTER_IP)"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  # Reset default set in common.sh
0000000000000000000000000000000000000000;;	  set -o pipefail
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# detect-nodes will query Photon Controller for the Kubernetes nodes
0000000000000000000000000000000000000000;;	# It assumes that the VM name for the nodes are unique.
0000000000000000000000000000000000000000;;	# It assumes that NODE_NAMES has been set
0000000000000000000000000000000000000000;;	# It will set KUBE_NODE_IP_ADDRESSES to be the VM IPs of the nodes
0000000000000000000000000000000000000000;;	# It will set the KUBE_NODE_IDS to be the VM IDs of the nodes
0000000000000000000000000000000000000000;;	# If the silent parameter is passed, it will not print when the nodes
0000000000000000000000000000000000000000;;	# are found: this is used internally just to find the MASTER
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function detect-nodes {
0000000000000000000000000000000000000000;;	  local silent=${1:-""}
0000000000000000000000000000000000000000;;	  local failure=0
0000000000000000000000000000000000000000;;	  local tenant_args="--tenant ${PHOTON_TENANT} --project ${PHOTON_PROJECT}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  KUBE_NODE_IP_ADDRESSES=()
0000000000000000000000000000000000000000;;	  KUBE_NODE_IDS=()
0000000000000000000000000000000000000000;;	  # We don't want silent failure: we check for failure
0000000000000000000000000000000000000000;;	  set +o pipefail
0000000000000000000000000000000000000000;;	  for (( i=0; i<${#NODE_NAMES[@]}; i++)); do
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    local node_id
0000000000000000000000000000000000000000;;	    node_id=$(${PHOTON} vm list ${tenant_args} | grep $'\t'"${NODE_NAMES[${i}]}"$'\t' | awk '{print $1}')
0000000000000000000000000000000000000000;;	    if [[ -z ${node_id} ]]; then
0000000000000000000000000000000000000000;;	      kube::log::error "Could not find ${NODE_NAMES[${i}]}"
0000000000000000000000000000000000000000;;	      failure=1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    KUBE_NODE_IDS+=("${node_id}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Pick out the NICs that have a MAC address owned VMware (with OUI 00:0C:29)
0000000000000000000000000000000000000000;;	    # Make sure to ignore lines that have a network interface but no address
0000000000000000000000000000000000000000;;	    node_ip=$(${PHOTON} vm networks "${node_id}" | grep -i $'\t'"00:0C:29" | grep -E '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' | head -1 | awk -F'\t' '{print $3}')
0000000000000000000000000000000000000000;;	    KUBE_NODE_IP_ADDRESSES+=("${node_ip}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if [[ -z ${silent} ]]; then
0000000000000000000000000000000000000000;;	      kube::log::status "Node: ${NODE_NAMES[${i}]} (${KUBE_NODE_IP_ADDRESSES[${i}]})"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ ${failure} -ne 0 ]]; then
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  # Reset default set in common.sh
0000000000000000000000000000000000000000;;	  set -o pipefail
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Get node names if they are not static.
0000000000000000000000000000000000000000;;	function detect-node-names {
0000000000000000000000000000000000000000;;	  echo "TODO: detect-node-names" 1>&2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Verifies that this computer has sufficient software installed
0000000000000000000000000000000000000000;;	# so that it can run the rest of the script.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function verify-prereqs {
0000000000000000000000000000000000000000;;	  verify-cmd-in-path photon
0000000000000000000000000000000000000000;;	  verify-cmd-in-path ssh
0000000000000000000000000000000000000000;;	  verify-cmd-in-path scp
0000000000000000000000000000000000000000;;	  verify-cmd-in-path ssh-add
0000000000000000000000000000000000000000;;	  verify-cmd-in-path openssl
0000000000000000000000000000000000000000;;	  verify-cmd-in-path mkisofs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# The entry point for bringing up a Kubernetes cluster
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function kube-up {
0000000000000000000000000000000000000000;;	  verify-prereqs
0000000000000000000000000000000000000000;;	  verify-ssh-prereqs
0000000000000000000000000000000000000000;;	  verify-photon-config
0000000000000000000000000000000000000000;;	  kube::util::ensure-temp-dir
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  find-release-tars
0000000000000000000000000000000000000000;;	  find-image-id
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  load-or-gen-kube-basicauth
0000000000000000000000000000000000000000;;	  gen-cloud-init-iso
0000000000000000000000000000000000000000;;	  gen-master-start
0000000000000000000000000000000000000000;;	  create-master-vm
0000000000000000000000000000000000000000;;	  install-salt-on-master
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  gen-node-start
0000000000000000000000000000000000000000;;	  install-salt-on-nodes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  detect-nodes -s
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  install-kubernetes-on-master
0000000000000000000000000000000000000000;;	  install-kubernetes-on-nodes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  wait-master-api
0000000000000000000000000000000000000000;;	  wait-node-apis
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  setup-pod-routes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  copy-kube-certs
0000000000000000000000000000000000000000;;	  kube::log::status "Creating kubeconfig..."
0000000000000000000000000000000000000000;;	  create-kubeconfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Delete a kubernetes cluster
0000000000000000000000000000000000000000;;	function kube-down {
0000000000000000000000000000000000000000;;	  detect-master
0000000000000000000000000000000000000000;;	  detect-nodes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  pc-delete-vm "${KUBE_MASTER}" "${KUBE_MASTER_ID}"
0000000000000000000000000000000000000000;;	  for (( node=0; node<${#KUBE_NODE_IDS[@]}; node++)); do
0000000000000000000000000000000000000000;;	    pc-delete-vm "${NODE_NAMES[${node}]}" "${KUBE_NODE_IDS[${node}]}"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Update a kubernetes cluster
0000000000000000000000000000000000000000;;	function kube-push {
0000000000000000000000000000000000000000;;	  echo "TODO: kube-push" 1>&2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Prepare update a kubernetes component
0000000000000000000000000000000000000000;;	function prepare-push {
0000000000000000000000000000000000000000;;	  echo "TODO: prepare-push" 1>&2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Update a kubernetes master
0000000000000000000000000000000000000000;;	function push-master {
0000000000000000000000000000000000000000;;	  echo "TODO: push-master" 1>&2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Update a kubernetes node
0000000000000000000000000000000000000000;;	function push-node {
0000000000000000000000000000000000000000;;	  echo "TODO: push-node" 1>&2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Execute prior to running tests to build a release if required for env
0000000000000000000000000000000000000000;;	function test-build-release {
0000000000000000000000000000000000000000;;	  echo "TODO: test-build-release" 1>&2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Execute prior to running tests to initialize required structure
0000000000000000000000000000000000000000;;	function test-setup {
0000000000000000000000000000000000000000;;	  echo "TODO: test-setup" 1>&2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Execute after running tests to perform any required clean-up
0000000000000000000000000000000000000000;;	function test-teardown {
0000000000000000000000000000000000000000;;	  echo "TODO: test-teardown" 1>&2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#####################################################################
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Internal functions
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#####################################################################
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Uses Photon Controller to make a VM
0000000000000000000000000000000000000000;;	# Takes two parameters:
0000000000000000000000000000000000000000;;	#   - The name of the VM (Assumed to be unique)
0000000000000000000000000000000000000000;;	#   - The name of the flavor to create the VM (Assumed to be unique)
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# It assumes that the variables in config-common.sh (PHOTON_TENANT, etc)
0000000000000000000000000000000000000000;;	# are set correctly.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# It also assumes the cloud-init ISO has been generated
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# When it completes, it sets two environment variables for use by the
0000000000000000000000000000000000000000;;	# caller: _VM_ID (the ID of the created VM) and _VM_IP (the IP address
0000000000000000000000000000000000000000;;	# of the created VM)
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function pc-create-vm {
0000000000000000000000000000000000000000;;	  local vm_name="${1}"
0000000000000000000000000000000000000000;;	  local vm_flavor="${2}"
0000000000000000000000000000000000000000;;	  local rc=0
0000000000000000000000000000000000000000;;	  local i=0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Create the VM
0000000000000000000000000000000000000000;;	  local tenant_args="--tenant ${PHOTON_TENANT} --project ${PHOTON_PROJECT}"
0000000000000000000000000000000000000000;;	  local vm_args="--name ${vm_name} --image ${PHOTON_IMAGE_ID} --flavor ${vm_flavor}"
0000000000000000000000000000000000000000;;	  local disk_args="disk-1 ${PHOTON_DISK_FLAVOR} boot=true"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  rc=0
0000000000000000000000000000000000000000;;	  _VM_ID=$(${PHOTON} vm create ${tenant_args} ${vm_args} --disks "${disk_args}" 2>&1) || rc=$?
0000000000000000000000000000000000000000;;	  if [[ ${rc} -ne 0 ]]; then
0000000000000000000000000000000000000000;;	    kube::log::error "Failed to create VM. Error output:"
0000000000000000000000000000000000000000;;	    echo "${_VM_ID}"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  kube::log::status "Created VM ${vm_name}: ${_VM_ID}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Start the VM
0000000000000000000000000000000000000000;;	  # Note that the VM has cloud-init in it, and we attach an ISO that
0000000000000000000000000000000000000000;;	  # contains a user-data.txt file for cloud-init. When the VM starts,
0000000000000000000000000000000000000000;;	  # cloud-init will temporarily mount the ISO and configure the VM
0000000000000000000000000000000000000000;;	  # Our user-data will configure the 'kube' user and set up the ssh
0000000000000000000000000000000000000000;;	  # authorized keys to allow us to ssh to the VM and do further work.
0000000000000000000000000000000000000000;;	  run-cmd "${PHOTON} vm attach-iso -p ${KUBE_TEMP}/cloud-init.iso ${_VM_ID}"
0000000000000000000000000000000000000000;;	  run-cmd "${PHOTON} vm start ${_VM_ID}"
0000000000000000000000000000000000000000;;	  kube::log::status "Started VM ${vm_name}, waiting for network address..."
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	   # Wait for the VM to be started and connected to the network
0000000000000000000000000000000000000000;;	  have_network=0
0000000000000000000000000000000000000000;;	  for i in {1..120}; do
0000000000000000000000000000000000000000;;	    # photon -n vm networks print several fields:
0000000000000000000000000000000000000000;;	    # NETWORK MAC IP GATEWAY CONNECTED?
0000000000000000000000000000000000000000;;	    # We wait until CONNECTED is True
0000000000000000000000000000000000000000;;	    rc=0
0000000000000000000000000000000000000000;;	    networks=$(${PHOTON} vm networks "${_VM_ID}") || rc=$?
0000000000000000000000000000000000000000;;	    if [[ ${rc} -ne 0 ]]; then
0000000000000000000000000000000000000000;;	      kube::log::error "'${PHOTON} vm networks ${_VM_ID}' failed. Error output: "
0000000000000000000000000000000000000000;;	      echo "${networks}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    networks=$(echo "${networks}" | grep True) || rc=$?
0000000000000000000000000000000000000000;;	    if [[ ${rc} -eq 0 ]]; then
0000000000000000000000000000000000000000;;	      have_network=1
0000000000000000000000000000000000000000;;	      break;
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    sleep 1
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Fail if the VM didn't come up
0000000000000000000000000000000000000000;;	  if [[ ${have_network} -eq 0 ]]; then
0000000000000000000000000000000000000000;;	    kube::log::error "VM ${vm_name} failed to start up: no IP was found"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Find the IP address of the VM
0000000000000000000000000000000000000000;;	  _VM_IP=$(${PHOTON} vm networks "${_VM_ID}" | head -1 | awk -F'\t' '{print $3}')
0000000000000000000000000000000000000000;;	  kube::log::status "VM ${vm_name} has IP: ${_VM_IP}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Delete one of our VMs
0000000000000000000000000000000000000000;;	# If it is STARTED, it will be stopped first.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function pc-delete-vm {
0000000000000000000000000000000000000000;;	  local vm_name="${1}"
0000000000000000000000000000000000000000;;	  local vm_id="${2}"
0000000000000000000000000000000000000000;;	  local rc=0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::log::status "Deleting VM ${vm_name}"
0000000000000000000000000000000000000000;;	  # In some cases, head exits before photon, so the pipline exits with
0000000000000000000000000000000000000000;;	  # SIGPIPE. We disable the pipefile option to hide that failure.
0000000000000000000000000000000000000000;;	  set +o pipefail
0000000000000000000000000000000000000000;;	  ${PHOTON} vm show "${vm_id}" | head -1 | grep STARTED > /dev/null 2>&1 || rc=$?
0000000000000000000000000000000000000000;;	  set +o pipefail
0000000000000000000000000000000000000000;;	  if [[ ${rc} -eq 0 ]]; then
0000000000000000000000000000000000000000;;	    ${PHOTON} vm stop "${vm_id}" > /dev/null 2>&1 || rc=$?
0000000000000000000000000000000000000000;;	    if [[ ${rc} -ne 0 ]]; then
0000000000000000000000000000000000000000;;	      kube::log::error "Error: could not stop ${vm_name} ($vm_id)"
0000000000000000000000000000000000000000;;	      kube::log::error "Please investigate and stop manually"
0000000000000000000000000000000000000000;;	      return
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  rc=0
0000000000000000000000000000000000000000;;	  ${PHOTON} vm delete "${vm_id}" > /dev/null 2>&1 || rc=$?
0000000000000000000000000000000000000000;;	  if [[ ${rc} -ne 0 ]]; then
0000000000000000000000000000000000000000;;	    kube::log::error "Error: could not delete ${vm_name} ($vm_id)"
0000000000000000000000000000000000000000;;	    kube::log::error "Please investigate and delete manually"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Looks for the image named PHOTON_IMAGE
0000000000000000000000000000000000000000;;	# Sets PHOTON_IMAGE_ID to be the id of that image.
0000000000000000000000000000000000000000;;	# We currently assume there is exactly one image with name
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function find-image-id {
0000000000000000000000000000000000000000;;	  local rc=0
0000000000000000000000000000000000000000;;	  PHOTON_IMAGE_ID=$(${PHOTON} image list | grep $'\t'"${PHOTON_IMAGE}"$'\t' | head -1 | grep READY | awk -F'\t' '{print $1}')
0000000000000000000000000000000000000000;;	  if [[ ${rc} -ne 0 ]]; then
0000000000000000000000000000000000000000;;	    kube::log::error "Cannot find image \"${PHOTON_IMAGE}\""
0000000000000000000000000000000000000000;;	    fail=1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Generate an ISO with a single file called user-data.txt
0000000000000000000000000000000000000000;;	# This ISO will be used to configure cloud-init (which is already
0000000000000000000000000000000000000000;;	# on the VM). We will tell cloud-init to create the kube user/group
0000000000000000000000000000000000000000;;	# and give ourselves the ability to ssh to the VM with ssh. We also
0000000000000000000000000000000000000000;;	# allow people to ssh with the same password that was randomly
0000000000000000000000000000000000000000;;	# generated for access to Kubernetes as a backup method.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumes environment variables:
0000000000000000000000000000000000000000;;	#   - VM_USER
0000000000000000000000000000000000000000;;	#   - KUBE_PASSWORD (randomly generated password)
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function gen-cloud-init-iso {
0000000000000000000000000000000000000000;;	  local password_hash
0000000000000000000000000000000000000000;;	  password_hash=$(openssl passwd -1 "${KUBE_PASSWORD}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local ssh_key
0000000000000000000000000000000000000000;;	  ssh_key=$(ssh-add -L | head -1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Make the user-data file that will be used by cloud-init
0000000000000000000000000000000000000000;;	  (
0000000000000000000000000000000000000000;;	    echo "#cloud-config"
0000000000000000000000000000000000000000;;	    echo ""
0000000000000000000000000000000000000000;;	    echo "groups:"
0000000000000000000000000000000000000000;;	    echo "  - ${VM_USER}"
0000000000000000000000000000000000000000;;	    echo ""
0000000000000000000000000000000000000000;;	    echo "users:"
0000000000000000000000000000000000000000;;	    echo "  - name: ${VM_USER}"
0000000000000000000000000000000000000000;;	    echo "    gecos: Kubernetes"
0000000000000000000000000000000000000000;;	    echo "    primary-group: ${VM_USER}"
0000000000000000000000000000000000000000;;	    echo "    lock-passwd: false"
0000000000000000000000000000000000000000;;	    echo "    passwd: ${password_hash}"
0000000000000000000000000000000000000000;;	    echo "    ssh-authorized-keys: "
0000000000000000000000000000000000000000;;	    echo "      - ${ssh_key}"
0000000000000000000000000000000000000000;;	    echo "    sudo: ALL=(ALL) NOPASSWD:ALL"
0000000000000000000000000000000000000000;;	    echo "    shell: /bin/bash"
0000000000000000000000000000000000000000;;	    echo ""
0000000000000000000000000000000000000000;;	    echo "hostname:"
0000000000000000000000000000000000000000;;	    echo "  - hostname: kube"
0000000000000000000000000000000000000000;;	  ) > "${KUBE_TEMP}/user-data.txt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Make the ISO that will contain the user-data
0000000000000000000000000000000000000000;;	  # The -rock option means that we'll generate real filenames (long and with case)
0000000000000000000000000000000000000000;;	  run-cmd "mkisofs -rock -o ${KUBE_TEMP}/cloud-init.iso ${KUBE_TEMP}/user-data.txt"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Generate a script used to install salt on the master
0000000000000000000000000000000000000000;;	# It is placed into $KUBE_TEMP/master-start.sh
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function gen-master-start {
0000000000000000000000000000000000000000;;	  python "${KUBE_ROOT}/third_party/htpasswd/htpasswd.py" \
0000000000000000000000000000000000000000;;	    -b -c "${KUBE_TEMP}/htpasswd" "${KUBE_USER}" "${KUBE_PASSWORD}"
0000000000000000000000000000000000000000;;	  local htpasswd
0000000000000000000000000000000000000000;;	  htpasswd=$(cat "${KUBE_TEMP}/htpasswd")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # This calculation of the service IP should work, but if you choose an
0000000000000000000000000000000000000000;;	  # alternate subnet, there's a small chance you'd need to modify the
0000000000000000000000000000000000000000;;	  # service_ip, below.  We'll choose an IP like 10.244.240.1 by taking
0000000000000000000000000000000000000000;;	  # the first three octets of the SERVICE_CLUSTER_IP_RANGE and tacking
0000000000000000000000000000000000000000;;	  # on a .1
0000000000000000000000000000000000000000;;	  local octets
0000000000000000000000000000000000000000;;	  local service_ip
0000000000000000000000000000000000000000;;	  octets=($(echo "${SERVICE_CLUSTER_IP_RANGE}" | sed -e 's|/.*||' -e 's/\./ /g'))
0000000000000000000000000000000000000000;;	  ((octets[3]+=1))
0000000000000000000000000000000000000000;;	  service_ip=$(echo "${octets[*]}" | sed 's/ /./g')
0000000000000000000000000000000000000000;;	  MASTER_EXTRA_SANS="IP:${service_ip},DNS:${MASTER_NAME},${MASTER_EXTRA_SANS}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  (
0000000000000000000000000000000000000000;;	    echo "#! /bin/bash"
0000000000000000000000000000000000000000;;	    echo "readonly MY_NAME=${MASTER_NAME}"
0000000000000000000000000000000000000000;;	    grep -v "^#" "${KUBE_ROOT}/cluster/photon-controller/templates/hostname.sh"
0000000000000000000000000000000000000000;;	    echo "cd /home/kube/cache/kubernetes-install"
0000000000000000000000000000000000000000;;	    echo "readonly MASTER_NAME='${MASTER_NAME}'"
0000000000000000000000000000000000000000;;	    echo "readonly MASTER_IP_RANGE='${MASTER_IP_RANGE}'"
0000000000000000000000000000000000000000;;	    echo "readonly INSTANCE_PREFIX='${INSTANCE_PREFIX}'"
0000000000000000000000000000000000000000;;	    echo "readonly NODE_INSTANCE_PREFIX='${INSTANCE_PREFIX}-node'"
0000000000000000000000000000000000000000;;	    echo "readonly NODE_IP_RANGES='${NODE_IP_RANGES}'"
0000000000000000000000000000000000000000;;	    echo "readonly SERVICE_CLUSTER_IP_RANGE='${SERVICE_CLUSTER_IP_RANGE}'"
0000000000000000000000000000000000000000;;	    echo "readonly ENABLE_NODE_LOGGING='${ENABLE_NODE_LOGGING:-false}'"
0000000000000000000000000000000000000000;;	    echo "readonly LOGGING_DESTINATION='${LOGGING_DESTINATION:-}'"
0000000000000000000000000000000000000000;;	    echo "readonly ENABLE_CLUSTER_DNS='${ENABLE_CLUSTER_DNS:-false}'"
0000000000000000000000000000000000000000;;	    echo "readonly ENABLE_CLUSTER_UI='${ENABLE_CLUSTER_UI:-false}'"
0000000000000000000000000000000000000000;;	    echo "readonly DNS_SERVER_IP='${DNS_SERVER_IP:-}'"
0000000000000000000000000000000000000000;;	    echo "readonly DNS_DOMAIN='${DNS_DOMAIN:-}'"
0000000000000000000000000000000000000000;;	    echo "readonly KUBE_USER='${KUBE_USER:-}'"
0000000000000000000000000000000000000000;;	    echo "readonly KUBE_PASSWORD='${KUBE_PASSWORD:-}'"
0000000000000000000000000000000000000000;;	    echo "readonly SERVER_BINARY_TAR='${SERVER_BINARY_TAR##*/}'"
0000000000000000000000000000000000000000;;	    echo "readonly SALT_TAR='${SALT_TAR##*/}'"
0000000000000000000000000000000000000000;;	    echo "readonly MASTER_HTPASSWD='${htpasswd}'"
0000000000000000000000000000000000000000;;	    echo "readonly E2E_STORAGE_TEST_ENVIRONMENT='${E2E_STORAGE_TEST_ENVIRONMENT:-}'"
0000000000000000000000000000000000000000;;	    echo "readonly MASTER_EXTRA_SANS='${MASTER_EXTRA_SANS:-}'"
0000000000000000000000000000000000000000;;	    grep -v "^#" "${KUBE_ROOT}/cluster/photon-controller/templates/create-dynamic-salt-files.sh"
0000000000000000000000000000000000000000;;	    grep -v "^#" "${KUBE_ROOT}/cluster/photon-controller/templates/install-release.sh"
0000000000000000000000000000000000000000;;	    grep -v "^#" "${KUBE_ROOT}/cluster/photon-controller/templates/salt-master.sh"
0000000000000000000000000000000000000000;;	  ) > "${KUBE_TEMP}/master-start.sh"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Generate the scripts for each node to install salt
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function gen-node-start {
0000000000000000000000000000000000000000;;	  local i
0000000000000000000000000000000000000000;;	  for (( i=0; i<${#NODE_NAMES[@]}; i++)); do
0000000000000000000000000000000000000000;;	    (
0000000000000000000000000000000000000000;;	      echo "#! /bin/bash"
0000000000000000000000000000000000000000;;	      echo "readonly MY_NAME=${NODE_NAMES[${i}]}"
0000000000000000000000000000000000000000;;	      grep -v "^#" "${KUBE_ROOT}/cluster/photon-controller/templates/hostname.sh"
0000000000000000000000000000000000000000;;	      echo "KUBE_MASTER=${KUBE_MASTER}"
0000000000000000000000000000000000000000;;	      echo "KUBE_MASTER_IP=${KUBE_MASTER_IP}"
0000000000000000000000000000000000000000;;	      echo "NODE_IP_RANGE=$NODE_IP_RANGES"
0000000000000000000000000000000000000000;;	      grep -v "^#" "${KUBE_ROOT}/cluster/photon-controller/templates/salt-minion.sh"
0000000000000000000000000000000000000000;;	    ) > "${KUBE_TEMP}/node-start-${i}.sh"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Create a script that will run on the Kubernetes master and will run salt
0000000000000000000000000000000000000000;;	# to configure the master. We make it a script instead of just running a
0000000000000000000000000000000000000000;;	# single ssh command so that we can get logging.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function gen-master-salt {
0000000000000000000000000000000000000000;;	  gen-salt "kubernetes-master"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Create scripts that will be run on the Kubernetes master. Each of these
0000000000000000000000000000000000000000;;	# will invoke salt to configure one of the nodes
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function gen-node-salt {
0000000000000000000000000000000000000000;;	  local i
0000000000000000000000000000000000000000;;	  for (( i=0; i<${#NODE_NAMES[@]}; i++)); do
0000000000000000000000000000000000000000;;	    gen-salt "${NODE_NAMES[${i}]}"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# 
0000000000000000000000000000000000000000;;	# Shared implementation for gen-master-salt and gen-node-salt
0000000000000000000000000000000000000000;;	# Writes a script that installs Kubernetes with salt
0000000000000000000000000000000000000000;;	# The core of the script is simple (run 'salt ... state.highstate')
0000000000000000000000000000000000000000;;	# We also do a bit of logging so we can debug problems
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# There is also a funky workaround for an issue with docker 1.9 
0000000000000000000000000000000000000000;;	# (elsewhere we peg ourselves to docker 1.9). It's fixed in 1.10, 
0000000000000000000000000000000000000000;;	# so we should be able to remove it in the future
0000000000000000000000000000000000000000;;	# https://github.com/docker/docker/issues/18113
0000000000000000000000000000000000000000;;	# The problem is that sometimes the install (with apt-get) of
0000000000000000000000000000000000000000;;	# docker fails. Deleting a file and retrying fixes it.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Tell shellcheck to ignore our variables within single quotes: 
0000000000000000000000000000000000000000;;	# We're writing a script, not executing it, so this is normal
0000000000000000000000000000000000000000;;	# shellcheck disable=SC2016
0000000000000000000000000000000000000000;;	function gen-salt {
0000000000000000000000000000000000000000;;	  node_name=${1}
0000000000000000000000000000000000000000;;	    (
0000000000000000000000000000000000000000;;	      echo '#!/bin/bash'
0000000000000000000000000000000000000000;;	      echo ''
0000000000000000000000000000000000000000;;	      echo "node=${node_name}"
0000000000000000000000000000000000000000;;	      echo 'out=/tmp/${node}-salt.out'
0000000000000000000000000000000000000000;;	      echo 'log=/tmp/${node}-salt.log'
0000000000000000000000000000000000000000;;	      echo ''
0000000000000000000000000000000000000000;;	      echo 'echo $(date) >> $log'
0000000000000000000000000000000000000000;;	      echo 'salt ${node} state.highstate -t 30 --no-color > ${out}'
0000000000000000000000000000000000000000;;	      echo 'grep -E "Failed:[[:space:]]+0" ${out}'
0000000000000000000000000000000000000000;;	      echo 'success=$?'
0000000000000000000000000000000000000000;;	      echo 'cat ${out} >> ${log}'
0000000000000000000000000000000000000000;;	      echo ''
0000000000000000000000000000000000000000;;	      echo 'if [[ ${success} -ne 0 ]]; then'
0000000000000000000000000000000000000000;;	      echo '  # Did we try to install docker-engine?'
0000000000000000000000000000000000000000;;	      echo '  attempted=$(grep docker-engine ${out} | wc -l)'
0000000000000000000000000000000000000000;;	      echo '  # Is docker-engine installed?'
0000000000000000000000000000000000000000;;	      echo '  installed=$(salt --output=txt ${node} pkg.version docker-engine | wc -l)'
0000000000000000000000000000000000000000;;	      echo '  if [[ ${attempted} -ne 0 && ${installed} -eq 0 ]]; then'
0000000000000000000000000000000000000000;;	      echo '    echo "Unwedging docker-engine install" >> ${log}'
0000000000000000000000000000000000000000;;	      echo '    salt ${node} cmd.run "rm -f /var/lib/docker/network/files/local-kv.db"'
0000000000000000000000000000000000000000;;	      echo '  fi'
0000000000000000000000000000000000000000;;	      echo 'fi'
0000000000000000000000000000000000000000;;	      echo 'exit ${success}'
0000000000000000000000000000000000000000;;	    ) > "${KUBE_TEMP}/${node_name}-salt.sh"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Generate a script to add a route to a host (master or node)
0000000000000000000000000000000000000000;;	# The script will do two things:
0000000000000000000000000000000000000000;;	# 1. Add the route immediately with the route command
0000000000000000000000000000000000000000;;	# 2. Persist the route by saving it in /etc/network/interfaces
0000000000000000000000000000000000000000;;	# This was done with a script because it was easier to get the quoting right
0000000000000000000000000000000000000000;;	# and make it clear.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function gen-add-route {
0000000000000000000000000000000000000000;;	  route=${1}
0000000000000000000000000000000000000000;;	  gateway=${2}
0000000000000000000000000000000000000000;;	  (
0000000000000000000000000000000000000000;;	      echo '#!/bin/bash'
0000000000000000000000000000000000000000;;	      echo ''
0000000000000000000000000000000000000000;;	      echo '# Immediately add route'
0000000000000000000000000000000000000000;;	      echo "sudo route add -net ${route} gw ${gateway}"
0000000000000000000000000000000000000000;;	      echo ''
0000000000000000000000000000000000000000;;	      echo '# Persist route so it lasts over restarts'
0000000000000000000000000000000000000000;;	      echo 'sed -in "s|^iface eth0.*|&\n    post-up route add -net' "${route} gw ${gateway}|"'" /etc/network/interfaces'
0000000000000000000000000000000000000000;;	  ) > "${KUBE_TEMP}/add-route.sh"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Create the Kubernetes master VM
0000000000000000000000000000000000000000;;	# Sets global variables: 
0000000000000000000000000000000000000000;;	# - KUBE_MASTER    (Name)
0000000000000000000000000000000000000000;;	# - KUBE_MASTER_ID (Photon VM ID)
0000000000000000000000000000000000000000;;	# - KUBE_MASTER_IP (IP address)
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function create-master-vm {
0000000000000000000000000000000000000000;;	  kube::log::status "Starting master VM..."
0000000000000000000000000000000000000000;;	  pc-create-vm "${MASTER_NAME}" "${PHOTON_MASTER_FLAVOR}"
0000000000000000000000000000000000000000;;	  KUBE_MASTER=${MASTER_NAME}
0000000000000000000000000000000000000000;;	  KUBE_MASTER_ID=${_VM_ID}
0000000000000000000000000000000000000000;;	  KUBE_MASTER_IP=${_VM_IP}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# 
0000000000000000000000000000000000000000;;	# Install salt on the Kubernetes master
0000000000000000000000000000000000000000;;	# Relies on the master-start.sh script created in gen-master-start
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function install-salt-on-master {
0000000000000000000000000000000000000000;;	  kube::log::status "Installing salt on master..."
0000000000000000000000000000000000000000;;	  upload-server-tars "${MASTER_NAME}" "${KUBE_MASTER_IP}"
0000000000000000000000000000000000000000;;	  run-script-remotely "${KUBE_MASTER_IP}" "${KUBE_TEMP}/master-start.sh"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Installs salt on Kubernetes nodes in parallel
0000000000000000000000000000000000000000;;	# Relies on the node-start script created in gen-node-start
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function install-salt-on-nodes {
0000000000000000000000000000000000000000;;	  kube::log::status "Creating nodes and installing salt on them..."
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Start each of the VMs in parallel
0000000000000000000000000000000000000000;;	  # In the future, we'll batch this because it doesn't scale well
0000000000000000000000000000000000000000;;	  # past 10 or 20 nodes
0000000000000000000000000000000000000000;;	  local node
0000000000000000000000000000000000000000;;	  for (( node=0; node<${#NODE_NAMES[@]}; node++)); do
0000000000000000000000000000000000000000;;	  (
0000000000000000000000000000000000000000;;	    pc-create-vm "${NODE_NAMES[${node}]}" "${PHOTON_NODE_FLAVOR}"
0000000000000000000000000000000000000000;;	    run-script-remotely "${_VM_IP}" "${KUBE_TEMP}/node-start-${node}.sh"
0000000000000000000000000000000000000000;;	  ) &
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Wait for the node VM startups to complete
0000000000000000000000000000000000000000;;	  local fail=0
0000000000000000000000000000000000000000;;	  local job
0000000000000000000000000000000000000000;;	  for job in $(jobs -p); do
0000000000000000000000000000000000000000;;	    wait "${job}" || fail=$((fail + 1))
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  if (( fail != 0 )); then
0000000000000000000000000000000000000000;;	    kube::log::error "Failed to start ${fail}/${NUM_NODES} nodes"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Install Kubernetes on the master.
0000000000000000000000000000000000000000;;	# This uses the kubernetes-master-salt.sh script created by gen-master-salt
0000000000000000000000000000000000000000;;	# That script uses salt to install Kubernetes
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function install-kubernetes-on-master {
0000000000000000000000000000000000000000;;	  # Wait until salt-master is running: it may take a bit
0000000000000000000000000000000000000000;;	  try-until-success-ssh "${KUBE_MASTER_IP}" \
0000000000000000000000000000000000000000;;	    "Waiting for salt-master to start on ${KUBE_MASTER}" \
0000000000000000000000000000000000000000;;	    "pgrep salt-master"
0000000000000000000000000000000000000000;;	  gen-master-salt
0000000000000000000000000000000000000000;;	  copy-file-to-vm "${_VM_IP}" "${KUBE_TEMP}/kubernetes-master-salt.sh" "/tmp/kubernetes-master-salt.sh"
0000000000000000000000000000000000000000;;	  try-until-success-ssh "${KUBE_MASTER_IP}" \
0000000000000000000000000000000000000000;;	    "Installing Kubernetes on ${KUBE_MASTER} via salt" \
0000000000000000000000000000000000000000;;	    "sudo /bin/bash /tmp/kubernetes-master-salt.sh"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Install Kubernetes on the the nodes in parallel
0000000000000000000000000000000000000000;;	# This uses the kubernetes-master-salt.sh script created by gen-node-salt
0000000000000000000000000000000000000000;;	# That script uses salt to install Kubernetes
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function install-kubernetes-on-nodes {
0000000000000000000000000000000000000000;;	  gen-node-salt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Run in parallel to bring up the cluster faster
0000000000000000000000000000000000000000;;	  # TODO: Batch this so that we run up to N in parallel, so
0000000000000000000000000000000000000000;;	  # we don't overload this machine or the salt master
0000000000000000000000000000000000000000;;	  local node
0000000000000000000000000000000000000000;;	  for (( node=0; node<${#NODE_NAMES[@]}; node++)); do
0000000000000000000000000000000000000000;;	    (
0000000000000000000000000000000000000000;;	      copy-file-to-vm "${_VM_IP}" "${KUBE_TEMP}/${NODE_NAMES[${node}]}-salt.sh" "/tmp/${NODE_NAMES[${node}]}-salt.sh"
0000000000000000000000000000000000000000;;	      try-until-success-ssh "${KUBE_NODE_IP_ADDRESSES[${node}]}" \
0000000000000000000000000000000000000000;;	        "Waiting for salt-master to start on ${NODE_NAMES[${node}]}" \
0000000000000000000000000000000000000000;;	        "pgrep salt-minion"
0000000000000000000000000000000000000000;;	      try-until-success-ssh "${KUBE_MASTER_IP}" \
0000000000000000000000000000000000000000;;	        "Installing Kubernetes on ${NODE_NAMES[${node}]} via salt" \
0000000000000000000000000000000000000000;;	        "sudo /bin/bash /tmp/${NODE_NAMES[${node}]}-salt.sh"
0000000000000000000000000000000000000000;;	    ) &
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Wait for the Kubernetes installations to complete
0000000000000000000000000000000000000000;;	  local fail=0
0000000000000000000000000000000000000000;;	  local job
0000000000000000000000000000000000000000;;	  for job in $(jobs -p); do
0000000000000000000000000000000000000000;;	    wait "${job}" || fail=$((fail + 1))
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  if (( fail != 0 )); then
0000000000000000000000000000000000000000;;	    kube::log::error "Failed to start install Kubernetes on ${fail} out of ${NUM_NODES} nodess"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Upload the Kubernetes tarballs to the master
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function upload-server-tars {
0000000000000000000000000000000000000000;;	  vm_name=${1}
0000000000000000000000000000000000000000;;	  vm_ip=${2}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  run-ssh-cmd "${vm_ip}" "mkdir -p /home/kube/cache/kubernetes-install"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local tar
0000000000000000000000000000000000000000;;	  for tar in "${SERVER_BINARY_TAR}" "${SALT_TAR}"; do
0000000000000000000000000000000000000000;;	    local base_tar
0000000000000000000000000000000000000000;;	    base_tar=$(basename "${tar}")
0000000000000000000000000000000000000000;;	    kube::log::status "Uploading ${base_tar} to ${vm_name}..."
0000000000000000000000000000000000000000;;	    copy-file-to-vm "${vm_ip}" "${tar}" "/home/kube/cache/kubernetes-install/${tar##*/}"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Wait for the Kubernets healthz API to be responsive on the master
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function wait-master-api {
0000000000000000000000000000000000000000;;	  local curl_creds="--insecure --user ${KUBE_USER}:${KUBE_PASSWORD}"
0000000000000000000000000000000000000000;;	  local curl_output="--fail --output /dev/null --silent"
0000000000000000000000000000000000000000;;	  local curl_net="--max-time 1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  try-until-success "Waiting for Kubernetes API on ${KUBE_MASTER}" \
0000000000000000000000000000000000000000;;	    "curl ${curl_creds} ${curl_output} ${curl_net} https://${KUBE_MASTER_IP}/healthz"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Wait for the Kubernetes healthz API to be responsive on each node
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function wait-node-apis {
0000000000000000000000000000000000000000;;	  local curl_output="--fail --output /dev/null --silent"
0000000000000000000000000000000000000000;;	  local curl_net="--max-time 1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for (( i=0; i<${#NODE_NAMES[@]}; i++)); do
0000000000000000000000000000000000000000;;	    try-until-success "Waiting for Kubernetes API on ${NODE_NAMES[${i}]}..." \
0000000000000000000000000000000000000000;;	      "curl ${curl_output} ${curl_net} http://${KUBE_NODE_IP_ADDRESSES[${i}]}:10250/healthz"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Configure the nodes so the pods can communicate
0000000000000000000000000000000000000000;;	# Each node will have a bridge named cbr0 for the NODE_IP_RANGES
0000000000000000000000000000000000000000;;	# defined in config-default.sh. This finds the IP subnet (assigned
0000000000000000000000000000000000000000;;	# by Kubernetes) to nodes and configures routes so they can communicate
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Also configure the master to be able to talk to the nodes. This is
0000000000000000000000000000000000000000;;	# useful so that you can get to the UI from the master.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function setup-pod-routes {
0000000000000000000000000000000000000000;;	  local node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  KUBE_NODE_BRIDGE_NETWORK=()
0000000000000000000000000000000000000000;;	  for (( node=0; node<${#NODE_NAMES[@]}; node++)); do
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # This happens in two steps (wait for an address, wait for a non 172.x.x.x address)
0000000000000000000000000000000000000000;;	    # because it's both simpler and more clear what's happening.
0000000000000000000000000000000000000000;;	    try-until-success-ssh "${KUBE_NODE_IP_ADDRESSES[${node}]}" \
0000000000000000000000000000000000000000;;	      "Waiting for cbr0 bridge on ${NODE_NAMES[${node}]} to have an address"  \
0000000000000000000000000000000000000000;;	      'sudo ifconfig cbr0  | grep -oP "inet addr:\K\S+"'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    try-until-success-ssh "${KUBE_NODE_IP_ADDRESSES[${node}]}" \
0000000000000000000000000000000000000000;;	      "Waiting for cbr0 bridge on ${NODE_NAMES[${node}]} to have correct address"  \
0000000000000000000000000000000000000000;;	      'sudo ifconfig cbr0  | grep -oP "inet addr:\K\S+" | grep -v  "^172."'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    run-ssh-cmd "${KUBE_NODE_IP_ADDRESSES[${node}]}" 'sudo ip route show | grep -E "dev cbr0" | cut -d " " -f1'
0000000000000000000000000000000000000000;;	    KUBE_NODE_BRIDGE_NETWORK+=(${_OUTPUT})
0000000000000000000000000000000000000000;;	    kube::log::status "cbr0 on ${NODE_NAMES[${node}]} is ${_OUTPUT}"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local i
0000000000000000000000000000000000000000;;	  local j
0000000000000000000000000000000000000000;;	  for (( i=0; i<${#NODE_NAMES[@]}; i++)); do
0000000000000000000000000000000000000000;;	    kube::log::status "Configuring pod routes on ${NODE_NAMES[${i}]}..."
0000000000000000000000000000000000000000;;	    gen-add-route "${KUBE_NODE_BRIDGE_NETWORK[${i}]}" "${KUBE_NODE_IP_ADDRESSES[${i}]}"
0000000000000000000000000000000000000000;;	    run-script-remotely "${KUBE_MASTER_IP}" "${KUBE_TEMP}/add-route.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    for (( j=0; j<${#NODE_NAMES[@]}; j++)); do
0000000000000000000000000000000000000000;;	      if [[ "${i}" != "${j}" ]]; then
0000000000000000000000000000000000000000;;	        gen-add-route "${KUBE_NODE_BRIDGE_NETWORK[${j}]}" "${KUBE_NODE_IP_ADDRESSES[${j}]}"
0000000000000000000000000000000000000000;;	        run-script-remotely "${KUBE_NODE_IP_ADDRESSES[${i}]}" "${KUBE_TEMP}/add-route.sh"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Copy the certificate/key from the Kubernetes master
0000000000000000000000000000000000000000;;	# These are used to create the kubeconfig file, which allows
0000000000000000000000000000000000000000;;	# users to use kubectl easily
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# We also set KUBE_CERT, KUBE_KEY, CA_CERT, and CONTEXT because they
0000000000000000000000000000000000000000;;	# are needed by create-kubeconfig from common.sh to generate
0000000000000000000000000000000000000000;;	# the kube config file.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function copy-kube-certs {
0000000000000000000000000000000000000000;;	  local cert="kubecfg.crt"
0000000000000000000000000000000000000000;;	  local key="kubecfg.key"
0000000000000000000000000000000000000000;;	  local ca="ca.crt"
0000000000000000000000000000000000000000;;	  local cert_dir="/srv/kubernetes"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::log::status "Copying credentials from ${KUBE_MASTER}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Set global environment variables: needed by create-kubeconfig
0000000000000000000000000000000000000000;;	  # in common.sh
0000000000000000000000000000000000000000;;	  export KUBE_CERT="${KUBE_TEMP}/${cert}"
0000000000000000000000000000000000000000;;	  export KUBE_KEY="${KUBE_TEMP}/${key}"
0000000000000000000000000000000000000000;;	  export CA_CERT="${KUBE_TEMP}/${ca}"
0000000000000000000000000000000000000000;;	  export CONTEXT="photon-${INSTANCE_PREFIX}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  run-ssh-cmd "${KUBE_MASTER_IP}" "sudo chmod 644 ${cert_dir}/${cert}"
0000000000000000000000000000000000000000;;	  run-ssh-cmd "${KUBE_MASTER_IP}" "sudo chmod 644 ${cert_dir}/${key}"
0000000000000000000000000000000000000000;;	  run-ssh-cmd "${KUBE_MASTER_IP}" "sudo chmod 644 ${cert_dir}/${ca}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  copy-file-from-vm "${KUBE_MASTER_IP}" "${cert_dir}/${cert}" "${KUBE_CERT}"
0000000000000000000000000000000000000000;;	  copy-file-from-vm "${KUBE_MASTER_IP}" "${cert_dir}/${key}"  "${KUBE_KEY}"
0000000000000000000000000000000000000000;;	  copy-file-from-vm "${KUBE_MASTER_IP}" "${cert_dir}/${ca}"   "${CA_CERT}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  run-ssh-cmd "${KUBE_MASTER_IP}" "sudo chmod 600 ${cert_dir}/${cert}"
0000000000000000000000000000000000000000;;	  run-ssh-cmd "${KUBE_MASTER_IP}" "sudo chmod 600 ${cert_dir}/${key}"
0000000000000000000000000000000000000000;;	  run-ssh-cmd "${KUBE_MASTER_IP}" "sudo chmod 600 ${cert_dir}/${ca}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Copies a script to a VM and runs it
0000000000000000000000000000000000000000;;	# Parameters:
0000000000000000000000000000000000000000;;	#   - IP of VM
0000000000000000000000000000000000000000;;	#   - Path to local file
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function run-script-remotely {
0000000000000000000000000000000000000000;;	  local vm_ip=${1}
0000000000000000000000000000000000000000;;	  local local_file="${2}"
0000000000000000000000000000000000000000;;	  local base_file
0000000000000000000000000000000000000000;;	  local remote_file
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  base_file=$(basename "${local_file}")
0000000000000000000000000000000000000000;;	  remote_file="/tmp/${base_file}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  copy-file-to-vm "${vm_ip}" "${local_file}" "${remote_file}"
0000000000000000000000000000000000000000;;	  run-ssh-cmd "${vm_ip}" "chmod 700 ${remote_file}"
0000000000000000000000000000000000000000;;	  run-ssh-cmd "${vm_ip}" "nohup sudo ${remote_file} < /dev/null 1> ${remote_file}.out 2>&1 &"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Runs an command on a VM using ssh
0000000000000000000000000000000000000000;;	# Parameters:
0000000000000000000000000000000000000000;;	#   - (optional) -i to ignore failure
0000000000000000000000000000000000000000;;	#   - IP address of the VM
0000000000000000000000000000000000000000;;	#   - Command to run
0000000000000000000000000000000000000000;;	# Assumes environment variables:
0000000000000000000000000000000000000000;;	#   - VM_USER
0000000000000000000000000000000000000000;;	#   - SSH_OPTS
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function run-ssh-cmd {
0000000000000000000000000000000000000000;;	  local ignore_failure=""
0000000000000000000000000000000000000000;;	  if [[ "${1}" = "-i" ]]; then
0000000000000000000000000000000000000000;;	    ignore_failure="-i"
0000000000000000000000000000000000000000;;	    shift
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local vm_ip=${1}
0000000000000000000000000000000000000000;;	  shift
0000000000000000000000000000000000000000;;	  local cmd=${1}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  run-cmd ${ignore_failure} "ssh ${SSH_OPTS} $VM_USER@${vm_ip} $1"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Uses scp to copy file to VM
0000000000000000000000000000000000000000;;	# Parameters:
0000000000000000000000000000000000000000;;	#   - IP address of the VM
0000000000000000000000000000000000000000;;	#   - Path to local file
0000000000000000000000000000000000000000;;	#   - Path to remote file
0000000000000000000000000000000000000000;;	# Assumes environment variables:
0000000000000000000000000000000000000000;;	#   - VM_USER
0000000000000000000000000000000000000000;;	#   - SSH_OPTS
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function copy-file-to-vm {
0000000000000000000000000000000000000000;;	  local vm_ip=${1}
0000000000000000000000000000000000000000;;	  local local_file=${2}
0000000000000000000000000000000000000000;;	  local remote_file=${3}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  run-cmd "scp ${SSH_OPTS} ${local_file} ${VM_USER}@${vm_ip}:${remote_file}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function copy-file-from-vm {
0000000000000000000000000000000000000000;;	  local vm_ip=${1}
0000000000000000000000000000000000000000;;	  local remote_file=${2}
0000000000000000000000000000000000000000;;	  local local_file=${3}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  run-cmd "scp ${SSH_OPTS} ${VM_USER}@${vm_ip}:${remote_file} ${local_file}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Run a command, print nice error output
0000000000000000000000000000000000000000;;	# Used by copy-file-to-vm and run-ssh-cmd
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function run-cmd {
0000000000000000000000000000000000000000;;	  local rc=0
0000000000000000000000000000000000000000;;	  local ignore_failure=""
0000000000000000000000000000000000000000;;	  if [[ "${1}" = "-i" ]]; then
0000000000000000000000000000000000000000;;	    ignore_failure=${1}
0000000000000000000000000000000000000000;;	    shift
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local cmd=$1
0000000000000000000000000000000000000000;;	  local output
0000000000000000000000000000000000000000;;	  output=$(${cmd} 2>&1) || rc=$?
0000000000000000000000000000000000000000;;	  if [[ ${rc} -ne 0 ]]; then
0000000000000000000000000000000000000000;;	    if [[ -z "${ignore_failure}" ]]; then
0000000000000000000000000000000000000000;;	      kube::log::error "Failed to run command: ${cmd} Output:"
0000000000000000000000000000000000000000;;	      echo "${output}"
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  _OUTPUT=${output}
0000000000000000000000000000000000000000;;	  return ${rc}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# After the initial VM setup, we use SSH with keys to access the VMs
0000000000000000000000000000000000000000;;	# This requires an SSH agent, so we verify that it's running
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function verify-ssh-prereqs {
0000000000000000000000000000000000000000;;	  kube::log::status "Validating SSH configuration..."
0000000000000000000000000000000000000000;;	  local rc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  rc=0
0000000000000000000000000000000000000000;;	  ssh-add -L 1> /dev/null 2> /dev/null || rc=$?
0000000000000000000000000000000000000000;;	  # "Could not open a connection to your authentication agent."
0000000000000000000000000000000000000000;;	  if [[ "${rc}" -eq 2 ]]; then
0000000000000000000000000000000000000000;;	    # ssh agent wasn't running, so start it and ensure we stop it
0000000000000000000000000000000000000000;;	    eval "$(ssh-agent)" > /dev/null
0000000000000000000000000000000000000000;;	    trap-add "kill ${SSH_AGENT_PID}" EXIT
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  rc=0
0000000000000000000000000000000000000000;;	  ssh-add -L 1> /dev/null 2> /dev/null || rc=$?
0000000000000000000000000000000000000000;;	  # "The agent has no identities."
0000000000000000000000000000000000000000;;	  if [[ "${rc}" -eq 1 ]]; then
0000000000000000000000000000000000000000;;	  # Try adding one of the default identities, with or without passphrase.
0000000000000000000000000000000000000000;;	    ssh-add || true
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Expect at least one identity to be available.
0000000000000000000000000000000000000000;;	  if ! ssh-add -L 1> /dev/null 2> /dev/null; then
0000000000000000000000000000000000000000;;	    kube::log::error "Could not find or add an SSH identity."
0000000000000000000000000000000000000000;;	    kube::log::error "Please start ssh-agent, add your identity, and retry."
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Verify that Photon Controller has been configured in the way we expect. Specifically
0000000000000000000000000000000000000000;;	# - Have the flavors been created?
0000000000000000000000000000000000000000;;	# - Has the image been uploaded?
0000000000000000000000000000000000000000;;	# TODO: Check the tenant and project as well.
0000000000000000000000000000000000000000;;	function verify-photon-config {
0000000000000000000000000000000000000000;;	  kube::log::status "Validating Photon configuration..."
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # We don't want silent failure: we check for failure
0000000000000000000000000000000000000000;;	  set +o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  verify-photon-flavors
0000000000000000000000000000000000000000;;	  verify-photon-image
0000000000000000000000000000000000000000;;	  verify-photon-tenant
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Reset default set in common.sh
0000000000000000000000000000000000000000;;	  set -o pipefail
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Verify that the VM and disk flavors have been created
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function verify-photon-flavors {
0000000000000000000000000000000000000000;;	  local rc=0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  ${PHOTON} flavor list | awk -F'\t' '{print $2}' | grep -q "^${PHOTON_MASTER_FLAVOR}$" > /dev/null 2>&1 || rc=$?
0000000000000000000000000000000000000000;;	  if [[ ${rc} -ne 0 ]]; then
0000000000000000000000000000000000000000;;	    kube::log::error "ERROR: Cannot find VM flavor named ${PHOTON_MASTER_FLAVOR}"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "${PHOTON_MASTER_FLAVOR}" != "${PHOTON_NODE_FLAVOR}" ]]; then
0000000000000000000000000000000000000000;;	    rc=0
0000000000000000000000000000000000000000;;	    ${PHOTON} flavor list | awk -F'\t' '{print $2}' | grep -q "^${PHOTON_NODE_FLAVOR}$" > /dev/null 2>&1 || rc=$?
0000000000000000000000000000000000000000;;	    if [[ ${rc} -ne 0 ]]; then
0000000000000000000000000000000000000000;;	      kube::log::error "ERROR: Cannot find VM flavor named ${PHOTON_NODE_FLAVOR}"
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  ${PHOTON} flavor list | awk -F'\t' '{print $2}' | grep -q "^${PHOTON_DISK_FLAVOR}$" > /dev/null 2>&1 || rc=$?
0000000000000000000000000000000000000000;;	  if [[ ${rc} -ne 0 ]]; then
0000000000000000000000000000000000000000;;	    kube::log::error "ERROR: Cannot find disk flavor named ${PHOTON_DISK_FLAVOR}"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Verify that we have the image we need, and it's not in error state or
0000000000000000000000000000000000000000;;	# multiple copies
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function verify-photon-image {
0000000000000000000000000000000000000000;;	  local rc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  rc=0
0000000000000000000000000000000000000000;;	  ${PHOTON} image list | grep -q $'\t'"${PHOTON_IMAGE}"$'\t'  > /dev/null 2>&1 || rc=$?
0000000000000000000000000000000000000000;;	  if [[ ${rc} -ne 0 ]]; then
0000000000000000000000000000000000000000;;	    kube::log::error "ERROR: Cannot find image \"${PHOTON_IMAGE}\""
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  rc=0
0000000000000000000000000000000000000000;;	  ${PHOTON} image list | grep $'\t'"${PHOTON_IMAGE}"$'\t' | grep ERROR > /dev/null 2>&1 || rc=$?
0000000000000000000000000000000000000000;;	  if [[ ${rc} -eq 0 ]]; then
0000000000000000000000000000000000000000;;	    echo "Warning: You have at least one ${PHOTON_IMAGE} image in the ERROR state. You may want to investigate."
0000000000000000000000000000000000000000;;	    echo "Images in the ERROR state will be ignored."
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  rc=0
0000000000000000000000000000000000000000;;	  num_images=$(${PHOTON} image list | grep $'\t'"${PHOTON_IMAGE}"$'\t' | grep -c READY)
0000000000000000000000000000000000000000;;	  if [[ "${num_images}" -gt 1 ]]; then
0000000000000000000000000000000000000000;;	    echo "ERROR: You have more than one READY ${PHOTON_IMAGE} image. Ensure there is only one"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function verify-photon-tenant {
0000000000000000000000000000000000000000;;	  local rc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  rc=0
0000000000000000000000000000000000000000;;	  ${PHOTON} tenant list | grep -q $'\t'"${PHOTON_TENANT}"  > /dev/null 2>&1 || rc=$?
0000000000000000000000000000000000000000;;	  if [[ ${rc} -ne 0 ]]; then
0000000000000000000000000000000000000000;;	    echo "ERROR: Cannot find tenant \"${PHOTON_TENANT}\""
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  ${PHOTON} project list --tenant "${PHOTON_TENANT}" | grep -q $'\t'"${PHOTON_PROJECT}"$'\t' > /dev/null 2>&1  || rc=$?
0000000000000000000000000000000000000000;;	  if [[ ${rc} -ne 0 ]]; then
0000000000000000000000000000000000000000;;	    echo "ERROR: Cannot find project \"${PHOTON_PROJECT}\""
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Verifies that a given command is in the PATH
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function verify-cmd-in-path {
0000000000000000000000000000000000000000;;	  cmd=${1}
0000000000000000000000000000000000000000;;	  which "${cmd}" >/dev/null || {
0000000000000000000000000000000000000000;;	    kube::log::error "Can't find ${cmd} in PATH, please install and retry."
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Repeatedly try a command over ssh until it succeeds or until five minutes have passed
0000000000000000000000000000000000000000;;	# The timeout isn't exact, since we assume the command runs instantaneously, and
0000000000000000000000000000000000000000;;	# it doesn't.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function try-until-success-ssh {
0000000000000000000000000000000000000000;;	  local vm_ip=${1}
0000000000000000000000000000000000000000;;	  local cmd_description=${2}
0000000000000000000000000000000000000000;;	  local cmd=${3}
0000000000000000000000000000000000000000;;	  local timeout=600
0000000000000000000000000000000000000000;;	  local sleep_time=5
0000000000000000000000000000000000000000;;	  local max_attempts
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  ((max_attempts=timeout/sleep_time))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::log::status "${cmd_description} for up to 10 minutes..."
0000000000000000000000000000000000000000;;	  local attempt=0
0000000000000000000000000000000000000000;;	  while true; do
0000000000000000000000000000000000000000;;	    local rc=0
0000000000000000000000000000000000000000;;	    run-ssh-cmd -i "${vm_ip}" "${cmd}" || rc=1
0000000000000000000000000000000000000000;;	    if [[ ${rc} != 0 ]]; then
0000000000000000000000000000000000000000;;	      if (( attempt == max_attempts )); then
0000000000000000000000000000000000000000;;	        kube::log::error "Failed, cannot proceed: you may need to retry to log into the VM to debug"
0000000000000000000000000000000000000000;;	        exit 1
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      break
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    attempt=$((attempt+1))
0000000000000000000000000000000000000000;;	    sleep ${sleep_time}
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function try-until-success {
0000000000000000000000000000000000000000;;	  local cmd_description=${1}
0000000000000000000000000000000000000000;;	  local cmd=${2}
0000000000000000000000000000000000000000;;	  local timeout=600
0000000000000000000000000000000000000000;;	  local sleep_time=5
0000000000000000000000000000000000000000;;	  local max_attempts
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  ((max_attempts=timeout/sleep_time))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::log::status "${cmd_description} for up to 10 minutes..."
0000000000000000000000000000000000000000;;	  local attempt=0
0000000000000000000000000000000000000000;;	  while true; do
0000000000000000000000000000000000000000;;	    local rc=0
0000000000000000000000000000000000000000;;	    run-cmd -i "${cmd}" || rc=1
0000000000000000000000000000000000000000;;	    if [[ ${rc} != 0 ]]; then
0000000000000000000000000000000000000000;;	      if (( attempt == max_attempts )); then
0000000000000000000000000000000000000000;;	        kube::log::error "Failed, cannot proceed"
0000000000000000000000000000000000000000;;	        exit 1
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      break
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    attempt=$((attempt+1))
0000000000000000000000000000000000000000;;	    sleep ${sleep_time}
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Sets up a trap handler
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function trap-add {
0000000000000000000000000000000000000000;;	  local handler="${1}"
0000000000000000000000000000000000000000;;	  local signal="${2-EXIT}"
0000000000000000000000000000000000000000;;	  local cur
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  cur="$(eval "sh -c 'echo \$3' -- $(trap -p ${signal})")"
0000000000000000000000000000000000000000;;	  if [[ -n "${cur}" ]]; then
0000000000000000000000000000000000000000;;	    handler="${cur}; ${handler}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # We want ${handler} to expand now, so tell shellcheck
0000000000000000000000000000000000000000;;	  # shellcheck disable=SC2064
0000000000000000000000000000000000000000;;	  trap "${handler}" ${signal}
0000000000000000000000000000000000000000;;	}
