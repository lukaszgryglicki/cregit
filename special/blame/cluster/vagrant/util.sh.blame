0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2014 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# A library of helper functions that each provider hosting Kubernetes must implement to use cluster/kube-*.sh scripts.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_ROOT=$(dirname "${BASH_SOURCE}")/../..
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/cluster/vagrant/${KUBE_CONFIG_FILE-"config-default.sh"}"
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/cluster/common.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function detect-master () {
0000000000000000000000000000000000000000;;	  KUBE_MASTER_IP=$MASTER_IP
0000000000000000000000000000000000000000;;	  echo "KUBE_MASTER_IP: ${KUBE_MASTER_IP}" 1>&2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Get node IP addresses and store in KUBE_NODE_IP_ADDRESSES[]
0000000000000000000000000000000000000000;;	function detect-nodes {
0000000000000000000000000000000000000000;;	  echo "Nodes already detected" 1>&2
0000000000000000000000000000000000000000;;	  KUBE_NODE_IP_ADDRESSES=("${NODE_IPS[@]}")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Verify prereqs on host machine  Also sets exports USING_KUBE_SCRIPTS=true so
0000000000000000000000000000000000000000;;	# that our Vagrantfile doesn't error out.
0000000000000000000000000000000000000000;;	function verify-prereqs {
0000000000000000000000000000000000000000;;	  for x in vagrant; do
0000000000000000000000000000000000000000;;	    if ! which "$x" >/dev/null; then
0000000000000000000000000000000000000000;;	      echo "Can't find $x in PATH, please fix and retry."
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local vagrant_plugins=$(vagrant plugin list | sed '-es% .*$%%' '-es%  *% %g' | tr ' ' $'\n')
0000000000000000000000000000000000000000;;	  local providers=(
0000000000000000000000000000000000000000;;	      # Format is:
0000000000000000000000000000000000000000;;	      #   provider_ctl_executable vagrant_provider_name vagrant_provider_plugin_re
0000000000000000000000000000000000000000;;	      # either provider_ctl_executable or vagrant_provider_plugin_re can
0000000000000000000000000000000000000000;;	      # be blank (i.e., '') if none is needed by Vagrant (see, e.g.,
0000000000000000000000000000000000000000;;	      # virtualbox entry)
0000000000000000000000000000000000000000;;	      '' vmware_fusion vagrant-vmware-fusion
0000000000000000000000000000000000000000;;	      '' vmware_workstation vagrant-vmware-workstation
0000000000000000000000000000000000000000;;	      prlctl parallels vagrant-parallels
0000000000000000000000000000000000000000;;	      VBoxManage virtualbox ''
0000000000000000000000000000000000000000;;	      virsh libvirt vagrant-libvirt
0000000000000000000000000000000000000000;;	      '' vsphere vagrant-vsphere
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	  local provider_found=''
0000000000000000000000000000000000000000;;	  local provider_bin
0000000000000000000000000000000000000000;;	  local provider_name
0000000000000000000000000000000000000000;;	  local provider_plugin_re
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  while [ "${#providers[@]}" -gt 0 ]; do
0000000000000000000000000000000000000000;;	    provider_bin=${providers[0]}
0000000000000000000000000000000000000000;;	    provider_name=${providers[1]}
0000000000000000000000000000000000000000;;	    provider_plugin_re=${providers[2]}
0000000000000000000000000000000000000000;;	    providers=("${providers[@]:3}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # If the provider is explicitly set, look only for that provider
0000000000000000000000000000000000000000;;	    if [ -n "${VAGRANT_DEFAULT_PROVIDER:-}" ] \
0000000000000000000000000000000000000000;;	        && [ "${VAGRANT_DEFAULT_PROVIDER}" != "${provider_name}" ]; then
0000000000000000000000000000000000000000;;	      continue
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if ([ -z "${provider_bin}" ] \
0000000000000000000000000000000000000000;;	          || which "${provider_bin}" >/dev/null 2>&1) \
0000000000000000000000000000000000000000;;	        && ([ -z "${provider_plugin_re}" ] \
0000000000000000000000000000000000000000;;	          || [ -n "$(echo "${vagrant_plugins}" | grep -E "^${provider_plugin_re}$")" ]); then
0000000000000000000000000000000000000000;;	      provider_found="${provider_name}"
0000000000000000000000000000000000000000;;	      # Stop after finding the first viable provider
0000000000000000000000000000000000000000;;	      break
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [ -z "${provider_found}" ]; then
0000000000000000000000000000000000000000;;	    if [ -n "${VAGRANT_DEFAULT_PROVIDER:-}" ]; then
0000000000000000000000000000000000000000;;	      echo "Can't find the necessary components for the ${VAGRANT_DEFAULT_PROVIDER} vagrant provider."
0000000000000000000000000000000000000000;;	      echo "Possible reasons could be: "
0000000000000000000000000000000000000000;;	      echo -e "\t- vmrun utility is not in your path"
0000000000000000000000000000000000000000;;	      echo -e "\t- Vagrant plugin was not found."
0000000000000000000000000000000000000000;;	      echo -e "\t- VAGRANT_DEFAULT_PROVIDER is set, but not found."
0000000000000000000000000000000000000000;;	      echo "Please fix and retry."
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      echo "Can't find the necessary components for any viable vagrant providers (e.g., virtualbox), please fix and retry."
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Set VAGRANT_CWD to KUBE_ROOT so that we find the right Vagrantfile no
0000000000000000000000000000000000000000;;	  # matter what directory the tools are called from.
0000000000000000000000000000000000000000;;	  export VAGRANT_CWD="${KUBE_ROOT}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  export USING_KUBE_SCRIPTS=true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Create a set of provision scripts for the master and each of the nodes
0000000000000000000000000000000000000000;;	function create-provision-scripts {
0000000000000000000000000000000000000000;;	  kube::util::ensure-temp-dir
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  (
0000000000000000000000000000000000000000;;	    echo "#! /bin/bash"
0000000000000000000000000000000000000000;;	    echo-kube-env
0000000000000000000000000000000000000000;;	    echo "NODE_IP='${MASTER_IP}'"
0000000000000000000000000000000000000000;;	    echo "CONTAINER_ADDR='${MASTER_CONTAINER_ADDR}'"
0000000000000000000000000000000000000000;;	    echo "CONTAINER_NETMASK='${MASTER_CONTAINER_NETMASK}'"
0000000000000000000000000000000000000000;;	    awk '!/^#/' "${KUBE_ROOT}/cluster/vagrant/provision-utils.sh"
0000000000000000000000000000000000000000;;	    awk '!/^#/' "${KUBE_ROOT}/cluster/vagrant/provision-network-master.sh"
0000000000000000000000000000000000000000;;	    awk '!/^#/' "${KUBE_ROOT}/cluster/vagrant/provision-master.sh"
0000000000000000000000000000000000000000;;	  ) > "${KUBE_TEMP}/master-start.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for (( i=0; i<${#NODE_NAMES[@]}; i++)); do
0000000000000000000000000000000000000000;;	    (
0000000000000000000000000000000000000000;;	      echo "#! /bin/bash"
0000000000000000000000000000000000000000;;	      echo-kube-env
0000000000000000000000000000000000000000;;	      echo "NODE_NAME=(${NODE_NAMES[$i]})"
0000000000000000000000000000000000000000;;	      echo "NODE_IP='${NODE_IPS[$i]}'"
0000000000000000000000000000000000000000;;	      echo "NODE_ID='$i'"
0000000000000000000000000000000000000000;;	      echo "CONTAINER_ADDR='${NODE_CONTAINER_ADDRS[$i]}'"
0000000000000000000000000000000000000000;;	      echo "CONTAINER_NETMASK='${NODE_CONTAINER_NETMASKS[$i]}'"
0000000000000000000000000000000000000000;;	      awk '!/^#/' "${KUBE_ROOT}/cluster/vagrant/provision-utils.sh"
0000000000000000000000000000000000000000;;	      awk '!/^#/' "${KUBE_ROOT}/cluster/vagrant/provision-network-node.sh"
0000000000000000000000000000000000000000;;	      awk '!/^#/' "${KUBE_ROOT}/cluster/vagrant/provision-node.sh"
0000000000000000000000000000000000000000;;	    ) > "${KUBE_TEMP}/node-start-${i}.sh"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function echo-kube-env() {
0000000000000000000000000000000000000000;;	  echo "KUBE_ROOT=/vagrant"
0000000000000000000000000000000000000000;;	  echo "INSTANCE_PREFIX='${INSTANCE_PREFIX}'"
0000000000000000000000000000000000000000;;	  echo "MASTER_NAME='${INSTANCE_PREFIX}-master'"
0000000000000000000000000000000000000000;;	  echo "MASTER_IP='${MASTER_IP}'"
0000000000000000000000000000000000000000;;	  echo "NODE_NAMES=(${NODE_NAMES[@]})"
0000000000000000000000000000000000000000;;	  echo "NODE_IPS=(${NODE_IPS[@]})"
0000000000000000000000000000000000000000;;	  echo "DEFAULT_NETWORK_IF_NAME=${DEFAULT_NETWORK_IF_NAME}"
0000000000000000000000000000000000000000;;	  echo "CONTAINER_SUBNET='${CONTAINER_SUBNET}'"
0000000000000000000000000000000000000000;;	  echo "CLUSTER_IP_RANGE='${CLUSTER_IP_RANGE}'"
0000000000000000000000000000000000000000;;	  echo "MASTER_CONTAINER_SUBNET='${MASTER_CONTAINER_SUBNET}'"
0000000000000000000000000000000000000000;;	  echo "NODE_CONTAINER_NETMASKS='${NODE_CONTAINER_NETMASKS[@]}'"
0000000000000000000000000000000000000000;;	  echo "NODE_CONTAINER_SUBNETS=(${NODE_CONTAINER_SUBNETS[@]})"
0000000000000000000000000000000000000000;;	  echo "SERVICE_CLUSTER_IP_RANGE='${SERVICE_CLUSTER_IP_RANGE}'"
0000000000000000000000000000000000000000;;	  echo "MASTER_USER='${MASTER_USER}'"
0000000000000000000000000000000000000000;;	  echo "MASTER_PASSWD='${MASTER_PASSWD}'"
0000000000000000000000000000000000000000;;	  echo "KUBE_USER='${KUBE_USER}'"
0000000000000000000000000000000000000000;;	  echo "KUBE_PASSWORD='${KUBE_PASSWORD}'"
0000000000000000000000000000000000000000;;	  echo "KUBE_BEARER_TOKEN='${KUBE_BEARER_TOKEN}'"
0000000000000000000000000000000000000000;;	  echo "ENABLE_CLUSTER_MONITORING='${ENABLE_CLUSTER_MONITORING}'"
0000000000000000000000000000000000000000;;	  echo "ENABLE_CLUSTER_LOGGING='${ENABLE_CLUSTER_LOGGING:-false}'"
0000000000000000000000000000000000000000;;	  echo "ELASTICSEARCH_LOGGING_REPLICAS='${ELASTICSEARCH_LOGGING_REPLICAS:-1}'"
0000000000000000000000000000000000000000;;	  echo "ENABLE_NODE_LOGGING='${ENABLE_NODE_LOGGING:-false}'"
0000000000000000000000000000000000000000;;	  echo "ENABLE_CLUSTER_UI='${ENABLE_CLUSTER_UI}'"
0000000000000000000000000000000000000000;;	  echo "ENABLE_HOSTPATH_PROVISIONER='${ENABLE_HOSTPATH_PROVISIONER:-false}'"
0000000000000000000000000000000000000000;;	  echo "LOGGING_DESTINATION='${LOGGING_DESTINATION:-}'"
0000000000000000000000000000000000000000;;	  echo "ENABLE_CLUSTER_DNS='${ENABLE_CLUSTER_DNS:-false}'"
0000000000000000000000000000000000000000;;	  echo "DNS_SERVER_IP='${DNS_SERVER_IP:-}'"
0000000000000000000000000000000000000000;;	  echo "DNS_DOMAIN='${DNS_DOMAIN:-}'"
0000000000000000000000000000000000000000;;	  echo "RUNTIME_CONFIG='${RUNTIME_CONFIG:-}'"
0000000000000000000000000000000000000000;;	  echo "ADMISSION_CONTROL='${ADMISSION_CONTROL:-}'"
0000000000000000000000000000000000000000;;	  echo "DOCKER_OPTS='${EXTRA_DOCKER_OPTS:-}'"
0000000000000000000000000000000000000000;;	  echo "VAGRANT_DEFAULT_PROVIDER='${VAGRANT_DEFAULT_PROVIDER:-}'"
0000000000000000000000000000000000000000;;	  echo "KUBELET_TOKEN='${KUBELET_TOKEN:-}'"
0000000000000000000000000000000000000000;;	  echo "KUBE_PROXY_TOKEN='${KUBE_PROXY_TOKEN:-}'"
0000000000000000000000000000000000000000;;	  echo "MASTER_EXTRA_SANS='${MASTER_EXTRA_SANS:-}'"
0000000000000000000000000000000000000000;;	  echo "ENABLE_CPU_CFS_QUOTA='${ENABLE_CPU_CFS_QUOTA}'"
0000000000000000000000000000000000000000;;	  echo "NETWORK_PROVIDER='${NETWORK_PROVIDER:-}'"
0000000000000000000000000000000000000000;;	  echo "OPENCONTRAIL_TAG='${OPENCONTRAIL_TAG:-}'"
0000000000000000000000000000000000000000;;	  echo "OPENCONTRAIL_KUBERNETES_TAG='${OPENCONTRAIL_KUBERNETES_TAG:-}'"
0000000000000000000000000000000000000000;;	  echo "OPENCONTRAIL_PUBLIC_SUBNET='${OPENCONTRAIL_PUBLIC_SUBNET:-}'"
0000000000000000000000000000000000000000;;	  echo "E2E_STORAGE_TEST_ENVIRONMENT='${E2E_STORAGE_TEST_ENVIRONMENT:-}'"
0000000000000000000000000000000000000000;;	  echo "CUSTOM_FEDORA_REPOSITORY_URL='${CUSTOM_FEDORA_REPOSITORY_URL:-}'"
0000000000000000000000000000000000000000;;	  echo "EVICTION_HARD='${EVICTION_HARD:-}'"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function verify-cluster {
0000000000000000000000000000000000000000;;	  # TODO: How does the user know the difference between "tak[ing] some
0000000000000000000000000000000000000000;;	  # time" and "loop[ing] forever"? Can we give more specific feedback on
0000000000000000000000000000000000000000;;	  # whether "an error" has occurred?
0000000000000000000000000000000000000000;;	  echo "Each machine instance has been created/updated."
0000000000000000000000000000000000000000;;	  echo "  Now waiting for the Salt provisioning process to complete on each machine."
0000000000000000000000000000000000000000;;	  echo "  This can take some time based on your network, disk, and cpu speed."
0000000000000000000000000000000000000000;;	  echo "  It is possible for an error to occur during Salt provision of cluster and this could loop forever."
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # verify master has all required daemons
0000000000000000000000000000000000000000;;	  echo "Validating master"
0000000000000000000000000000000000000000;;	  local machine="master"
0000000000000000000000000000000000000000;;	  local -a required_processes=("kube-apiserver" "kube-scheduler" "kube-controller-manager" "kubelet" "docker")
0000000000000000000000000000000000000000;;	  local validated="1"
0000000000000000000000000000000000000000;;	  until [[ "$validated" == "0" ]]; do
0000000000000000000000000000000000000000;;	    validated="0"
0000000000000000000000000000000000000000;;	    for process in "${required_processes[@]}"; do
0000000000000000000000000000000000000000;;	      vagrant ssh "${machine}" -c "pgrep -f ${process}" >/dev/null 2>&1 || {
0000000000000000000000000000000000000000;;	        printf "."
0000000000000000000000000000000000000000;;	        validated="1"
0000000000000000000000000000000000000000;;	        sleep 2
0000000000000000000000000000000000000000;;	      }
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # verify each node has all required daemons
0000000000000000000000000000000000000000;;	  local i
0000000000000000000000000000000000000000;;	  for (( i=0; i<${#NODE_NAMES[@]}; i++)); do
0000000000000000000000000000000000000000;;	    echo "Validating ${VAGRANT_NODE_NAMES[$i]}"
0000000000000000000000000000000000000000;;	    local machine=${VAGRANT_NODE_NAMES[$i]}
0000000000000000000000000000000000000000;;	    local -a required_processes=("kube-proxy" "kubelet" "docker")
0000000000000000000000000000000000000000;;	    local validated="1"
0000000000000000000000000000000000000000;;	    until [[ "${validated}" == "0" ]]; do
0000000000000000000000000000000000000000;;	      validated="0"
0000000000000000000000000000000000000000;;	      for process in "${required_processes[@]}"; do
0000000000000000000000000000000000000000;;	        vagrant ssh "${machine}" -c "pgrep -f ${process}" >/dev/null 2>&1 || {
0000000000000000000000000000000000000000;;	          printf "."
0000000000000000000000000000000000000000;;	          validated="1"
0000000000000000000000000000000000000000;;	          sleep 2
0000000000000000000000000000000000000000;;	        }
0000000000000000000000000000000000000000;;	      done
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo "Waiting for each node to be registered with cloud provider"
0000000000000000000000000000000000000000;;	  for (( i=0; i<${#NODE_NAMES[@]}; i++)); do
0000000000000000000000000000000000000000;;	    local validated="0"
0000000000000000000000000000000000000000;;	    start="$(date +%s)"
0000000000000000000000000000000000000000;;	    until [[ "$validated" == "1" ]]; do
0000000000000000000000000000000000000000;;	      now="$(date +%s)"
0000000000000000000000000000000000000000;;	      # Timeout set to 3 minutes
0000000000000000000000000000000000000000;;	      if [ $((now - start)) -gt 180 ]; then
0000000000000000000000000000000000000000;;	        echo "Timeout while waiting for echo node to be registered with cloud provider"
0000000000000000000000000000000000000000;;	        exit 2
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	      local nodes=$("${KUBE_ROOT}/cluster/kubectl.sh" get nodes -o name)
0000000000000000000000000000000000000000;;	      validated=$(echo $nodes | grep -c "${NODE_NAMES[i]}") || {
0000000000000000000000000000000000000000;;	        printf "."
0000000000000000000000000000000000000000;;	        sleep 2
0000000000000000000000000000000000000000;;	        validated="0"
0000000000000000000000000000000000000000;;	      }
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # By this time, all kube api calls should work, so no need to loop and retry.
0000000000000000000000000000000000000000;;	  echo "Validating we can run kubectl commands."
0000000000000000000000000000000000000000;;	  vagrant ssh master --command "kubectl get pods" || {
0000000000000000000000000000000000000000;;	    echo "WARNING: kubectl to localhost failed.  This could mean localhost is not bound to an IP"
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  (
0000000000000000000000000000000000000000;;	    # ensures KUBECONFIG is set
0000000000000000000000000000000000000000;;	    get-kubeconfig-basicauth
0000000000000000000000000000000000000000;;	    get-kubeconfig-bearertoken
0000000000000000000000000000000000000000;;	    echo
0000000000000000000000000000000000000000;;	    echo "Kubernetes cluster is running."
0000000000000000000000000000000000000000;;	    echo
0000000000000000000000000000000000000000;;	    echo "The master is running at:"
0000000000000000000000000000000000000000;;	    echo
0000000000000000000000000000000000000000;;	    echo "  https://${MASTER_IP}"
0000000000000000000000000000000000000000;;	    echo
0000000000000000000000000000000000000000;;	    echo "Administer and visualize its resources using Cockpit:"
0000000000000000000000000000000000000000;;	    echo
0000000000000000000000000000000000000000;;	    echo "  https://${MASTER_IP}:9090"
0000000000000000000000000000000000000000;;	    echo
0000000000000000000000000000000000000000;;	    echo "For more information on Cockpit, visit http://cockpit-project.org"
0000000000000000000000000000000000000000;;	    echo
0000000000000000000000000000000000000000;;	    echo "The user name and password to use is located in ${KUBECONFIG}"
0000000000000000000000000000000000000000;;	    echo
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Instantiate a kubernetes cluster
0000000000000000000000000000000000000000;;	function kube-up {
0000000000000000000000000000000000000000;;	  load-or-gen-kube-basicauth
0000000000000000000000000000000000000000;;	  load-or-gen-kube-bearertoken
0000000000000000000000000000000000000000;;	  get-tokens
0000000000000000000000000000000000000000;;	  create-provision-scripts
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  vagrant up --no-parallel
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  export KUBE_CERT="/tmp/$RANDOM-kubecfg.crt"
0000000000000000000000000000000000000000;;	  export KUBE_KEY="/tmp/$RANDOM-kubecfg.key"
0000000000000000000000000000000000000000;;	  export CA_CERT="/tmp/$RANDOM-kubernetes.ca.crt"
0000000000000000000000000000000000000000;;	  export CONTEXT="vagrant"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  (
0000000000000000000000000000000000000000;;	   umask 077
0000000000000000000000000000000000000000;;	   vagrant ssh master -- sudo cat /srv/kubernetes/kubecfg.crt >"${KUBE_CERT}" 2>/dev/null
0000000000000000000000000000000000000000;;	   vagrant ssh master -- sudo cat /srv/kubernetes/kubecfg.key >"${KUBE_KEY}" 2>/dev/null
0000000000000000000000000000000000000000;;	   vagrant ssh master -- sudo cat /srv/kubernetes/ca.crt >"${CA_CERT}" 2>/dev/null
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	   # Update the user's kubeconfig to include credentials for this apiserver.
0000000000000000000000000000000000000000;;	   create-kubeconfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	   create-kubeconfig-for-federation
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  verify-cluster
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Delete a kubernetes cluster
0000000000000000000000000000000000000000;;	function kube-down {
0000000000000000000000000000000000000000;;	  vagrant destroy -f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Update a kubernetes cluster with latest source
0000000000000000000000000000000000000000;;	function kube-push {
0000000000000000000000000000000000000000;;	  get-kubeconfig-basicauth
0000000000000000000000000000000000000000;;	  get-kubeconfig-bearertoken
0000000000000000000000000000000000000000;;	  create-provision-scripts
0000000000000000000000000000000000000000;;	  vagrant provision
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Execute prior to running tests to build a release if required for env
0000000000000000000000000000000000000000;;	function test-build-release {
0000000000000000000000000000000000000000;;	  # Make a release
0000000000000000000000000000000000000000;;	  "${KUBE_ROOT}/build/release.sh"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Execute prior to running tests to initialize required structure
0000000000000000000000000000000000000000;;	function test-setup {
0000000000000000000000000000000000000000;;	  "${KUBE_ROOT}/cluster/kube-up.sh"
0000000000000000000000000000000000000000;;	  echo "Vagrant test setup complete" 1>&2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Execute after running tests to perform any required clean-up
0000000000000000000000000000000000000000;;	function test-teardown {
0000000000000000000000000000000000000000;;	  kube-down
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Find the node name based on the IP address
0000000000000000000000000000000000000000;;	function find-vagrant-name-by-ip {
0000000000000000000000000000000000000000;;	  local ip="$1"
0000000000000000000000000000000000000000;;	  local ip_pattern="${NODE_IP_BASE}(.*)"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # This is subtle.  We map 10.245.2.2 -> node-1.  We do this by matching a
0000000000000000000000000000000000000000;;	  # regexp and using the capture to construct the name.
0000000000000000000000000000000000000000;;	  [[ $ip =~ $ip_pattern ]] || {
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "node-$((${BASH_REMATCH[1]} - 1))"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Find the vagrant machine name based on the host name of the node
0000000000000000000000000000000000000000;;	function find-vagrant-name-by-node-name {
0000000000000000000000000000000000000000;;	  local ip="$1"
0000000000000000000000000000000000000000;;	  if [[ "$ip" == "${INSTANCE_PREFIX}-master" ]]; then
0000000000000000000000000000000000000000;;	    echo "master"
0000000000000000000000000000000000000000;;	    return $?
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  local ip_pattern="${INSTANCE_PREFIX}-node-(.*)"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  [[ $ip =~ $ip_pattern ]] || {
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "node-${BASH_REMATCH[1]}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# SSH to a node by name or IP ($1) and run a command ($2).
0000000000000000000000000000000000000000;;	function ssh-to-node {
0000000000000000000000000000000000000000;;	  local node="$1"
0000000000000000000000000000000000000000;;	  local cmd="$2"
0000000000000000000000000000000000000000;;	  local machine
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  machine=$(find-vagrant-name-by-ip $node) || true
0000000000000000000000000000000000000000;;	  [[ -n ${machine-} ]] || machine=$(find-vagrant-name-by-node-name $node) || true
0000000000000000000000000000000000000000;;	  [[ -n ${machine-} ]] || {
0000000000000000000000000000000000000000;;	    echo "Cannot find machine to ssh to: $1"
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  vagrant ssh "${machine}" -c "${cmd}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Perform preparations required to run e2e tests
0000000000000000000000000000000000000000;;	function prepare-e2e() {
0000000000000000000000000000000000000000;;	  echo "Vagrant doesn't need special preparations for e2e tests" 1>&2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function get-tokens() {
0000000000000000000000000000000000000000;;	  KUBELET_TOKEN=$(dd if=/dev/urandom bs=128 count=1 2>/dev/null | base64 | tr -d "=+/" | dd bs=32 count=1 2>/dev/null)
0000000000000000000000000000000000000000;;	  KUBE_PROXY_TOKEN=$(dd if=/dev/urandom bs=128 count=1 2>/dev/null | base64 | tr -d "=+/" | dd bs=32 count=1 2>/dev/null)
0000000000000000000000000000000000000000;;	}
