0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2014 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# A library of helper functions and constant for the local config.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Uses the config file specified in $KUBE_CONFIG_FILE, or defaults to config-default.sh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_PROMPT_FOR_UPDATE=${KUBE_PROMPT_FOR_UPDATE:-"n"}
0000000000000000000000000000000000000000;;	KUBE_ROOT=$(dirname "${BASH_SOURCE}")/../..
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/cluster/gke/${KUBE_CONFIG_FILE:-config-default.sh}"
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/cluster/common.sh"
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/hack/lib/util.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function with-retry() {
0000000000000000000000000000000000000000;;	  local retry_limit=$1
0000000000000000000000000000000000000000;;	  local cmd=("${@:2}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local retry_count=0
0000000000000000000000000000000000000000;;	  local rc=0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  until [[ ${retry_count} -ge ${retry_limit} ]]; do
0000000000000000000000000000000000000000;;	    ((retry_count+=1))
0000000000000000000000000000000000000000;;	    "${cmd[@]}" && rc=0 || rc=$?
0000000000000000000000000000000000000000;;	    if [[ ${rc} == 0 ]]; then
0000000000000000000000000000000000000000;;	      return 0
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    sleep 3
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  return ${rc}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Perform preparations required to run e2e tests
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   GCLOUD
0000000000000000000000000000000000000000;;	function prepare-e2e() {
0000000000000000000000000000000000000000;;	  echo "... in gke:prepare-e2e()" >&2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Ensure GCLOUD is set to some gcloud binary.
0000000000000000000000000000000000000000;;	  if [[ -z "${GCLOUD:-}" ]]; then
0000000000000000000000000000000000000000;;	    echo "GCLOUD environment variable is not set. It should be your gcloud binary. " >&2
0000000000000000000000000000000000000000;;	    echo "A sane default is probably \$ export GCLOUD=gcloud" >&2
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Use the gcloud defaults to find the project.  If it is already set in the
0000000000000000000000000000000000000000;;	# environment then go with that.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   GCLOUD
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   PROJECT
0000000000000000000000000000000000000000;;	function detect-project() {
0000000000000000000000000000000000000000;;	  echo "... in gke:detect-project()" >&2
0000000000000000000000000000000000000000;;	  if [[ -z "${PROJECT:-}" ]]; then
0000000000000000000000000000000000000000;;	    export PROJECT=$("${GCLOUD}" config list project --format 'value(core.project)')
0000000000000000000000000000000000000000;;	    echo "... Using project: ${PROJECT}" >&2
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [[ -z "${PROJECT:-}" ]]; then
0000000000000000000000000000000000000000;;	    echo "Could not detect Google Cloud Platform project. Set the default project using " >&2
0000000000000000000000000000000000000000;;	    echo "'gcloud config set project <PROJECT>'" >&2
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Execute prior to running tests to build a release if required for env.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed Vars:
0000000000000000000000000000000000000000;;	#   KUBE_ROOT
0000000000000000000000000000000000000000;;	function test-build-release() {
0000000000000000000000000000000000000000;;	  echo "... in gke:test-build-release()" >&2
0000000000000000000000000000000000000000;;	  "${KUBE_ROOT}/build/release.sh"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Verify needed binaries exist.
0000000000000000000000000000000000000000;;	function verify-prereqs() {
0000000000000000000000000000000000000000;;	  echo "... in gke:verify-prereqs()" >&2
0000000000000000000000000000000000000000;;	  if ! which gcloud >/dev/null; then
0000000000000000000000000000000000000000;;	    local resp
0000000000000000000000000000000000000000;;	    if [[ "${KUBE_PROMPT_FOR_UPDATE}" == "y" ]]; then
0000000000000000000000000000000000000000;;	      echo "Can't find gcloud in PATH.  Do you wish to install the Google Cloud SDK? [Y/n]"
0000000000000000000000000000000000000000;;	      read resp
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [[ "${resp}" != "n" && "${resp}" != "N" ]]; then
0000000000000000000000000000000000000000;;	      curl https://sdk.cloud.google.com | bash
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if ! which gcloud >/dev/null; then
0000000000000000000000000000000000000000;;	      echo "Can't find gcloud in PATH, please fix and retry. The Google Cloud "
0000000000000000000000000000000000000000;;	      echo "SDK can be downloaded from https://cloud.google.com/sdk/."
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  update-or-verify-gcloud
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Validate a kubernetes cluster
0000000000000000000000000000000000000000;;	function validate-cluster {
0000000000000000000000000000000000000000;;	  # Simply override the NUM_NODES variable if we've spread nodes across multiple
0000000000000000000000000000000000000000;;	  # zones before calling into the generic validate-cluster logic.
0000000000000000000000000000000000000000;;	  local EXPECTED_NUM_NODES="${NUM_NODES}"
0000000000000000000000000000000000000000;;	  for zone in $(echo "${ADDITIONAL_ZONES}" | sed "s/,/ /g")
0000000000000000000000000000000000000000;;	  do
0000000000000000000000000000000000000000;;	    (( EXPECTED_NUM_NODES += NUM_NODES ))
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  NUM_NODES=${EXPECTED_NUM_NODES} bash -c "${KUBE_ROOT}/cluster/validate-cluster.sh"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Instantiate a kubernetes cluster
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   GCLOUD
0000000000000000000000000000000000000000;;	#   CLUSTER_NAME
0000000000000000000000000000000000000000;;	#   ZONE
0000000000000000000000000000000000000000;;	#   CLUSTER_API_VERSION (optional)
0000000000000000000000000000000000000000;;	#   NUM_NODES
0000000000000000000000000000000000000000;;	#   ADDITIONAL_ZONES (optional)
0000000000000000000000000000000000000000;;	#   NODE_SCOPES
0000000000000000000000000000000000000000;;	#   MACHINE_TYPE
0000000000000000000000000000000000000000;;	#   HEAPSTER_MACHINE_TYPE (optional)
0000000000000000000000000000000000000000;;	#   CLUSTER_IP_RANGE (optional)
0000000000000000000000000000000000000000;;	#   GKE_CREATE_FLAGS (optional, space delineated)
0000000000000000000000000000000000000000;;	#   ENABLE_KUBERNETES_ALPHA (optional)
0000000000000000000000000000000000000000;;	function kube-up() {
0000000000000000000000000000000000000000;;	  echo "... in gke:kube-up()" >&2
0000000000000000000000000000000000000000;;	  detect-project >&2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Make the specified network if we need to.
0000000000000000000000000000000000000000;;	  if ! "${GCLOUD}" compute networks --project "${PROJECT}" describe "${NETWORK}" &>/dev/null; then
0000000000000000000000000000000000000000;;	    echo "Creating new network: ${NETWORK}" >&2
0000000000000000000000000000000000000000;;	    with-retry 3 "${GCLOUD}" compute networks create "${NETWORK}" --project="${PROJECT}" --mode=auto
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    echo "... Using network: ${NETWORK}" >&2
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Allow SSH on all nodes in the network. This doesn't actually check whether
0000000000000000000000000000000000000000;;	  # such a rule exists, only whether we've created this exact rule.
0000000000000000000000000000000000000000;;	  if ! "${GCLOUD}" compute firewall-rules --project "${PROJECT}" describe "${FIREWALL_SSH}" &>/dev/null; then
0000000000000000000000000000000000000000;;	    echo "Creating new firewall for SSH: ${FIREWALL_SSH}" >&2
0000000000000000000000000000000000000000;;	    with-retry 3 "${GCLOUD}" compute firewall-rules create "${FIREWALL_SSH}" \
0000000000000000000000000000000000000000;;	      --allow="tcp:22" \
0000000000000000000000000000000000000000;;	      --network="${NETWORK}" \
0000000000000000000000000000000000000000;;	      --project="${PROJECT}" \
0000000000000000000000000000000000000000;;	      --source-ranges="0.0.0.0/0"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    echo "... Using firewall-rule: ${FIREWALL_SSH}" >&2
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local shared_args=(
0000000000000000000000000000000000000000;;	    "--zone=${ZONE}"
0000000000000000000000000000000000000000;;	    "--project=${PROJECT}"
0000000000000000000000000000000000000000;;	    "--scopes=${NODE_SCOPES}"
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ ! -z "${IMAGE_TYPE:-}" ]]; then
0000000000000000000000000000000000000000;;	    shared_args+=("--image-type=${IMAGE_TYPE}")
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ -z "${HEAPSTER_MACHINE_TYPE:-}" ]]; then
0000000000000000000000000000000000000000;;	    local -r nodes="${NUM_NODES}"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    local -r nodes=$(( NUM_NODES - 1 ))
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local create_args=(
0000000000000000000000000000000000000000;;	    ${shared_args[@]}
0000000000000000000000000000000000000000;;	    "--num-nodes=${nodes}"
0000000000000000000000000000000000000000;;	    "--network=${NETWORK}"
0000000000000000000000000000000000000000;;	    "--cluster-version=${CLUSTER_API_VERSION}"
0000000000000000000000000000000000000000;;	    "--machine-type=${MACHINE_TYPE}"
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ ! -z "${ENABLE_KUBERNETES_ALPHA:-}" ]]; then
0000000000000000000000000000000000000000;;	    create_args+=("--enable-kubernetes-alpha")
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ ! -z "${ADDITIONAL_ZONES:-}" ]]; then
0000000000000000000000000000000000000000;;	    create_args+=("--additional-zones=${ADDITIONAL_ZONES}")
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ ! -z "${CLUSTER_IP_RANGE:-}" ]]; then
0000000000000000000000000000000000000000;;	    create_args+=("--cluster-ipv4-cidr=${CLUSTER_IP_RANGE}")
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ ! -z "${ENABLE_LEGACY_ABAC:-}" ]]; then
0000000000000000000000000000000000000000;;	    if [[ "${ENABLE_LEGACY_ABAC:-}" == "true" ]]; then
0000000000000000000000000000000000000000;;	      create_args+=("--enable-legacy-authorization")
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      create_args+=("--no-enable-legacy-authorization")
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  create_args+=( ${GKE_CREATE_FLAGS:-} )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Bring up the cluster.
0000000000000000000000000000000000000000;;	  "${GCLOUD}" ${CMD_GROUP:-} container clusters create "${CLUSTER_NAME}" "${create_args[@]}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  create-kubeconfig-for-federation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ ! -z "${HEAPSTER_MACHINE_TYPE:-}" ]]; then
0000000000000000000000000000000000000000;;	    "${GCLOUD}" ${CMD_GROUP:-} container node-pools create "heapster-pool" --cluster "${CLUSTER_NAME}" --num-nodes=1 --machine-type="${HEAPSTER_MACHINE_TYPE}" "${shared_args[@]}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Execute prior to running tests to initialize required structure. This is
0000000000000000000000000000000000000000;;	# called from hack/e2e-go only when running -up (it is run after kube-up, so
0000000000000000000000000000000000000000;;	# the cluster already exists at this point).
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   CLUSTER_NAME
0000000000000000000000000000000000000000;;	#   GCLOUD
0000000000000000000000000000000000000000;;	#   ZONE
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   NODE_TAG
0000000000000000000000000000000000000000;;	function test-setup() {
0000000000000000000000000000000000000000;;	  echo "... in gke:test-setup()" >&2
0000000000000000000000000000000000000000;;	  # Detect the project into $PROJECT if it isn't set
0000000000000000000000000000000000000000;;	  detect-project >&2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  "${KUBE_ROOT}/cluster/kube-up.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  detect-nodes >&2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # At this point, CLUSTER_NAME should have been used, so its value is final.
0000000000000000000000000000000000000000;;	  NODE_TAG=$($GCLOUD compute instances describe ${NODE_NAMES[0]} --project="${PROJECT}" --zone="${ZONE}" --format='value(tags.items)' | grep -o "gke-${CLUSTER_NAME}-.\{8\}-node")
0000000000000000000000000000000000000000;;	  OLD_NODE_TAG="k8s-${CLUSTER_NAME}-node"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Open up port 80 & 8080 so common containers on minions can be reached.
0000000000000000000000000000000000000000;;	  with-retry 3 "${GCLOUD}" compute firewall-rules create \
0000000000000000000000000000000000000000;;	    "${CLUSTER_NAME}-http-alt" \
0000000000000000000000000000000000000000;;	    --allow tcp:80,tcp:8080 \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --target-tags "${NODE_TAG},${OLD_NODE_TAG}" \
0000000000000000000000000000000000000000;;	    --network="${NETWORK}" &
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  with-retry 3 "${GCLOUD}" compute firewall-rules create \
0000000000000000000000000000000000000000;;	    "${CLUSTER_NAME}-nodeports" \
0000000000000000000000000000000000000000;;	    --allow tcp:30000-32767,udp:30000-32767 \
0000000000000000000000000000000000000000;;	    --project "${PROJECT}" \
0000000000000000000000000000000000000000;;	    --target-tags "${NODE_TAG},${OLD_NODE_TAG}" \
0000000000000000000000000000000000000000;;	    --network="${NETWORK}" &
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Wait for firewall rules.
0000000000000000000000000000000000000000;;	  kube::util::wait-for-jobs || {
0000000000000000000000000000000000000000;;	    echo "... gke:test-setup(): Could not create firewall" >&2
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Detect the IP for the master. Note that on GKE, we don't know the name of the
0000000000000000000000000000000000000000;;	# master, so KUBE_MASTER is not set.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   ZONE
0000000000000000000000000000000000000000;;	#   CLUSTER_NAME
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   KUBE_MASTER_IP
0000000000000000000000000000000000000000;;	function detect-master() {
0000000000000000000000000000000000000000;;	  echo "... in gke:detect-master()" >&2
0000000000000000000000000000000000000000;;	  detect-project >&2
0000000000000000000000000000000000000000;;	  KUBE_MASTER_IP=$("${GCLOUD}" ${CMD_GROUP:-} container clusters describe \
0000000000000000000000000000000000000000;;	    --project="${PROJECT}" --zone="${ZONE}" --format='value(endpoint)' \
0000000000000000000000000000000000000000;;	    "${CLUSTER_NAME}")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   none
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   NODE_NAMES
0000000000000000000000000000000000000000;;	function detect-nodes() {
0000000000000000000000000000000000000000;;	  echo "... in gke:detect-nodes()" >&2
0000000000000000000000000000000000000000;;	  detect-node-names
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Detect minions created in the minion group
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Note that this will only select nodes in the same zone as the
0000000000000000000000000000000000000000;;	# cluster, meaning that it won't include all nodes in a multi-zone cluster.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   none
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   NODE_NAMES
0000000000000000000000000000000000000000;;	function detect-node-names {
0000000000000000000000000000000000000000;;	  echo "... in gke:detect-node-names()" >&2
0000000000000000000000000000000000000000;;	  detect-project
0000000000000000000000000000000000000000;;	  detect-node-instance-groups
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  NODE_NAMES=()
0000000000000000000000000000000000000000;;	  for group in "${NODE_INSTANCE_GROUPS[@]:-}"; do
0000000000000000000000000000000000000000;;	    NODE_NAMES+=($(gcloud compute instance-groups managed list-instances \
0000000000000000000000000000000000000000;;	      "${group}" --zone "${ZONE}" \
0000000000000000000000000000000000000000;;	      --project "${PROJECT}" --format='value(instance)'))
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  echo "NODE_NAMES=${NODE_NAMES[*]:-}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Detect instance group name generated by gke.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Note that the NODE_INSTANCE_GROUPS var will only have instance groups in the
0000000000000000000000000000000000000000;;	# same zone as the cluster, meaning that it won't include all groups in a
0000000000000000000000000000000000000000;;	# multi-zone cluster. The ALL_INSTANCE_GROUP_URLS will contain all the
0000000000000000000000000000000000000000;;	# instance group URLs, which include multi-zone groups.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   GCLOUD
0000000000000000000000000000000000000000;;	#   PROJECT
0000000000000000000000000000000000000000;;	#   ZONE
0000000000000000000000000000000000000000;;	#   CLUSTER_NAME
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   NODE_INSTANCE_GROUPS
0000000000000000000000000000000000000000;;	#   ALL_INSTANCE_GROUP_URLS
0000000000000000000000000000000000000000;;	function detect-node-instance-groups {
0000000000000000000000000000000000000000;;	  echo "... in gke:detect-node-instance-groups()" >&2
0000000000000000000000000000000000000000;;	  local urls=$("${GCLOUD}" ${CMD_GROUP:-} container clusters describe \
0000000000000000000000000000000000000000;;	    --project="${PROJECT}" --zone="${ZONE}" \
0000000000000000000000000000000000000000;;	    --format='value(instanceGroupUrls)' "${CLUSTER_NAME}")
0000000000000000000000000000000000000000;;	  urls=(${urls//;/ })
0000000000000000000000000000000000000000;;	  ALL_INSTANCE_GROUP_URLS=${urls[*]}
0000000000000000000000000000000000000000;;	  NODE_INSTANCE_GROUPS=()
0000000000000000000000000000000000000000;;	  for url in "${urls[@]:-}"; do
0000000000000000000000000000000000000000;;	    local igm_zone=$(expr ${url} : '.*/zones/\([a-z0-9-]*\)/')
0000000000000000000000000000000000000000;;	    if [[ "${igm_zone}" == "${ZONE}" ]]; then
0000000000000000000000000000000000000000;;	      NODE_INSTANCE_GROUPS+=("${url##*/}")
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# SSH to a node by name ($1) and run a command ($2).
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   GCLOUD
0000000000000000000000000000000000000000;;	#   ZONE
0000000000000000000000000000000000000000;;	function ssh-to-node() {
0000000000000000000000000000000000000000;;	  echo "... in gke:ssh-to-node()" >&2
0000000000000000000000000000000000000000;;	  detect-project >&2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local node="$1"
0000000000000000000000000000000000000000;;	  local cmd="$2"
0000000000000000000000000000000000000000;;	  # Loop until we can successfully ssh into the box
0000000000000000000000000000000000000000;;	  for try in {1..5}; do
0000000000000000000000000000000000000000;;	    if gcloud compute ssh --ssh-flag="-o LogLevel=quiet" --ssh-flag="-o ConnectTimeout=30" --project "${PROJECT}" --zone="${ZONE}" "${node}" --command "echo test > /dev/null"; then
0000000000000000000000000000000000000000;;	      break
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    sleep 5
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  # Then actually try the command.
0000000000000000000000000000000000000000;;	  gcloud compute ssh --ssh-flag="-o LogLevel=quiet" --ssh-flag="-o ConnectTimeout=30" --project "${PROJECT}" --zone="${ZONE}" "${node}" --command "${cmd}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Execute after running tests to perform any required clean-up.  This is called
0000000000000000000000000000000000000000;;	# from hack/e2e.go. This calls kube-down, so the cluster still exists when this
0000000000000000000000000000000000000000;;	# is called.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   CLUSTER_NAME
0000000000000000000000000000000000000000;;	#   GCLOUD
0000000000000000000000000000000000000000;;	#   KUBE_ROOT
0000000000000000000000000000000000000000;;	#   ZONE
0000000000000000000000000000000000000000;;	function test-teardown() {
0000000000000000000000000000000000000000;;	  echo "... in gke:test-teardown()" >&2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  detect-project >&2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Tear down the cluster first.
0000000000000000000000000000000000000000;;	  "${KUBE_ROOT}/cluster/kube-down.sh" || true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Then remove the firewall rules. We do it in this order because the
0000000000000000000000000000000000000000;;	  # time to delete a firewall is actually dependent on the number of
0000000000000000000000000000000000000000;;	  # instances, but we can safely delete the cluster before the firewall.
0000000000000000000000000000000000000000;;	  #
0000000000000000000000000000000000000000;;	  # NOTE: Keep in sync with names above in test-setup.
0000000000000000000000000000000000000000;;	  for fw in "${CLUSTER_NAME}-http-alt" "${CLUSTER_NAME}-nodeports" "${FIREWALL_SSH}"; do
0000000000000000000000000000000000000000;;	    if [[ -n $("${GCLOUD}" compute firewall-rules --project "${PROJECT}" describe "${fw}" --format='value(name)' 2>/dev/null || true) ]]; then
0000000000000000000000000000000000000000;;	      with-retry 3 "${GCLOUD}" compute firewall-rules delete "${fw}" --project="${PROJECT}" --quiet &
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Wait for firewall rule teardown.
0000000000000000000000000000000000000000;;	  kube::util::wait-for-jobs || true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # It's unfortunate that the $FIREWALL_SSH rule and network are created in
0000000000000000000000000000000000000000;;	  # kube-up, but we can only really delete them in test-teardown. So much for
0000000000000000000000000000000000000000;;	  # symmetry.
0000000000000000000000000000000000000000;;	  if [[ "${KUBE_DELETE_NETWORK}" == "true" ]]; then
0000000000000000000000000000000000000000;;	    if [[ -n $("${GCLOUD}" compute networks --project "${PROJECT}" describe "${NETWORK}" --format='value(name)' 2>/dev/null || true) ]]; then
0000000000000000000000000000000000000000;;	      if ! with-retry 3 "${GCLOUD}" compute networks delete --project "${PROJECT}" --quiet "${NETWORK}"; then
0000000000000000000000000000000000000000;;	        echo "Failed to delete network '${NETWORK}'. Listing firewall-rules:"
0000000000000000000000000000000000000000;;	        "${GCLOUD}" compute firewall-rules --project "${PROJECT}" list --filter="network=${NETWORK}"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Actually take down the cluster. This is called from test-teardown.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#  GCLOUD
0000000000000000000000000000000000000000;;	#  ZONE
0000000000000000000000000000000000000000;;	#  CLUSTER_NAME
0000000000000000000000000000000000000000;;	function kube-down() {
0000000000000000000000000000000000000000;;	  echo "... in gke:kube-down()" >&2
0000000000000000000000000000000000000000;;	  detect-project >&2
0000000000000000000000000000000000000000;;	  if "${GCLOUD}" ${CMD_GROUP:-} container clusters describe --project="${PROJECT}" --zone="${ZONE}" "${CLUSTER_NAME}" --quiet &>/dev/null; then
0000000000000000000000000000000000000000;;	    with-retry 3 "${GCLOUD}" ${CMD_GROUP:-} container clusters delete --project="${PROJECT}" \
0000000000000000000000000000000000000000;;	      --zone="${ZONE}" "${CLUSTER_NAME}" --quiet
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
