0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2015 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# A library of helper functions that each provider hosting Kubernetes must implement to use cluster/kube-*.sh scripts.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# exit on any error
0000000000000000000000000000000000000000;;	set -e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	SSH_OPTS="-oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -oLogLevel=ERROR -C"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Use the config file specified in $KUBE_CONFIG_FILE, or default to
0000000000000000000000000000000000000000;;	# config-default.sh.
0000000000000000000000000000000000000000;;	KUBE_ROOT=$(dirname "${BASH_SOURCE}")/../..
0000000000000000000000000000000000000000;;	readonly ROOT=$(dirname "${BASH_SOURCE}")
0000000000000000000000000000000000000000;;	source "${ROOT}/${KUBE_CONFIG_FILE:-"config-default.sh"}"
0000000000000000000000000000000000000000;;	source "$KUBE_ROOT/cluster/common.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBECTL_PATH=${KUBE_ROOT}/cluster/centos/binaries/kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Directory to be used for master and node provisioning.
0000000000000000000000000000000000000000;;	KUBE_TEMP="~/kube_temp"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Get master IP addresses and store in KUBE_MASTER_IP_ADDRESSES[]
0000000000000000000000000000000000000000;;	# Must ensure that the following ENV vars are set:
0000000000000000000000000000000000000000;;	#   MASTERS
0000000000000000000000000000000000000000;;	function detect-masters() {
0000000000000000000000000000000000000000;;	  KUBE_MASTER_IP_ADDRESSES=()
0000000000000000000000000000000000000000;;	  for master in ${MASTERS}; do
0000000000000000000000000000000000000000;;	    KUBE_MASTER_IP_ADDRESSES+=("${master#*@}")
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  echo "KUBE_MASTERS: ${MASTERS}" 1>&2
0000000000000000000000000000000000000000;;	  echo "KUBE_MASTER_IP_ADDRESSES: [${KUBE_MASTER_IP_ADDRESSES[*]}]" 1>&2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Get node IP addresses and store in KUBE_NODE_IP_ADDRESSES[]
0000000000000000000000000000000000000000;;	function detect-nodes() {
0000000000000000000000000000000000000000;;	  KUBE_NODE_IP_ADDRESSES=()
0000000000000000000000000000000000000000;;	  for node in ${NODES}; do
0000000000000000000000000000000000000000;;	    KUBE_NODE_IP_ADDRESSES+=("${node#*@}")
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  echo "KUBE_NODE_IP_ADDRESSES: [${KUBE_NODE_IP_ADDRESSES[*]}]" 1>&2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Verify prereqs on host machine
0000000000000000000000000000000000000000;;	function verify-prereqs() {
0000000000000000000000000000000000000000;;	  local rc
0000000000000000000000000000000000000000;;	  rc=0
0000000000000000000000000000000000000000;;	  ssh-add -L 1> /dev/null 2> /dev/null || rc="$?"
0000000000000000000000000000000000000000;;	  # "Could not open a connection to your authentication agent."
0000000000000000000000000000000000000000;;	  if [[ "${rc}" -eq 2 ]]; then
0000000000000000000000000000000000000000;;	    eval "$(ssh-agent)" > /dev/null
0000000000000000000000000000000000000000;;	    trap-add "kill ${SSH_AGENT_PID}" EXIT
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  rc=0
0000000000000000000000000000000000000000;;	  ssh-add -L 1> /dev/null 2> /dev/null || rc="$?"
0000000000000000000000000000000000000000;;	  # "The agent has no identities."
0000000000000000000000000000000000000000;;	  if [[ "${rc}" -eq 1 ]]; then
0000000000000000000000000000000000000000;;	    # Try adding one of the default identities, with or without passphrase.
0000000000000000000000000000000000000000;;	    ssh-add || true
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  rc=0
0000000000000000000000000000000000000000;;	  # Expect at least one identity to be available.
0000000000000000000000000000000000000000;;	  if ! ssh-add -L 1> /dev/null 2> /dev/null; then
0000000000000000000000000000000000000000;;	    echo "Could not find or add an SSH identity."
0000000000000000000000000000000000000000;;	    echo "Please start ssh-agent, add your identity, and retry."
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Install handler for signal trap
0000000000000000000000000000000000000000;;	function trap-add {
0000000000000000000000000000000000000000;;	  local handler="$1"
0000000000000000000000000000000000000000;;	  local signal="${2-EXIT}"
0000000000000000000000000000000000000000;;	  local cur
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  cur="$(eval "sh -c 'echo \$3' -- $(trap -p ${signal})")"
0000000000000000000000000000000000000000;;	  if [[ -n "${cur}" ]]; then
0000000000000000000000000000000000000000;;	    handler="${cur}; ${handler}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  trap "${handler}" ${signal}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Validate a kubernetes cluster
0000000000000000000000000000000000000000;;	function validate-cluster() {
0000000000000000000000000000000000000000;;	  # by default call the generic validate-cluster.sh script, customizable by
0000000000000000000000000000000000000000;;	  # any cluster provider if this does not fit.
0000000000000000000000000000000000000000;;	  set +e
0000000000000000000000000000000000000000;;	  "${KUBE_ROOT}/cluster/validate-cluster.sh"
0000000000000000000000000000000000000000;;	  if [[ "$?" -ne "0" ]]; then
0000000000000000000000000000000000000000;;	    for master in ${MASTERS}; do
0000000000000000000000000000000000000000;;	      troubleshoot-master ${master}
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	    for node in ${NODES}; do
0000000000000000000000000000000000000000;;	      troubleshoot-node ${node}
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  set -e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Instantiate a kubernetes cluster
0000000000000000000000000000000000000000;;	function kube-up() {
0000000000000000000000000000000000000000;;	  make-ca-cert
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local num_infra=0
0000000000000000000000000000000000000000;;	  for master in ${MASTERS}; do
0000000000000000000000000000000000000000;;	    provision-master "${master}" "infra${num_infra}"
0000000000000000000000000000000000000000;;	    let ++num_infra
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for master in ${MASTERS}; do
0000000000000000000000000000000000000000;;	    post-provision-master "${master}"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for node in ${NODES}; do
0000000000000000000000000000000000000000;;	    provision-node "${node}"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  detect-masters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # set CONTEXT and KUBE_SERVER values for create-kubeconfig() and get-password()
0000000000000000000000000000000000000000;;	  export CONTEXT="centos"
0000000000000000000000000000000000000000;;	  export KUBE_SERVER="http://${MASTER_ADVERTISE_ADDRESS}:8080"
0000000000000000000000000000000000000000;;	  source "${KUBE_ROOT}/cluster/common.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # set kubernetes user and password
0000000000000000000000000000000000000000;;	  get-password
0000000000000000000000000000000000000000;;	  create-kubeconfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Delete a kubernetes cluster
0000000000000000000000000000000000000000;;	function kube-down() {
0000000000000000000000000000000000000000;;	  for master in ${MASTERS}; do
0000000000000000000000000000000000000000;;	    tear-down-master ${master}
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for node in ${NODES}; do
0000000000000000000000000000000000000000;;	    tear-down-node ${node}
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function troubleshoot-master() {
0000000000000000000000000000000000000000;;	  # Troubleshooting on master if all required daemons are active.
0000000000000000000000000000000000000000;;	  echo "[INFO] Troubleshooting on master $1"
0000000000000000000000000000000000000000;;	  local -a required_daemon=("kube-apiserver" "kube-controller-manager" "kube-scheduler")
0000000000000000000000000000000000000000;;	  local daemon
0000000000000000000000000000000000000000;;	  local daemon_status
0000000000000000000000000000000000000000;;	  printf "%-24s %-10s \n" "PROCESS" "STATUS"
0000000000000000000000000000000000000000;;	  for daemon in "${required_daemon[@]}"; do
0000000000000000000000000000000000000000;;	    local rc=0
0000000000000000000000000000000000000000;;	    kube-ssh "${1}" "sudo systemctl is-active ${daemon}" >/dev/null 2>&1 || rc="$?"
0000000000000000000000000000000000000000;;	    if [[ "${rc}" -ne "0" ]]; then
0000000000000000000000000000000000000000;;	      daemon_status="inactive"
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      daemon_status="active"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    printf "%-24s %s\n" ${daemon} ${daemon_status}
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  printf "\n"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function troubleshoot-node() {
0000000000000000000000000000000000000000;;	  # Troubleshooting on node if all required daemons are active.
0000000000000000000000000000000000000000;;	  echo "[INFO] Troubleshooting on node ${1}"
0000000000000000000000000000000000000000;;	  local -a required_daemon=("kube-proxy" "kubelet" "docker" "flannel")
0000000000000000000000000000000000000000;;	  local daemon
0000000000000000000000000000000000000000;;	  local daemon_status
0000000000000000000000000000000000000000;;	  printf "%-24s %-10s \n" "PROCESS" "STATUS"
0000000000000000000000000000000000000000;;	  for daemon in "${required_daemon[@]}"; do
0000000000000000000000000000000000000000;;	    local rc=0
0000000000000000000000000000000000000000;;	    kube-ssh "${1}" "sudo systemctl is-active ${daemon}" >/dev/null 2>&1 || rc="$?"
0000000000000000000000000000000000000000;;	    if [[ "${rc}" -ne "0" ]]; then
0000000000000000000000000000000000000000;;	      daemon_status="inactive"
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      daemon_status="active"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    printf "%-24s %s\n" ${daemon} ${daemon_status}
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  printf "\n"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Clean up on master
0000000000000000000000000000000000000000;;	function tear-down-master() {
0000000000000000000000000000000000000000;;	echo "[INFO] tear-down-master on $1"
0000000000000000000000000000000000000000;;	  for service_name in etcd kube-apiserver kube-controller-manager kube-scheduler ; do
0000000000000000000000000000000000000000;;	      service_file="/usr/lib/systemd/system/${service_name}.service"
0000000000000000000000000000000000000000;;	      kube-ssh "$1" " \
0000000000000000000000000000000000000000;;	        if [[ -f $service_file ]]; then \
0000000000000000000000000000000000000000;;	          sudo systemctl stop $service_name; \
0000000000000000000000000000000000000000;;	          sudo systemctl disable $service_name; \
0000000000000000000000000000000000000000;;	          sudo rm -f $service_file; \
0000000000000000000000000000000000000000;;	        fi"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  kube-ssh "${1}" "sudo rm -rf /opt/kubernetes"
0000000000000000000000000000000000000000;;	  kube-ssh "${1}" "sudo rm -rf /srv/kubernetes"
0000000000000000000000000000000000000000;;	  kube-ssh "${1}" "sudo rm -rf ${KUBE_TEMP}"
0000000000000000000000000000000000000000;;	  kube-ssh "${1}" "sudo rm -rf /var/lib/etcd"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Clean up on node
0000000000000000000000000000000000000000;;	function tear-down-node() {
0000000000000000000000000000000000000000;;	echo "[INFO] tear-down-node on $1"
0000000000000000000000000000000000000000;;	  for service_name in kube-proxy kubelet docker flannel ; do
0000000000000000000000000000000000000000;;	      service_file="/usr/lib/systemd/system/${service_name}.service"
0000000000000000000000000000000000000000;;	      kube-ssh "$1" " \
0000000000000000000000000000000000000000;;	        if [[ -f $service_file ]]; then \
0000000000000000000000000000000000000000;;	          sudo systemctl stop $service_name; \
0000000000000000000000000000000000000000;;	          sudo systemctl disable $service_name; \
0000000000000000000000000000000000000000;;	          sudo rm -f $service_file; \
0000000000000000000000000000000000000000;;	        fi"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  kube-ssh "$1" "sudo rm -rf /run/flannel"
0000000000000000000000000000000000000000;;	  kube-ssh "$1" "sudo rm -rf /opt/kubernetes"
0000000000000000000000000000000000000000;;	  kube-ssh "$1" "sudo rm -rf /srv/kubernetes"
0000000000000000000000000000000000000000;;	  kube-ssh "$1" "sudo rm -rf ${KUBE_TEMP}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Generate the CA certificates for k8s components
0000000000000000000000000000000000000000;;	function make-ca-cert() {
0000000000000000000000000000000000000000;;	  echo "[INFO] make-ca-cert"
0000000000000000000000000000000000000000;;	  bash "${ROOT}/../saltbase/salt/generate-cert/make-ca-cert.sh" "${MASTER_ADVERTISE_IP}" "IP:${MASTER_ADVERTISE_IP},IP:${SERVICE_CLUSTER_IP_RANGE%.*}.1,DNS:kubernetes,DNS:kubernetes.default,DNS:kubernetes.default.svc,DNS:kubernetes.default.svc.cluster.local"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Provision master
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   $1 (master)
0000000000000000000000000000000000000000;;	#   $2 (etcd_name)
0000000000000000000000000000000000000000;;	#   KUBE_TEMP
0000000000000000000000000000000000000000;;	#   ETCD_SERVERS
0000000000000000000000000000000000000000;;	#   ETCD_INITIAL_CLUSTER
0000000000000000000000000000000000000000;;	#   SERVICE_CLUSTER_IP_RANGE
0000000000000000000000000000000000000000;;	#   MASTER_ADVERTISE_ADDRESS
0000000000000000000000000000000000000000;;	function provision-master() {
0000000000000000000000000000000000000000;;	  echo "[INFO] Provision master on $1"
0000000000000000000000000000000000000000;;	  local master="$1"
0000000000000000000000000000000000000000;;	  local master_ip="${master#*@}"
0000000000000000000000000000000000000000;;	  local etcd_name="$2"
0000000000000000000000000000000000000000;;	  ensure-setup-dir "${master}"
0000000000000000000000000000000000000000;;	  ensure-etcd-cert "${etcd_name}" "${master_ip}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube-scp "${master}" "${ROOT}/ca-cert ${ROOT}/binaries/master ${ROOT}/master ${ROOT}/config-default.sh ${ROOT}/util.sh" "${KUBE_TEMP}"
0000000000000000000000000000000000000000;;	  kube-scp "${master}" "${ROOT}/etcd-cert/ca.pem \
0000000000000000000000000000000000000000;;	    ${ROOT}/etcd-cert/client.pem \
0000000000000000000000000000000000000000;;	    ${ROOT}/etcd-cert/client-key.pem \
0000000000000000000000000000000000000000;;	    ${ROOT}/etcd-cert/server-${etcd_name}.pem \
0000000000000000000000000000000000000000;;	    ${ROOT}/etcd-cert/server-${etcd_name}-key.pem \
0000000000000000000000000000000000000000;;	    ${ROOT}/etcd-cert/peer-${etcd_name}.pem \
0000000000000000000000000000000000000000;;	    ${ROOT}/etcd-cert/peer-${etcd_name}-key.pem" "${KUBE_TEMP}/etcd-cert"
0000000000000000000000000000000000000000;;	  kube-ssh "${master}" " \
0000000000000000000000000000000000000000;;	    sudo rm -rf /opt/kubernetes/bin; \
0000000000000000000000000000000000000000;;	    sudo cp -r ${KUBE_TEMP}/master/bin /opt/kubernetes; \
0000000000000000000000000000000000000000;;	    sudo mkdir -p /srv/kubernetes/; sudo cp -f ${KUBE_TEMP}/ca-cert/* /srv/kubernetes/; \
0000000000000000000000000000000000000000;;	    sudo mkdir -p /srv/kubernetes/etcd; sudo cp -f ${KUBE_TEMP}/etcd-cert/* /srv/kubernetes/etcd/; \
0000000000000000000000000000000000000000;;	    sudo chmod -R +x /opt/kubernetes/bin; \
0000000000000000000000000000000000000000;;	    sudo ln -sf /opt/kubernetes/bin/* /usr/local/bin/; \
0000000000000000000000000000000000000000;;	    sudo bash ${KUBE_TEMP}/master/scripts/etcd.sh ${etcd_name} ${master_ip} ${ETCD_INITIAL_CLUSTER}; \
0000000000000000000000000000000000000000;;	    sudo bash ${KUBE_TEMP}/master/scripts/apiserver.sh ${master_ip} ${ETCD_SERVERS} ${SERVICE_CLUSTER_IP_RANGE} ${ADMISSION_CONTROL}; \
0000000000000000000000000000000000000000;;	    sudo bash ${KUBE_TEMP}/master/scripts/controller-manager.sh ${MASTER_ADVERTISE_ADDRESS}; \
0000000000000000000000000000000000000000;;	    sudo bash ${KUBE_TEMP}/master/scripts/scheduler.sh ${MASTER_ADVERTISE_ADDRESS}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Post-provision master, run after all masters were provisioned
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   $1 (master)
0000000000000000000000000000000000000000;;	#   KUBE_TEMP
0000000000000000000000000000000000000000;;	#   ETCD_SERVERS
0000000000000000000000000000000000000000;;	#   FLANNEL_NET
0000000000000000000000000000000000000000;;	function post-provision-master() {
0000000000000000000000000000000000000000;;	  echo "[INFO] Post provision master on $1"
0000000000000000000000000000000000000000;;	  local master=$1
0000000000000000000000000000000000000000;;	  kube-ssh "${master}" " \
0000000000000000000000000000000000000000;;	    sudo bash ${KUBE_TEMP}/master/scripts/flannel.sh ${ETCD_SERVERS} ${FLANNEL_NET}; \
0000000000000000000000000000000000000000;;	    sudo bash ${KUBE_TEMP}/master/scripts/post-etcd.sh"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Provision node
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   $1 (node)
0000000000000000000000000000000000000000;;	#   KUBE_TEMP
0000000000000000000000000000000000000000;;	#   ETCD_SERVERS
0000000000000000000000000000000000000000;;	#   FLANNEL_NET
0000000000000000000000000000000000000000;;	#   MASTER_ADVERTISE_ADDRESS
0000000000000000000000000000000000000000;;	#   DOCKER_OPTS
0000000000000000000000000000000000000000;;	#   DNS_SERVER_IP
0000000000000000000000000000000000000000;;	#   DNS_DOMAIN
0000000000000000000000000000000000000000;;	function provision-node() {
0000000000000000000000000000000000000000;;	  echo "[INFO] Provision node on $1"
0000000000000000000000000000000000000000;;	  local node=$1
0000000000000000000000000000000000000000;;	  local node_ip=${node#*@}
0000000000000000000000000000000000000000;;	  local dns_ip=${DNS_SERVER_IP#*@}
0000000000000000000000000000000000000000;;	  local dns_domain=${DNS_DOMAIN#*@}
0000000000000000000000000000000000000000;;	  ensure-setup-dir ${node}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube-scp "${node}" "${ROOT}/binaries/node ${ROOT}/node ${ROOT}/config-default.sh ${ROOT}/util.sh" "${KUBE_TEMP}"
0000000000000000000000000000000000000000;;	  kube-scp "${node}" "${ROOT}/etcd-cert/ca.pem \
0000000000000000000000000000000000000000;;	    ${ROOT}/etcd-cert/client.pem \
0000000000000000000000000000000000000000;;	    ${ROOT}/etcd-cert/client-key.pem" "${KUBE_TEMP}/etcd-cert"
0000000000000000000000000000000000000000;;	  kube-ssh "${node}" " \
0000000000000000000000000000000000000000;;	    rm -rf /opt/kubernetes/bin; \
0000000000000000000000000000000000000000;;	    sudo cp -r ${KUBE_TEMP}/node/bin /opt/kubernetes; \
0000000000000000000000000000000000000000;;	    sudo chmod -R +x /opt/kubernetes/bin; \
0000000000000000000000000000000000000000;;	    sudo mkdir -p /srv/kubernetes/etcd; sudo cp -f ${KUBE_TEMP}/etcd-cert/* /srv/kubernetes/etcd/; \
0000000000000000000000000000000000000000;;	    sudo ln -s /opt/kubernetes/bin/* /usr/local/bin/; \
0000000000000000000000000000000000000000;;	    sudo mkdir -p /srv/kubernetes/etcd; sudo cp -f ${KUBE_TEMP}/etcd-cert/* /srv/kubernetes/etcd/; \
0000000000000000000000000000000000000000;;	    sudo bash ${KUBE_TEMP}/node/scripts/flannel.sh ${ETCD_SERVERS} ${FLANNEL_NET}; \
0000000000000000000000000000000000000000;;	    sudo bash ${KUBE_TEMP}/node/scripts/docker.sh \"${DOCKER_OPTS}\"; \
0000000000000000000000000000000000000000;;	    sudo bash ${KUBE_TEMP}/node/scripts/kubelet.sh ${MASTER_ADVERTISE_ADDRESS} ${node_ip} ${dns_ip} ${dns_domain}; \
0000000000000000000000000000000000000000;;	    sudo bash ${KUBE_TEMP}/node/scripts/proxy.sh ${MASTER_ADVERTISE_ADDRESS}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Create dirs that'll be used during setup on target machine.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   KUBE_TEMP
0000000000000000000000000000000000000000;;	function ensure-setup-dir() {
0000000000000000000000000000000000000000;;	  kube-ssh "${1}" "mkdir -p ${KUBE_TEMP}; \
0000000000000000000000000000000000000000;;	                   mkdir -p ${KUBE_TEMP}/etcd-cert; \
0000000000000000000000000000000000000000;;	                   sudo mkdir -p /opt/kubernetes/bin; \
0000000000000000000000000000000000000000;;	                   sudo mkdir -p /opt/kubernetes/cfg"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Generate certificates for etcd cluster
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   $1 (etcd member name)
0000000000000000000000000000000000000000;;	#   $2 (master ip)
0000000000000000000000000000000000000000;;	function ensure-etcd-cert() {
0000000000000000000000000000000000000000;;	  local etcd_name="$1"
0000000000000000000000000000000000000000;;	  local master_ip="$2"
0000000000000000000000000000000000000000;;	  local cert_dir="${ROOT}/etcd-cert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ ! -r "${cert_dir}/client.pem" || ! -r "${cert_dir}/client-key.pem" ]]; then
0000000000000000000000000000000000000000;;	    generate-etcd-cert "${cert_dir}" "${master_ip}" "client" "client"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  generate-etcd-cert "${cert_dir}" "${master_ip}" "server" "server-${etcd_name}"
0000000000000000000000000000000000000000;;	  generate-etcd-cert "${cert_dir}" "${master_ip}" "peer" "peer-${etcd_name}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Run command over ssh
0000000000000000000000000000000000000000;;	function kube-ssh() {
0000000000000000000000000000000000000000;;	  local host="$1"
0000000000000000000000000000000000000000;;	  shift
0000000000000000000000000000000000000000;;	  ssh ${SSH_OPTS} -t "${host}" "$@" >/dev/null 2>&1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copy file recursively over ssh
0000000000000000000000000000000000000000;;	function kube-scp() {
0000000000000000000000000000000000000000;;	  local host="$1"
0000000000000000000000000000000000000000;;	  local src=($2)
0000000000000000000000000000000000000000;;	  local dst="$3"
0000000000000000000000000000000000000000;;	  scp -r ${SSH_OPTS} ${src[*]} "${host}:${dst}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Ensure that we have a password created for validating to the master. Will
0000000000000000000000000000000000000000;;	# read from kubeconfig if available.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   KUBE_USER
0000000000000000000000000000000000000000;;	#   KUBE_PASSWORD
0000000000000000000000000000000000000000;;	function get-password {
0000000000000000000000000000000000000000;;	  load-or-gen-kube-basicauth
0000000000000000000000000000000000000000;;	  if [[ -z "${KUBE_USER}" || -z "${KUBE_PASSWORD}" ]]; then
0000000000000000000000000000000000000000;;	    KUBE_USER=admin
0000000000000000000000000000000000000000;;	    KUBE_PASSWORD=$(python -c 'import string,random; \
0000000000000000000000000000000000000000;;	      print("".join(random.SystemRandom().choice(string.ascii_letters + string.digits) for _ in range(16)))')
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
