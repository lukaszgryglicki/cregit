0000000000000000000000000000000000000000;;	# Private Docker Registry in Kubernetes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Kubernetes offers an optional private Docker registry addon, which you can turn
0000000000000000000000000000000000000000;;	on when you bring up a cluster or install later.  This gives you a place to
0000000000000000000000000000000000000000;;	store truly private Docker images for your cluster.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## How it works
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The private registry runs as a `Pod` in your cluster.  It does not currently
0000000000000000000000000000000000000000;;	support SSL or authentication, which triggers Docker's "insecure registry"
0000000000000000000000000000000000000000;;	logic.  To work around this, we run a proxy on each node in the cluster,
0000000000000000000000000000000000000000;;	exposing a port onto the node (via a hostPort), which Docker accepts as
0000000000000000000000000000000000000000;;	"secure", since it is accessed by `localhost`.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Turning it on
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Some cluster installs (e.g. GCE) support this as a cluster-birth flag.  The
0000000000000000000000000000000000000000;;	`ENABLE_CLUSTER_REGISTRY` variable in `cluster/gce/config-default.sh` governs
0000000000000000000000000000000000000000;;	whether the registry is run or not.  To set this flag, you can specify
0000000000000000000000000000000000000000;;	`KUBE_ENABLE_CLUSTER_REGISTRY=true` when running `kube-up.sh`.  If your cluster
0000000000000000000000000000000000000000;;	does not include this flag, the following steps should work.  Note that some of
0000000000000000000000000000000000000000;;	this is cloud-provider specific, so you may have to customize it a bit.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Make some storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The primary job of the registry is to store data.  To do that we have to decide
0000000000000000000000000000000000000000;;	where to store it.  For cloud environments that have networked storage, we can
0000000000000000000000000000000000000000;;	use Kubernetes's `PersistentVolume` abstraction.  The following template is
0000000000000000000000000000000000000000;;	expanded by `salt` in the GCE cluster turnup, but can easily be adapted to
0000000000000000000000000000000000000000;;	other situations:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	<!-- BEGIN MUNGE: EXAMPLE registry-pv.yaml.in -->
0000000000000000000000000000000000000000;;	```yaml
0000000000000000000000000000000000000000;;	kind: PersistentVolume
0000000000000000000000000000000000000000;;	apiVersion: v1
0000000000000000000000000000000000000000;;	metadata:
0000000000000000000000000000000000000000;;	  name: kube-system-kube-registry-pv
0000000000000000000000000000000000000000;;	  labels:
0000000000000000000000000000000000000000;;	    kubernetes.io/cluster-service: "true"
0000000000000000000000000000000000000000;;	spec:
0000000000000000000000000000000000000000;;	{% if pillar.get('cluster_registry_disk_type', '') == 'gce' %}
0000000000000000000000000000000000000000;;	  capacity:
0000000000000000000000000000000000000000;;	    storage: {{ pillar['cluster_registry_disk_size'] }}
0000000000000000000000000000000000000000;;	  accessModes:
0000000000000000000000000000000000000000;;	    - ReadWriteOnce
0000000000000000000000000000000000000000;;	  gcePersistentDisk:
0000000000000000000000000000000000000000;;	    pdName: "{{ pillar['cluster_registry_disk_name'] }}"
0000000000000000000000000000000000000000;;	    fsType: "ext4"
0000000000000000000000000000000000000000;;	{% endif %}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	<!-- END MUNGE: EXAMPLE registry-pv.yaml.in -->
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If, for example, you wanted to use NFS you would just need to change the
0000000000000000000000000000000000000000;;	`gcePersistentDisk` block to `nfs`. See
0000000000000000000000000000000000000000;;	[here](https://kubernetes.io/docs/user-guide/volumes.md) for more details on volumes.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Note that in any case, the storage (in the case the GCE PersistentDisk) must be
0000000000000000000000000000000000000000;;	created independently - this is not something Kubernetes manages for you (yet).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### I don't want or don't have persistent storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If you are running in a place that doesn't have networked storage, or if you
0000000000000000000000000000000000000000;;	just want to kick the tires on this without committing to it, you can easily
0000000000000000000000000000000000000000;;	adapt the `ReplicationController` specification below to use a simple
0000000000000000000000000000000000000000;;	`emptyDir` volume instead of a `persistentVolumeClaim`.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Claim the storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Now that the Kubernetes cluster knows that some storage exists, you can put a
0000000000000000000000000000000000000000;;	claim on that storage.  As with the `PersistentVolume` above, you can start
0000000000000000000000000000000000000000;;	with the `salt` template:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	<!-- BEGIN MUNGE: EXAMPLE registry-pvc.yaml.in -->
0000000000000000000000000000000000000000;;	```yaml
0000000000000000000000000000000000000000;;	kind: PersistentVolumeClaim
0000000000000000000000000000000000000000;;	apiVersion: v1
0000000000000000000000000000000000000000;;	metadata:
0000000000000000000000000000000000000000;;	  name: kube-registry-pvc
0000000000000000000000000000000000000000;;	  namespace: kube-system
0000000000000000000000000000000000000000;;	  labels:
0000000000000000000000000000000000000000;;	    kubernetes.io/cluster-service: "true"
0000000000000000000000000000000000000000;;	spec:
0000000000000000000000000000000000000000;;	  accessModes:
0000000000000000000000000000000000000000;;	    - ReadWriteOnce
0000000000000000000000000000000000000000;;	  resources:
0000000000000000000000000000000000000000;;	    requests:
0000000000000000000000000000000000000000;;	      storage: {{ pillar['cluster_registry_disk_size'] }}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	<!-- END MUNGE: EXAMPLE registry-pvc.yaml.in -->
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This tells Kubernetes that you want to use storage, and the `PersistentVolume`
0000000000000000000000000000000000000000;;	you created before will be bound to this claim (unless you have other
0000000000000000000000000000000000000000;;	`PersistentVolumes` in which case those might get bound instead).  This claim
0000000000000000000000000000000000000000;;	gives you the right to use this storage until you release the claim.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Run the registry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Now we can run a Docker registry:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	<!-- BEGIN MUNGE: EXAMPLE registry-rc.yaml -->
0000000000000000000000000000000000000000;;	```yaml
0000000000000000000000000000000000000000;;	apiVersion: v1
0000000000000000000000000000000000000000;;	kind: ReplicationController
0000000000000000000000000000000000000000;;	metadata:
0000000000000000000000000000000000000000;;	  name: kube-registry-v0
0000000000000000000000000000000000000000;;	  namespace: kube-system
0000000000000000000000000000000000000000;;	  labels:
0000000000000000000000000000000000000000;;	    k8s-app: kube-registry-upstream
0000000000000000000000000000000000000000;;	    version: v0
0000000000000000000000000000000000000000;;	    kubernetes.io/cluster-service: "true"
0000000000000000000000000000000000000000;;	spec:
0000000000000000000000000000000000000000;;	  replicas: 1
0000000000000000000000000000000000000000;;	  selector:
0000000000000000000000000000000000000000;;	    k8s-app: kube-registry-upstream
0000000000000000000000000000000000000000;;	    version: v0
0000000000000000000000000000000000000000;;	  template:
0000000000000000000000000000000000000000;;	    metadata:
0000000000000000000000000000000000000000;;	      labels:
0000000000000000000000000000000000000000;;	        k8s-app: kube-registry-upstream
0000000000000000000000000000000000000000;;	        version: v0
0000000000000000000000000000000000000000;;	        kubernetes.io/cluster-service: "true"
0000000000000000000000000000000000000000;;	    spec:
0000000000000000000000000000000000000000;;	      containers:
0000000000000000000000000000000000000000;;	      - name: registry
0000000000000000000000000000000000000000;;	        image: registry:2
0000000000000000000000000000000000000000;;	        resources:
0000000000000000000000000000000000000000;;	          limits:
0000000000000000000000000000000000000000;;	            cpu: 100m
0000000000000000000000000000000000000000;;	            memory: 100Mi
0000000000000000000000000000000000000000;;	        env:
0000000000000000000000000000000000000000;;	        - name: REGISTRY_HTTP_ADDR
0000000000000000000000000000000000000000;;	          value: :5000
0000000000000000000000000000000000000000;;	        - name: REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY
0000000000000000000000000000000000000000;;	          value: /var/lib/registry
0000000000000000000000000000000000000000;;	        volumeMounts:
0000000000000000000000000000000000000000;;	        - name: image-store
0000000000000000000000000000000000000000;;	          mountPath: /var/lib/registry
0000000000000000000000000000000000000000;;	        ports:
0000000000000000000000000000000000000000;;	        - containerPort: 5000
0000000000000000000000000000000000000000;;	          name: registry
0000000000000000000000000000000000000000;;	          protocol: TCP
0000000000000000000000000000000000000000;;	      volumes:
0000000000000000000000000000000000000000;;	      - name: image-store
0000000000000000000000000000000000000000;;	        persistentVolumeClaim:
0000000000000000000000000000000000000000;;	          claimName: kube-registry-pvc
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	<!-- END MUNGE: EXAMPLE registry-rc.yaml -->
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Expose the registry in the cluster
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Now that we have a registry `Pod` running, we can expose it as a Service:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	<!-- BEGIN MUNGE: EXAMPLE registry-svc.yaml -->
0000000000000000000000000000000000000000;;	```yaml
0000000000000000000000000000000000000000;;	apiVersion: v1
0000000000000000000000000000000000000000;;	kind: Service
0000000000000000000000000000000000000000;;	metadata:
0000000000000000000000000000000000000000;;	  name: kube-registry
0000000000000000000000000000000000000000;;	  namespace: kube-system
0000000000000000000000000000000000000000;;	  labels:
0000000000000000000000000000000000000000;;	    k8s-app: kube-registry-upstream
0000000000000000000000000000000000000000;;	    kubernetes.io/cluster-service: "true"
0000000000000000000000000000000000000000;;	    kubernetes.io/name: "KubeRegistry"
0000000000000000000000000000000000000000;;	spec:
0000000000000000000000000000000000000000;;	  selector:
0000000000000000000000000000000000000000;;	    k8s-app: kube-registry-upstream
0000000000000000000000000000000000000000;;	  ports:
0000000000000000000000000000000000000000;;	  - name: registry
0000000000000000000000000000000000000000;;	    port: 5000
0000000000000000000000000000000000000000;;	    protocol: TCP
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	<!-- END MUNGE: EXAMPLE registry-svc.yaml -->
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Expose the registry on each node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Now that we have a running `Service`, we need to expose it onto each Kubernetes
0000000000000000000000000000000000000000;;	`Node` so that Docker will see it as `localhost`.  We can load a `Pod` on every
0000000000000000000000000000000000000000;;	node by creating following daemonset.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	<!-- BEGIN MUNGE: EXAMPLE ../../saltbase/salt/kube-registry-proxy/kube-registry-proxy.yaml -->
0000000000000000000000000000000000000000;;	```yaml
0000000000000000000000000000000000000000;;	apiVersion: extensions/v1beta1
0000000000000000000000000000000000000000;;	kind: DaemonSet
0000000000000000000000000000000000000000;;	metadata:
0000000000000000000000000000000000000000;;	  name: kube-registry-proxy
0000000000000000000000000000000000000000;;	  namespace: kube-system
0000000000000000000000000000000000000000;;	  labels:
0000000000000000000000000000000000000000;;	    k8s-app: kube-registry-proxy
0000000000000000000000000000000000000000;;	    kubernetes.io/cluster-service: "true"
0000000000000000000000000000000000000000;;	    version: v0.4
0000000000000000000000000000000000000000;;	spec:
0000000000000000000000000000000000000000;;	  template:
0000000000000000000000000000000000000000;;	    metadata:
0000000000000000000000000000000000000000;;	      labels:
0000000000000000000000000000000000000000;;	        k8s-app: kube-registry-proxy
0000000000000000000000000000000000000000;;	        kubernetes.io/name: "kube-registry-proxy"
0000000000000000000000000000000000000000;;	        kubernetes.io/cluster-service: "true"
0000000000000000000000000000000000000000;;	        version: v0.4
0000000000000000000000000000000000000000;;	    spec:
0000000000000000000000000000000000000000;;	      containers:
0000000000000000000000000000000000000000;;	      - name: kube-registry-proxy
0000000000000000000000000000000000000000;;	        image: gcr.io/google_containers/kube-registry-proxy:0.4
0000000000000000000000000000000000000000;;	        resources:
0000000000000000000000000000000000000000;;	          limits:
0000000000000000000000000000000000000000;;	            cpu: 100m
0000000000000000000000000000000000000000;;	            memory: 50Mi
0000000000000000000000000000000000000000;;	        env:
0000000000000000000000000000000000000000;;	        - name: REGISTRY_HOST
0000000000000000000000000000000000000000;;	          value: kube-registry.kube-system.svc.cluster.local
0000000000000000000000000000000000000000;;	        - name: REGISTRY_PORT
0000000000000000000000000000000000000000;;	          value: "5000"
0000000000000000000000000000000000000000;;	        ports:
0000000000000000000000000000000000000000;;	        - name: registry
0000000000000000000000000000000000000000;;	          containerPort: 80
0000000000000000000000000000000000000000;;	          hostPort: 5000
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	<!-- END MUNGE: EXAMPLE ../../saltbase/salt/kube-registry-proxy/kube-registry-proxy.yaml -->
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	When modifying replication-controller, service and daemon-set defintions, take
0000000000000000000000000000000000000000;;	care to ensure _unique_ identifiers for the rc-svc couple and the daemon-set.
0000000000000000000000000000000000000000;;	Failing to do so will have register the localhost proxy daemon-sets to the
0000000000000000000000000000000000000000;;	upstream service. As a result they will then try to proxy themselves, which
0000000000000000000000000000000000000000;;	will, for obvious reasons, not work.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This ensures that port 5000 on each node is directed to the registry `Service`.
0000000000000000000000000000000000000000;;	You should be able to verify that it is running by hitting port 5000 with a web
0000000000000000000000000000000000000000;;	browser and getting a 404 error:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```console
0000000000000000000000000000000000000000;;	$ curl localhost:5000
0000000000000000000000000000000000000000;;	404 page not found
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Using the registry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To use an image hosted by this registry, simply say this in your `Pod`'s
0000000000000000000000000000000000000000;;	`spec.containers[].image` field:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```yaml
0000000000000000000000000000000000000000;;	    image: localhost:5000/user/container
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Before you can use the registry, you have to be able to get images into it,
0000000000000000000000000000000000000000;;	though.  If you are building an image on your Kubernetes `Node`, you can spell
0000000000000000000000000000000000000000;;	out `localhost:5000` when you build and push.  More likely, though, you are
0000000000000000000000000000000000000000;;	building locally and want to push to your cluster.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You can use `kubectl` to set up a port-forward from your local node to a
0000000000000000000000000000000000000000;;	running Pod:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```console
0000000000000000000000000000000000000000;;	$ POD=$(kubectl get pods --namespace kube-system -l k8s-app=kube-registry-upstream \
0000000000000000000000000000000000000000;;	            -o template --template '{{range .items}}{{.metadata.name}} {{.status.phase}}{{"\n"}}{{end}}' \
0000000000000000000000000000000000000000;;	            | grep Running | head -1 | cut -f1 -d' ')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	$ kubectl port-forward --namespace kube-system $POD 5000:5000 &
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Now you can build and push images on your local computer as
0000000000000000000000000000000000000000;;	`localhost:5000/yourname/container` and those images will be available inside
0000000000000000000000000000000000000000;;	your kubernetes cluster with the same name.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# More Extensions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	- [Use GCS as storage backend](gcs/README.md)
0000000000000000000000000000000000000000;;	- [Enable TLS/SSL](tls/README.md)
0000000000000000000000000000000000000000;;	- [Enable Authentication](auth/README.md)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Future improvements
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* Allow port-forwarding to a Service rather than a pod (#15180)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[![Analytics](https://kubernetes-site.appspot.com/UA-36037335-10/GitHub/cluster/addons/registry/README.md?pixel)]()
