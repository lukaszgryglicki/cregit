0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2014 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# LIMITATIONS
0000000000000000000000000000000000000000;;	# 1. Exit code is probably not always correct.
0000000000000000000000000000000000000000;;	# 2. There are no unittests.
0000000000000000000000000000000000000000;;	# 3. Will not work if the total length of paths to addons is greater than
0000000000000000000000000000000000000000;;	#    bash can handle. Probably it is not a problem: ARG_MAX=2097152 on GCE.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# cosmetic improvements to be done
0000000000000000000000000000000000000000;;	# 1. Improve the log function; add timestamp, file name, etc.
0000000000000000000000000000000000000000;;	# 2. Logging doesn't work from files that print things out.
0000000000000000000000000000000000000000;;	# 3. Kubectl prints the output to stderr (the output should be captured and then
0000000000000000000000000000000000000000;;	#    logged)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# The business logic for whether a given object should be created
0000000000000000000000000000000000000000;;	# was already enforced by salt, and /etc/kubernetes/addons is the
0000000000000000000000000000000000000000;;	# managed result is of that. Start everything below that directory.
0000000000000000000000000000000000000000;;	KUBECTL=${KUBECTL_BIN:-/usr/local/bin/kubectl}
0000000000000000000000000000000000000000;;	KUBECTL_OPTS=${KUBECTL_OPTS:-}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	ADDON_CHECK_INTERVAL_SEC=${TEST_ADDON_CHECK_INTERVAL_SEC:-60}
0000000000000000000000000000000000000000;;	ADDON_PATH=${ADDON_PATH:-/etc/kubernetes/addons}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	SYSTEM_NAMESPACE=kube-system
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Addons could use this label with two modes:
0000000000000000000000000000000000000000;;	# - ADDON_MANAGER_LABEL=Reconcile
0000000000000000000000000000000000000000;;	# - ADDON_MANAGER_LABEL=EnsureExists
0000000000000000000000000000000000000000;;	ADDON_MANAGER_LABEL="addonmanager.kubernetes.io/mode"
0000000000000000000000000000000000000000;;	# This label is deprecated (only for Addon Manager). In future release
0000000000000000000000000000000000000000;;	# addon-manager may not respect it anymore. Addons with
0000000000000000000000000000000000000000;;	# CLUSTER_SERVICE_LABEL=true and without ADDON_MANAGER_LABEL=EnsureExists
0000000000000000000000000000000000000000;;	# will be reconciled for now.
0000000000000000000000000000000000000000;;	CLUSTER_SERVICE_LABEL="kubernetes.io/cluster-service"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Remember that you can't log from functions that print some output (because
0000000000000000000000000000000000000000;;	# logs are also printed on stdout).
0000000000000000000000000000000000000000;;	# $1 level
0000000000000000000000000000000000000000;;	# $2 message
0000000000000000000000000000000000000000;;	function log() {
0000000000000000000000000000000000000000;;	  # manage log levels manually here
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # add the timestamp if you find it useful
0000000000000000000000000000000000000000;;	  case $1 in
0000000000000000000000000000000000000000;;	    DB3 )
0000000000000000000000000000000000000000;;	#        echo "$1: $2"
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	    DB2 )
0000000000000000000000000000000000000000;;	#        echo "$1: $2"
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	    DBG )
0000000000000000000000000000000000000000;;	#        echo "$1: $2"
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	    INFO )
0000000000000000000000000000000000000000;;	        echo "$1: $2"
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	    WRN )
0000000000000000000000000000000000000000;;	        echo "$1: $2"
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	    ERR )
0000000000000000000000000000000000000000;;	        echo "$1: $2"
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	    * )
0000000000000000000000000000000000000000;;	        echo "INVALID_LOG_LEVEL $1: $2"
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	  esac
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# $1 filename of addon to start.
0000000000000000000000000000000000000000;;	# $2 count of tries to start the addon.
0000000000000000000000000000000000000000;;	# $3 delay in seconds between two consecutive tries
0000000000000000000000000000000000000000;;	# $4 namespace
0000000000000000000000000000000000000000;;	function start_addon() {
0000000000000000000000000000000000000000;;	  local -r addon_filename=$1;
0000000000000000000000000000000000000000;;	  local -r tries=$2;
0000000000000000000000000000000000000000;;	  local -r delay=$3;
0000000000000000000000000000000000000000;;	  local -r namespace=$4
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  create_resource_from_string "$(cat ${addon_filename})" "${tries}" "${delay}" "${addon_filename}" "${namespace}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# $1 string with json or yaml.
0000000000000000000000000000000000000000;;	# $2 count of tries to start the addon.
0000000000000000000000000000000000000000;;	# $3 delay in seconds between two consecutive tries
0000000000000000000000000000000000000000;;	# $4 name of this object to use when logging about it.
0000000000000000000000000000000000000000;;	# $5 namespace for this object
0000000000000000000000000000000000000000;;	function create_resource_from_string() {
0000000000000000000000000000000000000000;;	  local -r config_string=$1;
0000000000000000000000000000000000000000;;	  local tries=$2;
0000000000000000000000000000000000000000;;	  local -r delay=$3;
0000000000000000000000000000000000000000;;	  local -r config_name=$4;
0000000000000000000000000000000000000000;;	  local -r namespace=$5;
0000000000000000000000000000000000000000;;	  while [ ${tries} -gt 0 ]; do
0000000000000000000000000000000000000000;;	    echo "${config_string}" | ${KUBECTL} ${KUBECTL_OPTS} --namespace="${namespace}" apply -f - && \
0000000000000000000000000000000000000000;;	      log INFO "== Successfully started ${config_name} in namespace ${namespace} at $(date -Is)" && \
0000000000000000000000000000000000000000;;	      return 0;
0000000000000000000000000000000000000000;;	    let tries=tries-1;
0000000000000000000000000000000000000000;;	    log WRN "== Failed to start ${config_name} in namespace ${namespace} at $(date -Is). ${tries} tries remaining. =="
0000000000000000000000000000000000000000;;	    sleep ${delay};
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  return 1;
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# $1 resource type.
0000000000000000000000000000000000000000;;	function annotate_addons() {
0000000000000000000000000000000000000000;;	  local -r obj_type=$1;
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Annotate to objects already have this annotation should fail.
0000000000000000000000000000000000000000;;	  # Only try once for now.
0000000000000000000000000000000000000000;;	  ${KUBECTL} ${KUBECTL_OPTS} annotate ${obj_type} --namespace=${SYSTEM_NAMESPACE} -l ${CLUSTER_SERVICE_LABEL}=true \
0000000000000000000000000000000000000000;;	    kubectl.kubernetes.io/last-applied-configuration='' --overwrite=false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ $? -eq 0 ]]; then
0000000000000000000000000000000000000000;;	    log INFO "== Annotate resources completed successfully at $(date -Is) =="
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    log WRN "== Annotate resources completed with errors at $(date -Is) =="
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# $1 enable --prune or not.
0000000000000000000000000000000000000000;;	function reconcile_addons() {
0000000000000000000000000000000000000000;;	  local -r enable_prune=$1;
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # TODO: Remove the first command in future release.
0000000000000000000000000000000000000000;;	  # Adding this for backward compatibility. Old addons have CLUSTER_SERVICE_LABEL=true and don't have
0000000000000000000000000000000000000000;;	  # ADDON_MANAGER_LABEL=EnsureExists will still be reconciled.
0000000000000000000000000000000000000000;;	  # Filter out `configured` message to not noisily log.
0000000000000000000000000000000000000000;;	  # `created`, `pruned` and errors will be logged.
0000000000000000000000000000000000000000;;	  log INFO "== Reconciling with deprecated label =="
0000000000000000000000000000000000000000;;	  ${KUBECTL} ${KUBECTL_OPTS} apply --namespace=${SYSTEM_NAMESPACE} -f ${ADDON_PATH} \
0000000000000000000000000000000000000000;;	    -l ${CLUSTER_SERVICE_LABEL}=true,${ADDON_MANAGER_LABEL}!=EnsureExists \
0000000000000000000000000000000000000000;;	    --prune=${enable_prune} --recursive | grep -v configured
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  log INFO "== Reconciling with addon-manager label =="
0000000000000000000000000000000000000000;;	  ${KUBECTL} ${KUBECTL_OPTS} apply --namespace=${SYSTEM_NAMESPACE} -f ${ADDON_PATH} \
0000000000000000000000000000000000000000;;	    -l ${CLUSTER_SERVICE_LABEL}!=true,${ADDON_MANAGER_LABEL}=Reconcile \
0000000000000000000000000000000000000000;;	    --prune=${enable_prune} --recursive | grep -v configured
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  log INFO "== Kubernetes addon reconcile completed at $(date -Is) =="
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function ensure_addons() {
0000000000000000000000000000000000000000;;	  # Create objects already exist should fail.
0000000000000000000000000000000000000000;;	  # Filter out `AlreadyExists` message to not noisily log.
0000000000000000000000000000000000000000;;	  ${KUBECTL} ${KUBECTL_OPTS} create --namespace=${SYSTEM_NAMESPACE} -f ${ADDON_PATH} \
0000000000000000000000000000000000000000;;	    -l ${ADDON_MANAGER_LABEL}=EnsureExists --recursive 2>&1 | grep -v AlreadyExists
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  log INFO "== Kubernetes addon ensure completed at $(date -Is) =="
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# The business logic for whether a given object should be created
0000000000000000000000000000000000000000;;	# was already enforced by salt, and /etc/kubernetes/addons is the
0000000000000000000000000000000000000000;;	# managed result is of that. Start everything below that directory.
0000000000000000000000000000000000000000;;	log INFO "== Kubernetes addon manager started at $(date -Is) with ADDON_CHECK_INTERVAL_SEC=${ADDON_CHECK_INTERVAL_SEC} =="
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Create the namespace that will be used to host the cluster-level add-ons.
0000000000000000000000000000000000000000;;	start_addon /opt/namespace.yaml 100 10 "" &
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Wait for the default service account to be created in the kube-system namespace.
0000000000000000000000000000000000000000;;	token_found=""
0000000000000000000000000000000000000000;;	while [ -z "${token_found}" ]; do
0000000000000000000000000000000000000000;;	  sleep .5
0000000000000000000000000000000000000000;;	  token_found=$(${KUBECTL} ${KUBECTL_OPTS} get --namespace="${SYSTEM_NAMESPACE}" serviceaccount default -o go-template="{{with index .secrets 0}}{{.name}}{{end}}")
0000000000000000000000000000000000000000;;	  if [[ $? -ne 0 ]]; then
0000000000000000000000000000000000000000;;	    token_found="";
0000000000000000000000000000000000000000;;	    log WRN "== Error getting default service account, retry in 0.5 second =="
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	log INFO "== Default service account in the ${SYSTEM_NAMESPACE} namespace has token ${token_found} =="
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Create admission_control objects if defined before any other addon services. If the limits
0000000000000000000000000000000000000000;;	# are defined in a namespace other than default, we should still create the limits for the
0000000000000000000000000000000000000000;;	# default namespace.
0000000000000000000000000000000000000000;;	for obj in $(find /etc/kubernetes/admission-controls \( -name \*.yaml -o -name \*.json \)); do
0000000000000000000000000000000000000000;;	  start_addon "${obj}" 100 10 default &
0000000000000000000000000000000000000000;;	  log INFO "++ obj ${obj} is created ++"
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# TODO: The annotate and spin up parts should be removed after 1.6 is released.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Fake the "kubectl.kubernetes.io/last-applied-configuration" annotation on old resources
0000000000000000000000000000000000000000;;	# in order to clean them up by `kubectl apply --prune`.
0000000000000000000000000000000000000000;;	# RCs have to be annotated for 1.4->1.5+ upgrade, because we migrated from RCs to deployments for all default addons in 1.5.
0000000000000000000000000000000000000000;;	# Other types resources will also need this fake annotation if their names are changed,
0000000000000000000000000000000000000000;;	# otherwise they would be leaked during upgrade.
0000000000000000000000000000000000000000;;	log INFO "== Annotating the old addon resources at $(date -Is) =="
0000000000000000000000000000000000000000;;	annotate_addons ReplicationController
0000000000000000000000000000000000000000;;	annotate_addons Deployment
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Create new addon resources by apply (with --prune=false).
0000000000000000000000000000000000000000;;	# The old RCs will not fight for pods created by new Deployments with the same label because the `controllerRef` feature.
0000000000000000000000000000000000000000;;	# The new Deployments will not fight for pods created by old RCs with the same label because the additional `pod-template-hash` label.
0000000000000000000000000000000000000000;;	# Apply will fail if some fields are modified but not are allowed, in that case should bump up addon version and name (e.g. handle externally).
0000000000000000000000000000000000000000;;	log INFO "== Executing apply to spin up new addon resources at $(date -Is) =="
0000000000000000000000000000000000000000;;	ensure_addons
0000000000000000000000000000000000000000;;	reconcile_addons false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Wait for new addons to be spinned up before delete old resources
0000000000000000000000000000000000000000;;	log INFO "== Wait for addons to be spinned up at $(date -Is) =="
0000000000000000000000000000000000000000;;	sleep ${ADDON_CHECK_INTERVAL_SEC}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Start the apply loop.
0000000000000000000000000000000000000000;;	# Check if the configuration has changed recently - in case the user
0000000000000000000000000000000000000000;;	# created/updated/deleted the files on the master.
0000000000000000000000000000000000000000;;	log INFO "== Entering periodical apply loop at $(date -Is) =="
0000000000000000000000000000000000000000;;	while true; do
0000000000000000000000000000000000000000;;	  start_sec=$(date +"%s")
0000000000000000000000000000000000000000;;	  # Only print stderr for the readability of logging
0000000000000000000000000000000000000000;;	  ensure_addons
0000000000000000000000000000000000000000;;	  reconcile_addons true
0000000000000000000000000000000000000000;;	  end_sec=$(date +"%s")
0000000000000000000000000000000000000000;;	  len_sec=$((${end_sec}-${start_sec}))
0000000000000000000000000000000000000000;;	  # subtract the time passed from the sleep time
0000000000000000000000000000000000000000;;	  if [[ ${len_sec} -lt ${ADDON_CHECK_INTERVAL_SEC} ]]; then
0000000000000000000000000000000000000000;;	    sleep_time=$((${ADDON_CHECK_INTERVAL_SEC}-${len_sec}))
0000000000000000000000000000000000000000;;	    sleep ${sleep_time}
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	done
