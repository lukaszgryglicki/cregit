0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
ae301fd95e3db999ae5dc41a9f49b6318a970194;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		clientapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		clientset "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildConfigFromEnvs(masterURL, kubeconfigPath string) (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		if kubeconfigPath == "" && masterURL == "" {
0000000000000000000000000000000000000000;;			kubeconfig, err := restclient.InClusterConfig()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return kubeconfig, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clientcmd.NewNonInteractiveDeferredLoadingClientConfig(
0000000000000000000000000000000000000000;;			&clientcmd.ClientConfigLoadingRules{ExplicitPath: kubeconfigPath},
0000000000000000000000000000000000000000;;			&clientcmd.ConfigOverrides{ClusterInfo: clientapi.Cluster{Server: masterURL}}).ClientConfig()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func flattenSubsets(subsets []api.EndpointSubset) []string {
0000000000000000000000000000000000000000;;		ips := []string{}
0000000000000000000000000000000000000000;;		for _, ss := range subsets {
0000000000000000000000000000000000000000;;			for _, addr := range ss.Addresses {
0000000000000000000000000000000000000000;;				ips = append(ips, fmt.Sprintf(`"%s"`, addr.IP))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ips
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Info("Kubernetes Elasticsearch logging discovery")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cc, err := buildConfigFromEnvs(os.Getenv("APISERVER_HOST"), os.Getenv("KUBE_CONFIG_FILE"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed to make client: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client, err := clientset.NewForConfig(cc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed to make client: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		namespace := metav1.NamespaceSystem
0000000000000000000000000000000000000000;;		envNamespace := os.Getenv("NAMESPACE")
0000000000000000000000000000000000000000;;		if envNamespace != "" {
0000000000000000000000000000000000000000;;			if _, err := client.Core().Namespaces().Get(envNamespace, metav1.GetOptions{}); err != nil {
0000000000000000000000000000000000000000;;				glog.Fatalf("%s namespace doesn't exist: %v", envNamespace, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			namespace = envNamespace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var elasticsearch *api.Service
0000000000000000000000000000000000000000;;		// Look for endpoints associated with the Elasticsearch loggging service.
0000000000000000000000000000000000000000;;		// First wait for the service to become available.
0000000000000000000000000000000000000000;;		for t := time.Now(); time.Since(t) < 5*time.Minute; time.Sleep(10 * time.Second) {
0000000000000000000000000000000000000000;;			elasticsearch, err = client.Core().Services(namespace).Get("elasticsearch-logging", metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If we did not find an elasticsearch logging service then log a warning
0000000000000000000000000000000000000000;;		// and return without adding any unicast hosts.
0000000000000000000000000000000000000000;;		if elasticsearch == nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Failed to find the elasticsearch-logging service: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var endpoints *api.Endpoints
0000000000000000000000000000000000000000;;		addrs := []string{}
0000000000000000000000000000000000000000;;		// Wait for some endpoints.
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		for t := time.Now(); time.Since(t) < 5*time.Minute; time.Sleep(10 * time.Second) {
0000000000000000000000000000000000000000;;			endpoints, err = client.Core().Endpoints(namespace).Get("elasticsearch-logging", metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			addrs = flattenSubsets(endpoints.Subsets)
0000000000000000000000000000000000000000;;			glog.Infof("Found %s", addrs)
0000000000000000000000000000000000000000;;			if len(addrs) > 0 && len(addrs) == count {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			count = len(addrs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If there was an error finding endpoints then log a warning and quit.
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Error finding endpoints: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Endpoints = %s", addrs)
0000000000000000000000000000000000000000;;		fmt.Printf("discovery.zen.ping.unicast.hosts: [%s]\n", strings.Join(addrs, ", "))
0000000000000000000000000000000000000000;;	}
