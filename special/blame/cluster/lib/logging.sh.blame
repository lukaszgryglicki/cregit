0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2014 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Controls verbosity of the script output and logging.
0000000000000000000000000000000000000000;;	KUBE_VERBOSE="${KUBE_VERBOSE:-5}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Handler for when we exit automatically on an error.
0000000000000000000000000000000000000000;;	# Borrowed from https://gist.github.com/ahendrix/7030300
0000000000000000000000000000000000000000;;	kube::log::errexit() {
0000000000000000000000000000000000000000;;	  local err="${PIPESTATUS[@]}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # If the shell we are in doesn't have errexit set (common in subshells) then
0000000000000000000000000000000000000000;;	  # don't dump stacks.
0000000000000000000000000000000000000000;;	  set +o | grep -qe "-o errexit" || return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  set +o xtrace
0000000000000000000000000000000000000000;;	  local code="${1:-1}"
0000000000000000000000000000000000000000;;	  # Print out the stack trace described by $function_stack  
0000000000000000000000000000000000000000;;	  if [ ${#FUNCNAME[@]} -gt 2 ]
0000000000000000000000000000000000000000;;	  then
0000000000000000000000000000000000000000;;	    kube::log::error "Call tree:"
0000000000000000000000000000000000000000;;	    for ((i=1;i<${#FUNCNAME[@]}-1;i++))
0000000000000000000000000000000000000000;;	    do
0000000000000000000000000000000000000000;;	      kube::log::error " $i: ${BASH_SOURCE[$i+1]}:${BASH_LINENO[$i]} ${FUNCNAME[$i]}(...)"
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	  fi  
0000000000000000000000000000000000000000;;	  kube::log::error_exit "Error in ${BASH_SOURCE[1]}:${BASH_LINENO[0]}. '${BASH_COMMAND}' exited with status $err" "${1:-1}" 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::log::install_errexit() {
0000000000000000000000000000000000000000;;	  # trap ERR to provide an error handler whenever a command exits nonzero  this
0000000000000000000000000000000000000000;;	  # is a more verbose version of set -o errexit
0000000000000000000000000000000000000000;;	  trap 'kube::log::errexit' ERR
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # setting errtrace allows our ERR trap handler to be propagated to functions,
0000000000000000000000000000000000000000;;	  # expansions and subshells
0000000000000000000000000000000000000000;;	  set -o errtrace
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Print out the stack trace
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Args:
0000000000000000000000000000000000000000;;	#   $1 The number of stack frames to skip when printing.
0000000000000000000000000000000000000000;;	kube::log::stack() {
0000000000000000000000000000000000000000;;	  local stack_skip=${1:-0}
0000000000000000000000000000000000000000;;	  stack_skip=$((stack_skip + 1))
0000000000000000000000000000000000000000;;	  if [[ ${#FUNCNAME[@]} -gt $stack_skip ]]; then
0000000000000000000000000000000000000000;;	    echo "Call stack:" >&2
0000000000000000000000000000000000000000;;	    local i
0000000000000000000000000000000000000000;;	    for ((i=1 ; i <= ${#FUNCNAME[@]} - $stack_skip ; i++))
0000000000000000000000000000000000000000;;	    do
0000000000000000000000000000000000000000;;	      local frame_no=$((i - 1 + stack_skip))
0000000000000000000000000000000000000000;;	      local source_file=${BASH_SOURCE[$frame_no]}
0000000000000000000000000000000000000000;;	      local source_lineno=${BASH_LINENO[$((frame_no - 1))]}
0000000000000000000000000000000000000000;;	      local funcname=${FUNCNAME[$frame_no]}
0000000000000000000000000000000000000000;;	      echo "  $i: ${source_file}:${source_lineno} ${funcname}(...)" >&2
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Log an error and exit.
0000000000000000000000000000000000000000;;	# Args:
0000000000000000000000000000000000000000;;	#   $1 Message to log with the error
0000000000000000000000000000000000000000;;	#   $2 The error code to return
0000000000000000000000000000000000000000;;	#   $3 The number of stack frames to skip when printing.
0000000000000000000000000000000000000000;;	kube::log::error_exit() {
0000000000000000000000000000000000000000;;	  local message="${1:-}"
0000000000000000000000000000000000000000;;	  local code="${2:-1}"
0000000000000000000000000000000000000000;;	  local stack_skip="${3:-0}"
0000000000000000000000000000000000000000;;	  stack_skip=$((stack_skip + 1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ ${KUBE_VERBOSE} -ge 4 ]]; then
0000000000000000000000000000000000000000;;	    local source_file=${BASH_SOURCE[$stack_skip]}
0000000000000000000000000000000000000000;;	    local source_line=${BASH_LINENO[$((stack_skip - 1))]}
0000000000000000000000000000000000000000;;	    echo "!!! Error in ${source_file}:${source_line}" >&2
0000000000000000000000000000000000000000;;	    [[ -z ${1-} ]] || {
0000000000000000000000000000000000000000;;	      echo "  ${1}" >&2
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    kube::log::stack $stack_skip
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    echo "Exiting with status ${code}" >&2
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  exit "${code}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Log an error but keep going.  Don't dump the stack or exit.
0000000000000000000000000000000000000000;;	kube::log::error() {
0000000000000000000000000000000000000000;;	  timestamp=$(date +"[%m%d %H:%M:%S]")
0000000000000000000000000000000000000000;;	  echo "!!! $timestamp ${1-}" >&2
0000000000000000000000000000000000000000;;	  shift
0000000000000000000000000000000000000000;;	  for message; do
0000000000000000000000000000000000000000;;	    echo "    $message" >&2
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Print an usage message to stderr.  The arguments are printed directly.
0000000000000000000000000000000000000000;;	kube::log::usage() {
0000000000000000000000000000000000000000;;	  echo >&2
0000000000000000000000000000000000000000;;	  local message
0000000000000000000000000000000000000000;;	  for message; do
0000000000000000000000000000000000000000;;	    echo "$message" >&2
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  echo >&2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::log::usage_from_stdin() {
0000000000000000000000000000000000000000;;	  local messages=()
0000000000000000000000000000000000000000;;	  while read -r line; do
0000000000000000000000000000000000000000;;	    messages+=("$line")
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::log::usage "${messages[@]}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Print out some info that isn't a top level status line
0000000000000000000000000000000000000000;;	kube::log::info() {
0000000000000000000000000000000000000000;;	  local V="${V:-0}"
0000000000000000000000000000000000000000;;	  if [[ $KUBE_VERBOSE < $V ]]; then
0000000000000000000000000000000000000000;;	    return
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for message; do
0000000000000000000000000000000000000000;;	    echo "$message"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Just like kube::log::info, but no \n, so you can make a progress bar
0000000000000000000000000000000000000000;;	kube::log::progress() {
0000000000000000000000000000000000000000;;	  for message; do
0000000000000000000000000000000000000000;;	    echo -e -n "$message"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::log::info_from_stdin() {
0000000000000000000000000000000000000000;;	  local messages=()
0000000000000000000000000000000000000000;;	  while read -r line; do
0000000000000000000000000000000000000000;;	    messages+=("$line")
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::log::info "${messages[@]}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Print a status line.  Formatted to show up in a stream of output.
0000000000000000000000000000000000000000;;	kube::log::status() {
0000000000000000000000000000000000000000;;	  local V="${V:-0}"
0000000000000000000000000000000000000000;;	  if [[ $KUBE_VERBOSE < $V ]]; then
0000000000000000000000000000000000000000;;	    return
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  timestamp=$(date +"[%m%d %H:%M:%S]")
0000000000000000000000000000000000000000;;	  echo "+++ $timestamp $1"
0000000000000000000000000000000000000000;;	  shift
0000000000000000000000000000000000000000;;	  for message; do
0000000000000000000000000000000000000000;;	    echo "    $message"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
