0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2015 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	set -o errexit
0000000000000000000000000000000000000000;;	set -o nounset
0000000000000000000000000000000000000000;;	set -o pipefail
0000000000000000000000000000000000000000;;	#set -o xtrace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	UTIL_SCRIPT=$(readlink -m "${BASH_SOURCE}")
0000000000000000000000000000000000000000;;	JUJU_PATH=$(dirname ${UTIL_SCRIPT})
0000000000000000000000000000000000000000;;	KUBE_ROOT=$(readlink -m ${JUJU_PATH}/../../)
0000000000000000000000000000000000000000;;	# Use the config file specified in $KUBE_CONFIG_FILE, or config-default.sh.
0000000000000000000000000000000000000000;;	source "${JUJU_PATH}/${KUBE_CONFIG_FILE-config-default.sh}"
0000000000000000000000000000000000000000;;	# This attempts installation of Juju - This really needs to support multiple
0000000000000000000000000000000000000000;;	# providers/distros - but I'm super familiar with ubuntu so assume that for now.
0000000000000000000000000000000000000000;;	source "${JUJU_PATH}/prereqs/ubuntu-juju.sh"
0000000000000000000000000000000000000000;;	export JUJU_REPOSITORY="${JUJU_PATH}/charms"
0000000000000000000000000000000000000000;;	KUBE_BUNDLE_PATH="${JUJU_PATH}/bundles/local.yaml"
0000000000000000000000000000000000000000;;	# The directory for the kubectl binary, this is one of the paths in kubectl.sh.
0000000000000000000000000000000000000000;;	KUBECTL_DIR="${KUBE_ROOT}/platforms/linux/amd64"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function build-local() {
0000000000000000000000000000000000000000;;	    # This used to build the kubernetes project. Now it rebuilds the charm(s)
0000000000000000000000000000000000000000;;	    # living in `cluster/juju/layers`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    charm build ${JUJU_PATH}/layers/kubernetes -o $JUJU_REPOSITORY -r --no-local-layers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function detect-master() {
0000000000000000000000000000000000000000;;	    local kubestatus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Capturing a newline, and my awk-fu was weak - pipe through tr -d
0000000000000000000000000000000000000000;;	    kubestatus=$(juju status --format=oneline kubernetes | grep ${KUBE_MASTER_NAME} | awk '{print $3}' | tr -d "\n")
0000000000000000000000000000000000000000;;	    export KUBE_MASTER_IP=${kubestatus}
0000000000000000000000000000000000000000;;	    export KUBE_SERVER=https://${KUBE_MASTER_IP}:6433
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function detect-nodes() {
0000000000000000000000000000000000000000;;	    # Run the Juju command that gets the minion private IP addresses.
0000000000000000000000000000000000000000;;	    local ipoutput
0000000000000000000000000000000000000000;;	    ipoutput=$(juju run --application kubernetes "unit-get private-address" --format=json)
0000000000000000000000000000000000000000;;	    # [
0000000000000000000000000000000000000000;;	    # {"MachineId":"2","Stdout":"192.168.122.188\n","UnitId":"kubernetes/0"},
0000000000000000000000000000000000000000;;	    # {"MachineId":"3","Stdout":"192.168.122.166\n","UnitId":"kubernetes/1"}
0000000000000000000000000000000000000000;;	    # ]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Strip out the IP addresses
0000000000000000000000000000000000000000;;	    export KUBE_NODE_IP_ADDRESSES=($(${JUJU_PATH}/return-node-ips.py "${ipoutput}"))
0000000000000000000000000000000000000000;;	    # echo "Kubernetes minions: " ${KUBE_NODE_IP_ADDRESSES[@]} 1>&2
0000000000000000000000000000000000000000;;	    export NUM_NODES=${#KUBE_NODE_IP_ADDRESSES[@]}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube-up() {
0000000000000000000000000000000000000000;;	    build-local
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Replace the charm directory in the bundle.
0000000000000000000000000000000000000000;;	    sed "s|__CHARM_DIR__|${JUJU_REPOSITORY}|" < ${KUBE_BUNDLE_PATH}.base > ${KUBE_BUNDLE_PATH}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # The juju-deployer command will deploy the bundle and can be run
0000000000000000000000000000000000000000;;	    # multiple times to continue deploying the parts that fail.
0000000000000000000000000000000000000000;;	    juju deploy ${KUBE_BUNDLE_PATH}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    source "${KUBE_ROOT}/cluster/common.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Sleep due to juju bug http://pad.lv/1432759
0000000000000000000000000000000000000000;;	    sleep-status
0000000000000000000000000000000000000000;;	    detect-master
0000000000000000000000000000000000000000;;	    detect-nodes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Copy kubectl, the cert and key to this machine from master.
0000000000000000000000000000000000000000;;	    (
0000000000000000000000000000000000000000;;	      umask 077
0000000000000000000000000000000000000000;;	      mkdir -p ${KUBECTL_DIR}
0000000000000000000000000000000000000000;;	      juju scp ${KUBE_MASTER_NAME}:kubectl_package.tar.gz ${KUBECTL_DIR}
0000000000000000000000000000000000000000;;	      tar xfz ${KUBECTL_DIR}/kubectl_package.tar.gz -C ${KUBECTL_DIR}
0000000000000000000000000000000000000000;;	    )
0000000000000000000000000000000000000000;;	    # Export the location of the kubectl configuration file.
0000000000000000000000000000000000000000;;	    export KUBECONFIG="${KUBECTL_DIR}/kubeconfig"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube-down() {
0000000000000000000000000000000000000000;;	    local force="${1-}"
0000000000000000000000000000000000000000;;	    local jujuenv
0000000000000000000000000000000000000000;;	    jujuenv=$(juju switch)
0000000000000000000000000000000000000000;;	    juju destroy-model ${jujuenv} ${force} || true
0000000000000000000000000000000000000000;;	    # Clean up the generated charm files.
0000000000000000000000000000000000000000;;	    rm -rf ${KUBE_ROOT}/cluster/juju/charms
0000000000000000000000000000000000000000;;	    # Clean up the kubectl binary and config file.
0000000000000000000000000000000000000000;;	    rm -rf ${KUBECTL_DIR}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function prepare-e2e() {
0000000000000000000000000000000000000000;;	  echo "prepare-e2e() The Juju provider does not need any preparations for e2e." 1>&2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function sleep-status() {
0000000000000000000000000000000000000000;;	    local i
0000000000000000000000000000000000000000;;	    local maxtime
0000000000000000000000000000000000000000;;	    local jujustatus
0000000000000000000000000000000000000000;;	    i=0
0000000000000000000000000000000000000000;;	    maxtime=900
0000000000000000000000000000000000000000;;	    jujustatus=''
0000000000000000000000000000000000000000;;	    echo "Waiting up to 15 minutes to allow the cluster to come online... wait for it..." 1>&2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    while [[ $i < $maxtime && -z $jujustatus ]]; do
0000000000000000000000000000000000000000;;	      sleep 15
0000000000000000000000000000000000000000;;	      i=$((i + 15))
0000000000000000000000000000000000000000;;	      jujustatus=$(${JUJU_PATH}/identify-leaders.py)
0000000000000000000000000000000000000000;;	      export KUBE_MASTER_NAME=${jujustatus}
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Execute prior to running tests to build a release if required for environment.
0000000000000000000000000000000000000000;;	function test-build-release {
0000000000000000000000000000000000000000;;	    echo "test-build-release() " 1>&2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Execute prior to running tests to initialize required structure. This is
0000000000000000000000000000000000000000;;	# called from hack/e2e.go only when running -up.
0000000000000000000000000000000000000000;;	function test-setup {
0000000000000000000000000000000000000000;;	  "${KUBE_ROOT}/cluster/kube-up.sh"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Execute after running tests to perform any required clean-up. This is called
0000000000000000000000000000000000000000;;	# from hack/e2e.go
0000000000000000000000000000000000000000;;	function test-teardown() {
0000000000000000000000000000000000000000;;	    kube-down "-y"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Verify the prerequisites are statisfied before running.
0000000000000000000000000000000000000000;;	function verify-prereqs() {
0000000000000000000000000000000000000000;;	    gather_installation_reqs
0000000000000000000000000000000000000000;;	}
