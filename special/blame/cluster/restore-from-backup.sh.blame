0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2016 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This script performs disaster recovery of etcd from the backup data.
0000000000000000000000000000000000000000;;	# Assumptions:
0000000000000000000000000000000000000000;;	# - backup was done using etcdctl command:
0000000000000000000000000000000000000000;;	#   a) in case of etcd2
0000000000000000000000000000000000000000;;	#      $ etcdctl backup --data-dir=<dir>
0000000000000000000000000000000000000000;;	#      produced .snap and .wal files
0000000000000000000000000000000000000000;;	#   b) in case of etcd3
0000000000000000000000000000000000000000;;	#      $ etcdctl --endpoints=<address> snapshot save
0000000000000000000000000000000000000000;;	#      produced .db file
0000000000000000000000000000000000000000;;	# - version.txt file is in the current directy (if it isn't it will be
0000000000000000000000000000000000000000;;	#     defaulted to "2.2.1/etcd2"). Based on this file, the script will
0000000000000000000000000000000000000000;;	#     decide to which version we are restoring (procedures are different
0000000000000000000000000000000000000000;;	#     for etcd2 and etcd3).
0000000000000000000000000000000000000000;;	# - in case of etcd2 - *.snap and *.wal files are in current directory
0000000000000000000000000000000000000000;;	# - in case of etcd3 - *.db file is in the current directory
0000000000000000000000000000000000000000;;	# - the script is run as root
0000000000000000000000000000000000000000;;	# - for event etcd, we only support clearing it - to do it, you need to
0000000000000000000000000000000000000000;;	#   set RESET_EVENT_ETCD=true env var.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	set -o errexit
0000000000000000000000000000000000000000;;	set -o nounset
0000000000000000000000000000000000000000;;	set -o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Version file contains information about current version in the format:
0000000000000000000000000000000000000000;;	# <etcd binary version>/<etcd api mode> (e.g. "3.0.12/etcd3").
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# If the file doesn't exist we assume "2.2.1/etcd2" configuration is
0000000000000000000000000000000000000000;;	# the current one and create a file with such configuration.
0000000000000000000000000000000000000000;;	# The restore procedure is chosen based on this information.
0000000000000000000000000000000000000000;;	VERSION_FILE="version.txt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Make it possible to overwrite version file (or default version)
0000000000000000000000000000000000000000;;	# with VERSION_CONTENTS env var.
0000000000000000000000000000000000000000;;	if [ -n "${VERSION_CONTENTS:-}" ]; then
0000000000000000000000000000000000000000;;	  echo "${VERSION_CONTENTS}" > "${VERSION_FILE}"
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	if [ ! -f "${VERSION_FILE}" ]; then
0000000000000000000000000000000000000000;;	  echo "2.2.1/etcd2" > "${VERSION_FILE}"
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	VERSION_CONTENTS="$(cat ${VERSION_FILE})"
0000000000000000000000000000000000000000;;	ETCD_VERSION="$(echo $VERSION_CONTENTS | cut -d '/' -f 1)"
0000000000000000000000000000000000000000;;	ETCD_API="$(echo $VERSION_CONTENTS | cut -d '/' -f 2)"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Name is used only in case of etcd3 mode, to appropriate set the metadata
0000000000000000000000000000000000000000;;	# for the etcd data.
0000000000000000000000000000000000000000;;	# NOTE: NAME HAS TO BE EQUAL TO WHAT WE USE IN --name flag when starting etcd.
0000000000000000000000000000000000000000;;	NAME="${NAME:-etcd-$(hostname)}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Port on which etcd is exposed.
0000000000000000000000000000000000000000;;	etcd_port=2379
0000000000000000000000000000000000000000;;	event_etcd_port=4002
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Wait until both etcd instances are up
0000000000000000000000000000000000000000;;	wait_for_etcd_up() {
0000000000000000000000000000000000000000;;	  port=$1
0000000000000000000000000000000000000000;;	  # TODO: As of 3.0.x etcd versions, all 2.* and 3.* versions return
0000000000000000000000000000000000000000;;	  # {"health": "true"} on /health endpoint in healthy case.
0000000000000000000000000000000000000000;;	  # However, we should come with a regex for it to avoid future break.
0000000000000000000000000000000000000000;;	  health_ok="{\"health\": \"true\"}"
0000000000000000000000000000000000000000;;	  for i in $(seq 120); do
0000000000000000000000000000000000000000;;	    # TODO: Is it enough to look into /health endpoint?
0000000000000000000000000000000000000000;;	    health=$(curl --silent http://127.0.0.1:${port}/health)
0000000000000000000000000000000000000000;;	    if [ "${health}" == "${health_ok}" ]; then
0000000000000000000000000000000000000000;;	      return 0
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    sleep 1
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  return 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Wait until apiserver is up.
0000000000000000000000000000000000000000;;	wait_for_cluster_healthy() {
0000000000000000000000000000000000000000;;	  for i in $(seq 120); do
0000000000000000000000000000000000000000;;	    cs_status=$(kubectl get componentstatuses -o template --template='{{range .items}}{{with index .conditions 0}}{{.type}}:{{.status}}{{end}}{{"\n"}}{{end}}') || true
0000000000000000000000000000000000000000;;	    componentstatuses=$(echo "${cs_status}" | grep -c 'Healthy:') || true
0000000000000000000000000000000000000000;;	    healthy=$(echo "${cs_status}" | grep -c 'Healthy:True') || true
0000000000000000000000000000000000000000;;	    if [ "${componentstatuses}" -eq "${healthy}" ]; then
0000000000000000000000000000000000000000;;	      return 0
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    sleep 1
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  return 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Wait until etcd and apiserver pods are down.
0000000000000000000000000000000000000000;;	wait_for_etcd_and_apiserver_down() {
0000000000000000000000000000000000000000;;	  for i in $(seq 120); do
0000000000000000000000000000000000000000;;	    etcd=$(docker ps | grep etcd | grep -v etcd-empty-dir | grep -v etcd-monitor | wc -l)
0000000000000000000000000000000000000000;;	    apiserver=$(docker ps | grep apiserver | wc -l)
0000000000000000000000000000000000000000;;	    # TODO: Theoretically it is possible, that apiserver and or etcd
0000000000000000000000000000000000000000;;	    # are currently down, but Kubelet is now restarting them and they
0000000000000000000000000000000000000000;;	    # will reappear again. We should avoid it.
0000000000000000000000000000000000000000;;	    if [ "${etcd}" -eq "0" -a "${apiserver}" -eq "0" ]; then
0000000000000000000000000000000000000000;;	      return 0
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    sleep 1
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  return 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Move the manifest files to stop etcd and kube-apiserver
0000000000000000000000000000000000000000;;	# while we swap the data out from under them.
0000000000000000000000000000000000000000;;	MANIFEST_DIR="/etc/kubernetes/manifests"
0000000000000000000000000000000000000000;;	MANIFEST_BACKUP_DIR="/etc/kubernetes/manifests-backups"
0000000000000000000000000000000000000000;;	mkdir -p "${MANIFEST_BACKUP_DIR}"
0000000000000000000000000000000000000000;;	echo "Moving etcd(s) & apiserver manifest files to ${MANIFEST_BACKUP_DIR}"
0000000000000000000000000000000000000000;;	# If those files were already moved (e.g. during previous
0000000000000000000000000000000000000000;;	# try of backup) don't fail on it.
0000000000000000000000000000000000000000;;	mv "${MANIFEST_DIR}/kube-apiserver.manifest" "${MANIFEST_BACKUP_DIR}" || true
0000000000000000000000000000000000000000;;	mv "${MANIFEST_DIR}/etcd.manifest" "${MANIFEST_BACKUP_DIR}" || true
0000000000000000000000000000000000000000;;	mv "${MANIFEST_DIR}/etcd-events.manifest" "${MANIFEST_BACKUP_DIR}" || true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Wait for the pods to be stopped
0000000000000000000000000000000000000000;;	echo "Waiting for etcd and kube-apiserver to be down"
0000000000000000000000000000000000000000;;	if ! wait_for_etcd_and_apiserver_down; then
0000000000000000000000000000000000000000;;	  # Couldn't kill etcd and apiserver.
0000000000000000000000000000000000000000;;	  echo "Downing etcd and apiserver failed"
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Create the sort of directory structure that etcd expects.
0000000000000000000000000000000000000000;;	# If this directory already exists, remove it.
0000000000000000000000000000000000000000;;	BACKUP_DIR="/var/tmp/backup"
0000000000000000000000000000000000000000;;	rm -rf "${BACKUP_DIR}"
0000000000000000000000000000000000000000;;	if [ "${ETCD_API}" == "etcd2" ]; then
0000000000000000000000000000000000000000;;	  echo "Preparing etcd backup data for restore"
0000000000000000000000000000000000000000;;	  # In v2 mode, we simply copy both snap and wal files to a newly created
0000000000000000000000000000000000000000;;	  # directory. After that, we start etcd with --force-new-cluster option
0000000000000000000000000000000000000000;;	  # that (according to the etcd documentation) is required to recover from
0000000000000000000000000000000000000000;;	  # a backup.
0000000000000000000000000000000000000000;;	  echo "Copying data to ${BACKUP_DIR} and restoring there"
0000000000000000000000000000000000000000;;	  mkdir -p "${BACKUP_DIR}/member/snap"
0000000000000000000000000000000000000000;;	  mkdir -p "${BACKUP_DIR}/member/wal"
0000000000000000000000000000000000000000;;	  # If the cluster is relatively new, there can be no .snap file.
0000000000000000000000000000000000000000;;	  mv *.snap "${BACKUP_DIR}/member/snap/" || true
0000000000000000000000000000000000000000;;	  mv *.wal "${BACKUP_DIR}/member/wal/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # TODO(jsz): This won't work with HA setups (e.g. do we need to set --name flag)?
0000000000000000000000000000000000000000;;	  echo "Starting etcd ${ETCD_VERSION} to restore data"
0000000000000000000000000000000000000000;;	  image=$(docker run -d -v ${BACKUP_DIR}:/var/etcd/data \
0000000000000000000000000000000000000000;;	    --net=host -p ${etcd_port}:${etcd_port} \
0000000000000000000000000000000000000000;;	    "gcr.io/google_containers/etcd:${ETCD_VERSION}" /bin/sh -c \
0000000000000000000000000000000000000000;;	    "/usr/local/bin/etcd --data-dir /var/etcd/data --force-new-cluster")
0000000000000000000000000000000000000000;;	  if [ "$?" -ne "0" ]; then
0000000000000000000000000000000000000000;;	    echo "Docker container didn't started correctly"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  echo "Container ${image} created, waiting for etcd to report as healthy"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if ! wait_for_etcd_up "${etcd_port}"; then
0000000000000000000000000000000000000000;;	    echo "Etcd didn't come back correctly"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Kill that etcd instance.
0000000000000000000000000000000000000000;;	  echo "Etcd healthy - killing ${image} container"
0000000000000000000000000000000000000000;;	  docker kill "${image}"
0000000000000000000000000000000000000000;;	elif [ "${ETCD_API}" == "etcd3" ]; then
0000000000000000000000000000000000000000;;	  echo "Preparing etcd snapshot for restore"
0000000000000000000000000000000000000000;;	  mkdir -p "${BACKUP_DIR}"
0000000000000000000000000000000000000000;;	  echo "Copying data to ${BACKUP_DIR} and restoring there"
0000000000000000000000000000000000000000;;	  number_files=$(find . -maxdepth 1 -type f -name "*.db" | wc -l)
0000000000000000000000000000000000000000;;	  if [ "${number_files}" -ne "1" ]; then
0000000000000000000000000000000000000000;;	    echo "Incorrect number of *.db files - expected 1"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  mv *.db "${BACKUP_DIR}/"
0000000000000000000000000000000000000000;;	  snapshot="$(ls ${BACKUP_DIR})"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Run etcdctl snapshot restore command and wait until it is finished.
0000000000000000000000000000000000000000;;	  # setting with --name in the etcd manifest file and then it seems to work.
0000000000000000000000000000000000000000;;	  # TODO(jsz): This command may not work in case of HA.
0000000000000000000000000000000000000000;;	  image=$(docker run -d -v ${BACKUP_DIR}:/var/tmp/backup --env ETCDCTL_API=3 \
0000000000000000000000000000000000000000;;	    "gcr.io/google_containers/etcd:${ETCD_VERSION}" /bin/sh -c \
0000000000000000000000000000000000000000;;	    "/usr/local/bin/etcdctl snapshot restore ${BACKUP_DIR}/${snapshot} --name ${NAME} --initial-cluster ${NAME}=http://localhost:2380; mv /${NAME}.etcd/member /var/tmp/backup/")
0000000000000000000000000000000000000000;;	  if [ "$?" -ne "0" ]; then
0000000000000000000000000000000000000000;;	    echo "Docker container didn't started correctly"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  echo "Prepare container exit code: $(docker wait ${image})"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  rm -f "${BACKUP_DIR}/${snapshot}"
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	# Also copy version.txt file.
0000000000000000000000000000000000000000;;	cp "${VERSION_FILE}" "${BACKUP_DIR}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Find out if we are running GCI vs CVM.
0000000000000000000000000000000000000000;;	export CVM=$(curl "http://metadata/computeMetadata/v1/instance/attributes/" -H "Metadata-Flavor: Google" |& grep -q gci; echo $?)
0000000000000000000000000000000000000000;;	if [[ "$CVM" == "1" ]]; then
0000000000000000000000000000000000000000;;	  export MNT_DISK="/mnt/master-pd"
0000000000000000000000000000000000000000;;	else
0000000000000000000000000000000000000000;;	  export MNT_DISK="/mnt/disks/master-pd"
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Save the corrupted data (clean directory if it is already non-empty).
0000000000000000000000000000000000000000;;	rm -rf "${MNT_DISK}/var/etcd-corrupted"
0000000000000000000000000000000000000000;;	mkdir -p "${MNT_DISK}/var/etcd-corrupted"
0000000000000000000000000000000000000000;;	echo "Saving corrupted data to ${MNT_DISK}/var/etcd-corrupted"
0000000000000000000000000000000000000000;;	mv /var/etcd/data "${MNT_DISK}/var/etcd-corrupted"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Replace the corrupted data dir with the resotred data.
0000000000000000000000000000000000000000;;	echo "Copying restored data to /var/etcd/data"
0000000000000000000000000000000000000000;;	mv "${BACKUP_DIR}" /var/etcd/data
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [ "${RESET_EVENT_ETCD:-}" == "true" ]; then
0000000000000000000000000000000000000000;;	  echo "Removing event-etcd corrupted data"
0000000000000000000000000000000000000000;;	  EVENTS_CORRUPTED_DIR="${MNT_DISK}/var/etcd-events-corrupted"
0000000000000000000000000000000000000000;;	  # Save the corrupted data (clean directory if it is already non-empty).
0000000000000000000000000000000000000000;;	  rm -rf "${EVENTS_CORRUPTED_DIR}"
0000000000000000000000000000000000000000;;	  mkdir -p "${EVENTS_CORRUPTED_DIR}"
0000000000000000000000000000000000000000;;	  mv /var/etcd/data-events "${EVENTS_CORRUPTED_DIR}"
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Start etcd and kube-apiserver again.
0000000000000000000000000000000000000000;;	echo "Restarting etcd and apiserver from restored snapshot"
0000000000000000000000000000000000000000;;	mv "${MANIFEST_BACKUP_DIR}"/* "${MANIFEST_DIR}/"
0000000000000000000000000000000000000000;;	rm -rf "${MANIFEST_BACKUP_DIR}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Verify that etcd is back.
0000000000000000000000000000000000000000;;	echo "Waiting for etcd to come back"
0000000000000000000000000000000000000000;;	if ! wait_for_etcd_up "${etcd_port}"; then
0000000000000000000000000000000000000000;;	  echo "Etcd didn't come back correctly"
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Verify that event etcd is back.
0000000000000000000000000000000000000000;;	echo "Waiting for event etcd to come back"
0000000000000000000000000000000000000000;;	if ! wait_for_etcd_up "${event_etcd_port}"; then
0000000000000000000000000000000000000000;;	  echo "Event etcd didn't come back correctly"
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Verify that kube-apiserver is back and cluster is healthy.
0000000000000000000000000000000000000000;;	echo "Waiting for apiserver to come back"
0000000000000000000000000000000000000000;;	if ! wait_for_cluster_healthy; then
0000000000000000000000000000000000000000;;	  echo "Apiserver didn't come back correctly"
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo "Cluster successfully restored!"
