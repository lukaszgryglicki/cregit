0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
c2e86248518ae112ebf4a8a270f2bdd0b724af06;pkg/master/server/server.go[pkg/master/server/server.go][cmd/kube-apiserver/app/server.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package app does all of the work necessary to create a Kubernetes
0000000000000000000000000000000000000000;;	// APIServer by binding together the API, master and APIServer infrastructure.
0000000000000000000000000000000000000000;;	// It can be configured and called directly or via the hyperkube framework.
0000000000000000000000000000000000000000;;	package app
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/openapi"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		utilwait "k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/authenticator"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		genericapiserver "k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/filters"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/options/encryptionconfig"
0000000000000000000000000000000000000000;;		serverstorage "k8s.io/apiserver/pkg/server/storage"
0000000000000000000000000000000000000000;;		aggregatorapiserver "k8s.io/kube-aggregator/pkg/apiserver"
0000000000000000000000000000000000000000;;		//aggregatorinformers "k8s.io/kube-aggregator/pkg/client/informers/internalversion"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientgoinformers "k8s.io/client-go/informers"
0000000000000000000000000000000000000000;;		clientgoclientset "k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kube-apiserver/app/options"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kube-apiserver/app/preflight"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/apps"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/batch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/networking"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/capabilities"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		serviceaccountcontroller "k8s.io/kubernetes/pkg/controller/serviceaccount"
0000000000000000000000000000000000000000;;		generatedopenapi "k8s.io/kubernetes/pkg/generated/openapi"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubeapiserver"
0000000000000000000000000000000000000000;;		kubeapiserveradmission "k8s.io/kubernetes/pkg/kubeapiserver/admission"
0000000000000000000000000000000000000000;;		kubeauthenticator "k8s.io/kubernetes/pkg/kubeapiserver/authenticator"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubeapiserver/authorizer/modes"
0000000000000000000000000000000000000000;;		kubeoptions "k8s.io/kubernetes/pkg/kubeapiserver/options"
0000000000000000000000000000000000000000;;		kubeserver "k8s.io/kubernetes/pkg/kubeapiserver/server"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/master"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/master/tunneler"
0000000000000000000000000000000000000000;;		quotainstall "k8s.io/kubernetes/pkg/quota/install"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/cachesize"
0000000000000000000000000000000000000000;;		rbacrest "k8s.io/kubernetes/pkg/registry/rbac/rest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/version"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/auth/authenticator/token/bootstrap"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const etcdRetryLimit = 60
0000000000000000000000000000000000000000;;	const etcdRetryInterval = 1 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAPIServerCommand creates a *cobra.Command object with default parameters
0000000000000000000000000000000000000000;;	func NewAPIServerCommand() *cobra.Command {
0000000000000000000000000000000000000000;;		s := options.NewServerRunOptions()
0000000000000000000000000000000000000000;;		s.AddFlags(pflag.CommandLine)
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use: "kube-apiserver",
0000000000000000000000000000000000000000;;			Long: `The Kubernetes API server validates and configures data
0000000000000000000000000000000000000000;;	for the api objects which include pods, services, replicationcontrollers, and
0000000000000000000000000000000000000000;;	others. The API Server services REST operations and provides the frontend to the
0000000000000000000000000000000000000000;;	cluster's shared state through which all other components interact.`,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run runs the specified APIServer.  This should never exit.
0000000000000000000000000000000000000000;;	func Run(runOptions *options.ServerRunOptions, stopCh <-chan struct{}) error {
0000000000000000000000000000000000000000;;		// To help debugging, immediately log version
0000000000000000000000000000000000000000;;		glog.Infof("Version: %+v", version.Get())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server, err := CreateServerChain(runOptions, stopCh)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return server.PrepareRun().Run(stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateServerChain creates the apiservers connected via delegation.
0000000000000000000000000000000000000000;;	func CreateServerChain(runOptions *options.ServerRunOptions, stopCh <-chan struct{}) (*genericapiserver.GenericAPIServer, error) {
0000000000000000000000000000000000000000;;		nodeTunneler, proxyTransport, err := CreateNodeDialer(runOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kubeAPIServerConfig, sharedInformers, versionedInformers, insecureServingOptions, serviceResolver, err := CreateKubeAPIServerConfig(runOptions, nodeTunneler, proxyTransport)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TPRs are enabled and not yet beta, since this these are the successor, they fall under the same enablement rule
0000000000000000000000000000000000000000;;		// If additional API servers are added, they should be gated.
0000000000000000000000000000000000000000;;		apiExtensionsConfig, err := createAPIExtensionsConfig(*kubeAPIServerConfig.GenericConfig, runOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		apiExtensionsServer, err := createAPIExtensionsServer(apiExtensionsConfig, genericapiserver.EmptyDelegate)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeAPIServer, err := CreateKubeAPIServer(kubeAPIServerConfig, apiExtensionsServer.GenericAPIServer, sharedInformers)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we're starting up a hacked up version of this API server for a weird test case,
0000000000000000000000000000000000000000;;		// just start the API server as is because clients don't get built correctly when you do this
0000000000000000000000000000000000000000;;		if len(os.Getenv("KUBE_API_VERSIONS")) > 0 {
0000000000000000000000000000000000000000;;			if insecureServingOptions != nil {
0000000000000000000000000000000000000000;;				insecureHandlerChain := kubeserver.BuildInsecureHandlerChain(kubeAPIServer.GenericAPIServer.UnprotectedHandler(), kubeAPIServerConfig.GenericConfig)
0000000000000000000000000000000000000000;;				if err := kubeserver.NonBlockingRun(insecureServingOptions, insecureHandlerChain, stopCh); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return kubeAPIServer.GenericAPIServer, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// otherwise go down the normal path of standing the aggregator up in front of the API server
0000000000000000000000000000000000000000;;		// this wires up openapi
0000000000000000000000000000000000000000;;		kubeAPIServer.GenericAPIServer.PrepareRun()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// aggregator comes last in the chain
0000000000000000000000000000000000000000;;		aggregatorConfig, err := createAggregatorConfig(*kubeAPIServerConfig.GenericConfig, runOptions, versionedInformers, serviceResolver, proxyTransport)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		aggregatorConfig.ProxyTransport = proxyTransport
0000000000000000000000000000000000000000;;		aggregatorConfig.ServiceResolver = serviceResolver
0000000000000000000000000000000000000000;;		aggregatorServer, err := createAggregatorServer(aggregatorConfig, kubeAPIServer.GenericAPIServer, apiExtensionsServer.Informers)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// we don't need special handling for innerStopCh because the aggregator server doesn't create any go routines
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if insecureServingOptions != nil {
0000000000000000000000000000000000000000;;			insecureHandlerChain := kubeserver.BuildInsecureHandlerChain(aggregatorServer.GenericAPIServer.UnprotectedHandler(), kubeAPIServerConfig.GenericConfig)
0000000000000000000000000000000000000000;;			if err := kubeserver.NonBlockingRun(insecureServingOptions, insecureHandlerChain, stopCh); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return aggregatorServer.GenericAPIServer, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateKubeAPIServer creates and wires a workable kube-apiserver
0000000000000000000000000000000000000000;;	func CreateKubeAPIServer(kubeAPIServerConfig *master.Config, delegateAPIServer genericapiserver.DelegationTarget, sharedInformers informers.SharedInformerFactory) (*master.Master, error) {
0000000000000000000000000000000000000000;;		kubeAPIServer, err := kubeAPIServerConfig.Complete().New(delegateAPIServer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kubeAPIServer.GenericAPIServer.AddPostStartHook("start-kube-apiserver-informers", func(context genericapiserver.PostStartHookContext) error {
0000000000000000000000000000000000000000;;			sharedInformers.Start(context.StopCh)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return kubeAPIServer, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateNodeDialer creates the dialer infrastructure to connect to the nodes.
0000000000000000000000000000000000000000;;	func CreateNodeDialer(s *options.ServerRunOptions) (tunneler.Tunneler, *http.Transport, error) {
0000000000000000000000000000000000000000;;		// Setup nodeTunneler if needed
0000000000000000000000000000000000000000;;		var nodeTunneler tunneler.Tunneler
0000000000000000000000000000000000000000;;		var proxyDialerFn utilnet.DialFunc
0000000000000000000000000000000000000000;;		if len(s.SSHUser) > 0 {
0000000000000000000000000000000000000000;;			// Get ssh key distribution func, if supported
0000000000000000000000000000000000000000;;			var installSSHKey tunneler.InstallSSHKey
0000000000000000000000000000000000000000;;			cloud, err := cloudprovider.InitCloudProvider(s.CloudProvider.CloudProvider, s.CloudProvider.CloudConfigFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, fmt.Errorf("cloud provider could not be initialized: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cloud != nil {
0000000000000000000000000000000000000000;;				if instances, supported := cloud.Instances(); supported {
0000000000000000000000000000000000000000;;					installSSHKey = instances.AddSSHKeyToAllInstances
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s.KubeletConfig.Port == 0 {
0000000000000000000000000000000000000000;;				return nil, nil, fmt.Errorf("must enable kubelet port if proxy ssh-tunneling is specified")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s.KubeletConfig.ReadOnlyPort == 0 {
0000000000000000000000000000000000000000;;				return nil, nil, fmt.Errorf("must enable kubelet readonly port if proxy ssh-tunneling is specified")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Set up the nodeTunneler
0000000000000000000000000000000000000000;;			// TODO(cjcullen): If we want this to handle per-kubelet ports or other
0000000000000000000000000000000000000000;;			// kubelet listen-addresses, we need to plumb through options.
0000000000000000000000000000000000000000;;			healthCheckPath := &url.URL{
0000000000000000000000000000000000000000;;				Scheme: "http",
0000000000000000000000000000000000000000;;				Host:   net.JoinHostPort("127.0.0.1", strconv.FormatUint(uint64(s.KubeletConfig.ReadOnlyPort), 10)),
0000000000000000000000000000000000000000;;				Path:   "healthz",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nodeTunneler = tunneler.New(s.SSHUser, s.SSHKeyfile, healthCheckPath, installSSHKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Use the nodeTunneler's dialer when proxying to pods, services, and nodes
0000000000000000000000000000000000000000;;			proxyDialerFn = nodeTunneler.Dial
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Proxying to pods and services is IP-based... don't expect to be able to verify the hostname
0000000000000000000000000000000000000000;;		proxyTLSClientConfig := &tls.Config{InsecureSkipVerify: true}
0000000000000000000000000000000000000000;;		proxyTransport := utilnet.SetTransportDefaults(&http.Transport{
0000000000000000000000000000000000000000;;			Dial:            proxyDialerFn,
0000000000000000000000000000000000000000;;			TLSClientConfig: proxyTLSClientConfig,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return nodeTunneler, proxyTransport, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateKubeAPIServerConfig creates all the resources for running the API server, but runs none of them
0000000000000000000000000000000000000000;;	func CreateKubeAPIServerConfig(s *options.ServerRunOptions, nodeTunneler tunneler.Tunneler, proxyTransport http.RoundTripper) (*master.Config, informers.SharedInformerFactory, clientgoinformers.SharedInformerFactory, *kubeserver.InsecureServingInfo, aggregatorapiserver.ServiceResolver, error) {
0000000000000000000000000000000000000000;;		// register all admission plugins
0000000000000000000000000000000000000000;;		registerAllAdmissionPlugins(s.Admission.Plugins)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set defaults in the options before trying to create the generic config
0000000000000000000000000000000000000000;;		if err := defaultOptions(s); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// validate options
0000000000000000000000000000000000000000;;		if errs := s.Validate(); len(errs) != 0 {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, utilerrors.NewAggregate(errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		genericConfig, sharedInformers, versionedInformers, insecureServingOptions, serviceResolver, err := BuildGenericConfig(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, port, err := net.SplitHostPort(s.Etcd.StorageConfig.ServerList[0]); err == nil && port != "0" && len(port) != 0 {
0000000000000000000000000000000000000000;;			if err := utilwait.PollImmediate(etcdRetryInterval, etcdRetryLimit*etcdRetryInterval, preflight.EtcdConnection{ServerList: s.Etcd.StorageConfig.ServerList}.CheckEtcdServers); err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, nil, nil, nil, fmt.Errorf("error waiting for etcd connection: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		capabilities.Initialize(capabilities.Capabilities{
0000000000000000000000000000000000000000;;			AllowPrivileged: s.AllowPrivileged,
0000000000000000000000000000000000000000;;			// TODO(vmarmol): Implement support for HostNetworkSources.
0000000000000000000000000000000000000000;;			PrivilegedSources: capabilities.PrivilegedSources{
0000000000000000000000000000000000000000;;				HostNetworkSources: []string{},
0000000000000000000000000000000000000000;;				HostPIDSources:     []string{},
0000000000000000000000000000000000000000;;				HostIPCSources:     []string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			PerConnectionBandwidthLimitBytesPerSec: s.MaxConnectionBytesPerSec,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serviceIPRange, apiServerServiceIP, err := master.DefaultServiceIPRange(s.ServiceClusterIPRange)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storageFactory, err := BuildStorageFactory(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientCA, err := readCAorNil(s.Authentication.ClientCert.ClientCA)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		requestHeaderProxyCA, err := readCAorNil(s.Authentication.RequestHeader.ClientCAFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := &master.Config{
0000000000000000000000000000000000000000;;			GenericConfig: genericConfig,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ClientCARegistrationHook: master.ClientCARegistrationHook{
0000000000000000000000000000000000000000;;				ClientCA:                         clientCA,
0000000000000000000000000000000000000000;;				RequestHeaderUsernameHeaders:     s.Authentication.RequestHeader.UsernameHeaders,
0000000000000000000000000000000000000000;;				RequestHeaderGroupHeaders:        s.Authentication.RequestHeader.GroupHeaders,
0000000000000000000000000000000000000000;;				RequestHeaderExtraHeaderPrefixes: s.Authentication.RequestHeader.ExtraHeaderPrefixes,
0000000000000000000000000000000000000000;;				RequestHeaderCA:                  requestHeaderProxyCA,
0000000000000000000000000000000000000000;;				RequestHeaderAllowedNames:        s.Authentication.RequestHeader.AllowedNames,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			APIResourceConfigSource: storageFactory.APIResourceConfigSource,
0000000000000000000000000000000000000000;;			StorageFactory:          storageFactory,
0000000000000000000000000000000000000000;;			EnableCoreControllers:   true,
0000000000000000000000000000000000000000;;			EventTTL:                s.EventTTL,
0000000000000000000000000000000000000000;;			KubeletClientConfig:     s.KubeletConfig,
0000000000000000000000000000000000000000;;			EnableUISupport:         true,
0000000000000000000000000000000000000000;;			EnableLogsSupport:       s.EnableLogsHandler,
0000000000000000000000000000000000000000;;			ProxyTransport:          proxyTransport,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Tunneler: nodeTunneler,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ServiceIPRange:       serviceIPRange,
0000000000000000000000000000000000000000;;			APIServerServiceIP:   apiServerServiceIP,
0000000000000000000000000000000000000000;;			APIServerServicePort: 443,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ServiceNodePortRange:      s.ServiceNodePortRange,
0000000000000000000000000000000000000000;;			KubernetesServiceNodePort: s.KubernetesServiceNodePort,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			MasterCount: s.MasterCount,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if nodeTunneler != nil {
0000000000000000000000000000000000000000;;			// Use the nodeTunneler's dialer to connect to the kubelet
0000000000000000000000000000000000000000;;			config.KubeletClientConfig.Dial = nodeTunneler.Dial
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return config, sharedInformers, versionedInformers, insecureServingOptions, serviceResolver, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildGenericConfig takes the master server options and produces the genericapiserver.Config associated with it
0000000000000000000000000000000000000000;;	func BuildGenericConfig(s *options.ServerRunOptions) (*genericapiserver.Config, informers.SharedInformerFactory, clientgoinformers.SharedInformerFactory, *kubeserver.InsecureServingInfo, aggregatorapiserver.ServiceResolver, error) {
0000000000000000000000000000000000000000;;		genericConfig := genericapiserver.NewConfig(api.Codecs)
0000000000000000000000000000000000000000;;		if err := s.GenericServerRunOptions.ApplyTo(genericConfig); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		insecureServingOptions, err := s.InsecureServing.ApplyTo(genericConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := s.SecureServing.ApplyTo(genericConfig); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := s.Authentication.ApplyTo(genericConfig); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := s.Audit.ApplyTo(genericConfig); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := s.Features.ApplyTo(genericConfig); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		genericConfig.OpenAPIConfig = genericapiserver.DefaultOpenAPIConfig(generatedopenapi.GetOpenAPIDefinitions, api.Scheme)
0000000000000000000000000000000000000000;;		genericConfig.OpenAPIConfig.PostProcessSpec = postProcessOpenAPISpecForBackwardCompatibility
0000000000000000000000000000000000000000;;		genericConfig.OpenAPIConfig.Info.Title = "Kubernetes"
0000000000000000000000000000000000000000;;		genericConfig.SwaggerConfig = genericapiserver.DefaultSwaggerConfig()
0000000000000000000000000000000000000000;;		genericConfig.EnableMetrics = true
0000000000000000000000000000000000000000;;		genericConfig.LongRunningFunc = filters.BasicLongRunningRequestCheck(
0000000000000000000000000000000000000000;;			sets.NewString("watch", "proxy"),
0000000000000000000000000000000000000000;;			sets.NewString("attach", "exec", "proxy", "log", "portforward"),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeVersion := version.Get()
0000000000000000000000000000000000000000;;		genericConfig.Version = &kubeVersion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storageFactory, err := BuildStorageFactory(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := s.Etcd.ApplyWithStorageFactoryTo(storageFactory, genericConfig); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use protobufs for self-communication.
0000000000000000000000000000000000000000;;		// Since not every generic apiserver has to support protobufs, we
0000000000000000000000000000000000000000;;		// cannot default to it in generic apiserver and need to explicitly
0000000000000000000000000000000000000000;;		// set it in kube-apiserver.
0000000000000000000000000000000000000000;;		genericConfig.LoopbackClientConfig.ContentConfig.ContentType = "application/vnd.kubernetes.protobuf"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client, err := internalclientset.NewForConfig(genericConfig.LoopbackClientConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			kubeAPIVersions := os.Getenv("KUBE_API_VERSIONS")
0000000000000000000000000000000000000000;;			if len(kubeAPIVersions) == 0 {
0000000000000000000000000000000000000000;;				return nil, nil, nil, nil, nil, fmt.Errorf("failed to create clientset: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// KUBE_API_VERSIONS is used in test-update-storage-objects.sh, disabling a number of API
0000000000000000000000000000000000000000;;			// groups. This leads to a nil client above and undefined behaviour further down.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// TODO: get rid of KUBE_API_VERSIONS or define sane behaviour if set
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to create clientset with KUBE_API_VERSIONS=%q. KUBE_API_VERSIONS is only for testing. Things will break.", kubeAPIVersions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		externalClient, err := clientset.NewForConfig(genericConfig.LoopbackClientConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, fmt.Errorf("failed to create external clientset: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sharedInformers := informers.NewSharedInformerFactory(client, 10*time.Minute)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientgoExternalClient, err := clientgoclientset.NewForConfig(genericConfig.LoopbackClientConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, fmt.Errorf("failed to create real external clientset: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		versionedInformers := clientgoinformers.NewSharedInformerFactory(clientgoExternalClient, 10*time.Minute)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var serviceResolver aggregatorapiserver.ServiceResolver
0000000000000000000000000000000000000000;;		if s.EnableAggregatorRouting {
0000000000000000000000000000000000000000;;			serviceResolver = aggregatorapiserver.NewEndpointServiceResolver(
0000000000000000000000000000000000000000;;				versionedInformers.Core().V1().Services().Lister(),
0000000000000000000000000000000000000000;;				versionedInformers.Core().V1().Endpoints().Lister(),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			serviceResolver = aggregatorapiserver.NewClusterIPServiceResolver(
0000000000000000000000000000000000000000;;				versionedInformers.Core().V1().Services().Lister(),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		genericConfig.Authenticator, genericConfig.OpenAPIConfig.SecurityDefinitions, err = BuildAuthenticator(s, storageFactory, client, sharedInformers)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, fmt.Errorf("invalid authentication config: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		genericConfig.Authorizer, err = BuildAuthorizer(s, sharedInformers)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, fmt.Errorf("invalid authorization config: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sets.NewString(s.Authorization.Modes()...).Has(modes.ModeRBAC) {
0000000000000000000000000000000000000000;;			genericConfig.DisabledPostStartHooks.Insert(rbacrest.PostStartHookName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pluginInitializer, err := BuildAdmissionPluginInitializer(
0000000000000000000000000000000000000000;;			s,
0000000000000000000000000000000000000000;;			client,
0000000000000000000000000000000000000000;;			externalClient,
0000000000000000000000000000000000000000;;			sharedInformers,
0000000000000000000000000000000000000000;;			genericConfig.Authorizer,
0000000000000000000000000000000000000000;;			serviceResolver,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, fmt.Errorf("failed to create admission plugin initializer: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = s.Admission.ApplyTo(
0000000000000000000000000000000000000000;;			genericConfig,
0000000000000000000000000000000000000000;;			pluginInitializer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, nil, nil, fmt.Errorf("failed to initialize admission: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return genericConfig, sharedInformers, versionedInformers, insecureServingOptions, serviceResolver, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildAdmissionPluginInitializer constructs the admission plugin initializer
0000000000000000000000000000000000000000;;	func BuildAdmissionPluginInitializer(s *options.ServerRunOptions, client internalclientset.Interface, externalClient clientset.Interface, sharedInformers informers.SharedInformerFactory, apiAuthorizer authorizer.Authorizer, serviceResolver aggregatorapiserver.ServiceResolver) (admission.PluginInitializer, error) {
0000000000000000000000000000000000000000;;		var cloudConfig []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.CloudProvider.CloudConfigFile != "" {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			cloudConfig, err = ioutil.ReadFile(s.CloudProvider.CloudConfigFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Fatalf("Error reading from cloud configuration file %s: %#v", s.CloudProvider.CloudConfigFile, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: use a dynamic restmapper. See https://github.com/kubernetes/kubernetes/pull/42615.
0000000000000000000000000000000000000000;;		restMapper := api.Registry.RESTMapper()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NOTE: we do not provide informers to the quota registry because admission level decisions
0000000000000000000000000000000000000000;;		// do not require us to open watches for all items tracked by quota.
0000000000000000000000000000000000000000;;		quotaRegistry := quotainstall.NewRegistry(nil, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pluginInitializer := kubeapiserveradmission.NewPluginInitializer(client, externalClient, sharedInformers, apiAuthorizer, cloudConfig, restMapper, quotaRegistry)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read client cert/key for plugins that need to make calls out
0000000000000000000000000000000000000000;;		if len(s.ProxyClientCertFile) > 0 && len(s.ProxyClientKeyFile) > 0 {
0000000000000000000000000000000000000000;;			certBytes, err := ioutil.ReadFile(s.ProxyClientCertFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			keyBytes, err := ioutil.ReadFile(s.ProxyClientKeyFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pluginInitializer = pluginInitializer.SetClientCert(certBytes, keyBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pluginInitializer = pluginInitializer.SetServiceResolver(serviceResolver)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pluginInitializer, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildAuthenticator constructs the authenticator
0000000000000000000000000000000000000000;;	func BuildAuthenticator(s *options.ServerRunOptions, storageFactory serverstorage.StorageFactory, client internalclientset.Interface, sharedInformers informers.SharedInformerFactory) (authenticator.Request, *spec.SecurityDefinitions, error) {
0000000000000000000000000000000000000000;;		authenticatorConfig := s.Authentication.ToAuthenticationConfig()
0000000000000000000000000000000000000000;;		if s.Authentication.ServiceAccounts.Lookup {
0000000000000000000000000000000000000000;;			// we have to go direct to storage because the clientsets fail when they're initialized with some API versions excluded
0000000000000000000000000000000000000000;;			// we should stop trying to control them like that.
0000000000000000000000000000000000000000;;			storageConfigServiceAccounts, err := storageFactory.NewConfig(api.Resource("serviceaccounts"))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, fmt.Errorf("unable to get serviceaccounts storage: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			storageConfigSecrets, err := storageFactory.NewConfig(api.Resource("secrets"))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, fmt.Errorf("unable to get secrets storage: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			authenticatorConfig.ServiceAccountTokenGetter = serviceaccountcontroller.NewGetterFromStorageInterface(
0000000000000000000000000000000000000000;;				storageConfigServiceAccounts,
0000000000000000000000000000000000000000;;				storageFactory.ResourcePrefix(api.Resource("serviceaccounts")),
0000000000000000000000000000000000000000;;				storageConfigSecrets,
0000000000000000000000000000000000000000;;				storageFactory.ResourcePrefix(api.Resource("secrets")),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if client == nil || reflect.ValueOf(client).IsNil() {
0000000000000000000000000000000000000000;;			// TODO: Remove check once client can never be nil.
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to setup bootstrap token authenticator because the loopback clientset was not setup properly.")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			authenticatorConfig.BootstrapTokenAuthenticator = bootstrap.NewTokenAuthenticator(
0000000000000000000000000000000000000000;;				sharedInformers.Core().InternalVersion().Secrets().Lister().Secrets(v1.NamespaceSystem),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return authenticatorConfig.New()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildAuthorizer constructs the authorizer
0000000000000000000000000000000000000000;;	func BuildAuthorizer(s *options.ServerRunOptions, sharedInformers informers.SharedInformerFactory) (authorizer.Authorizer, error) {
0000000000000000000000000000000000000000;;		authorizationConfig := s.Authorization.ToAuthorizationConfig(sharedInformers)
0000000000000000000000000000000000000000;;		return authorizationConfig.New()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildStorageFactory constructs the storage factory
0000000000000000000000000000000000000000;;	func BuildStorageFactory(s *options.ServerRunOptions) (*serverstorage.DefaultStorageFactory, error) {
0000000000000000000000000000000000000000;;		storageGroupsToEncodingVersion, err := s.StorageSerialization.StorageGroupsToEncodingVersion()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error generating storage version map: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storageFactory, err := kubeapiserver.NewStorageFactory(
0000000000000000000000000000000000000000;;			s.Etcd.StorageConfig, s.Etcd.DefaultStorageMediaType, api.Codecs,
0000000000000000000000000000000000000000;;			serverstorage.NewDefaultResourceEncodingConfig(api.Registry), storageGroupsToEncodingVersion,
0000000000000000000000000000000000000000;;			// FIXME: this GroupVersionResource override should be configurable
0000000000000000000000000000000000000000;;			[]schema.GroupVersionResource{batch.Resource("cronjobs").WithVersion("v2alpha1")},
0000000000000000000000000000000000000000;;			master.DefaultAPIResourceConfigSource(), s.APIEnablement.RuntimeConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error in initializing storage factory: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// keep Deployments and NetworkPolicies in extensions for backwards compatibility, we'll have to migrate at some point, eventually
0000000000000000000000000000000000000000;;		storageFactory.AddCohabitatingResources(extensions.Resource("deployments"), apps.Resource("deployments"))
0000000000000000000000000000000000000000;;		storageFactory.AddCohabitatingResources(extensions.Resource("networkpolicies"), networking.Resource("networkpolicies"))
0000000000000000000000000000000000000000;;		for _, override := range s.Etcd.EtcdServersOverrides {
0000000000000000000000000000000000000000;;			tokens := strings.Split(override, "#")
0000000000000000000000000000000000000000;;			if len(tokens) != 2 {
0000000000000000000000000000000000000000;;				glog.Errorf("invalid value of etcd server overrides: %s", override)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			apiresource := strings.Split(tokens[0], "/")
0000000000000000000000000000000000000000;;			if len(apiresource) != 2 {
0000000000000000000000000000000000000000;;				glog.Errorf("invalid resource definition: %s", tokens[0])
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			group := apiresource[0]
0000000000000000000000000000000000000000;;			resource := apiresource[1]
0000000000000000000000000000000000000000;;			groupResource := schema.GroupResource{Group: group, Resource: resource}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			servers := strings.Split(tokens[1], ";")
0000000000000000000000000000000000000000;;			storageFactory.SetEtcdLocation(groupResource, servers)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.Etcd.EncryptionProviderConfigFilepath != "" {
0000000000000000000000000000000000000000;;			transformerOverrides, err := encryptionconfig.GetTransformerOverrides(s.Etcd.EncryptionProviderConfigFilepath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for groupResource, transformer := range transformerOverrides {
0000000000000000000000000000000000000000;;				storageFactory.SetTransformer(groupResource, transformer)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return storageFactory, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func defaultOptions(s *options.ServerRunOptions) error {
0000000000000000000000000000000000000000;;		// set defaults
0000000000000000000000000000000000000000;;		if err := s.GenericServerRunOptions.DefaultAdvertiseAddress(s.SecureServing); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := kubeoptions.DefaultAdvertiseAddress(s.GenericServerRunOptions, s.InsecureServing); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, apiServerServiceIP, err := master.DefaultServiceIPRange(s.ServiceClusterIPRange)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error determining service IP ranges: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.SecureServing.ForceLoopbackConfigUsage()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := s.SecureServing.MaybeDefaultWithSelfSignedCerts(s.GenericServerRunOptions.AdvertiseAddress.String(), []string{"kubernetes.default.svc", "kubernetes.default", "kubernetes"}, []net.IP{apiServerServiceIP}); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error creating self-signed certificates: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := s.CloudProvider.DefaultExternalHost(s.GenericServerRunOptions); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error setting the external host value: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.Authentication.ApplyAuthorization(s.Authorization)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Default to the private server key for service account token signing
0000000000000000000000000000000000000000;;		if len(s.Authentication.ServiceAccounts.KeyFiles) == 0 && s.SecureServing.ServerCert.CertKey.KeyFile != "" {
0000000000000000000000000000000000000000;;			if kubeauthenticator.IsValidServiceAccountKeyFile(s.SecureServing.ServerCert.CertKey.KeyFile) {
0000000000000000000000000000000000000000;;				s.Authentication.ServiceAccounts.KeyFiles = []string{s.SecureServing.ServerCert.CertKey.KeyFile}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Warning("No TLS key provided, service account token authentication disabled")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.Etcd.StorageConfig.DeserializationCacheSize == 0 {
0000000000000000000000000000000000000000;;			// When size of cache is not explicitly set, estimate its size based on
0000000000000000000000000000000000000000;;			// target memory usage.
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Initializing deserialization cache size based on %dMB limit", s.GenericServerRunOptions.TargetRAMMB)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// This is the heuristics that from memory capacity is trying to infer
0000000000000000000000000000000000000000;;			// the maximum number of nodes in the cluster and set cache sizes based
0000000000000000000000000000000000000000;;			// on that value.
0000000000000000000000000000000000000000;;			// From our documentation, we officially recommend 120GB machines for
0000000000000000000000000000000000000000;;			// 2000 nodes, and we scale from that point. Thus we assume ~60MB of
0000000000000000000000000000000000000000;;			// capacity per node.
0000000000000000000000000000000000000000;;			// TODO: We may consider deciding that some percentage of memory will
0000000000000000000000000000000000000000;;			// be used for the deserialization cache and divide it by the max object
0000000000000000000000000000000000000000;;			// size to compute its size. We may even go further and measure
0000000000000000000000000000000000000000;;			// collective sizes of the objects in the cache.
0000000000000000000000000000000000000000;;			clusterSize := s.GenericServerRunOptions.TargetRAMMB / 60
0000000000000000000000000000000000000000;;			s.Etcd.StorageConfig.DeserializationCacheSize = 25 * clusterSize
0000000000000000000000000000000000000000;;			if s.Etcd.StorageConfig.DeserializationCacheSize < 1000 {
0000000000000000000000000000000000000000;;				s.Etcd.StorageConfig.DeserializationCacheSize = 1000
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.Etcd.EnableWatchCache {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Initializing cache sizes based on %dMB limit", s.GenericServerRunOptions.TargetRAMMB)
0000000000000000000000000000000000000000;;			cachesize.InitializeWatchCacheSizes(s.GenericServerRunOptions.TargetRAMMB)
0000000000000000000000000000000000000000;;			cachesize.SetWatchCacheSizes(s.GenericServerRunOptions.WatchCacheSizes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readCAorNil(file string) ([]byte, error) {
0000000000000000000000000000000000000000;;		if len(file) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ioutil.ReadFile(file)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PostProcessSpec adds removed definitions for backward compatibility
0000000000000000000000000000000000000000;;	func postProcessOpenAPISpecForBackwardCompatibility(s *spec.Swagger) (*spec.Swagger, error) {
0000000000000000000000000000000000000000;;		compatibilityMap := map[string]string{
0000000000000000000000000000000000000000;;			"v1beta1.DeploymentStatus":            "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.DeploymentStatus",
0000000000000000000000000000000000000000;;			"v1beta1.ReplicaSetList":              "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.ReplicaSetList",
0000000000000000000000000000000000000000;;			"v1beta1.Eviction":                    "k8s.io/kubernetes/pkg/apis/policy/v1beta1.Eviction",
0000000000000000000000000000000000000000;;			"v1beta1.StatefulSetList":             "k8s.io/kubernetes/pkg/apis/apps/v1beta1.StatefulSetList",
0000000000000000000000000000000000000000;;			"v1beta1.RoleBinding":                 "k8s.io/kubernetes/pkg/apis/rbac/v1beta1.RoleBinding",
0000000000000000000000000000000000000000;;			"v1beta1.PodSecurityPolicyList":       "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.PodSecurityPolicyList",
0000000000000000000000000000000000000000;;			"v1.NodeSpec":                         "k8s.io/kubernetes/pkg/api/v1.NodeSpec",
0000000000000000000000000000000000000000;;			"v1.FlockerVolumeSource":              "k8s.io/kubernetes/pkg/api/v1.FlockerVolumeSource",
0000000000000000000000000000000000000000;;			"v1.ContainerState":                   "k8s.io/kubernetes/pkg/api/v1.ContainerState",
0000000000000000000000000000000000000000;;			"v1beta1.ClusterRole":                 "k8s.io/kubernetes/pkg/apis/rbac/v1beta1.ClusterRole",
0000000000000000000000000000000000000000;;			"v1beta1.StorageClass":                "k8s.io/kubernetes/pkg/apis/storage/v1beta1.StorageClass",
0000000000000000000000000000000000000000;;			"v1.FlexVolumeSource":                 "k8s.io/kubernetes/pkg/api/v1.FlexVolumeSource",
0000000000000000000000000000000000000000;;			"v1.SecretKeySelector":                "k8s.io/kubernetes/pkg/api/v1.SecretKeySelector",
0000000000000000000000000000000000000000;;			"v1.DeleteOptions":                    "k8s.io/kubernetes/pkg/api/v1.DeleteOptions",
0000000000000000000000000000000000000000;;			"v1.PodStatus":                        "k8s.io/kubernetes/pkg/api/v1.PodStatus",
0000000000000000000000000000000000000000;;			"v1.NodeStatus":                       "k8s.io/kubernetes/pkg/api/v1.NodeStatus",
0000000000000000000000000000000000000000;;			"v1.ServiceSpec":                      "k8s.io/kubernetes/pkg/api/v1.ServiceSpec",
0000000000000000000000000000000000000000;;			"v1.AttachedVolume":                   "k8s.io/kubernetes/pkg/api/v1.AttachedVolume",
0000000000000000000000000000000000000000;;			"v1.PersistentVolume":                 "k8s.io/kubernetes/pkg/api/v1.PersistentVolume",
0000000000000000000000000000000000000000;;			"v1.LimitRangeList":                   "k8s.io/kubernetes/pkg/api/v1.LimitRangeList",
0000000000000000000000000000000000000000;;			"v1alpha1.Role":                       "k8s.io/kubernetes/pkg/apis/rbac/v1alpha1.Role",
0000000000000000000000000000000000000000;;			"v1.Affinity":                         "k8s.io/kubernetes/pkg/api/v1.Affinity",
0000000000000000000000000000000000000000;;			"v1beta1.PodDisruptionBudget":         "k8s.io/kubernetes/pkg/apis/policy/v1beta1.PodDisruptionBudget",
0000000000000000000000000000000000000000;;			"v1alpha1.RoleBindingList":            "k8s.io/kubernetes/pkg/apis/rbac/v1alpha1.RoleBindingList",
0000000000000000000000000000000000000000;;			"v1.PodAffinity":                      "k8s.io/kubernetes/pkg/api/v1.PodAffinity",
0000000000000000000000000000000000000000;;			"v1beta1.SELinuxStrategyOptions":      "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.SELinuxStrategyOptions",
0000000000000000000000000000000000000000;;			"v1.ResourceQuotaList":                "k8s.io/kubernetes/pkg/api/v1.ResourceQuotaList",
0000000000000000000000000000000000000000;;			"v1.PodList":                          "k8s.io/kubernetes/pkg/api/v1.PodList",
0000000000000000000000000000000000000000;;			"v1.EnvVarSource":                     "k8s.io/kubernetes/pkg/api/v1.EnvVarSource",
0000000000000000000000000000000000000000;;			"v1beta1.TokenReviewStatus":           "k8s.io/kubernetes/pkg/apis/authentication/v1beta1.TokenReviewStatus",
0000000000000000000000000000000000000000;;			"v1.PersistentVolumeClaimList":        "k8s.io/kubernetes/pkg/api/v1.PersistentVolumeClaimList",
0000000000000000000000000000000000000000;;			"v1beta1.RoleList":                    "k8s.io/kubernetes/pkg/apis/rbac/v1beta1.RoleList",
0000000000000000000000000000000000000000;;			"v1.ListMeta":                         "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta",
0000000000000000000000000000000000000000;;			"v1.ObjectMeta":                       "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta",
0000000000000000000000000000000000000000;;			"v1.APIGroupList":                     "k8s.io/apimachinery/pkg/apis/meta/v1.APIGroupList",
0000000000000000000000000000000000000000;;			"v2alpha1.Job":                        "k8s.io/kubernetes/pkg/apis/batch/v2alpha1.Job",
0000000000000000000000000000000000000000;;			"v1.EnvFromSource":                    "k8s.io/kubernetes/pkg/api/v1.EnvFromSource",
0000000000000000000000000000000000000000;;			"v1beta1.IngressStatus":               "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.IngressStatus",
0000000000000000000000000000000000000000;;			"v1.Service":                          "k8s.io/kubernetes/pkg/api/v1.Service",
0000000000000000000000000000000000000000;;			"v1beta1.DaemonSetStatus":             "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.DaemonSetStatus",
0000000000000000000000000000000000000000;;			"v1alpha1.Subject":                    "k8s.io/kubernetes/pkg/apis/rbac/v1alpha1.Subject",
0000000000000000000000000000000000000000;;			"v1.HorizontalPodAutoscaler":          "k8s.io/kubernetes/pkg/apis/autoscaling/v1.HorizontalPodAutoscaler",
0000000000000000000000000000000000000000;;			"v1.StatusCause":                      "k8s.io/apimachinery/pkg/apis/meta/v1.StatusCause",
0000000000000000000000000000000000000000;;			"v1.NodeSelectorRequirement":          "k8s.io/kubernetes/pkg/api/v1.NodeSelectorRequirement",
0000000000000000000000000000000000000000;;			"v1beta1.NetworkPolicyIngressRule":    "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.NetworkPolicyIngressRule",
0000000000000000000000000000000000000000;;			"v1beta1.ThirdPartyResource":          "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.ThirdPartyResource",
0000000000000000000000000000000000000000;;			"v1beta1.PodSecurityPolicy":           "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.PodSecurityPolicy",
0000000000000000000000000000000000000000;;			"v1beta1.StatefulSet":                 "k8s.io/kubernetes/pkg/apis/apps/v1beta1.StatefulSet",
0000000000000000000000000000000000000000;;			"v1.LabelSelector":                    "k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector",
0000000000000000000000000000000000000000;;			"v1.ScaleSpec":                        "k8s.io/kubernetes/pkg/apis/autoscaling/v1.ScaleSpec",
0000000000000000000000000000000000000000;;			"v1.DownwardAPIVolumeFile":            "k8s.io/kubernetes/pkg/api/v1.DownwardAPIVolumeFile",
0000000000000000000000000000000000000000;;			"v1beta1.HorizontalPodAutoscaler":     "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.HorizontalPodAutoscaler",
0000000000000000000000000000000000000000;;			"v1.AWSElasticBlockStoreVolumeSource": "k8s.io/kubernetes/pkg/api/v1.AWSElasticBlockStoreVolumeSource",
0000000000000000000000000000000000000000;;			"v1.ComponentStatus":                  "k8s.io/kubernetes/pkg/api/v1.ComponentStatus",
0000000000000000000000000000000000000000;;			"v2alpha1.JobSpec":                    "k8s.io/kubernetes/pkg/apis/batch/v2alpha1.JobSpec",
0000000000000000000000000000000000000000;;			"v1.ContainerImage":                   "k8s.io/kubernetes/pkg/api/v1.ContainerImage",
0000000000000000000000000000000000000000;;			"v1.ReplicationControllerStatus":      "k8s.io/kubernetes/pkg/api/v1.ReplicationControllerStatus",
0000000000000000000000000000000000000000;;			"v1.ResourceQuota":                    "k8s.io/kubernetes/pkg/api/v1.ResourceQuota",
0000000000000000000000000000000000000000;;			"v1beta1.NetworkPolicyList":           "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.NetworkPolicyList",
0000000000000000000000000000000000000000;;			"v1beta1.NonResourceAttributes":       "k8s.io/kubernetes/pkg/apis/authorization/v1beta1.NonResourceAttributes",
0000000000000000000000000000000000000000;;			"v1.JobCondition":                     "k8s.io/kubernetes/pkg/apis/batch/v1.JobCondition",
0000000000000000000000000000000000000000;;			"v1.LabelSelectorRequirement":         "k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelectorRequirement",
0000000000000000000000000000000000000000;;			"v1beta1.Deployment":                  "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.Deployment",
0000000000000000000000000000000000000000;;			"v1.LoadBalancerIngress":              "k8s.io/kubernetes/pkg/api/v1.LoadBalancerIngress",
0000000000000000000000000000000000000000;;			"v1.SecretList":                       "k8s.io/kubernetes/pkg/api/v1.SecretList",
0000000000000000000000000000000000000000;;			"v1beta1.ReplicaSetSpec":              "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.ReplicaSetSpec",
0000000000000000000000000000000000000000;;			"v1beta1.RoleBindingList":             "k8s.io/kubernetes/pkg/apis/rbac/v1beta1.RoleBindingList",
0000000000000000000000000000000000000000;;			"v1.ServicePort":                      "k8s.io/kubernetes/pkg/api/v1.ServicePort",
0000000000000000000000000000000000000000;;			"v1.Namespace":                        "k8s.io/kubernetes/pkg/api/v1.Namespace",
0000000000000000000000000000000000000000;;			"v1beta1.NetworkPolicyPeer":           "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.NetworkPolicyPeer",
0000000000000000000000000000000000000000;;			"v1.ReplicationControllerList":        "k8s.io/kubernetes/pkg/api/v1.ReplicationControllerList",
0000000000000000000000000000000000000000;;			"v1beta1.ReplicaSetCondition":         "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.ReplicaSetCondition",
0000000000000000000000000000000000000000;;			"v1.ReplicationControllerCondition":   "k8s.io/kubernetes/pkg/api/v1.ReplicationControllerCondition",
0000000000000000000000000000000000000000;;			"v1.DaemonEndpoint":                   "k8s.io/kubernetes/pkg/api/v1.DaemonEndpoint",
0000000000000000000000000000000000000000;;			"v1beta1.NetworkPolicyPort":           "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.NetworkPolicyPort",
0000000000000000000000000000000000000000;;			"v1.NodeSystemInfo":                   "k8s.io/kubernetes/pkg/api/v1.NodeSystemInfo",
0000000000000000000000000000000000000000;;			"v1.LimitRangeItem":                   "k8s.io/kubernetes/pkg/api/v1.LimitRangeItem",
0000000000000000000000000000000000000000;;			"v1.ConfigMapVolumeSource":            "k8s.io/kubernetes/pkg/api/v1.ConfigMapVolumeSource",
0000000000000000000000000000000000000000;;			"v1beta1.ClusterRoleList":             "k8s.io/kubernetes/pkg/apis/rbac/v1beta1.ClusterRoleList",
0000000000000000000000000000000000000000;;			"v1beta1.ResourceAttributes":          "k8s.io/kubernetes/pkg/apis/authorization/v1beta1.ResourceAttributes",
0000000000000000000000000000000000000000;;			"v1.Pod":                              "k8s.io/kubernetes/pkg/api/v1.Pod",
0000000000000000000000000000000000000000;;			"v1.FCVolumeSource":                   "k8s.io/kubernetes/pkg/api/v1.FCVolumeSource",
0000000000000000000000000000000000000000;;			"v1beta1.SubresourceReference":        "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.SubresourceReference",
0000000000000000000000000000000000000000;;			"v1.ResourceQuotaStatus":              "k8s.io/kubernetes/pkg/api/v1.ResourceQuotaStatus",
0000000000000000000000000000000000000000;;			"v1alpha1.RoleBinding":                "k8s.io/kubernetes/pkg/apis/rbac/v1alpha1.RoleBinding",
0000000000000000000000000000000000000000;;			"v1.PodCondition":                     "k8s.io/kubernetes/pkg/api/v1.PodCondition",
0000000000000000000000000000000000000000;;			"v1.GroupVersionForDiscovery":         "k8s.io/apimachinery/pkg/apis/meta/v1.GroupVersionForDiscovery",
0000000000000000000000000000000000000000;;			"v1.NamespaceStatus":                  "k8s.io/kubernetes/pkg/api/v1.NamespaceStatus",
0000000000000000000000000000000000000000;;			"v1.Job":                              "k8s.io/kubernetes/pkg/apis/batch/v1.Job",
0000000000000000000000000000000000000000;;			"v1.PersistentVolumeClaimVolumeSource":        "k8s.io/kubernetes/pkg/api/v1.PersistentVolumeClaimVolumeSource",
0000000000000000000000000000000000000000;;			"v1.Handler":                                  "k8s.io/kubernetes/pkg/api/v1.Handler",
0000000000000000000000000000000000000000;;			"v1.ComponentStatusList":                      "k8s.io/kubernetes/pkg/api/v1.ComponentStatusList",
0000000000000000000000000000000000000000;;			"v1.ServerAddressByClientCIDR":                "k8s.io/apimachinery/pkg/apis/meta/v1.ServerAddressByClientCIDR",
0000000000000000000000000000000000000000;;			"v1.PodAntiAffinity":                          "k8s.io/kubernetes/pkg/api/v1.PodAntiAffinity",
0000000000000000000000000000000000000000;;			"v1.ISCSIVolumeSource":                        "k8s.io/kubernetes/pkg/api/v1.ISCSIVolumeSource",
0000000000000000000000000000000000000000;;			"v1.ContainerStateRunning":                    "k8s.io/kubernetes/pkg/api/v1.ContainerStateRunning",
0000000000000000000000000000000000000000;;			"v1.WeightedPodAffinityTerm":                  "k8s.io/kubernetes/pkg/api/v1.WeightedPodAffinityTerm",
0000000000000000000000000000000000000000;;			"v1beta1.HostPortRange":                       "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.HostPortRange",
0000000000000000000000000000000000000000;;			"v1.HorizontalPodAutoscalerSpec":              "k8s.io/kubernetes/pkg/apis/autoscaling/v1.HorizontalPodAutoscalerSpec",
0000000000000000000000000000000000000000;;			"v1.HorizontalPodAutoscalerList":              "k8s.io/kubernetes/pkg/apis/autoscaling/v1.HorizontalPodAutoscalerList",
0000000000000000000000000000000000000000;;			"v1beta1.RoleRef":                             "k8s.io/kubernetes/pkg/apis/rbac/v1beta1.RoleRef",
0000000000000000000000000000000000000000;;			"v1.Probe":                                    "k8s.io/kubernetes/pkg/api/v1.Probe",
0000000000000000000000000000000000000000;;			"v1beta1.IngressTLS":                          "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.IngressTLS",
0000000000000000000000000000000000000000;;			"v1beta1.ThirdPartyResourceList":              "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.ThirdPartyResourceList",
0000000000000000000000000000000000000000;;			"v1beta1.DaemonSet":                           "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.DaemonSet",
0000000000000000000000000000000000000000;;			"v1.APIGroup":                                 "k8s.io/apimachinery/pkg/apis/meta/v1.APIGroup",
0000000000000000000000000000000000000000;;			"v1beta1.Subject":                             "k8s.io/kubernetes/pkg/apis/rbac/v1beta1.Subject",
0000000000000000000000000000000000000000;;			"v1beta1.DeploymentList":                      "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.DeploymentList",
0000000000000000000000000000000000000000;;			"v1.NodeAffinity":                             "k8s.io/kubernetes/pkg/api/v1.NodeAffinity",
0000000000000000000000000000000000000000;;			"v1beta1.RollingUpdateDeployment":             "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.RollingUpdateDeployment",
0000000000000000000000000000000000000000;;			"v1beta1.APIVersion":                          "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.APIVersion",
0000000000000000000000000000000000000000;;			"v1alpha1.CertificateSigningRequest":          "k8s.io/kubernetes/pkg/apis/certificates/v1alpha1.CertificateSigningRequest",
0000000000000000000000000000000000000000;;			"v1.CinderVolumeSource":                       "k8s.io/kubernetes/pkg/api/v1.CinderVolumeSource",
0000000000000000000000000000000000000000;;			"v1.NamespaceSpec":                            "k8s.io/kubernetes/pkg/api/v1.NamespaceSpec",
0000000000000000000000000000000000000000;;			"v1beta1.PodDisruptionBudgetSpec":             "k8s.io/kubernetes/pkg/apis/policy/v1beta1.PodDisruptionBudgetSpec",
0000000000000000000000000000000000000000;;			"v1.Patch":                                    "k8s.io/apimachinery/pkg/apis/meta/v1.Patch",
0000000000000000000000000000000000000000;;			"v1beta1.ClusterRoleBinding":                  "k8s.io/kubernetes/pkg/apis/rbac/v1beta1.ClusterRoleBinding",
0000000000000000000000000000000000000000;;			"v1beta1.HorizontalPodAutoscalerSpec":         "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.HorizontalPodAutoscalerSpec",
0000000000000000000000000000000000000000;;			"v1.PersistentVolumeClaimSpec":                "k8s.io/kubernetes/pkg/api/v1.PersistentVolumeClaimSpec",
0000000000000000000000000000000000000000;;			"v1.Secret":                                   "k8s.io/kubernetes/pkg/api/v1.Secret",
0000000000000000000000000000000000000000;;			"v1.NodeCondition":                            "k8s.io/kubernetes/pkg/api/v1.NodeCondition",
0000000000000000000000000000000000000000;;			"v1.LocalObjectReference":                     "k8s.io/kubernetes/pkg/api/v1.LocalObjectReference",
0000000000000000000000000000000000000000;;			"runtime.RawExtension":                        "k8s.io/apimachinery/pkg/runtime.RawExtension",
0000000000000000000000000000000000000000;;			"v1.PreferredSchedulingTerm":                  "k8s.io/kubernetes/pkg/api/v1.PreferredSchedulingTerm",
0000000000000000000000000000000000000000;;			"v1.RBDVolumeSource":                          "k8s.io/kubernetes/pkg/api/v1.RBDVolumeSource",
0000000000000000000000000000000000000000;;			"v1.KeyToPath":                                "k8s.io/kubernetes/pkg/api/v1.KeyToPath",
0000000000000000000000000000000000000000;;			"v1.ScaleStatus":                              "k8s.io/kubernetes/pkg/apis/autoscaling/v1.ScaleStatus",
0000000000000000000000000000000000000000;;			"v1alpha1.PolicyRule":                         "k8s.io/kubernetes/pkg/apis/rbac/v1alpha1.PolicyRule",
0000000000000000000000000000000000000000;;			"v1.EndpointPort":                             "k8s.io/kubernetes/pkg/api/v1.EndpointPort",
0000000000000000000000000000000000000000;;			"v1beta1.IngressList":                         "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.IngressList",
0000000000000000000000000000000000000000;;			"v1.EndpointAddress":                          "k8s.io/kubernetes/pkg/api/v1.EndpointAddress",
0000000000000000000000000000000000000000;;			"v1.NodeSelector":                             "k8s.io/kubernetes/pkg/api/v1.NodeSelector",
0000000000000000000000000000000000000000;;			"v1beta1.StorageClassList":                    "k8s.io/kubernetes/pkg/apis/storage/v1beta1.StorageClassList",
0000000000000000000000000000000000000000;;			"v1.ServiceList":                              "k8s.io/kubernetes/pkg/api/v1.ServiceList",
0000000000000000000000000000000000000000;;			"v2alpha1.CronJobSpec":                        "k8s.io/kubernetes/pkg/apis/batch/v2alpha1.CronJobSpec",
0000000000000000000000000000000000000000;;			"v1.ContainerStateTerminated":                 "k8s.io/kubernetes/pkg/api/v1.ContainerStateTerminated",
0000000000000000000000000000000000000000;;			"v1beta1.TokenReview":                         "k8s.io/kubernetes/pkg/apis/authentication/v1beta1.TokenReview",
0000000000000000000000000000000000000000;;			"v1beta1.IngressBackend":                      "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.IngressBackend",
0000000000000000000000000000000000000000;;			"v1.Time":                                     "k8s.io/apimachinery/pkg/apis/meta/v1.Time",
0000000000000000000000000000000000000000;;			"v1beta1.IngressSpec":                         "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.IngressSpec",
0000000000000000000000000000000000000000;;			"v2alpha1.JobTemplateSpec":                    "k8s.io/kubernetes/pkg/apis/batch/v2alpha1.JobTemplateSpec",
0000000000000000000000000000000000000000;;			"v1.LimitRange":                               "k8s.io/kubernetes/pkg/api/v1.LimitRange",
0000000000000000000000000000000000000000;;			"v1beta1.UserInfo":                            "k8s.io/kubernetes/pkg/apis/authentication/v1beta1.UserInfo",
0000000000000000000000000000000000000000;;			"v1.ResourceQuotaSpec":                        "k8s.io/kubernetes/pkg/api/v1.ResourceQuotaSpec",
0000000000000000000000000000000000000000;;			"v1.ContainerPort":                            "k8s.io/kubernetes/pkg/api/v1.ContainerPort",
0000000000000000000000000000000000000000;;			"v1beta1.HTTPIngressRuleValue":                "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.HTTPIngressRuleValue",
0000000000000000000000000000000000000000;;			"v1.AzureFileVolumeSource":                    "k8s.io/kubernetes/pkg/api/v1.AzureFileVolumeSource",
0000000000000000000000000000000000000000;;			"v1beta1.NetworkPolicySpec":                   "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.NetworkPolicySpec",
0000000000000000000000000000000000000000;;			"v1.PodTemplateSpec":                          "k8s.io/kubernetes/pkg/api/v1.PodTemplateSpec",
0000000000000000000000000000000000000000;;			"v1.SecretVolumeSource":                       "k8s.io/kubernetes/pkg/api/v1.SecretVolumeSource",
0000000000000000000000000000000000000000;;			"v1.PodSpec":                                  "k8s.io/kubernetes/pkg/api/v1.PodSpec",
0000000000000000000000000000000000000000;;			"v1.CephFSVolumeSource":                       "k8s.io/kubernetes/pkg/api/v1.CephFSVolumeSource",
0000000000000000000000000000000000000000;;			"v1beta1.CPUTargetUtilization":                "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.CPUTargetUtilization",
0000000000000000000000000000000000000000;;			"v1.Volume":                                   "k8s.io/kubernetes/pkg/api/v1.Volume",
0000000000000000000000000000000000000000;;			"v1beta1.Ingress":                             "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.Ingress",
0000000000000000000000000000000000000000;;			"v1beta1.HorizontalPodAutoscalerList":         "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.HorizontalPodAutoscalerList",
0000000000000000000000000000000000000000;;			"v1.PersistentVolumeStatus":                   "k8s.io/kubernetes/pkg/api/v1.PersistentVolumeStatus",
0000000000000000000000000000000000000000;;			"v1beta1.IDRange":                             "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.IDRange",
0000000000000000000000000000000000000000;;			"v2alpha1.JobCondition":                       "k8s.io/kubernetes/pkg/apis/batch/v2alpha1.JobCondition",
0000000000000000000000000000000000000000;;			"v1beta1.IngressRule":                         "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.IngressRule",
0000000000000000000000000000000000000000;;			"v1alpha1.RoleRef":                            "k8s.io/kubernetes/pkg/apis/rbac/v1alpha1.RoleRef",
0000000000000000000000000000000000000000;;			"v1.PodAffinityTerm":                          "k8s.io/kubernetes/pkg/api/v1.PodAffinityTerm",
0000000000000000000000000000000000000000;;			"v1.ObjectReference":                          "k8s.io/kubernetes/pkg/api/v1.ObjectReference",
0000000000000000000000000000000000000000;;			"v1.ServiceStatus":                            "k8s.io/kubernetes/pkg/api/v1.ServiceStatus",
0000000000000000000000000000000000000000;;			"v1.APIResource":                              "k8s.io/apimachinery/pkg/apis/meta/v1.APIResource",
0000000000000000000000000000000000000000;;			"v1beta1.Scale":                               "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.Scale",
0000000000000000000000000000000000000000;;			"v1.AzureDiskVolumeSource":                    "k8s.io/kubernetes/pkg/api/v1.AzureDiskVolumeSource",
0000000000000000000000000000000000000000;;			"v1beta1.SubjectAccessReviewStatus":           "k8s.io/kubernetes/pkg/apis/authorization/v1beta1.SubjectAccessReviewStatus",
0000000000000000000000000000000000000000;;			"v1.ConfigMap":                                "k8s.io/kubernetes/pkg/api/v1.ConfigMap",
0000000000000000000000000000000000000000;;			"v1.CrossVersionObjectReference":              "k8s.io/kubernetes/pkg/apis/autoscaling/v1.CrossVersionObjectReference",
0000000000000000000000000000000000000000;;			"v1.APIVersions":                              "k8s.io/apimachinery/pkg/apis/meta/v1.APIVersions",
0000000000000000000000000000000000000000;;			"v1alpha1.ClusterRoleList":                    "k8s.io/kubernetes/pkg/apis/rbac/v1alpha1.ClusterRoleList",
0000000000000000000000000000000000000000;;			"v1.Node":                                     "k8s.io/kubernetes/pkg/api/v1.Node",
0000000000000000000000000000000000000000;;			"resource.Quantity":                           "k8s.io/kubernetes/pkg/api/resource.Quantity",
0000000000000000000000000000000000000000;;			"v1.Event":                                    "k8s.io/kubernetes/pkg/api/v1.Event",
0000000000000000000000000000000000000000;;			"v1.JobStatus":                                "k8s.io/kubernetes/pkg/apis/batch/v1.JobStatus",
0000000000000000000000000000000000000000;;			"v1.PersistentVolumeSpec":                     "k8s.io/kubernetes/pkg/api/v1.PersistentVolumeSpec",
0000000000000000000000000000000000000000;;			"v1beta1.SubjectAccessReviewSpec":             "k8s.io/kubernetes/pkg/apis/authorization/v1beta1.SubjectAccessReviewSpec",
0000000000000000000000000000000000000000;;			"v1.ResourceFieldSelector":                    "k8s.io/kubernetes/pkg/api/v1.ResourceFieldSelector",
0000000000000000000000000000000000000000;;			"v1.EndpointSubset":                           "k8s.io/kubernetes/pkg/api/v1.EndpointSubset",
0000000000000000000000000000000000000000;;			"v1alpha1.CertificateSigningRequestSpec":      "k8s.io/kubernetes/pkg/apis/certificates/v1alpha1.CertificateSigningRequestSpec",
0000000000000000000000000000000000000000;;			"v1.HostPathVolumeSource":                     "k8s.io/kubernetes/pkg/api/v1.HostPathVolumeSource",
0000000000000000000000000000000000000000;;			"v1.LoadBalancerStatus":                       "k8s.io/kubernetes/pkg/api/v1.LoadBalancerStatus",
0000000000000000000000000000000000000000;;			"v1beta1.HTTPIngressPath":                     "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.HTTPIngressPath",
0000000000000000000000000000000000000000;;			"v1beta1.Role":                                "k8s.io/kubernetes/pkg/apis/rbac/v1beta1.Role",
0000000000000000000000000000000000000000;;			"v1beta1.DeploymentStrategy":                  "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.DeploymentStrategy",
0000000000000000000000000000000000000000;;			"v1beta1.RunAsUserStrategyOptions":            "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.RunAsUserStrategyOptions",
0000000000000000000000000000000000000000;;			"v1beta1.DeploymentSpec":                      "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.DeploymentSpec",
0000000000000000000000000000000000000000;;			"v1.ExecAction":                               "k8s.io/kubernetes/pkg/api/v1.ExecAction",
0000000000000000000000000000000000000000;;			"v1beta1.PodSecurityPolicySpec":               "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.PodSecurityPolicySpec",
0000000000000000000000000000000000000000;;			"v1.HorizontalPodAutoscalerStatus":            "k8s.io/kubernetes/pkg/apis/autoscaling/v1.HorizontalPodAutoscalerStatus",
0000000000000000000000000000000000000000;;			"v1.PersistentVolumeList":                     "k8s.io/kubernetes/pkg/api/v1.PersistentVolumeList",
0000000000000000000000000000000000000000;;			"v1alpha1.ClusterRole":                        "k8s.io/kubernetes/pkg/apis/rbac/v1alpha1.ClusterRole",
0000000000000000000000000000000000000000;;			"v1.JobSpec":                                  "k8s.io/kubernetes/pkg/apis/batch/v1.JobSpec",
0000000000000000000000000000000000000000;;			"v1beta1.DaemonSetSpec":                       "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.DaemonSetSpec",
0000000000000000000000000000000000000000;;			"v2alpha1.CronJobList":                        "k8s.io/kubernetes/pkg/apis/batch/v2alpha1.CronJobList",
0000000000000000000000000000000000000000;;			"v1.Endpoints":                                "k8s.io/kubernetes/pkg/api/v1.Endpoints",
0000000000000000000000000000000000000000;;			"v1.SELinuxOptions":                           "k8s.io/kubernetes/pkg/api/v1.SELinuxOptions",
0000000000000000000000000000000000000000;;			"v1beta1.SelfSubjectAccessReviewSpec":         "k8s.io/kubernetes/pkg/apis/authorization/v1beta1.SelfSubjectAccessReviewSpec",
0000000000000000000000000000000000000000;;			"v1beta1.ScaleStatus":                         "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.ScaleStatus",
0000000000000000000000000000000000000000;;			"v1.NodeSelectorTerm":                         "k8s.io/kubernetes/pkg/api/v1.NodeSelectorTerm",
0000000000000000000000000000000000000000;;			"v1alpha1.CertificateSigningRequestStatus":    "k8s.io/kubernetes/pkg/apis/certificates/v1alpha1.CertificateSigningRequestStatus",
0000000000000000000000000000000000000000;;			"v1.StatusDetails":                            "k8s.io/apimachinery/pkg/apis/meta/v1.StatusDetails",
0000000000000000000000000000000000000000;;			"v2alpha1.JobStatus":                          "k8s.io/kubernetes/pkg/apis/batch/v2alpha1.JobStatus",
0000000000000000000000000000000000000000;;			"v1beta1.DeploymentRollback":                  "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.DeploymentRollback",
0000000000000000000000000000000000000000;;			"v1.GlusterfsVolumeSource":                    "k8s.io/kubernetes/pkg/api/v1.GlusterfsVolumeSource",
0000000000000000000000000000000000000000;;			"v1.ServiceAccountList":                       "k8s.io/kubernetes/pkg/api/v1.ServiceAccountList",
0000000000000000000000000000000000000000;;			"v1.JobList":                                  "k8s.io/kubernetes/pkg/apis/batch/v1.JobList",
0000000000000000000000000000000000000000;;			"v1.EventList":                                "k8s.io/kubernetes/pkg/api/v1.EventList",
0000000000000000000000000000000000000000;;			"v1.ContainerStateWaiting":                    "k8s.io/kubernetes/pkg/api/v1.ContainerStateWaiting",
0000000000000000000000000000000000000000;;			"v1.APIResourceList":                          "k8s.io/apimachinery/pkg/apis/meta/v1.APIResourceList",
0000000000000000000000000000000000000000;;			"v1.ContainerStatus":                          "k8s.io/kubernetes/pkg/api/v1.ContainerStatus",
0000000000000000000000000000000000000000;;			"v2alpha1.JobList":                            "k8s.io/kubernetes/pkg/apis/batch/v2alpha1.JobList",
0000000000000000000000000000000000000000;;			"v1.ConfigMapKeySelector":                     "k8s.io/kubernetes/pkg/api/v1.ConfigMapKeySelector",
0000000000000000000000000000000000000000;;			"v1.PhotonPersistentDiskVolumeSource":         "k8s.io/kubernetes/pkg/api/v1.PhotonPersistentDiskVolumeSource",
0000000000000000000000000000000000000000;;			"v1.PodTemplateList":                          "k8s.io/kubernetes/pkg/api/v1.PodTemplateList",
0000000000000000000000000000000000000000;;			"v1.PersistentVolumeClaimStatus":              "k8s.io/kubernetes/pkg/api/v1.PersistentVolumeClaimStatus",
0000000000000000000000000000000000000000;;			"v1.ServiceAccount":                           "k8s.io/kubernetes/pkg/api/v1.ServiceAccount",
0000000000000000000000000000000000000000;;			"v1alpha1.CertificateSigningRequestList":      "k8s.io/kubernetes/pkg/apis/certificates/v1alpha1.CertificateSigningRequestList",
0000000000000000000000000000000000000000;;			"v1beta1.SupplementalGroupsStrategyOptions":   "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.SupplementalGroupsStrategyOptions",
0000000000000000000000000000000000000000;;			"v1.HTTPHeader":                               "k8s.io/kubernetes/pkg/api/v1.HTTPHeader",
0000000000000000000000000000000000000000;;			"version.Info":                                "k8s.io/apimachinery/pkg/version.Info",
0000000000000000000000000000000000000000;;			"v1.EventSource":                              "k8s.io/kubernetes/pkg/api/v1.EventSource",
0000000000000000000000000000000000000000;;			"v1alpha1.ClusterRoleBindingList":             "k8s.io/kubernetes/pkg/apis/rbac/v1alpha1.ClusterRoleBindingList",
0000000000000000000000000000000000000000;;			"v1.OwnerReference":                           "k8s.io/apimachinery/pkg/apis/meta/v1.OwnerReference",
0000000000000000000000000000000000000000;;			"v1beta1.ClusterRoleBindingList":              "k8s.io/kubernetes/pkg/apis/rbac/v1beta1.ClusterRoleBindingList",
0000000000000000000000000000000000000000;;			"v1beta1.ScaleSpec":                           "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.ScaleSpec",
0000000000000000000000000000000000000000;;			"v1.GitRepoVolumeSource":                      "k8s.io/kubernetes/pkg/api/v1.GitRepoVolumeSource",
0000000000000000000000000000000000000000;;			"v1beta1.NetworkPolicy":                       "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.NetworkPolicy",
0000000000000000000000000000000000000000;;			"v1.ConfigMapEnvSource":                       "k8s.io/kubernetes/pkg/api/v1.ConfigMapEnvSource",
0000000000000000000000000000000000000000;;			"v1.PodTemplate":                              "k8s.io/kubernetes/pkg/api/v1.PodTemplate",
0000000000000000000000000000000000000000;;			"v1beta1.DeploymentCondition":                 "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.DeploymentCondition",
0000000000000000000000000000000000000000;;			"v1beta1.PodDisruptionBudgetStatus":           "k8s.io/kubernetes/pkg/apis/policy/v1beta1.PodDisruptionBudgetStatus",
0000000000000000000000000000000000000000;;			"v1.EnvVar":                                   "k8s.io/kubernetes/pkg/api/v1.EnvVar",
0000000000000000000000000000000000000000;;			"v1.LimitRangeSpec":                           "k8s.io/kubernetes/pkg/api/v1.LimitRangeSpec",
0000000000000000000000000000000000000000;;			"v1.DownwardAPIVolumeSource":                  "k8s.io/kubernetes/pkg/api/v1.DownwardAPIVolumeSource",
0000000000000000000000000000000000000000;;			"v1.NodeDaemonEndpoints":                      "k8s.io/kubernetes/pkg/api/v1.NodeDaemonEndpoints",
0000000000000000000000000000000000000000;;			"v1.ComponentCondition":                       "k8s.io/kubernetes/pkg/api/v1.ComponentCondition",
0000000000000000000000000000000000000000;;			"v1alpha1.CertificateSigningRequestCondition": "k8s.io/kubernetes/pkg/apis/certificates/v1alpha1.CertificateSigningRequestCondition",
0000000000000000000000000000000000000000;;			"v1.SecurityContext":                          "k8s.io/kubernetes/pkg/api/v1.SecurityContext",
0000000000000000000000000000000000000000;;			"v1beta1.LocalSubjectAccessReview":            "k8s.io/kubernetes/pkg/apis/authorization/v1beta1.LocalSubjectAccessReview",
0000000000000000000000000000000000000000;;			"v1beta1.StatefulSetSpec":                     "k8s.io/kubernetes/pkg/apis/apps/v1beta1.StatefulSetSpec",
0000000000000000000000000000000000000000;;			"v1.NodeAddress":                              "k8s.io/kubernetes/pkg/api/v1.NodeAddress",
0000000000000000000000000000000000000000;;			"v1.QuobyteVolumeSource":                      "k8s.io/kubernetes/pkg/api/v1.QuobyteVolumeSource",
0000000000000000000000000000000000000000;;			"v1.Capabilities":                             "k8s.io/kubernetes/pkg/api/v1.Capabilities",
0000000000000000000000000000000000000000;;			"v1.GCEPersistentDiskVolumeSource":            "k8s.io/kubernetes/pkg/api/v1.GCEPersistentDiskVolumeSource",
0000000000000000000000000000000000000000;;			"v1beta1.ReplicaSet":                          "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.ReplicaSet",
0000000000000000000000000000000000000000;;			"v1beta1.HorizontalPodAutoscalerStatus":       "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.HorizontalPodAutoscalerStatus",
0000000000000000000000000000000000000000;;			"v1beta1.PolicyRule":                          "k8s.io/kubernetes/pkg/apis/rbac/v1beta1.PolicyRule",
0000000000000000000000000000000000000000;;			"v1.ConfigMapList":                            "k8s.io/kubernetes/pkg/api/v1.ConfigMapList",
0000000000000000000000000000000000000000;;			"v1.Lifecycle":                                "k8s.io/kubernetes/pkg/api/v1.Lifecycle",
0000000000000000000000000000000000000000;;			"v1beta1.SelfSubjectAccessReview":             "k8s.io/kubernetes/pkg/apis/authorization/v1beta1.SelfSubjectAccessReview",
0000000000000000000000000000000000000000;;			"v2alpha1.CronJob":                            "k8s.io/kubernetes/pkg/apis/batch/v2alpha1.CronJob",
0000000000000000000000000000000000000000;;			"v2alpha1.CronJobStatus":                      "k8s.io/kubernetes/pkg/apis/batch/v2alpha1.CronJobStatus",
0000000000000000000000000000000000000000;;			"v1beta1.SubjectAccessReview":                 "k8s.io/kubernetes/pkg/apis/authorization/v1beta1.SubjectAccessReview",
0000000000000000000000000000000000000000;;			"v1.Preconditions":                            "k8s.io/kubernetes/pkg/api/v1.Preconditions",
0000000000000000000000000000000000000000;;			"v1beta1.DaemonSetList":                       "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.DaemonSetList",
0000000000000000000000000000000000000000;;			"v1.PersistentVolumeClaim":                    "k8s.io/kubernetes/pkg/api/v1.PersistentVolumeClaim",
0000000000000000000000000000000000000000;;			"v1.Scale":                                    "k8s.io/kubernetes/pkg/apis/autoscaling/v1.Scale",
0000000000000000000000000000000000000000;;			"v1beta1.StatefulSetStatus":                   "k8s.io/kubernetes/pkg/apis/apps/v1beta1.StatefulSetStatus",
0000000000000000000000000000000000000000;;			"v1.NFSVolumeSource":                          "k8s.io/kubernetes/pkg/api/v1.NFSVolumeSource",
0000000000000000000000000000000000000000;;			"v1.ObjectFieldSelector":                      "k8s.io/kubernetes/pkg/api/v1.ObjectFieldSelector",
0000000000000000000000000000000000000000;;			"v1.ResourceRequirements":                     "k8s.io/kubernetes/pkg/api/v1.ResourceRequirements",
0000000000000000000000000000000000000000;;			"v1.WatchEvent":                               "k8s.io/apimachinery/pkg/apis/meta/v1.WatchEvent",
0000000000000000000000000000000000000000;;			"v1.ReplicationControllerSpec":                "k8s.io/kubernetes/pkg/api/v1.ReplicationControllerSpec",
0000000000000000000000000000000000000000;;			"v1.HTTPGetAction":                            "k8s.io/kubernetes/pkg/api/v1.HTTPGetAction",
0000000000000000000000000000000000000000;;			"v1beta1.RollbackConfig":                      "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.RollbackConfig",
0000000000000000000000000000000000000000;;			"v1beta1.TokenReviewSpec":                     "k8s.io/kubernetes/pkg/apis/authentication/v1beta1.TokenReviewSpec",
0000000000000000000000000000000000000000;;			"v1.PodSecurityContext":                       "k8s.io/kubernetes/pkg/api/v1.PodSecurityContext",
0000000000000000000000000000000000000000;;			"v1beta1.PodDisruptionBudgetList":             "k8s.io/kubernetes/pkg/apis/policy/v1beta1.PodDisruptionBudgetList",
0000000000000000000000000000000000000000;;			"v1.VolumeMount":                              "k8s.io/kubernetes/pkg/api/v1.VolumeMount",
0000000000000000000000000000000000000000;;			"v1.ReplicationController":                    "k8s.io/kubernetes/pkg/api/v1.ReplicationController",
0000000000000000000000000000000000000000;;			"v1.NamespaceList":                            "k8s.io/kubernetes/pkg/api/v1.NamespaceList",
0000000000000000000000000000000000000000;;			"v1alpha1.ClusterRoleBinding":                 "k8s.io/kubernetes/pkg/apis/rbac/v1alpha1.ClusterRoleBinding",
0000000000000000000000000000000000000000;;			"v1.TCPSocketAction":                          "k8s.io/kubernetes/pkg/api/v1.TCPSocketAction",
0000000000000000000000000000000000000000;;			"v1.Binding":                                  "k8s.io/kubernetes/pkg/api/v1.Binding",
0000000000000000000000000000000000000000;;			"v1beta1.ReplicaSetStatus":                    "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.ReplicaSetStatus",
0000000000000000000000000000000000000000;;			"intstr.IntOrString":                          "k8s.io/kubernetes/pkg/util/intstr.IntOrString",
0000000000000000000000000000000000000000;;			"v1.EndpointsList":                            "k8s.io/kubernetes/pkg/api/v1.EndpointsList",
0000000000000000000000000000000000000000;;			"v1.Container":                                "k8s.io/kubernetes/pkg/api/v1.Container",
0000000000000000000000000000000000000000;;			"v1alpha1.RoleList":                           "k8s.io/kubernetes/pkg/apis/rbac/v1alpha1.RoleList",
0000000000000000000000000000000000000000;;			"v1.VsphereVirtualDiskVolumeSource":           "k8s.io/kubernetes/pkg/api/v1.VsphereVirtualDiskVolumeSource",
0000000000000000000000000000000000000000;;			"v1.NodeList":                                 "k8s.io/kubernetes/pkg/api/v1.NodeList",
0000000000000000000000000000000000000000;;			"v1.EmptyDirVolumeSource":                     "k8s.io/kubernetes/pkg/api/v1.EmptyDirVolumeSource",
0000000000000000000000000000000000000000;;			"v1beta1.FSGroupStrategyOptions":              "k8s.io/kubernetes/pkg/apis/extensions/v1beta1.FSGroupStrategyOptions",
0000000000000000000000000000000000000000;;			"v1.Status":                                   "k8s.io/apimachinery/pkg/apis/meta/v1.Status",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range compatibilityMap {
0000000000000000000000000000000000000000;;			if _, found := s.Definitions[v]; !found {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.Definitions[k] = spec.Schema{
0000000000000000000000000000000000000000;;				SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;					Ref:         spec.MustCreateRef("#/definitions/" + openapi.EscapeJsonPointer(v)),
0000000000000000000000000000000000000000;;					Description: fmt.Sprintf("Deprecated. Please use %s instead.", v),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
