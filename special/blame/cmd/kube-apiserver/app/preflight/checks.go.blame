0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
77b5cbc391c8b9ce98505abe874e1c6d93939d9f;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package preflight
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const connectionTimeout = 1 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type connection interface {
0000000000000000000000000000000000000000;;		serverReachable(address string) bool
0000000000000000000000000000000000000000;;		parseServerList(serverList []string) error
0000000000000000000000000000000000000000;;		CheckEtcdServers() (bool, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EtcdConnection holds the Etcd server list
0000000000000000000000000000000000000000;;	type EtcdConnection struct {
0000000000000000000000000000000000000000;;		ServerList []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (EtcdConnection) serverReachable(address string) bool {
0000000000000000000000000000000000000000;;		if conn, err := net.DialTimeout("tcp", address, connectionTimeout); err == nil {
0000000000000000000000000000000000000000;;			defer conn.Close()
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseServerURI(serverURI string) (string, error) {
0000000000000000000000000000000000000000;;		connURL, err := url.Parse(serverURI)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unable to parse etcd url: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return connURL.Host, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckEtcdServers will attempt to reach all etcd servers once. If any
0000000000000000000000000000000000000000;;	// can be reached, return true.
0000000000000000000000000000000000000000;;	func (con EtcdConnection) CheckEtcdServers() (done bool, err error) {
0000000000000000000000000000000000000000;;		// Attempt to reach every Etcd server in order
0000000000000000000000000000000000000000;;		for _, serverURI := range con.ServerList {
0000000000000000000000000000000000000000;;			host, err := parseServerURI(serverURI)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if con.serverReachable(host) {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
