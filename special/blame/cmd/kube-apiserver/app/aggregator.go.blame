0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
bf78b4b2ad48ad82bd133378e762d10f8c95d014;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package app does all of the work necessary to create a Kubernetes
0000000000000000000000000000000000000000;;	// APIServer by binding together the API, master and APIServer infrastructure.
0000000000000000000000000000000000000000;;	// It can be configured and called directly or via the hyperkube framework.
0000000000000000000000000000000000000000;;	package app
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiextensionsinformers "k8s.io/apiextensions-apiserver/pkg/client/informers/internalversion"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		genericapiserver "k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/healthz"
0000000000000000000000000000000000000000;;		genericoptions "k8s.io/apiserver/pkg/server/options"
0000000000000000000000000000000000000000;;		kubeexternalinformers "k8s.io/client-go/informers"
0000000000000000000000000000000000000000;;		"k8s.io/kube-aggregator/pkg/apis/apiregistration"
0000000000000000000000000000000000000000;;		"k8s.io/kube-aggregator/pkg/apis/apiregistration/v1beta1"
0000000000000000000000000000000000000000;;		aggregatorapiserver "k8s.io/kube-aggregator/pkg/apiserver"
0000000000000000000000000000000000000000;;		apiregistrationclient "k8s.io/kube-aggregator/pkg/client/clientset_generated/internalclientset/typed/apiregistration/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kube-aggregator/pkg/controllers/autoregister"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kube-apiserver/app/options"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/master/controller/crdregistration"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createAggregatorConfig(kubeAPIServerConfig genericapiserver.Config, commandOptions *options.ServerRunOptions, externalInformers kubeexternalinformers.SharedInformerFactory, serviceResolver aggregatorapiserver.ServiceResolver, proxyTransport *http.Transport) (*aggregatorapiserver.Config, error) {
0000000000000000000000000000000000000000;;		// make a shallow copy to let us twiddle a few things
0000000000000000000000000000000000000000;;		// most of the config actually remains the same.  We only need to mess with a couple items related to the particulars of the aggregator
0000000000000000000000000000000000000000;;		genericConfig := kubeAPIServerConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the aggregator doesn't wire these up.  It just delegates them to the kubeapiserver
0000000000000000000000000000000000000000;;		genericConfig.EnableSwaggerUI = false
0000000000000000000000000000000000000000;;		genericConfig.SwaggerConfig = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// copy the etcd options so we don't mutate originals.
0000000000000000000000000000000000000000;;		etcdOptions := *commandOptions.Etcd
0000000000000000000000000000000000000000;;		etcdOptions.StorageConfig.Codec = aggregatorapiserver.Codecs.LegacyCodec(v1beta1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		etcdOptions.StorageConfig.Copier = aggregatorapiserver.Scheme
0000000000000000000000000000000000000000;;		genericConfig.RESTOptionsGetter = &genericoptions.SimpleRestOptionsFactory{Options: etcdOptions}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var certBytes, keyBytes []byte
0000000000000000000000000000000000000000;;		if len(commandOptions.ProxyClientCertFile) > 0 && len(commandOptions.ProxyClientKeyFile) > 0 {
0000000000000000000000000000000000000000;;			certBytes, err = ioutil.ReadFile(commandOptions.ProxyClientCertFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			keyBytes, err = ioutil.ReadFile(commandOptions.ProxyClientKeyFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		aggregatorConfig := &aggregatorapiserver.Config{
0000000000000000000000000000000000000000;;			GenericConfig:     &genericConfig,
0000000000000000000000000000000000000000;;			CoreKubeInformers: externalInformers,
0000000000000000000000000000000000000000;;			ProxyClientCert:   certBytes,
0000000000000000000000000000000000000000;;			ProxyClientKey:    keyBytes,
0000000000000000000000000000000000000000;;			ServiceResolver:   serviceResolver,
0000000000000000000000000000000000000000;;			ProxyTransport:    proxyTransport,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return aggregatorConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createAggregatorServer(aggregatorConfig *aggregatorapiserver.Config, delegateAPIServer genericapiserver.DelegationTarget, apiExtensionInformers apiextensionsinformers.SharedInformerFactory) (*aggregatorapiserver.APIAggregator, error) {
0000000000000000000000000000000000000000;;		aggregatorServer, err := aggregatorConfig.Complete().NewWithDelegate(delegateAPIServer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create controllers for auto-registration
0000000000000000000000000000000000000000;;		apiRegistrationClient, err := apiregistrationclient.NewForConfig(aggregatorConfig.GenericConfig.LoopbackClientConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		autoRegistrationController := autoregister.NewAutoRegisterController(aggregatorServer.APIRegistrationInformers.Apiregistration().InternalVersion().APIServices(), apiRegistrationClient)
0000000000000000000000000000000000000000;;		apiServices := apiServicesToRegister(delegateAPIServer, autoRegistrationController)
0000000000000000000000000000000000000000;;		crdRegistrationController := crdregistration.NewAutoRegistrationController(
0000000000000000000000000000000000000000;;			apiExtensionInformers.Apiextensions().InternalVersion().CustomResourceDefinitions(),
0000000000000000000000000000000000000000;;			autoRegistrationController)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		aggregatorServer.GenericAPIServer.AddPostStartHook("kube-apiserver-autoregistration", func(context genericapiserver.PostStartHookContext) error {
0000000000000000000000000000000000000000;;			go autoRegistrationController.Run(5, context.StopCh)
0000000000000000000000000000000000000000;;			go crdRegistrationController.Run(5, context.StopCh)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		aggregatorServer.GenericAPIServer.AddHealthzChecks(healthz.NamedCheck("autoregister-completion", func(r *http.Request) error {
0000000000000000000000000000000000000000;;			items, err := aggregatorServer.APIRegistrationInformers.Apiregistration().InternalVersion().APIServices().Lister().List(labels.Everything())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			missing := []apiregistration.APIService{}
0000000000000000000000000000000000000000;;			for _, apiService := range apiServices {
0000000000000000000000000000000000000000;;				found := false
0000000000000000000000000000000000000000;;				for _, item := range items {
0000000000000000000000000000000000000000;;					if item.Name != apiService.Name {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if apiregistration.IsAPIServiceConditionTrue(item, apiregistration.Available) {
0000000000000000000000000000000000000000;;						found = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !found {
0000000000000000000000000000000000000000;;					missing = append(missing, *apiService)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(missing) > 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("missing APIService: %v", missing)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return aggregatorServer, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeAPIService(gv schema.GroupVersion) *apiregistration.APIService {
0000000000000000000000000000000000000000;;		apiServicePriority, ok := apiVersionPriorities[gv]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// if we aren't found, then we shouldn't register ourselves because it could result in a CRD group version
0000000000000000000000000000000000000000;;			// being permanently stuck in the APIServices list.
0000000000000000000000000000000000000000;;			glog.Infof("Skipping APIService creation for %v", gv)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &apiregistration.APIService{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: gv.Version + "." + gv.Group},
0000000000000000000000000000000000000000;;			Spec: apiregistration.APIServiceSpec{
0000000000000000000000000000000000000000;;				Group:                gv.Group,
0000000000000000000000000000000000000000;;				Version:              gv.Version,
0000000000000000000000000000000000000000;;				GroupPriorityMinimum: apiServicePriority.group,
0000000000000000000000000000000000000000;;				VersionPriority:      apiServicePriority.version,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type priority struct {
0000000000000000000000000000000000000000;;		group   int32
0000000000000000000000000000000000000000;;		version int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The proper way to resolve this letting the aggregator know the desired group and version-within-group order of the underlying servers
0000000000000000000000000000000000000000;;	// is to refactor the genericapiserver.DelegationTarget to include a list of priorities based on which APIs were installed.
0000000000000000000000000000000000000000;;	// This requires the APIGroupInfo struct to evolve and include the concept of priorities and to avoid mistakes, the core storage map there needs to be updated.
0000000000000000000000000000000000000000;;	// That ripples out every bit as far as you'd expect, so for 1.7 we'll include the list here instead of being built up during storage.
0000000000000000000000000000000000000000;;	var apiVersionPriorities = map[schema.GroupVersion]priority{
0000000000000000000000000000000000000000;;		{Group: "", Version: "v1"}: {group: 18000, version: 1},
0000000000000000000000000000000000000000;;		// extensions is above the rest for CLI compatibility, though the level of unqalified resource compatibility we
0000000000000000000000000000000000000000;;		// can reasonably expect seems questionable.
0000000000000000000000000000000000000000;;		{Group: "extensions", Version: "v1beta1"}: {group: 17900, version: 1},
0000000000000000000000000000000000000000;;		// to my knowledge, nothing below here collides
0000000000000000000000000000000000000000;;		{Group: "apps", Version: "v1beta1"}:                          {group: 17800, version: 1},
0000000000000000000000000000000000000000;;		{Group: "authentication.k8s.io", Version: "v1"}:              {group: 17700, version: 15},
0000000000000000000000000000000000000000;;		{Group: "authentication.k8s.io", Version: "v1beta1"}:         {group: 17700, version: 9},
0000000000000000000000000000000000000000;;		{Group: "authorization.k8s.io", Version: "v1"}:               {group: 17600, version: 15},
0000000000000000000000000000000000000000;;		{Group: "authorization.k8s.io", Version: "v1beta1"}:          {group: 17600, version: 9},
0000000000000000000000000000000000000000;;		{Group: "autoscaling", Version: "v1"}:                        {group: 17500, version: 15},
0000000000000000000000000000000000000000;;		{Group: "autoscaling", Version: "v2alpha1"}:                  {group: 17500, version: 9},
0000000000000000000000000000000000000000;;		{Group: "batch", Version: "v1"}:                              {group: 17400, version: 15},
0000000000000000000000000000000000000000;;		{Group: "batch", Version: "v2alpha1"}:                        {group: 17400, version: 9},
0000000000000000000000000000000000000000;;		{Group: "certificates.k8s.io", Version: "v1beta1"}:           {group: 17300, version: 9},
0000000000000000000000000000000000000000;;		{Group: "networking.k8s.io", Version: "v1"}:                  {group: 17200, version: 15},
0000000000000000000000000000000000000000;;		{Group: "policy", Version: "v1beta1"}:                        {group: 17100, version: 9},
0000000000000000000000000000000000000000;;		{Group: "rbac.authorization.k8s.io", Version: "v1beta1"}:     {group: 17000, version: 12},
0000000000000000000000000000000000000000;;		{Group: "rbac.authorization.k8s.io", Version: "v1alpha1"}:    {group: 17000, version: 9},
0000000000000000000000000000000000000000;;		{Group: "settings.k8s.io", Version: "v1alpha1"}:              {group: 16900, version: 9},
0000000000000000000000000000000000000000;;		{Group: "storage.k8s.io", Version: "v1"}:                     {group: 16800, version: 15},
0000000000000000000000000000000000000000;;		{Group: "storage.k8s.io", Version: "v1beta1"}:                {group: 16800, version: 9},
0000000000000000000000000000000000000000;;		{Group: "apiextensions.k8s.io", Version: "v1beta1"}:          {group: 16700, version: 9},
0000000000000000000000000000000000000000;;		{Group: "admissionregistration.k8s.io", Version: "v1alpha1"}: {group: 16700, version: 9},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func apiServicesToRegister(delegateAPIServer genericapiserver.DelegationTarget, registration autoregister.AutoAPIServiceRegistration) []*apiregistration.APIService {
0000000000000000000000000000000000000000;;		apiServices := []*apiregistration.APIService{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, curr := range delegateAPIServer.ListedPaths() {
0000000000000000000000000000000000000000;;			if curr == "/api/v1" {
0000000000000000000000000000000000000000;;				apiService := makeAPIService(schema.GroupVersion{Group: "", Version: "v1"})
0000000000000000000000000000000000000000;;				registration.AddAPIServiceToSync(apiService)
0000000000000000000000000000000000000000;;				apiServices = append(apiServices, apiService)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(curr, "/apis/") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// this comes back in a list that looks like /apis/rbac.authorization.k8s.io/v1alpha1
0000000000000000000000000000000000000000;;			tokens := strings.Split(curr, "/")
0000000000000000000000000000000000000000;;			if len(tokens) != 4 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			apiService := makeAPIService(schema.GroupVersion{Group: tokens[2], Version: tokens[3]})
0000000000000000000000000000000000000000;;			if apiService == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			registration.AddAPIServiceToSync(apiService)
0000000000000000000000000000000000000000;;			apiServices = append(apiServices, apiService)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return apiServices
0000000000000000000000000000000000000000;;	}
