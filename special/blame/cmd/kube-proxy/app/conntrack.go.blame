0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
8bf7341467aec5c830e2ae808b0125217904579d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package app
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/sysctl"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Conntracker is an interface to the global sysctl. Descriptions of the various
0000000000000000000000000000000000000000;;	// sysctl fields can be found here:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// https://www.kernel.org/doc/Documentation/networking/nf_conntrack-sysctl.txt
0000000000000000000000000000000000000000;;	type Conntracker interface {
0000000000000000000000000000000000000000;;		// SetMax adjusts nf_conntrack_max.
0000000000000000000000000000000000000000;;		SetMax(max int) error
0000000000000000000000000000000000000000;;		// SetTCPEstablishedTimeout adjusts nf_conntrack_tcp_timeout_established.
0000000000000000000000000000000000000000;;		SetTCPEstablishedTimeout(seconds int) error
0000000000000000000000000000000000000000;;		// SetTCPCloseWaitTimeout nf_conntrack_tcp_timeout_close_wait.
0000000000000000000000000000000000000000;;		SetTCPCloseWaitTimeout(seconds int) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type realConntracker struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var readOnlySysFSError = errors.New("readOnlySysFS")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rct realConntracker) SetMax(max int) error {
0000000000000000000000000000000000000000;;		if err := rct.setIntSysCtl("nf_conntrack_max", max); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("Setting nf_conntrack_max to %d", max)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Linux does not support writing to /sys/module/nf_conntrack/parameters/hashsize
0000000000000000000000000000000000000000;;		// when the writer process is not in the initial network namespace
0000000000000000000000000000000000000000;;		// (https://github.com/torvalds/linux/blob/v4.10/net/netfilter/nf_conntrack_core.c#L1795-L1796).
0000000000000000000000000000000000000000;;		// Usually that's fine. But in some configurations such as with github.com/kinvolk/kubeadm-nspawn,
0000000000000000000000000000000000000000;;		// kube-proxy is in another netns.
0000000000000000000000000000000000000000;;		// Therefore, check if writing in hashsize is necessary and skip the writing if not.
0000000000000000000000000000000000000000;;		hashsize, err := readIntStringFile("/sys/module/nf_conntrack/parameters/hashsize")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hashsize >= (max / 4) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// sysfs is expected to be mounted as 'rw'. However, it may be
0000000000000000000000000000000000000000;;		// unexpectedly mounted as 'ro' by docker because of a known docker
0000000000000000000000000000000000000000;;		// issue (https://github.com/docker/docker/issues/24000). Setting
0000000000000000000000000000000000000000;;		// conntrack will fail when sysfs is readonly. When that happens, we
0000000000000000000000000000000000000000;;		// don't set conntrack hashsize and return a special error
0000000000000000000000000000000000000000;;		// readOnlySysFSError here. The caller should deal with
0000000000000000000000000000000000000000;;		// readOnlySysFSError differently.
0000000000000000000000000000000000000000;;		writable, err := isSysFSWritable()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !writable {
0000000000000000000000000000000000000000;;			return readOnlySysFSError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: generify this and sysctl to a new sysfs.WriteInt()
0000000000000000000000000000000000000000;;		glog.Infof("Setting conntrack hashsize to %d", max/4)
0000000000000000000000000000000000000000;;		return writeIntStringFile("/sys/module/nf_conntrack/parameters/hashsize", max/4)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rct realConntracker) SetTCPEstablishedTimeout(seconds int) error {
0000000000000000000000000000000000000000;;		return rct.setIntSysCtl("nf_conntrack_tcp_timeout_established", seconds)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rct realConntracker) SetTCPCloseWaitTimeout(seconds int) error {
0000000000000000000000000000000000000000;;		return rct.setIntSysCtl("nf_conntrack_tcp_timeout_close_wait", seconds)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (realConntracker) setIntSysCtl(name string, value int) error {
0000000000000000000000000000000000000000;;		entry := "net/netfilter/" + name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Set sysctl '%v' to %v", entry, value)
0000000000000000000000000000000000000000;;		if err := sysctl.New().SetSysctl(entry, value); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isSysFSWritable checks /proc/mounts to see whether sysfs is 'rw' or not.
0000000000000000000000000000000000000000;;	func isSysFSWritable() (bool, error) {
0000000000000000000000000000000000000000;;		const permWritable = "rw"
0000000000000000000000000000000000000000;;		const sysfsDevice = "sysfs"
0000000000000000000000000000000000000000;;		m := mount.New("" /* default mount path */)
0000000000000000000000000000000000000000;;		mountPoints, err := m.List()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("failed to list mount points: %v", err)
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, mountPoint := range mountPoints {
0000000000000000000000000000000000000000;;			if mountPoint.Type != sysfsDevice {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Check whether sysfs is 'rw'
0000000000000000000000000000000000000000;;			if len(mountPoint.Opts) > 0 && mountPoint.Opts[0] == permWritable {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Errorf("sysfs is not writable: %+v (mount options are %v)",
0000000000000000000000000000000000000000;;				mountPoint, mountPoint.Opts)
0000000000000000000000000000000000000000;;			return false, readOnlySysFSError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, errors.New("No sysfs mounted")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readIntStringFile(filename string) (int, error) {
0000000000000000000000000000000000000000;;		b, err := ioutil.ReadFile(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strconv.Atoi(strings.TrimSpace(string(b)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeIntStringFile(filename string, value int) error {
0000000000000000000000000000000000000000;;		return ioutil.WriteFile(filename, []byte(strconv.Itoa(value)), 0640)
0000000000000000000000000000000000000000;;	}
