0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
d13b706d630929e9df848c620e581276aa81d61d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package app
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/iptables"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeNodeInterface struct {
0000000000000000000000000000000000000000;;		node api.Node
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakeNodeInterface) Get(hostname string, options metav1.GetOptions) (*api.Node, error) {
0000000000000000000000000000000000000000;;		return &fake.node, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeIPTablesVersioner struct {
0000000000000000000000000000000000000000;;		version string // what to return
0000000000000000000000000000000000000000;;		err     error  // what to return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakeIPTablesVersioner) GetVersion() (string, error) {
0000000000000000000000000000000000000000;;		return fake.version, fake.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeKernelCompatTester struct {
0000000000000000000000000000000000000000;;		ok bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakeKernelCompatTester) IsCompatible() error {
0000000000000000000000000000000000000000;;		if !fake.ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_getProxyMode(t *testing.T) {
0000000000000000000000000000000000000000;;		if runtime.GOOS != "linux" {
0000000000000000000000000000000000000000;;			t.Skip("skipping on non-Linux")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var cases = []struct {
0000000000000000000000000000000000000000;;			flag            string
0000000000000000000000000000000000000000;;			annotationKey   string
0000000000000000000000000000000000000000;;			annotationVal   string
0000000000000000000000000000000000000000;;			iptablesVersion string
0000000000000000000000000000000000000000;;			kernelCompat    bool
0000000000000000000000000000000000000000;;			iptablesError   error
0000000000000000000000000000000000000000;;			expected        string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{ // flag says userspace
0000000000000000000000000000000000000000;;				flag:     "userspace",
0000000000000000000000000000000000000000;;				expected: proxyModeUserspace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // flag says iptables, error detecting version
0000000000000000000000000000000000000000;;				flag:          "iptables",
0000000000000000000000000000000000000000;;				iptablesError: fmt.Errorf("oops!"),
0000000000000000000000000000000000000000;;				expected:      proxyModeUserspace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // flag says iptables, version too low
0000000000000000000000000000000000000000;;				flag:            "iptables",
0000000000000000000000000000000000000000;;				iptablesVersion: "0.0.0",
0000000000000000000000000000000000000000;;				expected:        proxyModeUserspace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // flag says iptables, version ok, kernel not compatible
0000000000000000000000000000000000000000;;				flag:            "iptables",
0000000000000000000000000000000000000000;;				iptablesVersion: iptables.MinCheckVersion,
0000000000000000000000000000000000000000;;				kernelCompat:    false,
0000000000000000000000000000000000000000;;				expected:        proxyModeUserspace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // flag says iptables, version ok, kernel is compatible
0000000000000000000000000000000000000000;;				flag:            "iptables",
0000000000000000000000000000000000000000;;				iptablesVersion: iptables.MinCheckVersion,
0000000000000000000000000000000000000000;;				kernelCompat:    true,
0000000000000000000000000000000000000000;;				expected:        proxyModeIPTables,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // detect, error
0000000000000000000000000000000000000000;;				flag:          "",
0000000000000000000000000000000000000000;;				iptablesError: fmt.Errorf("oops!"),
0000000000000000000000000000000000000000;;				expected:      proxyModeUserspace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // detect, version too low
0000000000000000000000000000000000000000;;				flag:            "",
0000000000000000000000000000000000000000;;				iptablesVersion: "0.0.0",
0000000000000000000000000000000000000000;;				expected:        proxyModeUserspace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // detect, version ok, kernel not compatible
0000000000000000000000000000000000000000;;				flag:            "",
0000000000000000000000000000000000000000;;				iptablesVersion: iptables.MinCheckVersion,
0000000000000000000000000000000000000000;;				kernelCompat:    false,
0000000000000000000000000000000000000000;;				expected:        proxyModeUserspace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // detect, version ok, kernel is compatible
0000000000000000000000000000000000000000;;				flag:            "",
0000000000000000000000000000000000000000;;				iptablesVersion: iptables.MinCheckVersion,
0000000000000000000000000000000000000000;;				kernelCompat:    true,
0000000000000000000000000000000000000000;;				expected:        proxyModeIPTables,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, c := range cases {
0000000000000000000000000000000000000000;;			versioner := &fakeIPTablesVersioner{c.iptablesVersion, c.iptablesError}
0000000000000000000000000000000000000000;;			kcompater := &fakeKernelCompatTester{c.kernelCompat}
0000000000000000000000000000000000000000;;			r := getProxyMode(c.flag, versioner, kcompater)
0000000000000000000000000000000000000000;;			if r != c.expected {
0000000000000000000000000000000000000000;;				t.Errorf("Case[%d] Expected %q, got %q", i, c.expected, r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This test verifies that Proxy Server does not crash when CleanupAndExit is true.
0000000000000000000000000000000000000000;;	func TestProxyServerWithCleanupAndExit(t *testing.T) {
0000000000000000000000000000000000000000;;		options, err := NewOptions()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options.config = &componentconfig.KubeProxyConfiguration{
0000000000000000000000000000000000000000;;			BindAddress: "0.0.0.0",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		options.CleanupAndExit = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxyserver, err := NewProxyServer(options.config, options.CleanupAndExit, options.scheme, options.master)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.Nil(t, err)
0000000000000000000000000000000000000000;;		assert.NotNil(t, proxyserver)
0000000000000000000000000000000000000000;;		assert.NotNil(t, proxyserver.IptInterface)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetConntrackMax(t *testing.T) {
0000000000000000000000000000000000000000;;		ncores := runtime.NumCPU()
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			min        int32
0000000000000000000000000000000000000000;;			max        int32
0000000000000000000000000000000000000000;;			maxPerCore int32
0000000000000000000000000000000000000000;;			expected   int
0000000000000000000000000000000000000000;;			err        string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				expected: 0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				max:      12345,
0000000000000000000000000000000000000000;;				expected: 12345,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				max:        12345,
0000000000000000000000000000000000000000;;				maxPerCore: 67890,
0000000000000000000000000000000000000000;;				expected:   -1,
0000000000000000000000000000000000000000;;				err:        "mutually exclusive",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				maxPerCore: 67890, // use this if Max is 0
0000000000000000000000000000000000000000;;				min:        1,     // avoid 0 default
0000000000000000000000000000000000000000;;				expected:   67890 * ncores,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				maxPerCore: 1, // ensure that Min is considered
0000000000000000000000000000000000000000;;				min:        123456,
0000000000000000000000000000000000000000;;				expected:   123456,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				maxPerCore: 0, // leave system setting
0000000000000000000000000000000000000000;;				min:        123456,
0000000000000000000000000000000000000000;;				expected:   0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			cfg := componentconfig.KubeProxyConntrackConfiguration{
0000000000000000000000000000000000000000;;				Min:        tc.min,
0000000000000000000000000000000000000000;;				Max:        tc.max,
0000000000000000000000000000000000000000;;				MaxPerCore: tc.maxPerCore,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x, e := getConntrackMax(cfg)
0000000000000000000000000000000000000000;;			if e != nil {
0000000000000000000000000000000000000000;;				if tc.err == "" {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] unexpected error: %v", i, e)
0000000000000000000000000000000000000000;;				} else if !strings.Contains(e.Error(), tc.err) {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] expected an error containing %q: %v", i, tc.err, e)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if x != tc.expected {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] expected %d, got %d", i, tc.expected, x)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLoadConfig(t *testing.T) {
0000000000000000000000000000000000000000;;		yaml := `apiVersion: componentconfig/v1alpha1
0000000000000000000000000000000000000000;;	bindAddress: 9.8.7.6
0000000000000000000000000000000000000000;;	clientConnection:
0000000000000000000000000000000000000000;;	  acceptContentTypes: "abc"
0000000000000000000000000000000000000000;;	  burst: 100
0000000000000000000000000000000000000000;;	  contentType: content-type
0000000000000000000000000000000000000000;;	  kubeconfig: "/path/to/kubeconfig"
0000000000000000000000000000000000000000;;	  qps: 7
0000000000000000000000000000000000000000;;	clusterCIDR: "1.2.3.0/24"
0000000000000000000000000000000000000000;;	configSyncPeriod: 15s
0000000000000000000000000000000000000000;;	conntrack:
0000000000000000000000000000000000000000;;	  max: 4
0000000000000000000000000000000000000000;;	  maxPerCore: 2
0000000000000000000000000000000000000000;;	  min: 1
0000000000000000000000000000000000000000;;	  tcpCloseWaitTimeout: 10s
0000000000000000000000000000000000000000;;	  tcpEstablishedTimeout: 20s
0000000000000000000000000000000000000000;;	featureGates: "all"
0000000000000000000000000000000000000000;;	healthzBindAddress: 1.2.3.4:12345
0000000000000000000000000000000000000000;;	hostnameOverride: "foo"
0000000000000000000000000000000000000000;;	iptables:
0000000000000000000000000000000000000000;;	  masqueradeAll: true
0000000000000000000000000000000000000000;;	  masqueradeBit: 17
0000000000000000000000000000000000000000;;	  minSyncPeriod: 10s
0000000000000000000000000000000000000000;;	  syncPeriod: 60s
0000000000000000000000000000000000000000;;	kind: KubeProxyConfiguration
0000000000000000000000000000000000000000;;	metricsBindAddress: 2.3.4.5:23456
0000000000000000000000000000000000000000;;	mode: "iptables"
0000000000000000000000000000000000000000;;	oomScoreAdj: 17
0000000000000000000000000000000000000000;;	portRange: "2-7"
0000000000000000000000000000000000000000;;	resourceContainer: /foo
0000000000000000000000000000000000000000;;	udpTimeoutMilliseconds: 123ms
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected := &componentconfig.KubeProxyConfiguration{
0000000000000000000000000000000000000000;;			BindAddress: "9.8.7.6",
0000000000000000000000000000000000000000;;			ClientConnection: componentconfig.ClientConnectionConfiguration{
0000000000000000000000000000000000000000;;				AcceptContentTypes: "abc",
0000000000000000000000000000000000000000;;				Burst:              100,
0000000000000000000000000000000000000000;;				ContentType:        "content-type",
0000000000000000000000000000000000000000;;				KubeConfigFile:     "/path/to/kubeconfig",
0000000000000000000000000000000000000000;;				QPS:                7,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ClusterCIDR:      "1.2.3.0/24",
0000000000000000000000000000000000000000;;			ConfigSyncPeriod: metav1.Duration{Duration: 15 * time.Second},
0000000000000000000000000000000000000000;;			Conntrack: componentconfig.KubeProxyConntrackConfiguration{
0000000000000000000000000000000000000000;;				Max:                   4,
0000000000000000000000000000000000000000;;				MaxPerCore:            2,
0000000000000000000000000000000000000000;;				Min:                   1,
0000000000000000000000000000000000000000;;				TCPCloseWaitTimeout:   metav1.Duration{Duration: 10 * time.Second},
0000000000000000000000000000000000000000;;				TCPEstablishedTimeout: metav1.Duration{Duration: 20 * time.Second},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			FeatureGates:       "all",
0000000000000000000000000000000000000000;;			HealthzBindAddress: "1.2.3.4:12345",
0000000000000000000000000000000000000000;;			HostnameOverride:   "foo",
0000000000000000000000000000000000000000;;			IPTables: componentconfig.KubeProxyIPTablesConfiguration{
0000000000000000000000000000000000000000;;				MasqueradeAll: true,
0000000000000000000000000000000000000000;;				MasqueradeBit: util.Int32Ptr(17),
0000000000000000000000000000000000000000;;				MinSyncPeriod: metav1.Duration{Duration: 10 * time.Second},
0000000000000000000000000000000000000000;;				SyncPeriod:    metav1.Duration{Duration: 60 * time.Second},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			MetricsBindAddress: "2.3.4.5:23456",
0000000000000000000000000000000000000000;;			Mode:               "iptables",
0000000000000000000000000000000000000000;;			OOMScoreAdj:        util.Int32Ptr(17),
0000000000000000000000000000000000000000;;			PortRange:          "2-7",
0000000000000000000000000000000000000000;;			ResourceContainer:  "/foo",
0000000000000000000000000000000000000000;;			UDPIdleTimeout:     metav1.Duration{Duration: 123 * time.Millisecond},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options, err := NewOptions()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config, err := options.loadConfig([]byte(yaml))
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(expected, config) {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected config, diff = %s", diff.ObjectDiff(config, expected))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
