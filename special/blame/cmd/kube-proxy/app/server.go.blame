0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
5a142dc8ce502c03f30abd9843818c505d606e5d;pkg/proxy/server/server.go[pkg/proxy/server/server.go][cmd/kube-proxy/app/server.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package app does all of the work necessary to configure and run a
0000000000000000000000000000000000000000;;	// Kubernetes app process.
0000000000000000000000000000000000000000;;	package app
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/pprof"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		goruntime "runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/json"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/healthz"
0000000000000000000000000000000000000000;;		utilfeature "k8s.io/apiserver/pkg/util/feature"
0000000000000000000000000000000000000000;;		clientgoclientset "k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		v1core "k8s.io/client-go/kubernetes/typed/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig/v1alpha1"
0000000000000000000000000000000000000000;;		clientset "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/internalversion"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/qos"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/master/ports"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/proxy"
0000000000000000000000000000000000000000;;		proxyconfig "k8s.io/kubernetes/pkg/proxy/config"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/proxy/healthcheck"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/proxy/iptables"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/proxy/userspace"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/proxy/winuserspace"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/configz"
0000000000000000000000000000000000000000;;		utildbus "k8s.io/kubernetes/pkg/util/dbus"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		utiliptables "k8s.io/kubernetes/pkg/util/iptables"
0000000000000000000000000000000000000000;;		utilnetsh "k8s.io/kubernetes/pkg/util/netsh"
0000000000000000000000000000000000000000;;		nodeutil "k8s.io/kubernetes/pkg/util/node"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/oom"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/resourcecontainer"
0000000000000000000000000000000000000000;;		utilsysctl "k8s.io/kubernetes/pkg/util/sysctl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/version/verflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/prometheus/client_golang/prometheus"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		proxyModeUserspace = "userspace"
0000000000000000000000000000000000000000;;		proxyModeIPTables  = "iptables"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkKnownProxyMode returns true if proxyMode is valid.
0000000000000000000000000000000000000000;;	func checkKnownProxyMode(proxyMode string) bool {
0000000000000000000000000000000000000000;;		switch proxyMode {
0000000000000000000000000000000000000000;;		case "", proxyModeUserspace, proxyModeIPTables:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Options contains everything necessary to create and run a proxy server.
0000000000000000000000000000000000000000;;	type Options struct {
0000000000000000000000000000000000000000;;		// ConfigFile is the location of the proxy server's configuration file.
0000000000000000000000000000000000000000;;		ConfigFile string
0000000000000000000000000000000000000000;;		// WriteConfigTo is the path where the default configuration will be written.
0000000000000000000000000000000000000000;;		WriteConfigTo string
0000000000000000000000000000000000000000;;		// CleanupAndExit, when true, makes the proxy server clean up iptables rules, then exit.
0000000000000000000000000000000000000000;;		CleanupAndExit bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// config is the proxy server's configuration object.
0000000000000000000000000000000000000000;;		config *componentconfig.KubeProxyConfiguration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The fields below here are placeholders for flags that can't be directly mapped into
0000000000000000000000000000000000000000;;		// componentconfig.KubeProxyConfiguration.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// TODO remove these fields once the deprecated flags are removed.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// master is used to override the kubeconfig's URL to the apiserver.
0000000000000000000000000000000000000000;;		master string
0000000000000000000000000000000000000000;;		// healthzPort is the port to be used by the healthz server.
0000000000000000000000000000000000000000;;		healthzPort int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scheme *runtime.Scheme
0000000000000000000000000000000000000000;;		codecs serializer.CodecFactory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddFlags adds flags to fs and binds them to options.
0000000000000000000000000000000000000000;;	func AddFlags(options *Options, fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		fs.StringVar(&options.ConfigFile, "config", options.ConfigFile, "The path to the configuration file.")
0000000000000000000000000000000000000000;;		fs.StringVar(&options.WriteConfigTo, "write-config-to", options.WriteConfigTo, "If set, write the default configuration values to this file and exit.")
0000000000000000000000000000000000000000;;		fs.BoolVar(&options.CleanupAndExit, "cleanup-iptables", options.CleanupAndExit, "If true cleanup iptables rules and exit.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// All flags below here are deprecated and will eventually be removed.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.Var(componentconfig.IPVar{Val: &options.config.BindAddress}, "bind-address", "The IP address for the proxy server to serve on (set to 0.0.0.0 for all interfaces)")
0000000000000000000000000000000000000000;;		fs.StringVar(&options.master, "master", options.master, "The address of the Kubernetes API server (overrides any value in kubeconfig)")
0000000000000000000000000000000000000000;;		fs.Int32Var(&options.healthzPort, "healthz-port", options.healthzPort, "The port to bind the health check server. Use 0 to disable.")
0000000000000000000000000000000000000000;;		fs.Var(componentconfig.IPVar{Val: &options.config.HealthzBindAddress}, "healthz-bind-address", "The IP address and port for the health check server to serve on (set to 0.0.0.0 for all interfaces)")
0000000000000000000000000000000000000000;;		fs.Var(componentconfig.IPVar{Val: &options.config.MetricsBindAddress}, "metrics-bind-address", "The IP address and port for the metrics server to serve on (set to 0.0.0.0 for all interfaces)")
0000000000000000000000000000000000000000;;		fs.Int32Var(options.config.OOMScoreAdj, "oom-score-adj", util.Int32PtrDerefOr(options.config.OOMScoreAdj, int32(qos.KubeProxyOOMScoreAdj)), "The oom-score-adj value for kube-proxy process. Values must be within the range [-1000, 1000]")
0000000000000000000000000000000000000000;;		fs.StringVar(&options.config.ResourceContainer, "resource-container", options.config.ResourceContainer, "Absolute name of the resource-only container to create and run the Kube-proxy in (Default: /kube-proxy).")
0000000000000000000000000000000000000000;;		fs.MarkDeprecated("resource-container", "This feature will be removed in a later release.")
0000000000000000000000000000000000000000;;		fs.StringVar(&options.config.ClientConnection.KubeConfigFile, "kubeconfig", options.config.ClientConnection.KubeConfigFile, "Path to kubeconfig file with authorization information (the master location is set by the master flag).")
0000000000000000000000000000000000000000;;		fs.Var(componentconfig.PortRangeVar{Val: &options.config.PortRange}, "proxy-port-range", "Range of host ports (beginPort-endPort, inclusive) that may be consumed in order to proxy service traffic. If unspecified (0-0) then ports will be randomly chosen.")
0000000000000000000000000000000000000000;;		fs.StringVar(&options.config.HostnameOverride, "hostname-override", options.config.HostnameOverride, "If non-empty, will use this string as identification instead of the actual hostname.")
0000000000000000000000000000000000000000;;		fs.Var(&options.config.Mode, "proxy-mode", "Which proxy mode to use: 'userspace' (older) or 'iptables' (faster). If blank, use the best-available proxy (currently iptables).  If the iptables proxy is selected, regardless of how, but the system's kernel or iptables versions are insufficient, this always falls back to the userspace proxy.")
0000000000000000000000000000000000000000;;		fs.Int32Var(options.config.IPTables.MasqueradeBit, "iptables-masquerade-bit", util.Int32PtrDerefOr(options.config.IPTables.MasqueradeBit, 14), "If using the pure iptables proxy, the bit of the fwmark space to mark packets requiring SNAT with.  Must be within the range [0, 31].")
0000000000000000000000000000000000000000;;		fs.DurationVar(&options.config.IPTables.SyncPeriod.Duration, "iptables-sync-period", options.config.IPTables.SyncPeriod.Duration, "The maximum interval of how often iptables rules are refreshed (e.g. '5s', '1m', '2h22m').  Must be greater than 0.")
0000000000000000000000000000000000000000;;		fs.DurationVar(&options.config.IPTables.MinSyncPeriod.Duration, "iptables-min-sync-period", options.config.IPTables.MinSyncPeriod.Duration, "The minimum interval of how often the iptables rules can be refreshed as endpoints and services change (e.g. '5s', '1m', '2h22m').")
0000000000000000000000000000000000000000;;		fs.DurationVar(&options.config.ConfigSyncPeriod.Duration, "config-sync-period", options.config.ConfigSyncPeriod.Duration, "How often configuration from the apiserver is refreshed.  Must be greater than 0.")
0000000000000000000000000000000000000000;;		fs.BoolVar(&options.config.IPTables.MasqueradeAll, "masquerade-all", options.config.IPTables.MasqueradeAll, "If using the pure iptables proxy, SNAT everything (this not commonly needed)")
0000000000000000000000000000000000000000;;		fs.StringVar(&options.config.ClusterCIDR, "cluster-cidr", options.config.ClusterCIDR, "The CIDR range of pods in the cluster. It is used to bridge traffic coming from outside of the cluster. If not provided, no off-cluster bridging will be performed.")
0000000000000000000000000000000000000000;;		fs.StringVar(&options.config.ClientConnection.ContentType, "kube-api-content-type", options.config.ClientConnection.ContentType, "Content type of requests sent to apiserver.")
0000000000000000000000000000000000000000;;		fs.Float32Var(&options.config.ClientConnection.QPS, "kube-api-qps", options.config.ClientConnection.QPS, "QPS to use while talking with kubernetes apiserver")
0000000000000000000000000000000000000000;;		fs.IntVar(&options.config.ClientConnection.Burst, "kube-api-burst", options.config.ClientConnection.Burst, "Burst to use while talking with kubernetes apiserver")
0000000000000000000000000000000000000000;;		fs.DurationVar(&options.config.UDPIdleTimeout.Duration, "udp-timeout", options.config.UDPIdleTimeout.Duration, "How long an idle UDP connection will be kept open (e.g. '250ms', '2s').  Must be greater than 0. Only applicable for proxy-mode=userspace")
0000000000000000000000000000000000000000;;		fs.Int32Var(&options.config.Conntrack.Max, "conntrack-max", options.config.Conntrack.Max,
0000000000000000000000000000000000000000;;			"Maximum number of NAT connections to track (0 to leave as-is). This overrides conntrack-max-per-core and conntrack-min.")
0000000000000000000000000000000000000000;;		fs.MarkDeprecated("conntrack-max", "This feature will be removed in a later release.")
0000000000000000000000000000000000000000;;		fs.Int32Var(&options.config.Conntrack.MaxPerCore, "conntrack-max-per-core", options.config.Conntrack.MaxPerCore,
0000000000000000000000000000000000000000;;			"Maximum number of NAT connections to track per CPU core (0 to leave the limit as-is and ignore conntrack-min).")
0000000000000000000000000000000000000000;;		fs.Int32Var(&options.config.Conntrack.Min, "conntrack-min", options.config.Conntrack.Min,
0000000000000000000000000000000000000000;;			"Minimum number of conntrack entries to allocate, regardless of conntrack-max-per-core (set conntrack-max-per-core=0 to leave the limit as-is).")
0000000000000000000000000000000000000000;;		fs.DurationVar(&options.config.Conntrack.TCPEstablishedTimeout.Duration, "conntrack-tcp-timeout-established", options.config.Conntrack.TCPEstablishedTimeout.Duration, "Idle timeout for established TCP connections (0 to leave as-is)")
0000000000000000000000000000000000000000;;		fs.DurationVar(
0000000000000000000000000000000000000000;;			&options.config.Conntrack.TCPCloseWaitTimeout.Duration, "conntrack-tcp-timeout-close-wait",
0000000000000000000000000000000000000000;;			options.config.Conntrack.TCPCloseWaitTimeout.Duration,
0000000000000000000000000000000000000000;;			"NAT timeout for TCP connections in the CLOSE_WAIT state")
0000000000000000000000000000000000000000;;		fs.BoolVar(&options.config.EnableProfiling, "profiling", options.config.EnableProfiling, "If true enables profiling via web interface on /debug/pprof handler.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilfeature.DefaultFeatureGate.AddFlag(fs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewOptions() (*Options, error) {
0000000000000000000000000000000000000000;;		o := &Options{
0000000000000000000000000000000000000000;;			config:      new(componentconfig.KubeProxyConfiguration),
0000000000000000000000000000000000000000;;			healthzPort: ports.ProxyHealthzPort,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.scheme = runtime.NewScheme()
0000000000000000000000000000000000000000;;		o.codecs = serializer.NewCodecFactory(o.scheme)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := componentconfig.AddToScheme(o.scheme); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := v1alpha1.AddToScheme(o.scheme); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return o, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Complete completes all the required options.
0000000000000000000000000000000000000000;;	func (o *Options) Complete() error {
0000000000000000000000000000000000000000;;		if len(o.ConfigFile) == 0 && len(o.WriteConfigTo) == 0 {
0000000000000000000000000000000000000000;;			glog.Warning("WARNING: all flags other than --config, --write-config-to, and --cleanup-iptables are deprecated. Please begin using a config file ASAP.")
0000000000000000000000000000000000000000;;			o.applyDeprecatedHealthzPortToConfig()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate validates all the required options.
0000000000000000000000000000000000000000;;	func (o *Options) Validate(args []string) error {
0000000000000000000000000000000000000000;;		if len(args) != 0 {
0000000000000000000000000000000000000000;;			return errors.New("no arguments are supported")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Options) Run() error {
0000000000000000000000000000000000000000;;		config := o.config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(o.WriteConfigTo) > 0 {
0000000000000000000000000000000000000000;;			return o.writeConfigFile()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(o.ConfigFile) > 0 {
0000000000000000000000000000000000000000;;			if c, err := o.loadConfigFromFile(o.ConfigFile); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				config = c
0000000000000000000000000000000000000000;;				// Make sure we apply the feature gate settings in the config file.
0000000000000000000000000000000000000000;;				utilfeature.DefaultFeatureGate.Set(config.FeatureGates)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxyServer, err := NewProxyServer(config, o.CleanupAndExit, o.scheme, o.master)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return proxyServer.Run()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Options) writeConfigFile() error {
0000000000000000000000000000000000000000;;		var encoder runtime.Encoder
0000000000000000000000000000000000000000;;		mediaTypes := o.codecs.SupportedMediaTypes()
0000000000000000000000000000000000000000;;		for _, info := range mediaTypes {
0000000000000000000000000000000000000000;;			if info.MediaType == "application/yaml" {
0000000000000000000000000000000000000000;;				encoder = info.Serializer
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if encoder == nil {
0000000000000000000000000000000000000000;;			return errors.New("unable to locate yaml encoder")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		encoder = json.NewYAMLSerializer(json.DefaultMetaFactory, o.scheme, o.scheme)
0000000000000000000000000000000000000000;;		encoder = o.codecs.EncoderForVersion(encoder, v1alpha1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configFile, err := os.Create(o.WriteConfigTo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer configFile.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := encoder.Encode(o.config, configFile); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Printf("Wrote configuration to: %s\n", o.WriteConfigTo)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// applyDeprecatedHealthzPortToConfig sets o.config.HealthzBindAddress from
0000000000000000000000000000000000000000;;	// flags passed on the command line based on the following rules:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 1. If --healthz-port is 0, disable the healthz server.
0000000000000000000000000000000000000000;;	// 2. Otherwise, use the value of --healthz-port for the port portion of
0000000000000000000000000000000000000000;;	//    o.config.HealthzBindAddress
0000000000000000000000000000000000000000;;	func (o *Options) applyDeprecatedHealthzPortToConfig() {
0000000000000000000000000000000000000000;;		if o.healthzPort == 0 {
0000000000000000000000000000000000000000;;			o.config.HealthzBindAddress = ""
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		index := strings.Index(o.config.HealthzBindAddress, ":")
0000000000000000000000000000000000000000;;		if index != -1 {
0000000000000000000000000000000000000000;;			o.config.HealthzBindAddress = o.config.HealthzBindAddress[0:index]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.config.HealthzBindAddress = fmt.Sprintf("%s:%d", o.config.HealthzBindAddress, o.healthzPort)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// loadConfigFromFile loads the contents of file and decodes it as a
0000000000000000000000000000000000000000;;	// KubeProxyConfiguration object.
0000000000000000000000000000000000000000;;	func (o *Options) loadConfigFromFile(file string) (*componentconfig.KubeProxyConfiguration, error) {
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return o.loadConfig(data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// loadConfig decodes data as a KubeProxyConfiguration object.
0000000000000000000000000000000000000000;;	func (o *Options) loadConfig(data []byte) (*componentconfig.KubeProxyConfiguration, error) {
0000000000000000000000000000000000000000;;		configObj, gvk, err := o.codecs.UniversalDecoder().Decode(data, nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config, ok := configObj.(*componentconfig.KubeProxyConfiguration)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("got unexpected config type: %v", gvk)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return config, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Options) applyDefaults(in *componentconfig.KubeProxyConfiguration) (*componentconfig.KubeProxyConfiguration, error) {
0000000000000000000000000000000000000000;;		external, err := o.scheme.ConvertToVersion(in, v1alpha1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.scheme.Default(external)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		internal, err := o.scheme.ConvertToVersion(external, componentconfig.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := internal.(*componentconfig.KubeProxyConfiguration)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewProxyCommand creates a *cobra.Command object with default parameters
0000000000000000000000000000000000000000;;	func NewProxyCommand() *cobra.Command {
0000000000000000000000000000000000000000;;		opts, err := NewOptions()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Unable to initialize command options: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use: "kube-proxy",
0000000000000000000000000000000000000000;;			Long: `The Kubernetes network proxy runs on each node. This
0000000000000000000000000000000000000000;;	reflects services as defined in the Kubernetes API on each node and can do simple
0000000000000000000000000000000000000000;;	TCP,UDP stream forwarding or round robin TCP,UDP forwarding across a set of backends.
0000000000000000000000000000000000000000;;	Service cluster ips and ports are currently found through Docker-links-compatible
0000000000000000000000000000000000000000;;	environment variables specifying ports opened by the service proxy. There is an optional
0000000000000000000000000000000000000000;;	addon that provides cluster DNS for these cluster IPs. The user must create a service
0000000000000000000000000000000000000000;;	with the apiserver API to configure the proxy.`,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				verflag.PrintAndExitIfRequested()
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(opts.Complete())
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(opts.Validate(args))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(opts.Run())
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts.config, err = opts.applyDefaults(opts.config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("unable to create flag defaults: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flags := cmd.Flags()
0000000000000000000000000000000000000000;;		AddFlags(opts, flags)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.MarkFlagFilename("config", "yaml", "yml", "json")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProxyServer represents all the parameters required to start the Kubernetes proxy server. All
0000000000000000000000000000000000000000;;	// fields are required.
0000000000000000000000000000000000000000;;	type ProxyServer struct {
0000000000000000000000000000000000000000;;		Client                 clientset.Interface
0000000000000000000000000000000000000000;;		EventClient            v1core.EventsGetter
0000000000000000000000000000000000000000;;		IptInterface           utiliptables.Interface
0000000000000000000000000000000000000000;;		Proxier                proxy.ProxyProvider
0000000000000000000000000000000000000000;;		Broadcaster            record.EventBroadcaster
0000000000000000000000000000000000000000;;		Recorder               record.EventRecorder
0000000000000000000000000000000000000000;;		ConntrackConfiguration componentconfig.KubeProxyConntrackConfiguration
0000000000000000000000000000000000000000;;		Conntracker            Conntracker // if nil, ignored
0000000000000000000000000000000000000000;;		ProxyMode              string
0000000000000000000000000000000000000000;;		NodeRef                *clientv1.ObjectReference
0000000000000000000000000000000000000000;;		CleanupAndExit         bool
0000000000000000000000000000000000000000;;		MetricsBindAddress     string
0000000000000000000000000000000000000000;;		EnableProfiling        bool
0000000000000000000000000000000000000000;;		OOMScoreAdj            *int32
0000000000000000000000000000000000000000;;		ResourceContainer      string
0000000000000000000000000000000000000000;;		ConfigSyncPeriod       time.Duration
0000000000000000000000000000000000000000;;		ServiceEventHandler    proxyconfig.ServiceHandler
0000000000000000000000000000000000000000;;		EndpointsEventHandler  proxyconfig.EndpointsHandler
0000000000000000000000000000000000000000;;		HealthzServer          *healthcheck.HealthzServer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createClients creates a kube client and an event client from the given config and masterOverride.
0000000000000000000000000000000000000000;;	// TODO remove masterOverride when CLI flags are removed.
0000000000000000000000000000000000000000;;	func createClients(config componentconfig.ClientConnectionConfiguration, masterOverride string) (clientset.Interface, v1core.EventsGetter, error) {
0000000000000000000000000000000000000000;;		if len(config.KubeConfigFile) == 0 && len(masterOverride) == 0 {
0000000000000000000000000000000000000000;;			glog.Warningf("Neither --kubeconfig nor --master was specified. Using default API client. This might not work.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This creates a client, first loading any specified kubeconfig
0000000000000000000000000000000000000000;;		// file, and then overriding the Master flag, if non-empty.
0000000000000000000000000000000000000000;;		kubeConfig, err := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(
0000000000000000000000000000000000000000;;			&clientcmd.ClientConfigLoadingRules{ExplicitPath: config.KubeConfigFile},
0000000000000000000000000000000000000000;;			&clientcmd.ConfigOverrides{ClusterInfo: clientcmdapi.Cluster{Server: masterOverride}}).ClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeConfig.AcceptContentTypes = config.AcceptContentTypes
0000000000000000000000000000000000000000;;		kubeConfig.ContentType = config.ContentType
0000000000000000000000000000000000000000;;		kubeConfig.QPS = config.QPS
0000000000000000000000000000000000000000;;		//TODO make config struct use int instead of int32?
0000000000000000000000000000000000000000;;		kubeConfig.Burst = int(config.Burst)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client, err := clientset.NewForConfig(kubeConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventClient, err := clientgoclientset.NewForConfig(kubeConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return client, eventClient, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewProxyServer returns a new ProxyServer.
0000000000000000000000000000000000000000;;	func NewProxyServer(config *componentconfig.KubeProxyConfiguration, cleanupAndExit bool, scheme *runtime.Scheme, master string) (*ProxyServer, error) {
0000000000000000000000000000000000000000;;		if config == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("config is required")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c, err := configz.New("componentconfig"); err == nil {
0000000000000000000000000000000000000000;;			c.Set(config)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to register configz: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		protocol := utiliptables.ProtocolIpv4
0000000000000000000000000000000000000000;;		if net.ParseIP(config.BindAddress).To4() == nil {
0000000000000000000000000000000000000000;;			protocol = utiliptables.ProtocolIpv6
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var netshInterface utilnetsh.Interface
0000000000000000000000000000000000000000;;		var iptInterface utiliptables.Interface
0000000000000000000000000000000000000000;;		var dbus utildbus.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a iptables utils.
0000000000000000000000000000000000000000;;		execer := exec.New()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if goruntime.GOOS == "windows" {
0000000000000000000000000000000000000000;;			netshInterface = utilnetsh.New(execer)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			dbus = utildbus.New()
0000000000000000000000000000000000000000;;			iptInterface = utiliptables.New(execer, dbus, protocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We omit creation of pretty much everything if we run in cleanup mode
0000000000000000000000000000000000000000;;		if cleanupAndExit {
0000000000000000000000000000000000000000;;			return &ProxyServer{IptInterface: iptInterface, CleanupAndExit: cleanupAndExit}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client, eventClient, err := createClients(config.ClientConnection, master)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create event recorder
0000000000000000000000000000000000000000;;		hostname := nodeutil.GetHostname(config.HostnameOverride)
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		recorder := eventBroadcaster.NewRecorder(scheme, clientv1.EventSource{Component: "kube-proxy", Host: hostname})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var healthzServer *healthcheck.HealthzServer
0000000000000000000000000000000000000000;;		if len(config.HealthzBindAddress) > 0 {
0000000000000000000000000000000000000000;;			healthzServer = healthcheck.NewDefaultHealthzServer(config.HealthzBindAddress, 2*config.IPTables.SyncPeriod.Duration)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var proxier proxy.ProxyProvider
0000000000000000000000000000000000000000;;		var serviceEventHandler proxyconfig.ServiceHandler
0000000000000000000000000000000000000000;;		var endpointsEventHandler proxyconfig.EndpointsHandler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxyMode := getProxyMode(string(config.Mode), iptInterface, iptables.LinuxKernelCompatTester{})
0000000000000000000000000000000000000000;;		if proxyMode == proxyModeIPTables {
0000000000000000000000000000000000000000;;			glog.V(0).Info("Using iptables Proxier.")
0000000000000000000000000000000000000000;;			var nodeIP net.IP
0000000000000000000000000000000000000000;;			if config.BindAddress != "0.0.0.0" {
0000000000000000000000000000000000000000;;				nodeIP = net.ParseIP(config.BindAddress)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				nodeIP = getNodeIP(client, hostname)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if config.IPTables.MasqueradeBit == nil {
0000000000000000000000000000000000000000;;				// MasqueradeBit must be specified or defaulted.
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unable to read IPTables MasqueradeBit from config")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO this has side effects that should only happen when Run() is invoked.
0000000000000000000000000000000000000000;;			proxierIPTables, err := iptables.NewProxier(
0000000000000000000000000000000000000000;;				iptInterface,
0000000000000000000000000000000000000000;;				utilsysctl.New(),
0000000000000000000000000000000000000000;;				execer,
0000000000000000000000000000000000000000;;				config.IPTables.SyncPeriod.Duration,
0000000000000000000000000000000000000000;;				config.IPTables.MinSyncPeriod.Duration,
0000000000000000000000000000000000000000;;				config.IPTables.MasqueradeAll,
0000000000000000000000000000000000000000;;				int(*config.IPTables.MasqueradeBit),
0000000000000000000000000000000000000000;;				config.ClusterCIDR,
0000000000000000000000000000000000000000;;				hostname,
0000000000000000000000000000000000000000;;				nodeIP,
0000000000000000000000000000000000000000;;				recorder,
0000000000000000000000000000000000000000;;				healthzServer,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unable to create proxier: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			iptables.RegisterMetrics()
0000000000000000000000000000000000000000;;			proxier = proxierIPTables
0000000000000000000000000000000000000000;;			serviceEventHandler = proxierIPTables
0000000000000000000000000000000000000000;;			endpointsEventHandler = proxierIPTables
0000000000000000000000000000000000000000;;			// No turning back. Remove artifacts that might still exist from the userspace Proxier.
0000000000000000000000000000000000000000;;			glog.V(0).Info("Tearing down userspace rules.")
0000000000000000000000000000000000000000;;			// TODO this has side effects that should only happen when Run() is invoked.
0000000000000000000000000000000000000000;;			userspace.CleanupLeftovers(iptInterface)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(0).Info("Using userspace Proxier.")
0000000000000000000000000000000000000000;;			if goruntime.GOOS == "windows" {
0000000000000000000000000000000000000000;;				// This is a proxy.LoadBalancer which NewProxier needs but has methods we don't need for
0000000000000000000000000000000000000000;;				// our config.EndpointsConfigHandler.
0000000000000000000000000000000000000000;;				loadBalancer := winuserspace.NewLoadBalancerRR()
0000000000000000000000000000000000000000;;				// set EndpointsHandler to our loadBalancer
0000000000000000000000000000000000000000;;				endpointsEventHandler = loadBalancer
0000000000000000000000000000000000000000;;				proxierUserspace, err := winuserspace.NewProxier(
0000000000000000000000000000000000000000;;					loadBalancer,
0000000000000000000000000000000000000000;;					net.ParseIP(config.BindAddress),
0000000000000000000000000000000000000000;;					netshInterface,
0000000000000000000000000000000000000000;;					*utilnet.ParsePortRangeOrDie(config.PortRange),
0000000000000000000000000000000000000000;;					// TODO @pires replace below with default values, if applicable
0000000000000000000000000000000000000000;;					config.IPTables.SyncPeriod.Duration,
0000000000000000000000000000000000000000;;					config.UDPIdleTimeout.Duration,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("unable to create proxier: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				serviceEventHandler = proxierUserspace
0000000000000000000000000000000000000000;;				proxier = proxierUserspace
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// This is a proxy.LoadBalancer which NewProxier needs but has methods we don't need for
0000000000000000000000000000000000000000;;				// our config.EndpointsConfigHandler.
0000000000000000000000000000000000000000;;				loadBalancer := userspace.NewLoadBalancerRR()
0000000000000000000000000000000000000000;;				// set EndpointsConfigHandler to our loadBalancer
0000000000000000000000000000000000000000;;				endpointsEventHandler = loadBalancer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// TODO this has side effects that should only happen when Run() is invoked.
0000000000000000000000000000000000000000;;				proxierUserspace, err := userspace.NewProxier(
0000000000000000000000000000000000000000;;					loadBalancer,
0000000000000000000000000000000000000000;;					net.ParseIP(config.BindAddress),
0000000000000000000000000000000000000000;;					iptInterface,
0000000000000000000000000000000000000000;;					execer,
0000000000000000000000000000000000000000;;					*utilnet.ParsePortRangeOrDie(config.PortRange),
0000000000000000000000000000000000000000;;					config.IPTables.SyncPeriod.Duration,
0000000000000000000000000000000000000000;;					config.IPTables.MinSyncPeriod.Duration,
0000000000000000000000000000000000000000;;					config.UDPIdleTimeout.Duration,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("unable to create proxier: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				serviceEventHandler = proxierUserspace
0000000000000000000000000000000000000000;;				proxier = proxierUserspace
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Remove artifacts from the pure-iptables Proxier, if not on Windows.
0000000000000000000000000000000000000000;;			if goruntime.GOOS != "windows" {
0000000000000000000000000000000000000000;;				glog.V(0).Info("Tearing down pure-iptables proxy rules.")
0000000000000000000000000000000000000000;;				// TODO this has side effects that should only happen when Run() is invoked.
0000000000000000000000000000000000000000;;				iptables.CleanupLeftovers(iptInterface)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add iptables reload function, if not on Windows.
0000000000000000000000000000000000000000;;		if goruntime.GOOS != "windows" {
0000000000000000000000000000000000000000;;			iptInterface.AddReloadFunc(proxier.Sync)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeRef := &clientv1.ObjectReference{
0000000000000000000000000000000000000000;;			Kind:      "Node",
0000000000000000000000000000000000000000;;			Name:      hostname,
0000000000000000000000000000000000000000;;			UID:       types.UID(hostname),
0000000000000000000000000000000000000000;;			Namespace: "",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &ProxyServer{
0000000000000000000000000000000000000000;;			Client:                 client,
0000000000000000000000000000000000000000;;			EventClient:            eventClient,
0000000000000000000000000000000000000000;;			IptInterface:           iptInterface,
0000000000000000000000000000000000000000;;			Proxier:                proxier,
0000000000000000000000000000000000000000;;			Broadcaster:            eventBroadcaster,
0000000000000000000000000000000000000000;;			Recorder:               recorder,
0000000000000000000000000000000000000000;;			ConntrackConfiguration: config.Conntrack,
0000000000000000000000000000000000000000;;			Conntracker:            &realConntracker{},
0000000000000000000000000000000000000000;;			ProxyMode:              proxyMode,
0000000000000000000000000000000000000000;;			NodeRef:                nodeRef,
0000000000000000000000000000000000000000;;			MetricsBindAddress:     config.MetricsBindAddress,
0000000000000000000000000000000000000000;;			EnableProfiling:        config.EnableProfiling,
0000000000000000000000000000000000000000;;			OOMScoreAdj:            config.OOMScoreAdj,
0000000000000000000000000000000000000000;;			ResourceContainer:      config.ResourceContainer,
0000000000000000000000000000000000000000;;			ConfigSyncPeriod:       config.ConfigSyncPeriod.Duration,
0000000000000000000000000000000000000000;;			ServiceEventHandler:    serviceEventHandler,
0000000000000000000000000000000000000000;;			EndpointsEventHandler:  endpointsEventHandler,
0000000000000000000000000000000000000000;;			HealthzServer:          healthzServer,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run runs the specified ProxyServer.  This should never exit (unless CleanupAndExit is set).
0000000000000000000000000000000000000000;;	func (s *ProxyServer) Run() error {
0000000000000000000000000000000000000000;;		// remove iptables rules and exit
0000000000000000000000000000000000000000;;		if s.CleanupAndExit {
0000000000000000000000000000000000000000;;			encounteredError := userspace.CleanupLeftovers(s.IptInterface)
0000000000000000000000000000000000000000;;			encounteredError = iptables.CleanupLeftovers(s.IptInterface) || encounteredError
0000000000000000000000000000000000000000;;			if encounteredError {
0000000000000000000000000000000000000000;;				return errors.New("encountered an error while tearing down rules.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(vmarmol): Use container config for this.
0000000000000000000000000000000000000000;;		var oomAdjuster *oom.OOMAdjuster
0000000000000000000000000000000000000000;;		if s.OOMScoreAdj != nil {
0000000000000000000000000000000000000000;;			oomAdjuster = oom.NewOOMAdjuster()
0000000000000000000000000000000000000000;;			if err := oomAdjuster.ApplyOOMScoreAdj(0, int(*s.OOMScoreAdj)); err != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Info(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(s.ResourceContainer) != 0 {
0000000000000000000000000000000000000000;;			// Run in its own container.
0000000000000000000000000000000000000000;;			if err := resourcecontainer.RunInResourceContainer(s.ResourceContainer); err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to start in resource-only container %q: %v", s.ResourceContainer, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Running in resource-only container %q", s.ResourceContainer)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.Broadcaster != nil && s.EventClient != nil {
0000000000000000000000000000000000000000;;			s.Broadcaster.StartRecordingToSink(&v1core.EventSinkImpl{Interface: s.EventClient.Events("")})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start up a healthz server if requested
0000000000000000000000000000000000000000;;		if s.HealthzServer != nil {
0000000000000000000000000000000000000000;;			s.HealthzServer.Run()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start up a metrics server if requested
0000000000000000000000000000000000000000;;		if len(s.MetricsBindAddress) > 0 {
0000000000000000000000000000000000000000;;			mux := http.NewServeMux()
0000000000000000000000000000000000000000;;			healthz.InstallHandler(mux)
0000000000000000000000000000000000000000;;			mux.HandleFunc("/proxyMode", func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, "%s", s.ProxyMode)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			mux.Handle("/metrics", prometheus.Handler())
0000000000000000000000000000000000000000;;			if s.EnableProfiling {
0000000000000000000000000000000000000000;;				mux.HandleFunc("/debug/pprof/", pprof.Index)
0000000000000000000000000000000000000000;;				mux.HandleFunc("/debug/pprof/profile", pprof.Profile)
0000000000000000000000000000000000000000;;				mux.HandleFunc("/debug/pprof/symbol", pprof.Symbol)
0000000000000000000000000000000000000000;;				mux.HandleFunc("/debug/pprof/trace", pprof.Trace)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			configz.InstallHandler(mux)
0000000000000000000000000000000000000000;;			go wait.Until(func() {
0000000000000000000000000000000000000000;;				err := http.ListenAndServe(s.MetricsBindAddress, mux)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					utilruntime.HandleError(fmt.Errorf("starting metrics server failed: %v", err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}, 5*time.Second, wait.NeverStop)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Tune conntrack, if requested
0000000000000000000000000000000000000000;;		if s.Conntracker != nil && goruntime.GOOS != "windows" {
0000000000000000000000000000000000000000;;			max, err := getConntrackMax(s.ConntrackConfiguration)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if max > 0 {
0000000000000000000000000000000000000000;;				err := s.Conntracker.SetMax(max)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if err != readOnlySysFSError {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// readOnlySysFSError is caused by a known docker issue (https://github.com/docker/docker/issues/24000),
0000000000000000000000000000000000000000;;					// the only remediation we know is to restart the docker daemon.
0000000000000000000000000000000000000000;;					// Here we'll send an node event with specific reason and message, the
0000000000000000000000000000000000000000;;					// administrator should decide whether and how to handle this issue,
0000000000000000000000000000000000000000;;					// whether to drain the node and restart docker.
0000000000000000000000000000000000000000;;					// TODO(random-liu): Remove this when the docker bug is fixed.
0000000000000000000000000000000000000000;;					const message = "DOCKER RESTART NEEDED (docker issue #24000): /sys is read-only: " +
0000000000000000000000000000000000000000;;						"cannot modify conntrack limits, problems may arise later."
0000000000000000000000000000000000000000;;					s.Recorder.Eventf(s.NodeRef, api.EventTypeWarning, err.Error(), message)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if s.ConntrackConfiguration.TCPEstablishedTimeout.Duration > 0 {
0000000000000000000000000000000000000000;;				timeout := int(s.ConntrackConfiguration.TCPEstablishedTimeout.Duration / time.Second)
0000000000000000000000000000000000000000;;				if err := s.Conntracker.SetTCPEstablishedTimeout(timeout); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if s.ConntrackConfiguration.TCPCloseWaitTimeout.Duration > 0 {
0000000000000000000000000000000000000000;;				timeout := int(s.ConntrackConfiguration.TCPCloseWaitTimeout.Duration / time.Second)
0000000000000000000000000000000000000000;;				if err := s.Conntracker.SetTCPCloseWaitTimeout(timeout); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(s.Client, s.ConfigSyncPeriod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create configs (i.e. Watches for Services and Endpoints)
0000000000000000000000000000000000000000;;		// Note: RegisterHandler() calls need to happen before creation of Sources because sources
0000000000000000000000000000000000000000;;		// only notify on changes, and the initial update (on process start) may be lost if no handlers
0000000000000000000000000000000000000000;;		// are registered yet.
0000000000000000000000000000000000000000;;		serviceConfig := proxyconfig.NewServiceConfig(informerFactory.Core().InternalVersion().Services(), s.ConfigSyncPeriod)
0000000000000000000000000000000000000000;;		serviceConfig.RegisterEventHandler(s.ServiceEventHandler)
0000000000000000000000000000000000000000;;		go serviceConfig.Run(wait.NeverStop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpointsConfig := proxyconfig.NewEndpointsConfig(informerFactory.Core().InternalVersion().Endpoints(), s.ConfigSyncPeriod)
0000000000000000000000000000000000000000;;		endpointsConfig.RegisterEventHandler(s.EndpointsEventHandler)
0000000000000000000000000000000000000000;;		go endpointsConfig.Run(wait.NeverStop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This has to start after the calls to NewServiceConfig and NewEndpointsConfig because those
0000000000000000000000000000000000000000;;		// functions must configure their shared informer event handlers first.
0000000000000000000000000000000000000000;;		go informerFactory.Start(wait.NeverStop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Birth Cry after the birth is successful
0000000000000000000000000000000000000000;;		s.birthCry()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Just loop forever for now...
0000000000000000000000000000000000000000;;		s.Proxier.SyncLoop()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getConntrackMax(config componentconfig.KubeProxyConntrackConfiguration) (int, error) {
0000000000000000000000000000000000000000;;		if config.Max > 0 {
0000000000000000000000000000000000000000;;			if config.MaxPerCore > 0 {
0000000000000000000000000000000000000000;;				return -1, fmt.Errorf("invalid config: Conntrack Max and Conntrack MaxPerCore are mutually exclusive")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(3).Infof("getConntrackMax: using absolute conntrack-max (deprecated)")
0000000000000000000000000000000000000000;;			return int(config.Max), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.MaxPerCore > 0 {
0000000000000000000000000000000000000000;;			floor := int(config.Min)
0000000000000000000000000000000000000000;;			scaled := int(config.MaxPerCore) * goruntime.NumCPU()
0000000000000000000000000000000000000000;;			if scaled > floor {
0000000000000000000000000000000000000000;;				glog.V(3).Infof("getConntrackMax: using scaled conntrack-max-per-core")
0000000000000000000000000000000000000000;;				return scaled, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(3).Infof("getConntrackMax: using conntrack-min")
0000000000000000000000000000000000000000;;			return floor, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getProxyMode(proxyMode string, iptver iptables.IPTablesVersioner, kcompat iptables.KernelCompatTester) string {
0000000000000000000000000000000000000000;;		if proxyMode == proxyModeUserspace {
0000000000000000000000000000000000000000;;			return proxyModeUserspace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(proxyMode) > 0 && proxyMode != proxyModeIPTables {
0000000000000000000000000000000000000000;;			glog.Warningf("Flag proxy-mode=%q unknown, assuming iptables proxy", proxyMode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tryIPTablesProxy(iptver, kcompat)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tryIPTablesProxy(iptver iptables.IPTablesVersioner, kcompat iptables.KernelCompatTester) string {
0000000000000000000000000000000000000000;;		// guaranteed false on error, error only necessary for debugging
0000000000000000000000000000000000000000;;		useIPTablesProxy, err := iptables.CanUseIPTablesProxier(iptver, kcompat)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("can't determine whether to use iptables proxy, using userspace proxier: %v", err))
0000000000000000000000000000000000000000;;			return proxyModeUserspace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if useIPTablesProxy {
0000000000000000000000000000000000000000;;			return proxyModeIPTables
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Fallback.
0000000000000000000000000000000000000000;;		glog.V(1).Infof("Can't use iptables proxy, using userspace proxier")
0000000000000000000000000000000000000000;;		return proxyModeUserspace
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ProxyServer) birthCry() {
0000000000000000000000000000000000000000;;		s.Recorder.Eventf(s.NodeRef, api.EventTypeNormal, "Starting", "Starting kube-proxy.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNodeIP(client clientset.Interface, hostname string) net.IP {
0000000000000000000000000000000000000000;;		var nodeIP net.IP
0000000000000000000000000000000000000000;;		node, err := client.Core().Nodes().Get(hostname, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Failed to retrieve node info: %v", err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeIP, err = nodeutil.InternalGetNodeHostIP(node)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Failed to retrieve node IP: %v", err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodeIP
0000000000000000000000000000000000000000;;	}
