0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
b9765c9e56dba0e0e9f3b802ddfb9e9ede7aa351;pkg/standalone/standalone.go[pkg/standalone/standalone.go][cmd/kubelet/app/server.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package app makes it easy to create a kubelet server for various contexts.
0000000000000000000000000000000000000000;;	package app
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		_ "net/http/pprof"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/healthz"
0000000000000000000000000000000000000000;;		utilfeature "k8s.io/apiserver/pkg/util/feature"
0000000000000000000000000000000000000000;;		clientgoclientset "k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		v1core "k8s.io/client-go/kubernetes/typed/core/v1"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		clientauth "k8s.io/client-go/tools/auth"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		certutil "k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubelet/app/options"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		componentconfigv1alpha1 "k8s.io/kubernetes/pkg/apis/componentconfig/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/capabilities"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/chaosclient"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/credentialprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/features"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/cadvisor"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/certificate"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/cm"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/config"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/dockershim"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/dockershim/libdocker"
0000000000000000000000000000000000000000;;		dockerremote "k8s.io/kubernetes/pkg/kubelet/dockershim/remote"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/eviction"
0000000000000000000000000000000000000000;;		evictionapi "k8s.io/kubernetes/pkg/kubelet/eviction/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/server"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/server/streaming"
0000000000000000000000000000000000000000;;		kubetypes "k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/configz"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/flock"
0000000000000000000000000000000000000000;;		kubeio "k8s.io/kubernetes/pkg/util/io"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		nodeutil "k8s.io/kubernetes/pkg/util/node"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/oom"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/rlimit"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/version"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Kubelet component name
0000000000000000000000000000000000000000;;		componentKubelet = "kubelet"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewKubeletCommand creates a *cobra.Command object with default parameters
0000000000000000000000000000000000000000;;	func NewKubeletCommand() *cobra.Command {
0000000000000000000000000000000000000000;;		s := options.NewKubeletServer()
0000000000000000000000000000000000000000;;		s.AddFlags(pflag.CommandLine)
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use: componentKubelet,
0000000000000000000000000000000000000000;;			Long: `The kubelet is the primary "node agent" that runs on each
0000000000000000000000000000000000000000;;	node. The kubelet works in terms of a PodSpec. A PodSpec is a YAML or JSON object
0000000000000000000000000000000000000000;;	that describes a pod. The kubelet takes a set of PodSpecs that are provided through
0000000000000000000000000000000000000000;;	various mechanisms (primarily through the apiserver) and ensures that the containers
0000000000000000000000000000000000000000;;	described in those PodSpecs are running and healthy. The kubelet doesn't manage
0000000000000000000000000000000000000000;;	containers which were not created by Kubernetes.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Other than from an PodSpec from the apiserver, there are three ways that a container
0000000000000000000000000000000000000000;;	manifest can be provided to the Kubelet.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	File: Path passed as a flag on the command line. Files under this path will be monitored
0000000000000000000000000000000000000000;;	periodically for updates. The monitoring period is 20s by default and is configurable
0000000000000000000000000000000000000000;;	via a flag.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	HTTP endpoint: HTTP endpoint passed as a parameter on the command line. This endpoint
0000000000000000000000000000000000000000;;	is checked every 20 seconds (also configurable with a flag).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	HTTP server: The kubelet can also listen for HTTP and respond to a simple API
0000000000000000000000000000000000000000;;	(underspec'd currently) to submit a new manifest.`,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnsecuredKubeletDeps returns a KubeletDeps suitable for being run, or an error if the server setup
0000000000000000000000000000000000000000;;	// is not valid.  It will not start any background processes, and does not include authentication/authorization
0000000000000000000000000000000000000000;;	func UnsecuredKubeletDeps(s *options.KubeletServer) (*kubelet.KubeletDeps, error) {
0000000000000000000000000000000000000000;;		// Initialize the TLS Options
0000000000000000000000000000000000000000;;		tlsOptions, err := InitializeTLS(&s.KubeletFlags, &s.KubeletConfiguration)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mounter := mount.New(s.ExperimentalMounterPath)
0000000000000000000000000000000000000000;;		var writer kubeio.Writer = &kubeio.StdWriter{}
0000000000000000000000000000000000000000;;		if s.Containerized {
0000000000000000000000000000000000000000;;			glog.V(2).Info("Running kubelet in containerized mode (experimental)")
0000000000000000000000000000000000000000;;			mounter = mount.NewNsenterMounter()
0000000000000000000000000000000000000000;;			writer = &kubeio.NsenterWriter{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dockerClient libdocker.Interface
0000000000000000000000000000000000000000;;		if s.ContainerRuntime == kubetypes.DockerContainerRuntime {
0000000000000000000000000000000000000000;;			dockerClient = libdocker.ConnectToDockerOrDie(s.DockerEndpoint, s.RuntimeRequestTimeout.Duration,
0000000000000000000000000000000000000000;;				s.ImagePullProgressDeadline.Duration)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			dockerClient = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &kubelet.KubeletDeps{
0000000000000000000000000000000000000000;;			Auth:               nil, // default does not enforce auth[nz]
0000000000000000000000000000000000000000;;			CAdvisorInterface:  nil, // cadvisor.New launches background processes (bg http.ListenAndServe, and some bg cleaners), not set here
0000000000000000000000000000000000000000;;			Cloud:              nil, // cloud provider might start background processes
0000000000000000000000000000000000000000;;			ContainerManager:   nil,
0000000000000000000000000000000000000000;;			DockerClient:       dockerClient,
0000000000000000000000000000000000000000;;			KubeClient:         nil,
0000000000000000000000000000000000000000;;			ExternalKubeClient: nil,
0000000000000000000000000000000000000000;;			Mounter:            mounter,
0000000000000000000000000000000000000000;;			NetworkPlugins:     ProbeNetworkPlugins(s.NetworkPluginDir, s.CNIConfDir, s.CNIBinDir),
0000000000000000000000000000000000000000;;			OOMAdjuster:        oom.NewOOMAdjuster(),
0000000000000000000000000000000000000000;;			OSInterface:        kubecontainer.RealOS{},
0000000000000000000000000000000000000000;;			Writer:             writer,
0000000000000000000000000000000000000000;;			VolumePlugins:      ProbeVolumePlugins(s.VolumePluginDir),
0000000000000000000000000000000000000000;;			TLSOptions:         tlsOptions,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getKubeClient(s *options.KubeletServer) (*clientset.Clientset, error) {
0000000000000000000000000000000000000000;;		clientConfig, err := CreateAPIServerClientConfig(s)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			kubeClient, err := clientset.NewForConfig(clientConfig)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return kubeClient, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tries to download the kubelet-<node-name> configmap from "kube-system" namespace via the API server and returns a JSON string or error
0000000000000000000000000000000000000000;;	func getRemoteKubeletConfig(s *options.KubeletServer, kubeDeps *kubelet.KubeletDeps) (string, error) {
0000000000000000000000000000000000000000;;		// TODO(mtaufen): should probably cache clientset and pass into this function rather than regenerate on every request
0000000000000000000000000000000000000000;;		kubeClient, err := getKubeClient(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configmap, err := func() (*v1.ConfigMap, error) {
0000000000000000000000000000000000000000;;			var nodename types.NodeName
0000000000000000000000000000000000000000;;			hostname := nodeutil.GetHostname(s.HostnameOverride)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if kubeDeps != nil && kubeDeps.Cloud != nil {
0000000000000000000000000000000000000000;;				instances, ok := kubeDeps.Cloud.Instances()
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					err = fmt.Errorf("failed to get instances from cloud provider, can't determine nodename")
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				nodename, err = instances.CurrentNodeName(hostname)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					err = fmt.Errorf("error fetching current instance name from cloud provider: %v", err)
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// look for kubelet-<node-name> configmap from "kube-system"
0000000000000000000000000000000000000000;;				configmap, err := kubeClient.CoreV1Client.ConfigMaps("kube-system").Get(fmt.Sprintf("kubelet-%s", nodename), metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return configmap, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// No cloud provider yet, so can't get the nodename via Cloud.Instances().CurrentNodeName(hostname), try just using the hostname
0000000000000000000000000000000000000000;;			configmap, err := kubeClient.CoreV1Client.ConfigMaps("kube-system").Get(fmt.Sprintf("kubelet-%s", hostname), metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("cloud provider was nil, and attempt to use hostname to find config resulted in: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return configmap, nil
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// When we create the KubeletConfiguration configmap, we put a json string
0000000000000000000000000000000000000000;;		// representation of the config in a `kubelet.config` key.
0000000000000000000000000000000000000000;;		jsonstr, ok := configmap.Data["kubelet.config"]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("KubeletConfiguration configmap did not contain a value with key `kubelet.config`")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return jsonstr, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startKubeletConfigSyncLoop(s *options.KubeletServer, currentKC string) {
0000000000000000000000000000000000000000;;		glog.Infof("Starting Kubelet configuration sync loop")
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			wait.PollInfinite(30*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;				glog.Infof("Checking API server for new Kubelet configuration.")
0000000000000000000000000000000000000000;;				remoteKC, err := getRemoteKubeletConfig(s, nil)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					// Detect new config by comparing with the last JSON string we extracted.
0000000000000000000000000000000000000000;;					if remoteKC != currentKC {
0000000000000000000000000000000000000000;;						glog.Info("Found new Kubelet configuration via API server, restarting!")
0000000000000000000000000000000000000000;;						os.Exit(0)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					glog.Infof("Did not find a configuration for this Kubelet via API server: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, nil // Always return (false, nil) so we poll forever.
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Try to check for config on the API server, return that config if we get it, and start
0000000000000000000000000000000000000000;;	// a background thread that checks for updates to configs.
0000000000000000000000000000000000000000;;	func initKubeletConfigSync(s *options.KubeletServer) (*componentconfig.KubeletConfiguration, error) {
0000000000000000000000000000000000000000;;		jsonstr, err := getRemoteKubeletConfig(s, nil)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			// We will compare future API server config against the config we just got (jsonstr):
0000000000000000000000000000000000000000;;			startKubeletConfigSyncLoop(s, jsonstr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Convert json from API server to external type struct, and convert that to internal type struct
0000000000000000000000000000000000000000;;			extKC := componentconfigv1alpha1.KubeletConfiguration{}
0000000000000000000000000000000000000000;;			err := runtime.DecodeInto(api.Codecs.UniversalDecoder(), []byte(jsonstr), &extKC)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			api.Scheme.Default(&extKC)
0000000000000000000000000000000000000000;;			kc := componentconfig.KubeletConfiguration{}
0000000000000000000000000000000000000000;;			err = api.Scheme.Convert(&extKC, &kc, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &kc, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Couldn't get a configuration from the API server yet.
0000000000000000000000000000000000000000;;			// Restart as soon as anything comes back from the API server.
0000000000000000000000000000000000000000;;			startKubeletConfigSyncLoop(s, "")
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run runs the specified KubeletServer with the given KubeletDeps.  This should never exit.
0000000000000000000000000000000000000000;;	// The kubeDeps argument may be nil - if so, it is initialized from the settings on KubeletServer.
0000000000000000000000000000000000000000;;	// Otherwise, the caller is assumed to have set up the KubeletDeps object and a default one will
0000000000000000000000000000000000000000;;	// not be generated.
0000000000000000000000000000000000000000;;	func Run(s *options.KubeletServer, kubeDeps *kubelet.KubeletDeps) error {
0000000000000000000000000000000000000000;;		if err := run(s, kubeDeps); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to run Kubelet: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkPermissions() error {
0000000000000000000000000000000000000000;;		if uid := os.Getuid(); uid != 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Kubelet needs to run as uid `0`. It is being run as %d", uid)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: Check if kubelet is running in the `initial` user namespace.
0000000000000000000000000000000000000000;;		// http://man7.org/linux/man-pages/man7/user_namespaces.7.html
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setConfigz(cz *configz.Config, kc *componentconfig.KubeletConfiguration) {
0000000000000000000000000000000000000000;;		tmp := componentconfigv1alpha1.KubeletConfiguration{}
0000000000000000000000000000000000000000;;		api.Scheme.Convert(kc, &tmp, nil)
0000000000000000000000000000000000000000;;		cz.Set(tmp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func initConfigz(kc *componentconfig.KubeletConfiguration) (*configz.Config, error) {
0000000000000000000000000000000000000000;;		cz, err := configz.New("componentconfig")
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			setConfigz(cz, kc)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Errorf("unable to register configz: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cz, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateConfig validates configuration of Kubelet and returns an error if the input configuration is invalid.
0000000000000000000000000000000000000000;;	func validateConfig(s *options.KubeletServer) error {
0000000000000000000000000000000000000000;;		if !s.CgroupsPerQOS && len(s.EnforceNodeAllocatable) > 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Node Allocatable enforcement is not supported unless Cgroups Per QOS feature is turned on")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.SystemCgroups != "" && s.CgroupRoot == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid configuration: system container was specified and cgroup root was not specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, val := range s.EnforceNodeAllocatable {
0000000000000000000000000000000000000000;;			switch val {
0000000000000000000000000000000000000000;;			case cm.NodeAllocatableEnforcementKey:
0000000000000000000000000000000000000000;;			case cm.SystemReservedEnforcementKey:
0000000000000000000000000000000000000000;;			case cm.KubeReservedEnforcementKey:
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid option %q specified for EnforceNodeAllocatable setting. Valid options are %q, %q or %q", val, cm.NodeAllocatableEnforcementKey, cm.SystemReservedEnforcementKey, cm.KubeReservedEnforcementKey)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeEventRecorder sets up kubeDeps.Recorder if its nil. Its a no-op otherwise.
0000000000000000000000000000000000000000;;	func makeEventRecorder(s *componentconfig.KubeletConfiguration, kubeDeps *kubelet.KubeletDeps, nodeName types.NodeName) {
0000000000000000000000000000000000000000;;		if kubeDeps.Recorder != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		kubeDeps.Recorder = eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: componentKubelet, Host: string(nodeName)})
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(glog.V(3).Infof)
0000000000000000000000000000000000000000;;		if kubeDeps.EventClient != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Sending events to api server.")
0000000000000000000000000000000000000000;;			eventBroadcaster.StartRecordingToSink(&v1core.EventSinkImpl{Interface: kubeDeps.EventClient.Events("")})
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Warning("No api server defined - no events will be sent to API server.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func run(s *options.KubeletServer, kubeDeps *kubelet.KubeletDeps) (err error) {
0000000000000000000000000000000000000000;;		// TODO: this should be replaced by a --standalone flag
0000000000000000000000000000000000000000;;		standaloneMode := (len(s.APIServerList) == 0 && !s.RequireKubeConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.ExitOnLockContention && s.LockFilePath == "" {
0000000000000000000000000000000000000000;;			return errors.New("cannot exit on lock file contention: no lock file specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		done := make(chan struct{})
0000000000000000000000000000000000000000;;		if s.LockFilePath != "" {
0000000000000000000000000000000000000000;;			glog.Infof("acquiring file lock on %q", s.LockFilePath)
0000000000000000000000000000000000000000;;			if err := flock.Acquire(s.LockFilePath); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to acquire file lock on %q: %v", s.LockFilePath, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s.ExitOnLockContention {
0000000000000000000000000000000000000000;;				glog.Infof("watching for inotify events for: %v", s.LockFilePath)
0000000000000000000000000000000000000000;;				if err := watchForLockfileContention(s.LockFilePath, done); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set feature gates based on the value in KubeletConfiguration
0000000000000000000000000000000000000000;;		err = utilfeature.DefaultFeatureGate.Set(s.KubeletConfiguration.FeatureGates)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Register current configuration with /configz endpoint
0000000000000000000000000000000000000000;;		cfgz, cfgzErr := initConfigz(&s.KubeletConfiguration)
0000000000000000000000000000000000000000;;		if utilfeature.DefaultFeatureGate.Enabled(features.DynamicKubeletConfig) {
0000000000000000000000000000000000000000;;			// Look for config on the API server. If it exists, replace s.KubeletConfiguration
0000000000000000000000000000000000000000;;			// with it and continue. initKubeletConfigSync also starts the background thread that checks for new config.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Don't do dynamic Kubelet configuration in runonce mode
0000000000000000000000000000000000000000;;			if s.RunOnce == false {
0000000000000000000000000000000000000000;;				remoteKC, err := initKubeletConfigSync(s)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					// Update s (KubeletServer) with new config from API server
0000000000000000000000000000000000000000;;					s.KubeletConfiguration = *remoteKC
0000000000000000000000000000000000000000;;					// Ensure that /configz is up to date with the new config
0000000000000000000000000000000000000000;;					if cfgzErr != nil {
0000000000000000000000000000000000000000;;						glog.Errorf("was unable to register configz before due to %s, will not be able to set now", cfgzErr)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						setConfigz(cfgz, &s.KubeletConfiguration)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Update feature gates from the new config
0000000000000000000000000000000000000000;;					err = utilfeature.DefaultFeatureGate.Set(s.KubeletConfiguration.FeatureGates)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					glog.Errorf("failed to init dynamic Kubelet configuration sync: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Validate configuration.
0000000000000000000000000000000000000000;;		if err := validateConfig(s); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if kubeDeps == nil {
0000000000000000000000000000000000000000;;			kubeDeps, err = UnsecuredKubeletDeps(s)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if kubeDeps.Cloud == nil {
0000000000000000000000000000000000000000;;			if !cloudprovider.IsExternal(s.CloudProvider) && s.CloudProvider != componentconfigv1alpha1.AutoDetectCloudProvider {
0000000000000000000000000000000000000000;;				cloud, err := cloudprovider.InitCloudProvider(s.CloudProvider, s.CloudConfigFile)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if cloud == nil {
0000000000000000000000000000000000000000;;					glog.V(2).Infof("No cloud provider specified: %q from the config file: %q\n", s.CloudProvider, s.CloudConfigFile)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					glog.V(2).Infof("Successfully initialized cloud provider: %q from the config file: %q\n", s.CloudProvider, s.CloudConfigFile)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				kubeDeps.Cloud = cloud
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeName, err := getNodeName(kubeDeps.Cloud, nodeutil.GetHostname(s.HostnameOverride))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.BootstrapKubeconfig != "" {
0000000000000000000000000000000000000000;;			if err := bootstrapClientCert(s.KubeConfig.Value(), s.BootstrapKubeconfig, s.CertDirectory, nodeName); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// initialize clients if any of the clients are not provided
0000000000000000000000000000000000000000;;		if kubeDeps.KubeClient == nil || kubeDeps.ExternalKubeClient == nil || kubeDeps.EventClient == nil {
0000000000000000000000000000000000000000;;			var kubeClient clientset.Interface
0000000000000000000000000000000000000000;;			var eventClient v1core.EventsGetter
0000000000000000000000000000000000000000;;			var externalKubeClient clientgoclientset.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			clientConfig, err := CreateAPIServerClientConfig(s)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var clientCertificateManager certificate.Manager
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				if utilfeature.DefaultFeatureGate.Enabled(features.RotateKubeletClientCertificate) {
0000000000000000000000000000000000000000;;					clientCertificateManager, err = certificate.NewKubeletClientCertificateManager(s.CertDirectory, nodeName, clientConfig.CertData, clientConfig.KeyData, clientConfig.CertFile, clientConfig.KeyFile)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err := updateTransport(clientConfig, clientCertificateManager); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				kubeClient, err = clientset.NewForConfig(clientConfig)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Warningf("New kubeClient from clientConfig error: %v", err)
0000000000000000000000000000000000000000;;				} else if kubeClient.Certificates() != nil && clientCertificateManager != nil {
0000000000000000000000000000000000000000;;					glog.V(2).Info("Starting client certificate rotation.")
0000000000000000000000000000000000000000;;					clientCertificateManager.SetCertificateSigningRequestClient(kubeClient.Certificates().CertificateSigningRequests())
0000000000000000000000000000000000000000;;					clientCertificateManager.Start()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				externalKubeClient, err = clientgoclientset.NewForConfig(clientConfig)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Warningf("New kubeClient from clientConfig error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// make a separate client for events
0000000000000000000000000000000000000000;;				eventClientConfig := *clientConfig
0000000000000000000000000000000000000000;;				eventClientConfig.QPS = float32(s.EventRecordQPS)
0000000000000000000000000000000000000000;;				eventClientConfig.Burst = int(s.EventBurst)
0000000000000000000000000000000000000000;;				eventClient, err = clientgoclientset.NewForConfig(&eventClientConfig)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Warningf("Failed to create API Server client: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case s.RequireKubeConfig:
0000000000000000000000000000000000000000;;					return fmt.Errorf("invalid kubeconfig: %v", err)
0000000000000000000000000000000000000000;;				case standaloneMode:
0000000000000000000000000000000000000000;;					glog.Warningf("No API client: %v", err)
0000000000000000000000000000000000000000;;				case s.KubeConfig.Provided():
0000000000000000000000000000000000000000;;					glog.Warningf("Invalid kubeconfig: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			kubeDeps.KubeClient = kubeClient
0000000000000000000000000000000000000000;;			kubeDeps.ExternalKubeClient = externalKubeClient
0000000000000000000000000000000000000000;;			kubeDeps.EventClient = eventClient
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if kubeDeps.Auth == nil {
0000000000000000000000000000000000000000;;			auth, err := BuildAuth(nodeName, kubeDeps.ExternalKubeClient, s.KubeletConfiguration)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			kubeDeps.Auth = auth
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if kubeDeps.CAdvisorInterface == nil {
0000000000000000000000000000000000000000;;			kubeDeps.CAdvisorInterface, err = cadvisor.New(s.Address, uint(s.CAdvisorPort), s.ContainerRuntime, s.RootDirectory)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup event recorder if required.
0000000000000000000000000000000000000000;;		makeEventRecorder(&s.KubeletConfiguration, kubeDeps, nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if kubeDeps.ContainerManager == nil {
0000000000000000000000000000000000000000;;			if s.CgroupsPerQOS && s.CgroupRoot == "" {
0000000000000000000000000000000000000000;;				glog.Infof("--cgroups-per-qos enabled, but --cgroup-root was not specified.  defaulting to /")
0000000000000000000000000000000000000000;;				s.CgroupRoot = "/"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			kubeReserved, err := parseResourceList(s.KubeReserved)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			systemReserved, err := parseResourceList(s.SystemReserved)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var hardEvictionThresholds []evictionapi.Threshold
0000000000000000000000000000000000000000;;			// If the user requested to ignore eviction thresholds, then do not set valid values for hardEvictionThresholds here.
0000000000000000000000000000000000000000;;			if !s.ExperimentalNodeAllocatableIgnoreEvictionThreshold {
0000000000000000000000000000000000000000;;				hardEvictionThresholds, err = eviction.ParseThresholdConfig([]string{}, s.EvictionHard, "", "", "")
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			experimentalQOSReserved, err := cm.ParseQOSReserved(s.ExperimentalQOSReserved)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			kubeDeps.ContainerManager, err = cm.NewContainerManager(
0000000000000000000000000000000000000000;;				kubeDeps.Mounter,
0000000000000000000000000000000000000000;;				kubeDeps.CAdvisorInterface,
0000000000000000000000000000000000000000;;				cm.NodeConfig{
0000000000000000000000000000000000000000;;					RuntimeCgroupsName:    s.RuntimeCgroups,
0000000000000000000000000000000000000000;;					SystemCgroupsName:     s.SystemCgroups,
0000000000000000000000000000000000000000;;					KubeletCgroupsName:    s.KubeletCgroups,
0000000000000000000000000000000000000000;;					ContainerRuntime:      s.ContainerRuntime,
0000000000000000000000000000000000000000;;					CgroupsPerQOS:         s.CgroupsPerQOS,
0000000000000000000000000000000000000000;;					CgroupRoot:            s.CgroupRoot,
0000000000000000000000000000000000000000;;					CgroupDriver:          s.CgroupDriver,
0000000000000000000000000000000000000000;;					ProtectKernelDefaults: s.ProtectKernelDefaults,
0000000000000000000000000000000000000000;;					NodeAllocatableConfig: cm.NodeAllocatableConfig{
0000000000000000000000000000000000000000;;						KubeReservedCgroupName:   s.KubeReservedCgroup,
0000000000000000000000000000000000000000;;						SystemReservedCgroupName: s.SystemReservedCgroup,
0000000000000000000000000000000000000000;;						EnforceNodeAllocatable:   sets.NewString(s.EnforceNodeAllocatable...),
0000000000000000000000000000000000000000;;						KubeReserved:             kubeReserved,
0000000000000000000000000000000000000000;;						SystemReserved:           systemReserved,
0000000000000000000000000000000000000000;;						HardEvictionThresholds:   hardEvictionThresholds,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					ExperimentalQOSReserved: *experimentalQOSReserved,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				s.ExperimentalFailSwapOn,
0000000000000000000000000000000000000000;;				kubeDeps.Recorder)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := checkPermissions(); err != nil {
0000000000000000000000000000000000000000;;			glog.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilruntime.ReallyCrash = s.ReallyCrashForTesting
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rand.Seed(time.Now().UTC().UnixNano())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(vmarmol): Do this through container config.
0000000000000000000000000000000000000000;;		oomAdjuster := kubeDeps.OOMAdjuster
0000000000000000000000000000000000000000;;		if err := oomAdjuster.ApplyOOMScoreAdj(0, int(s.OOMScoreAdj)); err != nil {
0000000000000000000000000000000000000000;;			glog.Warning(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := RunKubelet(&s.KubeletFlags, &s.KubeletConfiguration, kubeDeps, s.RunOnce, standaloneMode); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.HealthzPort > 0 {
0000000000000000000000000000000000000000;;			healthz.DefaultHealthz()
0000000000000000000000000000000000000000;;			go wait.Until(func() {
0000000000000000000000000000000000000000;;				err := http.ListenAndServe(net.JoinHostPort(s.HealthzBindAddress, strconv.Itoa(int(s.HealthzPort))), nil)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Starting health server failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}, 5*time.Second, wait.NeverStop)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.RunOnce {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-done
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updateTransport(clientConfig *restclient.Config, clientCertificateManager certificate.Manager) error {
0000000000000000000000000000000000000000;;		if clientConfig.Transport != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("there is already a transport configured")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tlsConfig, err := restclient.TLSConfigFor(clientConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to configure TLS for the rest client: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tlsConfig == nil {
0000000000000000000000000000000000000000;;			tlsConfig = &tls.Config{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tlsConfig.Certificates = nil
0000000000000000000000000000000000000000;;		tlsConfig.GetClientCertificate = func(requestInfo *tls.CertificateRequestInfo) (*tls.Certificate, error) {
0000000000000000000000000000000000000000;;			cert := clientCertificateManager.Current()
0000000000000000000000000000000000000000;;			if cert == nil {
0000000000000000000000000000000000000000;;				return &tls.Certificate{Certificate: nil}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return cert, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clientConfig.Transport = utilnet.SetTransportDefaults(&http.Transport{
0000000000000000000000000000000000000000;;			Proxy:               http.ProxyFromEnvironment,
0000000000000000000000000000000000000000;;			TLSHandshakeTimeout: 10 * time.Second,
0000000000000000000000000000000000000000;;			TLSClientConfig:     tlsConfig,
0000000000000000000000000000000000000000;;			MaxIdleConnsPerHost: 25,
0000000000000000000000000000000000000000;;			Dial: (&net.Dialer{
0000000000000000000000000000000000000000;;				Timeout:   30 * time.Second,
0000000000000000000000000000000000000000;;				KeepAlive: 30 * time.Second,
0000000000000000000000000000000000000000;;			}).Dial,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		clientConfig.CertData = nil
0000000000000000000000000000000000000000;;		clientConfig.KeyData = nil
0000000000000000000000000000000000000000;;		clientConfig.CertFile = ""
0000000000000000000000000000000000000000;;		clientConfig.KeyFile = ""
0000000000000000000000000000000000000000;;		clientConfig.CAData = nil
0000000000000000000000000000000000000000;;		clientConfig.CAFile = ""
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getNodeName returns the node name according to the cloud provider
0000000000000000000000000000000000000000;;	// if cloud provider is specified. Otherwise, returns the hostname of the node.
0000000000000000000000000000000000000000;;	func getNodeName(cloud cloudprovider.Interface, hostname string) (types.NodeName, error) {
0000000000000000000000000000000000000000;;		if cloud == nil {
0000000000000000000000000000000000000000;;			return types.NodeName(hostname), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instances, ok := cloud.Instances()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to get instances from cloud provider")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeName, err := instances.CurrentNodeName(hostname)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("error fetching current node name from cloud provider: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("cloud provider determined current node name to be %s", nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nodeName, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InitializeTLS checks for a configured TLSCertFile and TLSPrivateKeyFile: if unspecified a new self-signed
0000000000000000000000000000000000000000;;	// certificate and key file are generated. Returns a configured server.TLSOptions object.
0000000000000000000000000000000000000000;;	func InitializeTLS(kf *options.KubeletFlags, kc *componentconfig.KubeletConfiguration) (*server.TLSOptions, error) {
0000000000000000000000000000000000000000;;		if !utilfeature.DefaultFeatureGate.Enabled(features.RotateKubeletServerCertificate) && kc.TLSCertFile == "" && kc.TLSPrivateKeyFile == "" {
0000000000000000000000000000000000000000;;			kc.TLSCertFile = path.Join(kc.CertDirectory, "kubelet.crt")
0000000000000000000000000000000000000000;;			kc.TLSPrivateKeyFile = path.Join(kc.CertDirectory, "kubelet.key")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			canReadCertAndKey, err := certutil.CanReadCertAndKey(kc.TLSCertFile, kc.TLSPrivateKeyFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !canReadCertAndKey {
0000000000000000000000000000000000000000;;				cert, key, err := certutil.GenerateSelfSignedCertKey(nodeutil.GetHostname(kf.HostnameOverride), nil, nil)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("unable to generate self signed cert: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := certutil.WriteCert(kc.TLSCertFile, cert); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := certutil.WriteKey(kc.TLSPrivateKeyFile, key); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Using self-signed cert (%s, %s)", kc.TLSCertFile, kc.TLSPrivateKeyFile)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tlsOptions := &server.TLSOptions{
0000000000000000000000000000000000000000;;			Config: &tls.Config{
0000000000000000000000000000000000000000;;				// Can't use SSLv3 because of POODLE and BEAST
0000000000000000000000000000000000000000;;				// Can't use TLSv1.0 because of POODLE and BEAST using CBC cipher
0000000000000000000000000000000000000000;;				// Can't use TLSv1.1 because of RC4 cipher usage
0000000000000000000000000000000000000000;;				MinVersion: tls.VersionTLS12,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			CertFile: kc.TLSCertFile,
0000000000000000000000000000000000000000;;			KeyFile:  kc.TLSPrivateKeyFile,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(kc.Authentication.X509.ClientCAFile) > 0 {
0000000000000000000000000000000000000000;;			clientCAs, err := certutil.NewPool(kc.Authentication.X509.ClientCAFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unable to load client CA file %s: %v", kc.Authentication.X509.ClientCAFile, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Specify allowed CAs for client certificates
0000000000000000000000000000000000000000;;			tlsOptions.Config.ClientCAs = clientCAs
0000000000000000000000000000000000000000;;			// Populate PeerCertificates in requests, but don't reject connections without verified certificates
0000000000000000000000000000000000000000;;			tlsOptions.Config.ClientAuth = tls.RequestClientCert
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tlsOptions, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func kubeconfigClientConfig(s *options.KubeletServer) (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		if s.RequireKubeConfig {
0000000000000000000000000000000000000000;;			// Ignores the values of s.APIServerList
0000000000000000000000000000000000000000;;			return clientcmd.NewNonInteractiveDeferredLoadingClientConfig(
0000000000000000000000000000000000000000;;				&clientcmd.ClientConfigLoadingRules{ExplicitPath: s.KubeConfig.Value()},
0000000000000000000000000000000000000000;;				&clientcmd.ConfigOverrides{},
0000000000000000000000000000000000000000;;			).ClientConfig()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clientcmd.NewNonInteractiveDeferredLoadingClientConfig(
0000000000000000000000000000000000000000;;			&clientcmd.ClientConfigLoadingRules{ExplicitPath: s.KubeConfig.Value()},
0000000000000000000000000000000000000000;;			&clientcmd.ConfigOverrides{ClusterInfo: clientcmdapi.Cluster{Server: s.APIServerList[0]}},
0000000000000000000000000000000000000000;;		).ClientConfig()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createClientConfig creates a client configuration from the command line
0000000000000000000000000000000000000000;;	// arguments. If --kubeconfig is explicitly set, it will be used. If it is
0000000000000000000000000000000000000000;;	// not set, we attempt to load the default kubeconfig file, and if we cannot,
0000000000000000000000000000000000000000;;	// we fall back to the default client with no auth - this fallback does not, in
0000000000000000000000000000000000000000;;	// and of itself, constitute an error.
0000000000000000000000000000000000000000;;	func createClientConfig(s *options.KubeletServer) (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		if s.RequireKubeConfig {
0000000000000000000000000000000000000000;;			return kubeconfigClientConfig(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: handle a new --standalone flag that bypasses kubeconfig loading and returns no error.
0000000000000000000000000000000000000000;;		// DEPRECATED: all subsequent code is deprecated
0000000000000000000000000000000000000000;;		if len(s.APIServerList) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no api servers specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: adapt Kube client to support LB over several servers
0000000000000000000000000000000000000000;;		if len(s.APIServerList) > 1 {
0000000000000000000000000000000000000000;;			glog.Infof("Multiple api servers specified.  Picking first one")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.KubeConfig.Provided() {
0000000000000000000000000000000000000000;;			return kubeconfigClientConfig(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If KubeConfig was not provided, try to load the default file, then fall back
0000000000000000000000000000000000000000;;		// to a default auth config.
0000000000000000000000000000000000000000;;		clientConfig, err := kubeconfigClientConfig(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Could not load kubeconfig file %s: %v. Using default client config instead.", s.KubeConfig, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			authInfo := &clientauth.Info{}
0000000000000000000000000000000000000000;;			authConfig, err := authInfo.MergeWithConfig(restclient.Config{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			authConfig.Host = s.APIServerList[0]
0000000000000000000000000000000000000000;;			clientConfig = &authConfig
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clientConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateAPIServerClientConfig generates a client.Config from command line flags,
0000000000000000000000000000000000000000;;	// including api-server-list, via createClientConfig and then injects chaos into
0000000000000000000000000000000000000000;;	// the configuration via addChaosToClientConfig. This func is exported to support
0000000000000000000000000000000000000000;;	// integration with third party kubelet extensions (e.g. kubernetes-mesos).
0000000000000000000000000000000000000000;;	func CreateAPIServerClientConfig(s *options.KubeletServer) (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		clientConfig, err := createClientConfig(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientConfig.ContentType = s.ContentType
0000000000000000000000000000000000000000;;		// Override kubeconfig qps/burst settings from flags
0000000000000000000000000000000000000000;;		clientConfig.QPS = float32(s.KubeAPIQPS)
0000000000000000000000000000000000000000;;		clientConfig.Burst = int(s.KubeAPIBurst)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addChaosToClientConfig(s, clientConfig)
0000000000000000000000000000000000000000;;		return clientConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addChaosToClientConfig injects random errors into client connections if configured.
0000000000000000000000000000000000000000;;	func addChaosToClientConfig(s *options.KubeletServer, config *restclient.Config) {
0000000000000000000000000000000000000000;;		if s.ChaosChance != 0.0 {
0000000000000000000000000000000000000000;;			config.WrapTransport = func(rt http.RoundTripper) http.RoundTripper {
0000000000000000000000000000000000000000;;				seed := chaosclient.NewSeed(1)
0000000000000000000000000000000000000000;;				// TODO: introduce a standard chaos package with more tunables - this is just a proof of concept
0000000000000000000000000000000000000000;;				// TODO: introduce random latency and stalls
0000000000000000000000000000000000000000;;				return chaosclient.NewChaosRoundTripper(rt, chaosclient.LogChaos, seed.P(s.ChaosChance, chaosclient.ErrSimulatedConnectionResetByPeer))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunKubelet is responsible for setting up and running a kubelet.  It is used in three different applications:
0000000000000000000000000000000000000000;;	//   1 Integration tests
0000000000000000000000000000000000000000;;	//   2 Kubelet binary
0000000000000000000000000000000000000000;;	//   3 Standalone 'kubernetes' binary
0000000000000000000000000000000000000000;;	// Eventually, #2 will be replaced with instances of #3
0000000000000000000000000000000000000000;;	func RunKubelet(kubeFlags *options.KubeletFlags, kubeCfg *componentconfig.KubeletConfiguration, kubeDeps *kubelet.KubeletDeps, runOnce bool, standaloneMode bool) error {
0000000000000000000000000000000000000000;;		hostname := nodeutil.GetHostname(kubeFlags.HostnameOverride)
0000000000000000000000000000000000000000;;		// Query the cloud provider for our node name, default to hostname if kcfg.Cloud == nil
0000000000000000000000000000000000000000;;		nodeName, err := getNodeName(kubeDeps.Cloud, hostname)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Setup event recorder if required.
0000000000000000000000000000000000000000;;		makeEventRecorder(kubeCfg, kubeDeps, nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(mtaufen): I moved the validation of these fields here, from UnsecuredKubeletConfig,
0000000000000000000000000000000000000000;;		//                so that I could remove the associated fields from KubeletConfig. I would
0000000000000000000000000000000000000000;;		//                prefer this to be done as part of an independent validation step on the
0000000000000000000000000000000000000000;;		//                KubeletConfiguration. But as far as I can tell, we don't have an explicit
0000000000000000000000000000000000000000;;		//                place for validation of the KubeletConfiguration yet.
0000000000000000000000000000000000000000;;		hostNetworkSources, err := kubetypes.GetValidatedSources(kubeCfg.HostNetworkSources)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostPIDSources, err := kubetypes.GetValidatedSources(kubeCfg.HostPIDSources)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostIPCSources, err := kubetypes.GetValidatedSources(kubeCfg.HostIPCSources)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		privilegedSources := capabilities.PrivilegedSources{
0000000000000000000000000000000000000000;;			HostNetworkSources: hostNetworkSources,
0000000000000000000000000000000000000000;;			HostPIDSources:     hostPIDSources,
0000000000000000000000000000000000000000;;			HostIPCSources:     hostIPCSources,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		capabilities.Setup(kubeCfg.AllowPrivileged, privilegedSources, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		credentialprovider.SetPreferredDockercfgPath(kubeCfg.RootDirectory)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Using root directory: %v", kubeCfg.RootDirectory)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		builder := kubeDeps.Builder
0000000000000000000000000000000000000000;;		if builder == nil {
0000000000000000000000000000000000000000;;			builder = CreateAndInitKubelet
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if kubeDeps.OSInterface == nil {
0000000000000000000000000000000000000000;;			kubeDeps.OSInterface = kubecontainer.RealOS{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		k, err := builder(kubeCfg, kubeDeps, &kubeFlags.ContainerRuntimeOptions, standaloneMode, kubeFlags.HostnameOverride, kubeFlags.NodeIP, kubeFlags.ProviderID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to create kubelet: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NewMainKubelet should have set up a pod source config if one didn't exist
0000000000000000000000000000000000000000;;		// when the builder was run. This is just a precaution.
0000000000000000000000000000000000000000;;		if kubeDeps.PodConfig == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to create kubelet, pod source config was nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podCfg := kubeDeps.PodConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rlimit.RlimitNumFiles(uint64(kubeCfg.MaxOpenFiles))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// process pods and exit.
0000000000000000000000000000000000000000;;		if runOnce {
0000000000000000000000000000000000000000;;			if _, err := k.RunOnce(podCfg.Updates()); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("runonce failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Infof("Started kubelet %s as runonce", version.Get().String())
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			startKubelet(k, podCfg, kubeCfg, kubeDeps)
0000000000000000000000000000000000000000;;			glog.Infof("Started kubelet %s", version.Get().String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startKubelet(k kubelet.KubeletBootstrap, podCfg *config.PodConfig, kubeCfg *componentconfig.KubeletConfiguration, kubeDeps *kubelet.KubeletDeps) {
0000000000000000000000000000000000000000;;		// start the kubelet
0000000000000000000000000000000000000000;;		go wait.Until(func() { k.Run(podCfg.Updates()) }, 0, wait.NeverStop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// start the kubelet server
0000000000000000000000000000000000000000;;		if kubeCfg.EnableServer {
0000000000000000000000000000000000000000;;			go wait.Until(func() {
0000000000000000000000000000000000000000;;				k.ListenAndServe(net.ParseIP(kubeCfg.Address), uint(kubeCfg.Port), kubeDeps.TLSOptions, kubeDeps.Auth, kubeCfg.EnableDebuggingHandlers, kubeCfg.EnableContentionProfiling)
0000000000000000000000000000000000000000;;			}, 0, wait.NeverStop)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if kubeCfg.ReadOnlyPort > 0 {
0000000000000000000000000000000000000000;;			go wait.Until(func() {
0000000000000000000000000000000000000000;;				k.ListenAndServeReadOnly(net.ParseIP(kubeCfg.Address), uint(kubeCfg.ReadOnlyPort))
0000000000000000000000000000000000000000;;			}, 0, wait.NeverStop)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreateAndInitKubelet(kubeCfg *componentconfig.KubeletConfiguration, kubeDeps *kubelet.KubeletDeps, crOptions *options.ContainerRuntimeOptions, standaloneMode bool, hostnameOverride, nodeIP, providerID string) (k kubelet.KubeletBootstrap, err error) {
0000000000000000000000000000000000000000;;		// TODO: block until all sources have delivered at least one update to the channel, or break the sync loop
0000000000000000000000000000000000000000;;		// up into "per source" synchronizations
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		k, err = kubelet.NewMainKubelet(kubeCfg, kubeDeps, crOptions, standaloneMode, hostnameOverride, nodeIP, providerID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		k.BirthCry()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		k.StartGarbageCollection()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return k, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseResourceList parses the given configuration map into an API
0000000000000000000000000000000000000000;;	// ResourceList or returns an error.
0000000000000000000000000000000000000000;;	func parseResourceList(m componentconfig.ConfigurationMap) (v1.ResourceList, error) {
0000000000000000000000000000000000000000;;		if len(m) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rl := make(v1.ResourceList)
0000000000000000000000000000000000000000;;		for k, v := range m {
0000000000000000000000000000000000000000;;			switch v1.ResourceName(k) {
0000000000000000000000000000000000000000;;			// CPU, memory and local storage resources are supported.
0000000000000000000000000000000000000000;;			case v1.ResourceCPU, v1.ResourceMemory, v1.ResourceStorage:
0000000000000000000000000000000000000000;;				q, err := resource.ParseQuantity(v)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if q.Sign() == -1 {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("resource quantity for %q cannot be negative: %v", k, v)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rl[v1.ResourceName(k)] = q
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("cannot reserve %q resource", k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rl, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunDockershim only starts the dockershim in current process. This is only used for cri validate testing purpose
0000000000000000000000000000000000000000;;	// TODO(random-liu): Move this to a separate binary.
0000000000000000000000000000000000000000;;	func RunDockershim(c *componentconfig.KubeletConfiguration, r *options.ContainerRuntimeOptions) error {
0000000000000000000000000000000000000000;;		// Create docker client.
0000000000000000000000000000000000000000;;		dockerClient := libdocker.ConnectToDockerOrDie(r.DockerEndpoint, c.RuntimeRequestTimeout.Duration,
0000000000000000000000000000000000000000;;			r.ImagePullProgressDeadline.Duration)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Initialize network plugin settings.
0000000000000000000000000000000000000000;;		binDir := r.CNIBinDir
0000000000000000000000000000000000000000;;		if binDir == "" {
0000000000000000000000000000000000000000;;			binDir = r.NetworkPluginDir
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nh := &kubelet.NoOpLegacyHost{}
0000000000000000000000000000000000000000;;		pluginSettings := dockershim.NetworkPluginSettings{
0000000000000000000000000000000000000000;;			HairpinMode:       componentconfig.HairpinMode(c.HairpinMode),
0000000000000000000000000000000000000000;;			NonMasqueradeCIDR: c.NonMasqueradeCIDR,
0000000000000000000000000000000000000000;;			PluginName:        r.NetworkPluginName,
0000000000000000000000000000000000000000;;			PluginConfDir:     r.CNIConfDir,
0000000000000000000000000000000000000000;;			PluginBinDir:      binDir,
0000000000000000000000000000000000000000;;			MTU:               int(r.NetworkPluginMTU),
0000000000000000000000000000000000000000;;			LegacyRuntimeHost: nh,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Initialize streaming configuration. (Not using TLS now)
0000000000000000000000000000000000000000;;		streamingConfig := &streaming.Config{
0000000000000000000000000000000000000000;;			// Use a relative redirect (no scheme or host).
0000000000000000000000000000000000000000;;			BaseURL:                         &url.URL{Path: "/cri/"},
0000000000000000000000000000000000000000;;			StreamIdleTimeout:               c.StreamingConnectionIdleTimeout.Duration,
0000000000000000000000000000000000000000;;			StreamCreationTimeout:           streaming.DefaultConfig.StreamCreationTimeout,
0000000000000000000000000000000000000000;;			SupportedRemoteCommandProtocols: streaming.DefaultConfig.SupportedRemoteCommandProtocols,
0000000000000000000000000000000000000000;;			SupportedPortForwardProtocols:   streaming.DefaultConfig.SupportedPortForwardProtocols,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ds, err := dockershim.NewDockerService(dockerClient, c.SeccompProfileRoot, r.PodSandboxImage,
0000000000000000000000000000000000000000;;			streamingConfig, &pluginSettings, c.RuntimeCgroups, c.CgroupDriver, r.DockerExecHandlerName, r.DockershimRootDirectory,
0000000000000000000000000000000000000000;;			r.DockerDisableSharedPID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ds.Start(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Starting the GRPC server for the docker CRI shim.")
0000000000000000000000000000000000000000;;		server := dockerremote.NewDockerServer(c.RemoteRuntimeEndpoint, ds)
0000000000000000000000000000000000000000;;		if err := server.Start(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start the streaming server
0000000000000000000000000000000000000000;;		addr := net.JoinHostPort(c.Address, strconv.Itoa(int(c.Port)))
0000000000000000000000000000000000000000;;		return http.ListenAndServe(addr, ds)
0000000000000000000000000000000000000000;;	}
