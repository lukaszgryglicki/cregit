0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
3159cdfc2b9c56d4333d8da215757a1ae323156f;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package app
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		_ "net/http/pprof"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		certificates "k8s.io/client-go/kubernetes/typed/certificates/v1beta1"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		certutil "k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/csr"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		defaultKubeletClientCertificateFile = "kubelet-client.crt"
0000000000000000000000000000000000000000;;		defaultKubeletClientKeyFile         = "kubelet-client.key"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bootstrapClientCert requests a client cert for kubelet if the kubeconfigPath file does not exist.
0000000000000000000000000000000000000000;;	// The kubeconfig at bootstrapPath is used to request a client certificate from the API server.
0000000000000000000000000000000000000000;;	// On success, a kubeconfig file referencing the generated key and obtained certificate is written to kubeconfigPath.
0000000000000000000000000000000000000000;;	// The certificate and key file are stored in certDir.
0000000000000000000000000000000000000000;;	func bootstrapClientCert(kubeconfigPath string, bootstrapPath string, certDir string, nodeName types.NodeName) error {
0000000000000000000000000000000000000000;;		// Short-circuit if the kubeconfig file already exists.
0000000000000000000000000000000000000000;;		// TODO: inspect the kubeconfig, ensure a rest client can be built from it, verify client cert expiration, etc.
0000000000000000000000000000000000000000;;		_, err := os.Stat(kubeconfigPath)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Kubeconfig %s exists, skipping bootstrap", kubeconfigPath)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			glog.Errorf("Error reading kubeconfig %s, skipping bootstrap: %v", kubeconfigPath, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Info("Using bootstrap kubeconfig to generate TLS client cert, key and kubeconfig file")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bootstrapClientConfig, err := loadRESTClientConfig(bootstrapPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to load bootstrap kubeconfig: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bootstrapClient, err := certificates.NewForConfig(bootstrapClientConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to create certificates signing request client: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		success := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the private key.
0000000000000000000000000000000000000000;;		keyPath, err := filepath.Abs(filepath.Join(certDir, defaultKubeletClientKeyFile))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to build bootstrap key path: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		keyData, _, err := certutil.LoadOrGenerateKeyFile(keyPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the cert.
0000000000000000000000000000000000000000;;		certPath, err := filepath.Abs(filepath.Join(certDir, defaultKubeletClientCertificateFile))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to build bootstrap client cert path: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		certData, err := csr.RequestNodeCertificate(bootstrapClient.CertificateSigningRequests(), keyData, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := certutil.WriteCert(certPath, certData); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if !success {
0000000000000000000000000000000000000000;;				if err := os.Remove(certPath); err != nil {
0000000000000000000000000000000000000000;;					glog.Warningf("Cannot clean up the cert file %q: %v", certPath, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the CA data from the bootstrap client config.
0000000000000000000000000000000000000000;;		caFile, caData := bootstrapClientConfig.CAFile, []byte{}
0000000000000000000000000000000000000000;;		if len(caFile) == 0 {
0000000000000000000000000000000000000000;;			caData = bootstrapClientConfig.CAData
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Build resulting kubeconfig.
0000000000000000000000000000000000000000;;		kubeconfigData := clientcmdapi.Config{
0000000000000000000000000000000000000000;;			// Define a cluster stanza based on the bootstrap kubeconfig.
0000000000000000000000000000000000000000;;			Clusters: map[string]*clientcmdapi.Cluster{"default-cluster": {
0000000000000000000000000000000000000000;;				Server:                   bootstrapClientConfig.Host,
0000000000000000000000000000000000000000;;				InsecureSkipTLSVerify:    bootstrapClientConfig.Insecure,
0000000000000000000000000000000000000000;;				CertificateAuthority:     caFile,
0000000000000000000000000000000000000000;;				CertificateAuthorityData: caData,
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			// Define auth based on the obtained client cert.
0000000000000000000000000000000000000000;;			AuthInfos: map[string]*clientcmdapi.AuthInfo{"default-auth": {
0000000000000000000000000000000000000000;;				ClientCertificate: certPath,
0000000000000000000000000000000000000000;;				ClientKey:         keyPath,
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			// Define a context that connects the auth info and cluster, and set it as the default
0000000000000000000000000000000000000000;;			Contexts: map[string]*clientcmdapi.Context{"default-context": {
0000000000000000000000000000000000000000;;				Cluster:   "default-cluster",
0000000000000000000000000000000000000000;;				AuthInfo:  "default-auth",
0000000000000000000000000000000000000000;;				Namespace: "default",
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			CurrentContext: "default-context",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Marshal to disk
0000000000000000000000000000000000000000;;		if err := clientcmd.WriteToFile(kubeconfigData, kubeconfigPath); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		success = true
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func loadRESTClientConfig(kubeconfig string) (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		// Load structured kubeconfig data from the given path.
0000000000000000000000000000000000000000;;		loader := &clientcmd.ClientConfigLoadingRules{ExplicitPath: kubeconfig}
0000000000000000000000000000000000000000;;		loadedConfig, err := loader.Load()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Flatten the loaded data to a particular restclient.Config based on the current context.
0000000000000000000000000000000000000000;;		return clientcmd.NewNonInteractiveClientConfig(
0000000000000000000000000000000000000000;;			*loadedConfig,
0000000000000000000000000000000000000000;;			loadedConfig.CurrentContext,
0000000000000000000000000000000000000000;;			&clientcmd.ConfigOverrides{},
0000000000000000000000000000000000000000;;			loader,
0000000000000000000000000000000000000000;;		).ClientConfig()
0000000000000000000000000000000000000000;;	}
