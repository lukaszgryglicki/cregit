0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
17bd98a01abc237f05e432a57a5dd9e8409f812a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package app
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/authenticator"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/authenticatorfactory"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizerfactory"
0000000000000000000000000000000000000000;;		clientset "k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		authenticationclient "k8s.io/client-go/kubernetes/typed/authentication/v1beta1"
0000000000000000000000000000000000000000;;		authorizationclient "k8s.io/client-go/kubernetes/typed/authorization/v1beta1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/server"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildAuth creates an authenticator, an authorizer, and a matching authorizer attributes getter compatible with the kubelet's needs
0000000000000000000000000000000000000000;;	func BuildAuth(nodeName types.NodeName, client clientset.Interface, config componentconfig.KubeletConfiguration) (server.AuthInterface, error) {
0000000000000000000000000000000000000000;;		// Get clients, if provided
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			tokenClient authenticationclient.TokenReviewInterface
0000000000000000000000000000000000000000;;			sarClient   authorizationclient.SubjectAccessReviewInterface
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if client != nil && !reflect.ValueOf(client).IsNil() {
0000000000000000000000000000000000000000;;			tokenClient = client.AuthenticationV1beta1().TokenReviews()
0000000000000000000000000000000000000000;;			sarClient = client.AuthorizationV1beta1().SubjectAccessReviews()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authenticator, err := BuildAuthn(tokenClient, config.Authentication)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attributes := server.NewNodeAuthorizerAttributesGetter(nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authorizer, err := BuildAuthz(sarClient, config.Authorization)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return server.NewKubeletAuth(authenticator, attributes, authorizer), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildAuthn creates an authenticator compatible with the kubelet's needs
0000000000000000000000000000000000000000;;	func BuildAuthn(client authenticationclient.TokenReviewInterface, authn componentconfig.KubeletAuthentication) (authenticator.Request, error) {
0000000000000000000000000000000000000000;;		authenticatorConfig := authenticatorfactory.DelegatingAuthenticatorConfig{
0000000000000000000000000000000000000000;;			Anonymous:    authn.Anonymous.Enabled,
0000000000000000000000000000000000000000;;			CacheTTL:     authn.Webhook.CacheTTL.Duration,
0000000000000000000000000000000000000000;;			ClientCAFile: authn.X509.ClientCAFile,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if authn.Webhook.Enabled {
0000000000000000000000000000000000000000;;			if client == nil {
0000000000000000000000000000000000000000;;				return nil, errors.New("no client provided, cannot use webhook authentication")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			authenticatorConfig.TokenAccessReviewClient = client
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authenticator, _, err := authenticatorConfig.New()
0000000000000000000000000000000000000000;;		return authenticator, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildAuthz creates an authorizer compatible with the kubelet's needs
0000000000000000000000000000000000000000;;	func BuildAuthz(client authorizationclient.SubjectAccessReviewInterface, authz componentconfig.KubeletAuthorization) (authorizer.Authorizer, error) {
0000000000000000000000000000000000000000;;		switch authz.Mode {
0000000000000000000000000000000000000000;;		case componentconfig.KubeletAuthorizationModeAlwaysAllow:
0000000000000000000000000000000000000000;;			return authorizerfactory.NewAlwaysAllowAuthorizer(), nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case componentconfig.KubeletAuthorizationModeWebhook:
0000000000000000000000000000000000000000;;			if client == nil {
0000000000000000000000000000000000000000;;				return nil, errors.New("no client provided, cannot use webhook authorization")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			authorizerConfig := authorizerfactory.DelegatingAuthorizerConfig{
0000000000000000000000000000000000000000;;				SubjectAccessReviewClient: client,
0000000000000000000000000000000000000000;;				AllowCacheTTL:             authz.Webhook.CacheAuthorizedTTL.Duration,
0000000000000000000000000000000000000000;;				DenyCacheTTL:              authz.Webhook.CacheUnauthorizedTTL.Duration,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return authorizerConfig.New()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case "":
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("No authorization mode specified")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unknown authorization mode %s", authz.Mode)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
