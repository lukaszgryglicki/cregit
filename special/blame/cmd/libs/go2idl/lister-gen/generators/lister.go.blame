0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
4c4e1113cfc9d090fb8aa8d36466830e2e48a8cc;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package generators
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/args"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;		clientgentypes "k8s.io/kubernetes/cmd/libs/go2idl/client-gen/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameSystems returns the name system used by the generators in this package.
0000000000000000000000000000000000000000;;	func NameSystems() namer.NameSystems {
0000000000000000000000000000000000000000;;		pluralExceptions := map[string]string{
0000000000000000000000000000000000000000;;			"Endpoints": "Endpoints",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"public":             namer.NewPublicNamer(0),
0000000000000000000000000000000000000000;;			"private":            namer.NewPrivateNamer(0),
0000000000000000000000000000000000000000;;			"raw":                namer.NewRawNamer("", nil),
0000000000000000000000000000000000000000;;			"publicPlural":       namer.NewPublicPluralNamer(pluralExceptions),
0000000000000000000000000000000000000000;;			"allLowercasePlural": namer.NewAllLowercasePluralNamer(pluralExceptions),
0000000000000000000000000000000000000000;;			"lowercaseSingular":  &lowercaseSingularNamer{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lowercaseSingularNamer implements Namer
0000000000000000000000000000000000000000;;	type lowercaseSingularNamer struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name returns t's name in all lowercase.
0000000000000000000000000000000000000000;;	func (n *lowercaseSingularNamer) Name(t *types.Type) string {
0000000000000000000000000000000000000000;;		return strings.ToLower(t.Name.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultNameSystem returns the default name system for ordering the types to be
0000000000000000000000000000000000000000;;	// processed by the generators in this package.
0000000000000000000000000000000000000000;;	func DefaultNameSystem() string {
0000000000000000000000000000000000000000;;		return "public"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generatedBy returns information about the arguments used to invoke
0000000000000000000000000000000000000000;;	// lister-gen.
0000000000000000000000000000000000000000;;	func generatedBy() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("\n// This file was automatically generated by lister-gen\n\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Packages makes the client package definition.
0000000000000000000000000000000000000000;;	func Packages(context *generator.Context, arguments *args.GeneratorArgs) generator.Packages {
0000000000000000000000000000000000000000;;		boilerplate, err := arguments.LoadGoBoilerplate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed loading boilerplate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		boilerplate = append(boilerplate, []byte(generatedBy())...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var packageList generator.Packages
0000000000000000000000000000000000000000;;		for _, inputDir := range arguments.InputDirs {
0000000000000000000000000000000000000000;;			p := context.Universe.Package(inputDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			objectMeta, internal, err := objectMetaForPackage(p)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if objectMeta == nil {
0000000000000000000000000000000000000000;;				// no types in this package had genclient
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var gv clientgentypes.GroupVersion
0000000000000000000000000000000000000000;;			var internalGVPkg string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if internal {
0000000000000000000000000000000000000000;;				lastSlash := strings.LastIndex(p.Path, "/")
0000000000000000000000000000000000000000;;				if lastSlash == -1 {
0000000000000000000000000000000000000000;;					glog.Fatalf("error constructing internal group version for package %q", p.Path)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				gv.Group = clientgentypes.Group(p.Path[lastSlash+1:])
0000000000000000000000000000000000000000;;				internalGVPkg = p.Path
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				parts := strings.Split(p.Path, "/")
0000000000000000000000000000000000000000;;				gv.Group = clientgentypes.Group(parts[len(parts)-2])
0000000000000000000000000000000000000000;;				gv.Version = clientgentypes.Version(parts[len(parts)-1])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				internalGVPkg = strings.Join(parts[0:len(parts)-1], "/")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If there's a comment of the form "// +groupName=somegroup" or
0000000000000000000000000000000000000000;;			// "// +groupName=somegroup.foo.bar.io", use the first field (somegroup) as the name of the
0000000000000000000000000000000000000000;;			// group when generating.
0000000000000000000000000000000000000000;;			if override := types.ExtractCommentTags("+", p.DocComments)["groupName"]; override != nil {
0000000000000000000000000000000000000000;;				gv.Group = clientgentypes.Group(strings.SplitN(override[0], ".", 2)[0])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var typesToGenerate []*types.Type
0000000000000000000000000000000000000000;;			for _, t := range p.Types {
0000000000000000000000000000000000000000;;				// filter out types which dont have genclient=true.
0000000000000000000000000000000000000000;;				if extractBoolTagOrDie("genclient", t.SecondClosestCommentLines) == false {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				typesToGenerate = append(typesToGenerate, t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			orderer := namer.Orderer{Namer: namer.NewPrivateNamer(0)}
0000000000000000000000000000000000000000;;			typesToGenerate = orderer.OrderTypes(typesToGenerate)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			packagePath := filepath.Join(arguments.OutputPackagePath, strings.ToLower(gv.Group.NonEmpty()), strings.ToLower(gv.Version.NonEmpty()))
0000000000000000000000000000000000000000;;			packageList = append(packageList, &generator.DefaultPackage{
0000000000000000000000000000000000000000;;				PackageName: strings.ToLower(gv.Version.NonEmpty()),
0000000000000000000000000000000000000000;;				PackagePath: packagePath,
0000000000000000000000000000000000000000;;				HeaderText:  boilerplate,
0000000000000000000000000000000000000000;;				GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
0000000000000000000000000000000000000000;;					generators = append(generators, &expansionGenerator{
0000000000000000000000000000000000000000;;						DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;							OptionalName: "expansion_generated",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						packagePath: filepath.Join(arguments.OutputBase, packagePath),
0000000000000000000000000000000000000000;;						types:       typesToGenerate,
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					for _, t := range typesToGenerate {
0000000000000000000000000000000000000000;;						generators = append(generators, &listerGenerator{
0000000000000000000000000000000000000000;;							DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;								OptionalName: strings.ToLower(t.Name.Name),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							outputPackage:  arguments.OutputPackagePath,
0000000000000000000000000000000000000000;;							groupVersion:   gv,
0000000000000000000000000000000000000000;;							internalGVPkg:  internalGVPkg,
0000000000000000000000000000000000000000;;							typeToGenerate: t,
0000000000000000000000000000000000000000;;							imports:        generator.NewImportTracker(),
0000000000000000000000000000000000000000;;							objectMeta:     objectMeta,
0000000000000000000000000000000000000000;;						})
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return generators
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				FilterFunc: func(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;					// piggy-back on types that are tagged for client-gen
0000000000000000000000000000000000000000;;					return extractBoolTagOrDie("genclient", t.SecondClosestCommentLines) == true
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return packageList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// objectMetaForPackage returns the type of ObjectMeta used by package p.
0000000000000000000000000000000000000000;;	func objectMetaForPackage(p *types.Package) (*types.Type, bool, error) {
0000000000000000000000000000000000000000;;		generatingForPackage := false
0000000000000000000000000000000000000000;;		for _, t := range p.Types {
0000000000000000000000000000000000000000;;			// filter out types which dont have genclient=true.
0000000000000000000000000000000000000000;;			if extractBoolTagOrDie("genclient", t.SecondClosestCommentLines) == false {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			generatingForPackage = true
0000000000000000000000000000000000000000;;			for _, member := range t.Members {
0000000000000000000000000000000000000000;;				if member.Name == "ObjectMeta" {
0000000000000000000000000000000000000000;;					return member.Type, isInternal(member), nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if generatingForPackage {
0000000000000000000000000000000000000000;;			return nil, false, fmt.Errorf("unable to find ObjectMeta for any types in package %s", p.Path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isInternal returns true if the tags for a member do not contain a json tag
0000000000000000000000000000000000000000;;	func isInternal(m types.Member) bool {
0000000000000000000000000000000000000000;;		return !strings.Contains(m.Tags, "json")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// listerGenerator produces a file of listers for a given GroupVersion and
0000000000000000000000000000000000000000;;	// type.
0000000000000000000000000000000000000000;;	type listerGenerator struct {
0000000000000000000000000000000000000000;;		generator.DefaultGen
0000000000000000000000000000000000000000;;		outputPackage  string
0000000000000000000000000000000000000000;;		groupVersion   clientgentypes.GroupVersion
0000000000000000000000000000000000000000;;		internalGVPkg  string
0000000000000000000000000000000000000000;;		typeToGenerate *types.Type
0000000000000000000000000000000000000000;;		imports        namer.ImportTracker
0000000000000000000000000000000000000000;;		objectMeta     *types.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ generator.Generator = &listerGenerator{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *listerGenerator) Filter(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;		return t == g.typeToGenerate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *listerGenerator) Namers(c *generator.Context) namer.NameSystems {
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"raw": namer.NewRawNamer(g.outputPackage, g.imports),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *listerGenerator) Imports(c *generator.Context) (imports []string) {
0000000000000000000000000000000000000000;;		imports = append(imports, g.imports.ImportLines()...)
0000000000000000000000000000000000000000;;		imports = append(imports, "k8s.io/apimachinery/pkg/api/errors")
0000000000000000000000000000000000000000;;		imports = append(imports, "k8s.io/apimachinery/pkg/labels")
0000000000000000000000000000000000000000;;		// for Indexer
0000000000000000000000000000000000000000;;		imports = append(imports, "k8s.io/client-go/tools/cache")
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *listerGenerator) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(w, c, "$", "$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("processing type %v", t)
0000000000000000000000000000000000000000;;		m := map[string]interface{}{
0000000000000000000000000000000000000000;;			"Resource":   c.Universe.Function(types.Name{Package: t.Name.Package, Name: "Resource"}),
0000000000000000000000000000000000000000;;			"type":       t,
0000000000000000000000000000000000000000;;			"objectMeta": g.objectMeta,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespaced := !extractBoolTagOrDie("nonNamespaced", t.SecondClosestCommentLines)
0000000000000000000000000000000000000000;;		if namespaced {
0000000000000000000000000000000000000000;;			sw.Do(typeListerInterface, m)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sw.Do(typeListerInterface_NonNamespaced, m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sw.Do(typeListerStruct, m)
0000000000000000000000000000000000000000;;		sw.Do(typeListerConstructor, m)
0000000000000000000000000000000000000000;;		sw.Do(typeLister_List, m)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if namespaced {
0000000000000000000000000000000000000000;;			sw.Do(typeLister_NamespaceLister, m)
0000000000000000000000000000000000000000;;			sw.Do(namespaceListerInterface, m)
0000000000000000000000000000000000000000;;			sw.Do(namespaceListerStruct, m)
0000000000000000000000000000000000000000;;			sw.Do(namespaceLister_List, m)
0000000000000000000000000000000000000000;;			sw.Do(namespaceLister_Get, m)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sw.Do(typeLister_NonNamespacedGet, m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sw.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var typeListerInterface = `
0000000000000000000000000000000000000000;;	// $.type|public$Lister helps list $.type|publicPlural$.
0000000000000000000000000000000000000000;;	type $.type|public$Lister interface {
0000000000000000000000000000000000000000;;		// List lists all $.type|publicPlural$ in the indexer.
0000000000000000000000000000000000000000;;		List(selector labels.Selector) (ret []*$.type|raw$, err error)
0000000000000000000000000000000000000000;;		// $.type|publicPlural$ returns an object that can list and get $.type|publicPlural$.
0000000000000000000000000000000000000000;;		$.type|publicPlural$(namespace string) $.type|public$NamespaceLister
0000000000000000000000000000000000000000;;		$.type|public$ListerExpansion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var typeListerInterface_NonNamespaced = `
0000000000000000000000000000000000000000;;	// $.type|public$Lister helps list $.type|publicPlural$.
0000000000000000000000000000000000000000;;	type $.type|public$Lister interface {
0000000000000000000000000000000000000000;;		// List lists all $.type|publicPlural$ in the indexer.
0000000000000000000000000000000000000000;;		List(selector labels.Selector) (ret []*$.type|raw$, err error)
0000000000000000000000000000000000000000;;		// Get retrieves the $.type|public$ from the index for a given name.
0000000000000000000000000000000000000000;;		Get(name string) (*$.type|raw$, error)
0000000000000000000000000000000000000000;;		$.type|public$ListerExpansion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var typeListerStruct = `
0000000000000000000000000000000000000000;;	// $.type|private$Lister implements the $.type|public$Lister interface.
0000000000000000000000000000000000000000;;	type $.type|private$Lister struct {
0000000000000000000000000000000000000000;;		indexer cache.Indexer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var typeListerConstructor = `
0000000000000000000000000000000000000000;;	// New$.type|public$Lister returns a new $.type|public$Lister.
0000000000000000000000000000000000000000;;	func New$.type|public$Lister(indexer cache.Indexer) $.type|public$Lister {
0000000000000000000000000000000000000000;;		return &$.type|private$Lister{indexer: indexer}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var typeLister_List = `
0000000000000000000000000000000000000000;;	// List lists all $.type|publicPlural$ in the indexer.
0000000000000000000000000000000000000000;;	func (s *$.type|private$Lister) List(selector labels.Selector) (ret []*$.type|raw$, err error) {
0000000000000000000000000000000000000000;;		err = cache.ListAll(s.indexer, selector, func(m interface{}) {
0000000000000000000000000000000000000000;;			ret = append(ret, m.(*$.type|raw$))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return ret, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var typeLister_NamespaceLister = `
0000000000000000000000000000000000000000;;	// $.type|publicPlural$ returns an object that can list and get $.type|publicPlural$.
0000000000000000000000000000000000000000;;	func (s *$.type|private$Lister) $.type|publicPlural$(namespace string) $.type|public$NamespaceLister {
0000000000000000000000000000000000000000;;		return $.type|private$NamespaceLister{indexer: s.indexer, namespace: namespace}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var typeLister_NonNamespacedGet = `
0000000000000000000000000000000000000000;;	// Get retrieves the $.type|public$ from the index for a given name.
0000000000000000000000000000000000000000;;	func (s *$.type|private$Lister) Get(name string) (*$.type|raw$, error) {
0000000000000000000000000000000000000000;;	  key := &$.type|raw${ObjectMeta: $.objectMeta|raw${Name: name}}
0000000000000000000000000000000000000000;;	  obj, exists, err := s.indexer.Get(key)
0000000000000000000000000000000000000000;;	  if err != nil {
0000000000000000000000000000000000000000;;	    return nil, err
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	  if !exists {
0000000000000000000000000000000000000000;;	    return nil, errors.NewNotFound($.Resource|raw$("$.type|lowercaseSingular$"), name)
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	  return obj.(*$.type|raw$), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var namespaceListerInterface = `
0000000000000000000000000000000000000000;;	// $.type|public$NamespaceLister helps list and get $.type|publicPlural$.
0000000000000000000000000000000000000000;;	type $.type|public$NamespaceLister interface {
0000000000000000000000000000000000000000;;		// List lists all $.type|publicPlural$ in the indexer for a given namespace.
0000000000000000000000000000000000000000;;		List(selector labels.Selector) (ret []*$.type|raw$, err error)
0000000000000000000000000000000000000000;;		// Get retrieves the $.type|public$ from the indexer for a given namespace and name.
0000000000000000000000000000000000000000;;		Get(name string) (*$.type|raw$, error)
0000000000000000000000000000000000000000;;		$.type|public$NamespaceListerExpansion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var namespaceListerStruct = `
0000000000000000000000000000000000000000;;	// $.type|private$NamespaceLister implements the $.type|public$NamespaceLister
0000000000000000000000000000000000000000;;	// interface.
0000000000000000000000000000000000000000;;	type $.type|private$NamespaceLister struct {
0000000000000000000000000000000000000000;;		indexer cache.Indexer
0000000000000000000000000000000000000000;;		namespace string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var namespaceLister_List = `
0000000000000000000000000000000000000000;;	// List lists all $.type|publicPlural$ in the indexer for a given namespace.
0000000000000000000000000000000000000000;;	func (s $.type|private$NamespaceLister) List(selector labels.Selector) (ret []*$.type|raw$, err error) {
0000000000000000000000000000000000000000;;		err = cache.ListAllByNamespace(s.indexer, s.namespace, selector, func(m interface{}) {
0000000000000000000000000000000000000000;;			ret = append(ret, m.(*$.type|raw$))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return ret, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var namespaceLister_Get = `
0000000000000000000000000000000000000000;;	// Get retrieves the $.type|public$ from the indexer for a given namespace and name.
0000000000000000000000000000000000000000;;	func (s $.type|private$NamespaceLister) Get(name string) (*$.type|raw$, error) {
0000000000000000000000000000000000000000;;		obj, exists, err := s.indexer.GetByKey(s.namespace + "/" + name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			return nil, errors.NewNotFound($.Resource|raw$("$.type|lowercaseSingular$"), name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj.(*$.type|raw$), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
