0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
a084fae4ea1be54c78b21b867aa827d7c7e51211;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package generators
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/openapi"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/args"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is the comment tag that carries parameters for open API generation.
0000000000000000000000000000000000000000;;	const tagName = "k8s:openapi-gen"
0000000000000000000000000000000000000000;;	const tagOptional = "optional"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Known values for the tag.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		tagValueTrue               = "true"
0000000000000000000000000000000000000000;;		tagValueFalse              = "false"
0000000000000000000000000000000000000000;;		tagExtensionPrefix         = "x-kubernetes-"
0000000000000000000000000000000000000000;;		tagPatchStrategy           = "patchStrategy"
0000000000000000000000000000000000000000;;		tagPatchMergeKey           = "patchMergeKey"
0000000000000000000000000000000000000000;;		patchStrategyExtensionName = "patch-strategy"
0000000000000000000000000000000000000000;;		patchMergeKeyExtensionName = "patch-merge-key"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getOpenAPITagValue(comments []string) []string {
0000000000000000000000000000000000000000;;		return types.ExtractCommentTags("+", comments)[tagName]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSingleTagsValue(comments []string, tag string) (string, error) {
0000000000000000000000000000000000000000;;		tags, ok := types.ExtractCommentTags("+", comments)[tag]
0000000000000000000000000000000000000000;;		if !ok || len(tags) == 0 {
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(tags) > 1 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Multiple values are not allowed for tag %s", tag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tags[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasOpenAPITagValue(comments []string, value string) bool {
0000000000000000000000000000000000000000;;		tagValues := getOpenAPITagValue(comments)
0000000000000000000000000000000000000000;;		for _, val := range tagValues {
0000000000000000000000000000000000000000;;			if val == value {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hasOptionalTag returns true if the member has +optional in its comments or
0000000000000000000000000000000000000000;;	// omitempty in its json tags.
0000000000000000000000000000000000000000;;	func hasOptionalTag(m *types.Member) bool {
0000000000000000000000000000000000000000;;		hasOptionalCommentTag := types.ExtractCommentTags(
0000000000000000000000000000000000000000;;			"+", m.CommentLines)[tagOptional] != nil
0000000000000000000000000000000000000000;;		hasOptionalJsonTag := strings.Contains(
0000000000000000000000000000000000000000;;			reflect.StructTag(m.Tags).Get("json"), "omitempty")
0000000000000000000000000000000000000000;;		return hasOptionalCommentTag || hasOptionalJsonTag
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type identityNamer struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ identityNamer) Name(t *types.Type) string {
0000000000000000000000000000000000000000;;		return t.Name.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ namer.Namer = identityNamer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameSystems returns the name system used by the generators in this package.
0000000000000000000000000000000000000000;;	func NameSystems() namer.NameSystems {
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"raw":           namer.NewRawNamer("", nil),
0000000000000000000000000000000000000000;;			"sorting_namer": identityNamer{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultNameSystem returns the default name system for ordering the types to be
0000000000000000000000000000000000000000;;	// processed by the generators in this package.
0000000000000000000000000000000000000000;;	func DefaultNameSystem() string {
0000000000000000000000000000000000000000;;		return "sorting_namer"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Packages(context *generator.Context, arguments *args.GeneratorArgs) generator.Packages {
0000000000000000000000000000000000000000;;		boilerplate, err := arguments.LoadGoBoilerplate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed loading boilerplate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		header := append([]byte(fmt.Sprintf("// +build !%s\n\n", arguments.GeneratedBuildTag)), boilerplate...)
0000000000000000000000000000000000000000;;		header = append(header, []byte(
0000000000000000000000000000000000000000;;			`
0000000000000000000000000000000000000000;;	// This file was autogenerated by openapi-gen. Do not edit it manually!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := context.AddDir(arguments.OutputPackagePath); err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed to load output package: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pkg := context.Universe[arguments.OutputPackagePath]
0000000000000000000000000000000000000000;;		if pkg == nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Got nil output package: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return generator.Packages{
0000000000000000000000000000000000000000;;			&generator.DefaultPackage{
0000000000000000000000000000000000000000;;				PackageName: strings.Split(filepath.Base(pkg.Path), ".")[0],
0000000000000000000000000000000000000000;;				PackagePath: pkg.Path,
0000000000000000000000000000000000000000;;				HeaderText:  header,
0000000000000000000000000000000000000000;;				GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
0000000000000000000000000000000000000000;;					return []generator.Generator{NewOpenAPIGen(arguments.OutputFileBaseName, pkg, context)}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				FilterFunc: func(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;					// There is a conflict between this codegen and codecgen, we should avoid types generated for codecgen
0000000000000000000000000000000000000000;;					if strings.HasPrefix(t.Name.Name, "codecSelfer") {
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					pkg := context.Universe.Package(t.Name.Package)
0000000000000000000000000000000000000000;;					if hasOpenAPITagValue(pkg.Comments, tagValueTrue) {
0000000000000000000000000000000000000000;;						return !hasOpenAPITagValue(t.CommentLines, tagValueFalse)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if hasOpenAPITagValue(t.CommentLines, tagValueTrue) {
0000000000000000000000000000000000000000;;						return true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		specPackagePath          = "github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		openAPICommonPackagePath = "k8s.io/apimachinery/pkg/openapi"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// openApiGen produces a file with auto-generated OpenAPI functions.
0000000000000000000000000000000000000000;;	type openAPIGen struct {
0000000000000000000000000000000000000000;;		generator.DefaultGen
0000000000000000000000000000000000000000;;		// TargetPackage is the package that will get GetOpenAPIDefinitions function returns all open API definitions.
0000000000000000000000000000000000000000;;		targetPackage *types.Package
0000000000000000000000000000000000000000;;		imports       namer.ImportTracker
0000000000000000000000000000000000000000;;		context       *generator.Context
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewOpenAPIGen(sanitizedName string, targetPackage *types.Package, context *generator.Context) generator.Generator {
0000000000000000000000000000000000000000;;		return &openAPIGen{
0000000000000000000000000000000000000000;;			DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;				OptionalName: sanitizedName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			imports:       generator.NewImportTracker(),
0000000000000000000000000000000000000000;;			targetPackage: targetPackage,
0000000000000000000000000000000000000000;;			context:       context,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *openAPIGen) Namers(c *generator.Context) namer.NameSystems {
0000000000000000000000000000000000000000;;		// Have the raw namer for this file track what it imports.
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"raw": namer.NewRawNamer(g.targetPackage.Path, g.imports),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *openAPIGen) Filter(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;		// There is a conflict between this codegen and codecgen, we should avoid types generated for codecgen
0000000000000000000000000000000000000000;;		if strings.HasPrefix(t.Name.Name, "codecSelfer") {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *openAPIGen) isOtherPackage(pkg string) bool {
0000000000000000000000000000000000000000;;		if pkg == g.targetPackage.Path {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasSuffix(pkg, "\""+g.targetPackage.Path+"\"") {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *openAPIGen) Imports(c *generator.Context) []string {
0000000000000000000000000000000000000000;;		importLines := []string{}
0000000000000000000000000000000000000000;;		for _, singleImport := range g.imports.ImportLines() {
0000000000000000000000000000000000000000;;			importLines = append(importLines, singleImport)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return importLines
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func argsFromType(t *types.Type) generator.Args {
0000000000000000000000000000000000000000;;		return generator.Args{
0000000000000000000000000000000000000000;;			"type":              t,
0000000000000000000000000000000000000000;;			"ReferenceCallback": types.Ref(openAPICommonPackagePath, "ReferenceCallback"),
0000000000000000000000000000000000000000;;			"OpenAPIDefinition": types.Ref(openAPICommonPackagePath, "OpenAPIDefinition"),
0000000000000000000000000000000000000000;;			"SpecSchemaType":    types.Ref(specPackagePath, "Schema"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *openAPIGen) Init(c *generator.Context, w io.Writer) error {
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(w, c, "$", "$")
0000000000000000000000000000000000000000;;		sw.Do("func GetOpenAPIDefinitions(ref $.ReferenceCallback|raw$) map[string]$.OpenAPIDefinition|raw$ {\n", argsFromType(nil))
0000000000000000000000000000000000000000;;		sw.Do("return map[string]$.OpenAPIDefinition|raw${\n", argsFromType(nil))
0000000000000000000000000000000000000000;;		return sw.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *openAPIGen) Finalize(c *generator.Context, w io.Writer) error {
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(w, c, "$", "$")
0000000000000000000000000000000000000000;;		sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;		sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;		return sw.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *openAPIGen) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
0000000000000000000000000000000000000000;;		glog.V(5).Infof("generating for type %v", t)
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(w, c, "$", "$")
0000000000000000000000000000000000000000;;		err := newOpenAPITypeWriter(sw).generate(t)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sw.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getJsonTags(m *types.Member) []string {
0000000000000000000000000000000000000000;;		jsonTag := reflect.StructTag(m.Tags).Get("json")
0000000000000000000000000000000000000000;;		if jsonTag == "" {
0000000000000000000000000000000000000000;;			return []string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Split(jsonTag, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPatchTags(m *types.Member) (string, string) {
0000000000000000000000000000000000000000;;		return reflect.StructTag(m.Tags).Get(tagPatchMergeKey), reflect.StructTag(m.Tags).Get(tagPatchStrategy)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getReferableName(m *types.Member) string {
0000000000000000000000000000000000000000;;		jsonTags := getJsonTags(m)
0000000000000000000000000000000000000000;;		if len(jsonTags) > 0 {
0000000000000000000000000000000000000000;;			if jsonTags[0] == "-" {
0000000000000000000000000000000000000000;;				return ""
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return jsonTags[0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return m.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func shouldInlineMembers(m *types.Member) bool {
0000000000000000000000000000000000000000;;		jsonTags := getJsonTags(m)
0000000000000000000000000000000000000000;;		return len(jsonTags) > 1 && jsonTags[1] == "inline"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type openAPITypeWriter struct {
0000000000000000000000000000000000000000;;		*generator.SnippetWriter
0000000000000000000000000000000000000000;;		refTypes               map[string]*types.Type
0000000000000000000000000000000000000000;;		GetDefinitionInterface *types.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newOpenAPITypeWriter(sw *generator.SnippetWriter) openAPITypeWriter {
0000000000000000000000000000000000000000;;		return openAPITypeWriter{
0000000000000000000000000000000000000000;;			SnippetWriter: sw,
0000000000000000000000000000000000000000;;			refTypes:      map[string]*types.Type{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasOpenAPIDefinitionMethod(t *types.Type) bool {
0000000000000000000000000000000000000000;;		for mn, mt := range t.Methods {
0000000000000000000000000000000000000000;;			if mn != "OpenAPIDefinition" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(mt.Signature.Parameters) != 0 || len(mt.Signature.Results) != 1 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r := mt.Signature.Results[0]
0000000000000000000000000000000000000000;;			if r.Name.Name != "OpenAPIDefinition" || r.Name.Package != openAPICommonPackagePath {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// typeShortName returns short package name (e.g. the name x appears in package x definition) dot type name.
0000000000000000000000000000000000000000;;	func typeShortName(t *types.Type) string {
0000000000000000000000000000000000000000;;		return filepath.Base(t.Name.Package) + "." + t.Name.Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g openAPITypeWriter) generateMembers(t *types.Type, required []string) ([]string, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for _, m := range t.Members {
0000000000000000000000000000000000000000;;			if hasOpenAPITagValue(m.CommentLines, tagValueFalse) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if shouldInlineMembers(&m) {
0000000000000000000000000000000000000000;;				required, err = g.generateMembers(m.Type, required)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return required, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			name := getReferableName(&m)
0000000000000000000000000000000000000000;;			if name == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !hasOptionalTag(&m) {
0000000000000000000000000000000000000000;;				required = append(required, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = g.generateProperty(&m, t); err != nil {
0000000000000000000000000000000000000000;;				return required, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return required, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g openAPITypeWriter) generate(t *types.Type) error {
0000000000000000000000000000000000000000;;		// Only generate for struct type and ignore the rest
0000000000000000000000000000000000000000;;		switch t.Kind {
0000000000000000000000000000000000000000;;		case types.Struct:
0000000000000000000000000000000000000000;;			args := argsFromType(t)
0000000000000000000000000000000000000000;;			g.Do("\"$.$\": ", t.Name)
0000000000000000000000000000000000000000;;			if hasOpenAPIDefinitionMethod(t) {
0000000000000000000000000000000000000000;;				g.Do("$.type|raw${}.OpenAPIDefinition(),\n", args)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.Do("{\nSchema: spec.Schema{\nSchemaProps: spec.SchemaProps{\n", nil)
0000000000000000000000000000000000000000;;			g.generateDescription(t.CommentLines)
0000000000000000000000000000000000000000;;			g.Do("Properties: map[string]$.SpecSchemaType|raw${\n", args)
0000000000000000000000000000000000000000;;			required, err := g.generateMembers(t, []string{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.Do("},\n", nil)
0000000000000000000000000000000000000000;;			if len(required) > 0 {
0000000000000000000000000000000000000000;;				g.Do("Required: []string{\"$.$\"},\n", strings.Join(required, "\",\""))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.Do("},\n", nil)
0000000000000000000000000000000000000000;;			if err := g.generateExtensions(t.CommentLines); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.Do("},\n", nil)
0000000000000000000000000000000000000000;;			g.Do("Dependencies: []string{\n", args)
0000000000000000000000000000000000000000;;			// Map order is undefined, sort them or we may get a different file generated each time.
0000000000000000000000000000000000000000;;			keys := []string{}
0000000000000000000000000000000000000000;;			for k := range g.refTypes {
0000000000000000000000000000000000000000;;				keys = append(keys, k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Strings(keys)
0000000000000000000000000000000000000000;;			for _, k := range keys {
0000000000000000000000000000000000000000;;				v := g.refTypes[k]
0000000000000000000000000000000000000000;;				if t, _ := openapi.GetOpenAPITypeFormat(v.String()); t != "" {
0000000000000000000000000000000000000000;;					// This is a known type, we do not need a reference to it
0000000000000000000000000000000000000000;;					// Will eliminate special case of time.Time
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				g.Do("\"$.$\",", k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.Do("},\n},\n", nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g openAPITypeWriter) generateExtensions(CommentLines []string) error {
0000000000000000000000000000000000000000;;		tagValues := getOpenAPITagValue(CommentLines)
0000000000000000000000000000000000000000;;		type NameValue struct {
0000000000000000000000000000000000000000;;			Name, Value string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		extensions := []NameValue{}
0000000000000000000000000000000000000000;;		for _, val := range tagValues {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(val, tagExtensionPrefix) {
0000000000000000000000000000000000000000;;				parts := strings.SplitN(val, ":", 2)
0000000000000000000000000000000000000000;;				if len(parts) != 2 {
0000000000000000000000000000000000000000;;					return fmt.Errorf("Invalid extension value: %v", val)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				extensions = append(extensions, NameValue{parts[0], parts[1]})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		patchMergeKeyTag, err := getSingleTagsValue(CommentLines, tagPatchMergeKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(patchMergeKeyTag) > 0 {
0000000000000000000000000000000000000000;;			extensions = append(extensions, NameValue{tagExtensionPrefix + patchMergeKeyExtensionName, patchMergeKeyTag})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		patchStrategyTag, err := getSingleTagsValue(CommentLines, tagPatchStrategy)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(patchStrategyTag) > 0 {
0000000000000000000000000000000000000000;;			extensions = append(extensions, NameValue{tagExtensionPrefix + patchStrategyExtensionName, patchStrategyTag})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(extensions) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.Do("VendorExtensible: spec.VendorExtensible{\nExtensions: spec.Extensions{\n", nil)
0000000000000000000000000000000000000000;;		for _, extension := range extensions {
0000000000000000000000000000000000000000;;			g.Do("\"$.$\": ", extension.Name)
0000000000000000000000000000000000000000;;			g.Do("\"$.$\",\n", extension.Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.Do("},\n},\n", nil)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(#44005): Move this validation outside of this generator (probably to policy verifier)
0000000000000000000000000000000000000000;;	func (g openAPITypeWriter) validatePatchTags(m *types.Member, parent *types.Type) error {
0000000000000000000000000000000000000000;;		patchMergeKeyStructTag, patchStrategyStructTag := getPatchTags(m)
0000000000000000000000000000000000000000;;		patchMergeKeyCommentTag, err := getSingleTagsValue(m.CommentLines, tagPatchMergeKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		patchStrategyCommentTag, err := getSingleTagsValue(m.CommentLines, tagPatchStrategy)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if patchMergeKeyStructTag != patchMergeKeyCommentTag {
0000000000000000000000000000000000000000;;			return fmt.Errorf("patchMergeKey in comment and struct tags should match for member (%s) of (%s)",
0000000000000000000000000000000000000000;;				m.Name, parent.Name.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if patchStrategyStructTag != patchStrategyCommentTag {
0000000000000000000000000000000000000000;;			return fmt.Errorf("patchStrategy in comment and struct tags should match for member (%s) of (%s)",
0000000000000000000000000000000000000000;;				m.Name, parent.Name.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g openAPITypeWriter) generateDescription(CommentLines []string) {
0000000000000000000000000000000000000000;;		var buffer bytes.Buffer
0000000000000000000000000000000000000000;;		delPrevChar := func() {
0000000000000000000000000000000000000000;;			if buffer.Len() > 0 {
0000000000000000000000000000000000000000;;				buffer.Truncate(buffer.Len() - 1) // Delete the last " " or "\n"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, line := range CommentLines {
0000000000000000000000000000000000000000;;			// Ignore all lines after ---
0000000000000000000000000000000000000000;;			if line == "---" {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			line = strings.TrimRight(line, " ")
0000000000000000000000000000000000000000;;			leading := strings.TrimLeft(line, " ")
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case len(line) == 0: // Keep paragraphs
0000000000000000000000000000000000000000;;				delPrevChar()
0000000000000000000000000000000000000000;;				buffer.WriteString("\n\n")
0000000000000000000000000000000000000000;;			case strings.HasPrefix(leading, "TODO"): // Ignore one line TODOs
0000000000000000000000000000000000000000;;			case strings.HasPrefix(leading, "+"): // Ignore instructions to go2idl
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if strings.HasPrefix(line, " ") || strings.HasPrefix(line, "\t") {
0000000000000000000000000000000000000000;;					delPrevChar()
0000000000000000000000000000000000000000;;					line = "\n" + line + "\n" // Replace it with newline. This is useful when we have a line with: "Example:\n\tJSON-someting..."
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					line += " "
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				buffer.WriteString(line)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		postDoc := strings.TrimRight(buffer.String(), "\n")
0000000000000000000000000000000000000000;;		postDoc = strings.Replace(postDoc, "\\\"", "\"", -1) // replace user's \" to "
0000000000000000000000000000000000000000;;		postDoc = strings.Replace(postDoc, "\"", "\\\"", -1) // Escape "
0000000000000000000000000000000000000000;;		postDoc = strings.Replace(postDoc, "\n", "\\n", -1)
0000000000000000000000000000000000000000;;		postDoc = strings.Replace(postDoc, "\t", "\\t", -1)
0000000000000000000000000000000000000000;;		postDoc = strings.Trim(postDoc, " ")
0000000000000000000000000000000000000000;;		if postDoc != "" {
0000000000000000000000000000000000000000;;			g.Do("Description: \"$.$\",\n", postDoc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g openAPITypeWriter) generateProperty(m *types.Member, parent *types.Type) error {
0000000000000000000000000000000000000000;;		name := getReferableName(m)
0000000000000000000000000000000000000000;;		if name == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := g.validatePatchTags(m, parent); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.Do("\"$.$\": {\n", name)
0000000000000000000000000000000000000000;;		if err := g.generateExtensions(m.CommentLines); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.Do("SchemaProps: spec.SchemaProps{\n", nil)
0000000000000000000000000000000000000000;;		g.generateDescription(m.CommentLines)
0000000000000000000000000000000000000000;;		jsonTags := getJsonTags(m)
0000000000000000000000000000000000000000;;		if len(jsonTags) > 1 && jsonTags[1] == "string" {
0000000000000000000000000000000000000000;;			g.generateSimpleProperty("string", "")
0000000000000000000000000000000000000000;;			g.Do("},\n},\n", nil)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t := resolveAliasAndPtrType(m.Type)
0000000000000000000000000000000000000000;;		// If we can get a openAPI type and format for this type, we consider it to be simple property
0000000000000000000000000000000000000000;;		typeString, format := openapi.GetOpenAPITypeFormat(t.String())
0000000000000000000000000000000000000000;;		if typeString != "" {
0000000000000000000000000000000000000000;;			g.generateSimpleProperty(typeString, format)
0000000000000000000000000000000000000000;;			g.Do("},\n},\n", nil)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t.Kind {
0000000000000000000000000000000000000000;;		case types.Builtin:
0000000000000000000000000000000000000000;;			return fmt.Errorf("please add type %v to getOpenAPITypeFormat function", t)
0000000000000000000000000000000000000000;;		case types.Map:
0000000000000000000000000000000000000000;;			if err := g.generateMapProperty(t); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case types.Slice, types.Array:
0000000000000000000000000000000000000000;;			if err := g.generateSliceProperty(t); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case types.Struct, types.Interface:
0000000000000000000000000000000000000000;;			g.generateReferenceProperty(t)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot generate spec for type %v", t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.Do("},\n},\n", nil)
0000000000000000000000000000000000000000;;		return g.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g openAPITypeWriter) generateSimpleProperty(typeString, format string) {
0000000000000000000000000000000000000000;;		g.Do("Type: []string{\"$.$\"},\n", typeString)
0000000000000000000000000000000000000000;;		g.Do("Format: \"$.$\",\n", format)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g openAPITypeWriter) generateReferenceProperty(t *types.Type) {
0000000000000000000000000000000000000000;;		g.refTypes[t.Name.String()] = t
0000000000000000000000000000000000000000;;		g.Do("Ref: ref(\"$.$\"),\n", t.Name.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func resolveAliasAndPtrType(t *types.Type) *types.Type {
0000000000000000000000000000000000000000;;		var prev *types.Type
0000000000000000000000000000000000000000;;		for prev != t {
0000000000000000000000000000000000000000;;			prev = t
0000000000000000000000000000000000000000;;			if t.Kind == types.Alias {
0000000000000000000000000000000000000000;;				t = t.Underlying
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if t.Kind == types.Pointer {
0000000000000000000000000000000000000000;;				t = t.Elem
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g openAPITypeWriter) generateMapProperty(t *types.Type) error {
0000000000000000000000000000000000000000;;		keyType := resolveAliasAndPtrType(t.Key)
0000000000000000000000000000000000000000;;		elemType := resolveAliasAndPtrType(t.Elem)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// According to OpenAPI examples, only map from string is supported
0000000000000000000000000000000000000000;;		if keyType.Name.Name != "string" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("map with non-string keys are not supported by OpenAPI in %v", t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.Do("Type: []string{\"object\"},\n", nil)
0000000000000000000000000000000000000000;;		g.Do("AdditionalProperties: &spec.SchemaOrBool{\nSchema: &spec.Schema{\nSchemaProps: spec.SchemaProps{\n", nil)
0000000000000000000000000000000000000000;;		typeString, format := openapi.GetOpenAPITypeFormat(elemType.String())
0000000000000000000000000000000000000000;;		if typeString != "" {
0000000000000000000000000000000000000000;;			g.generateSimpleProperty(typeString, format)
0000000000000000000000000000000000000000;;			g.Do("},\n},\n},\n", nil)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch elemType.Kind {
0000000000000000000000000000000000000000;;		case types.Builtin:
0000000000000000000000000000000000000000;;			return fmt.Errorf("please add type %v to getOpenAPITypeFormat function.", elemType)
0000000000000000000000000000000000000000;;		case types.Struct:
0000000000000000000000000000000000000000;;			g.generateReferenceProperty(t.Elem)
0000000000000000000000000000000000000000;;		case types.Slice, types.Array:
0000000000000000000000000000000000000000;;			g.generateSliceProperty(elemType)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("map Element kind %v is not supported in %v", elemType.Kind, t.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.Do("},\n},\n},\n", nil)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g openAPITypeWriter) generateSliceProperty(t *types.Type) error {
0000000000000000000000000000000000000000;;		elemType := resolveAliasAndPtrType(t.Elem)
0000000000000000000000000000000000000000;;		g.Do("Type: []string{\"array\"},\n", nil)
0000000000000000000000000000000000000000;;		g.Do("Items: &spec.SchemaOrArray{\nSchema: &spec.Schema{\nSchemaProps: spec.SchemaProps{\n", nil)
0000000000000000000000000000000000000000;;		typeString, format := openapi.GetOpenAPITypeFormat(elemType.String())
0000000000000000000000000000000000000000;;		if typeString != "" {
0000000000000000000000000000000000000000;;			g.generateSimpleProperty(typeString, format)
0000000000000000000000000000000000000000;;			g.Do("},\n},\n},\n", nil)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch elemType.Kind {
0000000000000000000000000000000000000000;;		case types.Builtin:
0000000000000000000000000000000000000000;;			return fmt.Errorf("please add type %v to getOpenAPITypeFormat function.", elemType)
0000000000000000000000000000000000000000;;		case types.Struct:
0000000000000000000000000000000000000000;;			g.generateReferenceProperty(t.Elem)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("slice Element kind %v is not supported in %v", elemType.Kind, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.Do("},\n},\n},\n", nil)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
