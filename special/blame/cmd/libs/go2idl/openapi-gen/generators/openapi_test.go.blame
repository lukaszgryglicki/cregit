0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
a084fae4ea1be54c78b21b867aa827d7c7e51211;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package generators
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/parser"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func construct(t *testing.T, files map[string]string, testNamer namer.Namer) (*parser.Builder, types.Universe, []*types.Type) {
0000000000000000000000000000000000000000;;		b := parser.New()
0000000000000000000000000000000000000000;;		for name, src := range files {
0000000000000000000000000000000000000000;;			if err := b.AddFileForTest(filepath.Dir(name), name, []byte(src)); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u, err := b.FindTypes()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		orderer := namer.Orderer{Namer: testNamer}
0000000000000000000000000000000000000000;;		o := orderer.OrderUniverse(u)
0000000000000000000000000000000000000000;;		return b, u, o
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testOpenAPITypeWritter(t *testing.T, code string) (error, *assert.Assertions, *bytes.Buffer) {
0000000000000000000000000000000000000000;;		assert := assert.New(t)
0000000000000000000000000000000000000000;;		var testFiles = map[string]string{
0000000000000000000000000000000000000000;;			"base/foo/bar.go": code,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rawNamer := namer.NewRawNamer("o", nil)
0000000000000000000000000000000000000000;;		namers := namer.NameSystems{
0000000000000000000000000000000000000000;;			"raw": namer.NewRawNamer("", nil),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		builder, universe, _ := construct(t, testFiles, rawNamer)
0000000000000000000000000000000000000000;;		context, err := generator.NewContext(builder, namers, "raw")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buffer := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(buffer, context, "$", "$")
0000000000000000000000000000000000000000;;		blahT := universe.Type(types.Name{Package: "base/foo", Name: "Blah"})
0000000000000000000000000000000000000000;;		return newOpenAPITypeWriter(sw).generate(blahT), assert, buffer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSimple(t *testing.T) {
0000000000000000000000000000000000000000;;		err, assert, buffer := testOpenAPITypeWritter(t, `
0000000000000000000000000000000000000000;;	package foo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Blah is a test.
0000000000000000000000000000000000000000;;	// +k8s:openapi-gen=true
0000000000000000000000000000000000000000;;	// +k8s:openapi-gen=x-kubernetes-type-tag:type_test
0000000000000000000000000000000000000000;;	type Blah struct {
0000000000000000000000000000000000000000;;		// A simple string
0000000000000000000000000000000000000000;;		String string
0000000000000000000000000000000000000000;;		// A simple int
0000000000000000000000000000000000000000;;		Int int `+"`"+`json:",omitempty"`+"`"+`
0000000000000000000000000000000000000000;;		// An int considered string simple int
0000000000000000000000000000000000000000;;		IntString int `+"`"+`json:",string"`+"`"+`
0000000000000000000000000000000000000000;;		// A simple int64
0000000000000000000000000000000000000000;;		Int64 int64
0000000000000000000000000000000000000000;;		// A simple int32
0000000000000000000000000000000000000000;;		Int32 int32
0000000000000000000000000000000000000000;;		// A simple int16
0000000000000000000000000000000000000000;;		Int16 int16
0000000000000000000000000000000000000000;;		// A simple int8
0000000000000000000000000000000000000000;;		Int8 int8
0000000000000000000000000000000000000000;;		// A simple int
0000000000000000000000000000000000000000;;		Uint uint
0000000000000000000000000000000000000000;;		// A simple int64
0000000000000000000000000000000000000000;;		Uint64 uint64
0000000000000000000000000000000000000000;;		// A simple int32
0000000000000000000000000000000000000000;;		Uint32 uint32
0000000000000000000000000000000000000000;;		// A simple int16
0000000000000000000000000000000000000000;;		Uint16 uint16
0000000000000000000000000000000000000000;;		// A simple int8
0000000000000000000000000000000000000000;;		Uint8 uint8
0000000000000000000000000000000000000000;;		// A simple byte
0000000000000000000000000000000000000000;;		Byte byte
0000000000000000000000000000000000000000;;		// A simple boolean
0000000000000000000000000000000000000000;;		Bool bool
0000000000000000000000000000000000000000;;		// A simple float64
0000000000000000000000000000000000000000;;		Float64 float64
0000000000000000000000000000000000000000;;		// A simple float32
0000000000000000000000000000000000000000;;		Float32 float32
0000000000000000000000000000000000000000;;		// a base64 encoded characters
0000000000000000000000000000000000000000;;		ByteArray []byte
0000000000000000000000000000000000000000;;		// a member with an extension
0000000000000000000000000000000000000000;;		// +k8s:openapi-gen=x-kubernetes-member-tag:member_test
0000000000000000000000000000000000000000;;		WithExtension string
0000000000000000000000000000000000000000;;		// a member with struct tag as extension
0000000000000000000000000000000000000000;;		// +patchStrategy=ps
0000000000000000000000000000000000000000;;		// +patchMergeKey=pmk
0000000000000000000000000000000000000000;;		WithStructTagExtension string `+"`"+`patchStrategy:"ps" patchMergeKey:"pmk"`+"`"+`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;			`)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		assert.Equal(`"base/foo.Blah": {
0000000000000000000000000000000000000000;;	Schema: spec.Schema{
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "Blah is a test.",
0000000000000000000000000000000000000000;;	Properties: map[string]spec.Schema{
0000000000000000000000000000000000000000;;	"String": {
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "A simple string",
0000000000000000000000000000000000000000;;	Type: []string{"string"},
0000000000000000000000000000000000000000;;	Format: "",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	"Int64": {
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "A simple int64",
0000000000000000000000000000000000000000;;	Type: []string{"integer"},
0000000000000000000000000000000000000000;;	Format: "int64",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	"Int32": {
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "A simple int32",
0000000000000000000000000000000000000000;;	Type: []string{"integer"},
0000000000000000000000000000000000000000;;	Format: "int32",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	"Int16": {
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "A simple int16",
0000000000000000000000000000000000000000;;	Type: []string{"integer"},
0000000000000000000000000000000000000000;;	Format: "int32",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	"Int8": {
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "A simple int8",
0000000000000000000000000000000000000000;;	Type: []string{"integer"},
0000000000000000000000000000000000000000;;	Format: "byte",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	"Uint": {
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "A simple int",
0000000000000000000000000000000000000000;;	Type: []string{"integer"},
0000000000000000000000000000000000000000;;	Format: "int32",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	"Uint64": {
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "A simple int64",
0000000000000000000000000000000000000000;;	Type: []string{"integer"},
0000000000000000000000000000000000000000;;	Format: "int64",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	"Uint32": {
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "A simple int32",
0000000000000000000000000000000000000000;;	Type: []string{"integer"},
0000000000000000000000000000000000000000;;	Format: "int64",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	"Uint16": {
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "A simple int16",
0000000000000000000000000000000000000000;;	Type: []string{"integer"},
0000000000000000000000000000000000000000;;	Format: "int32",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	"Uint8": {
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "A simple int8",
0000000000000000000000000000000000000000;;	Type: []string{"integer"},
0000000000000000000000000000000000000000;;	Format: "byte",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	"Byte": {
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "A simple byte",
0000000000000000000000000000000000000000;;	Type: []string{"integer"},
0000000000000000000000000000000000000000;;	Format: "byte",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	"Bool": {
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "A simple boolean",
0000000000000000000000000000000000000000;;	Type: []string{"boolean"},
0000000000000000000000000000000000000000;;	Format: "",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	"Float64": {
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "A simple float64",
0000000000000000000000000000000000000000;;	Type: []string{"number"},
0000000000000000000000000000000000000000;;	Format: "double",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	"Float32": {
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "A simple float32",
0000000000000000000000000000000000000000;;	Type: []string{"number"},
0000000000000000000000000000000000000000;;	Format: "float",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	"ByteArray": {
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "a base64 encoded characters",
0000000000000000000000000000000000000000;;	Type: []string{"string"},
0000000000000000000000000000000000000000;;	Format: "byte",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	"WithExtension": {
0000000000000000000000000000000000000000;;	VendorExtensible: spec.VendorExtensible{
0000000000000000000000000000000000000000;;	Extensions: spec.Extensions{
0000000000000000000000000000000000000000;;	"x-kubernetes-member-tag": "member_test",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "a member with an extension",
0000000000000000000000000000000000000000;;	Type: []string{"string"},
0000000000000000000000000000000000000000;;	Format: "",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	"WithStructTagExtension": {
0000000000000000000000000000000000000000;;	VendorExtensible: spec.VendorExtensible{
0000000000000000000000000000000000000000;;	Extensions: spec.Extensions{
0000000000000000000000000000000000000000;;	"x-kubernetes-patch-merge-key": "pmk",
0000000000000000000000000000000000000000;;	"x-kubernetes-patch-strategy": "ps",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "a member with struct tag as extension",
0000000000000000000000000000000000000000;;	Type: []string{"string"},
0000000000000000000000000000000000000000;;	Format: "",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	Required: []string{"String","Int64","Int32","Int16","Int8","Uint","Uint64","Uint32","Uint16","Uint8","Byte","Bool","Float64","Float32","ByteArray","WithExtension","WithStructTagExtension"},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	VendorExtensible: spec.VendorExtensible{
0000000000000000000000000000000000000000;;	Extensions: spec.Extensions{
0000000000000000000000000000000000000000;;	"x-kubernetes-type-tag": "type_test",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	Dependencies: []string{
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	`, buffer.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFailingSample1(t *testing.T) {
0000000000000000000000000000000000000000;;		err, assert, _ := testOpenAPITypeWritter(t, `
0000000000000000000000000000000000000000;;	package foo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Map sample tests openAPIGen.generateMapProperty method.
0000000000000000000000000000000000000000;;	type Blah struct {
0000000000000000000000000000000000000000;;		// A sample String to String map
0000000000000000000000000000000000000000;;		StringToArray map[string]map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;		`)
0000000000000000000000000000000000000000;;		if assert.Error(err, "An error was expected") {
0000000000000000000000000000000000000000;;			assert.Equal(err, fmt.Errorf("map Element kind Map is not supported in map[string]map[string]string"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFailingSample2(t *testing.T) {
0000000000000000000000000000000000000000;;		err, assert, _ := testOpenAPITypeWritter(t, `
0000000000000000000000000000000000000000;;	package foo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Map sample tests openAPIGen.generateMapProperty method.
0000000000000000000000000000000000000000;;	type Blah struct {
0000000000000000000000000000000000000000;;		// A sample String to String map
0000000000000000000000000000000000000000;;		StringToArray map[int]string
0000000000000000000000000000000000000000;;	}	`)
0000000000000000000000000000000000000000;;		if assert.Error(err, "An error was expected") {
0000000000000000000000000000000000000000;;			assert.Equal(err, fmt.Errorf("map with non-string keys are not supported by OpenAPI in map[int]string"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPointer(t *testing.T) {
0000000000000000000000000000000000000000;;		err, assert, buffer := testOpenAPITypeWritter(t, `
0000000000000000000000000000000000000000;;	package foo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PointerSample demonstrate pointer's properties
0000000000000000000000000000000000000000;;	type Blah struct {
0000000000000000000000000000000000000000;;		// A string pointer
0000000000000000000000000000000000000000;;		StringPointer *string
0000000000000000000000000000000000000000;;		// A struct pointer
0000000000000000000000000000000000000000;;		StructPointer *Blah
0000000000000000000000000000000000000000;;		// A slice pointer
0000000000000000000000000000000000000000;;		SlicePointer *[]string
0000000000000000000000000000000000000000;;		// A map pointer
0000000000000000000000000000000000000000;;		MapPointer *map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;		`)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		assert.Equal(`"base/foo.Blah": {
0000000000000000000000000000000000000000;;	Schema: spec.Schema{
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "PointerSample demonstrate pointer's properties",
0000000000000000000000000000000000000000;;	Properties: map[string]spec.Schema{
0000000000000000000000000000000000000000;;	"StringPointer": {
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "A string pointer",
0000000000000000000000000000000000000000;;	Type: []string{"string"},
0000000000000000000000000000000000000000;;	Format: "",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	"StructPointer": {
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "A struct pointer",
0000000000000000000000000000000000000000;;	Ref: ref("base/foo.Blah"),
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	"SlicePointer": {
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "A slice pointer",
0000000000000000000000000000000000000000;;	Type: []string{"array"},
0000000000000000000000000000000000000000;;	Items: &spec.SchemaOrArray{
0000000000000000000000000000000000000000;;	Schema: &spec.Schema{
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Type: []string{"string"},
0000000000000000000000000000000000000000;;	Format: "",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	"MapPointer": {
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Description: "A map pointer",
0000000000000000000000000000000000000000;;	Type: []string{"object"},
0000000000000000000000000000000000000000;;	AdditionalProperties: &spec.SchemaOrBool{
0000000000000000000000000000000000000000;;	Schema: &spec.Schema{
0000000000000000000000000000000000000000;;	SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;	Type: []string{"string"},
0000000000000000000000000000000000000000;;	Format: "",
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	Required: []string{"StringPointer","StructPointer","SlicePointer","MapPointer"},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	Dependencies: []string{
0000000000000000000000000000000000000000;;	"base/foo.Blah",},
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	`, buffer.String())
0000000000000000000000000000000000000000;;	}
