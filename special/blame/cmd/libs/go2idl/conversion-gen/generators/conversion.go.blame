0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1e8bf9d1df546495621c53c64e52ebc67c891610;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package generators
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/args"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CustomArgs is used tby the go2idl framework to pass args specific to this
0000000000000000000000000000000000000000;;	// generator.
0000000000000000000000000000000000000000;;	type CustomArgs struct {
0000000000000000000000000000000000000000;;		ExtraPeerDirs []string // Always consider these as last-ditch possibilities for conversions.
0000000000000000000000000000000000000000;;		// Skipunsafe indicates whether to generate unsafe conversions to improve the efficiency
0000000000000000000000000000000000000000;;		// of these operations. The unsafe operation is a direct pointer assignment via unsafe
0000000000000000000000000000000000000000;;		// (within the allowed uses of unsafe) and is equivalent to a proposed Golang change to
0000000000000000000000000000000000000000;;		// allow structs that are identical to be assigned to each other.
0000000000000000000000000000000000000000;;		SkipUnsafe bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are the comment tags that carry parameters for conversion generation.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// e.g., "+k8s:conversion-gen=<peer-pkg>" in doc.go, where <peer-pkg> is the
0000000000000000000000000000000000000000;;		// import path of the package the peer types are defined in.
0000000000000000000000000000000000000000;;		// e.g., "+k8s:conversion-gen=false" in a type's comment will let
0000000000000000000000000000000000000000;;		// conversion-gen skip that type.
0000000000000000000000000000000000000000;;		tagName = "k8s:conversion-gen"
0000000000000000000000000000000000000000;;		// e.g., "+k8s:conversion-gen-external-types=<type-pkg>" in doc.go, where
0000000000000000000000000000000000000000;;		// <type-pkg> is the relative path to the package the types are defined in.
0000000000000000000000000000000000000000;;		externalTypesTagName = "k8s:conversion-gen-external-types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractTag(comments []string) []string {
0000000000000000000000000000000000000000;;		return types.ExtractCommentTags("+", comments)[tagName]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractExternalTypesTag(comments []string) []string {
0000000000000000000000000000000000000000;;		return types.ExtractCommentTags("+", comments)[externalTypesTagName]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isCopyOnly(comments []string) bool {
0000000000000000000000000000000000000000;;		values := types.ExtractCommentTags("+", comments)["k8s:conversion-fn"]
0000000000000000000000000000000000000000;;		return len(values) == 1 && values[0] == "copy-only"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isDrop(comments []string) bool {
0000000000000000000000000000000000000000;;		values := types.ExtractCommentTags("+", comments)["k8s:conversion-fn"]
0000000000000000000000000000000000000000;;		return len(values) == 1 && values[0] == "drop"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: This is created only to reduce number of changes in a single PR.
0000000000000000000000000000000000000000;;	// Remove it and use PublicNamer instead.
0000000000000000000000000000000000000000;;	func conversionNamer() *namer.NameStrategy {
0000000000000000000000000000000000000000;;		return &namer.NameStrategy{
0000000000000000000000000000000000000000;;			Join: func(pre string, in []string, post string) string {
0000000000000000000000000000000000000000;;				return strings.Join(in, "_")
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			PrependPackageNames: 1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func defaultFnNamer() *namer.NameStrategy {
0000000000000000000000000000000000000000;;		return &namer.NameStrategy{
0000000000000000000000000000000000000000;;			Prefix: "SetDefaults_",
0000000000000000000000000000000000000000;;			Join: func(pre string, in []string, post string) string {
0000000000000000000000000000000000000000;;				return pre + strings.Join(in, "_") + post
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameSystems returns the name system used by the generators in this package.
0000000000000000000000000000000000000000;;	func NameSystems() namer.NameSystems {
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"public":    conversionNamer(),
0000000000000000000000000000000000000000;;			"raw":       namer.NewRawNamer("", nil),
0000000000000000000000000000000000000000;;			"defaultfn": defaultFnNamer(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultNameSystem returns the default name system for ordering the types to be
0000000000000000000000000000000000000000;;	// processed by the generators in this package.
0000000000000000000000000000000000000000;;	func DefaultNameSystem() string {
0000000000000000000000000000000000000000;;		return "public"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPeerTypeFor(context *generator.Context, t *types.Type, potenialPeerPkgs []string) *types.Type {
0000000000000000000000000000000000000000;;		for _, ppp := range potenialPeerPkgs {
0000000000000000000000000000000000000000;;			p := context.Universe.Package(ppp)
0000000000000000000000000000000000000000;;			if p == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p.Has(t.Name.Name) {
0000000000000000000000000000000000000000;;				return p.Type(t.Name.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type conversionPair struct {
0000000000000000000000000000000000000000;;		inType  *types.Type
0000000000000000000000000000000000000000;;		outType *types.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// All of the types in conversions map are of type "DeclarationOf" with
0000000000000000000000000000000000000000;;	// the underlying type being "Func".
0000000000000000000000000000000000000000;;	type conversionFuncMap map[conversionPair]*types.Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns all manually-defined conversion functions in the package.
0000000000000000000000000000000000000000;;	func getManualConversionFunctions(context *generator.Context, pkg *types.Package, manualMap conversionFuncMap) {
0000000000000000000000000000000000000000;;		scopeName := types.Ref(conversionPackagePath, "Scope").Name
0000000000000000000000000000000000000000;;		errorName := types.Ref("", "error").Name
0000000000000000000000000000000000000000;;		buffer := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(buffer, context, "$", "$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, f := range pkg.Functions {
0000000000000000000000000000000000000000;;			if f.Underlying == nil || f.Underlying.Kind != types.Func {
0000000000000000000000000000000000000000;;				glog.Errorf("Malformed function: %#v", f)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if f.Underlying.Signature == nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Function without signature: %#v", f)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			signature := f.Underlying.Signature
0000000000000000000000000000000000000000;;			// Check whether the function is conversion function.
0000000000000000000000000000000000000000;;			// Note that all of them have signature:
0000000000000000000000000000000000000000;;			// func Convert_inType_To_outType(inType, outType, conversion.Scope) error
0000000000000000000000000000000000000000;;			if signature.Receiver != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(signature.Parameters) != 3 || signature.Parameters[2].Name != scopeName {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(signature.Results) != 1 || signature.Results[0].Name != errorName {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			inType := signature.Parameters[0]
0000000000000000000000000000000000000000;;			outType := signature.Parameters[1]
0000000000000000000000000000000000000000;;			if inType.Kind != types.Pointer || outType.Kind != types.Pointer {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Now check if the name satisfies the convention.
0000000000000000000000000000000000000000;;			// TODO: This should call the Namer directly.
0000000000000000000000000000000000000000;;			args := argsFromType(inType.Elem, outType.Elem)
0000000000000000000000000000000000000000;;			sw.Do("Convert_$.inType|public$_To_$.outType|public$", args)
0000000000000000000000000000000000000000;;			if f.Name.Name == buffer.String() {
0000000000000000000000000000000000000000;;				key := conversionPair{inType.Elem, outType.Elem}
0000000000000000000000000000000000000000;;				// We might scan the same package twice, and that's OK.
0000000000000000000000000000000000000000;;				if v, ok := manualMap[key]; ok && v != nil && v.Name.Package != pkg.Path {
0000000000000000000000000000000000000000;;					panic(fmt.Sprintf("duplicate static conversion defined: %s -> %s", key.inType, key.outType))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				manualMap[key] = f
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buffer.Reset()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Packages(context *generator.Context, arguments *args.GeneratorArgs) generator.Packages {
0000000000000000000000000000000000000000;;		boilerplate, err := arguments.LoadGoBoilerplate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed loading boilerplate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inputs := sets.NewString(context.Inputs...)
0000000000000000000000000000000000000000;;		packages := generator.Packages{}
0000000000000000000000000000000000000000;;		header := append([]byte(fmt.Sprintf("// +build !%s\n\n", arguments.GeneratedBuildTag)), boilerplate...)
0000000000000000000000000000000000000000;;		header = append(header, []byte("\n// This file was autogenerated by conversion-gen. Do not edit it manually!\n\n")...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Accumulate pre-existing conversion functions.
0000000000000000000000000000000000000000;;		// TODO: This is too ad-hoc.  We need a better way.
0000000000000000000000000000000000000000;;		manualConversions := conversionFuncMap{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Record types that are memory equivalent. A type is memory equivalent
0000000000000000000000000000000000000000;;		// if it has the same memory layout and no nested manual conversion is
0000000000000000000000000000000000000000;;		// defined.
0000000000000000000000000000000000000000;;		// TODO: in the future, relax the nested manual conversion requirement
0000000000000000000000000000000000000000;;		//   if we can show that a large enough types are memory identical but
0000000000000000000000000000000000000000;;		//   have non-trivial conversion
0000000000000000000000000000000000000000;;		memoryEquivalentTypes := equalMemoryTypes{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We are generating conversions only for packages that are explicitly
0000000000000000000000000000000000000000;;		// passed as InputDir.
0000000000000000000000000000000000000000;;		for i := range inputs {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("considering pkg %q", i)
0000000000000000000000000000000000000000;;			pkg := context.Universe[i]
0000000000000000000000000000000000000000;;			// typesPkg is where the versioned types are defined. Sometimes it is
0000000000000000000000000000000000000000;;			// different from pkg. For example, kubernetes core/v1 types are defined
0000000000000000000000000000000000000000;;			// in vendor/k8s.io/api/core/v1, while pkg is at pkg/api/v1.
0000000000000000000000000000000000000000;;			typesPkg := pkg
0000000000000000000000000000000000000000;;			if pkg == nil {
0000000000000000000000000000000000000000;;				// If the input had no Go files, for example.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add conversion and defaulting functions.
0000000000000000000000000000000000000000;;			getManualConversionFunctions(context, pkg, manualConversions)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Only generate conversions for packages which explicitly request it
0000000000000000000000000000000000000000;;			// by specifying one or more "+k8s:conversion-gen=<peer-pkg>"
0000000000000000000000000000000000000000;;			// in their doc.go file.
0000000000000000000000000000000000000000;;			peerPkgs := extractTag(pkg.Comments)
0000000000000000000000000000000000000000;;			if peerPkgs != nil {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("  tags: %q", peerPkgs)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("  no tag")
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			skipUnsafe := false
0000000000000000000000000000000000000000;;			if customArgs, ok := arguments.CustomArgs.(*CustomArgs); ok {
0000000000000000000000000000000000000000;;				if len(customArgs.ExtraPeerDirs) > 0 {
0000000000000000000000000000000000000000;;					peerPkgs = append(peerPkgs, customArgs.ExtraPeerDirs...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				skipUnsafe = customArgs.SkipUnsafe
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if the external types are not in the same package where the conversion functions to be generated
0000000000000000000000000000000000000000;;			externalTypesValues := extractExternalTypesTag(pkg.Comments)
0000000000000000000000000000000000000000;;			if externalTypesValues != nil {
0000000000000000000000000000000000000000;;				if len(externalTypesValues) != 1 {
0000000000000000000000000000000000000000;;					glog.Fatalf("  expect only one value for %q tag, got: %q", externalTypesTagName, externalTypesValues)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				externalTypes := externalTypesValues[0]
0000000000000000000000000000000000000000;;				glog.V(5).Infof("  external types tags: %q", externalTypes)
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				typesPkg, err = context.AddDirectory(filepath.Join(pkg.Path, externalTypes))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Fatalf("cannot import package %s", externalTypes)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// update context.Order to the latest context.Universe
0000000000000000000000000000000000000000;;				orderer := namer.Orderer{Namer: namer.NewPublicNamer(1)}
0000000000000000000000000000000000000000;;				context.Order = orderer.OrderUniverse(context.Universe)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if the source path is within a /vendor/ directory (for example,
0000000000000000000000000000000000000000;;			// k8s.io/kubernetes/vendor/k8s.io/apimachinery/pkg/apis/meta/v1), allow
0000000000000000000000000000000000000000;;			// generation to output to the proper relative path (under vendor).
0000000000000000000000000000000000000000;;			// Otherwise, the generator will create the file in the wrong location
0000000000000000000000000000000000000000;;			// in the output directory.
0000000000000000000000000000000000000000;;			// TODO: build a more fundamental concept in gengo for dealing with modifications
0000000000000000000000000000000000000000;;			// to vendored packages.
0000000000000000000000000000000000000000;;			vendorless := func(pkg string) string {
0000000000000000000000000000000000000000;;				if pos := strings.LastIndex(pkg, "/vendor/"); pos != -1 {
0000000000000000000000000000000000000000;;					return pkg[pos+len("/vendor/"):]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return pkg
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fqPkgPath := pkg.Path
0000000000000000000000000000000000000000;;			if strings.Contains(pkg.SourcePath, "/vendor/") {
0000000000000000000000000000000000000000;;				fqPkgPath = filepath.Join("k8s.io", "kubernetes", "vendor", pkg.Path)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := range peerPkgs {
0000000000000000000000000000000000000000;;				peerPkgs[i] = vendorless(peerPkgs[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Make sure our peer-packages are added and fully parsed.
0000000000000000000000000000000000000000;;			for _, pp := range peerPkgs {
0000000000000000000000000000000000000000;;				context.AddDir(pp)
0000000000000000000000000000000000000000;;				getManualConversionFunctions(context, context.Universe[pp], manualConversions)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			unsafeEquality := TypesEqual(memoryEquivalentTypes)
0000000000000000000000000000000000000000;;			if skipUnsafe {
0000000000000000000000000000000000000000;;				unsafeEquality = noEquality{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			packages = append(packages,
0000000000000000000000000000000000000000;;				&generator.DefaultPackage{
0000000000000000000000000000000000000000;;					PackageName: filepath.Base(pkg.Path),
0000000000000000000000000000000000000000;;					PackagePath: fqPkgPath,
0000000000000000000000000000000000000000;;					HeaderText:  header,
0000000000000000000000000000000000000000;;					GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
0000000000000000000000000000000000000000;;						return []generator.Generator{
0000000000000000000000000000000000000000;;							NewGenConversion(arguments.OutputFileBaseName, typesPkg.Path, pkg.Path, manualConversions, peerPkgs, unsafeEquality),
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					FilterFunc: func(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;						return t.Name.Package == typesPkg.Path
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If there is a manual conversion defined between two types, exclude it
0000000000000000000000000000000000000000;;		// from being a candidate for unsafe conversion
0000000000000000000000000000000000000000;;		for k, v := range manualConversions {
0000000000000000000000000000000000000000;;			if isCopyOnly(v.CommentLines) {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Conversion function %s will not block memory copy because it is copy-only", v.Name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// this type should be excluded from all equivalence, because the converter must be called.
0000000000000000000000000000000000000000;;			memoryEquivalentTypes.Skip(k.inType, k.outType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return packages
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type equalMemoryTypes map[conversionPair]bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e equalMemoryTypes) Skip(a, b *types.Type) {
0000000000000000000000000000000000000000;;		e[conversionPair{a, b}] = false
0000000000000000000000000000000000000000;;		e[conversionPair{b, a}] = false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e equalMemoryTypes) Equal(a, b *types.Type) bool {
0000000000000000000000000000000000000000;;		if a == b {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if equal, ok := e[conversionPair{a, b}]; ok {
0000000000000000000000000000000000000000;;			return equal
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if equal, ok := e[conversionPair{b, a}]; ok {
0000000000000000000000000000000000000000;;			return equal
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := e.equal(a, b)
0000000000000000000000000000000000000000;;		e[conversionPair{a, b}] = result
0000000000000000000000000000000000000000;;		e[conversionPair{b, a}] = result
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e equalMemoryTypes) equal(a, b *types.Type) bool {
0000000000000000000000000000000000000000;;		in, out := unwrapAlias(a), unwrapAlias(b)
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case in == out:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case in.Kind == out.Kind:
0000000000000000000000000000000000000000;;			switch in.Kind {
0000000000000000000000000000000000000000;;			case types.Struct:
0000000000000000000000000000000000000000;;				if len(in.Members) != len(out.Members) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for i, inMember := range in.Members {
0000000000000000000000000000000000000000;;					outMember := out.Members[i]
0000000000000000000000000000000000000000;;					if !e.Equal(inMember.Type, outMember.Type) {
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case types.Pointer:
0000000000000000000000000000000000000000;;				return e.Equal(in.Elem, out.Elem)
0000000000000000000000000000000000000000;;			case types.Map:
0000000000000000000000000000000000000000;;				return e.Equal(in.Key, out.Key) && e.Equal(in.Elem, out.Elem)
0000000000000000000000000000000000000000;;			case types.Slice:
0000000000000000000000000000000000000000;;				return e.Equal(in.Elem, out.Elem)
0000000000000000000000000000000000000000;;			case types.Interface:
0000000000000000000000000000000000000000;;				// TODO: determine whether the interfaces are actually equivalent - for now, they must have the
0000000000000000000000000000000000000000;;				// same type.
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			case types.Builtin:
0000000000000000000000000000000000000000;;				return in.Name.Name == out.Name.Name
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findMember(t *types.Type, name string) (types.Member, bool) {
0000000000000000000000000000000000000000;;		if t.Kind != types.Struct {
0000000000000000000000000000000000000000;;			return types.Member{}, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, member := range t.Members {
0000000000000000000000000000000000000000;;			if member.Name == name {
0000000000000000000000000000000000000000;;				return member, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return types.Member{}, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unwrapAlias recurses down aliased types to find the bedrock type.
0000000000000000000000000000000000000000;;	func unwrapAlias(in *types.Type) *types.Type {
0000000000000000000000000000000000000000;;		for in.Kind == types.Alias {
0000000000000000000000000000000000000000;;			in = in.Underlying
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return in
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		runtimePackagePath    = "k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		conversionPackagePath = "k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type noEquality struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (noEquality) Equal(_, _ *types.Type) bool { return false }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TypesEqual interface {
0000000000000000000000000000000000000000;;		Equal(a, b *types.Type) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// genConversion produces a file with a autogenerated conversions.
0000000000000000000000000000000000000000;;	type genConversion struct {
0000000000000000000000000000000000000000;;		generator.DefaultGen
0000000000000000000000000000000000000000;;		// the package that contains the types that conversion func are going to be
0000000000000000000000000000000000000000;;		// generated for
0000000000000000000000000000000000000000;;		typesPackage string
0000000000000000000000000000000000000000;;		// the package that the conversion funcs are going to be output to
0000000000000000000000000000000000000000;;		outputPackage string
0000000000000000000000000000000000000000;;		// packages that contain the peer of types in typesPacakge
0000000000000000000000000000000000000000;;		peerPackages      []string
0000000000000000000000000000000000000000;;		manualConversions conversionFuncMap
0000000000000000000000000000000000000000;;		imports           namer.ImportTracker
0000000000000000000000000000000000000000;;		types             []*types.Type
0000000000000000000000000000000000000000;;		skippedFields     map[*types.Type][]string
0000000000000000000000000000000000000000;;		useUnsafe         TypesEqual
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewGenConversion(sanitizedName, typesPackage, outputPackage string, manualConversions conversionFuncMap, peerPkgs []string, useUnsafe TypesEqual) generator.Generator {
0000000000000000000000000000000000000000;;		return &genConversion{
0000000000000000000000000000000000000000;;			DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;				OptionalName: sanitizedName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			typesPackage:      typesPackage,
0000000000000000000000000000000000000000;;			outputPackage:     outputPackage,
0000000000000000000000000000000000000000;;			peerPackages:      peerPkgs,
0000000000000000000000000000000000000000;;			manualConversions: manualConversions,
0000000000000000000000000000000000000000;;			imports:           generator.NewImportTracker(),
0000000000000000000000000000000000000000;;			types:             []*types.Type{},
0000000000000000000000000000000000000000;;			skippedFields:     map[*types.Type][]string{},
0000000000000000000000000000000000000000;;			useUnsafe:         useUnsafe,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genConversion) Namers(c *generator.Context) namer.NameSystems {
0000000000000000000000000000000000000000;;		// Have the raw namer for this file track what it imports.
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"raw": namer.NewRawNamer(g.outputPackage, g.imports),
0000000000000000000000000000000000000000;;			"publicIT": &namerPlusImportTracking{
0000000000000000000000000000000000000000;;				delegate: conversionNamer(),
0000000000000000000000000000000000000000;;				tracker:  g.imports,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type namerPlusImportTracking struct {
0000000000000000000000000000000000000000;;		delegate namer.Namer
0000000000000000000000000000000000000000;;		tracker  namer.ImportTracker
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *namerPlusImportTracking) Name(t *types.Type) string {
0000000000000000000000000000000000000000;;		n.tracker.AddType(t)
0000000000000000000000000000000000000000;;		return n.delegate.Name(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genConversion) convertibleOnlyWithinPackage(inType, outType *types.Type) bool {
0000000000000000000000000000000000000000;;		var t *types.Type
0000000000000000000000000000000000000000;;		var other *types.Type
0000000000000000000000000000000000000000;;		if inType.Name.Package == g.typesPackage {
0000000000000000000000000000000000000000;;			t, other = inType, outType
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t, other = outType, inType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t.Name.Package != g.typesPackage {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If the type has opted out, skip it.
0000000000000000000000000000000000000000;;		tagvals := extractTag(t.CommentLines)
0000000000000000000000000000000000000000;;		if tagvals != nil {
0000000000000000000000000000000000000000;;			if tagvals[0] != "false" {
0000000000000000000000000000000000000000;;				glog.Fatalf("Type %v: unsupported %s value: %q", t, tagName, tagvals[0])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(5).Infof("type %v requests no conversion generation, skipping", t)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: Consider generating functions for other kinds too.
0000000000000000000000000000000000000000;;		if t.Kind != types.Struct {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Also, filter out private types.
0000000000000000000000000000000000000000;;		if namer.IsPrivateGoName(other.Name.Name) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genConversion) Filter(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;		peerType := getPeerTypeFor(c, t, g.peerPackages)
0000000000000000000000000000000000000000;;		if peerType == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !g.convertibleOnlyWithinPackage(t, peerType) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.types = append(g.types, t)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genConversion) isOtherPackage(pkg string) bool {
0000000000000000000000000000000000000000;;		if pkg == g.outputPackage {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasSuffix(pkg, `"`+g.outputPackage+`"`) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genConversion) Imports(c *generator.Context) (imports []string) {
0000000000000000000000000000000000000000;;		var importLines []string
0000000000000000000000000000000000000000;;		for _, singleImport := range g.imports.ImportLines() {
0000000000000000000000000000000000000000;;			if g.isOtherPackage(singleImport) {
0000000000000000000000000000000000000000;;				importLines = append(importLines, singleImport)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return importLines
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func argsFromType(inType, outType *types.Type) generator.Args {
0000000000000000000000000000000000000000;;		return generator.Args{
0000000000000000000000000000000000000000;;			"inType":  inType,
0000000000000000000000000000000000000000;;			"outType": outType,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func defaultingArgsFromType(inType *types.Type) generator.Args {
0000000000000000000000000000000000000000;;		return generator.Args{
0000000000000000000000000000000000000000;;			"inType": inType,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const nameTmpl = "Convert_$.inType|publicIT$_To_$.outType|publicIT$"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genConversion) preexists(inType, outType *types.Type) (*types.Type, bool) {
0000000000000000000000000000000000000000;;		function, ok := g.manualConversions[conversionPair{inType, outType}]
0000000000000000000000000000000000000000;;		return function, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genConversion) Init(c *generator.Context, w io.Writer) error {
0000000000000000000000000000000000000000;;		if glog.V(5) {
0000000000000000000000000000000000000000;;			if m, ok := g.useUnsafe.(equalMemoryTypes); ok {
0000000000000000000000000000000000000000;;				var result []string
0000000000000000000000000000000000000000;;				glog.Infof("All objects without identical memory layout:")
0000000000000000000000000000000000000000;;				for k, v := range m {
0000000000000000000000000000000000000000;;					if v {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					result = append(result, fmt.Sprintf("  %s -> %s = %t", k.inType, k.outType, v))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sort.Strings(result)
0000000000000000000000000000000000000000;;				for _, s := range result {
0000000000000000000000000000000000000000;;					glog.Infof(s)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(w, c, "$", "$")
0000000000000000000000000000000000000000;;		sw.Do("func init() {\n", nil)
0000000000000000000000000000000000000000;;		sw.Do("localSchemeBuilder.Register(RegisterConversions)\n", nil)
0000000000000000000000000000000000000000;;		sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scheme := c.Universe.Type(types.Name{Package: runtimePackagePath, Name: "Scheme"})
0000000000000000000000000000000000000000;;		schemePtr := &types.Type{
0000000000000000000000000000000000000000;;			Kind: types.Pointer,
0000000000000000000000000000000000000000;;			Elem: scheme,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sw.Do("// RegisterConversions adds conversion functions to the given scheme.\n", nil)
0000000000000000000000000000000000000000;;		sw.Do("// Public to allow building arbitrary schemes.\n", nil)
0000000000000000000000000000000000000000;;		sw.Do("func RegisterConversions(scheme $.|raw$) error {\n", schemePtr)
0000000000000000000000000000000000000000;;		sw.Do("return scheme.AddGeneratedConversionFuncs(\n", nil)
0000000000000000000000000000000000000000;;		for _, t := range g.types {
0000000000000000000000000000000000000000;;			peerType := getPeerTypeFor(c, t, g.peerPackages)
0000000000000000000000000000000000000000;;			sw.Do(nameTmpl+",\n", argsFromType(t, peerType))
0000000000000000000000000000000000000000;;			sw.Do(nameTmpl+",\n", argsFromType(peerType, t))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sw.Do(")\n", nil)
0000000000000000000000000000000000000000;;		sw.Do("}\n\n", nil)
0000000000000000000000000000000000000000;;		return sw.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genConversion) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
0000000000000000000000000000000000000000;;		glog.V(5).Infof("generating for type %v", t)
0000000000000000000000000000000000000000;;		peerType := getPeerTypeFor(c, t, g.peerPackages)
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(w, c, "$", "$")
0000000000000000000000000000000000000000;;		g.generateConversion(t, peerType, sw)
0000000000000000000000000000000000000000;;		g.generateConversion(peerType, t, sw)
0000000000000000000000000000000000000000;;		return sw.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genConversion) generateConversion(inType, outType *types.Type, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		args := argsFromType(inType, outType).
0000000000000000000000000000000000000000;;			With("Scope", types.Ref(conversionPackagePath, "Scope"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sw.Do("func auto"+nameTmpl+"(in *$.inType|raw$, out *$.outType|raw$, s $.Scope|raw$) error {\n", args)
0000000000000000000000000000000000000000;;		g.generateFor(inType, outType, sw)
0000000000000000000000000000000000000000;;		sw.Do("return nil\n", nil)
0000000000000000000000000000000000000000;;		sw.Do("}\n\n", nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, found := g.preexists(inType, outType); found {
0000000000000000000000000000000000000000;;			// There is a public manual Conversion method: use it.
0000000000000000000000000000000000000000;;		} else if skipped := g.skippedFields[inType]; len(skipped) != 0 {
0000000000000000000000000000000000000000;;			// The inType had some fields we could not generate.
0000000000000000000000000000000000000000;;			glog.Errorf("Warning: could not find nor generate a final Conversion function for %v -> %v", inType, outType)
0000000000000000000000000000000000000000;;			glog.Errorf("  the following fields need manual conversion:")
0000000000000000000000000000000000000000;;			for _, f := range skipped {
0000000000000000000000000000000000000000;;				glog.Errorf("      - %v", f)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Emit a public conversion function.
0000000000000000000000000000000000000000;;			sw.Do("// "+nameTmpl+" is an autogenerated conversion function.\n", args)
0000000000000000000000000000000000000000;;			sw.Do("func "+nameTmpl+"(in *$.inType|raw$, out *$.outType|raw$, s $.Scope|raw$) error {\n", args)
0000000000000000000000000000000000000000;;			sw.Do("return auto"+nameTmpl+"(in, out, s)\n", args)
0000000000000000000000000000000000000000;;			sw.Do("}\n\n", nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// we use the system of shadowing 'in' and 'out' so that the same code is valid
0000000000000000000000000000000000000000;;	// at any nesting level. This makes the autogenerator easy to understand, and
0000000000000000000000000000000000000000;;	// the compiler shouldn't care.
0000000000000000000000000000000000000000;;	func (g *genConversion) generateFor(inType, outType *types.Type, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		glog.V(5).Infof("generating %v -> %v", inType, outType)
0000000000000000000000000000000000000000;;		var f func(*types.Type, *types.Type, *generator.SnippetWriter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch inType.Kind {
0000000000000000000000000000000000000000;;		case types.Builtin:
0000000000000000000000000000000000000000;;			f = g.doBuiltin
0000000000000000000000000000000000000000;;		case types.Map:
0000000000000000000000000000000000000000;;			f = g.doMap
0000000000000000000000000000000000000000;;		case types.Slice:
0000000000000000000000000000000000000000;;			f = g.doSlice
0000000000000000000000000000000000000000;;		case types.Struct:
0000000000000000000000000000000000000000;;			f = g.doStruct
0000000000000000000000000000000000000000;;		case types.Pointer:
0000000000000000000000000000000000000000;;			f = g.doPointer
0000000000000000000000000000000000000000;;		case types.Alias:
0000000000000000000000000000000000000000;;			f = g.doAlias
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			f = g.doUnknown
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f(inType, outType, sw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genConversion) doBuiltin(inType, outType *types.Type, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		if inType == outType {
0000000000000000000000000000000000000000;;			sw.Do("*out = *in\n", nil)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sw.Do("*out = $.|raw$(*in)\n", outType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genConversion) doMap(inType, outType *types.Type, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		sw.Do("*out = make($.|raw$, len(*in))\n", outType)
0000000000000000000000000000000000000000;;		if isDirectlyAssignable(inType.Key, outType.Key) {
0000000000000000000000000000000000000000;;			sw.Do("for key, val := range *in {\n", nil)
0000000000000000000000000000000000000000;;			if isDirectlyAssignable(inType.Elem, outType.Elem) {
0000000000000000000000000000000000000000;;				if inType.Key == outType.Key {
0000000000000000000000000000000000000000;;					sw.Do("(*out)[key] = ", nil)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					sw.Do("(*out)[$.|raw$(key)] = ", outType.Key)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if inType.Elem == outType.Elem {
0000000000000000000000000000000000000000;;					sw.Do("val\n", nil)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					sw.Do("$.|raw$(val)\n", outType.Elem)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				sw.Do("newVal := new($.|raw$)\n", outType.Elem)
0000000000000000000000000000000000000000;;				if function, ok := g.preexists(inType.Elem, outType.Elem); ok {
0000000000000000000000000000000000000000;;					sw.Do("if err := $.|raw$(&val, newVal, s); err != nil {\n", function)
0000000000000000000000000000000000000000;;				} else if g.convertibleOnlyWithinPackage(inType.Elem, outType.Elem) {
0000000000000000000000000000000000000000;;					sw.Do("if err := "+nameTmpl+"(&val, newVal, s); err != nil {\n", argsFromType(inType.Elem, outType.Elem))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					sw.Do("// TODO: Inefficient conversion - can we improve it?\n", nil)
0000000000000000000000000000000000000000;;					sw.Do("if err := s.Convert(&val, newVal, 0); err != nil {\n", nil)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sw.Do("return err\n", nil)
0000000000000000000000000000000000000000;;				sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;				if inType.Key == outType.Key {
0000000000000000000000000000000000000000;;					sw.Do("(*out)[key] = *newVal\n", nil)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					sw.Do("(*out)[$.|raw$(key)] = *newVal\n", outType.Key)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// TODO: Implement it when necessary.
0000000000000000000000000000000000000000;;			sw.Do("for range *in {\n", nil)
0000000000000000000000000000000000000000;;			sw.Do("// FIXME: Converting unassignable keys unsupported $.|raw$\n", inType.Key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genConversion) doSlice(inType, outType *types.Type, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		sw.Do("*out = make($.|raw$, len(*in))\n", outType)
0000000000000000000000000000000000000000;;		if inType.Elem == outType.Elem && inType.Elem.Kind == types.Builtin {
0000000000000000000000000000000000000000;;			sw.Do("copy(*out, *in)\n", nil)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sw.Do("for i := range *in {\n", nil)
0000000000000000000000000000000000000000;;			if isDirectlyAssignable(inType.Elem, outType.Elem) {
0000000000000000000000000000000000000000;;				if inType.Elem == outType.Elem {
0000000000000000000000000000000000000000;;					sw.Do("(*out)[i] = (*in)[i]\n", nil)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					sw.Do("(*out)[i] = $.|raw$((*in)[i])\n", outType.Elem)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if function, ok := g.preexists(inType.Elem, outType.Elem); ok {
0000000000000000000000000000000000000000;;					sw.Do("if err := $.|raw$(&(*in)[i], &(*out)[i], s); err != nil {\n", function)
0000000000000000000000000000000000000000;;				} else if g.convertibleOnlyWithinPackage(inType.Elem, outType.Elem) {
0000000000000000000000000000000000000000;;					sw.Do("if err := "+nameTmpl+"(&(*in)[i], &(*out)[i], s); err != nil {\n", argsFromType(inType.Elem, outType.Elem))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// TODO: This triggers on metav1.ObjectMeta <-> metav1.ObjectMeta and
0000000000000000000000000000000000000000;;					// similar because neither package is the target package, and
0000000000000000000000000000000000000000;;					// we really don't know which package will have the conversion
0000000000000000000000000000000000000000;;					// function defined.  This fires on basically every object
0000000000000000000000000000000000000000;;					// conversion outside of pkg/api/v1.
0000000000000000000000000000000000000000;;					sw.Do("// TODO: Inefficient conversion - can we improve it?\n", nil)
0000000000000000000000000000000000000000;;					sw.Do("if err := s.Convert(&(*in)[i], &(*out)[i], 0); err != nil {\n", nil)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sw.Do("return err\n", nil)
0000000000000000000000000000000000000000;;				sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genConversion) doStruct(inType, outType *types.Type, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		for _, inMember := range inType.Members {
0000000000000000000000000000000000000000;;			if tagvals := extractTag(inMember.CommentLines); tagvals != nil && tagvals[0] == "false" {
0000000000000000000000000000000000000000;;				// This field is excluded from conversion.
0000000000000000000000000000000000000000;;				sw.Do("// INFO: in."+inMember.Name+" opted out of conversion generation\n", nil)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			outMember, found := findMember(outType, inMember.Name)
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				// This field doesn't exist in the peer.
0000000000000000000000000000000000000000;;				sw.Do("// WARNING: in."+inMember.Name+" requires manual conversion: does not exist in peer-type\n", nil)
0000000000000000000000000000000000000000;;				g.skippedFields[inType] = append(g.skippedFields[inType], inMember.Name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			inMemberType, outMemberType := inMember.Type, outMember.Type
0000000000000000000000000000000000000000;;			// create a copy of both underlying types but give them the top level alias name (since aliases
0000000000000000000000000000000000000000;;			// are assignable)
0000000000000000000000000000000000000000;;			if underlying := unwrapAlias(inMemberType); underlying != inMemberType {
0000000000000000000000000000000000000000;;				copied := *underlying
0000000000000000000000000000000000000000;;				copied.Name = inMemberType.Name
0000000000000000000000000000000000000000;;				inMemberType = &copied
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if underlying := unwrapAlias(outMemberType); underlying != outMemberType {
0000000000000000000000000000000000000000;;				copied := *underlying
0000000000000000000000000000000000000000;;				copied.Name = outMemberType.Name
0000000000000000000000000000000000000000;;				outMemberType = &copied
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Determine if our destination field is a slice that should be output when empty.
0000000000000000000000000000000000000000;;			// If it is, ensure a nil source slice converts to a zero-length destination slice.
0000000000000000000000000000000000000000;;			// See http://issue.k8s.io/43203
0000000000000000000000000000000000000000;;			persistEmptySlice := false
0000000000000000000000000000000000000000;;			if outMemberType.Kind == types.Slice {
0000000000000000000000000000000000000000;;				jsonTag := reflect.StructTag(outMember.Tags).Get("json")
0000000000000000000000000000000000000000;;				persistEmptySlice = len(jsonTag) > 0 && !strings.Contains(jsonTag, ",omitempty")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			args := argsFromType(inMemberType, outMemberType).With("name", inMember.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// try a direct memory copy for any type that has exactly equivalent values
0000000000000000000000000000000000000000;;			if g.useUnsafe.Equal(inMemberType, outMemberType) {
0000000000000000000000000000000000000000;;				args = args.
0000000000000000000000000000000000000000;;					With("Pointer", types.Ref("unsafe", "Pointer")).
0000000000000000000000000000000000000000;;					With("SliceHeader", types.Ref("reflect", "SliceHeader"))
0000000000000000000000000000000000000000;;				switch inMemberType.Kind {
0000000000000000000000000000000000000000;;				case types.Pointer:
0000000000000000000000000000000000000000;;					sw.Do("out.$.name$ = ($.outType|raw$)($.Pointer|raw$(in.$.name$))\n", args)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				case types.Map:
0000000000000000000000000000000000000000;;					sw.Do("out.$.name$ = *(*$.outType|raw$)($.Pointer|raw$(&in.$.name$))\n", args)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				case types.Slice:
0000000000000000000000000000000000000000;;					if persistEmptySlice {
0000000000000000000000000000000000000000;;						sw.Do("if in.$.name$ == nil {\n", args)
0000000000000000000000000000000000000000;;						sw.Do("out.$.name$ = make($.outType|raw$, 0)\n", args)
0000000000000000000000000000000000000000;;						sw.Do("} else {\n", nil)
0000000000000000000000000000000000000000;;						sw.Do("out.$.name$ = *(*$.outType|raw$)($.Pointer|raw$(&in.$.name$))\n", args)
0000000000000000000000000000000000000000;;						sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						sw.Do("out.$.name$ = *(*$.outType|raw$)($.Pointer|raw$(&in.$.name$))\n", args)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// check based on the top level name, not the underlying names
0000000000000000000000000000000000000000;;			if function, ok := g.preexists(inMember.Type, outMember.Type); ok {
0000000000000000000000000000000000000000;;				if isDrop(function.CommentLines) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// copy-only functions that are directly assignable can be inlined instead of invoked.
0000000000000000000000000000000000000000;;				// As an example, conversion functions exist that allow types with private fields to be
0000000000000000000000000000000000000000;;				// correctly copied between types. These functions are equivalent to a memory assignment,
0000000000000000000000000000000000000000;;				// and are necessary for the reflection path, but should not block memory conversion.
0000000000000000000000000000000000000000;;				// Convert_unversioned_Time_to_unversioned_Time is an example of this logic.
0000000000000000000000000000000000000000;;				if !isCopyOnly(function.CommentLines) || !g.isFastConversion(inMemberType, outMemberType) {
0000000000000000000000000000000000000000;;					args["function"] = function
0000000000000000000000000000000000000000;;					sw.Do("if err := $.function|raw$(&in.$.name$, &out.$.name$, s); err != nil {\n", args)
0000000000000000000000000000000000000000;;					sw.Do("return err\n", nil)
0000000000000000000000000000000000000000;;					sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Skipped function %s because it is copy-only and we can use direct assignment", function.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If we can't auto-convert, punt before we emit any code.
0000000000000000000000000000000000000000;;			if inMemberType.Kind != outMemberType.Kind {
0000000000000000000000000000000000000000;;				sw.Do("// WARNING: in."+inMember.Name+" requires manual conversion: inconvertible types ("+
0000000000000000000000000000000000000000;;					inMemberType.String()+" vs "+outMemberType.String()+")\n", nil)
0000000000000000000000000000000000000000;;				g.skippedFields[inType] = append(g.skippedFields[inType], inMember.Name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch inMemberType.Kind {
0000000000000000000000000000000000000000;;			case types.Builtin:
0000000000000000000000000000000000000000;;				if inMemberType == outMemberType {
0000000000000000000000000000000000000000;;					sw.Do("out.$.name$ = in.$.name$\n", args)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					sw.Do("out.$.name$ = $.outType|raw$(in.$.name$)\n", args)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case types.Map, types.Slice, types.Pointer:
0000000000000000000000000000000000000000;;				if g.isDirectlyAssignable(inMemberType, outMemberType) {
0000000000000000000000000000000000000000;;					sw.Do("out.$.name$ = in.$.name$\n", args)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				sw.Do("if in.$.name$ != nil {\n", args)
0000000000000000000000000000000000000000;;				sw.Do("in, out := &in.$.name$, &out.$.name$\n", args)
0000000000000000000000000000000000000000;;				g.generateFor(inMemberType, outMemberType, sw)
0000000000000000000000000000000000000000;;				sw.Do("} else {\n", nil)
0000000000000000000000000000000000000000;;				if persistEmptySlice {
0000000000000000000000000000000000000000;;					sw.Do("out.$.name$ = make($.outType|raw$, 0)\n", args)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					sw.Do("out.$.name$ = nil\n", args)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;			case types.Struct:
0000000000000000000000000000000000000000;;				if g.isDirectlyAssignable(inMemberType, outMemberType) {
0000000000000000000000000000000000000000;;					sw.Do("out.$.name$ = in.$.name$\n", args)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if g.convertibleOnlyWithinPackage(inMemberType, outMemberType) {
0000000000000000000000000000000000000000;;					sw.Do("if err := "+nameTmpl+"(&in.$.name$, &out.$.name$, s); err != nil {\n", args)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					sw.Do("// TODO: Inefficient conversion - can we improve it?\n", nil)
0000000000000000000000000000000000000000;;					sw.Do("if err := s.Convert(&in.$.name$, &out.$.name$, 0); err != nil {\n", args)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sw.Do("return err\n", nil)
0000000000000000000000000000000000000000;;				sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;			case types.Alias:
0000000000000000000000000000000000000000;;				if isDirectlyAssignable(inMemberType, outMemberType) {
0000000000000000000000000000000000000000;;					if inMemberType == outMemberType {
0000000000000000000000000000000000000000;;						sw.Do("out.$.name$ = in.$.name$\n", args)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						sw.Do("out.$.name$ = $.outType|raw$(in.$.name$)\n", args)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if g.convertibleOnlyWithinPackage(inMemberType, outMemberType) {
0000000000000000000000000000000000000000;;						sw.Do("if err := "+nameTmpl+"(&in.$.name$, &out.$.name$, s); err != nil {\n", args)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						sw.Do("// TODO: Inefficient conversion - can we improve it?\n", nil)
0000000000000000000000000000000000000000;;						sw.Do("if err := s.Convert(&in.$.name$, &out.$.name$, 0); err != nil {\n", args)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					sw.Do("return err\n", nil)
0000000000000000000000000000000000000000;;					sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if g.convertibleOnlyWithinPackage(inMemberType, outMemberType) {
0000000000000000000000000000000000000000;;					sw.Do("if err := "+nameTmpl+"(&in.$.name$, &out.$.name$, s); err != nil {\n", args)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					sw.Do("// TODO: Inefficient conversion - can we improve it?\n", nil)
0000000000000000000000000000000000000000;;					sw.Do("if err := s.Convert(&in.$.name$, &out.$.name$, 0); err != nil {\n", args)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sw.Do("return err\n", nil)
0000000000000000000000000000000000000000;;				sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genConversion) isFastConversion(inType, outType *types.Type) bool {
0000000000000000000000000000000000000000;;		switch inType.Kind {
0000000000000000000000000000000000000000;;		case types.Builtin:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case types.Map, types.Slice, types.Pointer, types.Struct, types.Alias:
0000000000000000000000000000000000000000;;			return g.isDirectlyAssignable(inType, outType)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genConversion) isDirectlyAssignable(inType, outType *types.Type) bool {
0000000000000000000000000000000000000000;;		return unwrapAlias(inType) == unwrapAlias(outType)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genConversion) doPointer(inType, outType *types.Type, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		sw.Do("*out = new($.Elem|raw$)\n", outType)
0000000000000000000000000000000000000000;;		if isDirectlyAssignable(inType.Elem, outType.Elem) {
0000000000000000000000000000000000000000;;			if inType.Elem == outType.Elem {
0000000000000000000000000000000000000000;;				sw.Do("**out = **in\n", nil)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				sw.Do("**out = $.|raw$(**in)\n", outType.Elem)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if function, ok := g.preexists(inType.Elem, outType.Elem); ok {
0000000000000000000000000000000000000000;;				sw.Do("if err := $.|raw$(*in, *out, s); err != nil {\n", function)
0000000000000000000000000000000000000000;;			} else if g.convertibleOnlyWithinPackage(inType.Elem, outType.Elem) {
0000000000000000000000000000000000000000;;				sw.Do("if err := "+nameTmpl+"(*in, *out, s); err != nil {\n", argsFromType(inType.Elem, outType.Elem))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				sw.Do("// TODO: Inefficient conversion - can we improve it?\n", nil)
0000000000000000000000000000000000000000;;				sw.Do("if err := s.Convert(*in, *out, 0); err != nil {\n", nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sw.Do("return err\n", nil)
0000000000000000000000000000000000000000;;			sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genConversion) doAlias(inType, outType *types.Type, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		// TODO: Add support for aliases.
0000000000000000000000000000000000000000;;		g.doUnknown(inType, outType, sw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genConversion) doUnknown(inType, outType *types.Type, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		sw.Do("// FIXME: Type $.|raw$ is unsupported.\n", inType)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isDirectlyAssignable(inType, outType *types.Type) bool {
0000000000000000000000000000000000000000;;		// TODO: This should maybe check for actual assignability between the two
0000000000000000000000000000000000000000;;		// types, rather than superficial traits that happen to indicate it is
0000000000000000000000000000000000000000;;		// assignable in the ways we currently use this code.
0000000000000000000000000000000000000000;;		return inType.IsAssignable() && (inType.IsPrimitive() || isSamePackage(inType, outType))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isSamePackage(inType, outType *types.Type) bool {
0000000000000000000000000000000000000000;;		return inType.Name.Package == outType.Name.Package
0000000000000000000000000000000000000000;;	}
