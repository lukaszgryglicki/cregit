0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
0eddaa82cd8f1e2a7e1393606ef884ef767a6eaa;cmd/libs/go2idl/client-gen/generators/generator_for_scheme.go[cmd/libs/go2idl/client-gen/generators/generator_for_scheme.go][cmd/libs/go2idl/client-gen/generators/scheme/generator_for_scheme.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package scheme
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/path"
0000000000000000000000000000000000000000;;		clientgentypes "k8s.io/kubernetes/cmd/libs/go2idl/client-gen/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenScheme produces a package for a clientset with the scheme, codecs and parameter codecs.
0000000000000000000000000000000000000000;;	type GenScheme struct {
0000000000000000000000000000000000000000;;		generator.DefaultGen
0000000000000000000000000000000000000000;;		OutputPackage   string
0000000000000000000000000000000000000000;;		Groups          []clientgentypes.GroupVersions
0000000000000000000000000000000000000000;;		InputPackages   map[clientgentypes.GroupVersion]string
0000000000000000000000000000000000000000;;		OutputPath      string
0000000000000000000000000000000000000000;;		ImportTracker   namer.ImportTracker
0000000000000000000000000000000000000000;;		PrivateScheme   bool
0000000000000000000000000000000000000000;;		CreateRegistry  bool
0000000000000000000000000000000000000000;;		schemeGenerated bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *GenScheme) Namers(c *generator.Context) namer.NameSystems {
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"raw": namer.NewRawNamer(g.OutputPackage, g.ImportTracker),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// We only want to call GenerateType() once.
0000000000000000000000000000000000000000;;	func (g *GenScheme) Filter(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;		ret := !g.schemeGenerated
0000000000000000000000000000000000000000;;		g.schemeGenerated = true
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *GenScheme) Imports(c *generator.Context) (imports []string) {
0000000000000000000000000000000000000000;;		imports = append(imports, g.ImportTracker.ImportLines()...)
0000000000000000000000000000000000000000;;		for _, group := range g.Groups {
0000000000000000000000000000000000000000;;			for _, version := range group.Versions {
0000000000000000000000000000000000000000;;				packagePath := g.InputPackages[clientgentypes.GroupVersion{Group: group.Group, Version: version}]
0000000000000000000000000000000000000000;;				if g.CreateRegistry {
0000000000000000000000000000000000000000;;					// import the install package for internal clientsets instead of the type package with register.go
0000000000000000000000000000000000000000;;					if version != "" {
0000000000000000000000000000000000000000;;						packagePath = filepath.Dir(packagePath)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					packagePath = filepath.Join(packagePath, "install")
0000000000000000000000000000000000000000;;					imports = append(imports, strings.ToLower(fmt.Sprintf("%s \"%s\"", group.Group.NonEmpty(), path.Vendorless(packagePath))))
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					imports = append(imports, strings.ToLower(fmt.Sprintf("%s%s \"%s\"", group.Group.NonEmpty(), version.NonEmpty(), path.Vendorless(packagePath))))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *GenScheme) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(w, c, "$", "$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allGroupVersions := clientgentypes.ToGroupVersionPackages(g.Groups)
0000000000000000000000000000000000000000;;		allInstallGroups := clientgentypes.ToGroupInstallPackages(g.Groups)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := map[string]interface{}{
0000000000000000000000000000000000000000;;			"allGroupVersions":                 allGroupVersions,
0000000000000000000000000000000000000000;;			"allInstallGroups":                 allInstallGroups,
0000000000000000000000000000000000000000;;			"customRegister":                   false,
0000000000000000000000000000000000000000;;			"osGetenv":                         c.Universe.Function(types.Name{Package: "os", Name: "Getenv"}),
0000000000000000000000000000000000000000;;			"runtimeNewParameterCodec":         c.Universe.Function(types.Name{Package: "k8s.io/apimachinery/pkg/runtime", Name: "NewParameterCodec"}),
0000000000000000000000000000000000000000;;			"runtimeNewScheme":                 c.Universe.Function(types.Name{Package: "k8s.io/apimachinery/pkg/runtime", Name: "NewScheme"}),
0000000000000000000000000000000000000000;;			"serializerNewCodecFactory":        c.Universe.Function(types.Name{Package: "k8s.io/apimachinery/pkg/runtime/serializer", Name: "NewCodecFactory"}),
0000000000000000000000000000000000000000;;			"runtimeScheme":                    c.Universe.Type(types.Name{Package: "k8s.io/apimachinery/pkg/runtime", Name: "Scheme"}),
0000000000000000000000000000000000000000;;			"schemaGroupVersion":               c.Universe.Type(types.Name{Package: "k8s.io/apimachinery/pkg/runtime/schema", Name: "GroupVersion"}),
0000000000000000000000000000000000000000;;			"metav1AddToGroupVersion":          c.Universe.Function(types.Name{Package: "k8s.io/apimachinery/pkg/apis/meta/v1", Name: "AddToGroupVersion"}),
0000000000000000000000000000000000000000;;			"announcedAPIGroupFactoryRegistry": c.Universe.Type(types.Name{Package: "k8s.io/apimachinery/pkg/apimachinery/announced", Name: "APIGroupFactoryRegistry"}),
0000000000000000000000000000000000000000;;			"registeredNewOrDie":               c.Universe.Function(types.Name{Package: "k8s.io/apimachinery/pkg/apimachinery/registered", Name: "NewOrDie"}),
0000000000000000000000000000000000000000;;			"registeredAPIRegistrationManager": c.Universe.Type(types.Name{Package: "k8s.io/apimachinery/pkg/apimachinery/registered", Name: "APIRegistrationManager"}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		globals := map[string]string{
0000000000000000000000000000000000000000;;			"Scheme":               "Scheme",
0000000000000000000000000000000000000000;;			"Codecs":               "Codecs",
0000000000000000000000000000000000000000;;			"ParameterCodec":       "ParameterCodec",
0000000000000000000000000000000000000000;;			"Registry":             "Registry",
0000000000000000000000000000000000000000;;			"GroupFactoryRegistry": "GroupFactoryRegistry",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range globals {
0000000000000000000000000000000000000000;;			if g.PrivateScheme {
0000000000000000000000000000000000000000;;				m[k] = strings.ToLower(v[0:1]) + v[1:]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				m[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sw.Do(globalsTemplate, m)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if g.OutputPath != "" {
0000000000000000000000000000000000000000;;			if _, err := os.Stat(filepath.Join(g.OutputPath, strings.ToLower("register_custom.go"))); err == nil {
0000000000000000000000000000000000000000;;				m["customRegister"] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if g.CreateRegistry {
0000000000000000000000000000000000000000;;			sw.Do(registryRegistration, m)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sw.Do(simpleRegistration, m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sw.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var globalsTemplate = `
0000000000000000000000000000000000000000;;	var $.Scheme$ = $.runtimeNewScheme|raw$()
0000000000000000000000000000000000000000;;	var $.Codecs$ = $.serializerNewCodecFactory|raw$($.Scheme$)
0000000000000000000000000000000000000000;;	var $.ParameterCodec$ = $.runtimeNewParameterCodec|raw$($.Scheme$)
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var registryRegistration = `
0000000000000000000000000000000000000000;;	var $.Registry$ = $.registeredNewOrDie|raw$($.osGetenv|raw$("KUBE_API_VERSIONS"))
0000000000000000000000000000000000000000;;	var $.GroupFactoryRegistry$ = make($.announcedAPIGroupFactoryRegistry|raw$)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		$.metav1AddToGroupVersion|raw$($.Scheme$, $.schemaGroupVersion|raw${Version: "v1"})
0000000000000000000000000000000000000000;;		Install($.GroupFactoryRegistry$, $.Registry$, $.Scheme$)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Install registers the API group and adds types to a scheme
0000000000000000000000000000000000000000;;	func Install(groupFactoryRegistry $.announcedAPIGroupFactoryRegistry|raw$, registry *$.registeredAPIRegistrationManager|raw$, scheme *$.runtimeScheme|raw$) {
0000000000000000000000000000000000000000;;		$range .allInstallGroups$ $.InstallPackageName$.Install(groupFactoryRegistry, registry, scheme)
0000000000000000000000000000000000000000;;		$end$
0000000000000000000000000000000000000000;;		$if .customRegister$ExtraInstall(groupFactoryRegistry, registry, scheme)$end$
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var simpleRegistration = `
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		$.metav1AddToGroupVersion|raw$($.Scheme$, $.schemaGroupVersion|raw${Version: "v1"})
0000000000000000000000000000000000000000;;		AddToScheme($.Scheme$)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddToScheme adds all types of this clientset into the given scheme. This allows composition
0000000000000000000000000000000000000000;;	// of clientsets, like in:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   import (
0000000000000000000000000000000000000000;;	//     "k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;	//     clientsetscheme "k8s.io/client-go/kuberentes/scheme"
0000000000000000000000000000000000000000;;	//     aggregatorclientsetscheme "k8s.io/kube-aggregator/pkg/client/clientset_generated/clientset/scheme"
0000000000000000000000000000000000000000;;	//   )
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   kclientset, _ := kubernetes.NewForConfig(c)
0000000000000000000000000000000000000000;;	//   aggregatorclientsetscheme.AddToScheme(clientsetscheme.Scheme)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// After this, RawExtensions in Kubernetes types will serialize kube-aggregator types
0000000000000000000000000000000000000000;;	// correctly.
0000000000000000000000000000000000000000;;	func AddToScheme(scheme *$.runtimeScheme|raw$) {
0000000000000000000000000000000000000000;;		$range .allGroupVersions$ $.PackageName$.AddToScheme(scheme)
0000000000000000000000000000000000000000;;		$end$
0000000000000000000000000000000000000000;;		$if .customRegister$ExtraAddToScheme(scheme)$end$
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
