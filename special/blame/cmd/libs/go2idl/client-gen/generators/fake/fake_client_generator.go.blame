0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
d411520f4df7bcb85546106000dcbeb792b636a7;cmd/libs/go2idl/client-gen/generators/fake/fake-client-generator.go[cmd/libs/go2idl/client-gen/generators/fake/fake-client-generator.go][cmd/libs/go2idl/client-gen/generators/fake/fake_client_generator.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package fake
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;		clientgenargs "k8s.io/kubernetes/cmd/libs/go2idl/client-gen/args"
0000000000000000000000000000000000000000;;		scheme "k8s.io/kubernetes/cmd/libs/go2idl/client-gen/generators/scheme"
0000000000000000000000000000000000000000;;		clientgentypes "k8s.io/kubernetes/cmd/libs/go2idl/client-gen/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PackageForGroup(gv clientgentypes.GroupVersion, typeList []*types.Type, clientsetPackage string, inputPackage string, boilerplate []byte, generatedBy string) generator.Package {
0000000000000000000000000000000000000000;;		outputPackage := strings.ToLower(filepath.Join(clientsetPackage, "typed", gv.Group.NonEmpty(), gv.Version.NonEmpty(), "fake"))
0000000000000000000000000000000000000000;;		// TODO: should make this a function, called by here and in client-generator.go
0000000000000000000000000000000000000000;;		realClientPackage := filepath.Join(clientsetPackage, "typed", gv.Group.NonEmpty(), gv.Version.NonEmpty())
0000000000000000000000000000000000000000;;		return &generator.DefaultPackage{
0000000000000000000000000000000000000000;;			PackageName: "fake",
0000000000000000000000000000000000000000;;			PackagePath: outputPackage,
0000000000000000000000000000000000000000;;			HeaderText:  boilerplate,
0000000000000000000000000000000000000000;;			PackageDocumentation: []byte(
0000000000000000000000000000000000000000;;				generatedBy +
0000000000000000000000000000000000000000;;					`// Package fake has the automatically generated clients.
0000000000000000000000000000000000000000;;	`),
0000000000000000000000000000000000000000;;			// GeneratorFunc returns a list of generators. Each generator makes a
0000000000000000000000000000000000000000;;			// single file.
0000000000000000000000000000000000000000;;			GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
0000000000000000000000000000000000000000;;				generators = []generator.Generator{
0000000000000000000000000000000000000000;;					// Always generate a "doc.go" file.
0000000000000000000000000000000000000000;;					generator.DefaultGen{OptionalName: "doc"},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Since we want a file per type that we generate a client for, we
0000000000000000000000000000000000000000;;				// have to provide a function for this.
0000000000000000000000000000000000000000;;				for _, t := range typeList {
0000000000000000000000000000000000000000;;					generators = append(generators, &genFakeForType{
0000000000000000000000000000000000000000;;						DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;							OptionalName: "fake_" + strings.ToLower(c.Namers["private"].Name(t)),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						outputPackage: outputPackage,
0000000000000000000000000000000000000000;;						inputPackage:  inputPackage,
0000000000000000000000000000000000000000;;						group:         gv.Group.NonEmpty(),
0000000000000000000000000000000000000000;;						version:       gv.Version.String(),
0000000000000000000000000000000000000000;;						typeToMatch:   t,
0000000000000000000000000000000000000000;;						imports:       generator.NewImportTracker(),
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				generators = append(generators, &genFakeForGroup{
0000000000000000000000000000000000000000;;					DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;						OptionalName: "fake_" + gv.Group.NonEmpty() + "_client",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					outputPackage:     outputPackage,
0000000000000000000000000000000000000000;;					realClientPackage: realClientPackage,
0000000000000000000000000000000000000000;;					group:             gv.Group.NonEmpty(),
0000000000000000000000000000000000000000;;					version:           gv.Version.String(),
0000000000000000000000000000000000000000;;					types:             typeList,
0000000000000000000000000000000000000000;;					imports:           generator.NewImportTracker(),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				return generators
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			FilterFunc: func(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;				return extractBoolTagOrDie("genclient", t.SecondClosestCommentLines) == true
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractBoolTagOrDie(key string, lines []string) bool {
0000000000000000000000000000000000000000;;		val, err := types.ExtractSingleBoolCommentTag("+", key, false, lines)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PackageForClientset(customArgs clientgenargs.Args, fakeClientsetPackage string, boilerplate []byte, generatedBy string) generator.Package {
0000000000000000000000000000000000000000;;		return &generator.DefaultPackage{
0000000000000000000000000000000000000000;;			// TODO: we'll generate fake clientset for different release in the future.
0000000000000000000000000000000000000000;;			// Package name and path are hard coded for now.
0000000000000000000000000000000000000000;;			PackageName: "fake",
0000000000000000000000000000000000000000;;			PackagePath: filepath.Join(fakeClientsetPackage, "fake"),
0000000000000000000000000000000000000000;;			HeaderText:  boilerplate,
0000000000000000000000000000000000000000;;			PackageDocumentation: []byte(
0000000000000000000000000000000000000000;;				generatedBy +
0000000000000000000000000000000000000000;;					`// This package has the automatically generated fake clientset.
0000000000000000000000000000000000000000;;	`),
0000000000000000000000000000000000000000;;			// GeneratorFunc returns a list of generators. Each generator generates a
0000000000000000000000000000000000000000;;			// single file.
0000000000000000000000000000000000000000;;			GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
0000000000000000000000000000000000000000;;				generators = []generator.Generator{
0000000000000000000000000000000000000000;;					// Always generate a "doc.go" file.
0000000000000000000000000000000000000000;;					generator.DefaultGen{OptionalName: "doc"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					&genClientset{
0000000000000000000000000000000000000000;;						DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;							OptionalName: "clientset_generated",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						groups:               customArgs.Groups,
0000000000000000000000000000000000000000;;						fakeClientsetPackage: fakeClientsetPackage,
0000000000000000000000000000000000000000;;						outputPackage:        "fake",
0000000000000000000000000000000000000000;;						imports:              generator.NewImportTracker(),
0000000000000000000000000000000000000000;;						realClientsetPackage: filepath.Join(customArgs.ClientsetOutputPath, customArgs.ClientsetName),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					&scheme.GenScheme{
0000000000000000000000000000000000000000;;						DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;							OptionalName: "register",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						InputPackages: customArgs.GroupVersionToInputPath,
0000000000000000000000000000000000000000;;						OutputPackage: fakeClientsetPackage,
0000000000000000000000000000000000000000;;						Groups:        customArgs.Groups,
0000000000000000000000000000000000000000;;						ImportTracker: generator.NewImportTracker(),
0000000000000000000000000000000000000000;;						PrivateScheme: true,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return generators
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
