0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
09be7eecf899805a7bc59a2119b475307567b5d8;cmd/libs/go2idl/client-gen/generators/generator-for-type.go[cmd/libs/go2idl/client-gen/generators/generator-for-type.go][cmd/libs/go2idl/client-gen/generators/generator_for_type.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package generators
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// genClientForType produces a file for each top-level type.
0000000000000000000000000000000000000000;;	type genClientForType struct {
0000000000000000000000000000000000000000;;		generator.DefaultGen
0000000000000000000000000000000000000000;;		outputPackage    string
0000000000000000000000000000000000000000;;		clientsetPackage string
0000000000000000000000000000000000000000;;		group            string
0000000000000000000000000000000000000000;;		version          string
0000000000000000000000000000000000000000;;		typeToMatch      *types.Type
0000000000000000000000000000000000000000;;		imports          namer.ImportTracker
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ generator.Generator = &genClientForType{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Filter ignores all but one type because we're making a single file per type.
0000000000000000000000000000000000000000;;	func (g *genClientForType) Filter(c *generator.Context, t *types.Type) bool { return t == g.typeToMatch }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genClientForType) Namers(c *generator.Context) namer.NameSystems {
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"raw": namer.NewRawNamer(g.outputPackage, g.imports),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genClientForType) Imports(c *generator.Context) (imports []string) {
0000000000000000000000000000000000000000;;		return g.imports.ImportLines()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ideally, we'd like genStatus to return true if there is a subresource path
0000000000000000000000000000000000000000;;	// registered for "status" in the API server, but we do not have that
0000000000000000000000000000000000000000;;	// information, so genStatus returns true if the type has a status field.
0000000000000000000000000000000000000000;;	func genStatus(t *types.Type) bool {
0000000000000000000000000000000000000000;;		// Default to true if we have a Status member
0000000000000000000000000000000000000000;;		hasStatus := false
0000000000000000000000000000000000000000;;		for _, m := range t.Members {
0000000000000000000000000000000000000000;;			if m.Name == "Status" {
0000000000000000000000000000000000000000;;				hasStatus = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow overriding via a comment on the type
0000000000000000000000000000000000000000;;		genStatus, err := types.ExtractSingleBoolCommentTag("+", "genclientstatus", hasStatus, t.SecondClosestCommentLines)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Printf("error looking up +genclientstatus: %v\n", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return genStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenerateType makes the body of a file implementing the individual typed client for type t.
0000000000000000000000000000000000000000;;	func (g *genClientForType) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(w, c, "$", "$")
0000000000000000000000000000000000000000;;		pkg := filepath.Base(t.Name.Package)
0000000000000000000000000000000000000000;;		namespaced := !extractBoolTagOrDie("nonNamespaced", t.SecondClosestCommentLines)
0000000000000000000000000000000000000000;;		m := map[string]interface{}{
0000000000000000000000000000000000000000;;			"type":                 t,
0000000000000000000000000000000000000000;;			"package":              pkg,
0000000000000000000000000000000000000000;;			"Package":              namer.IC(pkg),
0000000000000000000000000000000000000000;;			"namespaced":           namespaced,
0000000000000000000000000000000000000000;;			"Group":                namer.IC(g.group),
0000000000000000000000000000000000000000;;			"GroupVersion":         namer.IC(g.group) + namer.IC(g.version),
0000000000000000000000000000000000000000;;			"DeleteOptions":        c.Universe.Type(types.Name{Package: "k8s.io/apimachinery/pkg/apis/meta/v1", Name: "DeleteOptions"}),
0000000000000000000000000000000000000000;;			"ListOptions":          c.Universe.Type(types.Name{Package: "k8s.io/apimachinery/pkg/apis/meta/v1", Name: "ListOptions"}),
0000000000000000000000000000000000000000;;			"GetOptions":           c.Universe.Type(types.Name{Package: "k8s.io/apimachinery/pkg/apis/meta/v1", Name: "GetOptions"}),
0000000000000000000000000000000000000000;;			"PatchType":            c.Universe.Type(types.Name{Package: "k8s.io/apimachinery/pkg/types", Name: "PatchType"}),
0000000000000000000000000000000000000000;;			"watchInterface":       c.Universe.Type(types.Name{Package: "k8s.io/apimachinery/pkg/watch", Name: "Interface"}),
0000000000000000000000000000000000000000;;			"RESTClientInterface":  c.Universe.Type(types.Name{Package: "k8s.io/client-go/rest", Name: "Interface"}),
0000000000000000000000000000000000000000;;			"schemeParameterCodec": c.Universe.Variable(types.Name{Package: filepath.Join(g.clientsetPackage, "scheme"), Name: "ParameterCodec"}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sw.Do(getterComment, m)
0000000000000000000000000000000000000000;;		if namespaced {
0000000000000000000000000000000000000000;;			sw.Do(getterNamesapced, m)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sw.Do(getterNonNamesapced, m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		noMethods := extractBoolTagOrDie("noMethods", t.SecondClosestCommentLines) == true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		readonly := extractBoolTagOrDie("readonly", t.SecondClosestCommentLines) == true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sw.Do(interfaceTemplate1, m)
0000000000000000000000000000000000000000;;		if !noMethods {
0000000000000000000000000000000000000000;;			if readonly {
0000000000000000000000000000000000000000;;				sw.Do(interfaceTemplateReadonly, m)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				sw.Do(interfaceTemplate2, m)
0000000000000000000000000000000000000000;;				// Include the UpdateStatus method if the type has a status
0000000000000000000000000000000000000000;;				if genStatus(t) {
0000000000000000000000000000000000000000;;					sw.Do(interfaceUpdateStatusTemplate, m)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sw.Do(interfaceTemplate3, m)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sw.Do(interfaceTemplate4, m)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if namespaced {
0000000000000000000000000000000000000000;;			sw.Do(structNamespaced, m)
0000000000000000000000000000000000000000;;			sw.Do(newStructNamespaced, m)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sw.Do(structNonNamespaced, m)
0000000000000000000000000000000000000000;;			sw.Do(newStructNonNamespaced, m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !noMethods && !readonly {
0000000000000000000000000000000000000000;;			sw.Do(createTemplate, m)
0000000000000000000000000000000000000000;;			sw.Do(updateTemplate, m)
0000000000000000000000000000000000000000;;			// Generate the UpdateStatus method if the type has a status
0000000000000000000000000000000000000000;;			if genStatus(t) {
0000000000000000000000000000000000000000;;				sw.Do(updateStatusTemplate, m)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sw.Do(deleteTemplate, m)
0000000000000000000000000000000000000000;;			sw.Do(deleteCollectionTemplate, m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !noMethods {
0000000000000000000000000000000000000000;;			sw.Do(getTemplate, m)
0000000000000000000000000000000000000000;;			sw.Do(listTemplate, m)
0000000000000000000000000000000000000000;;			sw.Do(watchTemplate, m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !noMethods && !readonly {
0000000000000000000000000000000000000000;;			sw.Do(patchTemplate, m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sw.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// group client will implement this interface.
0000000000000000000000000000000000000000;;	var getterComment = `
0000000000000000000000000000000000000000;;	// $.type|publicPlural$Getter has a method to return a $.type|public$Interface.
0000000000000000000000000000000000000000;;	// A group's client should implement this interface.`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var getterNamesapced = `
0000000000000000000000000000000000000000;;	type $.type|publicPlural$Getter interface {
0000000000000000000000000000000000000000;;		$.type|publicPlural$(namespace string) $.type|public$Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var getterNonNamesapced = `
0000000000000000000000000000000000000000;;	type $.type|publicPlural$Getter interface {
0000000000000000000000000000000000000000;;		$.type|publicPlural$() $.type|public$Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// this type's interface, typed client will implement this interface.
0000000000000000000000000000000000000000;;	var interfaceTemplate1 = `
0000000000000000000000000000000000000000;;	// $.type|public$Interface has methods to work with $.type|public$ resources.
0000000000000000000000000000000000000000;;	type $.type|public$Interface interface {`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var interfaceTemplate2 = `
0000000000000000000000000000000000000000;;		Create(*$.type|raw$) (*$.type|raw$, error)
0000000000000000000000000000000000000000;;		Update(*$.type|raw$) (*$.type|raw$, error)`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var interfaceUpdateStatusTemplate = `
0000000000000000000000000000000000000000;;		UpdateStatus(*$.type|raw$) (*$.type|raw$, error)`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// template for the Interface
0000000000000000000000000000000000000000;;	var interfaceTemplate3 = `
0000000000000000000000000000000000000000;;		Delete(name string, options *$.DeleteOptions|raw$) error
0000000000000000000000000000000000000000;;		DeleteCollection(options *$.DeleteOptions|raw$, listOptions $.ListOptions|raw$) error
0000000000000000000000000000000000000000;;		Get(name string, options $.GetOptions|raw$) (*$.type|raw$, error)
0000000000000000000000000000000000000000;;		List(opts $.ListOptions|raw$) (*$.type|raw$List, error)
0000000000000000000000000000000000000000;;		Watch(opts $.ListOptions|raw$) ($.watchInterface|raw$, error)
0000000000000000000000000000000000000000;;		Patch(name string, pt $.PatchType|raw$, data []byte, subresources ...string) (result *$.type|raw$, err error)`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var interfaceTemplateReadonly = `
0000000000000000000000000000000000000000;;		Get(name string, options $.GetOptions|raw$) (*$.type|raw$, error)
0000000000000000000000000000000000000000;;		List(opts $.ListOptions|raw$) (*$.type|raw$List, error)
0000000000000000000000000000000000000000;;		Watch(opts $.ListOptions|raw$) ($.watchInterface|raw$, error)`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var interfaceTemplate4 = `
0000000000000000000000000000000000000000;;		$.type|public$Expansion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// template for the struct that implements the type's interface
0000000000000000000000000000000000000000;;	var structNamespaced = `
0000000000000000000000000000000000000000;;	// $.type|privatePlural$ implements $.type|public$Interface
0000000000000000000000000000000000000000;;	type $.type|privatePlural$ struct {
0000000000000000000000000000000000000000;;		client $.RESTClientInterface|raw$
0000000000000000000000000000000000000000;;		ns     string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// template for the struct that implements the type's interface
0000000000000000000000000000000000000000;;	var structNonNamespaced = `
0000000000000000000000000000000000000000;;	// $.type|privatePlural$ implements $.type|public$Interface
0000000000000000000000000000000000000000;;	type $.type|privatePlural$ struct {
0000000000000000000000000000000000000000;;		client $.RESTClientInterface|raw$
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var newStructNamespaced = `
0000000000000000000000000000000000000000;;	// new$.type|publicPlural$ returns a $.type|publicPlural$
0000000000000000000000000000000000000000;;	func new$.type|publicPlural$(c *$.GroupVersion$Client, namespace string) *$.type|privatePlural$ {
0000000000000000000000000000000000000000;;		return &$.type|privatePlural${
0000000000000000000000000000000000000000;;			client: c.RESTClient(),
0000000000000000000000000000000000000000;;			ns:     namespace,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var newStructNonNamespaced = `
0000000000000000000000000000000000000000;;	// new$.type|publicPlural$ returns a $.type|publicPlural$
0000000000000000000000000000000000000000;;	func new$.type|publicPlural$(c *$.GroupVersion$Client) *$.type|privatePlural$ {
0000000000000000000000000000000000000000;;		return &$.type|privatePlural${
0000000000000000000000000000000000000000;;			client: c.RESTClient(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var listTemplate = `
0000000000000000000000000000000000000000;;	// List takes label and field selectors, and returns the list of $.type|publicPlural$ that match those selectors.
0000000000000000000000000000000000000000;;	func (c *$.type|privatePlural$) List(opts $.ListOptions|raw$) (result *$.type|raw$List, err error) {
0000000000000000000000000000000000000000;;		result = &$.type|raw$List{}
0000000000000000000000000000000000000000;;		err = c.client.Get().
0000000000000000000000000000000000000000;;			$if .namespaced$Namespace(c.ns).$end$
0000000000000000000000000000000000000000;;			Resource("$.type|resource$").
0000000000000000000000000000000000000000;;			VersionedParams(&opts, $.schemeParameterCodec|raw$).
0000000000000000000000000000000000000000;;			Do().
0000000000000000000000000000000000000000;;			Into(result)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	var getTemplate = `
0000000000000000000000000000000000000000;;	// Get takes name of the $.type|private$, and returns the corresponding $.type|private$ object, and an error if there is any.
0000000000000000000000000000000000000000;;	func (c *$.type|privatePlural$) Get(name string, options $.GetOptions|raw$) (result *$.type|raw$, err error) {
0000000000000000000000000000000000000000;;		result = &$.type|raw${}
0000000000000000000000000000000000000000;;		err = c.client.Get().
0000000000000000000000000000000000000000;;			$if .namespaced$Namespace(c.ns).$end$
0000000000000000000000000000000000000000;;			Resource("$.type|resource$").
0000000000000000000000000000000000000000;;			Name(name).
0000000000000000000000000000000000000000;;			VersionedParams(&options, $.schemeParameterCodec|raw$).
0000000000000000000000000000000000000000;;			Do().
0000000000000000000000000000000000000000;;			Into(result)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var deleteTemplate = `
0000000000000000000000000000000000000000;;	// Delete takes name of the $.type|private$ and deletes it. Returns an error if one occurs.
0000000000000000000000000000000000000000;;	func (c *$.type|privatePlural$) Delete(name string, options *$.DeleteOptions|raw$) error {
0000000000000000000000000000000000000000;;		return c.client.Delete().
0000000000000000000000000000000000000000;;			$if .namespaced$Namespace(c.ns).$end$
0000000000000000000000000000000000000000;;			Resource("$.type|resource$").
0000000000000000000000000000000000000000;;			Name(name).
0000000000000000000000000000000000000000;;			Body(options).
0000000000000000000000000000000000000000;;			Do().
0000000000000000000000000000000000000000;;			Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var deleteCollectionTemplate = `
0000000000000000000000000000000000000000;;	// DeleteCollection deletes a collection of objects.
0000000000000000000000000000000000000000;;	func (c *$.type|privatePlural$) DeleteCollection(options *$.DeleteOptions|raw$, listOptions $.ListOptions|raw$) error {
0000000000000000000000000000000000000000;;		return c.client.Delete().
0000000000000000000000000000000000000000;;			$if .namespaced$Namespace(c.ns).$end$
0000000000000000000000000000000000000000;;			Resource("$.type|resource$").
0000000000000000000000000000000000000000;;			VersionedParams(&listOptions, $.schemeParameterCodec|raw$).
0000000000000000000000000000000000000000;;			Body(options).
0000000000000000000000000000000000000000;;			Do().
0000000000000000000000000000000000000000;;			Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var createTemplate = `
0000000000000000000000000000000000000000;;	// Create takes the representation of a $.type|private$ and creates it.  Returns the server's representation of the $.type|private$, and an error, if there is any.
0000000000000000000000000000000000000000;;	func (c *$.type|privatePlural$) Create($.type|private$ *$.type|raw$) (result *$.type|raw$, err error) {
0000000000000000000000000000000000000000;;		result = &$.type|raw${}
0000000000000000000000000000000000000000;;		err = c.client.Post().
0000000000000000000000000000000000000000;;			$if .namespaced$Namespace(c.ns).$end$
0000000000000000000000000000000000000000;;			Resource("$.type|resource$").
0000000000000000000000000000000000000000;;			Body($.type|private$).
0000000000000000000000000000000000000000;;			Do().
0000000000000000000000000000000000000000;;			Into(result)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var updateTemplate = `
0000000000000000000000000000000000000000;;	// Update takes the representation of a $.type|private$ and updates it. Returns the server's representation of the $.type|private$, and an error, if there is any.
0000000000000000000000000000000000000000;;	func (c *$.type|privatePlural$) Update($.type|private$ *$.type|raw$) (result *$.type|raw$, err error) {
0000000000000000000000000000000000000000;;		result = &$.type|raw${}
0000000000000000000000000000000000000000;;		err = c.client.Put().
0000000000000000000000000000000000000000;;			$if .namespaced$Namespace(c.ns).$end$
0000000000000000000000000000000000000000;;			Resource("$.type|resource$").
0000000000000000000000000000000000000000;;			Name($.type|private$.Name).
0000000000000000000000000000000000000000;;			Body($.type|private$).
0000000000000000000000000000000000000000;;			Do().
0000000000000000000000000000000000000000;;			Into(result)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var updateStatusTemplate = `
0000000000000000000000000000000000000000;;	// UpdateStatus was generated because the type contains a Status member.
0000000000000000000000000000000000000000;;	// Add a +genclientstatus=false comment above the type to avoid generating UpdateStatus().
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *$.type|privatePlural$) UpdateStatus($.type|private$ *$.type|raw$) (result *$.type|raw$, err error) {
0000000000000000000000000000000000000000;;		result = &$.type|raw${}
0000000000000000000000000000000000000000;;		err = c.client.Put().
0000000000000000000000000000000000000000;;			$if .namespaced$Namespace(c.ns).$end$
0000000000000000000000000000000000000000;;			Resource("$.type|resource$").
0000000000000000000000000000000000000000;;			Name($.type|private$.Name).
0000000000000000000000000000000000000000;;			SubResource("status").
0000000000000000000000000000000000000000;;			Body($.type|private$).
0000000000000000000000000000000000000000;;			Do().
0000000000000000000000000000000000000000;;			Into(result)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var watchTemplate = `
0000000000000000000000000000000000000000;;	// Watch returns a $.watchInterface|raw$ that watches the requested $.type|privatePlural$.
0000000000000000000000000000000000000000;;	func (c *$.type|privatePlural$) Watch(opts $.ListOptions|raw$) ($.watchInterface|raw$, error) {
0000000000000000000000000000000000000000;;		opts.Watch = true
0000000000000000000000000000000000000000;;		return c.client.Get().
0000000000000000000000000000000000000000;;			$if .namespaced$Namespace(c.ns).$end$
0000000000000000000000000000000000000000;;			Resource("$.type|resource$").
0000000000000000000000000000000000000000;;			VersionedParams(&opts, $.schemeParameterCodec|raw$).
0000000000000000000000000000000000000000;;			Watch()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var patchTemplate = `
0000000000000000000000000000000000000000;;	// Patch applies the patch and returns the patched $.type|private$.
0000000000000000000000000000000000000000;;	func (c *$.type|privatePlural$) Patch(name string, pt $.PatchType|raw$, data []byte, subresources ...string) (result *$.type|raw$, err error) {
0000000000000000000000000000000000000000;;		result = &$.type|raw${}
0000000000000000000000000000000000000000;;		err = c.client.Patch(pt).
0000000000000000000000000000000000000000;;			$if .namespaced$Namespace(c.ns).$end$
0000000000000000000000000000000000000000;;			Resource("$.type|resource$").
0000000000000000000000000000000000000000;;			SubResource(subresources...).
0000000000000000000000000000000000000000;;			Name(name).
0000000000000000000000000000000000000000;;			Body(data).
0000000000000000000000000000000000000000;;			Do().
0000000000000000000000000000000000000000;;			Into(result)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
