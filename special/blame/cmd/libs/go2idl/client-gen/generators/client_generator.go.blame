0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
09be7eecf899805a7bc59a2119b475307567b5d8;cmd/libs/go2idl/client-gen/generators/client-generator.go[cmd/libs/go2idl/client-gen/generators/client-generator.go][cmd/libs/go2idl/client-gen/generators/client_generator.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package generators has the generators for the client-gen utility.
0000000000000000000000000000000000000000;;	package generators
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/args"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;		clientgenargs "k8s.io/kubernetes/cmd/libs/go2idl/client-gen/args"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/generators/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/generators/scheme"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/path"
0000000000000000000000000000000000000000;;		clientgentypes "k8s.io/kubernetes/cmd/libs/go2idl/client-gen/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameSystems returns the name system used by the generators in this package.
0000000000000000000000000000000000000000;;	func NameSystems() namer.NameSystems {
0000000000000000000000000000000000000000;;		pluralExceptions := map[string]string{
0000000000000000000000000000000000000000;;			"Endpoints": "Endpoints",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lowercaseNamer := namer.NewAllLowercasePluralNamer(pluralExceptions)
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"public":             namer.NewPublicNamer(0),
0000000000000000000000000000000000000000;;			"private":            namer.NewPrivateNamer(0),
0000000000000000000000000000000000000000;;			"raw":                namer.NewRawNamer("", nil),
0000000000000000000000000000000000000000;;			"publicPlural":       namer.NewPublicPluralNamer(pluralExceptions),
0000000000000000000000000000000000000000;;			"privatePlural":      namer.NewPrivatePluralNamer(pluralExceptions),
0000000000000000000000000000000000000000;;			"allLowercasePlural": lowercaseNamer,
0000000000000000000000000000000000000000;;			"resource":           NewTagOverrideNamer("resourceName", lowercaseNamer),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultNameSystem returns the default name system for ordering the types to be
0000000000000000000000000000000000000000;;	// processed by the generators in this package.
0000000000000000000000000000000000000000;;	func DefaultNameSystem() string {
0000000000000000000000000000000000000000;;		return "public"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generatedBy(customArgs clientgenargs.Args) string {
0000000000000000000000000000000000000000;;		if len(customArgs.CmdArgs) != 0 {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("\n// This package is generated by client-gen with custom arguments.\n\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("\n// This package is generated by client-gen with the default arguments.\n\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packageForGroup(gv clientgentypes.GroupVersion, typeList []*types.Type, clientsetPackage string, apiPath string, srcTreePath string, inputPackage string, boilerplate []byte, generatedBy string) generator.Package {
0000000000000000000000000000000000000000;;		groupVersionClientPackage := strings.ToLower(filepath.Join(clientsetPackage, "typed", gv.Group.NonEmpty(), gv.Version.NonEmpty()))
0000000000000000000000000000000000000000;;		return &generator.DefaultPackage{
0000000000000000000000000000000000000000;;			PackageName: strings.ToLower(gv.Version.NonEmpty()),
0000000000000000000000000000000000000000;;			PackagePath: groupVersionClientPackage,
0000000000000000000000000000000000000000;;			HeaderText:  boilerplate,
0000000000000000000000000000000000000000;;			PackageDocumentation: []byte(
0000000000000000000000000000000000000000;;				generatedBy +
0000000000000000000000000000000000000000;;					`// This package has the automatically generated typed clients.
0000000000000000000000000000000000000000;;	`),
0000000000000000000000000000000000000000;;			// GeneratorFunc returns a list of generators. Each generator makes a
0000000000000000000000000000000000000000;;			// single file.
0000000000000000000000000000000000000000;;			GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
0000000000000000000000000000000000000000;;				generators = []generator.Generator{
0000000000000000000000000000000000000000;;					// Always generate a "doc.go" file.
0000000000000000000000000000000000000000;;					generator.DefaultGen{OptionalName: "doc"},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Since we want a file per type that we generate a client for, we
0000000000000000000000000000000000000000;;				// have to provide a function for this.
0000000000000000000000000000000000000000;;				for _, t := range typeList {
0000000000000000000000000000000000000000;;					generators = append(generators, &genClientForType{
0000000000000000000000000000000000000000;;						DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;							OptionalName: strings.ToLower(c.Namers["private"].Name(t)),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						outputPackage:    groupVersionClientPackage,
0000000000000000000000000000000000000000;;						clientsetPackage: clientsetPackage,
0000000000000000000000000000000000000000;;						group:            gv.Group.NonEmpty(),
0000000000000000000000000000000000000000;;						version:          gv.Version.String(),
0000000000000000000000000000000000000000;;						typeToMatch:      t,
0000000000000000000000000000000000000000;;						imports:          generator.NewImportTracker(),
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				generators = append(generators, &genGroup{
0000000000000000000000000000000000000000;;					DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;						OptionalName: gv.Group.NonEmpty() + "_client",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					outputPackage:    groupVersionClientPackage,
0000000000000000000000000000000000000000;;					inputPackage:     inputPackage,
0000000000000000000000000000000000000000;;					clientsetPackage: clientsetPackage,
0000000000000000000000000000000000000000;;					group:            gv.Group.NonEmpty(),
0000000000000000000000000000000000000000;;					version:          gv.Version.String(),
0000000000000000000000000000000000000000;;					apiPath:          apiPath,
0000000000000000000000000000000000000000;;					types:            typeList,
0000000000000000000000000000000000000000;;					imports:          generator.NewImportTracker(),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expansionFileName := "generated_expansion"
0000000000000000000000000000000000000000;;				generators = append(generators, &genExpansion{
0000000000000000000000000000000000000000;;					groupPackagePath: filepath.Join(srcTreePath, groupVersionClientPackage),
0000000000000000000000000000000000000000;;					DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;						OptionalName: expansionFileName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					types: typeList,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return generators
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			FilterFunc: func(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;				return extractBoolTagOrDie("genclient", t.SecondClosestCommentLines) == true
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packageForClientset(customArgs clientgenargs.Args, clientsetPackage string, boilerplate []byte, generatedBy string) generator.Package {
0000000000000000000000000000000000000000;;		return &generator.DefaultPackage{
0000000000000000000000000000000000000000;;			PackageName: customArgs.ClientsetName,
0000000000000000000000000000000000000000;;			PackagePath: clientsetPackage,
0000000000000000000000000000000000000000;;			HeaderText:  boilerplate,
0000000000000000000000000000000000000000;;			PackageDocumentation: []byte(
0000000000000000000000000000000000000000;;				generatedBy +
0000000000000000000000000000000000000000;;					`// This package has the automatically generated clientset.
0000000000000000000000000000000000000000;;	`),
0000000000000000000000000000000000000000;;			// GeneratorFunc returns a list of generators. Each generator generates a
0000000000000000000000000000000000000000;;			// single file.
0000000000000000000000000000000000000000;;			GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
0000000000000000000000000000000000000000;;				generators = []generator.Generator{
0000000000000000000000000000000000000000;;					// Always generate a "doc.go" file.
0000000000000000000000000000000000000000;;					generator.DefaultGen{OptionalName: "doc"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					&genClientset{
0000000000000000000000000000000000000000;;						DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;							OptionalName: "clientset",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						groups:           customArgs.Groups,
0000000000000000000000000000000000000000;;						clientsetPackage: clientsetPackage,
0000000000000000000000000000000000000000;;						outputPackage:    customArgs.ClientsetName,
0000000000000000000000000000000000000000;;						imports:          generator.NewImportTracker(),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return generators
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packageForScheme(customArgs clientgenargs.Args, clientsetPackage string, srcTreePath string, boilerplate []byte, generatedBy string) generator.Package {
0000000000000000000000000000000000000000;;		schemePackage := filepath.Join(clientsetPackage, "scheme")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create runtime.Registry for internal client because it has to know about group versions
0000000000000000000000000000000000000000;;		internalClient := false
0000000000000000000000000000000000000000;;	NextGroup:
0000000000000000000000000000000000000000;;		for _, group := range customArgs.Groups {
0000000000000000000000000000000000000000;;			for _, v := range group.Versions {
0000000000000000000000000000000000000000;;				if v == "" {
0000000000000000000000000000000000000000;;					internalClient = true
0000000000000000000000000000000000000000;;					break NextGroup
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &generator.DefaultPackage{
0000000000000000000000000000000000000000;;			PackageName: "scheme",
0000000000000000000000000000000000000000;;			PackagePath: schemePackage,
0000000000000000000000000000000000000000;;			HeaderText:  boilerplate,
0000000000000000000000000000000000000000;;			PackageDocumentation: []byte(
0000000000000000000000000000000000000000;;				generatedBy +
0000000000000000000000000000000000000000;;					`// This package contains the scheme of the automatically generated clientset.
0000000000000000000000000000000000000000;;	`),
0000000000000000000000000000000000000000;;			// GeneratorFunc returns a list of generators. Each generator generates a
0000000000000000000000000000000000000000;;			// single file.
0000000000000000000000000000000000000000;;			GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
0000000000000000000000000000000000000000;;				generators = []generator.Generator{
0000000000000000000000000000000000000000;;					// Always generate a "doc.go" file.
0000000000000000000000000000000000000000;;					generator.DefaultGen{OptionalName: "doc"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					&scheme.GenScheme{
0000000000000000000000000000000000000000;;						DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;							OptionalName: "register",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						InputPackages:  customArgs.GroupVersionToInputPath,
0000000000000000000000000000000000000000;;						OutputPackage:  schemePackage,
0000000000000000000000000000000000000000;;						OutputPath:     filepath.Join(srcTreePath, schemePackage),
0000000000000000000000000000000000000000;;						Groups:         customArgs.Groups,
0000000000000000000000000000000000000000;;						ImportTracker:  generator.NewImportTracker(),
0000000000000000000000000000000000000000;;						CreateRegistry: internalClient,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return generators
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// applyGroupOverrides applies group name overrides to each package, if applicable. If there is a
0000000000000000000000000000000000000000;;	// comment of the form "// +groupName=somegroup" or "// +groupName=somegroup.foo.bar.io", use the
0000000000000000000000000000000000000000;;	// first field (somegroup) as the name of the group when generating.
0000000000000000000000000000000000000000;;	func applyGroupOverrides(universe types.Universe, customArgs *clientgenargs.Args) {
0000000000000000000000000000000000000000;;		// Create a map from "old GV" to "new GV" so we know what changes we need to make.
0000000000000000000000000000000000000000;;		changes := make(map[clientgentypes.GroupVersion]clientgentypes.GroupVersion)
0000000000000000000000000000000000000000;;		for gv, inputDir := range customArgs.GroupVersionToInputPath {
0000000000000000000000000000000000000000;;			p := universe.Package(inputDir)
0000000000000000000000000000000000000000;;			if override := types.ExtractCommentTags("+", p.DocComments)["groupName"]; override != nil {
0000000000000000000000000000000000000000;;				newGV := clientgentypes.GroupVersion{
0000000000000000000000000000000000000000;;					Group:   clientgentypes.Group(strings.SplitN(override[0], ".", 2)[0]),
0000000000000000000000000000000000000000;;					Version: gv.Version,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				changes[gv] = newGV
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Modify customArgs.Groups based on the groupName overrides.
0000000000000000000000000000000000000000;;		newGroups := make([]clientgentypes.GroupVersions, 0, len(customArgs.Groups))
0000000000000000000000000000000000000000;;		for _, gvs := range customArgs.Groups {
0000000000000000000000000000000000000000;;			gv := clientgentypes.GroupVersion{
0000000000000000000000000000000000000000;;				Group:   gvs.Group,
0000000000000000000000000000000000000000;;				Version: gvs.Versions[0], // we only need a version, and the first will do
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if newGV, ok := changes[gv]; ok {
0000000000000000000000000000000000000000;;				// There's an override, so use it.
0000000000000000000000000000000000000000;;				newGVS := clientgentypes.GroupVersions{
0000000000000000000000000000000000000000;;					Group:    newGV.Group,
0000000000000000000000000000000000000000;;					Versions: gvs.Versions,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newGroups = append(newGroups, newGVS)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// No override.
0000000000000000000000000000000000000000;;				newGroups = append(newGroups, gvs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		customArgs.Groups = newGroups
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Modify customArgs.GroupVersionToInputPath based on the groupName overrides.
0000000000000000000000000000000000000000;;		newGVToInputPath := make(map[clientgentypes.GroupVersion]string)
0000000000000000000000000000000000000000;;		for gv, inputDir := range customArgs.GroupVersionToInputPath {
0000000000000000000000000000000000000000;;			if newGV, ok := changes[gv]; ok {
0000000000000000000000000000000000000000;;				// There's an override, so use it.
0000000000000000000000000000000000000000;;				newGVToInputPath[newGV] = inputDir
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// No override.
0000000000000000000000000000000000000000;;				newGVToInputPath[gv] = inputDir
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		customArgs.GroupVersionToInputPath = newGVToInputPath
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Packages makes the client package definition.
0000000000000000000000000000000000000000;;	func Packages(context *generator.Context, arguments *args.GeneratorArgs) generator.Packages {
0000000000000000000000000000000000000000;;		boilerplate, err := arguments.LoadGoBoilerplate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed loading boilerplate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		customArgs, ok := arguments.CustomArgs.(clientgenargs.Args)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.Fatalf("cannot convert arguments.CustomArgs to clientgenargs.Args")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		includedTypesOverrides := customArgs.IncludedTypesOverrides
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		applyGroupOverrides(context.Universe, &customArgs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		generatedBy := generatedBy(customArgs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gvToTypes := map[clientgentypes.GroupVersion][]*types.Type{}
0000000000000000000000000000000000000000;;		for gv, inputDir := range customArgs.GroupVersionToInputPath {
0000000000000000000000000000000000000000;;			// Package are indexed with the vendor prefix stripped
0000000000000000000000000000000000000000;;			p := context.Universe.Package(path.Vendorless(inputDir))
0000000000000000000000000000000000000000;;			for n, t := range p.Types {
0000000000000000000000000000000000000000;;				// filter out types which are not included in user specified overrides.
0000000000000000000000000000000000000000;;				typesOverride, ok := includedTypesOverrides[gv]
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					found := false
0000000000000000000000000000000000000000;;					for _, typeStr := range typesOverride {
0000000000000000000000000000000000000000;;						if typeStr == n {
0000000000000000000000000000000000000000;;							found = true
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !found {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// User has not specified any override for this group version.
0000000000000000000000000000000000000000;;					// filter out types which dont have genclient=true.
0000000000000000000000000000000000000000;;					if extractBoolTagOrDie("genclient", t.SecondClosestCommentLines) == false {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, found := gvToTypes[gv]; !found {
0000000000000000000000000000000000000000;;					gvToTypes[gv] = []*types.Type{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				gvToTypes[gv] = append(gvToTypes[gv], t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var packageList []generator.Package
0000000000000000000000000000000000000000;;		clientsetPackage := filepath.Join(customArgs.ClientsetOutputPath, customArgs.ClientsetName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		packageList = append(packageList, packageForClientset(customArgs, clientsetPackage, boilerplate, generatedBy))
0000000000000000000000000000000000000000;;		packageList = append(packageList, packageForScheme(customArgs, clientsetPackage, arguments.OutputBase, boilerplate, generatedBy))
0000000000000000000000000000000000000000;;		if customArgs.FakeClient {
0000000000000000000000000000000000000000;;			packageList = append(packageList, fake.PackageForClientset(customArgs, clientsetPackage, boilerplate, generatedBy))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If --clientset-only=true, we don't regenerate the individual typed clients.
0000000000000000000000000000000000000000;;		if customArgs.ClientsetOnly {
0000000000000000000000000000000000000000;;			return generator.Packages(packageList)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		orderer := namer.Orderer{Namer: namer.NewPrivateNamer(0)}
0000000000000000000000000000000000000000;;		for _, group := range customArgs.Groups {
0000000000000000000000000000000000000000;;			for _, version := range group.Versions {
0000000000000000000000000000000000000000;;				gv := clientgentypes.GroupVersion{Group: group.Group, Version: version}
0000000000000000000000000000000000000000;;				types := gvToTypes[gv]
0000000000000000000000000000000000000000;;				inputPath := customArgs.GroupVersionToInputPath[gv]
0000000000000000000000000000000000000000;;				packageList = append(packageList, packageForGroup(gv, orderer.OrderTypes(types), clientsetPackage, customArgs.ClientsetAPIPath, arguments.OutputBase, inputPath, boilerplate, generatedBy))
0000000000000000000000000000000000000000;;				if customArgs.FakeClient {
0000000000000000000000000000000000000000;;					packageList = append(packageList, fake.PackageForGroup(gv, orderer.OrderTypes(types), clientsetPackage, inputPath, boilerplate, generatedBy))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return generator.Packages(packageList)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tagOverrideNamer is a namer which pulls names from a given tag, if specified,
0000000000000000000000000000000000000000;;	// and otherwise falls back to a different namer.
0000000000000000000000000000000000000000;;	type tagOverrideNamer struct {
0000000000000000000000000000000000000000;;		tagName  string
0000000000000000000000000000000000000000;;		fallback namer.Namer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *tagOverrideNamer) Name(t *types.Type) string {
0000000000000000000000000000000000000000;;		if nameOverride := extractTag(n.tagName, t.SecondClosestCommentLines); nameOverride != "" {
0000000000000000000000000000000000000000;;			return nameOverride
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n.fallback.Name(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTagOverrideNamer creates a namer.Namer which uses the contents of the given tag as
0000000000000000000000000000000000000000;;	// the name, or falls back to another Namer if the tag is not present.
0000000000000000000000000000000000000000;;	func NewTagOverrideNamer(tagName string, fallback namer.Namer) namer.Namer {
0000000000000000000000000000000000000000;;		return &tagOverrideNamer{
0000000000000000000000000000000000000000;;			tagName:  tagName,
0000000000000000000000000000000000000000;;			fallback: fallback,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
