0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
90e753b7d893977fcb7246ab3277eaab11726cf4;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package generators
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;		clientgentypes "k8s.io/kubernetes/cmd/libs/go2idl/client-gen/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// factoryGenerator produces a file of listers for a given GroupVersion and
0000000000000000000000000000000000000000;;	// type.
0000000000000000000000000000000000000000;;	type factoryGenerator struct {
0000000000000000000000000000000000000000;;		generator.DefaultGen
0000000000000000000000000000000000000000;;		outputPackage             string
0000000000000000000000000000000000000000;;		imports                   namer.ImportTracker
0000000000000000000000000000000000000000;;		groupVersions             map[string]clientgentypes.GroupVersions
0000000000000000000000000000000000000000;;		clientSetPackage          string
0000000000000000000000000000000000000000;;		internalInterfacesPackage string
0000000000000000000000000000000000000000;;		filtered                  bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ generator.Generator = &factoryGenerator{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *factoryGenerator) Filter(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;		if !g.filtered {
0000000000000000000000000000000000000000;;			g.filtered = true
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *factoryGenerator) Namers(c *generator.Context) namer.NameSystems {
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"raw": namer.NewRawNamer(g.outputPackage, g.imports),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *factoryGenerator) Imports(c *generator.Context) (imports []string) {
0000000000000000000000000000000000000000;;		imports = append(imports, g.imports.ImportLines()...)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *factoryGenerator) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(w, c, "{{", "}}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("processing type %v", t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gvInterfaces := make(map[string]*types.Type)
0000000000000000000000000000000000000000;;		gvNewFuncs := make(map[string]*types.Type)
0000000000000000000000000000000000000000;;		for groupName := range g.groupVersions {
0000000000000000000000000000000000000000;;			gvInterfaces[groupName] = c.Universe.Type(types.Name{Package: packageForGroup(vendorless(g.outputPackage), g.groupVersions[groupName].Group), Name: "Interface"})
0000000000000000000000000000000000000000;;			gvNewFuncs[groupName] = c.Universe.Function(types.Name{Package: packageForGroup(vendorless(g.outputPackage), g.groupVersions[groupName].Group), Name: "New"})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m := map[string]interface{}{
0000000000000000000000000000000000000000;;			"cacheSharedIndexInformer":   c.Universe.Type(cacheSharedIndexInformer),
0000000000000000000000000000000000000000;;			"groupVersions":              g.groupVersions,
0000000000000000000000000000000000000000;;			"gvInterfaces":               gvInterfaces,
0000000000000000000000000000000000000000;;			"gvNewFuncs":                 gvNewFuncs,
0000000000000000000000000000000000000000;;			"interfacesNewInformerFunc":  c.Universe.Type(types.Name{Package: g.internalInterfacesPackage, Name: "NewInformerFunc"}),
0000000000000000000000000000000000000000;;			"informerFactoryInterface":   c.Universe.Type(types.Name{Package: g.internalInterfacesPackage, Name: "SharedInformerFactory"}),
0000000000000000000000000000000000000000;;			"clientSetInterface":         c.Universe.Type(types.Name{Package: g.clientSetPackage, Name: "Interface"}),
0000000000000000000000000000000000000000;;			"reflectType":                c.Universe.Type(reflectType),
0000000000000000000000000000000000000000;;			"runtimeObject":              c.Universe.Type(runtimeObject),
0000000000000000000000000000000000000000;;			"schemaGroupVersionResource": c.Universe.Type(schemaGroupVersionResource),
0000000000000000000000000000000000000000;;			"syncMutex":                  c.Universe.Type(syncMutex),
0000000000000000000000000000000000000000;;			"timeDuration":               c.Universe.Type(timeDuration),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sw.Do(sharedInformerFactoryStruct, m)
0000000000000000000000000000000000000000;;		sw.Do(sharedInformerFactoryInterface, m)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sw.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var sharedInformerFactoryStruct = `
0000000000000000000000000000000000000000;;	type sharedInformerFactory struct {
0000000000000000000000000000000000000000;;		client {{.clientSetInterface|raw}}
0000000000000000000000000000000000000000;;		lock {{.syncMutex|raw}}
0000000000000000000000000000000000000000;;		defaultResync {{.timeDuration|raw}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informers map[{{.reflectType|raw}}]{{.cacheSharedIndexInformer|raw}}
0000000000000000000000000000000000000000;;		// startedInformers is used for tracking which informers have been started.
0000000000000000000000000000000000000000;;		// This allows Start() to be called multiple times safely.
0000000000000000000000000000000000000000;;		startedInformers map[{{.reflectType|raw}}]bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSharedInformerFactory constructs a new instance of sharedInformerFactory
0000000000000000000000000000000000000000;;	func NewSharedInformerFactory(client {{.clientSetInterface|raw}}, defaultResync {{.timeDuration|raw}}) SharedInformerFactory {
0000000000000000000000000000000000000000;;	  return &sharedInformerFactory{
0000000000000000000000000000000000000000;;			client: client,
0000000000000000000000000000000000000000;;	    defaultResync:    defaultResync,
0000000000000000000000000000000000000000;;	    informers:        make(map[{{.reflectType|raw}}]{{.cacheSharedIndexInformer|raw}}),
0000000000000000000000000000000000000000;;	    startedInformers: make(map[{{.reflectType|raw}}]bool),
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Start initializes all requested informers.
0000000000000000000000000000000000000000;;	func (f *sharedInformerFactory) Start(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;	  f.lock.Lock()
0000000000000000000000000000000000000000;;	  defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for informerType, informer := range f.informers {
0000000000000000000000000000000000000000;;	    if !f.startedInformers[informerType] {
0000000000000000000000000000000000000000;;	      go informer.Run(stopCh)
0000000000000000000000000000000000000000;;	      f.startedInformers[informerType] = true
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForCacheSync waits for all started informers' cache were synced.
0000000000000000000000000000000000000000;;	func (f *sharedInformerFactory) WaitForCacheSync(stopCh <-chan struct{}) map[reflect.Type]bool {
0000000000000000000000000000000000000000;;		informers := func()map[reflect.Type]cache.SharedIndexInformer{
0000000000000000000000000000000000000000;;	               f.lock.Lock()
0000000000000000000000000000000000000000;;	               defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	               informers := map[reflect.Type]cache.SharedIndexInformer{}
0000000000000000000000000000000000000000;;	               for informerType, informer := range f.informers {
0000000000000000000000000000000000000000;;	                       if f.startedInformers[informerType] {
0000000000000000000000000000000000000000;;	                               informers[informerType] = informer
0000000000000000000000000000000000000000;;	                       }
0000000000000000000000000000000000000000;;	               }
0000000000000000000000000000000000000000;;	               return informers
0000000000000000000000000000000000000000;;	       }()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	       res := map[reflect.Type]bool{}
0000000000000000000000000000000000000000;;	       for informType, informer := range informers {
0000000000000000000000000000000000000000;;	               res[informType] = cache.WaitForCacheSync(stopCh, informer.HasSynced)
0000000000000000000000000000000000000000;;	       }
0000000000000000000000000000000000000000;;	       return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InternalInformerFor returns the SharedIndexInformer for obj using an internal
0000000000000000000000000000000000000000;;	// client.
0000000000000000000000000000000000000000;;	func (f *sharedInformerFactory) InformerFor(obj {{.runtimeObject|raw}}, newFunc {{.interfacesNewInformerFunc|raw}}) {{.cacheSharedIndexInformer|raw}} {
0000000000000000000000000000000000000000;;	  f.lock.Lock()
0000000000000000000000000000000000000000;;	  defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  informerType := reflect.TypeOf(obj)
0000000000000000000000000000000000000000;;	  informer, exists := f.informers[informerType]
0000000000000000000000000000000000000000;;	  if exists {
0000000000000000000000000000000000000000;;	    return informer
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	  informer = newFunc(f.client, f.defaultResync)
0000000000000000000000000000000000000000;;	  f.informers[informerType] = informer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  return informer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var sharedInformerFactoryInterface = `
0000000000000000000000000000000000000000;;	// SharedInformerFactory provides shared informers for resources in all known
0000000000000000000000000000000000000000;;	// API group versions.
0000000000000000000000000000000000000000;;	type SharedInformerFactory interface {
0000000000000000000000000000000000000000;;		{{.informerFactoryInterface|raw}}
0000000000000000000000000000000000000000;;		ForResource(resource {{.schemaGroupVersionResource|raw}}) (GenericInformer, error)
0000000000000000000000000000000000000000;;		WaitForCacheSync(stopCh <-chan struct{}) map[reflect.Type]bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		{{$gvInterfaces := .gvInterfaces}}
0000000000000000000000000000000000000000;;		{{range $groupName, $group := .groupVersions}}{{$groupName}}() {{index $gvInterfaces $groupName|raw}}
0000000000000000000000000000000000000000;;		{{end}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	{{$gvNewFuncs := .gvNewFuncs}}
0000000000000000000000000000000000000000;;	{{range $groupName, $group := .groupVersions}}
0000000000000000000000000000000000000000;;	func (f *sharedInformerFactory) {{$groupName}}() {{index $gvInterfaces $groupName|raw}} {
0000000000000000000000000000000000000000;;	  return {{index $gvNewFuncs $groupName|raw}}(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	{{end}}
0000000000000000000000000000000000000000;;	`
