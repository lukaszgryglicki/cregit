0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
90e753b7d893977fcb7246ab3277eaab11726cf4;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package generators
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/args"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;		clientgentypes "k8s.io/kubernetes/cmd/libs/go2idl/client-gen/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameSystems returns the name system used by the generators in this package.
0000000000000000000000000000000000000000;;	func NameSystems() namer.NameSystems {
0000000000000000000000000000000000000000;;		pluralExceptions := map[string]string{
0000000000000000000000000000000000000000;;			"Endpoints": "Endpoints",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"public":             namer.NewPublicNamer(0),
0000000000000000000000000000000000000000;;			"private":            namer.NewPrivateNamer(0),
0000000000000000000000000000000000000000;;			"raw":                namer.NewRawNamer("", nil),
0000000000000000000000000000000000000000;;			"publicPlural":       namer.NewPublicPluralNamer(pluralExceptions),
0000000000000000000000000000000000000000;;			"allLowercasePlural": namer.NewAllLowercasePluralNamer(pluralExceptions),
0000000000000000000000000000000000000000;;			"lowercaseSingular":  &lowercaseSingularNamer{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lowercaseSingularNamer implements Namer
0000000000000000000000000000000000000000;;	type lowercaseSingularNamer struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name returns t's name in all lowercase.
0000000000000000000000000000000000000000;;	func (n *lowercaseSingularNamer) Name(t *types.Type) string {
0000000000000000000000000000000000000000;;		return strings.ToLower(t.Name.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultNameSystem returns the default name system for ordering the types to be
0000000000000000000000000000000000000000;;	// processed by the generators in this package.
0000000000000000000000000000000000000000;;	func DefaultNameSystem() string {
0000000000000000000000000000000000000000;;		return "public"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generatedBy returns information about the arguments used to invoke
0000000000000000000000000000000000000000;;	// lister-gen.
0000000000000000000000000000000000000000;;	func generatedBy() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("\n// This file was automatically generated by informer-gen\n\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// objectMetaForPackage returns the type of ObjectMeta used by package p.
0000000000000000000000000000000000000000;;	func objectMetaForPackage(p *types.Package) (*types.Type, bool, error) {
0000000000000000000000000000000000000000;;		generatingForPackage := false
0000000000000000000000000000000000000000;;		for _, t := range p.Types {
0000000000000000000000000000000000000000;;			// filter out types which dont have genclient=true.
0000000000000000000000000000000000000000;;			if extractBoolTagOrDie("genclient", t.SecondClosestCommentLines) == false {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			generatingForPackage = true
0000000000000000000000000000000000000000;;			for _, member := range t.Members {
0000000000000000000000000000000000000000;;				if member.Name == "ObjectMeta" {
0000000000000000000000000000000000000000;;					return member.Type, isInternal(member), nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if generatingForPackage {
0000000000000000000000000000000000000000;;			return nil, false, fmt.Errorf("unable to find ObjectMeta for any types in package %s", p.Path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isInternal returns true if the tags for a member do not contain a json tag
0000000000000000000000000000000000000000;;	func isInternal(m types.Member) bool {
0000000000000000000000000000000000000000;;		return !strings.Contains(m.Tags, "json")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packageForGroup(base string, group clientgentypes.Group) string {
0000000000000000000000000000000000000000;;		return filepath.Join(base, group.NonEmpty())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packageForInternalInterfaces(base string) string {
0000000000000000000000000000000000000000;;		return filepath.Join(base, "internalinterfaces")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func vendorless(p string) string {
0000000000000000000000000000000000000000;;		if pos := strings.LastIndex(p, "/vendor/"); pos != -1 {
0000000000000000000000000000000000000000;;			return p[pos+len("/vendor/"):]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Packages makes the client package definition.
0000000000000000000000000000000000000000;;	func Packages(context *generator.Context, arguments *args.GeneratorArgs) generator.Packages {
0000000000000000000000000000000000000000;;		boilerplate, err := arguments.LoadGoBoilerplate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed loading boilerplate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		boilerplate = append(boilerplate, []byte(generatedBy())...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		customArgs, ok := arguments.CustomArgs.(*CustomArgs)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.Fatalf("Wrong CustomArgs type: %T", arguments.CustomArgs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		internalVersionPackagePath := filepath.Join(arguments.OutputPackagePath, "internalversion")
0000000000000000000000000000000000000000;;		externalVersionPackagePath := filepath.Join(arguments.OutputPackagePath, "externalversions")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var packageList generator.Packages
0000000000000000000000000000000000000000;;		typesForGroupVersion := make(map[clientgentypes.GroupVersion][]*types.Type)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		externalGroupVersions := make(map[string]clientgentypes.GroupVersions)
0000000000000000000000000000000000000000;;		internalGroupVersions := make(map[string]clientgentypes.GroupVersions)
0000000000000000000000000000000000000000;;		for _, inputDir := range arguments.InputDirs {
0000000000000000000000000000000000000000;;			p := context.Universe.Package(vendorless(inputDir))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			objectMeta, internal, err := objectMetaForPackage(p)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if objectMeta == nil {
0000000000000000000000000000000000000000;;				// no types in this package had genclient
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var gv clientgentypes.GroupVersion
0000000000000000000000000000000000000000;;			var targetGroupVersions map[string]clientgentypes.GroupVersions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if internal {
0000000000000000000000000000000000000000;;				lastSlash := strings.LastIndex(p.Path, "/")
0000000000000000000000000000000000000000;;				if lastSlash == -1 {
0000000000000000000000000000000000000000;;					glog.Fatalf("error constructing internal group version for package %q", p.Path)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				gv.Group = clientgentypes.Group(p.Path[lastSlash+1:])
0000000000000000000000000000000000000000;;				targetGroupVersions = internalGroupVersions
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				parts := strings.Split(p.Path, "/")
0000000000000000000000000000000000000000;;				gv.Group = clientgentypes.Group(parts[len(parts)-2])
0000000000000000000000000000000000000000;;				gv.Version = clientgentypes.Version(parts[len(parts)-1])
0000000000000000000000000000000000000000;;				targetGroupVersions = externalGroupVersions
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If there's a comment of the form "// +groupName=somegroup" or
0000000000000000000000000000000000000000;;			// "// +groupName=somegroup.foo.bar.io", use the first field (somegroup) as the name of the
0000000000000000000000000000000000000000;;			// group when generating.
0000000000000000000000000000000000000000;;			if override := types.ExtractCommentTags("+", p.DocComments)["groupName"]; override != nil {
0000000000000000000000000000000000000000;;				gv.Group = clientgentypes.Group(strings.SplitN(override[0], ".", 2)[0])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var typesToGenerate []*types.Type
0000000000000000000000000000000000000000;;			for _, t := range p.Types {
0000000000000000000000000000000000000000;;				// filter out types which dont have genclient=true.
0000000000000000000000000000000000000000;;				if extractBoolTagOrDie("genclient", t.SecondClosestCommentLines) == false {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// filter out types which have noMethods
0000000000000000000000000000000000000000;;				if extractBoolTagOrDie("noMethods", t.SecondClosestCommentLines) == true {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				typesToGenerate = append(typesToGenerate, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if _, ok := typesForGroupVersion[gv]; !ok {
0000000000000000000000000000000000000000;;					typesForGroupVersion[gv] = []*types.Type{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				typesForGroupVersion[gv] = append(typesForGroupVersion[gv], t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(typesToGenerate) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			icGroupName := namer.IC(gv.Group.NonEmpty())
0000000000000000000000000000000000000000;;			groupVersionsEntry, ok := targetGroupVersions[icGroupName]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				groupVersionsEntry = clientgentypes.GroupVersions{
0000000000000000000000000000000000000000;;					Group: gv.Group,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groupVersionsEntry.Versions = append(groupVersionsEntry.Versions, gv.Version)
0000000000000000000000000000000000000000;;			targetGroupVersions[icGroupName] = groupVersionsEntry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			orderer := namer.Orderer{Namer: namer.NewPrivateNamer(0)}
0000000000000000000000000000000000000000;;			typesToGenerate = orderer.OrderTypes(typesToGenerate)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if internal {
0000000000000000000000000000000000000000;;				packageList = append(packageList, versionPackage(internalVersionPackagePath, gv, boilerplate, typesToGenerate, customArgs.InternalClientSetPackage, customArgs.ListersPackage))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				packageList = append(packageList, versionPackage(externalVersionPackagePath, gv, boilerplate, typesToGenerate, customArgs.VersionedClientSetPackage, customArgs.ListersPackage))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		packageList = append(packageList, factoryInterfacePackage(externalVersionPackagePath, boilerplate, customArgs.VersionedClientSetPackage, typesForGroupVersion))
0000000000000000000000000000000000000000;;		packageList = append(packageList, factoryPackage(externalVersionPackagePath, boilerplate, externalGroupVersions, customArgs.VersionedClientSetPackage, typesForGroupVersion))
0000000000000000000000000000000000000000;;		for _, groupVersionsEntry := range externalGroupVersions {
0000000000000000000000000000000000000000;;			packageList = append(packageList, groupPackage(externalVersionPackagePath, groupVersionsEntry, boilerplate))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		packageList = append(packageList, factoryInterfacePackage(internalVersionPackagePath, boilerplate, customArgs.InternalClientSetPackage, typesForGroupVersion))
0000000000000000000000000000000000000000;;		packageList = append(packageList, factoryPackage(internalVersionPackagePath, boilerplate, internalGroupVersions, customArgs.InternalClientSetPackage, typesForGroupVersion))
0000000000000000000000000000000000000000;;		for _, groupVersionsEntry := range internalGroupVersions {
0000000000000000000000000000000000000000;;			packageList = append(packageList, groupPackage(internalVersionPackagePath, groupVersionsEntry, boilerplate))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return packageList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isInternalVersion(gv clientgentypes.GroupVersion) bool {
0000000000000000000000000000000000000000;;		return len(gv.Version) == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func factoryPackage(basePackage string, boilerplate []byte, groupVersions map[string]clientgentypes.GroupVersions, clientSetPackage string, typesForGroupVersion map[clientgentypes.GroupVersion][]*types.Type) generator.Package {
0000000000000000000000000000000000000000;;		return &generator.DefaultPackage{
0000000000000000000000000000000000000000;;			PackageName: filepath.Base(basePackage),
0000000000000000000000000000000000000000;;			PackagePath: basePackage,
0000000000000000000000000000000000000000;;			HeaderText:  boilerplate,
0000000000000000000000000000000000000000;;			GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
0000000000000000000000000000000000000000;;				generators = append(generators, &factoryGenerator{
0000000000000000000000000000000000000000;;					DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;						OptionalName: "factory",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					outputPackage:             basePackage,
0000000000000000000000000000000000000000;;					imports:                   generator.NewImportTracker(),
0000000000000000000000000000000000000000;;					groupVersions:             groupVersions,
0000000000000000000000000000000000000000;;					clientSetPackage:          clientSetPackage,
0000000000000000000000000000000000000000;;					internalInterfacesPackage: packageForInternalInterfaces(basePackage),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				generators = append(generators, &genericGenerator{
0000000000000000000000000000000000000000;;					DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;						OptionalName: "generic",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					outputPackage:        basePackage,
0000000000000000000000000000000000000000;;					imports:              generator.NewImportTracker(),
0000000000000000000000000000000000000000;;					groupVersions:        groupVersions,
0000000000000000000000000000000000000000;;					typesForGroupVersion: typesForGroupVersion,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return generators
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func factoryInterfacePackage(basePackage string, boilerplate []byte, clientSetPackage string, typesForGroupVersion map[clientgentypes.GroupVersion][]*types.Type) generator.Package {
0000000000000000000000000000000000000000;;		packagePath := packageForInternalInterfaces(basePackage)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &generator.DefaultPackage{
0000000000000000000000000000000000000000;;			PackageName: filepath.Base(packagePath),
0000000000000000000000000000000000000000;;			PackagePath: packagePath,
0000000000000000000000000000000000000000;;			HeaderText:  boilerplate,
0000000000000000000000000000000000000000;;			GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
0000000000000000000000000000000000000000;;				generators = append(generators, &factoryInterfaceGenerator{
0000000000000000000000000000000000000000;;					DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;						OptionalName: "factory_interfaces",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					outputPackage:    packagePath,
0000000000000000000000000000000000000000;;					imports:          generator.NewImportTracker(),
0000000000000000000000000000000000000000;;					clientSetPackage: clientSetPackage,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return generators
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func groupPackage(basePackage string, groupVersions clientgentypes.GroupVersions, boilerplate []byte) generator.Package {
0000000000000000000000000000000000000000;;		packagePath := filepath.Join(basePackage, strings.ToLower(groupVersions.Group.NonEmpty()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &generator.DefaultPackage{
0000000000000000000000000000000000000000;;			PackageName: strings.ToLower(groupVersions.Group.NonEmpty()),
0000000000000000000000000000000000000000;;			PackagePath: packagePath,
0000000000000000000000000000000000000000;;			HeaderText:  boilerplate,
0000000000000000000000000000000000000000;;			GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
0000000000000000000000000000000000000000;;				generators = append(generators, &groupInterfaceGenerator{
0000000000000000000000000000000000000000;;					DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;						OptionalName: "interface",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					outputPackage:             packagePath,
0000000000000000000000000000000000000000;;					groupVersions:             groupVersions,
0000000000000000000000000000000000000000;;					imports:                   generator.NewImportTracker(),
0000000000000000000000000000000000000000;;					internalInterfacesPackage: packageForInternalInterfaces(basePackage),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				return generators
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			FilterFunc: func(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;				// piggy-back on types that are tagged for client-gen
0000000000000000000000000000000000000000;;				return extractBoolTagOrDie("genclient", t.SecondClosestCommentLines) == true
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func versionPackage(basePackage string, gv clientgentypes.GroupVersion, boilerplate []byte, typesToGenerate []*types.Type, clientSetPackage, listersPackage string) generator.Package {
0000000000000000000000000000000000000000;;		packagePath := filepath.Join(basePackage, strings.ToLower(gv.Group.NonEmpty()), strings.ToLower(gv.Version.NonEmpty()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &generator.DefaultPackage{
0000000000000000000000000000000000000000;;			PackageName: strings.ToLower(gv.Version.NonEmpty()),
0000000000000000000000000000000000000000;;			PackagePath: packagePath,
0000000000000000000000000000000000000000;;			HeaderText:  boilerplate,
0000000000000000000000000000000000000000;;			GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
0000000000000000000000000000000000000000;;				generators = append(generators, &versionInterfaceGenerator{
0000000000000000000000000000000000000000;;					DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;						OptionalName: "interface",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					outputPackage: packagePath,
0000000000000000000000000000000000000000;;					imports:       generator.NewImportTracker(),
0000000000000000000000000000000000000000;;					types:         typesToGenerate,
0000000000000000000000000000000000000000;;					internalInterfacesPackage: packageForInternalInterfaces(basePackage),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for _, t := range typesToGenerate {
0000000000000000000000000000000000000000;;					generators = append(generators, &informerGenerator{
0000000000000000000000000000000000000000;;						DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;							OptionalName: strings.ToLower(t.Name.Name),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						outputPackage:             packagePath,
0000000000000000000000000000000000000000;;						groupVersion:              gv,
0000000000000000000000000000000000000000;;						typeToGenerate:            t,
0000000000000000000000000000000000000000;;						imports:                   generator.NewImportTracker(),
0000000000000000000000000000000000000000;;						clientSetPackage:          clientSetPackage,
0000000000000000000000000000000000000000;;						listersPackage:            listersPackage,
0000000000000000000000000000000000000000;;						internalInterfacesPackage: packageForInternalInterfaces(basePackage),
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return generators
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			FilterFunc: func(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;				// piggy-back on types that are tagged for client-gen
0000000000000000000000000000000000000000;;				return extractBoolTagOrDie("genclient", t.SecondClosestCommentLines) == true
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
