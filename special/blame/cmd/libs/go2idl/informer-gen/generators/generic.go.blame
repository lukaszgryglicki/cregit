0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
90e753b7d893977fcb7246ab3277eaab11726cf4;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package generators
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;		clientgentypes "k8s.io/kubernetes/cmd/libs/go2idl/client-gen/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// genericGenerator generates the generic informer.
0000000000000000000000000000000000000000;;	type genericGenerator struct {
0000000000000000000000000000000000000000;;		generator.DefaultGen
0000000000000000000000000000000000000000;;		outputPackage        string
0000000000000000000000000000000000000000;;		imports              namer.ImportTracker
0000000000000000000000000000000000000000;;		groupVersions        map[string]clientgentypes.GroupVersions
0000000000000000000000000000000000000000;;		typesForGroupVersion map[clientgentypes.GroupVersion][]*types.Type
0000000000000000000000000000000000000000;;		filtered             bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ generator.Generator = &genericGenerator{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genericGenerator) Filter(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;		if !g.filtered {
0000000000000000000000000000000000000000;;			g.filtered = true
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genericGenerator) Namers(c *generator.Context) namer.NameSystems {
0000000000000000000000000000000000000000;;		pluralExceptions := map[string]string{
0000000000000000000000000000000000000000;;			"Endpoints": "Endpoints",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"raw":                namer.NewRawNamer(g.outputPackage, g.imports),
0000000000000000000000000000000000000000;;			"allLowercasePlural": namer.NewAllLowercasePluralNamer(pluralExceptions),
0000000000000000000000000000000000000000;;			"publicPlural":       namer.NewPublicPluralNamer(pluralExceptions),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genericGenerator) Imports(c *generator.Context) (imports []string) {
0000000000000000000000000000000000000000;;		imports = append(imports, g.imports.ImportLines()...)
0000000000000000000000000000000000000000;;		imports = append(imports, "fmt")
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type group struct {
0000000000000000000000000000000000000000;;		Name     string
0000000000000000000000000000000000000000;;		Versions []*version
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type groupSort []group
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g groupSort) Len() int           { return len(g) }
0000000000000000000000000000000000000000;;	func (g groupSort) Less(i, j int) bool { return strings.ToLower(g[i].Name) < strings.ToLower(g[j].Name) }
0000000000000000000000000000000000000000;;	func (g groupSort) Swap(i, j int)      { g[i], g[j] = g[j], g[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type version struct {
0000000000000000000000000000000000000000;;		Name      string
0000000000000000000000000000000000000000;;		Resources []*types.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type versionSort []*version
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v versionSort) Len() int { return len(v) }
0000000000000000000000000000000000000000;;	func (v versionSort) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return strings.ToLower(v[i].Name) < strings.ToLower(v[j].Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (v versionSort) Swap(i, j int) { v[i], v[j] = v[j], v[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genericGenerator) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(w, c, "{{", "}}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := []group{}
0000000000000000000000000000000000000000;;		schemeGVs := make(map[*version]*types.Type)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		orderer := namer.Orderer{Namer: namer.NewPrivateNamer(0)}
0000000000000000000000000000000000000000;;		for _, groupVersions := range g.groupVersions {
0000000000000000000000000000000000000000;;			group := group{
0000000000000000000000000000000000000000;;				Name:     namer.IC(groupVersions.Group.NonEmpty()),
0000000000000000000000000000000000000000;;				Versions: []*version{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, v := range groupVersions.Versions {
0000000000000000000000000000000000000000;;				gv := clientgentypes.GroupVersion{Group: groupVersions.Group, Version: v}
0000000000000000000000000000000000000000;;				version := &version{
0000000000000000000000000000000000000000;;					Name:      namer.IC(v.NonEmpty()),
0000000000000000000000000000000000000000;;					Resources: orderer.OrderTypes(g.typesForGroupVersion[gv]),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				schemeGVs[version] = c.Universe.Variable(types.Name{Package: g.typesForGroupVersion[gv][0].Name.Package, Name: "SchemeGroupVersion"})
0000000000000000000000000000000000000000;;				group.Versions = append(group.Versions, version)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Sort(versionSort(group.Versions))
0000000000000000000000000000000000000000;;			groups = append(groups, group)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(groupSort(groups))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := map[string]interface{}{
0000000000000000000000000000000000000000;;			"cacheGenericLister":         c.Universe.Type(cacheGenericLister),
0000000000000000000000000000000000000000;;			"cacheNewGenericLister":      c.Universe.Function(cacheNewGenericLister),
0000000000000000000000000000000000000000;;			"cacheSharedIndexInformer":   c.Universe.Type(cacheSharedIndexInformer),
0000000000000000000000000000000000000000;;			"groups":                     groups,
0000000000000000000000000000000000000000;;			"schemeGVs":                  schemeGVs,
0000000000000000000000000000000000000000;;			"schemaGroupResource":        c.Universe.Type(schemaGroupResource),
0000000000000000000000000000000000000000;;			"schemaGroupVersionResource": c.Universe.Type(schemaGroupVersionResource),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sw.Do(genericInformer, m)
0000000000000000000000000000000000000000;;		sw.Do(forResource, m)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sw.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var genericInformer = `
0000000000000000000000000000000000000000;;	// GenericInformer is type of SharedIndexInformer which will locate and delegate to other
0000000000000000000000000000000000000000;;	// sharedInformers based on type
0000000000000000000000000000000000000000;;	type GenericInformer interface {
0000000000000000000000000000000000000000;;		Informer() {{.cacheSharedIndexInformer|raw}}
0000000000000000000000000000000000000000;;		Lister() {{.cacheGenericLister|raw}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type genericInformer struct {
0000000000000000000000000000000000000000;;		informer {{.cacheSharedIndexInformer|raw}}
0000000000000000000000000000000000000000;;		resource {{.schemaGroupResource|raw}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Informer returns the SharedIndexInformer.
0000000000000000000000000000000000000000;;	func (f *genericInformer) Informer() {{.cacheSharedIndexInformer|raw}} {
0000000000000000000000000000000000000000;;		return f.informer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lister returns the GenericLister.
0000000000000000000000000000000000000000;;	func (f *genericInformer) Lister() {{.cacheGenericLister|raw}} {
0000000000000000000000000000000000000000;;		return {{.cacheNewGenericLister|raw}}(f.Informer().GetIndexer(), f.resource)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var forResource = `
0000000000000000000000000000000000000000;;	// ForResource gives generic access to a shared informer of the matching type
0000000000000000000000000000000000000000;;	// TODO extend this to unknown resources with a client pool
0000000000000000000000000000000000000000;;	func (f *sharedInformerFactory) ForResource(resource {{.schemaGroupVersionResource|raw}}) (GenericInformer, error) {
0000000000000000000000000000000000000000;;		switch resource {
0000000000000000000000000000000000000000;;			{{range $group := .groups -}}
0000000000000000000000000000000000000000;;				{{range $version := .Versions -}}
0000000000000000000000000000000000000000;;			// Group={{$group.Name}}, Version={{.Name}}
0000000000000000000000000000000000000000;;					{{range .Resources -}}
0000000000000000000000000000000000000000;;		case {{index $.schemeGVs $version|raw}}.WithResource("{{.|allLowercasePlural}}"):
0000000000000000000000000000000000000000;;			return &genericInformer{resource: resource.GroupResource(), informer: f.{{$group.Name}}().{{$version.Name}}().{{.|publicPlural}}().Informer()}, nil
0000000000000000000000000000000000000000;;					{{end}}
0000000000000000000000000000000000000000;;				{{end}}
0000000000000000000000000000000000000000;;			{{end -}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("no informer found for %v", resource)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
