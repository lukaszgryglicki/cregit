0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
90e753b7d893977fcb7246ab3277eaab11726cf4;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package generators
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;		clientgentypes "k8s.io/kubernetes/cmd/libs/go2idl/client-gen/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// groupInterfaceGenerator generates the per-group interface file.
0000000000000000000000000000000000000000;;	type groupInterfaceGenerator struct {
0000000000000000000000000000000000000000;;		generator.DefaultGen
0000000000000000000000000000000000000000;;		outputPackage             string
0000000000000000000000000000000000000000;;		imports                   namer.ImportTracker
0000000000000000000000000000000000000000;;		groupVersions             clientgentypes.GroupVersions
0000000000000000000000000000000000000000;;		filtered                  bool
0000000000000000000000000000000000000000;;		internalInterfacesPackage string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ generator.Generator = &groupInterfaceGenerator{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *groupInterfaceGenerator) Filter(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;		if !g.filtered {
0000000000000000000000000000000000000000;;			g.filtered = true
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *groupInterfaceGenerator) Namers(c *generator.Context) namer.NameSystems {
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"raw": namer.NewRawNamer(g.outputPackage, g.imports),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *groupInterfaceGenerator) Imports(c *generator.Context) (imports []string) {
0000000000000000000000000000000000000000;;		imports = append(imports, g.imports.ImportLines()...)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type versionData struct {
0000000000000000000000000000000000000000;;		Name      string
0000000000000000000000000000000000000000;;		Interface *types.Type
0000000000000000000000000000000000000000;;		New       *types.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *groupInterfaceGenerator) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(w, c, "$", "$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		versions := make([]versionData, 0, len(g.groupVersions.Versions))
0000000000000000000000000000000000000000;;		for _, version := range g.groupVersions.Versions {
0000000000000000000000000000000000000000;;			gv := clientgentypes.GroupVersion{Group: g.groupVersions.Group, Version: version}
0000000000000000000000000000000000000000;;			versionPackage := filepath.Join(g.outputPackage, strings.ToLower(gv.Version.NonEmpty()))
0000000000000000000000000000000000000000;;			iface := c.Universe.Type(types.Name{Package: versionPackage, Name: "Interface"})
0000000000000000000000000000000000000000;;			versions = append(versions, versionData{
0000000000000000000000000000000000000000;;				Name:      namer.IC(version.NonEmpty()),
0000000000000000000000000000000000000000;;				Interface: iface,
0000000000000000000000000000000000000000;;				New:       c.Universe.Function(types.Name{Package: versionPackage, Name: "New"}),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m := map[string]interface{}{
0000000000000000000000000000000000000000;;			"interfacesSharedInformerFactory": c.Universe.Type(types.Name{Package: g.internalInterfacesPackage, Name: "SharedInformerFactory"}),
0000000000000000000000000000000000000000;;			"versions":                        versions,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sw.Do(groupTemplate, m)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sw.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var groupTemplate = `
0000000000000000000000000000000000000000;;	// Interface provides access to each of this group's versions.
0000000000000000000000000000000000000000;;	type Interface interface {
0000000000000000000000000000000000000000;;		$range .versions -$
0000000000000000000000000000000000000000;;			// $.Name$ provides access to shared informers for resources in $.Name$.
0000000000000000000000000000000000000000;;			$.Name$() $.Interface|raw$
0000000000000000000000000000000000000000;;		$end$
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type group struct {
0000000000000000000000000000000000000000;;		$.interfacesSharedInformerFactory|raw$
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a new Interface.
0000000000000000000000000000000000000000;;	func New(f $.interfacesSharedInformerFactory|raw$) Interface {
0000000000000000000000000000000000000000;;		return &group{f}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	$range .versions$
0000000000000000000000000000000000000000;;	// $.Name$ returns a new $.Interface|raw$.
0000000000000000000000000000000000000000;;	func (g *group) $.Name$() $.Interface|raw$ {
0000000000000000000000000000000000000000;;		return $.New|raw$(g.SharedInformerFactory)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	$end$
0000000000000000000000000000000000000000;;	`
