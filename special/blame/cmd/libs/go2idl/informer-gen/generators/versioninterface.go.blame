0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
90e753b7d893977fcb7246ab3277eaab11726cf4;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package generators
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// versionInterfaceGenerator generates the per-version interface file.
0000000000000000000000000000000000000000;;	type versionInterfaceGenerator struct {
0000000000000000000000000000000000000000;;		generator.DefaultGen
0000000000000000000000000000000000000000;;		outputPackage             string
0000000000000000000000000000000000000000;;		imports                   namer.ImportTracker
0000000000000000000000000000000000000000;;		types                     []*types.Type
0000000000000000000000000000000000000000;;		filtered                  bool
0000000000000000000000000000000000000000;;		internalInterfacesPackage string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ generator.Generator = &versionInterfaceGenerator{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *versionInterfaceGenerator) Filter(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;		if !g.filtered {
0000000000000000000000000000000000000000;;			g.filtered = true
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *versionInterfaceGenerator) Namers(c *generator.Context) namer.NameSystems {
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"raw": namer.NewRawNamer(g.outputPackage, g.imports),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *versionInterfaceGenerator) Imports(c *generator.Context) (imports []string) {
0000000000000000000000000000000000000000;;		imports = append(imports, g.imports.ImportLines()...)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *versionInterfaceGenerator) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(w, c, "$", "$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := map[string]interface{}{
0000000000000000000000000000000000000000;;			"interfacesSharedInformerFactory": c.Universe.Type(types.Name{Package: g.internalInterfacesPackage, Name: "SharedInformerFactory"}),
0000000000000000000000000000000000000000;;			"types": g.types,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sw.Do(versionTemplate, m)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sw.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var versionTemplate = `
0000000000000000000000000000000000000000;;	// Interface provides access to all the informers in this group version.
0000000000000000000000000000000000000000;;	type Interface interface {
0000000000000000000000000000000000000000;;		$range .types -$
0000000000000000000000000000000000000000;;			// $.|publicPlural$ returns a $.|public$Informer.
0000000000000000000000000000000000000000;;			$.|publicPlural$() $.|public$Informer
0000000000000000000000000000000000000000;;		$end$
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type version struct {
0000000000000000000000000000000000000000;;		$.interfacesSharedInformerFactory|raw$
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a new Interface.
0000000000000000000000000000000000000000;;	func New(f $.interfacesSharedInformerFactory|raw$) Interface {
0000000000000000000000000000000000000000;;		return &version{f}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	$range .types$
0000000000000000000000000000000000000000;;	// $.|publicPlural$ returns a $.|public$Informer.
0000000000000000000000000000000000000000;;	func (v *version) $.|publicPlural$() $.|public$Informer {
0000000000000000000000000000000000000000;;		return &$.|private$Informer{factory: v.SharedInformerFactory}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	$end$
0000000000000000000000000000000000000000;;	`
