0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
4ac65c38863bea82dd9e7f52f4c39a42d440ff18;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package protobuf
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type localNamer struct {
0000000000000000000000000000000000000000;;		localPackage types.Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n localNamer) Name(t *types.Type) string {
0000000000000000000000000000000000000000;;		if t.Key != nil && t.Elem != nil {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("map<%s, %s>", n.Name(t.Key), n.Name(t.Elem))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(n.localPackage.Package) != 0 && n.localPackage.Package == t.Name.Package {
0000000000000000000000000000000000000000;;			return t.Name.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.Name.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type protobufNamer struct {
0000000000000000000000000000000000000000;;		packages       []*protobufPackage
0000000000000000000000000000000000000000;;		packagesByPath map[string]*protobufPackage
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewProtobufNamer() *protobufNamer {
0000000000000000000000000000000000000000;;		return &protobufNamer{
0000000000000000000000000000000000000000;;			packagesByPath: make(map[string]*protobufPackage),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *protobufNamer) Name(t *types.Type) string {
0000000000000000000000000000000000000000;;		if t.Kind == types.Map {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("map<%s, %s>", n.Name(t.Key), n.Name(t.Elem))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.Name.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *protobufNamer) List() []generator.Package {
0000000000000000000000000000000000000000;;		packages := make([]generator.Package, 0, len(n.packages))
0000000000000000000000000000000000000000;;		for i := range n.packages {
0000000000000000000000000000000000000000;;			packages = append(packages, n.packages[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return packages
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *protobufNamer) Add(p *protobufPackage) {
0000000000000000000000000000000000000000;;		if _, ok := n.packagesByPath[p.PackagePath]; !ok {
0000000000000000000000000000000000000000;;			n.packagesByPath[p.PackagePath] = p
0000000000000000000000000000000000000000;;			n.packages = append(n.packages, p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *protobufNamer) GoNameToProtoName(name types.Name) types.Name {
0000000000000000000000000000000000000000;;		if p, ok := n.packagesByPath[name.Package]; ok {
0000000000000000000000000000000000000000;;			return types.Name{
0000000000000000000000000000000000000000;;				Name:    name.Name,
0000000000000000000000000000000000000000;;				Package: p.PackageName,
0000000000000000000000000000000000000000;;				Path:    p.ImportPath(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, p := range n.packages {
0000000000000000000000000000000000000000;;			if _, ok := p.FilterTypes[name]; ok {
0000000000000000000000000000000000000000;;				return types.Name{
0000000000000000000000000000000000000000;;					Name:    name.Name,
0000000000000000000000000000000000000000;;					Package: p.PackageName,
0000000000000000000000000000000000000000;;					Path:    p.ImportPath(),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return types.Name{Name: name.Name}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func protoSafePackage(name string) string {
0000000000000000000000000000000000000000;;		pkg := strings.Replace(name, "/", ".", -1)
0000000000000000000000000000000000000000;;		return strings.Replace(pkg, "-", "_", -1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type typeNameSet map[types.Name]*protobufPackage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// assignGoTypeToProtoPackage looks for Go and Protobuf types that are referenced by a type in
0000000000000000000000000000000000000000;;	// a package. It will not recurse into protobuf types.
0000000000000000000000000000000000000000;;	func assignGoTypeToProtoPackage(p *protobufPackage, t *types.Type, local, global typeNameSet, optional map[types.Name]struct{}) {
0000000000000000000000000000000000000000;;		newT, isProto := isFundamentalProtoType(t)
0000000000000000000000000000000000000000;;		if isProto {
0000000000000000000000000000000000000000;;			t = newT
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if otherP, ok := global[t.Name]; ok {
0000000000000000000000000000000000000000;;			if _, ok := local[t.Name]; !ok {
0000000000000000000000000000000000000000;;				p.Imports.AddType(&types.Type{
0000000000000000000000000000000000000000;;					Kind: types.Protobuf,
0000000000000000000000000000000000000000;;					Name: otherP.ProtoTypeName(),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		global[t.Name] = p
0000000000000000000000000000000000000000;;		if _, ok := local[t.Name]; ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// don't recurse into existing proto types
0000000000000000000000000000000000000000;;		if isProto {
0000000000000000000000000000000000000000;;			p.Imports.AddType(t)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		local[t.Name] = p
0000000000000000000000000000000000000000;;		for _, m := range t.Members {
0000000000000000000000000000000000000000;;			if namer.IsPrivateGoName(m.Name) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			field := &protoField{}
0000000000000000000000000000000000000000;;			tag := reflect.StructTag(m.Tags).Get("protobuf")
0000000000000000000000000000000000000000;;			if tag == "-" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := protobufTagToField(tag, field, m, t, p.ProtoTypeName()); err == nil && field.Type != nil {
0000000000000000000000000000000000000000;;				assignGoTypeToProtoPackage(p, field.Type, local, global, optional)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			assignGoTypeToProtoPackage(p, m.Type, local, global, optional)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: should methods be walked?
0000000000000000000000000000000000000000;;		if t.Elem != nil {
0000000000000000000000000000000000000000;;			assignGoTypeToProtoPackage(p, t.Elem, local, global, optional)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.Key != nil {
0000000000000000000000000000000000000000;;			assignGoTypeToProtoPackage(p, t.Key, local, global, optional)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.Underlying != nil {
0000000000000000000000000000000000000000;;			if t.Kind == types.Alias && isOptionalAlias(t) {
0000000000000000000000000000000000000000;;				optional[t.Name] = struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			assignGoTypeToProtoPackage(p, t.Underlying, local, global, optional)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isTypeApplicableToProtobuf checks to see if a type is relevant for protobuf processing.
0000000000000000000000000000000000000000;;	// Currently, it filters out functions and private types.
0000000000000000000000000000000000000000;;	func isTypeApplicableToProtobuf(t *types.Type) bool {
0000000000000000000000000000000000000000;;		// skip functions -- we don't care about them for protobuf
0000000000000000000000000000000000000000;;		if t.Kind == types.Func || (t.Kind == types.DeclarationOf && t.Underlying.Kind == types.Func) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// skip private types
0000000000000000000000000000000000000000;;		if namer.IsPrivateGoName(t.Name.Name) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *protobufNamer) AssignTypesToPackages(c *generator.Context) error {
0000000000000000000000000000000000000000;;		global := make(typeNameSet)
0000000000000000000000000000000000000000;;		for _, p := range n.packages {
0000000000000000000000000000000000000000;;			local := make(typeNameSet)
0000000000000000000000000000000000000000;;			optional := make(map[types.Name]struct{})
0000000000000000000000000000000000000000;;			p.Imports = NewImportTracker(p.ProtoTypeName())
0000000000000000000000000000000000000000;;			for _, t := range c.Order {
0000000000000000000000000000000000000000;;				if t.Name.Package != p.PackagePath {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !isTypeApplicableToProtobuf(t) {
0000000000000000000000000000000000000000;;					// skip types that we don't care about, like functions
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				assignGoTypeToProtoPackage(p, t, local, global, optional)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.FilterTypes = make(map[types.Name]struct{})
0000000000000000000000000000000000000000;;			p.LocalNames = make(map[string]struct{})
0000000000000000000000000000000000000000;;			p.OptionalTypeNames = make(map[string]struct{})
0000000000000000000000000000000000000000;;			for k, v := range local {
0000000000000000000000000000000000000000;;				if v == p {
0000000000000000000000000000000000000000;;					p.FilterTypes[k] = struct{}{}
0000000000000000000000000000000000000000;;					p.LocalNames[k.Name] = struct{}{}
0000000000000000000000000000000000000000;;					if _, ok := optional[k]; ok {
0000000000000000000000000000000000000000;;						p.OptionalTypeNames[k.Name] = struct{}{}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
