0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
4ac65c38863bea82dd9e7f52f4c39a42d440ff18;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package protobuf
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"go/ast"
0000000000000000000000000000000000000000;;		"go/format"
0000000000000000000000000000000000000000;;		"go/parser"
0000000000000000000000000000000000000000;;		"go/printer"
0000000000000000000000000000000000000000;;		"go/token"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		customreflect "k8s.io/apimachinery/third_party/forked/golang/reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func rewriteFile(name string, header []byte, rewriteFn func(*token.FileSet, *ast.File) error) error {
0000000000000000000000000000000000000000;;		fset := token.NewFileSet()
0000000000000000000000000000000000000000;;		src, err := ioutil.ReadFile(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		file, err := parser.ParseFile(fset, name, src, parser.DeclarationErrors|parser.ParseComments)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := rewriteFn(fset, file); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		b.Write(header)
0000000000000000000000000000000000000000;;		if err := printer.Fprint(b, fset, file); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err := format.Source(b.Bytes())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := os.OpenFile(name, os.O_WRONLY|os.O_TRUNC, 0644)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;		if _, err := f.Write(body); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractFunc extracts information from the provided TypeSpec and returns true if the type should be
0000000000000000000000000000000000000000;;	// removed from the destination file.
0000000000000000000000000000000000000000;;	type ExtractFunc func(*ast.TypeSpec) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OptionalFunc returns true if the provided local name is a type that has protobuf.nullable=true
0000000000000000000000000000000000000000;;	// and should have its marshal functions adjusted to remove the 'Items' accessor.
0000000000000000000000000000000000000000;;	type OptionalFunc func(name string) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RewriteGeneratedGogoProtobufFile(name string, extractFn ExtractFunc, optionalFn OptionalFunc, header []byte) error {
0000000000000000000000000000000000000000;;		return rewriteFile(name, header, func(fset *token.FileSet, file *ast.File) error {
0000000000000000000000000000000000000000;;			cmap := ast.NewCommentMap(fset, file, file.Comments)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// transform methods that point to optional maps or slices
0000000000000000000000000000000000000000;;			for _, d := range file.Decls {
0000000000000000000000000000000000000000;;				rewriteOptionalMethods(d, optionalFn)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// remove types that are already declared
0000000000000000000000000000000000000000;;			decls := []ast.Decl{}
0000000000000000000000000000000000000000;;			for _, d := range file.Decls {
0000000000000000000000000000000000000000;;				if dropExistingTypeDeclarations(d, extractFn) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if dropEmptyImportDeclarations(d) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				decls = append(decls, d)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			file.Decls = decls
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// remove unmapped comments
0000000000000000000000000000000000000000;;			file.Comments = cmap.Filter(file).Comments()
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rewriteOptionalMethods makes specific mutations to marshaller methods that belong to types identified
0000000000000000000000000000000000000000;;	// as being "optional" (they may be nil on the wire). This allows protobuf to serialize a map or slice and
0000000000000000000000000000000000000000;;	// properly discriminate between empty and nil (which is not possible in protobuf).
0000000000000000000000000000000000000000;;	// TODO: move into upstream gogo-protobuf once https://github.com/gogo/protobuf/issues/181
0000000000000000000000000000000000000000;;	//   has agreement
0000000000000000000000000000000000000000;;	func rewriteOptionalMethods(decl ast.Decl, isOptional OptionalFunc) {
0000000000000000000000000000000000000000;;		switch t := decl.(type) {
0000000000000000000000000000000000000000;;		case *ast.FuncDecl:
0000000000000000000000000000000000000000;;			ident, ptr, ok := receiver(t)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// correct initialization of the form `m.Field = &OptionalType{}` to
0000000000000000000000000000000000000000;;			// `m.Field = OptionalType{}`
0000000000000000000000000000000000000000;;			if t.Name.Name == "Unmarshal" {
0000000000000000000000000000000000000000;;				ast.Walk(optionalAssignmentVisitor{fn: isOptional}, t.Body)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !isOptional(ident.Name) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch t.Name.Name {
0000000000000000000000000000000000000000;;			case "Unmarshal":
0000000000000000000000000000000000000000;;				ast.Walk(&optionalItemsVisitor{}, t.Body)
0000000000000000000000000000000000000000;;			case "MarshalTo", "Size", "String":
0000000000000000000000000000000000000000;;				ast.Walk(&optionalItemsVisitor{}, t.Body)
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;			case "Marshal":
0000000000000000000000000000000000000000;;				// if the method has a pointer receiver, set it back to a normal receiver
0000000000000000000000000000000000000000;;				if ptr {
0000000000000000000000000000000000000000;;					t.Recv.List[0].Type = ident
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type optionalAssignmentVisitor struct {
0000000000000000000000000000000000000000;;		fn OptionalFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Visit walks the provided node, transforming field initializations of the form
0000000000000000000000000000000000000000;;	// m.Field = &OptionalType{} -> m.Field = OptionalType{}
0000000000000000000000000000000000000000;;	func (v optionalAssignmentVisitor) Visit(n ast.Node) ast.Visitor {
0000000000000000000000000000000000000000;;		switch t := n.(type) {
0000000000000000000000000000000000000000;;		case *ast.AssignStmt:
0000000000000000000000000000000000000000;;			if len(t.Lhs) == 1 && len(t.Rhs) == 1 {
0000000000000000000000000000000000000000;;				if !isFieldSelector(t.Lhs[0], "m", "") {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				unary, ok := t.Rhs[0].(*ast.UnaryExpr)
0000000000000000000000000000000000000000;;				if !ok || unary.Op != token.AND {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				composite, ok := unary.X.(*ast.CompositeLit)
0000000000000000000000000000000000000000;;				if !ok || composite.Type == nil || len(composite.Elts) != 0 {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if ident, ok := composite.Type.(*ast.Ident); ok && v.fn(ident.Name) {
0000000000000000000000000000000000000000;;					t.Rhs[0] = composite
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type optionalItemsVisitor struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Visit walks the provided node, looking for specific patterns to transform that match
0000000000000000000000000000000000000000;;	// the effective outcome of turning struct{ map[x]y || []x } into map[x]y or []x.
0000000000000000000000000000000000000000;;	func (v *optionalItemsVisitor) Visit(n ast.Node) ast.Visitor {
0000000000000000000000000000000000000000;;		switch t := n.(type) {
0000000000000000000000000000000000000000;;		case *ast.RangeStmt:
0000000000000000000000000000000000000000;;			if isFieldSelector(t.X, "m", "Items") {
0000000000000000000000000000000000000000;;				t.X = &ast.Ident{Name: "m"}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *ast.AssignStmt:
0000000000000000000000000000000000000000;;			if len(t.Lhs) == 1 && len(t.Rhs) == 1 {
0000000000000000000000000000000000000000;;				switch lhs := t.Lhs[0].(type) {
0000000000000000000000000000000000000000;;				case *ast.IndexExpr:
0000000000000000000000000000000000000000;;					if isFieldSelector(lhs.X, "m", "Items") {
0000000000000000000000000000000000000000;;						lhs.X = &ast.StarExpr{X: &ast.Ident{Name: "m"}}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					if isFieldSelector(t.Lhs[0], "m", "Items") {
0000000000000000000000000000000000000000;;						t.Lhs[0] = &ast.StarExpr{X: &ast.Ident{Name: "m"}}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch rhs := t.Rhs[0].(type) {
0000000000000000000000000000000000000000;;				case *ast.CallExpr:
0000000000000000000000000000000000000000;;					if ident, ok := rhs.Fun.(*ast.Ident); ok && ident.Name == "append" {
0000000000000000000000000000000000000000;;						ast.Walk(v, rhs)
0000000000000000000000000000000000000000;;						if len(rhs.Args) > 0 {
0000000000000000000000000000000000000000;;							switch arg := rhs.Args[0].(type) {
0000000000000000000000000000000000000000;;							case *ast.Ident:
0000000000000000000000000000000000000000;;								if arg.Name == "m" {
0000000000000000000000000000000000000000;;									rhs.Args[0] = &ast.StarExpr{X: &ast.Ident{Name: "m"}}
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *ast.IfStmt:
0000000000000000000000000000000000000000;;			switch cond := t.Cond.(type) {
0000000000000000000000000000000000000000;;			case *ast.BinaryExpr:
0000000000000000000000000000000000000000;;				if cond.Op == token.EQL {
0000000000000000000000000000000000000000;;					if isFieldSelector(cond.X, "m", "Items") && isIdent(cond.Y, "nil") {
0000000000000000000000000000000000000000;;						cond.X = &ast.StarExpr{X: &ast.Ident{Name: "m"}}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if t.Init != nil {
0000000000000000000000000000000000000000;;				// Find form:
0000000000000000000000000000000000000000;;				// if err := m[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
0000000000000000000000000000000000000000;;				// 	return err
0000000000000000000000000000000000000000;;				// }
0000000000000000000000000000000000000000;;				switch s := t.Init.(type) {
0000000000000000000000000000000000000000;;				case *ast.AssignStmt:
0000000000000000000000000000000000000000;;					if call, ok := s.Rhs[0].(*ast.CallExpr); ok {
0000000000000000000000000000000000000000;;						if sel, ok := call.Fun.(*ast.SelectorExpr); ok {
0000000000000000000000000000000000000000;;							if x, ok := sel.X.(*ast.IndexExpr); ok {
0000000000000000000000000000000000000000;;								// m[] -> (*m)[]
0000000000000000000000000000000000000000;;								if sel2, ok := x.X.(*ast.SelectorExpr); ok {
0000000000000000000000000000000000000000;;									if ident, ok := sel2.X.(*ast.Ident); ok && ident.Name == "m" {
0000000000000000000000000000000000000000;;										x.X = &ast.StarExpr{X: &ast.Ident{Name: "m"}}
0000000000000000000000000000000000000000;;									}
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;								// len(m.Items) -> len(*m)
0000000000000000000000000000000000000000;;								if bin, ok := x.Index.(*ast.BinaryExpr); ok {
0000000000000000000000000000000000000000;;									if call2, ok := bin.X.(*ast.CallExpr); ok && len(call2.Args) == 1 {
0000000000000000000000000000000000000000;;										if isFieldSelector(call2.Args[0], "m", "Items") {
0000000000000000000000000000000000000000;;											call2.Args[0] = &ast.StarExpr{X: &ast.Ident{Name: "m"}}
0000000000000000000000000000000000000000;;										}
0000000000000000000000000000000000000000;;									}
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *ast.IndexExpr:
0000000000000000000000000000000000000000;;			if isFieldSelector(t.X, "m", "Items") {
0000000000000000000000000000000000000000;;				t.X = &ast.Ident{Name: "m"}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *ast.CallExpr:
0000000000000000000000000000000000000000;;			changed := false
0000000000000000000000000000000000000000;;			for i := range t.Args {
0000000000000000000000000000000000000000;;				if isFieldSelector(t.Args[i], "m", "Items") {
0000000000000000000000000000000000000000;;					t.Args[i] = &ast.Ident{Name: "m"}
0000000000000000000000000000000000000000;;					changed = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if changed {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isFieldSelector(n ast.Expr, name, field string) bool {
0000000000000000000000000000000000000000;;		s, ok := n.(*ast.SelectorExpr)
0000000000000000000000000000000000000000;;		if !ok || s.Sel == nil || (field != "" && s.Sel.Name != field) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return isIdent(s.X, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isIdent(n ast.Expr, value string) bool {
0000000000000000000000000000000000000000;;		ident, ok := n.(*ast.Ident)
0000000000000000000000000000000000000000;;		return ok && ident.Name == value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func receiver(f *ast.FuncDecl) (ident *ast.Ident, pointer bool, ok bool) {
0000000000000000000000000000000000000000;;		if f.Recv == nil || len(f.Recv.List) != 1 {
0000000000000000000000000000000000000000;;			return nil, false, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t := f.Recv.List[0].Type.(type) {
0000000000000000000000000000000000000000;;		case *ast.StarExpr:
0000000000000000000000000000000000000000;;			identity, ok := t.X.(*ast.Ident)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, false, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return identity, true, true
0000000000000000000000000000000000000000;;		case *ast.Ident:
0000000000000000000000000000000000000000;;			return t, false, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dropExistingTypeDeclarations removes any type declaration for which extractFn returns true. The function
0000000000000000000000000000000000000000;;	// returns true if the entire declaration should be dropped.
0000000000000000000000000000000000000000;;	func dropExistingTypeDeclarations(decl ast.Decl, extractFn ExtractFunc) bool {
0000000000000000000000000000000000000000;;		switch t := decl.(type) {
0000000000000000000000000000000000000000;;		case *ast.GenDecl:
0000000000000000000000000000000000000000;;			if t.Tok != token.TYPE {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			specs := []ast.Spec{}
0000000000000000000000000000000000000000;;			for _, s := range t.Specs {
0000000000000000000000000000000000000000;;				switch spec := s.(type) {
0000000000000000000000000000000000000000;;				case *ast.TypeSpec:
0000000000000000000000000000000000000000;;					if extractFn(spec) {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					specs = append(specs, spec)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(specs) == 0 {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Specs = specs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dropEmptyImportDeclarations strips any generated but no-op imports from the generated code
0000000000000000000000000000000000000000;;	// to prevent generation from being able to define side-effects.  The function returns true
0000000000000000000000000000000000000000;;	// if the entire declaration should be dropped.
0000000000000000000000000000000000000000;;	func dropEmptyImportDeclarations(decl ast.Decl) bool {
0000000000000000000000000000000000000000;;		switch t := decl.(type) {
0000000000000000000000000000000000000000;;		case *ast.GenDecl:
0000000000000000000000000000000000000000;;			if t.Tok != token.IMPORT {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			specs := []ast.Spec{}
0000000000000000000000000000000000000000;;			for _, s := range t.Specs {
0000000000000000000000000000000000000000;;				switch spec := s.(type) {
0000000000000000000000000000000000000000;;				case *ast.ImportSpec:
0000000000000000000000000000000000000000;;					if spec.Name != nil && spec.Name.Name == "_" {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					specs = append(specs, spec)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(specs) == 0 {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Specs = specs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RewriteTypesWithProtobufStructTags(name string, structTags map[string]map[string]string) error {
0000000000000000000000000000000000000000;;		return rewriteFile(name, []byte{}, func(fset *token.FileSet, file *ast.File) error {
0000000000000000000000000000000000000000;;			allErrs := []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// set any new struct tags
0000000000000000000000000000000000000000;;			for _, d := range file.Decls {
0000000000000000000000000000000000000000;;				if errs := updateStructTags(d, structTags, []string{"protobuf"}); len(errs) > 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, errs...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(allErrs) > 0 {
0000000000000000000000000000000000000000;;				var s string
0000000000000000000000000000000000000000;;				for _, err := range allErrs {
0000000000000000000000000000000000000000;;					s += err.Error() + "\n"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return errors.New(s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updateStructTags(decl ast.Decl, structTags map[string]map[string]string, toCopy []string) []error {
0000000000000000000000000000000000000000;;		var errs []error
0000000000000000000000000000000000000000;;		t, ok := decl.(*ast.GenDecl)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.Tok != token.TYPE {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, s := range t.Specs {
0000000000000000000000000000000000000000;;			spec, ok := s.(*ast.TypeSpec)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			typeName := spec.Name.Name
0000000000000000000000000000000000000000;;			fieldTags, ok := structTags[typeName]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			st, ok := spec.Type.(*ast.StructType)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i := range st.Fields.List {
0000000000000000000000000000000000000000;;				f := st.Fields.List[i]
0000000000000000000000000000000000000000;;				var name string
0000000000000000000000000000000000000000;;				if len(f.Names) == 0 {
0000000000000000000000000000000000000000;;					switch t := f.Type.(type) {
0000000000000000000000000000000000000000;;					case *ast.Ident:
0000000000000000000000000000000000000000;;						name = t.Name
0000000000000000000000000000000000000000;;					case *ast.SelectorExpr:
0000000000000000000000000000000000000000;;						name = t.Sel.Name
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						errs = append(errs, fmt.Errorf("unable to get name for tag from struct %q, field %#v", spec.Name.Name, t))
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					name = f.Names[0].Name
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				value, ok := fieldTags[name]
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				var tags customreflect.StructTags
0000000000000000000000000000000000000000;;				if f.Tag != nil {
0000000000000000000000000000000000000000;;					oldTags, err := customreflect.ParseStructTags(strings.Trim(f.Tag.Value, "`"))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						errs = append(errs, fmt.Errorf("unable to read struct tag from struct %q, field %q: %v", spec.Name.Name, name, err))
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					tags = oldTags
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, name := range toCopy {
0000000000000000000000000000000000000000;;					// don't overwrite existing tags
0000000000000000000000000000000000000000;;					if tags.Has(name) {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// append new tags
0000000000000000000000000000000000000000;;					if v := reflect.StructTag(value).Get(name); len(v) > 0 {
0000000000000000000000000000000000000000;;						tags = append(tags, customreflect.StructTag{Name: name, Value: v})
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(tags) == 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if f.Tag == nil {
0000000000000000000000000000000000000000;;					f.Tag = &ast.BasicLit{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				f.Tag.Value = tags.String()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errs
0000000000000000000000000000000000000000;;	}
