0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
4ac65c38863bea82dd9e7f52f4c39a42d440ff18;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// go-to-protobuf generates a Protobuf IDL from a Go struct, respecting any
0000000000000000000000000000000000000000;;	// existing IDL tags on the Go struct.
0000000000000000000000000000000000000000;;	package protobuf
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/args"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/parser"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flag "github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Generator struct {
0000000000000000000000000000000000000000;;		Common               args.GeneratorArgs
0000000000000000000000000000000000000000;;		Packages             string
0000000000000000000000000000000000000000;;		OutputBase           string
0000000000000000000000000000000000000000;;		VendorOutputBase     string
0000000000000000000000000000000000000000;;		ProtoImport          []string
0000000000000000000000000000000000000000;;		Conditional          string
0000000000000000000000000000000000000000;;		Clean                bool
0000000000000000000000000000000000000000;;		OnlyIDL              bool
0000000000000000000000000000000000000000;;		KeepGogoproto        bool
0000000000000000000000000000000000000000;;		SkipGeneratedRewrite bool
0000000000000000000000000000000000000000;;		DropEmbeddedFields   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New() *Generator {
0000000000000000000000000000000000000000;;		sourceTree := args.DefaultSourceTree()
0000000000000000000000000000000000000000;;		common := args.GeneratorArgs{
0000000000000000000000000000000000000000;;			OutputBase:       sourceTree,
0000000000000000000000000000000000000000;;			GoHeaderFilePath: filepath.Join(sourceTree, "k8s.io/kubernetes/hack/boilerplate/boilerplate.go.txt"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defaultProtoImport := filepath.Join(sourceTree, "k8s.io", "kubernetes", "vendor", "github.com", "gogo", "protobuf", "protobuf")
0000000000000000000000000000000000000000;;		return &Generator{
0000000000000000000000000000000000000000;;			Common:           common,
0000000000000000000000000000000000000000;;			OutputBase:       sourceTree,
0000000000000000000000000000000000000000;;			VendorOutputBase: filepath.Join(sourceTree, "k8s.io", "kubernetes", "vendor"),
0000000000000000000000000000000000000000;;			ProtoImport:      []string{defaultProtoImport},
0000000000000000000000000000000000000000;;			Packages: strings.Join([]string{
0000000000000000000000000000000000000000;;				`+k8s.io/apimachinery/pkg/util/intstr`,
0000000000000000000000000000000000000000;;				`+k8s.io/apimachinery/pkg/api/resource`,
0000000000000000000000000000000000000000;;				`+k8s.io/apimachinery/pkg/runtime/schema`,
0000000000000000000000000000000000000000;;				`+k8s.io/apimachinery/pkg/runtime`,
0000000000000000000000000000000000000000;;				`k8s.io/apimachinery/pkg/apis/meta/v1`,
0000000000000000000000000000000000000000;;				`k8s.io/apimachinery/pkg/apis/meta/v1alpha1`,
0000000000000000000000000000000000000000;;				`k8s.io/apiserver/pkg/apis/example/v1`,
0000000000000000000000000000000000000000;;				`k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1beta1`,
0000000000000000000000000000000000000000;;				`k8s.io/kube-aggregator/pkg/apis/apiregistration/v1beta1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/core/v1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/policy/v1beta1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/extensions/v1beta1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/autoscaling/v1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/authorization/v1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/autoscaling/v2alpha1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/authorization/v1beta1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/batch/v1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/batch/v2alpha1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/apps/v1beta1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/authentication/v1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/authentication/v1beta1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/rbac/v1alpha1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/rbac/v1beta1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/certificates/v1beta1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/imagepolicy/v1alpha1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/settings/v1alpha1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/storage/v1beta1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/storage/v1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/admissionregistration/v1alpha1`,
0000000000000000000000000000000000000000;;				`k8s.io/api/networking/v1`,
0000000000000000000000000000000000000000;;				`k8s.io/kubernetes/federation/apis/federation/v1beta1`,
0000000000000000000000000000000000000000;;				`k8s.io/kubernetes/pkg/apis/admission/v1alpha1`,
0000000000000000000000000000000000000000;;				`k8s.io/metrics/pkg/apis/metrics/v1alpha1`,
0000000000000000000000000000000000000000;;				`k8s.io/metrics/pkg/apis/custom_metrics/v1alpha1`,
0000000000000000000000000000000000000000;;				`k8s.io/apiserver/pkg/apis/audit/v1alpha1`,
0000000000000000000000000000000000000000;;			}, ","),
0000000000000000000000000000000000000000;;			DropEmbeddedFields: "k8s.io/apimachinery/pkg/apis/meta/v1.TypeMeta",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) BindFlags(flag *flag.FlagSet) {
0000000000000000000000000000000000000000;;		flag.StringVarP(&g.Common.GoHeaderFilePath, "go-header-file", "h", g.Common.GoHeaderFilePath, "File containing boilerplate header text. The string YEAR will be replaced with the current 4-digit year.")
0000000000000000000000000000000000000000;;		flag.BoolVar(&g.Common.VerifyOnly, "verify-only", g.Common.VerifyOnly, "If true, only verify existing output, do not write anything.")
0000000000000000000000000000000000000000;;		flag.StringVarP(&g.Packages, "packages", "p", g.Packages, "comma-separated list of directories to get input types from. Directories prefixed with '-' are not generated, directories prefixed with '+' only create types with explicit IDL instructions.")
0000000000000000000000000000000000000000;;		flag.StringVarP(&g.OutputBase, "output-base", "o", g.OutputBase, "Output base; defaults to $GOPATH/src/")
0000000000000000000000000000000000000000;;		flag.StringSliceVar(&g.ProtoImport, "proto-import", g.ProtoImport, "The search path for the core protobuf .protos, required, defaults to GODEPS on path.")
0000000000000000000000000000000000000000;;		flag.StringVar(&g.Conditional, "conditional", g.Conditional, "An optional Golang build tag condition to add to the generated Go code")
0000000000000000000000000000000000000000;;		flag.BoolVar(&g.Clean, "clean", g.Clean, "If true, remove all generated files for the specified Packages.")
0000000000000000000000000000000000000000;;		flag.BoolVar(&g.OnlyIDL, "only-idl", g.OnlyIDL, "If true, only generate the IDL for each package.")
0000000000000000000000000000000000000000;;		flag.BoolVar(&g.KeepGogoproto, "keep-gogoproto", g.KeepGogoproto, "If true, the generated IDL will contain gogoprotobuf extensions which are normally removed")
0000000000000000000000000000000000000000;;		flag.BoolVar(&g.SkipGeneratedRewrite, "skip-generated-rewrite", g.SkipGeneratedRewrite, "If true, skip fixing up the generated.pb.go file (debugging only).")
0000000000000000000000000000000000000000;;		flag.StringVar(&g.DropEmbeddedFields, "drop-embedded-fields", g.DropEmbeddedFields, "Comma-delimited list of embedded Go types to omit from generated protobufs")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Run(g *Generator) {
0000000000000000000000000000000000000000;;		if g.Common.VerifyOnly {
0000000000000000000000000000000000000000;;			g.OnlyIDL = true
0000000000000000000000000000000000000000;;			g.Clean = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := parser.New()
0000000000000000000000000000000000000000;;		b.AddBuildTags("proto")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		omitTypes := map[types.Name]struct{}{}
0000000000000000000000000000000000000000;;		for _, t := range strings.Split(g.DropEmbeddedFields, ",") {
0000000000000000000000000000000000000000;;			name := types.Name{}
0000000000000000000000000000000000000000;;			if i := strings.LastIndex(t, "."); i != -1 {
0000000000000000000000000000000000000000;;				name.Package, name.Name = t[:i], t[i+1:]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				name.Name = t
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(name.Name) == 0 {
0000000000000000000000000000000000000000;;				log.Fatalf("--drop-embedded-types requires names in the form of [GOPACKAGE.]TYPENAME: %v", t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			omitTypes[name] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		boilerplate, err := g.Common.LoadGoBoilerplate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Fatalf("Failed loading boilerplate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		protobufNames := NewProtobufNamer()
0000000000000000000000000000000000000000;;		outputPackages := generator.Packages{}
0000000000000000000000000000000000000000;;		nonOutputPackages := map[string]struct{}{}
0000000000000000000000000000000000000000;;		for _, d := range strings.Split(g.Packages, ",") {
0000000000000000000000000000000000000000;;			generateAllTypes, outputPackage := true, true
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case strings.HasPrefix(d, "+"):
0000000000000000000000000000000000000000;;				d = d[1:]
0000000000000000000000000000000000000000;;				generateAllTypes = false
0000000000000000000000000000000000000000;;			case strings.HasPrefix(d, "-"):
0000000000000000000000000000000000000000;;				d = d[1:]
0000000000000000000000000000000000000000;;				outputPackage = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			name := protoSafePackage(d)
0000000000000000000000000000000000000000;;			parts := strings.SplitN(d, "=", 2)
0000000000000000000000000000000000000000;;			if len(parts) > 1 {
0000000000000000000000000000000000000000;;				d = parts[0]
0000000000000000000000000000000000000000;;				name = parts[1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p := newProtobufPackage(d, name, generateAllTypes, omitTypes)
0000000000000000000000000000000000000000;;			header := append([]byte{}, boilerplate...)
0000000000000000000000000000000000000000;;			header = append(header, p.HeaderText...)
0000000000000000000000000000000000000000;;			p.HeaderText = header
0000000000000000000000000000000000000000;;			protobufNames.Add(p)
0000000000000000000000000000000000000000;;			if outputPackage {
0000000000000000000000000000000000000000;;				outputPackages = append(outputPackages, p)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				nonOutputPackages[name] = struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !g.Common.VerifyOnly {
0000000000000000000000000000000000000000;;			for _, p := range outputPackages {
0000000000000000000000000000000000000000;;				if err := p.(*protobufPackage).Clean(g.OutputBase); err != nil {
0000000000000000000000000000000000000000;;					log.Fatalf("Unable to clean package %s: %v", p.Name(), err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if g.Clean {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, p := range protobufNames.List() {
0000000000000000000000000000000000000000;;			if err := b.AddDir(p.Path()); err != nil {
0000000000000000000000000000000000000000;;				log.Fatalf("Unable to add directory %q: %v", p.Path(), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, err := generator.NewContext(
0000000000000000000000000000000000000000;;			b,
0000000000000000000000000000000000000000;;			namer.NameSystems{
0000000000000000000000000000000000000000;;				"public": namer.NewPublicNamer(3),
0000000000000000000000000000000000000000;;				"proto":  protobufNames,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"public",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Fatalf("Failed making a context: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.Verify = g.Common.VerifyOnly
0000000000000000000000000000000000000000;;		c.FileTypes["protoidl"] = NewProtoFile()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var vendoredOutputPackages, localOutputPackages generator.Packages
0000000000000000000000000000000000000000;;		for _, p := range protobufNames.packages {
0000000000000000000000000000000000000000;;			if _, ok := nonOutputPackages[p.Name()]; ok {
0000000000000000000000000000000000000000;;				// if we're not outputting the package, don't include it in either package list
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.Vendored = strings.Contains(c.Universe[p.PackagePath].SourcePath, "/vendor/")
0000000000000000000000000000000000000000;;			if p.Vendored {
0000000000000000000000000000000000000000;;				vendoredOutputPackages = append(vendoredOutputPackages, p)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				localOutputPackages = append(localOutputPackages, p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := protobufNames.AssignTypesToPackages(c); err != nil {
0000000000000000000000000000000000000000;;			log.Fatalf("Failed to identify Common types: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := c.ExecutePackages(g.VendorOutputBase, vendoredOutputPackages); err != nil {
0000000000000000000000000000000000000000;;			log.Fatalf("Failed executing vendor generator: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := c.ExecutePackages(g.OutputBase, localOutputPackages); err != nil {
0000000000000000000000000000000000000000;;			log.Fatalf("Failed executing local generator: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if g.OnlyIDL {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := exec.LookPath("protoc"); err != nil {
0000000000000000000000000000000000000000;;			log.Fatalf("Unable to find 'protoc': %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		searchArgs := []string{"-I", ".", "-I", g.OutputBase}
0000000000000000000000000000000000000000;;		if len(g.ProtoImport) != 0 {
0000000000000000000000000000000000000000;;			for _, s := range g.ProtoImport {
0000000000000000000000000000000000000000;;				searchArgs = append(searchArgs, "-I", s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		args := append(searchArgs, fmt.Sprintf("--gogo_out=%s", g.OutputBase))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		if len(g.Conditional) > 0 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(buf, "// +build %s\n\n", g.Conditional)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf.Write(boilerplate)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, outputPackage := range outputPackages {
0000000000000000000000000000000000000000;;			p := outputPackage.(*protobufPackage)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			path := filepath.Join(g.OutputBase, p.ImportPath())
0000000000000000000000000000000000000000;;			outputPath := filepath.Join(g.OutputBase, p.OutputPath())
0000000000000000000000000000000000000000;;			if p.Vendored {
0000000000000000000000000000000000000000;;				path = filepath.Join(g.VendorOutputBase, p.ImportPath())
0000000000000000000000000000000000000000;;				outputPath = filepath.Join(g.VendorOutputBase, p.OutputPath())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// generate the gogoprotobuf protoc
0000000000000000000000000000000000000000;;			cmd := exec.Command("protoc", append(args, path)...)
0000000000000000000000000000000000000000;;			out, err := cmd.CombinedOutput()
0000000000000000000000000000000000000000;;			if len(out) > 0 {
0000000000000000000000000000000000000000;;				log.Printf(string(out))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				log.Println(strings.Join(cmd.Args, " "))
0000000000000000000000000000000000000000;;				log.Fatalf("Unable to generate protoc on %s: %v", p.PackageName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if g.SkipGeneratedRewrite {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// alter the generated protobuf file to remove the generated types (but leave the serializers) and rewrite the
0000000000000000000000000000000000000000;;			// package statement to match the desired package name
0000000000000000000000000000000000000000;;			if err := RewriteGeneratedGogoProtobufFile(outputPath, p.ExtractGeneratedType, p.OptionalTypeName, buf.Bytes()); err != nil {
0000000000000000000000000000000000000000;;				log.Fatalf("Unable to rewrite generated %s: %v", outputPath, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// sort imports
0000000000000000000000000000000000000000;;			cmd = exec.Command("goimports", "-w", outputPath)
0000000000000000000000000000000000000000;;			out, err = cmd.CombinedOutput()
0000000000000000000000000000000000000000;;			if len(out) > 0 {
0000000000000000000000000000000000000000;;				log.Printf(string(out))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				log.Println(strings.Join(cmd.Args, " "))
0000000000000000000000000000000000000000;;				log.Fatalf("Unable to rewrite imports for %s: %v", p.PackageName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// format and simplify the generated file
0000000000000000000000000000000000000000;;			cmd = exec.Command("gofmt", "-s", "-w", outputPath)
0000000000000000000000000000000000000000;;			out, err = cmd.CombinedOutput()
0000000000000000000000000000000000000000;;			if len(out) > 0 {
0000000000000000000000000000000000000000;;				log.Printf(string(out))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				log.Println(strings.Join(cmd.Args, " "))
0000000000000000000000000000000000000000;;				log.Fatalf("Unable to apply gofmt for %s: %v", p.PackageName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if g.SkipGeneratedRewrite {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !g.KeepGogoproto {
0000000000000000000000000000000000000000;;			// generate, but do so without gogoprotobuf extensions
0000000000000000000000000000000000000000;;			for _, outputPackage := range outputPackages {
0000000000000000000000000000000000000000;;				p := outputPackage.(*protobufPackage)
0000000000000000000000000000000000000000;;				p.OmitGogo = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := c.ExecutePackages(g.VendorOutputBase, vendoredOutputPackages); err != nil {
0000000000000000000000000000000000000000;;				log.Fatalf("Failed executing vendor generator: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := c.ExecutePackages(g.OutputBase, localOutputPackages); err != nil {
0000000000000000000000000000000000000000;;				log.Fatalf("Failed executing local generator: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, outputPackage := range outputPackages {
0000000000000000000000000000000000000000;;			p := outputPackage.(*protobufPackage)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(p.StructTags) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pattern := filepath.Join(g.OutputBase, p.PackagePath, "*.go")
0000000000000000000000000000000000000000;;			if p.Vendored {
0000000000000000000000000000000000000000;;				pattern = filepath.Join(g.VendorOutputBase, p.PackagePath, "*.go")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			files, err := filepath.Glob(pattern)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				log.Fatalf("Can't glob pattern %q: %v", pattern, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, s := range files {
0000000000000000000000000000000000000000;;				if strings.HasSuffix(s, "_test.go") {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := RewriteTypesWithProtobufStructTags(s, p.StructTags); err != nil {
0000000000000000000000000000000000000000;;					log.Fatalf("Unable to rewrite with struct tags %s: %v", s, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
