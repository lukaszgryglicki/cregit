0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
4ac65c38863bea82dd9e7f52f4c39a42d440ff18;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package protobuf
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// genProtoIDL produces a .proto IDL.
0000000000000000000000000000000000000000;;	type genProtoIDL struct {
0000000000000000000000000000000000000000;;		generator.DefaultGen
0000000000000000000000000000000000000000;;		localPackage   types.Name
0000000000000000000000000000000000000000;;		localGoPackage types.Name
0000000000000000000000000000000000000000;;		imports        namer.ImportTracker
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		generateAll    bool
0000000000000000000000000000000000000000;;		omitGogo       bool
0000000000000000000000000000000000000000;;		omitFieldTypes map[types.Name]struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genProtoIDL) PackageVars(c *generator.Context) []string {
0000000000000000000000000000000000000000;;		if g.omitGogo {
0000000000000000000000000000000000000000;;			return []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("option go_package = %q;", g.localGoPackage.Name),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []string{
0000000000000000000000000000000000000000;;			"option (gogoproto.marshaler_all) = true;",
0000000000000000000000000000000000000000;;			"option (gogoproto.stable_marshaler_all) = true;",
0000000000000000000000000000000000000000;;			"option (gogoproto.sizer_all) = true;",
0000000000000000000000000000000000000000;;			"option (gogoproto.goproto_stringer_all) = false;",
0000000000000000000000000000000000000000;;			"option (gogoproto.stringer_all) = true;",
0000000000000000000000000000000000000000;;			"option (gogoproto.unmarshaler_all) = true;",
0000000000000000000000000000000000000000;;			"option (gogoproto.goproto_unrecognized_all) = false;",
0000000000000000000000000000000000000000;;			"option (gogoproto.goproto_enum_prefix_all) = false;",
0000000000000000000000000000000000000000;;			"option (gogoproto.goproto_getters_all) = false;",
0000000000000000000000000000000000000000;;			fmt.Sprintf("option go_package = %q;", g.localGoPackage.Name),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (g *genProtoIDL) Filename() string { return g.OptionalName + ".proto" }
0000000000000000000000000000000000000000;;	func (g *genProtoIDL) FileType() string { return "protoidl" }
0000000000000000000000000000000000000000;;	func (g *genProtoIDL) Namers(c *generator.Context) namer.NameSystems {
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			// The local namer returns the correct protobuf name for a proto type
0000000000000000000000000000000000000000;;			// in the context of a package
0000000000000000000000000000000000000000;;			"local": localNamer{g.localPackage},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Filter ignores types that are identified as not exportable.
0000000000000000000000000000000000000000;;	func (g *genProtoIDL) Filter(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;		tagVals := types.ExtractCommentTags("+", t.CommentLines)["protobuf"]
0000000000000000000000000000000000000000;;		if tagVals != nil {
0000000000000000000000000000000000000000;;			if tagVals[0] == "false" {
0000000000000000000000000000000000000000;;				// Type specified "false".
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tagVals[0] == "true" {
0000000000000000000000000000000000000000;;				// Type specified "true".
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Fatalf(`Comment tag "protobuf" must be true or false, found: %q`, tagVals[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !g.generateAll {
0000000000000000000000000000000000000000;;			// We're not generating everything.
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		seen := map[*types.Type]bool{}
0000000000000000000000000000000000000000;;		ok := isProtoable(seen, t)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isProtoable(seen map[*types.Type]bool, t *types.Type) bool {
0000000000000000000000000000000000000000;;		if seen[t] {
0000000000000000000000000000000000000000;;			// be optimistic in the case of type cycles.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		seen[t] = true
0000000000000000000000000000000000000000;;		switch t.Kind {
0000000000000000000000000000000000000000;;		case types.Builtin:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case types.Alias:
0000000000000000000000000000000000000000;;			return isProtoable(seen, t.Underlying)
0000000000000000000000000000000000000000;;		case types.Slice, types.Pointer:
0000000000000000000000000000000000000000;;			return isProtoable(seen, t.Elem)
0000000000000000000000000000000000000000;;		case types.Map:
0000000000000000000000000000000000000000;;			return isProtoable(seen, t.Key) && isProtoable(seen, t.Elem)
0000000000000000000000000000000000000000;;		case types.Struct:
0000000000000000000000000000000000000000;;			for _, m := range t.Members {
0000000000000000000000000000000000000000;;				if isProtoable(seen, m.Type) {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case types.Func, types.Chan:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case types.DeclarationOf, types.Unknown, types.Unsupported:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case types.Interface:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			log.Printf("WARNING: type %q is not protable: %s", t.Kind, t.Name)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isOptionalAlias should return true if the specified type has an underlying type
0000000000000000000000000000000000000000;;	// (is an alias) of a map or slice and has the comment tag protobuf.nullable=true,
0000000000000000000000000000000000000000;;	// indicating that the type should be nullable in protobuf.
0000000000000000000000000000000000000000;;	func isOptionalAlias(t *types.Type) bool {
0000000000000000000000000000000000000000;;		if t.Underlying == nil || (t.Underlying.Kind != types.Map && t.Underlying.Kind != types.Slice) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if extractBoolTagOrDie("protobuf.nullable", t.CommentLines) == false {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genProtoIDL) Imports(c *generator.Context) (imports []string) {
0000000000000000000000000000000000000000;;		lines := []string{}
0000000000000000000000000000000000000000;;		// TODO: this could be expressed more cleanly
0000000000000000000000000000000000000000;;		for _, line := range g.imports.ImportLines() {
0000000000000000000000000000000000000000;;			if g.omitGogo && line == "github.com/gogo/protobuf/gogoproto/gogo.proto" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lines = append(lines, line)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return lines
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenerateType makes the body of a file implementing a set for type t.
0000000000000000000000000000000000000000;;	func (g *genProtoIDL) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(w, c, "$", "$")
0000000000000000000000000000000000000000;;		b := bodyGen{
0000000000000000000000000000000000000000;;			locator: &protobufLocator{
0000000000000000000000000000000000000000;;				namer:    c.Namers["proto"].(ProtobufFromGoNamer),
0000000000000000000000000000000000000000;;				tracker:  g.imports,
0000000000000000000000000000000000000000;;				universe: c.Universe,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				localGoPackage: g.localGoPackage.Package,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			localPackage: g.localPackage,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			omitGogo:       g.omitGogo,
0000000000000000000000000000000000000000;;			omitFieldTypes: g.omitFieldTypes,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			t: t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t.Kind {
0000000000000000000000000000000000000000;;		case types.Alias:
0000000000000000000000000000000000000000;;			return b.doAlias(sw)
0000000000000000000000000000000000000000;;		case types.Struct:
0000000000000000000000000000000000000000;;			return b.doStruct(sw)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return b.unknown(sw)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProtobufFromGoNamer finds the protobuf name of a type (and its package, and
0000000000000000000000000000000000000000;;	// the package path) from its Go name.
0000000000000000000000000000000000000000;;	type ProtobufFromGoNamer interface {
0000000000000000000000000000000000000000;;		GoNameToProtoName(name types.Name) types.Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ProtobufLocator interface {
0000000000000000000000000000000000000000;;		ProtoTypeFor(t *types.Type) (*types.Type, error)
0000000000000000000000000000000000000000;;		GoTypeForName(name types.Name) *types.Type
0000000000000000000000000000000000000000;;		CastTypeName(name types.Name) string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type protobufLocator struct {
0000000000000000000000000000000000000000;;		namer    ProtobufFromGoNamer
0000000000000000000000000000000000000000;;		tracker  namer.ImportTracker
0000000000000000000000000000000000000000;;		universe types.Universe
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		localGoPackage string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CastTypeName returns the cast type name of a Go type
0000000000000000000000000000000000000000;;	// TODO: delegate to a new localgo namer?
0000000000000000000000000000000000000000;;	func (p protobufLocator) CastTypeName(name types.Name) string {
0000000000000000000000000000000000000000;;		if name.Package == p.localGoPackage {
0000000000000000000000000000000000000000;;			return name.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return name.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p protobufLocator) GoTypeForName(name types.Name) *types.Type {
0000000000000000000000000000000000000000;;		if len(name.Package) == 0 {
0000000000000000000000000000000000000000;;			name.Package = p.localGoPackage
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.universe.Type(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProtoTypeFor locates a Protobuf type for the provided Go type (if possible).
0000000000000000000000000000000000000000;;	func (p protobufLocator) ProtoTypeFor(t *types.Type) (*types.Type, error) {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		// we've already converted the type, or it's a map
0000000000000000000000000000000000000000;;		case t.Kind == types.Protobuf || t.Kind == types.Map:
0000000000000000000000000000000000000000;;			p.tracker.AddType(t)
0000000000000000000000000000000000000000;;			return t, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// it's a fundamental type
0000000000000000000000000000000000000000;;		if t, ok := isFundamentalProtoType(t); ok {
0000000000000000000000000000000000000000;;			p.tracker.AddType(t)
0000000000000000000000000000000000000000;;			return t, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// it's a message
0000000000000000000000000000000000000000;;		if t.Kind == types.Struct || isOptionalAlias(t) {
0000000000000000000000000000000000000000;;			t := &types.Type{
0000000000000000000000000000000000000000;;				Name: p.namer.GoNameToProtoName(t.Name),
0000000000000000000000000000000000000000;;				Kind: types.Protobuf,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				CommentLines: t.CommentLines,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.tracker.AddType(t)
0000000000000000000000000000000000000000;;			return t, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, errUnrecognizedType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type bodyGen struct {
0000000000000000000000000000000000000000;;		locator        ProtobufLocator
0000000000000000000000000000000000000000;;		localPackage   types.Name
0000000000000000000000000000000000000000;;		omitGogo       bool
0000000000000000000000000000000000000000;;		omitFieldTypes map[types.Name]struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t *types.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b bodyGen) unknown(sw *generator.SnippetWriter) error {
0000000000000000000000000000000000000000;;		return fmt.Errorf("not sure how to generate: %#v", b.t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b bodyGen) doAlias(sw *generator.SnippetWriter) error {
0000000000000000000000000000000000000000;;		if !isOptionalAlias(b.t) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var kind string
0000000000000000000000000000000000000000;;		switch b.t.Underlying.Kind {
0000000000000000000000000000000000000000;;		case types.Map:
0000000000000000000000000000000000000000;;			kind = "map"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			kind = "slice"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		optional := &types.Type{
0000000000000000000000000000000000000000;;			Name: b.t.Name,
0000000000000000000000000000000000000000;;			Kind: types.Struct,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			CommentLines:              b.t.CommentLines,
0000000000000000000000000000000000000000;;			SecondClosestCommentLines: b.t.SecondClosestCommentLines,
0000000000000000000000000000000000000000;;			Members: []types.Member{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:         "Items",
0000000000000000000000000000000000000000;;					CommentLines: []string{fmt.Sprintf("items, if empty, will result in an empty %s\n", kind)},
0000000000000000000000000000000000000000;;					Type:         b.t.Underlying,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nested := b
0000000000000000000000000000000000000000;;		nested.t = optional
0000000000000000000000000000000000000000;;		return nested.doStruct(sw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b bodyGen) doStruct(sw *generator.SnippetWriter) error {
0000000000000000000000000000000000000000;;		if len(b.t.Name.Name) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if namer.IsPrivateGoName(b.t.Name.Name) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var alias *types.Type
0000000000000000000000000000000000000000;;		var fields []protoField
0000000000000000000000000000000000000000;;		options := []string{}
0000000000000000000000000000000000000000;;		allOptions := types.ExtractCommentTags("+", b.t.CommentLines)
0000000000000000000000000000000000000000;;		for k, v := range allOptions {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case strings.HasPrefix(k, "protobuf.options."):
0000000000000000000000000000000000000000;;				key := strings.TrimPrefix(k, "protobuf.options.")
0000000000000000000000000000000000000000;;				switch key {
0000000000000000000000000000000000000000;;				case "marshal":
0000000000000000000000000000000000000000;;					if v[0] == "false" {
0000000000000000000000000000000000000000;;						if !b.omitGogo {
0000000000000000000000000000000000000000;;							options = append(options,
0000000000000000000000000000000000000000;;								"(gogoproto.marshaler) = false",
0000000000000000000000000000000000000000;;								"(gogoproto.unmarshaler) = false",
0000000000000000000000000000000000000000;;								"(gogoproto.sizer) = false",
0000000000000000000000000000000000000000;;							)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					if !b.omitGogo || !strings.HasPrefix(key, "(gogoproto.") {
0000000000000000000000000000000000000000;;						if key == "(gogoproto.goproto_stringer)" && v[0] == "false" {
0000000000000000000000000000000000000000;;							options = append(options, "(gogoproto.stringer) = false")
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						options = append(options, fmt.Sprintf("%s = %s", key, v[0]))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			// protobuf.as allows a type to have the same message contents as another Go type
0000000000000000000000000000000000000000;;			case k == "protobuf.as":
0000000000000000000000000000000000000000;;				fields = nil
0000000000000000000000000000000000000000;;				if alias = b.locator.GoTypeForName(types.Name{Name: v[0]}); alias == nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("type %v references alias %q which does not exist", b.t, v[0])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			// protobuf.embed instructs the generator to use the named type in this package
0000000000000000000000000000000000000000;;			// as an embedded message.
0000000000000000000000000000000000000000;;			case k == "protobuf.embed":
0000000000000000000000000000000000000000;;				fields = []protoField{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Tag:  1,
0000000000000000000000000000000000000000;;						Name: v[0],
0000000000000000000000000000000000000000;;						Type: &types.Type{
0000000000000000000000000000000000000000;;							Name: types.Name{
0000000000000000000000000000000000000000;;								Name:    v[0],
0000000000000000000000000000000000000000;;								Package: b.localPackage.Package,
0000000000000000000000000000000000000000;;								Path:    b.localPackage.Path,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if alias == nil {
0000000000000000000000000000000000000000;;			alias = b.t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we don't explicitly embed anything, generate fields by traversing fields.
0000000000000000000000000000000000000000;;		if fields == nil {
0000000000000000000000000000000000000000;;			memberFields, err := membersToFields(b.locator, alias, b.localPackage, b.omitFieldTypes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("type %v cannot be converted to protobuf: %v", b.t, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fields = memberFields
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := sw.Out()
0000000000000000000000000000000000000000;;		genComment(out, b.t.CommentLines, "")
0000000000000000000000000000000000000000;;		sw.Do(`message $.Name.Name$ {
0000000000000000000000000000000000000000;;	`, b.t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(options) > 0 {
0000000000000000000000000000000000000000;;			sort.Sort(sort.StringSlice(options))
0000000000000000000000000000000000000000;;			for _, s := range options {
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, "  option %s;\n", s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintln(out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, field := range fields {
0000000000000000000000000000000000000000;;			genComment(out, field.CommentLines, "  ")
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "  ")
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case field.Map:
0000000000000000000000000000000000000000;;			case field.Repeated:
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, "repeated ")
0000000000000000000000000000000000000000;;			case field.Required:
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, "required ")
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, "optional ")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sw.Do(`$.Type|local$ $.Name$ = $.Tag$`, field)
0000000000000000000000000000000000000000;;			if len(field.Extras) > 0 {
0000000000000000000000000000000000000000;;				extras := []string{}
0000000000000000000000000000000000000000;;				for k, v := range field.Extras {
0000000000000000000000000000000000000000;;					if b.omitGogo && strings.HasPrefix(k, "(gogoproto.") {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					extras = append(extras, fmt.Sprintf("%s = %s", k, v))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sort.Sort(sort.StringSlice(extras))
0000000000000000000000000000000000000000;;				if len(extras) > 0 {
0000000000000000000000000000000000000000;;					fmt.Fprintf(out, " [")
0000000000000000000000000000000000000000;;					fmt.Fprint(out, strings.Join(extras, ", "))
0000000000000000000000000000000000000000;;					fmt.Fprintf(out, "]")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, ";\n")
0000000000000000000000000000000000000000;;			if i != len(fields)-1 {
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, "\n")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintf(out, "}\n\n")
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type protoField struct {
0000000000000000000000000000000000000000;;		LocalPackage types.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Tag      int
0000000000000000000000000000000000000000;;		Name     string
0000000000000000000000000000000000000000;;		Type     *types.Type
0000000000000000000000000000000000000000;;		Map      bool
0000000000000000000000000000000000000000;;		Repeated bool
0000000000000000000000000000000000000000;;		Optional bool
0000000000000000000000000000000000000000;;		Required bool
0000000000000000000000000000000000000000;;		Nullable bool
0000000000000000000000000000000000000000;;		Extras   map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CommentLines []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errUnrecognizedType = fmt.Errorf("did not recognize the provided type")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isFundamentalProtoType(t *types.Type) (*types.Type, bool) {
0000000000000000000000000000000000000000;;		// TODO: when we enable proto3, also include other fundamental types in the google.protobuf package
0000000000000000000000000000000000000000;;		// switch {
0000000000000000000000000000000000000000;;		// case t.Kind == types.Struct && t.Name == types.Name{Package: "time", Name: "Time"}:
0000000000000000000000000000000000000000;;		// 	return &types.Type{
0000000000000000000000000000000000000000;;		// 		Kind: types.Protobuf,
0000000000000000000000000000000000000000;;		// 		Name: types.Name{Path: "google/protobuf/timestamp.proto", Package: "google.protobuf", Name: "Timestamp"},
0000000000000000000000000000000000000000;;		// 	}, true
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;		switch t.Kind {
0000000000000000000000000000000000000000;;		case types.Slice:
0000000000000000000000000000000000000000;;			if t.Elem.Name.Name == "byte" && len(t.Elem.Name.Package) == 0 {
0000000000000000000000000000000000000000;;				return &types.Type{Name: types.Name{Name: "bytes"}, Kind: types.Protobuf}, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case types.Builtin:
0000000000000000000000000000000000000000;;			switch t.Name.Name {
0000000000000000000000000000000000000000;;			case "string", "uint32", "int32", "uint64", "int64", "bool":
0000000000000000000000000000000000000000;;				return &types.Type{Name: types.Name{Name: t.Name.Name}, Kind: types.Protobuf}, true
0000000000000000000000000000000000000000;;			case "int":
0000000000000000000000000000000000000000;;				return &types.Type{Name: types.Name{Name: "int64"}, Kind: types.Protobuf}, true
0000000000000000000000000000000000000000;;			case "uint":
0000000000000000000000000000000000000000;;				return &types.Type{Name: types.Name{Name: "uint64"}, Kind: types.Protobuf}, true
0000000000000000000000000000000000000000;;			case "float64", "float":
0000000000000000000000000000000000000000;;				return &types.Type{Name: types.Name{Name: "double"}, Kind: types.Protobuf}, true
0000000000000000000000000000000000000000;;			case "float32":
0000000000000000000000000000000000000000;;				return &types.Type{Name: types.Name{Name: "float"}, Kind: types.Protobuf}, true
0000000000000000000000000000000000000000;;			case "uintptr":
0000000000000000000000000000000000000000;;				return &types.Type{Name: types.Name{Name: "uint64"}, Kind: types.Protobuf}, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: complex?
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func memberTypeToProtobufField(locator ProtobufLocator, field *protoField, t *types.Type) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		switch t.Kind {
0000000000000000000000000000000000000000;;		case types.Protobuf:
0000000000000000000000000000000000000000;;			field.Type, err = locator.ProtoTypeFor(t)
0000000000000000000000000000000000000000;;		case types.Builtin:
0000000000000000000000000000000000000000;;			field.Type, err = locator.ProtoTypeFor(t)
0000000000000000000000000000000000000000;;		case types.Map:
0000000000000000000000000000000000000000;;			valueField := &protoField{}
0000000000000000000000000000000000000000;;			if err := memberTypeToProtobufField(locator, valueField, t.Elem); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			keyField := &protoField{}
0000000000000000000000000000000000000000;;			if err := memberTypeToProtobufField(locator, keyField, t.Key); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// All other protobuf types have kind types.Protobuf, so setting types.Map
0000000000000000000000000000000000000000;;			// here would be very misleading.
0000000000000000000000000000000000000000;;			field.Type = &types.Type{
0000000000000000000000000000000000000000;;				Kind: types.Protobuf,
0000000000000000000000000000000000000000;;				Key:  keyField.Type,
0000000000000000000000000000000000000000;;				Elem: valueField.Type,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(t.Name.Name, "map[") {
0000000000000000000000000000000000000000;;				field.Extras["(gogoproto.casttype)"] = strconv.Quote(locator.CastTypeName(t.Name))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if k, ok := keyField.Extras["(gogoproto.casttype)"]; ok {
0000000000000000000000000000000000000000;;				field.Extras["(gogoproto.castkey)"] = k
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v, ok := valueField.Extras["(gogoproto.casttype)"]; ok {
0000000000000000000000000000000000000000;;				field.Extras["(gogoproto.castvalue)"] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			field.Map = true
0000000000000000000000000000000000000000;;		case types.Pointer:
0000000000000000000000000000000000000000;;			if err := memberTypeToProtobufField(locator, field, t.Elem); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			field.Nullable = true
0000000000000000000000000000000000000000;;		case types.Alias:
0000000000000000000000000000000000000000;;			if isOptionalAlias(t) {
0000000000000000000000000000000000000000;;				field.Type, err = locator.ProtoTypeFor(t)
0000000000000000000000000000000000000000;;				field.Nullable = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if err := memberTypeToProtobufField(locator, field, t.Underlying); err != nil {
0000000000000000000000000000000000000000;;					log.Printf("failed to alias: %s %s: err %v", t.Name, t.Underlying.Name, err)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if field.Extras == nil {
0000000000000000000000000000000000000000;;					field.Extras = make(map[string]string)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				field.Extras["(gogoproto.casttype)"] = strconv.Quote(locator.CastTypeName(t.Name))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case types.Slice:
0000000000000000000000000000000000000000;;			if t.Elem.Name.Name == "byte" && len(t.Elem.Name.Package) == 0 {
0000000000000000000000000000000000000000;;				field.Type = &types.Type{Name: types.Name{Name: "bytes"}, Kind: types.Protobuf}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := memberTypeToProtobufField(locator, field, t.Elem); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			field.Repeated = true
0000000000000000000000000000000000000000;;		case types.Struct:
0000000000000000000000000000000000000000;;			if len(t.Name.Name) == 0 {
0000000000000000000000000000000000000000;;				return errUnrecognizedType
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			field.Type, err = locator.ProtoTypeFor(t)
0000000000000000000000000000000000000000;;			field.Nullable = false
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return errUnrecognizedType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// protobufTagToField extracts information from an existing protobuf tag
0000000000000000000000000000000000000000;;	func protobufTagToField(tag string, field *protoField, m types.Member, t *types.Type, localPackage types.Name) error {
0000000000000000000000000000000000000000;;		if len(tag) == 0 || tag == "-" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// protobuf:"bytes,3,opt,name=Id,customtype=github.com/gogo/protobuf/test.Uuid"
0000000000000000000000000000000000000000;;		parts := strings.Split(tag, ",")
0000000000000000000000000000000000000000;;		if len(parts) < 3 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("member %q of %q malformed 'protobuf' tag, not enough segments\n", m.Name, t.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		protoTag, err := strconv.Atoi(parts[1])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("member %q of %q malformed 'protobuf' tag, field ID is %q which is not an integer: %v\n", m.Name, t.Name, parts[1], err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		field.Tag = protoTag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// In general there is doesn't make sense to parse the protobuf tags to get the type,
0000000000000000000000000000000000000000;;		// as all auto-generated once will have wire type "bytes", "varint" or "fixed64".
0000000000000000000000000000000000000000;;		// However, sometimes we explicitly set them to have a custom serialization, e.g.:
0000000000000000000000000000000000000000;;		//   type Time struct {
0000000000000000000000000000000000000000;;		//     time.Time `protobuf:"Timestamp,1,req,name=time"`
0000000000000000000000000000000000000000;;		//   }
0000000000000000000000000000000000000000;;		// to force the generator to use a given type (that we manually wrote serialization &
0000000000000000000000000000000000000000;;		// deserialization methods for).
0000000000000000000000000000000000000000;;		switch parts[0] {
0000000000000000000000000000000000000000;;		case "varint", "fixed32", "fixed64", "bytes", "group":
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			name := types.Name{}
0000000000000000000000000000000000000000;;			if last := strings.LastIndex(parts[0], "."); last != -1 {
0000000000000000000000000000000000000000;;				prefix := parts[0][:last]
0000000000000000000000000000000000000000;;				name = types.Name{
0000000000000000000000000000000000000000;;					Name:    parts[0][last+1:],
0000000000000000000000000000000000000000;;					Package: prefix,
0000000000000000000000000000000000000000;;					Path:    strings.Replace(prefix, ".", "/", -1),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				name = types.Name{
0000000000000000000000000000000000000000;;					Name:    parts[0],
0000000000000000000000000000000000000000;;					Package: localPackage.Package,
0000000000000000000000000000000000000000;;					Path:    localPackage.Path,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			field.Type = &types.Type{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;				Kind: types.Protobuf,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		protoExtra := make(map[string]string)
0000000000000000000000000000000000000000;;		for i, extra := range parts[3:] {
0000000000000000000000000000000000000000;;			parts := strings.SplitN(extra, "=", 2)
0000000000000000000000000000000000000000;;			if len(parts) != 2 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("member %q of %q malformed 'protobuf' tag, tag %d should be key=value, got %q\n", m.Name, t.Name, i+4, extra)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch parts[0] {
0000000000000000000000000000000000000000;;			case "name":
0000000000000000000000000000000000000000;;				protoExtra[parts[0]] = parts[1]
0000000000000000000000000000000000000000;;			case "casttype", "castkey", "castvalue":
0000000000000000000000000000000000000000;;				parts[0] = fmt.Sprintf("(gogoproto.%s)", parts[0])
0000000000000000000000000000000000000000;;				protoExtra[parts[0]] = strconv.Quote(parts[1])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		field.Extras = protoExtra
0000000000000000000000000000000000000000;;		if name, ok := protoExtra["name"]; ok {
0000000000000000000000000000000000000000;;			field.Name = name
0000000000000000000000000000000000000000;;			delete(protoExtra, "name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func membersToFields(locator ProtobufLocator, t *types.Type, localPackage types.Name, omitFieldTypes map[types.Name]struct{}) ([]protoField, error) {
0000000000000000000000000000000000000000;;		fields := []protoField{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, m := range t.Members {
0000000000000000000000000000000000000000;;			if namer.IsPrivateGoName(m.Name) {
0000000000000000000000000000000000000000;;				// skip private fields
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, ok := omitFieldTypes[types.Name{Name: m.Type.Name.Name, Package: m.Type.Name.Package}]; ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tags := reflect.StructTag(m.Tags)
0000000000000000000000000000000000000000;;			field := protoField{
0000000000000000000000000000000000000000;;				LocalPackage: localPackage,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Tag:    -1,
0000000000000000000000000000000000000000;;				Extras: make(map[string]string),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			protobufTag := tags.Get("protobuf")
0000000000000000000000000000000000000000;;			if protobufTag == "-" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := protobufTagToField(protobufTag, &field, m, t, localPackage); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// extract information from JSON field tag
0000000000000000000000000000000000000000;;			if tag := tags.Get("json"); len(tag) > 0 {
0000000000000000000000000000000000000000;;				parts := strings.Split(tag, ",")
0000000000000000000000000000000000000000;;				if len(field.Name) == 0 && len(parts[0]) != 0 {
0000000000000000000000000000000000000000;;					field.Name = parts[0]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if field.Tag == -1 && field.Name == "-" {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if field.Type == nil {
0000000000000000000000000000000000000000;;				if err := memberTypeToProtobufField(locator, &field, m.Type); err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("unable to embed type %q as field %q in %q: %v", m.Type, field.Name, t.Name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(field.Name) == 0 {
0000000000000000000000000000000000000000;;				field.Name = namer.IL(m.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if field.Map && field.Repeated {
0000000000000000000000000000000000000000;;				// maps cannot be repeated
0000000000000000000000000000000000000000;;				field.Repeated = false
0000000000000000000000000000000000000000;;				field.Nullable = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !field.Nullable {
0000000000000000000000000000000000000000;;				field.Extras["(gogoproto.nullable)"] = "false"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if (field.Type.Name.Name == "bytes" && field.Type.Name.Package == "") || (field.Repeated && field.Type.Name.Package == "" && namer.IsPrivateGoName(field.Type.Name.Name)) {
0000000000000000000000000000000000000000;;				delete(field.Extras, "(gogoproto.nullable)")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if field.Name != m.Name {
0000000000000000000000000000000000000000;;				field.Extras["(gogoproto.customname)"] = strconv.Quote(m.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			field.CommentLines = m.CommentLines
0000000000000000000000000000000000000000;;			fields = append(fields, field)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// assign tags
0000000000000000000000000000000000000000;;		highest := 0
0000000000000000000000000000000000000000;;		byTag := make(map[int]*protoField)
0000000000000000000000000000000000000000;;		// fields are in Go struct order, which we preserve
0000000000000000000000000000000000000000;;		for i := range fields {
0000000000000000000000000000000000000000;;			field := &fields[i]
0000000000000000000000000000000000000000;;			tag := field.Tag
0000000000000000000000000000000000000000;;			if tag != -1 {
0000000000000000000000000000000000000000;;				if existing, ok := byTag[tag]; ok {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("field %q and %q both have tag %d", field.Name, existing.Name, tag)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				byTag[tag] = field
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tag > highest {
0000000000000000000000000000000000000000;;				highest = tag
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// starting from the highest observed tag, assign new field tags
0000000000000000000000000000000000000000;;		for i := range fields {
0000000000000000000000000000000000000000;;			field := &fields[i]
0000000000000000000000000000000000000000;;			if field.Tag != -1 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			highest++
0000000000000000000000000000000000000000;;			field.Tag = highest
0000000000000000000000000000000000000000;;			byTag[field.Tag] = field
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fields, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genComment(out io.Writer, lines []string, indent string) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			l := len(lines)
0000000000000000000000000000000000000000;;			if l == 0 || len(lines[l-1]) != 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lines = lines[:l-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range lines {
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "%s// %s\n", indent, c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func formatProtoFile(source []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		// TODO; Is there any protobuf formatter?
0000000000000000000000000000000000000000;;		return source, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func assembleProtoFile(w io.Writer, f *generator.File) {
0000000000000000000000000000000000000000;;		w.Write(f.Header)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprint(w, "syntax = 'proto2';\n\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(f.PackageName) > 0 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "package %s;\n\n", f.PackageName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(f.Imports) > 0 {
0000000000000000000000000000000000000000;;			imports := []string{}
0000000000000000000000000000000000000000;;			for i := range f.Imports {
0000000000000000000000000000000000000000;;				imports = append(imports, i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Strings(imports)
0000000000000000000000000000000000000000;;			for _, s := range imports {
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, "import %q;\n", s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprint(w, "\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.Vars.Len() > 0 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "%s\n", f.Vars.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Write(f.Body.Bytes())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewProtoFile() *generator.DefaultFileType {
0000000000000000000000000000000000000000;;		return &generator.DefaultFileType{
0000000000000000000000000000000000000000;;			Format:   formatProtoFile,
0000000000000000000000000000000000000000;;			Assemble: assembleProtoFile,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
