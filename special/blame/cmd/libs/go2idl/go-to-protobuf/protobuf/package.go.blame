0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
4ac65c38863bea82dd9e7f52f4c39a42d440ff18;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package protobuf
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"go/ast"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newProtobufPackage(packagePath, packageName string, generateAll bool, omitFieldTypes map[types.Name]struct{}) *protobufPackage {
0000000000000000000000000000000000000000;;		pkg := &protobufPackage{
0000000000000000000000000000000000000000;;			DefaultPackage: generator.DefaultPackage{
0000000000000000000000000000000000000000;;				// The protobuf package name (foo.bar.baz)
0000000000000000000000000000000000000000;;				PackageName: packageName,
0000000000000000000000000000000000000000;;				// A path segment relative to the GOPATH root (foo/bar/baz)
0000000000000000000000000000000000000000;;				PackagePath: packagePath,
0000000000000000000000000000000000000000;;				HeaderText: []byte(
0000000000000000000000000000000000000000;;					`
0000000000000000000000000000000000000000;;	// This file was autogenerated by go-to-protobuf. Do not edit it manually!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`),
0000000000000000000000000000000000000000;;				PackageDocumentation: []byte(fmt.Sprintf(
0000000000000000000000000000000000000000;;					`// Package %s is an autogenerated protobuf IDL.
0000000000000000000000000000000000000000;;	`, packageName)),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			GenerateAll:    generateAll,
0000000000000000000000000000000000000000;;			OmitFieldTypes: omitFieldTypes,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pkg.FilterFunc = pkg.filterFunc
0000000000000000000000000000000000000000;;		pkg.GeneratorFunc = pkg.generatorFunc
0000000000000000000000000000000000000000;;		return pkg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// protobufPackage contains the protobuf implementation of Package.
0000000000000000000000000000000000000000;;	type protobufPackage struct {
0000000000000000000000000000000000000000;;		generator.DefaultPackage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If true, this package has been vendored into our source tree and thus can
0000000000000000000000000000000000000000;;		// only be generated by changing the vendor tree.
0000000000000000000000000000000000000000;;		Vendored bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If true, generate protobuf serializations for all public types.
0000000000000000000000000000000000000000;;		// If false, only generate protobuf serializations for structs that
0000000000000000000000000000000000000000;;		// request serialization.
0000000000000000000000000000000000000000;;		GenerateAll bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A list of types to filter to; if not specified all types will be included.
0000000000000000000000000000000000000000;;		FilterTypes map[types.Name]struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If true, omit any gogoprotobuf extensions not defined as types.
0000000000000000000000000000000000000000;;		OmitGogo bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A list of field types that will be excluded from the output struct
0000000000000000000000000000000000000000;;		OmitFieldTypes map[types.Name]struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A list of names that this package exports
0000000000000000000000000000000000000000;;		LocalNames map[string]struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A list of type names in this package that will need marshaller rewriting
0000000000000000000000000000000000000000;;		// to remove synthetic protobuf fields.
0000000000000000000000000000000000000000;;		OptionalTypeNames map[string]struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A list of struct tags to generate onto named struct fields
0000000000000000000000000000000000000000;;		StructTags map[string]map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// An import tracker for this package
0000000000000000000000000000000000000000;;		Imports *ImportTracker
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *protobufPackage) Clean(outputBase string) error {
0000000000000000000000000000000000000000;;		for _, s := range []string{p.ImportPath(), p.OutputPath()} {
0000000000000000000000000000000000000000;;			if err := os.Remove(filepath.Join(outputBase, s)); err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *protobufPackage) ProtoTypeName() types.Name {
0000000000000000000000000000000000000000;;		return types.Name{
0000000000000000000000000000000000000000;;			Name:    p.Path(),       // the go path "foo/bar/baz"
0000000000000000000000000000000000000000;;			Package: p.Name(),       // the protobuf package "foo.bar.baz"
0000000000000000000000000000000000000000;;			Path:    p.ImportPath(), // the path of the import to get the proto
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *protobufPackage) filterFunc(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;		switch t.Kind {
0000000000000000000000000000000000000000;;		case types.Func, types.Chan:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case types.Struct:
0000000000000000000000000000000000000000;;			if t.Name.Name == "struct{}" {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case types.Builtin:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case types.Alias:
0000000000000000000000000000000000000000;;			if !isOptionalAlias(t) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case types.Slice, types.Array, types.Map:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case types.Pointer:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := isFundamentalProtoType(t); ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := p.FilterTypes[t.Name]
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *protobufPackage) HasGoType(name string) bool {
0000000000000000000000000000000000000000;;		_, ok := p.LocalNames[name]
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *protobufPackage) OptionalTypeName(name string) bool {
0000000000000000000000000000000000000000;;		_, ok := p.OptionalTypeNames[name]
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *protobufPackage) ExtractGeneratedType(t *ast.TypeSpec) bool {
0000000000000000000000000000000000000000;;		if !p.HasGoType(t.Name.Name) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch s := t.Type.(type) {
0000000000000000000000000000000000000000;;		case *ast.StructType:
0000000000000000000000000000000000000000;;			for i, f := range s.Fields.List {
0000000000000000000000000000000000000000;;				if len(f.Tag.Value) == 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				tag := strings.Trim(f.Tag.Value, "`")
0000000000000000000000000000000000000000;;				protobufTag := reflect.StructTag(tag).Get("protobuf")
0000000000000000000000000000000000000000;;				if len(protobufTag) == 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(f.Names) > 1 {
0000000000000000000000000000000000000000;;					log.Printf("WARNING: struct %s field %d %s: defined multiple names but single protobuf tag", t.Name.Name, i, f.Names[0].Name)
0000000000000000000000000000000000000000;;					// TODO hard error?
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if p.StructTags == nil {
0000000000000000000000000000000000000000;;					p.StructTags = make(map[string]map[string]string)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				m := p.StructTags[t.Name.Name]
0000000000000000000000000000000000000000;;				if m == nil {
0000000000000000000000000000000000000000;;					m = make(map[string]string)
0000000000000000000000000000000000000000;;					p.StructTags[t.Name.Name] = m
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				m[f.Names[0].Name] = tag
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			log.Printf("WARNING: unexpected Go AST type definition: %#v", t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *protobufPackage) generatorFunc(c *generator.Context) []generator.Generator {
0000000000000000000000000000000000000000;;		generators := []generator.Generator{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.Imports.AddNullable()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		generators = append(generators, &genProtoIDL{
0000000000000000000000000000000000000000;;			DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;				OptionalName: "generated",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			localPackage:   types.Name{Package: p.PackageName, Path: p.PackagePath},
0000000000000000000000000000000000000000;;			localGoPackage: types.Name{Package: p.PackagePath, Name: p.GoPackageName()},
0000000000000000000000000000000000000000;;			imports:        p.Imports,
0000000000000000000000000000000000000000;;			generateAll:    p.GenerateAll,
0000000000000000000000000000000000000000;;			omitGogo:       p.OmitGogo,
0000000000000000000000000000000000000000;;			omitFieldTypes: p.OmitFieldTypes,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return generators
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *protobufPackage) GoPackageName() string {
0000000000000000000000000000000000000000;;		return filepath.Base(p.PackagePath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *protobufPackage) ImportPath() string {
0000000000000000000000000000000000000000;;		return filepath.Join(p.PackagePath, "generated.proto")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *protobufPackage) OutputPath() string {
0000000000000000000000000000000000000000;;		return filepath.Join(p.PackagePath, "generated.pb.go")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		_ = generator.Package(&protobufPackage{})
0000000000000000000000000000000000000000;;	)
