0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
c2e86248518ae112ebf4a8a270f2bdd0b724af06;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilflag "k8s.io/apiserver/pkg/util/flag"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/logs"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/version/verflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HyperKube represents a single binary that can morph/manage into multiple
0000000000000000000000000000000000000000;;	// servers.
0000000000000000000000000000000000000000;;	type HyperKube struct {
0000000000000000000000000000000000000000;;		Name string // The executable name, used for help and soft-link invocation
0000000000000000000000000000000000000000;;		Long string // A long description of the binary.  It will be world wrapped before output.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servers             []Server
0000000000000000000000000000000000000000;;		baseFlags           *pflag.FlagSet
0000000000000000000000000000000000000000;;		out                 io.Writer
0000000000000000000000000000000000000000;;		helpFlagVal         bool
0000000000000000000000000000000000000000;;		makeSymlinksFlagVal bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddServer adds a server to the HyperKube object.
0000000000000000000000000000000000000000;;	func (hk *HyperKube) AddServer(s *Server) {
0000000000000000000000000000000000000000;;		hk.servers = append(hk.servers, *s)
0000000000000000000000000000000000000000;;		hk.servers[len(hk.servers)-1].hk = hk
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindServer will find a specific server named name.
0000000000000000000000000000000000000000;;	func (hk *HyperKube) FindServer(name string) (*Server, error) {
0000000000000000000000000000000000000000;;		for _, s := range hk.servers {
0000000000000000000000000000000000000000;;			if s.Name() == name || s.AlternativeName == name {
0000000000000000000000000000000000000000;;				return &s, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Server not found: %s", name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Servers returns a list of all of the registered servers
0000000000000000000000000000000000000000;;	func (hk *HyperKube) Servers() []Server {
0000000000000000000000000000000000000000;;		return hk.servers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Flags returns a flagset for "global" flags.
0000000000000000000000000000000000000000;;	func (hk *HyperKube) Flags() *pflag.FlagSet {
0000000000000000000000000000000000000000;;		if hk.baseFlags == nil {
0000000000000000000000000000000000000000;;			hk.baseFlags = pflag.NewFlagSet(hk.Name, pflag.ContinueOnError)
0000000000000000000000000000000000000000;;			hk.baseFlags.SetOutput(ioutil.Discard)
0000000000000000000000000000000000000000;;			hk.baseFlags.SetNormalizeFunc(utilflag.WordSepNormalizeFunc)
0000000000000000000000000000000000000000;;			hk.baseFlags.BoolVarP(&hk.helpFlagVal, "help", "h", false, "help for "+hk.Name)
0000000000000000000000000000000000000000;;			hk.baseFlags.BoolVar(&hk.makeSymlinksFlagVal, "make-symlinks", false, "create a symlink for each server in current directory")
0000000000000000000000000000000000000000;;			hk.baseFlags.MarkHidden("make-symlinks") // hide this flag from appearing in servers' usage output
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// These will add all of the "global" flags (defined with both the
0000000000000000000000000000000000000000;;			// flag and pflag packages) to the new flag set we have.
0000000000000000000000000000000000000000;;			hk.baseFlags.AddGoFlagSet(flag.CommandLine)
0000000000000000000000000000000000000000;;			hk.baseFlags.AddFlagSet(pflag.CommandLine)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hk.baseFlags
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Out returns the io.Writer that is used for all usage/error information
0000000000000000000000000000000000000000;;	func (hk *HyperKube) Out() io.Writer {
0000000000000000000000000000000000000000;;		if hk.out == nil {
0000000000000000000000000000000000000000;;			hk.out = os.Stderr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hk.out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetOut sets the output writer for all usage/error information
0000000000000000000000000000000000000000;;	func (hk *HyperKube) SetOut(w io.Writer) {
0000000000000000000000000000000000000000;;		hk.out = w
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Print is a convenience method to Print to the defined output
0000000000000000000000000000000000000000;;	func (hk *HyperKube) Print(i ...interface{}) {
0000000000000000000000000000000000000000;;		fmt.Fprint(hk.Out(), i...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Println is a convenience method to Println to the defined output
0000000000000000000000000000000000000000;;	func (hk *HyperKube) Println(i ...interface{}) {
0000000000000000000000000000000000000000;;		fmt.Fprintln(hk.Out(), i...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Printf is a convenience method to Printf to the defined output
0000000000000000000000000000000000000000;;	func (hk *HyperKube) Printf(format string, i ...interface{}) {
0000000000000000000000000000000000000000;;		fmt.Fprintf(hk.Out(), format, i...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run the server.  This will pick the appropriate server and run it.
0000000000000000000000000000000000000000;;	func (hk *HyperKube) Run(args []string) error {
0000000000000000000000000000000000000000;;		// If we are called directly, parse all flags up to the first real
0000000000000000000000000000000000000000;;		// argument.  That should be the server to run.
0000000000000000000000000000000000000000;;		command := args[0]
0000000000000000000000000000000000000000;;		serverName := path.Base(command)
0000000000000000000000000000000000000000;;		args = args[1:]
0000000000000000000000000000000000000000;;		if serverName == hk.Name {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			baseFlags := hk.Flags()
0000000000000000000000000000000000000000;;			baseFlags.SetInterspersed(false) // Only parse flags up to the next real command
0000000000000000000000000000000000000000;;			err := baseFlags.Parse(args)
0000000000000000000000000000000000000000;;			if err != nil || hk.helpFlagVal {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					hk.Println("Error:", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				hk.Usage()
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if hk.makeSymlinksFlagVal {
0000000000000000000000000000000000000000;;				return hk.MakeSymlinks(command)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			verflag.PrintAndExitIfRequested()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			args = baseFlags.Args()
0000000000000000000000000000000000000000;;			if len(args) > 0 && len(args[0]) > 0 {
0000000000000000000000000000000000000000;;				serverName = args[0]
0000000000000000000000000000000000000000;;				args = args[1:]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				err = errors.New("no server specified")
0000000000000000000000000000000000000000;;				hk.Printf("Error: %v\n\n", err)
0000000000000000000000000000000000000000;;				hk.Usage()
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s, err := hk.FindServer(serverName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			hk.Printf("Error: %v\n\n", err)
0000000000000000000000000000000000000000;;			hk.Usage()
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.Flags().AddFlagSet(hk.Flags())
0000000000000000000000000000000000000000;;		err = s.Flags().Parse(args)
0000000000000000000000000000000000000000;;		if err != nil || hk.helpFlagVal {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				hk.Printf("Error: %v\n\n", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.Usage()
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verflag.PrintAndExitIfRequested()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logs.InitLogs()
0000000000000000000000000000000000000000;;		defer logs.FlushLogs()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = s.Run(s, s.Flags().Args())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			hk.Println("Error:", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunToExit will run the hyperkube and then call os.Exit with an appropriate exit code.
0000000000000000000000000000000000000000;;	func (hk *HyperKube) RunToExit(args []string) {
0000000000000000000000000000000000000000;;		err := hk.Run(args)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		os.Exit(0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Usage will write out a summary for all servers that this binary supports.
0000000000000000000000000000000000000000;;	func (hk *HyperKube) Usage() {
0000000000000000000000000000000000000000;;		tt := `{{if .Long}}{{.Long | trim | wrap ""}}
0000000000000000000000000000000000000000;;	{{end}}Usage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  {{.Name}} <server> [flags]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Servers
0000000000000000000000000000000000000000;;	{{range .Servers}}
0000000000000000000000000000000000000000;;	  {{.Name}}
0000000000000000000000000000000000000000;;	{{.Long | trim | wrap "    "}}{{end}}
0000000000000000000000000000000000000000;;	Call '{{.Name}} --make-symlinks' to create symlinks for each server in the local directory.
0000000000000000000000000000000000000000;;	Call '{{.Name}} <server> --help' for help on a specific server.
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;		util.ExecuteTemplate(hk.Out(), tt, hk)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MakeSymlinks will create a symlink for each registered hyperkube server in the local directory.
0000000000000000000000000000000000000000;;	func (hk *HyperKube) MakeSymlinks(command string) error {
0000000000000000000000000000000000000000;;		wd, err := os.Getwd()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var errs bool
0000000000000000000000000000000000000000;;		for _, s := range hk.servers {
0000000000000000000000000000000000000000;;			link := path.Join(wd, s.Name())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := os.Symlink(command, link)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errs = true
0000000000000000000000000000000000000000;;				hk.Println(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if errs {
0000000000000000000000000000000000000000;;			return errors.New("Error creating one or more symlinks.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
