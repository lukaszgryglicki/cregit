0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
ebf9cb8298907e456c57393b9ba4f41ee9ec0dec;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package app
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/pprof"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		goruntime "runtime"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/healthz"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		v1core "k8s.io/client-go/kubernetes/typed/core/v1"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/leaderelection"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/leaderelection/resourcelock"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/cloud-controller-manager/app/options"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		nodecontroller "k8s.io/kubernetes/pkg/controller/cloud"
0000000000000000000000000000000000000000;;		routecontroller "k8s.io/kubernetes/pkg/controller/route"
0000000000000000000000000000000000000000;;		servicecontroller "k8s.io/kubernetes/pkg/controller/service"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/configz"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/prometheus/client_golang/prometheus"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Jitter used when starting controller managers
0000000000000000000000000000000000000000;;		ControllerStartJitter = 1.0
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCloudControllerManagerCommand creates a *cobra.Command object with default parameters
0000000000000000000000000000000000000000;;	func NewCloudControllerManagerCommand() *cobra.Command {
0000000000000000000000000000000000000000;;		s := options.NewCloudControllerManagerServer()
0000000000000000000000000000000000000000;;		s.AddFlags(pflag.CommandLine)
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use: "cloud-controller-manager",
0000000000000000000000000000000000000000;;			Long: `The Cloud controller manager is a daemon that embeds
0000000000000000000000000000000000000000;;	the cloud specific control loops shipped with Kubernetes.`,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resyncPeriod computes the time interval a shared informer waits before resyncing with the api server
0000000000000000000000000000000000000000;;	func resyncPeriod(s *options.CloudControllerManagerServer) func() time.Duration {
0000000000000000000000000000000000000000;;		return func() time.Duration {
0000000000000000000000000000000000000000;;			factor := rand.Float64() + 1
0000000000000000000000000000000000000000;;			return time.Duration(float64(s.MinResyncPeriod.Nanoseconds()) * factor)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run runs the ExternalCMServer.  This should never exit.
0000000000000000000000000000000000000000;;	func Run(s *options.CloudControllerManagerServer, cloud cloudprovider.Interface) error {
0000000000000000000000000000000000000000;;		if c, err := configz.New("componentconfig"); err == nil {
0000000000000000000000000000000000000000;;			c.Set(s.KubeControllerManagerConfiguration)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Errorf("unable to register configz: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kubeconfig, err := clientcmd.BuildConfigFromFlags(s.Master, s.Kubeconfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set the ContentType of the requests from kube client
0000000000000000000000000000000000000000;;		kubeconfig.ContentConfig.ContentType = s.ContentType
0000000000000000000000000000000000000000;;		// Override kubeconfig qps/burst settings from flags
0000000000000000000000000000000000000000;;		kubeconfig.QPS = s.KubeAPIQPS
0000000000000000000000000000000000000000;;		kubeconfig.Burst = int(s.KubeAPIBurst)
0000000000000000000000000000000000000000;;		kubeClient, err := clientset.NewForConfig(restclient.AddUserAgent(kubeconfig, "cloud-controller-manager"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Invalid API configuration: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		leaderElectionClient := kubernetes.NewForConfigOrDie(restclient.AddUserAgent(kubeconfig, "leader-election"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start the external controller manager server
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			mux := http.NewServeMux()
0000000000000000000000000000000000000000;;			healthz.InstallHandler(mux)
0000000000000000000000000000000000000000;;			if s.EnableProfiling {
0000000000000000000000000000000000000000;;				mux.HandleFunc("/debug/pprof/", pprof.Index)
0000000000000000000000000000000000000000;;				mux.HandleFunc("/debug/pprof/profile", pprof.Profile)
0000000000000000000000000000000000000000;;				mux.HandleFunc("/debug/pprof/symbol", pprof.Symbol)
0000000000000000000000000000000000000000;;				mux.HandleFunc("/debug/pprof/trace", pprof.Trace)
0000000000000000000000000000000000000000;;				if s.EnableContentionProfiling {
0000000000000000000000000000000000000000;;					goruntime.SetBlockProfileRate(1)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			configz.InstallHandler(mux)
0000000000000000000000000000000000000000;;			mux.Handle("/metrics", prometheus.Handler())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			server := &http.Server{
0000000000000000000000000000000000000000;;				Addr:    net.JoinHostPort(s.Address, strconv.Itoa(int(s.Port))),
0000000000000000000000000000000000000000;;				Handler: mux,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Fatal(server.ListenAndServe())
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(glog.Infof)
0000000000000000000000000000000000000000;;		eventBroadcaster.StartRecordingToSink(&v1core.EventSinkImpl{Interface: v1core.New(kubeClient.Core().RESTClient()).Events("")})
0000000000000000000000000000000000000000;;		recorder := eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "cloud-controller-manager"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		run := func(stop <-chan struct{}) {
0000000000000000000000000000000000000000;;			rootClientBuilder := controller.SimpleControllerClientBuilder{
0000000000000000000000000000000000000000;;				ClientConfig: kubeconfig,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var clientBuilder controller.ControllerClientBuilder
0000000000000000000000000000000000000000;;			if len(s.ServiceAccountKeyFile) > 0 && s.UseServiceAccountCredentials {
0000000000000000000000000000000000000000;;				clientBuilder = controller.SAControllerClientBuilder{
0000000000000000000000000000000000000000;;					ClientConfig:         restclient.AnonymousClientConfig(kubeconfig),
0000000000000000000000000000000000000000;;					CoreClient:           kubeClient.Core(),
0000000000000000000000000000000000000000;;					AuthenticationClient: kubeClient.Authentication(),
0000000000000000000000000000000000000000;;					Namespace:            "kube-system",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				clientBuilder = rootClientBuilder
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := StartControllers(s, kubeconfig, rootClientBuilder, clientBuilder, stop, recorder, cloud)
0000000000000000000000000000000000000000;;			glog.Fatalf("error running controllers: %v", err)
0000000000000000000000000000000000000000;;			panic("unreachable")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.LeaderElection.LeaderElect {
0000000000000000000000000000000000000000;;			run(nil)
0000000000000000000000000000000000000000;;			panic("unreachable")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Identity used to distinguish between multiple cloud controller manager instances
0000000000000000000000000000000000000000;;		id, err := os.Hostname()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Lock required for leader election
0000000000000000000000000000000000000000;;		rl := resourcelock.EndpointsLock{
0000000000000000000000000000000000000000;;			EndpointsMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: "kube-system",
0000000000000000000000000000000000000000;;				Name:      "cloud-controller-manager",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Client: leaderElectionClient,
0000000000000000000000000000000000000000;;			LockConfig: resourcelock.ResourceLockConfig{
0000000000000000000000000000000000000000;;				Identity:      id + "-external-cloud-controller",
0000000000000000000000000000000000000000;;				EventRecorder: recorder,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try and become the leader and start cloud controller manager loops
0000000000000000000000000000000000000000;;		leaderelection.RunOrDie(leaderelection.LeaderElectionConfig{
0000000000000000000000000000000000000000;;			Lock:          &rl,
0000000000000000000000000000000000000000;;			LeaseDuration: s.LeaderElection.LeaseDuration.Duration,
0000000000000000000000000000000000000000;;			RenewDeadline: s.LeaderElection.RenewDeadline.Duration,
0000000000000000000000000000000000000000;;			RetryPeriod:   s.LeaderElection.RetryPeriod.Duration,
0000000000000000000000000000000000000000;;			Callbacks: leaderelection.LeaderCallbacks{
0000000000000000000000000000000000000000;;				OnStartedLeading: run,
0000000000000000000000000000000000000000;;				OnStoppedLeading: func() {
0000000000000000000000000000000000000000;;					glog.Fatalf("leaderelection lost")
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		panic("unreachable")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StartControllers starts the cloud specific controller loops.
0000000000000000000000000000000000000000;;	func StartControllers(s *options.CloudControllerManagerServer, kubeconfig *restclient.Config, rootClientBuilder, clientBuilder controller.ControllerClientBuilder, stop <-chan struct{}, recorder record.EventRecorder, cloud cloudprovider.Interface) error {
0000000000000000000000000000000000000000;;		// Function to build the kube client object
0000000000000000000000000000000000000000;;		client := func(serviceAccountName string) clientset.Interface {
0000000000000000000000000000000000000000;;			return rootClientBuilder.ClientOrDie(serviceAccountName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cloud != nil {
0000000000000000000000000000000000000000;;			// Initialize the cloud provider with a reference to the clientBuilder
0000000000000000000000000000000000000000;;			cloud.Initialize(clientBuilder)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		versionedClient := client("shared-informers")
0000000000000000000000000000000000000000;;		sharedInformers := informers.NewSharedInformerFactory(versionedClient, resyncPeriod(s)())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, clusterCIDR, err := net.ParseCIDR(s.ClusterCIDR)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Unsuccessful parsing of cluster CIDR %v: %v", s.ClusterCIDR, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start the CloudNodeController
0000000000000000000000000000000000000000;;		nodeController := nodecontroller.NewCloudNodeController(
0000000000000000000000000000000000000000;;			sharedInformers.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			client("cloud-node-controller"), cloud,
0000000000000000000000000000000000000000;;			s.NodeMonitorPeriod.Duration,
0000000000000000000000000000000000000000;;			s.NodeStatusUpdateFrequency.Duration)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeController.Run()
0000000000000000000000000000000000000000;;		time.Sleep(wait.Jitter(s.ControllerStartInterval.Duration, ControllerStartJitter))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start the service controller
0000000000000000000000000000000000000000;;		serviceController, err := servicecontroller.New(
0000000000000000000000000000000000000000;;			cloud,
0000000000000000000000000000000000000000;;			client("service-controller"),
0000000000000000000000000000000000000000;;			sharedInformers.Core().V1().Services(),
0000000000000000000000000000000000000000;;			sharedInformers.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			s.ClusterName,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to start service controller: %v", err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			go serviceController.Run(stop, int(s.ConcurrentServiceSyncs))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		time.Sleep(wait.Jitter(s.ControllerStartInterval.Duration, ControllerStartJitter))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If CIDRs should be allocated for pods and set on the CloudProvider, then start the route controller
0000000000000000000000000000000000000000;;		if s.AllocateNodeCIDRs && s.ConfigureCloudRoutes {
0000000000000000000000000000000000000000;;			if routes, ok := cloud.Routes(); !ok {
0000000000000000000000000000000000000000;;				glog.Warning("configure-cloud-routes is set, but cloud provider does not support routes. Will not configure cloud provider routes.")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				routeController := routecontroller.New(routes, client("route-controller"), sharedInformers.Core().V1().Nodes(), s.ClusterName, clusterCIDR)
0000000000000000000000000000000000000000;;				go routeController.Run(stop, s.RouteReconciliationPeriod.Duration)
0000000000000000000000000000000000000000;;				time.Sleep(wait.Jitter(s.ControllerStartInterval.Duration, ControllerStartJitter))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Infof("Will not configure cloud provider routes for allocate-node-cidrs: %v, configure-cloud-routes: %v.", s.AllocateNodeCIDRs, s.ConfigureCloudRoutes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If apiserver is not running we should wait for some time and fail only then. This is particularly
0000000000000000000000000000000000000000;;		// important when we start apiserver and controller manager at the same time.
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(time.Second, 10*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			if _, err = restclient.ServerAPIVersions(kubeconfig); err == nil {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to get api versions from server: %v", err)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed to get api versions from server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sharedInformers.Start(stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {}
0000000000000000000000000000000000000000;;	}
