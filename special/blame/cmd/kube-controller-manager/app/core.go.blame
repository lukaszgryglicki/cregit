0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
cbb45ae52ce68ec726ff4455c14f08ba76d28581;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package app implements a server that runs a set of active
0000000000000000000000000000000000000000;;	// components.  This includes replication controllers, service endpoints and
0000000000000000000000000000000000000000;;	// nodes.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	package app
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		utilfeature "k8s.io/apiserver/pkg/util/feature"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/discovery"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/dynamic"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		endpointcontroller "k8s.io/kubernetes/pkg/controller/endpoint"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/garbagecollector"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/garbagecollector/metaonly"
0000000000000000000000000000000000000000;;		namespacecontroller "k8s.io/kubernetes/pkg/controller/namespace"
0000000000000000000000000000000000000000;;		nodecontroller "k8s.io/kubernetes/pkg/controller/node"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/podgc"
0000000000000000000000000000000000000000;;		replicationcontroller "k8s.io/kubernetes/pkg/controller/replication"
0000000000000000000000000000000000000000;;		resourcequotacontroller "k8s.io/kubernetes/pkg/controller/resourcequota"
0000000000000000000000000000000000000000;;		routecontroller "k8s.io/kubernetes/pkg/controller/route"
0000000000000000000000000000000000000000;;		servicecontroller "k8s.io/kubernetes/pkg/controller/service"
0000000000000000000000000000000000000000;;		serviceaccountcontroller "k8s.io/kubernetes/pkg/controller/serviceaccount"
0000000000000000000000000000000000000000;;		ttlcontroller "k8s.io/kubernetes/pkg/controller/ttl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/volume/attachdetach"
0000000000000000000000000000000000000000;;		persistentvolumecontroller "k8s.io/kubernetes/pkg/controller/volume/persistentvolume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/features"
0000000000000000000000000000000000000000;;		quotainstall "k8s.io/kubernetes/pkg/quota/install"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startServiceController(ctx ControllerContext) (bool, error) {
0000000000000000000000000000000000000000;;		serviceController, err := servicecontroller.New(
0000000000000000000000000000000000000000;;			ctx.Cloud,
0000000000000000000000000000000000000000;;			ctx.ClientBuilder.ClientOrDie("service-controller"),
0000000000000000000000000000000000000000;;			ctx.InformerFactory.Core().V1().Services(),
0000000000000000000000000000000000000000;;			ctx.InformerFactory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			ctx.Options.ClusterName,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to start service controller: %v", err)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go serviceController.Run(ctx.Stop, int(ctx.Options.ConcurrentServiceSyncs))
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startNodeController(ctx ControllerContext) (bool, error) {
0000000000000000000000000000000000000000;;		_, clusterCIDR, err := net.ParseCIDR(ctx.Options.ClusterCIDR)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Unsuccessful parsing of cluster CIDR %v: %v", ctx.Options.ClusterCIDR, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, serviceCIDR, err := net.ParseCIDR(ctx.Options.ServiceCIDR)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Unsuccessful parsing of service CIDR %v: %v", ctx.Options.ServiceCIDR, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeController, err := nodecontroller.NewNodeController(
0000000000000000000000000000000000000000;;			ctx.InformerFactory.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			ctx.InformerFactory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			ctx.InformerFactory.Extensions().V1beta1().DaemonSets(),
0000000000000000000000000000000000000000;;			ctx.Cloud,
0000000000000000000000000000000000000000;;			ctx.ClientBuilder.ClientOrDie("node-controller"),
0000000000000000000000000000000000000000;;			ctx.Options.PodEvictionTimeout.Duration,
0000000000000000000000000000000000000000;;			ctx.Options.NodeEvictionRate,
0000000000000000000000000000000000000000;;			ctx.Options.SecondaryNodeEvictionRate,
0000000000000000000000000000000000000000;;			ctx.Options.LargeClusterSizeThreshold,
0000000000000000000000000000000000000000;;			ctx.Options.UnhealthyZoneThreshold,
0000000000000000000000000000000000000000;;			ctx.Options.NodeMonitorGracePeriod.Duration,
0000000000000000000000000000000000000000;;			ctx.Options.NodeStartupGracePeriod.Duration,
0000000000000000000000000000000000000000;;			ctx.Options.NodeMonitorPeriod.Duration,
0000000000000000000000000000000000000000;;			clusterCIDR,
0000000000000000000000000000000000000000;;			serviceCIDR,
0000000000000000000000000000000000000000;;			int(ctx.Options.NodeCIDRMaskSize),
0000000000000000000000000000000000000000;;			ctx.Options.AllocateNodeCIDRs,
0000000000000000000000000000000000000000;;			nodecontroller.CIDRAllocatorType(ctx.Options.CIDRAllocatorType),
0000000000000000000000000000000000000000;;			ctx.Options.EnableTaintManager,
0000000000000000000000000000000000000000;;			utilfeature.DefaultFeatureGate.Enabled(features.TaintBasedEvictions),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go nodeController.Run(ctx.Stop)
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startRouteController(ctx ControllerContext) (bool, error) {
0000000000000000000000000000000000000000;;		_, clusterCIDR, err := net.ParseCIDR(ctx.Options.ClusterCIDR)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Unsuccessful parsing of cluster CIDR %v: %v", ctx.Options.ClusterCIDR, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO demorgans
0000000000000000000000000000000000000000;;		if ctx.Options.AllocateNodeCIDRs && ctx.Options.ConfigureCloudRoutes {
0000000000000000000000000000000000000000;;			if ctx.Cloud == nil {
0000000000000000000000000000000000000000;;				glog.Warning("configure-cloud-routes is set, but no cloud provider specified. Will not configure cloud provider routes.")
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			} else if routes, ok := ctx.Cloud.Routes(); !ok {
0000000000000000000000000000000000000000;;				glog.Warning("configure-cloud-routes is set, but cloud provider does not support routes. Will not configure cloud provider routes.")
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				routeController := routecontroller.New(routes, ctx.ClientBuilder.ClientOrDie("route-controller"), ctx.InformerFactory.Core().V1().Nodes(), ctx.Options.ClusterName, clusterCIDR)
0000000000000000000000000000000000000000;;				go routeController.Run(ctx.Stop, ctx.Options.RouteReconciliationPeriod.Duration)
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Infof("Will not configure cloud provider routes for allocate-node-cidrs: %v, configure-cloud-routes: %v.", ctx.Options.AllocateNodeCIDRs, ctx.Options.ConfigureCloudRoutes)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startPersistentVolumeBinderController(ctx ControllerContext) (bool, error) {
0000000000000000000000000000000000000000;;		params := persistentvolumecontroller.ControllerParameters{
0000000000000000000000000000000000000000;;			KubeClient:                ctx.ClientBuilder.ClientOrDie("persistent-volume-binder"),
0000000000000000000000000000000000000000;;			SyncPeriod:                ctx.Options.PVClaimBinderSyncPeriod.Duration,
0000000000000000000000000000000000000000;;			VolumePlugins:             ProbeControllerVolumePlugins(ctx.Cloud, ctx.Options.VolumeConfiguration),
0000000000000000000000000000000000000000;;			Cloud:                     ctx.Cloud,
0000000000000000000000000000000000000000;;			ClusterName:               ctx.Options.ClusterName,
0000000000000000000000000000000000000000;;			VolumeInformer:            ctx.InformerFactory.Core().V1().PersistentVolumes(),
0000000000000000000000000000000000000000;;			ClaimInformer:             ctx.InformerFactory.Core().V1().PersistentVolumeClaims(),
0000000000000000000000000000000000000000;;			ClassInformer:             ctx.InformerFactory.Storage().V1().StorageClasses(),
0000000000000000000000000000000000000000;;			EnableDynamicProvisioning: ctx.Options.VolumeConfiguration.EnableDynamicProvisioning,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumeController, volumeControllerErr := persistentvolumecontroller.NewController(params)
0000000000000000000000000000000000000000;;		if volumeControllerErr != nil {
0000000000000000000000000000000000000000;;			return true, fmt.Errorf("failed to construct persistentvolume controller: %v", volumeControllerErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go volumeController.Run(ctx.Stop)
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startAttachDetachController(ctx ControllerContext) (bool, error) {
0000000000000000000000000000000000000000;;		if ctx.Options.ReconcilerSyncLoopPeriod.Duration < time.Second {
0000000000000000000000000000000000000000;;			return true, fmt.Errorf("Duration time must be greater than one second as set via command line option reconcile-sync-loop-period.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attachDetachController, attachDetachControllerErr :=
0000000000000000000000000000000000000000;;			attachdetach.NewAttachDetachController(
0000000000000000000000000000000000000000;;				ctx.ClientBuilder.ClientOrDie("attachdetach-controller"),
0000000000000000000000000000000000000000;;				ctx.InformerFactory.Core().V1().Pods(),
0000000000000000000000000000000000000000;;				ctx.InformerFactory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;				ctx.InformerFactory.Core().V1().PersistentVolumeClaims(),
0000000000000000000000000000000000000000;;				ctx.InformerFactory.Core().V1().PersistentVolumes(),
0000000000000000000000000000000000000000;;				ctx.Cloud,
0000000000000000000000000000000000000000;;				ProbeAttachableVolumePlugins(ctx.Options.VolumeConfiguration),
0000000000000000000000000000000000000000;;				ctx.Options.DisableAttachDetachReconcilerSync,
0000000000000000000000000000000000000000;;				ctx.Options.ReconcilerSyncLoopPeriod.Duration,
0000000000000000000000000000000000000000;;				attachdetach.DefaultTimerConfig,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		if attachDetachControllerErr != nil {
0000000000000000000000000000000000000000;;			return true, fmt.Errorf("failed to start attach/detach controller: %v", attachDetachControllerErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go attachDetachController.Run(ctx.Stop)
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startEndpointController(ctx ControllerContext) (bool, error) {
0000000000000000000000000000000000000000;;		go endpointcontroller.NewEndpointController(
0000000000000000000000000000000000000000;;			ctx.InformerFactory.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			ctx.InformerFactory.Core().V1().Services(),
0000000000000000000000000000000000000000;;			ctx.InformerFactory.Core().V1().Endpoints(),
0000000000000000000000000000000000000000;;			ctx.ClientBuilder.ClientOrDie("endpoint-controller"),
0000000000000000000000000000000000000000;;		).Run(int(ctx.Options.ConcurrentEndpointSyncs), ctx.Stop)
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startReplicationController(ctx ControllerContext) (bool, error) {
0000000000000000000000000000000000000000;;		go replicationcontroller.NewReplicationManager(
0000000000000000000000000000000000000000;;			ctx.InformerFactory.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			ctx.InformerFactory.Core().V1().ReplicationControllers(),
0000000000000000000000000000000000000000;;			ctx.ClientBuilder.ClientOrDie("replication-controller"),
0000000000000000000000000000000000000000;;			replicationcontroller.BurstReplicas,
0000000000000000000000000000000000000000;;		).Run(int(ctx.Options.ConcurrentRCSyncs), ctx.Stop)
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startPodGCController(ctx ControllerContext) (bool, error) {
0000000000000000000000000000000000000000;;		go podgc.NewPodGC(
0000000000000000000000000000000000000000;;			ctx.ClientBuilder.ClientOrDie("pod-garbage-collector"),
0000000000000000000000000000000000000000;;			ctx.InformerFactory.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			int(ctx.Options.TerminatedPodGCThreshold),
0000000000000000000000000000000000000000;;		).Run(ctx.Stop)
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startResourceQuotaController(ctx ControllerContext) (bool, error) {
0000000000000000000000000000000000000000;;		resourceQuotaControllerClient := ctx.ClientBuilder.ClientOrDie("resourcequota-controller")
0000000000000000000000000000000000000000;;		resourceQuotaRegistry := quotainstall.NewRegistry(resourceQuotaControllerClient, ctx.InformerFactory)
0000000000000000000000000000000000000000;;		groupKindsToReplenish := []schema.GroupKind{
0000000000000000000000000000000000000000;;			api.Kind("Pod"),
0000000000000000000000000000000000000000;;			api.Kind("Service"),
0000000000000000000000000000000000000000;;			api.Kind("ReplicationController"),
0000000000000000000000000000000000000000;;			api.Kind("PersistentVolumeClaim"),
0000000000000000000000000000000000000000;;			api.Kind("Secret"),
0000000000000000000000000000000000000000;;			api.Kind("ConfigMap"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceQuotaControllerOptions := &resourcequotacontroller.ResourceQuotaControllerOptions{
0000000000000000000000000000000000000000;;			KubeClient:                resourceQuotaControllerClient,
0000000000000000000000000000000000000000;;			ResourceQuotaInformer:     ctx.InformerFactory.Core().V1().ResourceQuotas(),
0000000000000000000000000000000000000000;;			ResyncPeriod:              controller.StaticResyncPeriodFunc(ctx.Options.ResourceQuotaSyncPeriod.Duration),
0000000000000000000000000000000000000000;;			Registry:                  resourceQuotaRegistry,
0000000000000000000000000000000000000000;;			ControllerFactory:         resourcequotacontroller.NewReplenishmentControllerFactory(ctx.InformerFactory),
0000000000000000000000000000000000000000;;			ReplenishmentResyncPeriod: ResyncPeriod(&ctx.Options),
0000000000000000000000000000000000000000;;			GroupKindsToReplenish:     groupKindsToReplenish,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go resourcequotacontroller.NewResourceQuotaController(
0000000000000000000000000000000000000000;;			resourceQuotaControllerOptions,
0000000000000000000000000000000000000000;;		).Run(int(ctx.Options.ConcurrentResourceQuotaSyncs), ctx.Stop)
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startNamespaceController(ctx ControllerContext) (bool, error) {
0000000000000000000000000000000000000000;;		// TODO: should use a dynamic RESTMapper built from the discovery results.
0000000000000000000000000000000000000000;;		restMapper := api.Registry.RESTMapper()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the namespace cleanup controller is very chatty.  It makes lots of discovery calls and then it makes lots of delete calls
0000000000000000000000000000000000000000;;		// the ratelimiter negatively affects its speed.  Deleting 100 total items in a namespace (that's only a few of each resource
0000000000000000000000000000000000000000;;		// including events), takes ~10 seconds by default.
0000000000000000000000000000000000000000;;		nsKubeconfig := ctx.ClientBuilder.ConfigOrDie("namespace-controller")
0000000000000000000000000000000000000000;;		nsKubeconfig.QPS *= 10
0000000000000000000000000000000000000000;;		nsKubeconfig.Burst *= 10
0000000000000000000000000000000000000000;;		namespaceKubeClient := clientset.NewForConfigOrDie(nsKubeconfig)
0000000000000000000000000000000000000000;;		namespaceClientPool := dynamic.NewClientPool(nsKubeconfig, restMapper, dynamic.LegacyAPIPathResolverFunc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		discoverResourcesFn := namespaceKubeClient.Discovery().ServerPreferredNamespacedResources
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespaceController := namespacecontroller.NewNamespaceController(
0000000000000000000000000000000000000000;;			namespaceKubeClient,
0000000000000000000000000000000000000000;;			namespaceClientPool,
0000000000000000000000000000000000000000;;			discoverResourcesFn,
0000000000000000000000000000000000000000;;			ctx.InformerFactory.Core().V1().Namespaces(),
0000000000000000000000000000000000000000;;			ctx.Options.NamespaceSyncPeriod.Duration,
0000000000000000000000000000000000000000;;			v1.FinalizerKubernetes,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		go namespaceController.Run(int(ctx.Options.ConcurrentNamespaceSyncs), ctx.Stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startServiceAccountController(ctx ControllerContext) (bool, error) {
0000000000000000000000000000000000000000;;		go serviceaccountcontroller.NewServiceAccountsController(
0000000000000000000000000000000000000000;;			ctx.InformerFactory.Core().V1().ServiceAccounts(),
0000000000000000000000000000000000000000;;			ctx.InformerFactory.Core().V1().Namespaces(),
0000000000000000000000000000000000000000;;			ctx.ClientBuilder.ClientOrDie("service-account-controller"),
0000000000000000000000000000000000000000;;			serviceaccountcontroller.DefaultServiceAccountsControllerOptions(),
0000000000000000000000000000000000000000;;		).Run(1, ctx.Stop)
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startTTLController(ctx ControllerContext) (bool, error) {
0000000000000000000000000000000000000000;;		go ttlcontroller.NewTTLController(
0000000000000000000000000000000000000000;;			ctx.InformerFactory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			ctx.ClientBuilder.ClientOrDie("ttl-controller"),
0000000000000000000000000000000000000000;;		).Run(5, ctx.Stop)
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startGarbageCollectorController(ctx ControllerContext) (bool, error) {
0000000000000000000000000000000000000000;;		if !ctx.Options.EnableGarbageCollector {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: should use a dynamic RESTMapper built from the discovery results.
0000000000000000000000000000000000000000;;		restMapper := api.Registry.RESTMapper()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gcClientset := ctx.ClientBuilder.ClientOrDie("generic-garbage-collector")
0000000000000000000000000000000000000000;;		preferredResources, err := gcClientset.Discovery().ServerPreferredResources()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return true, fmt.Errorf("failed to get supported resources from server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deletableResources := discovery.FilteredBy(discovery.SupportsAllVerbs{Verbs: []string{"get", "list", "watch", "patch", "update", "delete"}}, preferredResources)
0000000000000000000000000000000000000000;;		deletableGroupVersionResources, err := discovery.GroupVersionResources(deletableResources)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return true, fmt.Errorf("Failed to parse resources from server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := ctx.ClientBuilder.ConfigOrDie("generic-garbage-collector")
0000000000000000000000000000000000000000;;		config.ContentConfig.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: metaonly.NewMetadataCodecFactory()}
0000000000000000000000000000000000000000;;		metaOnlyClientPool := dynamic.NewClientPool(config, restMapper, dynamic.LegacyAPIPathResolverFunc)
0000000000000000000000000000000000000000;;		config.ContentConfig = dynamic.ContentConfig()
0000000000000000000000000000000000000000;;		clientPool := dynamic.NewClientPool(config, restMapper, dynamic.LegacyAPIPathResolverFunc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ignoredResources := make(map[schema.GroupResource]struct{})
0000000000000000000000000000000000000000;;		for _, r := range ctx.Options.GCIgnoredResources {
0000000000000000000000000000000000000000;;			ignoredResources[schema.GroupResource{Group: r.Group, Resource: r.Resource}] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		garbageCollector, err := garbagecollector.NewGarbageCollector(
0000000000000000000000000000000000000000;;			metaOnlyClientPool,
0000000000000000000000000000000000000000;;			clientPool,
0000000000000000000000000000000000000000;;			restMapper,
0000000000000000000000000000000000000000;;			deletableGroupVersionResources,
0000000000000000000000000000000000000000;;			ignoredResources,
0000000000000000000000000000000000000000;;			ctx.InformerFactory,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return true, fmt.Errorf("Failed to start the generic garbage collector: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		workers := int(ctx.Options.ConcurrentGCSyncs)
0000000000000000000000000000000000000000;;		go garbageCollector.Run(workers, ctx.Stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
