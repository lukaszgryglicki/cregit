0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
c9cd94f737267e483e9701db20182a5951aa08f7;pkg/controllermanager/controllermanager.go[pkg/controllermanager/controllermanager.go][cmd/kube-controller-manager/app/controllermanager.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package app implements a server that runs a set of active
0000000000000000000000000000000000000000;;	// components.  This includes replication controllers, service endpoints and
0000000000000000000000000000000000000000;;	// nodes.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	package app
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/pprof"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		goruntime "runtime"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/healthz"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/discovery"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		v1core "k8s.io/client-go/kubernetes/typed/core/v1"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		certutil "k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/leaderelection"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/leaderelection/resourcelock"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kube-controller-manager/app/options"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		serviceaccountcontroller "k8s.io/kubernetes/pkg/controller/serviceaccount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/serviceaccount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/configz"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/version"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/prometheus/client_golang/prometheus"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Jitter used when starting controller managers
0000000000000000000000000000000000000000;;		ControllerStartJitter = 1.0
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewControllerManagerCommand creates a *cobra.Command object with default parameters
0000000000000000000000000000000000000000;;	func NewControllerManagerCommand() *cobra.Command {
0000000000000000000000000000000000000000;;		s := options.NewCMServer()
0000000000000000000000000000000000000000;;		s.AddFlags(pflag.CommandLine, KnownControllers(), ControllersDisabledByDefault.List())
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use: "kube-controller-manager",
0000000000000000000000000000000000000000;;			Long: `The Kubernetes controller manager is a daemon that embeds
0000000000000000000000000000000000000000;;	the core control loops shipped with Kubernetes. In applications of robotics and
0000000000000000000000000000000000000000;;	automation, a control loop is a non-terminating loop that regulates the state of
0000000000000000000000000000000000000000;;	the system. In Kubernetes, a controller is a control loop that watches the shared
0000000000000000000000000000000000000000;;	state of the cluster through the apiserver and makes changes attempting to move the
0000000000000000000000000000000000000000;;	current state towards the desired state. Examples of controllers that ship with
0000000000000000000000000000000000000000;;	Kubernetes today are the replication controller, endpoints controller, namespace
0000000000000000000000000000000000000000;;	controller, and serviceaccounts controller.`,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResyncPeriod returns a function which generates a duration each time it is
0000000000000000000000000000000000000000;;	// invoked; this is so that multiple controllers don't get into lock-step and all
0000000000000000000000000000000000000000;;	// hammer the apiserver with list requests simultaneously.
0000000000000000000000000000000000000000;;	func ResyncPeriod(s *options.CMServer) func() time.Duration {
0000000000000000000000000000000000000000;;		return func() time.Duration {
0000000000000000000000000000000000000000;;			factor := rand.Float64() + 1
0000000000000000000000000000000000000000;;			return time.Duration(float64(s.MinResyncPeriod.Nanoseconds()) * factor)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run runs the CMServer.  This should never exit.
0000000000000000000000000000000000000000;;	func Run(s *options.CMServer) error {
0000000000000000000000000000000000000000;;		// To help debugging, immediately log version
0000000000000000000000000000000000000000;;		glog.Infof("Version: %+v", version.Get())
0000000000000000000000000000000000000000;;		if err := s.Validate(KnownControllers(), ControllersDisabledByDefault.List()); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c, err := configz.New("componentconfig"); err == nil {
0000000000000000000000000000000000000000;;			c.Set(s.KubeControllerManagerConfiguration)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Errorf("unable to register configz: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kubeconfig, err := clientcmd.BuildConfigFromFlags(s.Master, s.Kubeconfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeconfig.ContentConfig.ContentType = s.ContentType
0000000000000000000000000000000000000000;;		// Override kubeconfig qps/burst settings from flags
0000000000000000000000000000000000000000;;		kubeconfig.QPS = s.KubeAPIQPS
0000000000000000000000000000000000000000;;		kubeconfig.Burst = int(s.KubeAPIBurst)
0000000000000000000000000000000000000000;;		kubeClient, err := clientset.NewForConfig(restclient.AddUserAgent(kubeconfig, "controller-manager"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Invalid API configuration: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		leaderElectionClient := kubernetes.NewForConfigOrDie(restclient.AddUserAgent(kubeconfig, "leader-election"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			mux := http.NewServeMux()
0000000000000000000000000000000000000000;;			healthz.InstallHandler(mux)
0000000000000000000000000000000000000000;;			if s.EnableProfiling {
0000000000000000000000000000000000000000;;				mux.HandleFunc("/debug/pprof/", pprof.Index)
0000000000000000000000000000000000000000;;				mux.HandleFunc("/debug/pprof/profile", pprof.Profile)
0000000000000000000000000000000000000000;;				mux.HandleFunc("/debug/pprof/symbol", pprof.Symbol)
0000000000000000000000000000000000000000;;				mux.HandleFunc("/debug/pprof/trace", pprof.Trace)
0000000000000000000000000000000000000000;;				if s.EnableContentionProfiling {
0000000000000000000000000000000000000000;;					goruntime.SetBlockProfileRate(1)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			configz.InstallHandler(mux)
0000000000000000000000000000000000000000;;			mux.Handle("/metrics", prometheus.Handler())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			server := &http.Server{
0000000000000000000000000000000000000000;;				Addr:    net.JoinHostPort(s.Address, strconv.Itoa(int(s.Port))),
0000000000000000000000000000000000000000;;				Handler: mux,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Fatal(server.ListenAndServe())
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(glog.Infof)
0000000000000000000000000000000000000000;;		eventBroadcaster.StartRecordingToSink(&v1core.EventSinkImpl{Interface: v1core.New(kubeClient.Core().RESTClient()).Events("")})
0000000000000000000000000000000000000000;;		recorder := eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "controller-manager"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		run := func(stop <-chan struct{}) {
0000000000000000000000000000000000000000;;			rootClientBuilder := controller.SimpleControllerClientBuilder{
0000000000000000000000000000000000000000;;				ClientConfig: kubeconfig,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var clientBuilder controller.ControllerClientBuilder
0000000000000000000000000000000000000000;;			if len(s.ServiceAccountKeyFile) > 0 && s.UseServiceAccountCredentials {
0000000000000000000000000000000000000000;;				clientBuilder = controller.SAControllerClientBuilder{
0000000000000000000000000000000000000000;;					ClientConfig:         restclient.AnonymousClientConfig(kubeconfig),
0000000000000000000000000000000000000000;;					CoreClient:           kubeClient.Core(),
0000000000000000000000000000000000000000;;					AuthenticationClient: kubeClient.Authentication(),
0000000000000000000000000000000000000000;;					Namespace:            "kube-system",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				clientBuilder = rootClientBuilder
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ctx, err := CreateControllerContext(s, rootClientBuilder, clientBuilder, stop)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Fatalf("error building controller context: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			saTokenControllerInitFunc := serviceAccountTokenControllerStarter{rootClientBuilder: rootClientBuilder}.startServiceAccountTokenController
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := StartControllers(ctx, saTokenControllerInitFunc, NewControllerInitializers()); err != nil {
0000000000000000000000000000000000000000;;				glog.Fatalf("error starting controllers: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ctx.InformerFactory.Start(ctx.Stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			select {}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.LeaderElection.LeaderElect {
0000000000000000000000000000000000000000;;			run(nil)
0000000000000000000000000000000000000000;;			panic("unreachable")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		id, err := os.Hostname()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rl, err := resourcelock.New(s.LeaderElection.ResourceLock,
0000000000000000000000000000000000000000;;			"kube-system",
0000000000000000000000000000000000000000;;			"kube-controller-manager",
0000000000000000000000000000000000000000;;			leaderElectionClient,
0000000000000000000000000000000000000000;;			resourcelock.ResourceLockConfig{
0000000000000000000000000000000000000000;;				Identity:      id,
0000000000000000000000000000000000000000;;				EventRecorder: recorder,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("error creating lock: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		leaderelection.RunOrDie(leaderelection.LeaderElectionConfig{
0000000000000000000000000000000000000000;;			Lock:          rl,
0000000000000000000000000000000000000000;;			LeaseDuration: s.LeaderElection.LeaseDuration.Duration,
0000000000000000000000000000000000000000;;			RenewDeadline: s.LeaderElection.RenewDeadline.Duration,
0000000000000000000000000000000000000000;;			RetryPeriod:   s.LeaderElection.RetryPeriod.Duration,
0000000000000000000000000000000000000000;;			Callbacks: leaderelection.LeaderCallbacks{
0000000000000000000000000000000000000000;;				OnStartedLeading: run,
0000000000000000000000000000000000000000;;				OnStoppedLeading: func() {
0000000000000000000000000000000000000000;;					glog.Fatalf("leaderelection lost")
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		panic("unreachable")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ControllerContext struct {
0000000000000000000000000000000000000000;;		// ClientBuilder will provide a client for this controller to use
0000000000000000000000000000000000000000;;		ClientBuilder controller.ControllerClientBuilder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// InformerFactory gives access to informers for the controller.
0000000000000000000000000000000000000000;;		InformerFactory informers.SharedInformerFactory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Options provides access to init options for a given controller
0000000000000000000000000000000000000000;;		Options options.CMServer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AvailableResources is a map listing currently available resources
0000000000000000000000000000000000000000;;		AvailableResources map[schema.GroupVersionResource]bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Cloud is the cloud provider interface for the controllers to use.
0000000000000000000000000000000000000000;;		// It must be initialized and ready to use.
0000000000000000000000000000000000000000;;		Cloud cloudprovider.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stop is the stop channel
0000000000000000000000000000000000000000;;		Stop <-chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c ControllerContext) IsControllerEnabled(name string) bool {
0000000000000000000000000000000000000000;;		return IsControllerEnabled(name, ControllersDisabledByDefault, c.Options.Controllers...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IsControllerEnabled(name string, disabledByDefaultControllers sets.String, controllers ...string) bool {
0000000000000000000000000000000000000000;;		hasStar := false
0000000000000000000000000000000000000000;;		for _, ctrl := range controllers {
0000000000000000000000000000000000000000;;			if ctrl == name {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ctrl == "-"+name {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ctrl == "*" {
0000000000000000000000000000000000000000;;				hasStar = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if we get here, there was no explicit choice
0000000000000000000000000000000000000000;;		if !hasStar {
0000000000000000000000000000000000000000;;			// nothing on by default
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if disabledByDefaultControllers.Has(name) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InitFunc is used to launch a particular controller.  It may run additional "should I activate checks".
0000000000000000000000000000000000000000;;	// Any error returned will cause the controller process to `Fatal`
0000000000000000000000000000000000000000;;	// The bool indicates whether the controller was enabled.
0000000000000000000000000000000000000000;;	type InitFunc func(ctx ControllerContext) (bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func KnownControllers() []string {
0000000000000000000000000000000000000000;;		ret := sets.StringKeySet(NewControllerInitializers())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// add "special" controllers that aren't initialized normally.  These controllers cannot be initialized
0000000000000000000000000000000000000000;;		// using a normal function.  The only known special case is the SA token controller which *must* be started
0000000000000000000000000000000000000000;;		// first to ensure that the SA tokens for future controllers will exist.  Think very carefully before adding
0000000000000000000000000000000000000000;;		// to this list.
0000000000000000000000000000000000000000;;		ret.Insert(
0000000000000000000000000000000000000000;;			saTokenControllerName,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret.List()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ControllersDisabledByDefault = sets.NewString(
0000000000000000000000000000000000000000;;		"bootstrapsigner",
0000000000000000000000000000000000000000;;		"tokencleaner",
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		saTokenControllerName = "serviceaccount-token"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewControllerInitializers is a public map of named controller groups (you can start more than one in an init func)
0000000000000000000000000000000000000000;;	// paired to their InitFunc.  This allows for structured downstream composition and subdivision.
0000000000000000000000000000000000000000;;	func NewControllerInitializers() map[string]InitFunc {
0000000000000000000000000000000000000000;;		controllers := map[string]InitFunc{}
0000000000000000000000000000000000000000;;		controllers["endpoint"] = startEndpointController
0000000000000000000000000000000000000000;;		controllers["replicationcontroller"] = startReplicationController
0000000000000000000000000000000000000000;;		controllers["podgc"] = startPodGCController
0000000000000000000000000000000000000000;;		controllers["resourcequota"] = startResourceQuotaController
0000000000000000000000000000000000000000;;		controllers["namespace"] = startNamespaceController
0000000000000000000000000000000000000000;;		controllers["serviceaccount"] = startServiceAccountController
0000000000000000000000000000000000000000;;		controllers["garbagecollector"] = startGarbageCollectorController
0000000000000000000000000000000000000000;;		controllers["daemonset"] = startDaemonSetController
0000000000000000000000000000000000000000;;		controllers["job"] = startJobController
0000000000000000000000000000000000000000;;		controllers["deployment"] = startDeploymentController
0000000000000000000000000000000000000000;;		controllers["replicaset"] = startReplicaSetController
0000000000000000000000000000000000000000;;		controllers["horizontalpodautoscaling"] = startHPAController
0000000000000000000000000000000000000000;;		controllers["disruption"] = startDisruptionController
0000000000000000000000000000000000000000;;		controllers["statefulset"] = startStatefulSetController
0000000000000000000000000000000000000000;;		controllers["cronjob"] = startCronJobController
0000000000000000000000000000000000000000;;		controllers["csrsigning"] = startCSRSigningController
0000000000000000000000000000000000000000;;		controllers["csrapproving"] = startCSRApprovingController
0000000000000000000000000000000000000000;;		controllers["ttl"] = startTTLController
0000000000000000000000000000000000000000;;		controllers["bootstrapsigner"] = startBootstrapSignerController
0000000000000000000000000000000000000000;;		controllers["tokencleaner"] = startTokenCleanerController
0000000000000000000000000000000000000000;;		controllers["service"] = startServiceController
0000000000000000000000000000000000000000;;		controllers["node"] = startNodeController
0000000000000000000000000000000000000000;;		controllers["route"] = startRouteController
0000000000000000000000000000000000000000;;		controllers["persistentvolume-binder"] = startPersistentVolumeBinderController
0000000000000000000000000000000000000000;;		controllers["attachdetach"] = startAttachDetachController
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return controllers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: In general, any controller checking this needs to be dynamic so
0000000000000000000000000000000000000000;;	//  users don't have to restart their controller manager if they change the apiserver.
0000000000000000000000000000000000000000;;	// Until we get there, the structure here needs to be exposed for the construction of a proper ControllerContext.
0000000000000000000000000000000000000000;;	func GetAvailableResources(clientBuilder controller.ControllerClientBuilder) (map[schema.GroupVersionResource]bool, error) {
0000000000000000000000000000000000000000;;		var discoveryClient discovery.DiscoveryInterface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If apiserver is not running we should wait for some time and fail only then. This is particularly
0000000000000000000000000000000000000000;;		// important when we start apiserver and controller manager at the same time.
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(time.Second, 10*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			client, err := clientBuilder.Client("controller-discovery")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to get api versions from server: %v", err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			healthStatus := 0
0000000000000000000000000000000000000000;;			client.Discovery().RESTClient().Get().AbsPath("/healthz").Do().StatusCode(&healthStatus)
0000000000000000000000000000000000000000;;			if healthStatus != http.StatusOK {
0000000000000000000000000000000000000000;;				glog.Errorf("Server isn't healthy yet.  Waiting a little while.")
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			discoveryClient = client.Discovery()
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to get api versions from server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resourceMap, err := discoveryClient.ServerResources()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to get supported resources from server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allResources := map[schema.GroupVersionResource]bool{}
0000000000000000000000000000000000000000;;		for _, apiResourceList := range resourceMap {
0000000000000000000000000000000000000000;;			version, err := schema.ParseGroupVersion(apiResourceList.GroupVersion)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, apiResource := range apiResourceList.APIResources {
0000000000000000000000000000000000000000;;				allResources[version.WithResource(apiResource.Name)] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allResources, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreateControllerContext(s *options.CMServer, rootClientBuilder, clientBuilder controller.ControllerClientBuilder, stop <-chan struct{}) (ControllerContext, error) {
0000000000000000000000000000000000000000;;		versionedClient := rootClientBuilder.ClientOrDie("shared-informers")
0000000000000000000000000000000000000000;;		sharedInformers := informers.NewSharedInformerFactory(versionedClient, ResyncPeriod(s)())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		availableResources, err := GetAvailableResources(rootClientBuilder)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ControllerContext{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cloud, err := cloudprovider.InitCloudProvider(s.CloudProvider, s.CloudConfigFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ControllerContext{}, fmt.Errorf("cloud provider could not be initialized: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cloud != nil {
0000000000000000000000000000000000000000;;			// Initialize the cloud provider with a reference to the clientBuilder
0000000000000000000000000000000000000000;;			cloud.Initialize(rootClientBuilder)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx := ControllerContext{
0000000000000000000000000000000000000000;;			ClientBuilder:      clientBuilder,
0000000000000000000000000000000000000000;;			InformerFactory:    sharedInformers,
0000000000000000000000000000000000000000;;			Options:            *s,
0000000000000000000000000000000000000000;;			AvailableResources: availableResources,
0000000000000000000000000000000000000000;;			Cloud:              cloud,
0000000000000000000000000000000000000000;;			Stop:               stop,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ctx, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func StartControllers(ctx ControllerContext, startSATokenController InitFunc, controllers map[string]InitFunc) error {
0000000000000000000000000000000000000000;;		// Always start the SA token controller first using a full-power client, since it needs to mint tokens for the rest
0000000000000000000000000000000000000000;;		// If this fails, just return here and fail since other controllers won't be able to get credentials.
0000000000000000000000000000000000000000;;		if _, err := startSATokenController(ctx); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for controllerName, initFn := range controllers {
0000000000000000000000000000000000000000;;			if !ctx.IsControllerEnabled(controllerName) {
0000000000000000000000000000000000000000;;				glog.Warningf("%q is disabled", controllerName)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			time.Sleep(wait.Jitter(ctx.Options.ControllerStartInterval.Duration, ControllerStartJitter))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(1).Infof("Starting %q", controllerName)
0000000000000000000000000000000000000000;;			started, err := initFn(ctx)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Error starting %q", controllerName)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !started {
0000000000000000000000000000000000000000;;				glog.Warningf("Skipping %q", controllerName)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Infof("Started %q", controllerName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serviceAccountTokenControllerStarter is special because it must run first to set up permissions for other controllers.
0000000000000000000000000000000000000000;;	// It cannot use the "normal" client builder, so it tracks its own. It must also avoid being included in the "normal"
0000000000000000000000000000000000000000;;	// init map so that it can always run first.
0000000000000000000000000000000000000000;;	type serviceAccountTokenControllerStarter struct {
0000000000000000000000000000000000000000;;		rootClientBuilder controller.ControllerClientBuilder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c serviceAccountTokenControllerStarter) startServiceAccountTokenController(ctx ControllerContext) (bool, error) {
0000000000000000000000000000000000000000;;		if !ctx.IsControllerEnabled(saTokenControllerName) {
0000000000000000000000000000000000000000;;			glog.Warningf("%q is disabled", saTokenControllerName)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ctx.Options.ServiceAccountKeyFile) == 0 {
0000000000000000000000000000000000000000;;			glog.Warningf("%q is disabled because there is no private key", saTokenControllerName)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		privateKey, err := serviceaccount.ReadPrivateKey(ctx.Options.ServiceAccountKeyFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return true, fmt.Errorf("error reading key for service account token controller: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var rootCA []byte
0000000000000000000000000000000000000000;;		if ctx.Options.RootCAFile != "" {
0000000000000000000000000000000000000000;;			rootCA, err = ioutil.ReadFile(ctx.Options.RootCAFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return true, fmt.Errorf("error reading root-ca-file at %s: %v", ctx.Options.RootCAFile, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := certutil.ParseCertsPEM(rootCA); err != nil {
0000000000000000000000000000000000000000;;				return true, fmt.Errorf("error parsing root-ca-file at %s: %v", ctx.Options.RootCAFile, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rootCA = c.rootClientBuilder.ConfigOrDie("tokens-controller").CAData
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controller := serviceaccountcontroller.NewTokensController(
0000000000000000000000000000000000000000;;			ctx.InformerFactory.Core().V1().ServiceAccounts(),
0000000000000000000000000000000000000000;;			ctx.InformerFactory.Core().V1().Secrets(),
0000000000000000000000000000000000000000;;			c.rootClientBuilder.ClientOrDie("tokens-controller"),
0000000000000000000000000000000000000000;;			serviceaccountcontroller.TokensControllerOptions{
0000000000000000000000000000000000000000;;				TokenGenerator: serviceaccount.JWTTokenGenerator(privateKey),
0000000000000000000000000000000000000000;;				RootCA:         rootCA,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		go controller.Run(int(ctx.Options.ConcurrentSATokenSyncs), ctx.Stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// start the first set of informers now so that other controllers can start
0000000000000000000000000000000000000000;;		ctx.InformerFactory.Start(ctx.Stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
