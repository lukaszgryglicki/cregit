0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
e9c7c9f939fce6eaa13e3330f4498ca314738d66;cmd/apiserver/plugins.go[cmd/apiserver/plugins.go][cmd/kube-controller-manager/app/plugins.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package app
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		// This file exists to force the desired plugin implementations to be linked.
0000000000000000000000000000000000000000;;		// This should probably be part of some configuration fed into the build for a
0000000000000000000000000000000000000000;;		// given binary target.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Cloud providers
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/cloudprovider/providers"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Volume plugins
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/aws"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/azure"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/gce"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/openstack"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/photon"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/vsphere"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/aws_ebs"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/azure_dd"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/azure_file"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/cinder"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/flexvolume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/flocker"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/gce_pd"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/glusterfs"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/host_path"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/local"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/nfs"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/photon_pd"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/portworx"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/quobyte"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/rbd"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/scaleio"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/storageos"
0000000000000000000000000000000000000000;;		volumeutil "k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/vsphere_volume"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProbeAttachableVolumePlugins collects all volume plugins for the attach/
0000000000000000000000000000000000000000;;	// detach controller. VolumeConfiguration is used ot get FlexVolumePluginDir
0000000000000000000000000000000000000000;;	// which specifies the directory to search for additional third party volume
0000000000000000000000000000000000000000;;	// plugins.
0000000000000000000000000000000000000000;;	// The list of plugins is manually compiled. This code and the plugin
0000000000000000000000000000000000000000;;	// initialization code for kubelet really, really need a through refactor.
0000000000000000000000000000000000000000;;	func ProbeAttachableVolumePlugins(config componentconfig.VolumeConfiguration) []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		allPlugins := []volume.VolumePlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, aws_ebs.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, gce_pd.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, cinder.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, flexvolume.ProbeVolumePlugins(config.FlexVolumePluginDir)...)
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, portworx.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, vsphere_volume.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, azure_dd.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, photon_pd.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, scaleio.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, storageos.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;		return allPlugins
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProbeControllerVolumePlugins collects all persistent volume plugins into an
0000000000000000000000000000000000000000;;	// easy to use list. Only volume plugins that implement any of
0000000000000000000000000000000000000000;;	// provisioner/recycler/deleter interface should be returned.
0000000000000000000000000000000000000000;;	func ProbeControllerVolumePlugins(cloud cloudprovider.Interface, config componentconfig.VolumeConfiguration) []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		allPlugins := []volume.VolumePlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The list of plugins to probe is decided by this binary, not
0000000000000000000000000000000000000000;;		// by dynamic linking or other "magic".  Plugins will be analyzed and
0000000000000000000000000000000000000000;;		// initialized later.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Each plugin can make use of VolumeConfig.  The single arg to this func contains *all* enumerated
0000000000000000000000000000000000000000;;		// options meant to configure volume plugins.  From that single config, create an instance of volume.VolumeConfig
0000000000000000000000000000000000000000;;		// for a specific plugin and pass that instance to the plugin's ProbeVolumePlugins(config) func.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HostPath recycling is for testing and development purposes only!
0000000000000000000000000000000000000000;;		hostPathConfig := volume.VolumeConfig{
0000000000000000000000000000000000000000;;			RecyclerMinimumTimeout:   int(config.PersistentVolumeRecyclerConfiguration.MinimumTimeoutHostPath),
0000000000000000000000000000000000000000;;			RecyclerTimeoutIncrement: int(config.PersistentVolumeRecyclerConfiguration.IncrementTimeoutHostPath),
0000000000000000000000000000000000000000;;			RecyclerPodTemplate:      volume.NewPersistentVolumeRecyclerPodTemplate(),
0000000000000000000000000000000000000000;;			ProvisioningEnabled:      config.EnableHostPathProvisioning,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := AttemptToLoadRecycler(config.PersistentVolumeRecyclerConfiguration.PodTemplateFilePathHostPath, &hostPathConfig); err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Could not create hostpath recycler pod from file %s: %+v", config.PersistentVolumeRecyclerConfiguration.PodTemplateFilePathHostPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, host_path.ProbeVolumePlugins(hostPathConfig)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nfsConfig := volume.VolumeConfig{
0000000000000000000000000000000000000000;;			RecyclerMinimumTimeout:   int(config.PersistentVolumeRecyclerConfiguration.MinimumTimeoutNFS),
0000000000000000000000000000000000000000;;			RecyclerTimeoutIncrement: int(config.PersistentVolumeRecyclerConfiguration.IncrementTimeoutNFS),
0000000000000000000000000000000000000000;;			RecyclerPodTemplate:      volume.NewPersistentVolumeRecyclerPodTemplate(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := AttemptToLoadRecycler(config.PersistentVolumeRecyclerConfiguration.PodTemplateFilePathNFS, &nfsConfig); err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Could not create NFS recycler pod from file %s: %+v", config.PersistentVolumeRecyclerConfiguration.PodTemplateFilePathNFS, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, nfs.ProbeVolumePlugins(nfsConfig)...)
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, glusterfs.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;		// add rbd provisioner
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, rbd.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, quobyte.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, azure_file.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, flocker.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, portworx.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, scaleio.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, local.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;		allPlugins = append(allPlugins, storageos.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cloud != nil {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case aws.ProviderName == cloud.ProviderName():
0000000000000000000000000000000000000000;;				allPlugins = append(allPlugins, aws_ebs.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;			case gce.ProviderName == cloud.ProviderName():
0000000000000000000000000000000000000000;;				allPlugins = append(allPlugins, gce_pd.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;			case openstack.ProviderName == cloud.ProviderName():
0000000000000000000000000000000000000000;;				allPlugins = append(allPlugins, cinder.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;			case vsphere.ProviderName == cloud.ProviderName():
0000000000000000000000000000000000000000;;				allPlugins = append(allPlugins, vsphere_volume.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;			case azure.CloudProviderName == cloud.ProviderName():
0000000000000000000000000000000000000000;;				allPlugins = append(allPlugins, azure_dd.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;			case photon.ProviderName == cloud.ProviderName():
0000000000000000000000000000000000000000;;				allPlugins = append(allPlugins, photon_pd.ProbeVolumePlugins()...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allPlugins
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AttemptToLoadRecycler tries decoding a pod from a filepath for use as a recycler for a volume.
0000000000000000000000000000000000000000;;	// If successful, this method will set the recycler on the config.
0000000000000000000000000000000000000000;;	// If unsuccessful, an error is returned. Function is exported for reuse downstream.
0000000000000000000000000000000000000000;;	func AttemptToLoadRecycler(path string, config *volume.VolumeConfig) error {
0000000000000000000000000000000000000000;;		if path != "" {
0000000000000000000000000000000000000000;;			recyclerPod, err := volumeutil.LoadPodFromFile(path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = volume.ValidateRecyclerPodTemplate(recyclerPod); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Pod specification (%v): %v", path, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			config.RecyclerPodTemplate = recyclerPod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
