0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
3d00d115beae3ce8001307407b9741cd6461b964;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;		"gopkg.in/yaml.v2"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// gen_slate_yaml creates a yaml representation of the kubectl help commands.  This is to be consumed
0000000000000000000000000000000000000000;;	// by tools to generate documentation.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var outputFile = flag.String("output", "", "Destination for kubectl yaml representation.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(*outputFile) < 1 {
0000000000000000000000000000000000000000;;			fmt.Printf("Must specify --output.\n")
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Initialize a kubectl command that we can use to get the help documentation
0000000000000000000000000000000000000000;;		kubectl := cmd.NewKubectlCommand(cmdutil.NewFactory(nil), os.Stdin, ioutil.Discard, ioutil.Discard)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the structural representation
0000000000000000000000000000000000000000;;		spec := NewKubectlSpec(kubectl)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write the spec to a file as yaml
0000000000000000000000000000000000000000;;		WriteFile(spec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func WriteFile(spec KubectlSpec) {
0000000000000000000000000000000000000000;;		// Marshall the yaml
0000000000000000000000000000000000000000;;		final, err := yaml.Marshal(&spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Println(err)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the file
0000000000000000000000000000000000000000;;		outFile, err := os.Create(*outputFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Println(err)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer outFile.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write the file
0000000000000000000000000000000000000000;;		_, err = outFile.Write(final)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Println(err)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewKubectlSpec(c *cobra.Command) KubectlSpec {
0000000000000000000000000000000000000000;;		return KubectlSpec{
0000000000000000000000000000000000000000;;			TopLevelCommandGroups: []TopLevelCommands{NewTopLevelCommands(c.Commands())},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewTopLevelCommands(cs []*cobra.Command) TopLevelCommands {
0000000000000000000000000000000000000000;;		tlc := TopLevelCommands{}
0000000000000000000000000000000000000000;;		for _, c := range cs {
0000000000000000000000000000000000000000;;			tlc.Commands = append(tlc.Commands, NewTopLevelCommand(c))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(tlc)
0000000000000000000000000000000000000000;;		return tlc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewTopLevelCommand(c *cobra.Command) TopLevelCommand {
0000000000000000000000000000000000000000;;		result := TopLevelCommand{
0000000000000000000000000000000000000000;;			MainCommand: NewCommand(c, ""),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, sub := range c.Commands() {
0000000000000000000000000000000000000000;;			result.SubCommands = append(result.SubCommands, NewSubCommands(sub, "")...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(result.SubCommands)
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the Options
0000000000000000000000000000000000000000;;	func NewOptions(flags *pflag.FlagSet) Options {
0000000000000000000000000000000000000000;;		result := Options{}
0000000000000000000000000000000000000000;;		flags.VisitAll(func(flag *pflag.Flag) {
0000000000000000000000000000000000000000;;			opt := &Option{
0000000000000000000000000000000000000000;;				Name:         flag.Name,
0000000000000000000000000000000000000000;;				Shorthand:    flag.Shorthand,
0000000000000000000000000000000000000000;;				DefaultValue: flag.DefValue,
0000000000000000000000000000000000000000;;				Usage:        flag.Usage,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = append(result, opt)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the Commands
0000000000000000000000000000000000000000;;	func NewSubCommands(c *cobra.Command, path string) Commands {
0000000000000000000000000000000000000000;;		subCommands := Commands{NewCommand(c, path+c.Name())}
0000000000000000000000000000000000000000;;		for _, subCommand := range c.Commands() {
0000000000000000000000000000000000000000;;			subCommands = append(subCommands, NewSubCommands(subCommand, path+c.Name()+" ")...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return subCommands
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCommand(c *cobra.Command, path string) *Command {
0000000000000000000000000000000000000000;;		return &Command{
0000000000000000000000000000000000000000;;			Name:             c.Name(),
0000000000000000000000000000000000000000;;			Path:             path,
0000000000000000000000000000000000000000;;			Description:      c.Long,
0000000000000000000000000000000000000000;;			Synopsis:         c.Short,
0000000000000000000000000000000000000000;;			Example:          c.Example,
0000000000000000000000000000000000000000;;			Options:          NewOptions(c.NonInheritedFlags()),
0000000000000000000000000000000000000000;;			InheritedOptions: NewOptions(c.InheritedFlags()),
0000000000000000000000000000000000000000;;			Usage:            c.Use,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//////////////////////////
0000000000000000000000000000000000000000;;	// Types
0000000000000000000000000000000000000000;;	//////////////////////////
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type KubectlSpec struct {
0000000000000000000000000000000000000000;;		TopLevelCommandGroups []TopLevelCommands `yaml:",omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TopLevelCommands struct {
0000000000000000000000000000000000000000;;		Commands []TopLevelCommand `yaml:",omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	type TopLevelCommand struct {
0000000000000000000000000000000000000000;;		MainCommand *Command `yaml:",omitempty"`
0000000000000000000000000000000000000000;;		SubCommands Commands `yaml:",omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Options []*Option
0000000000000000000000000000000000000000;;	type Option struct {
0000000000000000000000000000000000000000;;		Name         string `yaml:",omitempty"`
0000000000000000000000000000000000000000;;		Shorthand    string `yaml:",omitempty"`
0000000000000000000000000000000000000000;;		DefaultValue string `yaml:"default_value,omitempty"`
0000000000000000000000000000000000000000;;		Usage        string `yaml:",omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Commands []*Command
0000000000000000000000000000000000000000;;	type Command struct {
0000000000000000000000000000000000000000;;		Name             string   `yaml:",omitempty"`
0000000000000000000000000000000000000000;;		Path             string   `yaml:",omitempty"`
0000000000000000000000000000000000000000;;		Synopsis         string   `yaml:",omitempty"`
0000000000000000000000000000000000000000;;		Description      string   `yaml:",omitempty"`
0000000000000000000000000000000000000000;;		Options          Options  `yaml:",omitempty"`
0000000000000000000000000000000000000000;;		InheritedOptions Options  `yaml:"inherited_options,omitempty"`
0000000000000000000000000000000000000000;;		Example          string   `yaml:",omitempty"`
0000000000000000000000000000000000000000;;		SeeAlso          []string `yaml:"see_also,omitempty"`
0000000000000000000000000000000000000000;;		Usage            string   `yaml:",omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a Options) Len() int      { return len(a) }
0000000000000000000000000000000000000000;;	func (a Options) Swap(i, j int) { a[i], a[j] = a[j], a[i] }
0000000000000000000000000000000000000000;;	func (a Options) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return a[i].Name < a[j].Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a TopLevelCommands) Len() int      { return len(a.Commands) }
0000000000000000000000000000000000000000;;	func (a TopLevelCommands) Swap(i, j int) { a.Commands[i], a.Commands[j] = a.Commands[j], a.Commands[i] }
0000000000000000000000000000000000000000;;	func (a TopLevelCommands) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return a.Commands[i].MainCommand.Path < a.Commands[j].MainCommand.Path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a Commands) Len() int      { return len(a) }
0000000000000000000000000000000000000000;;	func (a Commands) Swap(i, j int) { a[i], a[j] = a[j], a[i] }
0000000000000000000000000000000000000000;;	func (a Commands) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return a[i].Path < a[j].Path
0000000000000000000000000000000000000000;;	}
