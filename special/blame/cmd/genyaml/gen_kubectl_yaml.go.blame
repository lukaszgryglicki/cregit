0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
fcc6afc6cd61d76bc5319ad15f612874fedc4f73;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;		"gopkg.in/yaml.v2"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/genutils"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cmdOption struct {
0000000000000000000000000000000000000000;;		Name         string
0000000000000000000000000000000000000000;;		Shorthand    string `yaml:",omitempty"`
0000000000000000000000000000000000000000;;		DefaultValue string `yaml:"default_value,omitempty"`
0000000000000000000000000000000000000000;;		Usage        string `yaml:",omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cmdDoc struct {
0000000000000000000000000000000000000000;;		Name             string
0000000000000000000000000000000000000000;;		Synopsis         string      `yaml:",omitempty"`
0000000000000000000000000000000000000000;;		Description      string      `yaml:",omitempty"`
0000000000000000000000000000000000000000;;		Options          []cmdOption `yaml:",omitempty"`
0000000000000000000000000000000000000000;;		InheritedOptions []cmdOption `yaml:"inherited_options,omitempty"`
0000000000000000000000000000000000000000;;		Example          string      `yaml:",omitempty"`
0000000000000000000000000000000000000000;;		SeeAlso          []string    `yaml:"see_also,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		path := "docs/yaml/kubectl"
0000000000000000000000000000000000000000;;		if len(os.Args) == 2 {
0000000000000000000000000000000000000000;;			path = os.Args[1]
0000000000000000000000000000000000000000;;		} else if len(os.Args) > 2 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "usage: %s [output directory]\n", os.Args[0])
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		outDir, err := genutils.OutDir(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "failed to get output directory: %v\n", err)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set environment variables used by kubectl so the output is consistent,
0000000000000000000000000000000000000000;;		// regardless of where we run.
0000000000000000000000000000000000000000;;		os.Setenv("HOME", "/home/username")
0000000000000000000000000000000000000000;;		// TODO os.Stdin should really be something like ioutil.Discard, but a Reader
0000000000000000000000000000000000000000;;		kubectl := cmd.NewKubectlCommand(cmdutil.NewFactory(nil), os.Stdin, ioutil.Discard, ioutil.Discard)
0000000000000000000000000000000000000000;;		genYaml(kubectl, "", outDir)
0000000000000000000000000000000000000000;;		for _, c := range kubectl.Commands() {
0000000000000000000000000000000000000000;;			genYaml(c, "kubectl", outDir)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Temporary workaround for yaml lib generating incorrect yaml with long strings
0000000000000000000000000000000000000000;;	// that do not contain \n.
0000000000000000000000000000000000000000;;	func forceMultiLine(s string) string {
0000000000000000000000000000000000000000;;		if len(s) > 60 && !strings.Contains(s, "\n") {
0000000000000000000000000000000000000000;;			s = s + "\n"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genFlagResult(flags *pflag.FlagSet) []cmdOption {
0000000000000000000000000000000000000000;;		result := []cmdOption{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flags.VisitAll(func(flag *pflag.Flag) {
0000000000000000000000000000000000000000;;			// Todo, when we mark a shorthand is deprecated, but specify an empty message.
0000000000000000000000000000000000000000;;			// The flag.ShorthandDeprecated is empty as the shorthand is deprecated.
0000000000000000000000000000000000000000;;			// Using len(flag.ShorthandDeprecated) > 0 can't handle this, others are ok.
0000000000000000000000000000000000000000;;			if !(len(flag.ShorthandDeprecated) > 0) && len(flag.Shorthand) > 0 {
0000000000000000000000000000000000000000;;				opt := cmdOption{
0000000000000000000000000000000000000000;;					flag.Name,
0000000000000000000000000000000000000000;;					flag.Shorthand,
0000000000000000000000000000000000000000;;					flag.DefValue,
0000000000000000000000000000000000000000;;					forceMultiLine(flag.Usage),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				result = append(result, opt)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				opt := cmdOption{
0000000000000000000000000000000000000000;;					Name:         flag.Name,
0000000000000000000000000000000000000000;;					DefaultValue: forceMultiLine(flag.DefValue),
0000000000000000000000000000000000000000;;					Usage:        forceMultiLine(flag.Usage),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				result = append(result, opt)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genYaml(command *cobra.Command, parent, docsDir string) {
0000000000000000000000000000000000000000;;		doc := cmdDoc{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		doc.Name = command.Name()
0000000000000000000000000000000000000000;;		doc.Synopsis = forceMultiLine(command.Short)
0000000000000000000000000000000000000000;;		doc.Description = forceMultiLine(command.Long)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flags := command.NonInheritedFlags()
0000000000000000000000000000000000000000;;		if flags.HasFlags() {
0000000000000000000000000000000000000000;;			doc.Options = genFlagResult(flags)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		flags = command.InheritedFlags()
0000000000000000000000000000000000000000;;		if flags.HasFlags() {
0000000000000000000000000000000000000000;;			doc.InheritedOptions = genFlagResult(flags)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(command.Example) > 0 {
0000000000000000000000000000000000000000;;			doc.Example = command.Example
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(command.Commands()) > 0 || len(parent) > 0 {
0000000000000000000000000000000000000000;;			result := []string{}
0000000000000000000000000000000000000000;;			if len(parent) > 0 {
0000000000000000000000000000000000000000;;				result = append(result, parent)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, c := range command.Commands() {
0000000000000000000000000000000000000000;;				result = append(result, c.Name())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			doc.SeeAlso = result
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		final, err := yaml.Marshal(&doc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Println(err)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var filename string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if parent == "" {
0000000000000000000000000000000000000000;;			filename = docsDir + doc.Name + ".yaml"
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			filename = docsDir + parent + "_" + doc.Name + ".yaml"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		outFile, err := os.Create(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Println(err)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer outFile.Close()
0000000000000000000000000000000000000000;;		_, err = outFile.Write(final)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Println(err)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
