0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
e93f528a2925bb2eb55777605f932d5b57e0aa32;cmd/genman/gen_kubectl_man.go[cmd/genman/gen_kubectl_man.go][cmd/genman/gen_kube_man.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mangen "github.com/cpuguy83/go-md2man/md2man"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;		ccmapp "k8s.io/kubernetes/cmd/cloud-controller-manager/app"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/genutils"
0000000000000000000000000000000000000000;;		apiservapp "k8s.io/kubernetes/cmd/kube-apiserver/app"
0000000000000000000000000000000000000000;;		cmapp "k8s.io/kubernetes/cmd/kube-controller-manager/app"
0000000000000000000000000000000000000000;;		proxyapp "k8s.io/kubernetes/cmd/kube-proxy/app"
0000000000000000000000000000000000000000;;		kubeletapp "k8s.io/kubernetes/cmd/kubelet/app"
0000000000000000000000000000000000000000;;		kubectlcmd "k8s.io/kubernetes/pkg/kubectl/cmd"
0000000000000000000000000000000000000000;;		kubectlcmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		schapp "k8s.io/kubernetes/plugin/cmd/kube-scheduler/app"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		// use os.Args instead of "flags" because "flags" will mess up the man pages!
0000000000000000000000000000000000000000;;		path := "docs/man/man1"
0000000000000000000000000000000000000000;;		module := ""
0000000000000000000000000000000000000000;;		if len(os.Args) == 3 {
0000000000000000000000000000000000000000;;			path = os.Args[1]
0000000000000000000000000000000000000000;;			module = os.Args[2]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "usage: %s [output directory] [module] \n", os.Args[0])
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		outDir, err := genutils.OutDir(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "failed to get output directory: %v\n", err)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set environment variables used by command so the output is consistent,
0000000000000000000000000000000000000000;;		// regardless of where we run.
0000000000000000000000000000000000000000;;		os.Setenv("HOME", "/home/username")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch module {
0000000000000000000000000000000000000000;;		case "kube-apiserver":
0000000000000000000000000000000000000000;;			// generate manpage for kube-apiserver
0000000000000000000000000000000000000000;;			apiserver := apiservapp.NewAPIServerCommand()
0000000000000000000000000000000000000000;;			genMarkdown(apiserver, "", outDir)
0000000000000000000000000000000000000000;;			for _, c := range apiserver.Commands() {
0000000000000000000000000000000000000000;;				genMarkdown(c, "kube-apiserver", outDir)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "kube-controller-manager":
0000000000000000000000000000000000000000;;			// generate manpage for kube-controller-manager
0000000000000000000000000000000000000000;;			controllermanager := cmapp.NewControllerManagerCommand()
0000000000000000000000000000000000000000;;			genMarkdown(controllermanager, "", outDir)
0000000000000000000000000000000000000000;;			for _, c := range controllermanager.Commands() {
0000000000000000000000000000000000000000;;				genMarkdown(c, "kube-controller-manager", outDir)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "cloud-controller-manager":
0000000000000000000000000000000000000000;;			//generate manpage for cloud-controller-manager
0000000000000000000000000000000000000000;;			controllermanager := ccmapp.NewCloudControllerManagerCommand()
0000000000000000000000000000000000000000;;			genMarkdown(controllermanager, "", outDir)
0000000000000000000000000000000000000000;;			for _, c := range controllermanager.Commands() {
0000000000000000000000000000000000000000;;				genMarkdown(c, "cloud-controller-manager", outDir)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "kube-proxy":
0000000000000000000000000000000000000000;;			// generate manpage for kube-proxy
0000000000000000000000000000000000000000;;			proxy := proxyapp.NewProxyCommand()
0000000000000000000000000000000000000000;;			genMarkdown(proxy, "", outDir)
0000000000000000000000000000000000000000;;			for _, c := range proxy.Commands() {
0000000000000000000000000000000000000000;;				genMarkdown(c, "kube-proxy", outDir)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "kube-scheduler":
0000000000000000000000000000000000000000;;			// generate manpage for kube-scheduler
0000000000000000000000000000000000000000;;			scheduler := schapp.NewSchedulerCommand()
0000000000000000000000000000000000000000;;			genMarkdown(scheduler, "", outDir)
0000000000000000000000000000000000000000;;			for _, c := range scheduler.Commands() {
0000000000000000000000000000000000000000;;				genMarkdown(c, "kube-scheduler", outDir)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "kubelet":
0000000000000000000000000000000000000000;;			// generate manpage for kubelet
0000000000000000000000000000000000000000;;			kubelet := kubeletapp.NewKubeletCommand()
0000000000000000000000000000000000000000;;			genMarkdown(kubelet, "", outDir)
0000000000000000000000000000000000000000;;			for _, c := range kubelet.Commands() {
0000000000000000000000000000000000000000;;				genMarkdown(c, "kubelet", outDir)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "kubectl":
0000000000000000000000000000000000000000;;			// generate manpage for kubectl
0000000000000000000000000000000000000000;;			// TODO os.Stdin should really be something like ioutil.Discard, but a Reader
0000000000000000000000000000000000000000;;			kubectl := kubectlcmd.NewKubectlCommand(kubectlcmdutil.NewFactory(nil), os.Stdin, ioutil.Discard, ioutil.Discard)
0000000000000000000000000000000000000000;;			genMarkdown(kubectl, "", outDir)
0000000000000000000000000000000000000000;;			for _, c := range kubectl.Commands() {
0000000000000000000000000000000000000000;;				genMarkdown(c, "kubectl", outDir)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "Module %s is not supported", module)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func preamble(out *bytes.Buffer, name, short, long string) {
0000000000000000000000000000000000000000;;		out.WriteString(`% KUBERNETES(1) kubernetes User Manuals
0000000000000000000000000000000000000000;;	% Eric Paris
0000000000000000000000000000000000000000;;	% Jan 2015
0000000000000000000000000000000000000000;;	# NAME
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;		fmt.Fprintf(out, "%s \\- %s\n\n", name, short)
0000000000000000000000000000000000000000;;		fmt.Fprintf(out, "# SYNOPSIS\n")
0000000000000000000000000000000000000000;;		fmt.Fprintf(out, "**%s** [OPTIONS]\n\n", name)
0000000000000000000000000000000000000000;;		fmt.Fprintf(out, "# DESCRIPTION\n")
0000000000000000000000000000000000000000;;		fmt.Fprintf(out, "%s\n\n", long)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printFlags(out *bytes.Buffer, flags *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		flags.VisitAll(func(flag *pflag.Flag) {
0000000000000000000000000000000000000000;;			format := "**--%s**=%s\n\t%s\n\n"
0000000000000000000000000000000000000000;;			if flag.Value.Type() == "string" {
0000000000000000000000000000000000000000;;				// put quotes on the value
0000000000000000000000000000000000000000;;				format = "**--%s**=%q\n\t%s\n\n"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Todo, when we mark a shorthand is deprecated, but specify an empty message.
0000000000000000000000000000000000000000;;			// The flag.ShorthandDeprecated is empty as the shorthand is deprecated.
0000000000000000000000000000000000000000;;			// Using len(flag.ShorthandDeprecated) > 0 can't handle this, others are ok.
0000000000000000000000000000000000000000;;			if !(len(flag.ShorthandDeprecated) > 0) && len(flag.Shorthand) > 0 {
0000000000000000000000000000000000000000;;				format = "**-%s**, " + format
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, format, flag.Shorthand, flag.Name, flag.DefValue, flag.Usage)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, format, flag.Name, flag.DefValue, flag.Usage)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printOptions(out *bytes.Buffer, command *cobra.Command) {
0000000000000000000000000000000000000000;;		flags := command.NonInheritedFlags()
0000000000000000000000000000000000000000;;		if flags.HasFlags() {
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "# OPTIONS\n")
0000000000000000000000000000000000000000;;			printFlags(out, flags)
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		flags = command.InheritedFlags()
0000000000000000000000000000000000000000;;		if flags.HasFlags() {
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "# OPTIONS INHERITED FROM PARENT COMMANDS\n")
0000000000000000000000000000000000000000;;			printFlags(out, flags)
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genMarkdown(command *cobra.Command, parent, docsDir string) {
0000000000000000000000000000000000000000;;		dparent := strings.Replace(parent, " ", "-", -1)
0000000000000000000000000000000000000000;;		name := command.Name()
0000000000000000000000000000000000000000;;		dname := name
0000000000000000000000000000000000000000;;		if len(parent) > 0 {
0000000000000000000000000000000000000000;;			dname = dparent + "-" + name
0000000000000000000000000000000000000000;;			name = parent + " " + name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		short := command.Short
0000000000000000000000000000000000000000;;		long := command.Long
0000000000000000000000000000000000000000;;		if len(long) == 0 {
0000000000000000000000000000000000000000;;			long = short
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		preamble(out, name, short, long)
0000000000000000000000000000000000000000;;		printOptions(out, command)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(command.Example) > 0 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "# EXAMPLE\n")
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "```\n%s\n```\n", command.Example)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(command.Commands()) > 0 || len(parent) > 0 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "# SEE ALSO\n")
0000000000000000000000000000000000000000;;			if len(parent) > 0 {
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, "**%s(1)**, ", dparent)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, c := range command.Commands() {
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, "**%s-%s(1)**, ", dname, c.Name())
0000000000000000000000000000000000000000;;				genMarkdown(c, name, docsDir)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.WriteString(`
0000000000000000000000000000000000000000;;	# HISTORY
0000000000000000000000000000000000000000;;	January 2015, Originally compiled by Eric Paris (eparis at redhat dot com) based on the kubernetes source material, but hopefully they have been automatically generated since!
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		final := mangen.Render(out.Bytes())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		filename := docsDir + dname + ".1"
0000000000000000000000000000000000000000;;		outFile, err := os.Create(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Println(err)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer outFile.Close()
0000000000000000000000000000000000000000;;		_, err = outFile.Write(final)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Println(err)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
