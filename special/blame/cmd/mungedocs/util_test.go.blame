0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
74d1b05501163df589fe7ccc8bbc01812219e4eb;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_updateMacroBlock(t *testing.T) {
0000000000000000000000000000000000000000;;		token := "TOKEN"
0000000000000000000000000000000000000000;;		BEGIN := beginMungeTag(token)
0000000000000000000000000000000000000000;;		END := endMungeTag(token)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var cases = []struct {
0000000000000000000000000000000000000000;;			in  string
0000000000000000000000000000000000000000;;			out string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"", ""},
0000000000000000000000000000000000000000;;			{"Lorem ipsum\ndolor sit amet\n",
0000000000000000000000000000000000000000;;				"Lorem ipsum\ndolor sit amet\n"},
0000000000000000000000000000000000000000;;			{"Lorem ipsum \n" + BEGIN + "\ndolor\n" + END + "\nsit amet\n",
0000000000000000000000000000000000000000;;				"Lorem ipsum \n" + BEGIN + "\nfoo\n" + END + "\nsit amet\n"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range cases {
0000000000000000000000000000000000000000;;			in := getMungeLines(c.in)
0000000000000000000000000000000000000000;;			expected := getMungeLines(c.out)
0000000000000000000000000000000000000000;;			actual, err := updateMacroBlock(in, token, getMungeLines("foo"))
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;			if !expected.Equal(actual) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected '%v' but got '%v'", expected.String(), expected.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_updateMacroBlock_errors(t *testing.T) {
0000000000000000000000000000000000000000;;		token := "TOKEN"
0000000000000000000000000000000000000000;;		b := beginMungeTag(token)
0000000000000000000000000000000000000000;;		e := endMungeTag(token)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var cases = []struct {
0000000000000000000000000000000000000000;;			in string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{b + "\n"},
0000000000000000000000000000000000000000;;			{"blah\n" + b + "\nblah"},
0000000000000000000000000000000000000000;;			{e + "\n"},
0000000000000000000000000000000000000000;;			{"blah\n" + e + "\nblah\n"},
0000000000000000000000000000000000000000;;			{e + "\n" + b},
0000000000000000000000000000000000000000;;			{b + "\n" + e + "\n" + e},
0000000000000000000000000000000000000000;;			{b + "\n" + b + "\n" + e},
0000000000000000000000000000000000000000;;			{b + "\n" + b + "\n" + e + "\n" + e},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range cases {
0000000000000000000000000000000000000000;;			in := getMungeLines(c.in)
0000000000000000000000000000000000000000;;			_, err := updateMacroBlock(in, token, getMungeLines("foo"))
0000000000000000000000000000000000000000;;			assert.Error(t, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHasLine(t *testing.T) {
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			haystack string
0000000000000000000000000000000000000000;;			needle   string
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"abc\ndef\nghi", "abc", true},
0000000000000000000000000000000000000000;;			{"  abc\ndef\nghi", "abc", true},
0000000000000000000000000000000000000000;;			{"abc  \ndef\nghi", "abc", true},
0000000000000000000000000000000000000000;;			{"\n abc\ndef\nghi", "abc", true},
0000000000000000000000000000000000000000;;			{"abc \n\ndef\nghi", "abc", true},
0000000000000000000000000000000000000000;;			{"abc\ndef\nghi", "def", true},
0000000000000000000000000000000000000000;;			{"abc\ndef\nghi", "ghi", true},
0000000000000000000000000000000000000000;;			{"abc\ndef\nghi", "xyz", false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, c := range cases {
0000000000000000000000000000000000000000;;			in := getMungeLines(c.haystack)
0000000000000000000000000000000000000000;;			if hasLine(in, c.needle) != c.expected {
0000000000000000000000000000000000000000;;				t.Errorf("case[%d]: %q, expected %t, got %t", i, c.needle, c.expected, !c.expected)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHasMacroBlock(t *testing.T) {
0000000000000000000000000000000000000000;;		token := "<<<"
0000000000000000000000000000000000000000;;		b := beginMungeTag(token)
0000000000000000000000000000000000000000;;		e := endMungeTag(token)
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			lines    []string
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{[]string{b, e}, true},
0000000000000000000000000000000000000000;;			{[]string{b, "abc", e}, true},
0000000000000000000000000000000000000000;;			{[]string{b, b, "abc", e}, true},
0000000000000000000000000000000000000000;;			{[]string{b, "abc", e, e}, true},
0000000000000000000000000000000000000000;;			{[]string{b, e, b, e}, true},
0000000000000000000000000000000000000000;;			{[]string{b}, false},
0000000000000000000000000000000000000000;;			{[]string{e}, false},
0000000000000000000000000000000000000000;;			{[]string{b, "abc"}, false},
0000000000000000000000000000000000000000;;			{[]string{"abc", e}, false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, c := range cases {
0000000000000000000000000000000000000000;;			in := getMungeLines(strings.Join(c.lines, "\n"))
0000000000000000000000000000000000000000;;			if hasMacroBlock(in, token) != c.expected {
0000000000000000000000000000000000000000;;				t.Errorf("case[%d]: expected %t, got %t", i, c.expected, !c.expected)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAppendMacroBlock(t *testing.T) {
0000000000000000000000000000000000000000;;		token := "<<<"
0000000000000000000000000000000000000000;;		b := beginMungeTag(token)
0000000000000000000000000000000000000000;;		e := endMungeTag(token)
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			in       []string
0000000000000000000000000000000000000000;;			expected []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{[]string{}, []string{b, e}},
0000000000000000000000000000000000000000;;			{[]string{"bob"}, []string{"bob", "", b, e}},
0000000000000000000000000000000000000000;;			{[]string{b, e}, []string{b, e, "", b, e}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, c := range cases {
0000000000000000000000000000000000000000;;			in := getMungeLines(strings.Join(c.in, "\n"))
0000000000000000000000000000000000000000;;			expected := getMungeLines(strings.Join(c.expected, "\n"))
0000000000000000000000000000000000000000;;			out := appendMacroBlock(in, token)
0000000000000000000000000000000000000000;;			if !out.Equal(expected) {
0000000000000000000000000000000000000000;;				t.Errorf("Case[%d]: expected '%q' but got '%q'", i, expected.String(), out.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPrependMacroBlock(t *testing.T) {
0000000000000000000000000000000000000000;;		token := "<<<"
0000000000000000000000000000000000000000;;		b := beginMungeTag(token)
0000000000000000000000000000000000000000;;		e := endMungeTag(token)
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			in       []string
0000000000000000000000000000000000000000;;			expected []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{[]string{}, []string{b, e}},
0000000000000000000000000000000000000000;;			{[]string{"bob"}, []string{b, e, "", "bob"}},
0000000000000000000000000000000000000000;;			{[]string{b, e}, []string{b, e, "", b, e}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, c := range cases {
0000000000000000000000000000000000000000;;			in := getMungeLines(strings.Join(c.in, "\n"))
0000000000000000000000000000000000000000;;			expected := getMungeLines(strings.Join(c.expected, "\n"))
0000000000000000000000000000000000000000;;			out := prependMacroBlock(token, in)
0000000000000000000000000000000000000000;;			if !out.Equal(expected) {
0000000000000000000000000000000000000000;;				t.Errorf("Case[%d]: expected '%q' but got '%q'", i, expected.String(), out.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
