0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
b619dc23f9a3fa01173352da429939e623eab109;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flag "github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This needs to be updated when we cut a new release series.
0000000000000000000000000000000000000000;;	const latestReleaseBranch = "release-1.5"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		verbose   = flag.Bool("verbose", false, "On verification failure, emit pre-munge and post-munge versions.")
0000000000000000000000000000000000000000;;		verify    = flag.Bool("verify", false, "Exit with status 1 if files would have needed changes but do not change.")
0000000000000000000000000000000000000000;;		norecurse = flag.Bool("norecurse", false, "Only process the files of --root-dir.")
0000000000000000000000000000000000000000;;		upstream  = flag.String("upstream", "upstream", "The name of the upstream Git remote to pull from")
0000000000000000000000000000000000000000;;		rootDir   = flag.String("root-dir", "", "Root directory containing documents to be processed.")
0000000000000000000000000000000000000000;;		// "repo-root" seems like a dumb name, this is the relative path (from rootDir) to get to the repoRoot
0000000000000000000000000000000000000000;;		relRoot = flag.String("repo-root", "..", `Appended to --root-dir to get the repository root.
0000000000000000000000000000000000000000;;	It's done this way so that generally you just have to set --root-dir.
0000000000000000000000000000000000000000;;	Examples:
0000000000000000000000000000000000000000;;	 * --root-dir=docs/ --repo-root=.. means the repository root is ./
0000000000000000000000000000000000000000;;	 * --root-dir=/usr/local/long/path/repo/docs/ --repo-root=.. means the repository root is /usr/local/long/path/repo/
0000000000000000000000000000000000000000;;	 * --root-dir=/usr/local/long/path/repo/docs/admin --repo-root=../.. means the repository root is /usr/local/long/path/repo/`)
0000000000000000000000000000000000000000;;		skipMunges = flag.String("skip-munges", "", "Comma-separated list of munges to *not* run. Available munges are: "+availableMungeList)
0000000000000000000000000000000000000000;;		repoRoot   string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ErrChangesNeeded = errors.New("mungedocs: changes required")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// All of the munge operations to perform.
0000000000000000000000000000000000000000;;		// TODO: allow selection from command line. (e.g., just check links in the examples directory.)
0000000000000000000000000000000000000000;;		allMunges = []munge{
0000000000000000000000000000000000000000;;			// Simple "check something" functions must run first.
0000000000000000000000000000000000000000;;			{"preformat-balance", checkPreformatBalance},
0000000000000000000000000000000000000000;;			// Functions which modify state.
0000000000000000000000000000000000000000;;			{"remove-whitespace", updateWhitespace},
0000000000000000000000000000000000000000;;			{"table-of-contents", updateTOC},
0000000000000000000000000000000000000000;;			{"md-links", updateLinks},
0000000000000000000000000000000000000000;;			{"blank-lines-surround-preformatted", updatePreformatted},
0000000000000000000000000000000000000000;;			{"header-lines", updateHeaderLines},
0000000000000000000000000000000000000000;;			{"analytics", updateAnalytics},
0000000000000000000000000000000000000000;;			{"kubectl-dash-f", updateKubectlFileTargets},
0000000000000000000000000000000000000000;;			{"sync-examples", syncExamples},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		availableMungeList = func() string {
0000000000000000000000000000000000000000;;			names := []string{}
0000000000000000000000000000000000000000;;			for _, m := range allMunges {
0000000000000000000000000000000000000000;;				names = append(names, m.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return strings.Join(names, ",")
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// a munge processes a document, returning an updated document xor an error.
0000000000000000000000000000000000000000;;	// The fn is NOT allowed to mutate 'before', if changes are needed it must copy
0000000000000000000000000000000000000000;;	// data into a new byte array and return that.
0000000000000000000000000000000000000000;;	type munge struct {
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;		fn   func(filePath string, mlines mungeLines) (after mungeLines, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fileProcessor struct {
0000000000000000000000000000000000000000;;		// Which munge functions should we call?
0000000000000000000000000000000000000000;;		munges []munge
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Are we allowed to make changes?
0000000000000000000000000000000000000000;;		verifyOnly bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Either change a file or verify that it needs no changes (according to modify argument)
0000000000000000000000000000000000000000;;	func (f fileProcessor) visit(path string) error {
0000000000000000000000000000000000000000;;		if !strings.HasSuffix(path, ".md") {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fileBytes, err := ioutil.ReadFile(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mungeLines := getMungeLines(string(fileBytes))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		modificationsMade := false
0000000000000000000000000000000000000000;;		errFound := false
0000000000000000000000000000000000000000;;		filePrinted := false
0000000000000000000000000000000000000000;;		for _, munge := range f.munges {
0000000000000000000000000000000000000000;;			after, err := munge.fn(path, mungeLines)
0000000000000000000000000000000000000000;;			if err != nil || !after.Equal(mungeLines) {
0000000000000000000000000000000000000000;;				if !filePrinted {
0000000000000000000000000000000000000000;;					fmt.Printf("%s\n----\n", path)
0000000000000000000000000000000000000000;;					filePrinted = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Printf("%s:\n", munge.name)
0000000000000000000000000000000000000000;;				if *verbose {
0000000000000000000000000000000000000000;;					if len(mungeLines) <= 20 {
0000000000000000000000000000000000000000;;						fmt.Printf("INPUT: <<<%v>>>\n", mungeLines)
0000000000000000000000000000000000000000;;						fmt.Printf("MUNGED: <<<%v>>>\n", after)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						fmt.Printf("not printing failed chunk: too many lines\n")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					fmt.Println(err)
0000000000000000000000000000000000000000;;					errFound = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fmt.Println("contents were modified")
0000000000000000000000000000000000000000;;					modificationsMade = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Println("")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mungeLines = after
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write out new file with any changes.
0000000000000000000000000000000000000000;;		if modificationsMade {
0000000000000000000000000000000000000000;;			if f.verifyOnly {
0000000000000000000000000000000000000000;;				// We're not allowed to make changes.
0000000000000000000000000000000000000000;;				return ErrChangesNeeded
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ioutil.WriteFile(path, mungeLines.Bytes(), 0644)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if errFound {
0000000000000000000000000000000000000000;;			return ErrChangesNeeded
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newWalkFunc(fp *fileProcessor, changesNeeded *bool) filepath.WalkFunc {
0000000000000000000000000000000000000000;;		return func(path string, info os.FileInfo, err error) error {
0000000000000000000000000000000000000000;;			stat, err := os.Stat(path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if path != *rootDir && stat.IsDir() && *norecurse {
0000000000000000000000000000000000000000;;				return filepath.SkipDir
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := fp.visit(path); err != nil {
0000000000000000000000000000000000000000;;				*changesNeeded = true
0000000000000000000000000000000000000000;;				if err != ErrChangesNeeded {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func wantedMunges() (filtered []munge) {
0000000000000000000000000000000000000000;;		skipList := strings.Split(*skipMunges, ",")
0000000000000000000000000000000000000000;;		skipped := map[string]bool{}
0000000000000000000000000000000000000000;;		for _, m := range skipList {
0000000000000000000000000000000000000000;;			if len(m) > 0 {
0000000000000000000000000000000000000000;;				skipped[m] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, m := range allMunges {
0000000000000000000000000000000000000000;;			if !skipped[m.name] {
0000000000000000000000000000000000000000;;				filtered = append(filtered, m)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Remove from the map so we can verify that everything
0000000000000000000000000000000000000000;;				// requested was in fact valid.
0000000000000000000000000000000000000000;;				delete(skipped, m.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(skipped) != 0 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "ERROR: requested to skip %v, but these are not valid munges. (valid: %v)\n", skipped, availableMungeList)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filtered
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if *rootDir == "" {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "usage: %s [--help] [--verify] [--norecurse] --root-dir [--skip-munges=<skip list>] [--upstream=<git remote>] <docs root>\n", flag.Arg(0))
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		repoRoot = path.Join(*rootDir, *relRoot)
0000000000000000000000000000000000000000;;		repoRoot, err = filepath.Abs(repoRoot)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "ERROR: %v\n", err)
0000000000000000000000000000000000000000;;			os.Exit(2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fp := fileProcessor{
0000000000000000000000000000000000000000;;			munges:     wantedMunges(),
0000000000000000000000000000000000000000;;			verifyOnly: *verify,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For each markdown file under source docs root, process the doc.
0000000000000000000000000000000000000000;;		// - If any error occurs: exit with failure (exit >1).
0000000000000000000000000000000000000000;;		// - If verify is true: exit 0 if no changes needed, exit 1 if changes
0000000000000000000000000000000000000000;;		//   needed.
0000000000000000000000000000000000000000;;		// - If verify is false: exit 0 if changes successfully made or no
0000000000000000000000000000000000000000;;		//   changes needed, exit 1 if manual changes are needed.
0000000000000000000000000000000000000000;;		var changesNeeded bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = filepath.Walk(*rootDir, newWalkFunc(&fp, &changesNeeded))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "ERROR: %v\n", err)
0000000000000000000000000000000000000000;;			os.Exit(2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if changesNeeded {
0000000000000000000000000000000000000000;;			if *verify {
0000000000000000000000000000000000000000;;				fmt.Fprintf(os.Stderr, "FAIL: changes needed but not made due to --verify\n")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fmt.Fprintf(os.Stderr, "FAIL: some manual changes are still required.\n")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
