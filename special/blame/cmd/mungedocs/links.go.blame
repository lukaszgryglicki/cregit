0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
81587c0d3267c96d0dc3ada86cc4b069d261a100;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Finds markdown links of the form [foo](bar "alt-text").
0000000000000000000000000000000000000000;;		linkRE = regexp.MustCompile(`\[([^]]*)\]\(([^)]*)\)`)
0000000000000000000000000000000000000000;;		// Finds markdown link typos of the form (foo)[bar]
0000000000000000000000000000000000000000;;		badLinkRE = regexp.MustCompile(`\([^]()]*\)\[[^]()]*\]`)
0000000000000000000000000000000000000000;;		// Splits the link target into link target and alt-text.
0000000000000000000000000000000000000000;;		altTextRE = regexp.MustCompile(`([^)]*)( ".*")`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func processLink(in string, filePath string) (string, error) {
0000000000000000000000000000000000000000;;		var errs []string
0000000000000000000000000000000000000000;;		out := linkRE.ReplaceAllStringFunc(in, func(in string) string {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			match := linkRE.FindStringSubmatch(in)
0000000000000000000000000000000000000000;;			if match == nil {
0000000000000000000000000000000000000000;;				errs = append(errs, fmt.Sprintf("Detected this line had a link, but unable to parse, %v", in))
0000000000000000000000000000000000000000;;				return ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// match[0] is the entire expression;
0000000000000000000000000000000000000000;;			visibleText := match[1]
0000000000000000000000000000000000000000;;			linkText := match[2]
0000000000000000000000000000000000000000;;			altText := ""
0000000000000000000000000000000000000000;;			if parts := altTextRE.FindStringSubmatch(linkText); parts != nil {
0000000000000000000000000000000000000000;;				linkText = parts[1]
0000000000000000000000000000000000000000;;				altText = parts[2]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// clean up some random garbage I found in our docs.
0000000000000000000000000000000000000000;;			linkText = strings.Trim(linkText, " ")
0000000000000000000000000000000000000000;;			linkText = strings.Trim(linkText, "\n")
0000000000000000000000000000000000000000;;			linkText = strings.Trim(linkText, " ")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			u, terr := url.Parse(linkText)
0000000000000000000000000000000000000000;;			if terr != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, fmt.Sprintf("link %q is unparsable: %v", linkText, terr))
0000000000000000000000000000000000000000;;				return in
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if u.Host != "" && u.Host != "github.com" {
0000000000000000000000000000000000000000;;				// We only care about relative links and links within github.
0000000000000000000000000000000000000000;;				return in
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			suggestedVisibleText := visibleText
0000000000000000000000000000000000000000;;			if u.Path != "" && !strings.HasPrefix(linkText, "TODO:") {
0000000000000000000000000000000000000000;;				newPath, targetExists := checkPath(filePath, path.Clean(u.Path))
0000000000000000000000000000000000000000;;				if !targetExists {
0000000000000000000000000000000000000000;;					errs = append(errs, fmt.Sprintf("%q: target not found", linkText))
0000000000000000000000000000000000000000;;					return in
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				u.Path = newPath
0000000000000000000000000000000000000000;;				if strings.HasPrefix(u.Path, "/") {
0000000000000000000000000000000000000000;;					u.Host = "github.com"
0000000000000000000000000000000000000000;;					u.Scheme = "https"
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Remove host and scheme from relative paths
0000000000000000000000000000000000000000;;					u.Host = ""
0000000000000000000000000000000000000000;;					u.Scheme = ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Make the visible text show the absolute path if it's
0000000000000000000000000000000000000000;;				// not nested in or beneath the current directory.
0000000000000000000000000000000000000000;;				if strings.HasPrefix(u.Path, "..") {
0000000000000000000000000000000000000000;;					dir := path.Dir(filePath)
0000000000000000000000000000000000000000;;					suggestedVisibleText, err = makeRepoRelative(path.Join(dir, u.Path), filePath)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						errs = append(errs, fmt.Sprintf("%q: unable to make path relative", filePath))
0000000000000000000000000000000000000000;;						return in
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					suggestedVisibleText = u.Path
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				var unescaped string
0000000000000000000000000000000000000000;;				if unescaped, err = url.QueryUnescape(u.String()); err != nil {
0000000000000000000000000000000000000000;;					// Remove %28 type stuff, be nice to humans.
0000000000000000000000000000000000000000;;					// And don't fight with the toc generator.
0000000000000000000000000000000000000000;;					linkText = unescaped
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					linkText = u.String()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If the current visible text is trying to be a file name, use
0000000000000000000000000000000000000000;;			// the correct file name.
0000000000000000000000000000000000000000;;			if strings.HasSuffix(visibleText, ".md") && !strings.ContainsAny(visibleText, ` '"`+"`") {
0000000000000000000000000000000000000000;;				visibleText = suggestedVisibleText
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return fmt.Sprintf("[%s](%s)", visibleText, linkText+altText)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if len(errs) != 0 {
0000000000000000000000000000000000000000;;			return "", errors.New(strings.Join(errs, ","))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateLinks assumes lines has links in markdown syntax, and verifies that
0000000000000000000000000000000000000000;;	// any relative links actually point to files that exist.
0000000000000000000000000000000000000000;;	func updateLinks(filePath string, mlines mungeLines) (mungeLines, error) {
0000000000000000000000000000000000000000;;		var out mungeLines
0000000000000000000000000000000000000000;;		allErrs := []string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for lineNum, mline := range mlines {
0000000000000000000000000000000000000000;;			if mline.preformatted {
0000000000000000000000000000000000000000;;				out = append(out, mline)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if badMatch := badLinkRE.FindString(mline.data); badMatch != "" {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs,
0000000000000000000000000000000000000000;;					fmt.Sprintf("On line %d: found backwards markdown link %q", lineNum, badMatch))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !mline.link {
0000000000000000000000000000000000000000;;				out = append(out, mline)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			line, err := processLink(mline.data, filePath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				var s = fmt.Sprintf("On line %d: %s", lineNum, err.Error())
0000000000000000000000000000000000000000;;				err := errors.New(s)
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ml := newMungeLine(line)
0000000000000000000000000000000000000000;;			out = append(out, ml)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := error(nil)
0000000000000000000000000000000000000000;;		if len(allErrs) != 0 {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("%s", strings.Join(allErrs, "\n"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// We have to append together before path.Clean will be able to tell that stuff
0000000000000000000000000000000000000000;;	// like ../docs isn't needed.
0000000000000000000000000000000000000000;;	func cleanPath(dirPath, linkPath string) string {
0000000000000000000000000000000000000000;;		clean := path.Clean(path.Join(dirPath, linkPath))
0000000000000000000000000000000000000000;;		if strings.HasPrefix(clean, dirPath+"/") {
0000000000000000000000000000000000000000;;			out := strings.TrimPrefix(clean, dirPath+"/")
0000000000000000000000000000000000000000;;			if out != linkPath {
0000000000000000000000000000000000000000;;				fmt.Printf("%s -> %s\n", linkPath, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return linkPath
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkPath(filePath, linkPath string) (newPath string, ok bool) {
0000000000000000000000000000000000000000;;		dir := path.Dir(filePath)
0000000000000000000000000000000000000000;;		absFilePrefixes := []string{
0000000000000000000000000000000000000000;;			"/kubernetes/kubernetes/blob/master/",
0000000000000000000000000000000000000000;;			"/kubernetes/kubernetes/tree/master/",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, prefix := range absFilePrefixes {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(linkPath, prefix) {
0000000000000000000000000000000000000000;;				linkPath = strings.TrimPrefix(linkPath, prefix)
0000000000000000000000000000000000000000;;				// Now linkPath is relative to the root of the repo. The below
0000000000000000000000000000000000000000;;				// loop that adds ../ at the beginning of the path should find
0000000000000000000000000000000000000000;;				// the right path.
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasPrefix(linkPath, "/") {
0000000000000000000000000000000000000000;;			// These links might go to e.g. the github issues page, or a
0000000000000000000000000000000000000000;;			// file at a particular revision, or another github project
0000000000000000000000000000000000000000;;			// entirely.
0000000000000000000000000000000000000000;;			return linkPath, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		linkPath = cleanPath(dir, linkPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fast exit if the link is already correct.
0000000000000000000000000000000000000000;;		if info, err := os.Stat(path.Join(dir, linkPath)); err == nil {
0000000000000000000000000000000000000000;;			if info.IsDir() {
0000000000000000000000000000000000000000;;				return linkPath + "/", true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return linkPath, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for strings.HasPrefix(linkPath, "../") {
0000000000000000000000000000000000000000;;			linkPath = strings.TrimPrefix(linkPath, "../")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fix - vs _ automatically
0000000000000000000000000000000000000000;;		nameMungers := []func(string) string{
0000000000000000000000000000000000000000;;			func(s string) string { return s },
0000000000000000000000000000000000000000;;			func(s string) string { return strings.Replace(s, "-", "_", -1) },
0000000000000000000000000000000000000000;;			func(s string) string { return strings.Replace(s, "_", "-", -1) },
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Fix being moved into/out of admin (replace "admin" with directory
0000000000000000000000000000000000000000;;		// you're doing mass movements to/from).
0000000000000000000000000000000000000000;;		pathMungers := []func(string) string{
0000000000000000000000000000000000000000;;			func(s string) string { return s },
0000000000000000000000000000000000000000;;			func(s string) string { return path.Join("admin", s) },
0000000000000000000000000000000000000000;;			func(s string) string { return strings.TrimPrefix(s, "admin/") },
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, namer := range nameMungers {
0000000000000000000000000000000000000000;;			for _, pather := range pathMungers {
0000000000000000000000000000000000000000;;				newPath = pather(namer(linkPath))
0000000000000000000000000000000000000000;;				for i := 0; i < 7; i++ {
0000000000000000000000000000000000000000;;					// The file must exist.
0000000000000000000000000000000000000000;;					target := path.Join(dir, newPath)
0000000000000000000000000000000000000000;;					if info, err := os.Stat(target); err == nil {
0000000000000000000000000000000000000000;;						if info.IsDir() {
0000000000000000000000000000000000000000;;							return newPath + "/", true
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return cleanPath(dir, newPath), true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					newPath = path.Join("..", newPath)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return linkPath, false
0000000000000000000000000000000000000000;;	}
