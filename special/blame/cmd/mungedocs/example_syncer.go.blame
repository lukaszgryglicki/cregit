0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
204af8c0e4b0977a80c9ff15c7c33a23e60f75af;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const exampleToken = "EXAMPLE"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const exampleLineStart = "<!-- BEGIN MUNGE: EXAMPLE"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var exampleMungeTagRE = regexp.MustCompile(beginMungeTag(fmt.Sprintf("%s %s", exampleToken, `(([^ ])*[.]([^.]*))`)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncExamples updates all examples in markdown file.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Finds the magic macro block tags, find the link to the example
0000000000000000000000000000000000000000;;	// specified in the tags, and replaces anything between those with
0000000000000000000000000000000000000000;;	// the content of the example, thereby syncing it.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For example,
0000000000000000000000000000000000000000;;	// <!-- BEGIN MUNGE: EXAMPLE ../../examples/guestbook/frontend-service.yaml -->
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// ```yaml
0000000000000000000000000000000000000000;;	// foo:
0000000000000000000000000000000000000000;;	//    bar:
0000000000000000000000000000000000000000;;	// ```
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// [Download example](../../examples/guestbook/frontend-service.yaml?raw=true)
0000000000000000000000000000000000000000;;	// <!-- END MUNGE: EXAMPLE -->
0000000000000000000000000000000000000000;;	func syncExamples(filePath string, mlines mungeLines) (mungeLines, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		type exampleTag struct {
0000000000000000000000000000000000000000;;			token    string
0000000000000000000000000000000000000000;;			linkText string
0000000000000000000000000000000000000000;;			fileType string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		exampleTags := []exampleTag{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// collect all example Tags
0000000000000000000000000000000000000000;;		for _, mline := range mlines {
0000000000000000000000000000000000000000;;			if mline.preformatted || !mline.beginTag {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			line := mline.data
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(line, exampleLineStart) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			match := exampleMungeTagRE.FindStringSubmatch(line)
0000000000000000000000000000000000000000;;			if len(match) < 4 {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("Found unparsable EXAMPLE munge line %v", line)
0000000000000000000000000000000000000000;;				return mlines, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tag := exampleTag{
0000000000000000000000000000000000000000;;				token:    exampleToken + " " + match[1],
0000000000000000000000000000000000000000;;				linkText: match[1],
0000000000000000000000000000000000000000;;				fileType: match[3],
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			exampleTags = append(exampleTags, tag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// update all example Tags
0000000000000000000000000000000000000000;;		for _, tag := range exampleTags {
0000000000000000000000000000000000000000;;			ft := ""
0000000000000000000000000000000000000000;;			if tag.fileType == "json" {
0000000000000000000000000000000000000000;;				ft = "json"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tag.fileType == "yaml" {
0000000000000000000000000000000000000000;;				ft = "yaml"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			example, err := exampleContent(filePath, tag.linkText, ft)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return mlines, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mlines, err = updateMacroBlock(mlines, tag.token, example)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return mlines, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mlines, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// exampleContent retrieves the content of the file at linkPath
0000000000000000000000000000000000000000;;	func exampleContent(filePath, linkPath, fileType string) (mungeLines, error) {
0000000000000000000000000000000000000000;;		repoRel, err := makeRepoRelative(linkPath, filePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fileRel, err := makeFileRelative(linkPath, filePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dat, err := ioutil.ReadFile(repoRel)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// remove leading and trailing spaces and newlines
0000000000000000000000000000000000000000;;		trimmedFileContent := strings.TrimSpace(string(dat))
0000000000000000000000000000000000000000;;		content := fmt.Sprintf("\n```%s\n%s\n```\n\n[Download example](%s?raw=true)", fileType, trimmedFileContent, fileRel)
0000000000000000000000000000000000000000;;		out := getMungeLines(content)
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
