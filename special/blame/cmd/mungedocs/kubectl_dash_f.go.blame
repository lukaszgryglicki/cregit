0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
39447deaf339382facfc4543d73db4264b1dcbb9;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Looks for lines that have kubectl commands with -f flags and files that
0000000000000000000000000000000000000000;;	// don't exist.
0000000000000000000000000000000000000000;;	func updateKubectlFileTargets(file string, mlines mungeLines) (mungeLines, error) {
0000000000000000000000000000000000000000;;		var errors []string
0000000000000000000000000000000000000000;;		for i, mline := range mlines {
0000000000000000000000000000000000000000;;			if !mline.preformatted {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := lookForKubectl(mline.data, i); err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := error(nil)
0000000000000000000000000000000000000000;;		if len(errors) != 0 {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("%s", strings.Join(errors, "\n"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mlines, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lookForKubectl(line string, lineNum int) error {
0000000000000000000000000000000000000000;;		fields := strings.Fields(line)
0000000000000000000000000000000000000000;;		for i := range fields {
0000000000000000000000000000000000000000;;			if fields[i] == "kubectl" {
0000000000000000000000000000000000000000;;				return gotKubectl(lineNum, fields, i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func gotKubectl(lineNum int, fields []string, fieldNum int) error {
0000000000000000000000000000000000000000;;		for i := fieldNum + 1; i < len(fields); i++ {
0000000000000000000000000000000000000000;;			switch fields[i] {
0000000000000000000000000000000000000000;;			case "create", "update", "replace", "delete":
0000000000000000000000000000000000000000;;				return gotCommand(lineNum, fields, i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func gotCommand(lineNum int, fields []string, fieldNum int) error {
0000000000000000000000000000000000000000;;		for i := fieldNum + 1; i < len(fields); i++ {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(fields[i], "-f") {
0000000000000000000000000000000000000000;;				return gotDashF(lineNum, fields, i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func gotDashF(lineNum int, fields []string, fieldNum int) error {
0000000000000000000000000000000000000000;;		target := ""
0000000000000000000000000000000000000000;;		if fields[fieldNum] == "-f" {
0000000000000000000000000000000000000000;;			if fieldNum+1 == len(fields) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("ran out of fields after '-f'")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			target = fields[fieldNum+1]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			target = fields[fieldNum][2:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Turn dirs into file-like names.
0000000000000000000000000000000000000000;;		target = strings.TrimRight(target, "/")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now exclude special-cases
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if target == "-" || target == "FILENAME" {
0000000000000000000000000000000000000000;;			// stdin and "FILENAME" are OK
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasPrefix(target, "http://") || strings.HasPrefix(target, "https://") {
0000000000000000000000000000000000000000;;			// URLs are ok
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasPrefix(target, "./") {
0000000000000000000000000000000000000000;;			// Same-dir files are usually created in the same example
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasPrefix(target, "~/") {
0000000000000000000000000000000000000000;;			// Home directory may also be created by the same example
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasPrefix(target, "/") {
0000000000000000000000000000000000000000;;			// Absolute paths tend to be /tmp/* and created in the same example.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasPrefix(target, "$") {
0000000000000000000000000000000000000000;;			// Allow the start of the target to be an environment
0000000000000000000000000000000000000000;;			// variable that points to the root of the kubernetes
0000000000000000000000000000000000000000;;			// repo.
0000000000000000000000000000000000000000;;			split := strings.SplitN(target, "/", 2)
0000000000000000000000000000000000000000;;			if len(split) == 2 {
0000000000000000000000000000000000000000;;				target = split[1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we got here we expect the file to exist.
0000000000000000000000000000000000000000;;		_, err := os.Stat(path.Join(repoRoot, target))
0000000000000000000000000000000000000000;;		if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%d: target file %q does not exist", lineNum, target)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
