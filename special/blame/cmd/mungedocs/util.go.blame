0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
74d1b05501163df589fe7ccc8bbc01812219e4eb;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Replaces the text between matching "beginMark" and "endMark" within the
0000000000000000000000000000000000000000;;	// document represented by "lines" with "insertThis".
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Delimiters should occupy own line.
0000000000000000000000000000000000000000;;	// Returns copy of document with modifications.
0000000000000000000000000000000000000000;;	func updateMacroBlock(mlines mungeLines, token string, insertThis mungeLines) (mungeLines, error) {
0000000000000000000000000000000000000000;;		beginMark := beginMungeTag(token)
0000000000000000000000000000000000000000;;		endMark := endMungeTag(token)
0000000000000000000000000000000000000000;;		var out mungeLines
0000000000000000000000000000000000000000;;		betweenBeginAndEnd := false
0000000000000000000000000000000000000000;;		for _, mline := range mlines {
0000000000000000000000000000000000000000;;			if mline.preformatted && !betweenBeginAndEnd {
0000000000000000000000000000000000000000;;				out = append(out, mline)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			line := mline.data
0000000000000000000000000000000000000000;;			if mline.beginTag && line == beginMark {
0000000000000000000000000000000000000000;;				if betweenBeginAndEnd {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("found second begin mark while updating macro blocks")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				betweenBeginAndEnd = true
0000000000000000000000000000000000000000;;				out = append(out, mline)
0000000000000000000000000000000000000000;;			} else if mline.endTag && line == endMark {
0000000000000000000000000000000000000000;;				if !betweenBeginAndEnd {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("found end mark without begin mark while updating macro blocks")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				betweenBeginAndEnd = false
0000000000000000000000000000000000000000;;				out = append(out, insertThis...)
0000000000000000000000000000000000000000;;				out = append(out, mline)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if !betweenBeginAndEnd {
0000000000000000000000000000000000000000;;					out = append(out, mline)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if betweenBeginAndEnd {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("never found closing end mark while updating macro blocks")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tests that a document, represented as a slice of lines, has a line.  Ignores
0000000000000000000000000000000000000000;;	// leading and trailing space.
0000000000000000000000000000000000000000;;	func hasLine(lines mungeLines, needle string) bool {
0000000000000000000000000000000000000000;;		for _, mline := range lines {
0000000000000000000000000000000000000000;;			haystack := strings.TrimSpace(mline.data)
0000000000000000000000000000000000000000;;			if haystack == needle {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func removeMacroBlock(token string, mlines mungeLines) (mungeLines, error) {
0000000000000000000000000000000000000000;;		beginMark := beginMungeTag(token)
0000000000000000000000000000000000000000;;		endMark := endMungeTag(token)
0000000000000000000000000000000000000000;;		var out mungeLines
0000000000000000000000000000000000000000;;		betweenBeginAndEnd := false
0000000000000000000000000000000000000000;;		for _, mline := range mlines {
0000000000000000000000000000000000000000;;			if mline.preformatted {
0000000000000000000000000000000000000000;;				out = append(out, mline)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			line := mline.data
0000000000000000000000000000000000000000;;			if mline.beginTag && line == beginMark {
0000000000000000000000000000000000000000;;				if betweenBeginAndEnd {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("found second begin mark while updating macro blocks")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				betweenBeginAndEnd = true
0000000000000000000000000000000000000000;;			} else if mline.endTag && line == endMark {
0000000000000000000000000000000000000000;;				if !betweenBeginAndEnd {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("found end mark without begin mark while updating macro blocks")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				betweenBeginAndEnd = false
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if !betweenBeginAndEnd {
0000000000000000000000000000000000000000;;					out = append(out, mline)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if betweenBeginAndEnd {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("never found closing end mark while updating macro blocks")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add a macro block to the beginning of a set of lines
0000000000000000000000000000000000000000;;	func prependMacroBlock(token string, mlines mungeLines) mungeLines {
0000000000000000000000000000000000000000;;		beginLine := newMungeLine(beginMungeTag(token))
0000000000000000000000000000000000000000;;		endLine := newMungeLine(endMungeTag(token))
0000000000000000000000000000000000000000;;		out := mungeLines{beginLine, endLine}
0000000000000000000000000000000000000000;;		if len(mlines) > 0 && mlines[0].data != "" {
0000000000000000000000000000000000000000;;			out = append(out, blankMungeLine)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return append(out, mlines...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add a macro block to the end of a set of lines
0000000000000000000000000000000000000000;;	func appendMacroBlock(mlines mungeLines, token string) mungeLines {
0000000000000000000000000000000000000000;;		beginLine := newMungeLine(beginMungeTag(token))
0000000000000000000000000000000000000000;;		endLine := newMungeLine(endMungeTag(token))
0000000000000000000000000000000000000000;;		out := mlines
0000000000000000000000000000000000000000;;		if len(mlines) > 0 && mlines[len(mlines)-1].data != "" {
0000000000000000000000000000000000000000;;			out = append(out, blankMungeLine)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return append(out, beginLine, endLine)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tests that a document, represented as a slice of lines, has a macro block.
0000000000000000000000000000000000000000;;	func hasMacroBlock(lines mungeLines, token string) bool {
0000000000000000000000000000000000000000;;		beginMark := beginMungeTag(token)
0000000000000000000000000000000000000000;;		endMark := endMungeTag(token)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foundBegin := false
0000000000000000000000000000000000000000;;		for _, mline := range lines {
0000000000000000000000000000000000000000;;			if mline.preformatted {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !mline.beginTag && !mline.endTag {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			line := mline.data
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case !foundBegin && line == beginMark:
0000000000000000000000000000000000000000;;				foundBegin = true
0000000000000000000000000000000000000000;;			case foundBegin && line == endMark:
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the canonical begin-tag for a given description.  This does not
0000000000000000000000000000000000000000;;	// include the trailing newline.
0000000000000000000000000000000000000000;;	func beginMungeTag(desc string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("<!-- BEGIN MUNGE: %s -->", desc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the canonical end-tag for a given description.  This does not
0000000000000000000000000000000000000000;;	// include the trailing newline.
0000000000000000000000000000000000000000;;	func endMungeTag(desc string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("<!-- END MUNGE: %s -->", desc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mungeLine struct {
0000000000000000000000000000000000000000;;		data         string
0000000000000000000000000000000000000000;;		preformatted bool
0000000000000000000000000000000000000000;;		header       bool
0000000000000000000000000000000000000000;;		link         bool
0000000000000000000000000000000000000000;;		beginTag     bool
0000000000000000000000000000000000000000;;		endTag       bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mungeLines []mungeLine
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m1 mungeLines) Equal(m2 mungeLines) bool {
0000000000000000000000000000000000000000;;		if len(m1) != len(m2) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range m1 {
0000000000000000000000000000000000000000;;			if m1[i].data != m2[i].data {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (mlines mungeLines) String() string {
0000000000000000000000000000000000000000;;		slice := []string{}
0000000000000000000000000000000000000000;;		for _, mline := range mlines {
0000000000000000000000000000000000000000;;			slice = append(slice, mline.data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := strings.Join(slice, "\n")
0000000000000000000000000000000000000000;;		// We need to tack on an extra newline at the end of the file
0000000000000000000000000000000000000000;;		return s + "\n"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (mlines mungeLines) Bytes() []byte {
0000000000000000000000000000000000000000;;		return []byte(mlines.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Finds all preformatted block start/stops.
0000000000000000000000000000000000000000;;		preformatRE    = regexp.MustCompile("^\\s*```")
0000000000000000000000000000000000000000;;		notPreformatRE = regexp.MustCompile("^\\s*```.*```")
0000000000000000000000000000000000000000;;		// Is this line a header?
0000000000000000000000000000000000000000;;		mlHeaderRE = regexp.MustCompile(`^#`)
0000000000000000000000000000000000000000;;		// Is there a link on this line?
0000000000000000000000000000000000000000;;		mlLinkRE   = regexp.MustCompile(`\[[^]]*\]\([^)]*\)`)
0000000000000000000000000000000000000000;;		beginTagRE = regexp.MustCompile(`<!-- BEGIN MUNGE:`)
0000000000000000000000000000000000000000;;		endTagRE   = regexp.MustCompile(`<!-- END MUNGE:`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		blankMungeLine = newMungeLine("")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Does not set 'preformatted'
0000000000000000000000000000000000000000;;	func newMungeLine(line string) mungeLine {
0000000000000000000000000000000000000000;;		return mungeLine{
0000000000000000000000000000000000000000;;			data:     line,
0000000000000000000000000000000000000000;;			header:   mlHeaderRE.MatchString(line),
0000000000000000000000000000000000000000;;			link:     mlLinkRE.MatchString(line),
0000000000000000000000000000000000000000;;			beginTag: beginTagRE.MatchString(line),
0000000000000000000000000000000000000000;;			endTag:   endTagRE.MatchString(line),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func trimRightSpace(in string) string {
0000000000000000000000000000000000000000;;		return strings.TrimRightFunc(in, unicode.IsSpace)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Splits a document up into a slice of lines.
0000000000000000000000000000000000000000;;	func splitLines(document string) []string {
0000000000000000000000000000000000000000;;		lines := strings.Split(document, "\n")
0000000000000000000000000000000000000000;;		// Skip trailing empty string from Split-ing
0000000000000000000000000000000000000000;;		if len(lines) > 0 && lines[len(lines)-1] == "" {
0000000000000000000000000000000000000000;;			lines = lines[:len(lines)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return lines
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getMungeLines(in string) mungeLines {
0000000000000000000000000000000000000000;;		var out mungeLines
0000000000000000000000000000000000000000;;		preformatted := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lines := splitLines(in)
0000000000000000000000000000000000000000;;		// We indicate if any given line is inside a preformatted block or
0000000000000000000000000000000000000000;;		// outside a preformatted block
0000000000000000000000000000000000000000;;		for _, line := range lines {
0000000000000000000000000000000000000000;;			if !preformatted {
0000000000000000000000000000000000000000;;				if preformatRE.MatchString(line) && !notPreformatRE.MatchString(line) {
0000000000000000000000000000000000000000;;					preformatted = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if preformatRE.MatchString(line) {
0000000000000000000000000000000000000000;;					preformatted = false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ml := newMungeLine(line)
0000000000000000000000000000000000000000;;			ml.preformatted = preformatted
0000000000000000000000000000000000000000;;			out = append(out, ml)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// filePath is the file we are looking for
0000000000000000000000000000000000000000;;	// inFile is the file where we found the link. So if we are processing
0000000000000000000000000000000000000000;;	//    /path/to/repoRoot/docs/admin/README.md and are looking for
0000000000000000000000000000000000000000;;	//    ../../file.json we can find that location.
0000000000000000000000000000000000000000;;	// In many cases filePath and processingFile may be the same
0000000000000000000000000000000000000000;;	func makeRepoRelative(filePath string, processingFile string) (string, error) {
0000000000000000000000000000000000000000;;		if filePath, err := filepath.Rel(repoRoot, filePath); err == nil {
0000000000000000000000000000000000000000;;			return filePath, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cwd := path.Dir(processingFile)
0000000000000000000000000000000000000000;;		return filepath.Rel(repoRoot, path.Join(cwd, filePath))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeFileRelative(filePath string, processingFile string) (string, error) {
0000000000000000000000000000000000000000;;		cwd := path.Dir(processingFile)
0000000000000000000000000000000000000000;;		if filePath, err := filepath.Rel(cwd, filePath); err == nil {
0000000000000000000000000000000000000000;;			return filePath, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filepath.Rel(cwd, path.Join(cwd, filePath))
0000000000000000000000000000000000000000;;	}
