0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
83a4b883ee580b9fc469b163e01a854e51fd747d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateTokenDiscovery(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			c        *kubeadm.NodeConfiguration
0000000000000000000000000000000000000000;;			f        *field.Path
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{&kubeadm.NodeConfiguration{Token: "772ef5.6b6baab1d4a0a171", DiscoveryTokenAPIServers: []string{"192.168.122.100:9898"}}, nil, true},
0000000000000000000000000000000000000000;;			{&kubeadm.NodeConfiguration{Token: ".6b6baab1d4a0a171", DiscoveryTokenAPIServers: []string{"192.168.122.100:9898"}}, nil, false},
0000000000000000000000000000000000000000;;			{&kubeadm.NodeConfiguration{Token: "772ef5.", DiscoveryTokenAPIServers: []string{"192.168.122.100:9898"}}, nil, false},
0000000000000000000000000000000000000000;;			{&kubeadm.NodeConfiguration{Token: "772ef5.6b6baab1d4a0a171", DiscoveryTokenAPIServers: []string{"2001:db8::100:9898"}}, nil, true},
0000000000000000000000000000000000000000;;			{&kubeadm.NodeConfiguration{Token: ".6b6baab1d4a0a171", DiscoveryTokenAPIServers: []string{"2001:db8::100:9898"}}, nil, false},
0000000000000000000000000000000000000000;;			{&kubeadm.NodeConfiguration{Token: "772ef5.", DiscoveryTokenAPIServers: []string{"2001:db8::100:9898"}}, nil, false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			err := ValidateToken(rt.c.Token, rt.f).ToAggregate()
0000000000000000000000000000000000000000;;			if (err == nil) != rt.expected {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed ValidateTokenDiscovery:\n\texpected: %t\n\t  actual: %t",
0000000000000000000000000000000000000000;;					rt.expected,
0000000000000000000000000000000000000000;;					(err == nil),
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateAuthorizationModes(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			s        []string
0000000000000000000000000000000000000000;;			f        *field.Path
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{[]string{""}, nil, false},
0000000000000000000000000000000000000000;;			{[]string{"rBAC"}, nil, false},                               // mode not supported
0000000000000000000000000000000000000000;;			{[]string{"rBAC", "Webhook"}, nil, false},                    // mode not supported
0000000000000000000000000000000000000000;;			{[]string{"RBAC", "Webhook"}, nil, false},                    // mode Node required
0000000000000000000000000000000000000000;;			{[]string{"Node", "RBAC", "Webhook", "Webhook"}, nil, false}, // no duplicates allowed
0000000000000000000000000000000000000000;;			{[]string{"not valid"}, nil, false},                          // invalid mode
0000000000000000000000000000000000000000;;			{[]string{"Node", "RBAC"}, nil, true},                        // supported
0000000000000000000000000000000000000000;;			{[]string{"RBAC", "Node"}, nil, true},                        // supported
0000000000000000000000000000000000000000;;			{[]string{"Node", "RBAC", "Webhook", "ABAC"}, nil, true},     // supported
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := ValidateAuthorizationModes(rt.s, rt.f)
0000000000000000000000000000000000000000;;			if (len(actual) == 0) != rt.expected {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed ValidateAuthorizationModes:\n\texpected: %t\n\t  actual: %t",
0000000000000000000000000000000000000000;;					rt.expected,
0000000000000000000000000000000000000000;;					(len(actual) == 0),
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateNodeName(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			s        string
0000000000000000000000000000000000000000;;			f        *field.Path
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"", nil, false},                 // ok if not provided
0000000000000000000000000000000000000000;;			{"1234", nil, true},              // supported
0000000000000000000000000000000000000000;;			{"valid-nodename", nil, true},    // supported
0000000000000000000000000000000000000000;;			{"INVALID-NODENAME", nil, false}, // Upper cases is invalid
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := ValidateNodeName(rt.s, rt.f)
0000000000000000000000000000000000000000;;			if (len(actual) == 0) != rt.expected {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed ValidateNodeName:\n\texpected: %t\n\t  actual: %t",
0000000000000000000000000000000000000000;;					rt.expected,
0000000000000000000000000000000000000000;;					(len(actual) == 0),
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateCloudProvider(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			s        string
0000000000000000000000000000000000000000;;			f        *field.Path
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"", nil, true},      // if not provided, ok, it's optional
0000000000000000000000000000000000000000;;			{"1234", nil, false}, // not supported
0000000000000000000000000000000000000000;;			{"awws", nil, false}, // not supported
0000000000000000000000000000000000000000;;			{"aws", nil, true},   // supported
0000000000000000000000000000000000000000;;			{"gce", nil, true},   // supported
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := ValidateCloudProvider(rt.s, rt.f)
0000000000000000000000000000000000000000;;			if (len(actual) == 0) != rt.expected {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed ValidateCloudProvider:\n\texpected: %t\n\t  actual: %t",
0000000000000000000000000000000000000000;;					rt.expected,
0000000000000000000000000000000000000000;;					(len(actual) == 0),
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateAPIServerCertSANs(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			sans     []string
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{[]string{}, true},                                                     // ok if not provided
0000000000000000000000000000000000000000;;			{[]string{"1,2,,3"}, false},                                            // not a DNS label or IP
0000000000000000000000000000000000000000;;			{[]string{"my-hostname", "???&?.garbage"}, false},                      // not valid
0000000000000000000000000000000000000000;;			{[]string{"my-hostname", "my.subdomain", "1.2.3.4"}, true},             // supported
0000000000000000000000000000000000000000;;			{[]string{"my-hostname2", "my.other.subdomain", "10.0.0.10"}, true},    // supported
0000000000000000000000000000000000000000;;			{[]string{"my-hostname", "my.subdomain", "2001:db8::4"}, true},         // supported
0000000000000000000000000000000000000000;;			{[]string{"my-hostname2", "my.other.subdomain", "2001:db8::10"}, true}, // supported
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := ValidateAPIServerCertSANs(rt.sans, nil)
0000000000000000000000000000000000000000;;			if (len(actual) == 0) != rt.expected {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed ValidateAPIServerCertSANs:\n\texpected: %t\n\t  actual: %t",
0000000000000000000000000000000000000000;;					rt.expected,
0000000000000000000000000000000000000000;;					(len(actual) == 0),
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateIPFromString(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			ip       string
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"", false},           // not valid
0000000000000000000000000000000000000000;;			{"1234", false},       // not valid
0000000000000000000000000000000000000000;;			{"1.2", false},        // not valid
0000000000000000000000000000000000000000;;			{"1.2.3.4/16", false}, // not valid
0000000000000000000000000000000000000000;;			{"1.2.3.4", true},     // valid
0000000000000000000000000000000000000000;;			{"16.0.1.1", true},    // valid
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := ValidateIPFromString(rt.ip, nil)
0000000000000000000000000000000000000000;;			if (len(actual) == 0) != rt.expected {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed ValidateIPFromString:\n\texpected: %t\n\t  actual: %t",
0000000000000000000000000000000000000000;;					rt.expected,
0000000000000000000000000000000000000000;;					(len(actual) == 0),
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateIPNetFromString(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			subnet   string
0000000000000000000000000000000000000000;;			minaddrs int64
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"", 0, false},              // not valid
0000000000000000000000000000000000000000;;			{"1234", 0, false},          // not valid
0000000000000000000000000000000000000000;;			{"abc", 0, false},           // not valid
0000000000000000000000000000000000000000;;			{"1.2.3.4", 0, false},       // ip not valid
0000000000000000000000000000000000000000;;			{"10.0.0.16/29", 10, false}, // valid, but too small. At least 10 addrs needed
0000000000000000000000000000000000000000;;			{"10.0.0.16/12", 10, true},  // valid
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := ValidateIPNetFromString(rt.subnet, rt.minaddrs, nil)
0000000000000000000000000000000000000000;;			if (len(actual) == 0) != rt.expected {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed ValidateIPNetFromString:\n\texpected: %t\n\t  actual: %t",
0000000000000000000000000000000000000000;;					rt.expected,
0000000000000000000000000000000000000000;;					(len(actual) == 0),
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateMasterConfiguration(t *testing.T) {
0000000000000000000000000000000000000000;;		nodename := "valid-nodename"
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			s        *kubeadm.MasterConfiguration
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{&kubeadm.MasterConfiguration{}, false},
0000000000000000000000000000000000000000;;			{&kubeadm.MasterConfiguration{
0000000000000000000000000000000000000000;;				AuthorizationModes: []string{"Node", "RBAC"},
0000000000000000000000000000000000000000;;				Networking: kubeadm.Networking{
0000000000000000000000000000000000000000;;					ServiceSubnet: "10.96.0.1/12",
0000000000000000000000000000000000000000;;					DNSDomain:     "cluster.local",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				CertificatesDir: "/some/cert/dir",
0000000000000000000000000000000000000000;;				NodeName:        nodename,
0000000000000000000000000000000000000000;;			}, false},
0000000000000000000000000000000000000000;;			{&kubeadm.MasterConfiguration{
0000000000000000000000000000000000000000;;				AuthorizationModes: []string{"Node", "RBAC"},
0000000000000000000000000000000000000000;;				Networking: kubeadm.Networking{
0000000000000000000000000000000000000000;;					ServiceSubnet: "10.96.0.1/12",
0000000000000000000000000000000000000000;;					DNSDomain:     "cluster.local",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				CertificatesDir: "/some/other/cert/dir",
0000000000000000000000000000000000000000;;				Token:           "abcdef.0123456789abcdef",
0000000000000000000000000000000000000000;;				NodeName:        nodename,
0000000000000000000000000000000000000000;;			}, true},
0000000000000000000000000000000000000000;;			{&kubeadm.MasterConfiguration{
0000000000000000000000000000000000000000;;				AuthorizationModes: []string{"Node", "RBAC"},
0000000000000000000000000000000000000000;;				Networking: kubeadm.Networking{
0000000000000000000000000000000000000000;;					ServiceSubnet: "2001:db8::/98",
0000000000000000000000000000000000000000;;					DNSDomain:     "cluster.local",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				CertificatesDir: "/some/cert/dir",
0000000000000000000000000000000000000000;;				NodeName:        nodename,
0000000000000000000000000000000000000000;;			}, false},
0000000000000000000000000000000000000000;;			{&kubeadm.MasterConfiguration{
0000000000000000000000000000000000000000;;				AuthorizationModes: []string{"Node", "RBAC"},
0000000000000000000000000000000000000000;;				Networking: kubeadm.Networking{
0000000000000000000000000000000000000000;;					ServiceSubnet: "2001:db8::/98",
0000000000000000000000000000000000000000;;					DNSDomain:     "cluster.local",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				CertificatesDir: "/some/other/cert/dir",
0000000000000000000000000000000000000000;;				Token:           "abcdef.0123456789abcdef",
0000000000000000000000000000000000000000;;				NodeName:        nodename,
0000000000000000000000000000000000000000;;			}, true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := ValidateMasterConfiguration(rt.s)
0000000000000000000000000000000000000000;;			if (len(actual) == 0) != rt.expected {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed ValidateMasterConfiguration:\n\texpected: %t\n\t  actual: %t",
0000000000000000000000000000000000000000;;					rt.expected,
0000000000000000000000000000000000000000;;					(len(actual) == 0),
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateNodeConfiguration(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			s        *kubeadm.NodeConfiguration
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{&kubeadm.NodeConfiguration{}, false},
0000000000000000000000000000000000000000;;			{&kubeadm.NodeConfiguration{
0000000000000000000000000000000000000000;;				DiscoveryFile:  "foo",
0000000000000000000000000000000000000000;;				DiscoveryToken: "abcdef.1234567890123456@foobar",
0000000000000000000000000000000000000000;;				CACertPath:     "/some/cert.crt",
0000000000000000000000000000000000000000;;			}, false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := ValidateNodeConfiguration(rt.s)
0000000000000000000000000000000000000000;;			if (len(actual) == 0) != rt.expected {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed ValidateNodeConfiguration:\n\texpected: %t\n\t  actual: %t",
0000000000000000000000000000000000000000;;					rt.expected,
0000000000000000000000000000000000000000;;					(len(actual) == 0),
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateMixedArguments(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			args     []string
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{[]string{"--foo=bar"}, true},
0000000000000000000000000000000000000000;;			{[]string{"--config=hello"}, true},
0000000000000000000000000000000000000000;;			{[]string{"--foo=bar", "--config=hello"}, false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var cfgPath string
0000000000000000000000000000000000000000;;		var skipPreFlight bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			f := pflag.NewFlagSet("test", pflag.ContinueOnError)
0000000000000000000000000000000000000000;;			if f.Parsed() {
0000000000000000000000000000000000000000;;				t.Error("f.Parse() = true before Parse")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.String("foo", "", "string value")
0000000000000000000000000000000000000000;;			f.StringVar(&cfgPath, "config", cfgPath, "Path to kubeadm config file")
0000000000000000000000000000000000000000;;			f.BoolVar(
0000000000000000000000000000000000000000;;				&skipPreFlight, "skip-preflight-checks", skipPreFlight,
0000000000000000000000000000000000000000;;				"Skip preflight checks normally run before modifying the system",
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			if err := f.Parse(rt.args); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			actual := ValidateMixedArguments(f)
0000000000000000000000000000000000000000;;			if (actual == nil) != rt.expected {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed ValidateMixedArguments:\n\texpected: %t\n\t  actual: %t",
0000000000000000000000000000000000000000;;					rt.expected,
0000000000000000000000000000000000000000;;					(actual == nil),
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
