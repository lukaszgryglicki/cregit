0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6e3ee84dfd4d24a005a7b2fa9a61bcf457b48352;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/constants"
0000000000000000000000000000000000000000;;		tokenutil "k8s.io/kubernetes/cmd/kubeadm/app/util/token"
0000000000000000000000000000000000000000;;		apivalidation "k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;		authzmodes "k8s.io/kubernetes/pkg/kubeapiserver/authorizer/modes"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/service/ipallocator"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/node"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Break out the cloudprovider functionality out of core and only support the new flow
0000000000000000000000000000000000000000;;	// described in https://github.com/kubernetes/community/pull/128
0000000000000000000000000000000000000000;;	var cloudproviders = []string{
0000000000000000000000000000000000000000;;		"aws",
0000000000000000000000000000000000000000;;		"azure",
0000000000000000000000000000000000000000;;		"cloudstack",
0000000000000000000000000000000000000000;;		"gce",
0000000000000000000000000000000000000000;;		"openstack",
0000000000000000000000000000000000000000;;		"ovirt",
0000000000000000000000000000000000000000;;		"photon",
0000000000000000000000000000000000000000;;		"rackspace",
0000000000000000000000000000000000000000;;		"vsphere",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Describes the authorization modes that are enforced by kubeadm
0000000000000000000000000000000000000000;;	var requiredAuthzModes = []string{
0000000000000000000000000000000000000000;;		authzmodes.ModeRBAC,
0000000000000000000000000000000000000000;;		authzmodes.ModeNode,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateMasterConfiguration(c *kubeadm.MasterConfiguration) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateCloudProvider(c.CloudProvider, field.NewPath("cloudprovider"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateAuthorizationModes(c.AuthorizationModes, field.NewPath("authorization-modes"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateNetworking(&c.Networking, field.NewPath("networking"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateAPIServerCertSANs(c.APIServerCertSANs, field.NewPath("cert-altnames"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateAbsolutePath(c.CertificatesDir, field.NewPath("certificates-dir"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateNodeName(c.NodeName, field.NewPath("node-name"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateToken(c.Token, field.NewPath("token"))...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateNodeConfiguration(c *kubeadm.NodeConfiguration) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateDiscovery(c, field.NewPath("discovery"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !filepath.IsAbs(c.CACertPath) || !strings.HasSuffix(c.CACertPath, ".crt") {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(field.NewPath("ca-cert-path"), c.CACertPath, "the ca certificate path must be an absolute path"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateAuthorizationModes(authzModes []string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		found := map[string]bool{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, authzMode := range authzModes {
0000000000000000000000000000000000000000;;			if !authzmodes.IsValidAuthorizationMode(authzMode) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath, authzMode, "invalid authorization mode"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if found[authzMode] {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath, authzMode, "duplicate authorization mode"))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			found[authzMode] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, requiredMode := range requiredAuthzModes {
0000000000000000000000000000000000000000;;			if !found[requiredMode] {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(fldPath, fmt.Sprintf("authorization mode %s must be enabled", requiredMode)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateDiscovery(c *kubeadm.NodeConfiguration, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(c.DiscoveryToken) != 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateToken(c.DiscoveryToken, fldPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(c.DiscoveryFile) != 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateDiscoveryFile(c.DiscoveryFile, fldPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateArgSelection(c, fldPath)...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateToken(c.TLSBootstrapToken, fldPath)...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateJoinDiscoveryTokenAPIServer(c, fldPath)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(c.DiscoveryToken) != 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateToken(c.DiscoveryToken, fldPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(c.DiscoveryFile) != 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateDiscoveryFile(c.DiscoveryFile, fldPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateArgSelection(cfg *kubeadm.NodeConfiguration, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(cfg.DiscoveryToken) != 0 && len(cfg.DiscoveryFile) != 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, "", "DiscoveryToken and DiscoveryFile cannot both be set"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(cfg.DiscoveryToken) == 0 && len(cfg.DiscoveryFile) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, "", "DiscoveryToken or DiscoveryFile must be set"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(cfg.DiscoveryTokenAPIServers) < 1 && len(cfg.DiscoveryToken) != 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath, "DiscoveryTokenAPIServers not set"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO remove once we support multiple api servers
0000000000000000000000000000000000000000;;		if len(cfg.DiscoveryTokenAPIServers) > 1 {
0000000000000000000000000000000000000000;;			fmt.Println("[validation] WARNING: kubeadm doesn't fully support multiple API Servers yet")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateJoinDiscoveryTokenAPIServer(c *kubeadm.NodeConfiguration, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for _, m := range c.DiscoveryTokenAPIServers {
0000000000000000000000000000000000000000;;			_, _, err := net.SplitHostPort(m)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath, m, err.Error()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateDiscoveryFile(discoveryFile string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		u, err := url.Parse(discoveryFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, discoveryFile, "not a valid HTTPS URL or a file on disk"))
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if u.Scheme == "" {
0000000000000000000000000000000000000000;;			// URIs with no scheme should be treated as files
0000000000000000000000000000000000000000;;			if _, err := os.Stat(discoveryFile); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath, discoveryFile, "not a valid HTTPS URL or a file on disk"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if u.Scheme != "https" {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, discoveryFile, "if an URL is used, the scheme must be https"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateToken(t string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		id, secret, err := tokenutil.ParseToken(t)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, t, err.Error()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(id) == 0 || len(secret) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, t, "token must be of form '[a-z0-9]{6}.[a-z0-9]{16}'"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateAPIServerCertSANs(altnames []string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for _, altname := range altnames {
0000000000000000000000000000000000000000;;			if len(validation.IsDNS1123Subdomain(altname)) != 0 && net.ParseIP(altname) == nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath, altname, "altname is not a valid dns label or ip address"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateIPFromString(ipaddr string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if net.ParseIP(ipaddr) == nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, ipaddr, "ip address is not valid"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateIPNetFromString(subnet string, minAddrs int64, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		_, svcSubnet, err := net.ParseCIDR(subnet)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, subnet, "couldn't parse subnet"))
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		numAddresses := ipallocator.RangeSize(svcSubnet)
0000000000000000000000000000000000000000;;		if numAddresses < minAddrs {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, subnet, "subnet is too small"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateNetworking(c *kubeadm.Networking, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, apivalidation.ValidateDNS1123Subdomain(c.DNSDomain, field.NewPath("dns-domain"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateIPNetFromString(c.ServiceSubnet, constants.MinimumAddressesInServiceSubnet, field.NewPath("service-subnet"))...)
0000000000000000000000000000000000000000;;		if len(c.PodSubnet) != 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateIPNetFromString(c.PodSubnet, constants.MinimumAddressesInServiceSubnet, field.NewPath("pod-subnet"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateAbsolutePath(path string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if !filepath.IsAbs(path) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, path, "path is not absolute"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateNodeName(nodename string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if node.GetHostname(nodename) != nodename {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, nodename, "nodename is not valid, must be lower case"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateCloudProvider(provider string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(provider) == 0 {
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, supported := range cloudproviders {
0000000000000000000000000000000000000000;;			if provider == supported {
0000000000000000000000000000000000000000;;				return allErrs
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, field.Invalid(fldPath, provider, "cloudprovider not supported"))
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateMixedArguments(flag *pflag.FlagSet) error {
0000000000000000000000000000000000000000;;		if flag.Changed("config") && flag.NFlag() != 1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("can not mix '--config' with other arguments")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
