0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
8951cf217715eb02d670eff56c1581cc4389a177;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package token
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeadmapi "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		TokenIDBytes     = 3
0000000000000000000000000000000000000000;;		TokenSecretBytes = 8
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		TokenIDRegexpString = "^([a-z0-9]{6})$"
0000000000000000000000000000000000000000;;		TokenIDRegexp       = regexp.MustCompile(TokenIDRegexpString)
0000000000000000000000000000000000000000;;		TokenRegexpString   = "^([a-z0-9]{6})\\.([a-z0-9]{16})$"
0000000000000000000000000000000000000000;;		TokenRegexp         = regexp.MustCompile(TokenRegexpString)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func randBytes(length int) (string, error) {
0000000000000000000000000000000000000000;;		b := make([]byte, length)
0000000000000000000000000000000000000000;;		_, err := rand.Read(b)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hex.EncodeToString(b), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenerateToken generates a new token with a token ID that is valid as a
0000000000000000000000000000000000000000;;	// Kubernetes DNS label.
0000000000000000000000000000000000000000;;	// For more info, see kubernetes/pkg/util/validation/validation.go.
0000000000000000000000000000000000000000;;	func GenerateToken() (string, error) {
0000000000000000000000000000000000000000;;		tokenID, err := randBytes(TokenIDBytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokenSecret, err := randBytes(TokenSecretBytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s.%s", tokenID, tokenSecret), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseTokenID tries and parse a valid token ID from a string.
0000000000000000000000000000000000000000;;	// An error is returned in case of failure.
0000000000000000000000000000000000000000;;	func ParseTokenID(s string) error {
0000000000000000000000000000000000000000;;		if !TokenIDRegexp.MatchString(s) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("token ID [%q] was not of form [%q]", s, TokenIDRegexpString)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseToken tries and parse a valid token from a string.
0000000000000000000000000000000000000000;;	// A token ID and token secret are returned in case of success, an error otherwise.
0000000000000000000000000000000000000000;;	func ParseToken(s string) (string, string, error) {
0000000000000000000000000000000000000000;;		split := TokenRegexp.FindStringSubmatch(s)
0000000000000000000000000000000000000000;;		if len(split) != 3 {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("token [%q] was not of form [%q]", s, TokenRegexpString)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return split[1], split[2], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BearerToken returns a string representation of the passed token.
0000000000000000000000000000000000000000;;	func BearerToken(d *kubeadmapi.TokenDiscovery) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s.%s", d.ID, d.Secret)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateToken validates whether a token is well-formed.
0000000000000000000000000000000000000000;;	// In case it's not, the corresponding error is returned as well.
0000000000000000000000000000000000000000;;	func ValidateToken(d *kubeadmapi.TokenDiscovery) (bool, error) {
0000000000000000000000000000000000000000;;		if _, _, err := ParseToken(d.ID + "." + d.Secret); err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
