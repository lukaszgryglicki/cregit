0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
0bf86dc9f94ee8683005e93bc8d697ffa91fa00a;cmd/kubeadm/app/checks/checks.go[cmd/kubeadm/app/checks/checks.go][cmd/kubeadm/app/preflight/checks.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package preflight
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/PuerkitoBio/purell"
0000000000000000000000000000000000000000;;		"github.com/blang/semver"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiservoptions "k8s.io/kubernetes/cmd/kube-apiserver/app/options"
0000000000000000000000000000000000000000;;		cmoptions "k8s.io/kubernetes/cmd/kube-controller-manager/app/options"
0000000000000000000000000000000000000000;;		kubeadmapi "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm"
0000000000000000000000000000000000000000;;		kubeadmconstants "k8s.io/kubernetes/cmd/kubeadm/app/constants"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;		authzmodes "k8s.io/kubernetes/pkg/kubeapiserver/authorizer/modes"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/initsystem"
0000000000000000000000000000000000000000;;		schoptions "k8s.io/kubernetes/plugin/cmd/kube-scheduler/app/options"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e_node/system"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		bridgenf                    = "/proc/sys/net/bridge/bridge-nf-call-iptables"
0000000000000000000000000000000000000000;;		externalEtcdRequestTimeout  = time.Duration(10 * time.Second)
0000000000000000000000000000000000000000;;		externalEtcdRequestRetries  = 3
0000000000000000000000000000000000000000;;		externalEtcdRequestInterval = time.Duration(5 * time.Second)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		minExternalEtcdVersion = semver.MustParse(kubeadmconstants.MinExternalEtcdVersion)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Error struct {
0000000000000000000000000000000000000000;;		Msg string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Error) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("[preflight] Some fatal errors occurred:\n%s%s", e.Msg, "[preflight] If you know what you are doing, you can skip pre-flight checks with `--skip-preflight-checks`")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checker validates the state of the system to ensure kubeadm will be
0000000000000000000000000000000000000000;;	// successful as often as possilble.
0000000000000000000000000000000000000000;;	type Checker interface {
0000000000000000000000000000000000000000;;		Check() (warnings, errors []error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceCheck verifies that the given service is enabled and active. If we do not
0000000000000000000000000000000000000000;;	// detect a supported init system however, all checks are skipped and a warning is
0000000000000000000000000000000000000000;;	// returned.
0000000000000000000000000000000000000000;;	type ServiceCheck struct {
0000000000000000000000000000000000000000;;		Service       string
0000000000000000000000000000000000000000;;		CheckIfActive bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc ServiceCheck) Check() (warnings, errors []error) {
0000000000000000000000000000000000000000;;		initSystem, err := initsystem.GetInitSystem()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []error{err}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		warnings = []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !initSystem.ServiceExists(sc.Service) {
0000000000000000000000000000000000000000;;			warnings = append(warnings, fmt.Errorf("%s service does not exist", sc.Service))
0000000000000000000000000000000000000000;;			return warnings, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !initSystem.ServiceIsEnabled(sc.Service) {
0000000000000000000000000000000000000000;;			warnings = append(warnings,
0000000000000000000000000000000000000000;;				fmt.Errorf("%s service is not enabled, please run 'systemctl enable %s.service'",
0000000000000000000000000000000000000000;;					sc.Service, sc.Service))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sc.CheckIfActive && !initSystem.ServiceIsActive(sc.Service) {
0000000000000000000000000000000000000000;;			errors = append(errors,
0000000000000000000000000000000000000000;;				fmt.Errorf("%s service is not active, please run 'systemctl start %s.service'",
0000000000000000000000000000000000000000;;					sc.Service, sc.Service))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return warnings, errors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FirewalldCheck checks if firewalld is enabled or active, and if so outputs a warning.
0000000000000000000000000000000000000000;;	type FirewalldCheck struct {
0000000000000000000000000000000000000000;;		ports []int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fc FirewalldCheck) Check() (warnings, errors []error) {
0000000000000000000000000000000000000000;;		initSystem, err := initsystem.GetInitSystem()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []error{err}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		warnings = []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !initSystem.ServiceExists("firewalld") {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if initSystem.ServiceIsActive("firewalld") {
0000000000000000000000000000000000000000;;			warnings = append(warnings,
0000000000000000000000000000000000000000;;				fmt.Errorf("firewalld is active, please ensure ports %v are open or your cluster may not function correctly",
0000000000000000000000000000000000000000;;					fc.ports))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return warnings, errors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PortOpenCheck ensures the given port is available for use.
0000000000000000000000000000000000000000;;	type PortOpenCheck struct {
0000000000000000000000000000000000000000;;		port int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (poc PortOpenCheck) Check() (warnings, errors []error) {
0000000000000000000000000000000000000000;;		errors = []error{}
0000000000000000000000000000000000000000;;		// TODO: Get IP from KubeadmConfig
0000000000000000000000000000000000000000;;		ln, err := net.Listen("tcp", fmt.Sprintf(":%d", poc.port))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			errors = append(errors, fmt.Errorf("Port %d is in use", poc.port))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ln != nil {
0000000000000000000000000000000000000000;;			ln.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, errors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsRootCheck verifies user is root
0000000000000000000000000000000000000000;;	type IsRootCheck struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (irc IsRootCheck) Check() (warnings, errors []error) {
0000000000000000000000000000000000000000;;		errors = []error{}
0000000000000000000000000000000000000000;;		if os.Getuid() != 0 {
0000000000000000000000000000000000000000;;			errors = append(errors, fmt.Errorf("user is not running as root"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, errors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DirAvailableCheck checks if the given directory either does not exist, or is empty.
0000000000000000000000000000000000000000;;	type DirAvailableCheck struct {
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dac DirAvailableCheck) Check() (warnings, errors []error) {
0000000000000000000000000000000000000000;;		errors = []error{}
0000000000000000000000000000000000000000;;		// If it doesn't exist we are good:
0000000000000000000000000000000000000000;;		if _, err := os.Stat(dac.Path); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := os.Open(dac.Path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			errors = append(errors, fmt.Errorf("unable to check if %s is empty: %s", dac.Path, err))
0000000000000000000000000000000000000000;;			return nil, errors
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = f.Readdirnames(1)
0000000000000000000000000000000000000000;;		if err != io.EOF {
0000000000000000000000000000000000000000;;			errors = append(errors, fmt.Errorf("%s is not empty", dac.Path))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, errors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FileAvailableCheck checks that the given file does not already exist.
0000000000000000000000000000000000000000;;	type FileAvailableCheck struct {
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fac FileAvailableCheck) Check() (warnings, errors []error) {
0000000000000000000000000000000000000000;;		errors = []error{}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(fac.Path); err == nil {
0000000000000000000000000000000000000000;;			errors = append(errors, fmt.Errorf("%s already exists", fac.Path))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, errors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FileExistingCheck checks that the given file does not already exist.
0000000000000000000000000000000000000000;;	type FileExistingCheck struct {
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fac FileExistingCheck) Check() (warnings, errors []error) {
0000000000000000000000000000000000000000;;		errors = []error{}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(fac.Path); err != nil {
0000000000000000000000000000000000000000;;			errors = append(errors, fmt.Errorf("%s doesn't exist", fac.Path))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, errors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FileContentCheck checks that the given file contains the string Content.
0000000000000000000000000000000000000000;;	type FileContentCheck struct {
0000000000000000000000000000000000000000;;		Path    string
0000000000000000000000000000000000000000;;		Content []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fcc FileContentCheck) Check() (warnings, errors []error) {
0000000000000000000000000000000000000000;;		f, err := os.Open(fcc.Path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, []error{fmt.Errorf("%s does not exist", fcc.Path)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lr := io.LimitReader(f, int64(len(fcc.Content)))
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		_, err = io.Copy(buf, lr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, []error{fmt.Errorf("%s could not be read", fcc.Path)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !bytes.Equal(buf.Bytes(), fcc.Content) {
0000000000000000000000000000000000000000;;			return nil, []error{fmt.Errorf("%s contents are not set to %s", fcc.Path, fcc.Content)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InPathCheck checks if the given executable is present in the path
0000000000000000000000000000000000000000;;	type InPathCheck struct {
0000000000000000000000000000000000000000;;		executable string
0000000000000000000000000000000000000000;;		mandatory  bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ipc InPathCheck) Check() (warnings, errors []error) {
0000000000000000000000000000000000000000;;		_, err := exec.LookPath(ipc.executable)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if ipc.mandatory {
0000000000000000000000000000000000000000;;				// Return as an error:
0000000000000000000000000000000000000000;;				return nil, []error{fmt.Errorf("%s not found in system path", ipc.executable)}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Return as a warning:
0000000000000000000000000000000000000000;;			return []error{fmt.Errorf("%s not found in system path", ipc.executable)}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HostnameCheck checks if hostname match dns sub domain regex.
0000000000000000000000000000000000000000;;	// If hostname doesn't match this regex, kubelet will not launch static pods like kube-apiserver/kube-controller-manager and so on.
0000000000000000000000000000000000000000;;	type HostnameCheck struct {
0000000000000000000000000000000000000000;;		nodeName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (hc HostnameCheck) Check() (warnings, errors []error) {
0000000000000000000000000000000000000000;;		errors = []error{}
0000000000000000000000000000000000000000;;		warnings = []error{}
0000000000000000000000000000000000000000;;		for _, msg := range validation.ValidateNodeName(hc.nodeName, false) {
0000000000000000000000000000000000000000;;			errors = append(errors, fmt.Errorf("hostname \"%s\" %s", hc.nodeName, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		addr, err := net.LookupHost(hc.nodeName)
0000000000000000000000000000000000000000;;		if addr == nil {
0000000000000000000000000000000000000000;;			warnings = append(warnings, fmt.Errorf("hostname \"%s\" could not be reached", hc.nodeName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			warnings = append(warnings, fmt.Errorf("hostname \"%s\" %s", hc.nodeName, err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return warnings, errors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTTPProxyCheck checks if https connection to specific host is going
0000000000000000000000000000000000000000;;	// to be done directly or over proxy. If proxy detected, it will return warning.
0000000000000000000000000000000000000000;;	type HTTPProxyCheck struct {
0000000000000000000000000000000000000000;;		Proto string
0000000000000000000000000000000000000000;;		Host  string
0000000000000000000000000000000000000000;;		Port  int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (hst HTTPProxyCheck) Check() (warnings, errors []error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		url := fmt.Sprintf("%s://%s:%d", hst.Proto, hst.Host, hst.Port)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("GET", url, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, []error{err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxy, err := http.DefaultTransport.(*http.Transport).Proxy(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, []error{err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if proxy != nil {
0000000000000000000000000000000000000000;;			return []error{fmt.Errorf("Connection to %q uses proxy %q. If that is not intended, adjust your proxy settings", url, proxy)}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtraArgsCheck checks if arguments are valid.
0000000000000000000000000000000000000000;;	type ExtraArgsCheck struct {
0000000000000000000000000000000000000000;;		APIServerExtraArgs         map[string]string
0000000000000000000000000000000000000000;;		ControllerManagerExtraArgs map[string]string
0000000000000000000000000000000000000000;;		SchedulerExtraArgs         map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (eac ExtraArgsCheck) Check() (warnings, errors []error) {
0000000000000000000000000000000000000000;;		argsCheck := func(name string, args map[string]string, f *pflag.FlagSet) []error {
0000000000000000000000000000000000000000;;			errs := []error{}
0000000000000000000000000000000000000000;;			for k, v := range args {
0000000000000000000000000000000000000000;;				if err := f.Set(k, v); err != nil {
0000000000000000000000000000000000000000;;					errs = append(errs, fmt.Errorf("%s: failed to parse extra argument --%s=%s", name, k, v))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return errs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		warnings = []error{}
0000000000000000000000000000000000000000;;		if len(eac.APIServerExtraArgs) > 0 {
0000000000000000000000000000000000000000;;			flags := pflag.NewFlagSet("", pflag.ContinueOnError)
0000000000000000000000000000000000000000;;			s := apiservoptions.NewServerRunOptions()
0000000000000000000000000000000000000000;;			s.AddFlags(flags)
0000000000000000000000000000000000000000;;			warnings = append(warnings, argsCheck("kube-apiserver", eac.APIServerExtraArgs, flags)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(eac.ControllerManagerExtraArgs) > 0 {
0000000000000000000000000000000000000000;;			flags := pflag.NewFlagSet("", pflag.ContinueOnError)
0000000000000000000000000000000000000000;;			s := cmoptions.NewCMServer()
0000000000000000000000000000000000000000;;			s.AddFlags(flags, []string{}, []string{})
0000000000000000000000000000000000000000;;			warnings = append(warnings, argsCheck("kube-controller-manager", eac.ControllerManagerExtraArgs, flags)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(eac.SchedulerExtraArgs) > 0 {
0000000000000000000000000000000000000000;;			flags := pflag.NewFlagSet("", pflag.ContinueOnError)
0000000000000000000000000000000000000000;;			s := schoptions.NewSchedulerServer()
0000000000000000000000000000000000000000;;			s.AddFlags(flags)
0000000000000000000000000000000000000000;;			warnings = append(warnings, argsCheck("kube-scheduler", eac.SchedulerExtraArgs, flags)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return warnings, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SystemVerificationCheck struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sysver SystemVerificationCheck) Check() (warnings, errors []error) {
0000000000000000000000000000000000000000;;		// Create a buffered writer and choose a quite large value (1M) and suppose the output from the system verification test won't exceed the limit
0000000000000000000000000000000000000000;;		// Run the system verification check, but write to out buffered writer instead of stdout
0000000000000000000000000000000000000000;;		bufw := bufio.NewWriterSize(os.Stdout, 1*1024*1024)
0000000000000000000000000000000000000000;;		reporter := &system.StreamReporter{WriteStream: bufw}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var errs []error
0000000000000000000000000000000000000000;;		var warns []error
0000000000000000000000000000000000000000;;		// All the validators we'd like to run:
0000000000000000000000000000000000000000;;		var validators = []system.Validator{
0000000000000000000000000000000000000000;;			&system.OSValidator{Reporter: reporter},
0000000000000000000000000000000000000000;;			&system.KernelValidator{Reporter: reporter},
0000000000000000000000000000000000000000;;			&system.CgroupsValidator{Reporter: reporter},
0000000000000000000000000000000000000000;;			&system.DockerValidator{Reporter: reporter},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run all validators
0000000000000000000000000000000000000000;;		for _, v := range validators {
0000000000000000000000000000000000000000;;			warn, err := v.Validate(system.DefaultSysSpec)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if warn != nil {
0000000000000000000000000000000000000000;;				warns = append(warns, warn)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(errs) != 0 {
0000000000000000000000000000000000000000;;			// Only print the output from the system verification check if the check failed
0000000000000000000000000000000000000000;;			fmt.Println("[preflight] The system verification failed. Printing the output from the verification:")
0000000000000000000000000000000000000000;;			bufw.Flush()
0000000000000000000000000000000000000000;;			return warns, errs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return warns, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type etcdVersionResponse struct {
0000000000000000000000000000000000000000;;		Etcdserver  string `json:"etcdserver"`
0000000000000000000000000000000000000000;;		Etcdcluster string `json:"etcdcluster"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExternalEtcdVersionCheck checks if version of external etcd meets the demand of kubeadm
0000000000000000000000000000000000000000;;	type ExternalEtcdVersionCheck struct {
0000000000000000000000000000000000000000;;		Etcd kubeadmapi.Etcd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (evc ExternalEtcdVersionCheck) Check() (warnings, errors []error) {
0000000000000000000000000000000000000000;;		var config *tls.Config
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if config, err = evc.configRootCAs(config); err != nil {
0000000000000000000000000000000000000000;;			errors = append(errors, err)
0000000000000000000000000000000000000000;;			return nil, errors
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config, err = evc.configCertAndKey(config); err != nil {
0000000000000000000000000000000000000000;;			errors = append(errors, err)
0000000000000000000000000000000000000000;;			return nil, errors
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := evc.getHTTPClient(config)
0000000000000000000000000000000000000000;;		for _, endpoint := range evc.Etcd.Endpoints {
0000000000000000000000000000000000000000;;			if _, err := url.Parse(endpoint); err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, fmt.Errorf("failed to parse external etcd endpoint %s : %v", endpoint, err))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resp := etcdVersionResponse{}
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			versionURL := fmt.Sprintf("%s/%s", endpoint, "version")
0000000000000000000000000000000000000000;;			if tmpVersionURL, err := purell.NormalizeURLString(versionURL, purell.FlagRemoveDuplicateSlashes); err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, fmt.Errorf("failed to normalize external etcd version url %s : %v", versionURL, err))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				versionURL = tmpVersionURL
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = getEtcdVersionResponse(client, versionURL, &resp); err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			etcdVersion, err := semver.Parse(resp.Etcdserver)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, fmt.Errorf("couldn't parse external etcd version %q: %v", resp.Etcdserver, err))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if etcdVersion.LT(minExternalEtcdVersion) {
0000000000000000000000000000000000000000;;				errors = append(errors, fmt.Errorf("this version of kubeadm only supports external etcd version >= %s. Current version: %s", kubeadmconstants.MinExternalEtcdVersion, resp.Etcdserver))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, errors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// configRootCAs configures and returns a reference to tls.Config instance if CAFile is provided
0000000000000000000000000000000000000000;;	func (evc ExternalEtcdVersionCheck) configRootCAs(config *tls.Config) (*tls.Config, error) {
0000000000000000000000000000000000000000;;		var CACertPool *x509.CertPool
0000000000000000000000000000000000000000;;		if evc.Etcd.CAFile != "" {
0000000000000000000000000000000000000000;;			CACert, err := ioutil.ReadFile(evc.Etcd.CAFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("couldn't load external etcd's server certificate %s: %v", evc.Etcd.CAFile, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			CACertPool = x509.NewCertPool()
0000000000000000000000000000000000000000;;			CACertPool.AppendCertsFromPEM(CACert)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if CACertPool != nil {
0000000000000000000000000000000000000000;;			if config == nil {
0000000000000000000000000000000000000000;;				config = &tls.Config{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			config.RootCAs = CACertPool
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return config, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// configCertAndKey configures and returns a reference to tls.Config instance if CertFile and KeyFile pair is provided
0000000000000000000000000000000000000000;;	func (evc ExternalEtcdVersionCheck) configCertAndKey(config *tls.Config) (*tls.Config, error) {
0000000000000000000000000000000000000000;;		var cert tls.Certificate
0000000000000000000000000000000000000000;;		if evc.Etcd.CertFile != "" && evc.Etcd.KeyFile != "" {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			cert, err = tls.LoadX509KeyPair(evc.Etcd.CertFile, evc.Etcd.KeyFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("couldn't load external etcd's certificate and key pair %s, %s: %v", evc.Etcd.CertFile, evc.Etcd.KeyFile, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if config == nil {
0000000000000000000000000000000000000000;;				config = &tls.Config{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			config.Certificates = []tls.Certificate{cert}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return config, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (evc ExternalEtcdVersionCheck) getHTTPClient(config *tls.Config) *http.Client {
0000000000000000000000000000000000000000;;		if config != nil {
0000000000000000000000000000000000000000;;			transport := &http.Transport{
0000000000000000000000000000000000000000;;				TLSClientConfig: config,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &http.Client{
0000000000000000000000000000000000000000;;				Transport: transport,
0000000000000000000000000000000000000000;;				Timeout:   externalEtcdRequestTimeout,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &http.Client{Timeout: externalEtcdRequestTimeout}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func getEtcdVersionResponse(client *http.Client, url string, target interface{}) error {
0000000000000000000000000000000000000000;;		loopCount := externalEtcdRequestRetries + 1
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var stopRetry bool
0000000000000000000000000000000000000000;;		for loopCount > 0 {
0000000000000000000000000000000000000000;;			if loopCount <= externalEtcdRequestRetries {
0000000000000000000000000000000000000000;;				time.Sleep(externalEtcdRequestInterval)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			stopRetry, err = func() (stopRetry bool, err error) {
0000000000000000000000000000000000000000;;				r, err := client.Get(url)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					loopCount--
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer r.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if r != nil && r.StatusCode >= 500 && r.StatusCode <= 599 {
0000000000000000000000000000000000000000;;					loopCount--
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, json.NewDecoder(r.Body).Decode(target)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			if stopRetry {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func RunInitMasterChecks(cfg *kubeadmapi.MasterConfiguration) error {
0000000000000000000000000000000000000000;;		// First, check if we're root separately from the other preflight checks and fail fast
0000000000000000000000000000000000000000;;		if err := RunRootCheckOnly(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		checks := []Checker{
0000000000000000000000000000000000000000;;			SystemVerificationCheck{},
0000000000000000000000000000000000000000;;			IsRootCheck{},
0000000000000000000000000000000000000000;;			HostnameCheck{nodeName: cfg.NodeName},
0000000000000000000000000000000000000000;;			ServiceCheck{Service: "kubelet", CheckIfActive: false},
0000000000000000000000000000000000000000;;			ServiceCheck{Service: "docker", CheckIfActive: true},
0000000000000000000000000000000000000000;;			FirewalldCheck{ports: []int{int(cfg.API.BindPort), 10250}},
0000000000000000000000000000000000000000;;			PortOpenCheck{port: int(cfg.API.BindPort)},
0000000000000000000000000000000000000000;;			PortOpenCheck{port: 10250},
0000000000000000000000000000000000000000;;			PortOpenCheck{port: 10251},
0000000000000000000000000000000000000000;;			PortOpenCheck{port: 10252},
0000000000000000000000000000000000000000;;			HTTPProxyCheck{Proto: "https", Host: cfg.API.AdvertiseAddress, Port: int(cfg.API.BindPort)},
0000000000000000000000000000000000000000;;			DirAvailableCheck{Path: filepath.Join(kubeadmapi.GlobalEnvParams.KubernetesDir, kubeadmconstants.ManifestsSubDirName)},
0000000000000000000000000000000000000000;;			DirAvailableCheck{Path: "/var/lib/kubelet"},
0000000000000000000000000000000000000000;;			FileContentCheck{Path: bridgenf, Content: []byte{'1'}},
0000000000000000000000000000000000000000;;			InPathCheck{executable: "ip", mandatory: true},
0000000000000000000000000000000000000000;;			InPathCheck{executable: "iptables", mandatory: true},
0000000000000000000000000000000000000000;;			InPathCheck{executable: "mount", mandatory: true},
0000000000000000000000000000000000000000;;			InPathCheck{executable: "nsenter", mandatory: true},
0000000000000000000000000000000000000000;;			InPathCheck{executable: "ebtables", mandatory: false},
0000000000000000000000000000000000000000;;			InPathCheck{executable: "ethtool", mandatory: false},
0000000000000000000000000000000000000000;;			InPathCheck{executable: "socat", mandatory: false},
0000000000000000000000000000000000000000;;			InPathCheck{executable: "tc", mandatory: false},
0000000000000000000000000000000000000000;;			InPathCheck{executable: "touch", mandatory: false},
0000000000000000000000000000000000000000;;			ExtraArgsCheck{
0000000000000000000000000000000000000000;;				APIServerExtraArgs:         cfg.APIServerExtraArgs,
0000000000000000000000000000000000000000;;				ControllerManagerExtraArgs: cfg.ControllerManagerExtraArgs,
0000000000000000000000000000000000000000;;				SchedulerExtraArgs:         cfg.SchedulerExtraArgs,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(cfg.Etcd.Endpoints) == 0 {
0000000000000000000000000000000000000000;;			// Only do etcd related checks when no external endpoints were specified
0000000000000000000000000000000000000000;;			checks = append(checks,
0000000000000000000000000000000000000000;;				PortOpenCheck{port: 2379},
0000000000000000000000000000000000000000;;				DirAvailableCheck{Path: cfg.Etcd.DataDir},
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Only check etcd version when external endpoints are specified
0000000000000000000000000000000000000000;;			checks = append(checks,
0000000000000000000000000000000000000000;;				ExternalEtcdVersionCheck{Etcd: cfg.Etcd},
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check the config for authorization mode
0000000000000000000000000000000000000000;;		for _, authzMode := range cfg.AuthorizationModes {
0000000000000000000000000000000000000000;;			switch authzMode {
0000000000000000000000000000000000000000;;			case authzmodes.ModeABAC:
0000000000000000000000000000000000000000;;				checks = append(checks, FileExistingCheck{Path: kubeadmconstants.AuthorizationPolicyPath})
0000000000000000000000000000000000000000;;			case authzmodes.ModeWebhook:
0000000000000000000000000000000000000000;;				checks = append(checks, FileExistingCheck{Path: kubeadmconstants.AuthorizationWebhookConfigPath})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return RunChecks(checks, os.Stderr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunJoinNodeChecks(cfg *kubeadmapi.NodeConfiguration) error {
0000000000000000000000000000000000000000;;		// First, check if we're root separately from the other preflight checks and fail fast
0000000000000000000000000000000000000000;;		if err := RunRootCheckOnly(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		checks := []Checker{
0000000000000000000000000000000000000000;;			SystemVerificationCheck{},
0000000000000000000000000000000000000000;;			IsRootCheck{},
0000000000000000000000000000000000000000;;			HostnameCheck{},
0000000000000000000000000000000000000000;;			ServiceCheck{Service: "kubelet", CheckIfActive: false},
0000000000000000000000000000000000000000;;			ServiceCheck{Service: "docker", CheckIfActive: true},
0000000000000000000000000000000000000000;;			PortOpenCheck{port: 10250},
0000000000000000000000000000000000000000;;			DirAvailableCheck{Path: filepath.Join(kubeadmapi.GlobalEnvParams.KubernetesDir, kubeadmconstants.ManifestsSubDirName)},
0000000000000000000000000000000000000000;;			DirAvailableCheck{Path: "/var/lib/kubelet"},
0000000000000000000000000000000000000000;;			FileAvailableCheck{Path: cfg.CACertPath},
0000000000000000000000000000000000000000;;			FileAvailableCheck{Path: filepath.Join(kubeadmapi.GlobalEnvParams.KubernetesDir, kubeadmconstants.KubeletKubeConfigFileName)},
0000000000000000000000000000000000000000;;			FileContentCheck{Path: bridgenf, Content: []byte{'1'}},
0000000000000000000000000000000000000000;;			InPathCheck{executable: "ip", mandatory: true},
0000000000000000000000000000000000000000;;			InPathCheck{executable: "iptables", mandatory: true},
0000000000000000000000000000000000000000;;			InPathCheck{executable: "mount", mandatory: true},
0000000000000000000000000000000000000000;;			InPathCheck{executable: "nsenter", mandatory: true},
0000000000000000000000000000000000000000;;			InPathCheck{executable: "ebtables", mandatory: false},
0000000000000000000000000000000000000000;;			InPathCheck{executable: "ethtool", mandatory: false},
0000000000000000000000000000000000000000;;			InPathCheck{executable: "socat", mandatory: false},
0000000000000000000000000000000000000000;;			InPathCheck{executable: "tc", mandatory: false},
0000000000000000000000000000000000000000;;			InPathCheck{executable: "touch", mandatory: false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return RunChecks(checks, os.Stderr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunRootCheckOnly() error {
0000000000000000000000000000000000000000;;		checks := []Checker{
0000000000000000000000000000000000000000;;			IsRootCheck{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return RunChecks(checks, os.Stderr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunChecks runs each check, displays it's warnings/errors, and once all
0000000000000000000000000000000000000000;;	// are processed will exit if any errors occurred.
0000000000000000000000000000000000000000;;	func RunChecks(checks []Checker, ww io.Writer) error {
0000000000000000000000000000000000000000;;		found := []error{}
0000000000000000000000000000000000000000;;		for _, c := range checks {
0000000000000000000000000000000000000000;;			warnings, errs := c.Check()
0000000000000000000000000000000000000000;;			for _, w := range warnings {
0000000000000000000000000000000000000000;;				io.WriteString(ww, fmt.Sprintf("[preflight] WARNING: %v\n", w))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			found = append(found, errs...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(found) > 0 {
0000000000000000000000000000000000000000;;			var errs bytes.Buffer
0000000000000000000000000000000000000000;;			for _, i := range found {
0000000000000000000000000000000000000000;;				errs.WriteString("\t" + i.Error() + "\n")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &Error{Msg: errs.String()}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TryStartKubelet() {
0000000000000000000000000000000000000000;;		// If we notice that the kubelet service is inactive, try to start it
0000000000000000000000000000000000000000;;		initSystem, err := initsystem.GetInitSystem()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Println("[preflight] No supported init system detected, won't ensure kubelet is running.")
0000000000000000000000000000000000000000;;		} else if initSystem.ServiceExists("kubelet") && !initSystem.ServiceIsActive("kubelet") {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fmt.Println("[preflight] Starting the kubelet service")
0000000000000000000000000000000000000000;;			if err := initSystem.ServiceStart("kubelet"); err != nil {
0000000000000000000000000000000000000000;;				fmt.Printf("[preflight] WARNING: Unable to start the kubelet service: [%v]\n", err)
0000000000000000000000000000000000000000;;				fmt.Println("[preflight] WARNING: Please ensure kubelet is running manually.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
