0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6e3ee84dfd4d24a005a7b2fa9a61bcf457b48352;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package file
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/constants"
0000000000000000000000000000000000000000;;		kubeconfigutil "k8s.io/kubernetes/cmd/kubeadm/app/util/kubeconfig"
0000000000000000000000000000000000000000;;		bootstrapapi "k8s.io/kubernetes/pkg/bootstrap/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RetrieveValidatedClusterInfo connects to the API Server and makes sure it can talk
0000000000000000000000000000000000000000;;	// securely to the API Server using the provided CA cert and
0000000000000000000000000000000000000000;;	// optionally refreshes the cluster-info information from the cluster-info ConfigMap
0000000000000000000000000000000000000000;;	func RetrieveValidatedClusterInfo(filepath string) (*clientcmdapi.Cluster, error) {
0000000000000000000000000000000000000000;;		clusterinfo, err := clientcmd.LoadFromFile(filepath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ValidateClusterInfo(clusterinfo)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateClusterInfo connects to the API Server and makes sure it can talk
0000000000000000000000000000000000000000;;	// securely to the API Server using the provided CA cert and
0000000000000000000000000000000000000000;;	// optionally refreshes the cluster-info information from the cluster-info ConfigMap
0000000000000000000000000000000000000000;;	func ValidateClusterInfo(clusterinfo *clientcmdapi.Config) (*clientcmdapi.Cluster, error) {
0000000000000000000000000000000000000000;;		err := validateClusterInfoKubeConfig(clusterinfo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This is the cluster object we've got from the cluster-info KubeConfig file
0000000000000000000000000000000000000000;;		defaultCluster := kubeconfigutil.GetClusterFromKubeConfig(clusterinfo)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a new kubeconfig object from the given, just copy over the server and the CA cert
0000000000000000000000000000000000000000;;		// We do this in order to not pick up other possible misconfigurations in the clusterinfo file
0000000000000000000000000000000000000000;;		configFromClusterInfo := kubeconfigutil.CreateBasic(
0000000000000000000000000000000000000000;;			defaultCluster.Server,
0000000000000000000000000000000000000000;;			"kubernetes",
0000000000000000000000000000000000000000;;			"", // no user provided
0000000000000000000000000000000000000000;;			defaultCluster.CertificateAuthorityData,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client, err := kubeconfigutil.KubeConfigToClientSet(configFromClusterInfo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Printf("[discovery] Created cluster-info discovery client, requesting info from %q\n", defaultCluster.Server)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var clusterinfoCM *v1.ConfigMap
0000000000000000000000000000000000000000;;		wait.PollInfinite(constants.DiscoveryRetryInterval, func() (bool, error) {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			clusterinfoCM, err = client.CoreV1().ConfigMaps(metav1.NamespacePublic).Get(bootstrapapi.ConfigMapClusterInfo, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if apierrors.IsForbidden(err) {
0000000000000000000000000000000000000000;;					// If the request is unauthorized, the cluster admin has not granted access to the cluster info configmap for unauthenicated users
0000000000000000000000000000000000000000;;					// In that case, trust the cluster admin and do not refresh the cluster-info credentials
0000000000000000000000000000000000000000;;					fmt.Printf("[discovery] Could not access the %s ConfigMap for refreshing the cluster-info information, but the TLS cert is valid so proceeding...\n", bootstrapapi.ConfigMapClusterInfo)
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fmt.Printf("[discovery] Failed to validate the API Server's identity, will try again: [%v]\n", err)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we couldn't fetch the cluster-info ConfigMap, just return the cluster-info object the user provided
0000000000000000000000000000000000000000;;		if clusterinfoCM == nil {
0000000000000000000000000000000000000000;;			return defaultCluster, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We somehow got hold of the ConfigMap, try to read some data from it. If we can't, fallback on the user-provided file
0000000000000000000000000000000000000000;;		refreshedBaseKubeConfig, err := tryParseClusterInfoFromConfigMap(clusterinfoCM)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Printf("[discovery] The %s ConfigMap isn't set up properly (%v), but the TLS cert is valid so proceeding...\n", bootstrapapi.ConfigMapClusterInfo, err)
0000000000000000000000000000000000000000;;			return defaultCluster, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Println("[discovery] Synced cluster-info information from the API Server so we have got the latest information")
0000000000000000000000000000000000000000;;		// In an HA world in the future, this will make more sense, because now we've got new information, possibly about new API Servers to talk to
0000000000000000000000000000000000000000;;		return kubeconfigutil.GetClusterFromKubeConfig(refreshedBaseKubeConfig), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tryParseClusterInfoFromConfigMap tries to parse a kubeconfig file from a ConfigMap key
0000000000000000000000000000000000000000;;	func tryParseClusterInfoFromConfigMap(cm *v1.ConfigMap) (*clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;		kubeConfigString, ok := cm.Data[bootstrapapi.KubeConfigKey]
0000000000000000000000000000000000000000;;		if !ok || len(kubeConfigString) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no %s key in ConfigMap", bootstrapapi.KubeConfigKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parsedKubeConfig, err := clientcmd.Load([]byte(kubeConfigString))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't parse the kubeconfig file in the %s ConfigMap: %v", bootstrapapi.ConfigMapClusterInfo, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parsedKubeConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateClusterInfoKubeConfig makes sure the user-provided cluster-info KubeConfig file is valid
0000000000000000000000000000000000000000;;	func validateClusterInfoKubeConfig(clusterinfo *clientcmdapi.Config) error {
0000000000000000000000000000000000000000;;		if len(clusterinfo.Clusters) < 1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("the provided cluster-info KubeConfig file must have at least one Cluster defined")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defaultCluster := kubeconfigutil.GetClusterFromKubeConfig(clusterinfo)
0000000000000000000000000000000000000000;;		if defaultCluster == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("the provided cluster-info KubeConfig file must have an unnamed Cluster or a CurrentContext that specifies a non-nil Cluster")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
