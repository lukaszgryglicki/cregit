0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6e3ee84dfd4d24a005a7b2fa9a61bcf457b48352;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package token
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/constants"
0000000000000000000000000000000000000000;;		kubeconfigutil "k8s.io/kubernetes/cmd/kubeadm/app/util/kubeconfig"
0000000000000000000000000000000000000000;;		tokenutil "k8s.io/kubernetes/cmd/kubeadm/app/util/token"
0000000000000000000000000000000000000000;;		bootstrapapi "k8s.io/kubernetes/pkg/bootstrap/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/bootstrap"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const BootstrapUser = "token-bootstrap-client"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RetrieveValidatedClusterInfo connects to the API Server and tries to fetch the cluster-info ConfigMap
0000000000000000000000000000000000000000;;	// It then makes sure it can trust the API Server by looking at the JWS-signed tokens
0000000000000000000000000000000000000000;;	func RetrieveValidatedClusterInfo(discoveryToken string, tokenAPIServers []string) (*clientcmdapi.Cluster, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokenId, tokenSecret, err := tokenutil.ParseToken(discoveryToken)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The function below runs for every endpoint, and all endpoints races with each other.
0000000000000000000000000000000000000000;;		// The endpoint that wins the race and completes the task first gets its kubeconfig returned below
0000000000000000000000000000000000000000;;		baseKubeConfig := runForEndpointsAndReturnFirst(tokenAPIServers, func(endpoint string) (*clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			bootstrapConfig := buildInsecureBootstrapKubeConfig(endpoint)
0000000000000000000000000000000000000000;;			clusterName := bootstrapConfig.Contexts[bootstrapConfig.CurrentContext].Cluster
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			client, err := kubeconfigutil.KubeConfigToClientSet(bootstrapConfig)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fmt.Printf("[discovery] Created cluster-info discovery client, requesting info from %q\n", bootstrapConfig.Clusters[clusterName].Server)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var clusterinfo *v1.ConfigMap
0000000000000000000000000000000000000000;;			wait.PollImmediateInfinite(constants.DiscoveryRetryInterval, func() (bool, error) {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				clusterinfo, err = client.CoreV1().ConfigMaps(metav1.NamespacePublic).Get(bootstrapapi.ConfigMapClusterInfo, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					fmt.Printf("[discovery] Failed to request cluster info, will try again: [%s]\n", err)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			kubeConfigString, ok := clusterinfo.Data[bootstrapapi.KubeConfigKey]
0000000000000000000000000000000000000000;;			if !ok || len(kubeConfigString) == 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("there is no %s key in the %s ConfigMap. This API Server isn't set up for token bootstrapping, can't connect", bootstrapapi.KubeConfigKey, bootstrapapi.ConfigMapClusterInfo)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			detachedJWSToken, ok := clusterinfo.Data[bootstrapapi.JWSSignatureKeyPrefix+tokenId]
0000000000000000000000000000000000000000;;			if !ok || len(detachedJWSToken) == 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("there is no JWS signed token in the %s ConfigMap. This token id %q is invalid for this cluster, can't connect", bootstrapapi.ConfigMapClusterInfo, tokenId)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !bootstrap.DetachedTokenIsValid(detachedJWSToken, kubeConfigString, tokenId, tokenSecret) {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("failed to verify JWS signature of received cluster info object, can't trust this API Server")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			finalConfig, err := clientcmd.Load([]byte(kubeConfigString))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("couldn't parse the kubeconfig file in the %s configmap: %v", bootstrapapi.ConfigMapClusterInfo, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fmt.Printf("[discovery] Cluster info signature and contents are valid, will use API Server %q\n", bootstrapConfig.Clusters[clusterName].Server)
0000000000000000000000000000000000000000;;			return finalConfig, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return kubeconfigutil.GetClusterFromKubeConfig(baseKubeConfig), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildInsecureBootstrapKubeConfig makes a KubeConfig object that connects insecurely to the API Server for bootstrapping purposes
0000000000000000000000000000000000000000;;	func buildInsecureBootstrapKubeConfig(endpoint string) *clientcmdapi.Config {
0000000000000000000000000000000000000000;;		masterEndpoint := fmt.Sprintf("https://%s", endpoint)
0000000000000000000000000000000000000000;;		clusterName := "kubernetes"
0000000000000000000000000000000000000000;;		bootstrapConfig := kubeconfigutil.CreateBasic(masterEndpoint, clusterName, BootstrapUser, []byte{})
0000000000000000000000000000000000000000;;		bootstrapConfig.Clusters[clusterName].InsecureSkipTLSVerify = true
0000000000000000000000000000000000000000;;		return bootstrapConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// runForEndpointsAndReturnFirst loops the endpoints slice and let's the endpoints race for connecting to the master
0000000000000000000000000000000000000000;;	func runForEndpointsAndReturnFirst(endpoints []string, fetchKubeConfigFunc func(string) (*clientcmdapi.Config, error)) *clientcmdapi.Config {
0000000000000000000000000000000000000000;;		stopChan := make(chan struct{})
0000000000000000000000000000000000000000;;		var resultingKubeConfig *clientcmdapi.Config
0000000000000000000000000000000000000000;;		var once sync.Once
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		for _, endpoint := range endpoints {
0000000000000000000000000000000000000000;;			wg.Add(1)
0000000000000000000000000000000000000000;;			go func(apiEndpoint string) {
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;				wait.Until(func() {
0000000000000000000000000000000000000000;;					fmt.Printf("[discovery] Trying to connect to API Server %q\n", apiEndpoint)
0000000000000000000000000000000000000000;;					cfg, err := fetchKubeConfigFunc(apiEndpoint)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						fmt.Printf("[discovery] Failed to connect to API Server %q: %v\n", apiEndpoint, err)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					fmt.Printf("[discovery] Successfully established connection with API Server %q\n", apiEndpoint)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// connection established, stop all wait threads
0000000000000000000000000000000000000000;;					once.Do(func() {
0000000000000000000000000000000000000000;;						close(stopChan)
0000000000000000000000000000000000000000;;						resultingKubeConfig = cfg
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				}, constants.DiscoveryRetryInterval, stopChan)
0000000000000000000000000000000000000000;;			}(endpoint)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		return resultingKubeConfig
0000000000000000000000000000000000000000;;	}
