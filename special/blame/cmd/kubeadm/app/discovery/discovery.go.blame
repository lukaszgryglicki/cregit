0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6e3ee84dfd4d24a005a7b2fa9a61bcf457b48352;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package discovery
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		kubeadmapi "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/discovery/file"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/discovery/https"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/discovery/token"
0000000000000000000000000000000000000000;;		kubeconfigutil "k8s.io/kubernetes/cmd/kubeadm/app/util/kubeconfig"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const TokenUser = "tls-bootstrap-token-user"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// For returns a KubeConfig object that can be used for doing the TLS Bootstrap with the right credentials
0000000000000000000000000000000000000000;;	// Also, before returning anything, it makes sure it can trust the API Server
0000000000000000000000000000000000000000;;	func For(cfg *kubeadmapi.NodeConfiguration) (*clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;		// TODO: Print summary info about the CA certificate, along with the the checksum signature
0000000000000000000000000000000000000000;;		// we also need an ability for the user to configure the client to validate received CA cert against a checksum
0000000000000000000000000000000000000000;;		clusterinfo, err := GetValidatedClusterInfoObject(cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't validate the identity of the API Server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return kubeconfigutil.CreateWithToken(
0000000000000000000000000000000000000000;;			clusterinfo.Server,
0000000000000000000000000000000000000000;;			"kubernetes",
0000000000000000000000000000000000000000;;			TokenUser,
0000000000000000000000000000000000000000;;			clusterinfo.CertificateAuthorityData,
0000000000000000000000000000000000000000;;			cfg.TLSBootstrapToken,
0000000000000000000000000000000000000000;;		), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetValidatedClusterInfoObject returns a validated Cluster object that specifies where the cluster is and the CA cert to trust
0000000000000000000000000000000000000000;;	func GetValidatedClusterInfoObject(cfg *kubeadmapi.NodeConfiguration) (*clientcmdapi.Cluster, error) {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case len(cfg.DiscoveryFile) != 0:
0000000000000000000000000000000000000000;;			if isHTTPSURL(cfg.DiscoveryFile) {
0000000000000000000000000000000000000000;;				return https.RetrieveValidatedClusterInfo(cfg.DiscoveryFile)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return file.RetrieveValidatedClusterInfo(cfg.DiscoveryFile)
0000000000000000000000000000000000000000;;		case len(cfg.DiscoveryToken) != 0:
0000000000000000000000000000000000000000;;			return token.RetrieveValidatedClusterInfo(cfg.DiscoveryToken, cfg.DiscoveryTokenAPIServers)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't find a valid discovery configuration.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isHTTPSURL checks whether the string is parsable as an URL
0000000000000000000000000000000000000000;;	func isHTTPSURL(s string) bool {
0000000000000000000000000000000000000000;;		u, err := url.Parse(s)
0000000000000000000000000000000000000000;;		return err == nil && u.Scheme == "https"
0000000000000000000000000000000000000000;;	}
