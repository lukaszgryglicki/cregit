0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
9db0eae9e9d83114763752acc01f8cf31dda41c2;pkg/kubeadm/cmd/join.go[pkg/kubeadm/cmd/join.go][cmd/kubeadm/app/cmd/join.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/renstrom/dedent"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		certutil "k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;		kubeadmapi "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm"
0000000000000000000000000000000000000000;;		kubeadmapiext "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/validation"
0000000000000000000000000000000000000000;;		kubeadmconstants "k8s.io/kubernetes/cmd/kubeadm/app/constants"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/discovery"
0000000000000000000000000000000000000000;;		kubeadmnode "k8s.io/kubernetes/cmd/kubeadm/app/node"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/preflight"
0000000000000000000000000000000000000000;;		kubeadmutil "k8s.io/kubernetes/cmd/kubeadm/app/util"
0000000000000000000000000000000000000000;;		kubeconfigutil "k8s.io/kubernetes/cmd/kubeadm/app/util/kubeconfig"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		nodeutil "k8s.io/kubernetes/pkg/util/node"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		joinDoneMsgf = dedent.Dedent(`
0000000000000000000000000000000000000000;;			Node join complete:
0000000000000000000000000000000000000000;;			* Certificate signing request sent to master and response
0000000000000000000000000000000000000000;;			  received.
0000000000000000000000000000000000000000;;			* Kubelet informed of new secure connection details.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Run 'kubectl get nodes' on the master to see this machine join.
0000000000000000000000000000000000000000;;			`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCmdJoin returns "kubeadm join" command.
0000000000000000000000000000000000000000;;	func NewCmdJoin(out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		cfg := &kubeadmapiext.NodeConfiguration{}
0000000000000000000000000000000000000000;;		api.Scheme.Default(cfg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var skipPreFlight bool
0000000000000000000000000000000000000000;;		var cfgPath string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "join <flags> [DiscoveryTokenAPIServers]",
0000000000000000000000000000000000000000;;			Short: "Run this on any machine you wish to join an existing cluster",
0000000000000000000000000000000000000000;;			Long: dedent.Dedent(`
0000000000000000000000000000000000000000;;			When joining a kubeadm initialized cluster, we need to establish
0000000000000000000000000000000000000000;;			bidirectional trust. This is split into discovery (having the Node
0000000000000000000000000000000000000000;;			trust the Kubernetes Master) and TLS bootstrap (having the Kubernetes
0000000000000000000000000000000000000000;;			Master trust the Node).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			There are 2 main schemes for discovery. The first is to use a shared
0000000000000000000000000000000000000000;;			token along with the IP address of the API server. The second is to
0000000000000000000000000000000000000000;;			provide a file (a subset of the standard kubeconfig file). This file
0000000000000000000000000000000000000000;;			can be a local file or downloaded via an HTTPS URL. The forms are
0000000000000000000000000000000000000000;;			kubeadm join --discovery-token abcdef.1234567890abcdef 1.2.3.4:6443,
0000000000000000000000000000000000000000;;			kubeadm join --discovery-file path/to/file.conf, or kubeadm join
0000000000000000000000000000000000000000;;			--discovery-file https://url/file.conf. Only one form can be used. If
0000000000000000000000000000000000000000;;			the discovery information is loaded from a URL, HTTPS must be used and
0000000000000000000000000000000000000000;;			the host installed CA bundle is used to verify the connection.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			The TLS bootstrap mechanism is also driven via a shared token. This is
0000000000000000000000000000000000000000;;			used to temporarily authenticate with the Kubernetes Master to submit a
0000000000000000000000000000000000000000;;			certificate signing request (CSR) for a locally created key pair. By
0000000000000000000000000000000000000000;;			default kubeadm will set up the Kubernetes Master to automatically
0000000000000000000000000000000000000000;;			approve these signing requests. This token is passed in with the
0000000000000000000000000000000000000000;;			--tls-bootstrap-token abcdef.1234567890abcdef flag.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Often times the same token is used for both parts. In this case, the
0000000000000000000000000000000000000000;;			--token flag can be used instead of specifying each token individually.
0000000000000000000000000000000000000000;;			`),
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cfg.DiscoveryTokenAPIServers = args
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				api.Scheme.Default(cfg)
0000000000000000000000000000000000000000;;				internalcfg := &kubeadmapi.NodeConfiguration{}
0000000000000000000000000000000000000000;;				api.Scheme.Convert(cfg, internalcfg, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				j, err := NewJoin(cfgPath, args, internalcfg, skipPreFlight)
0000000000000000000000000000000000000000;;				kubeadmutil.CheckErr(err)
0000000000000000000000000000000000000000;;				kubeadmutil.CheckErr(j.Validate(cmd))
0000000000000000000000000000000000000000;;				kubeadmutil.CheckErr(j.Run(out))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().StringVar(
0000000000000000000000000000000000000000;;			&cfgPath, "config", cfgPath,
0000000000000000000000000000000000000000;;			"Path to kubeadm config file")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().StringVar(
0000000000000000000000000000000000000000;;			&cfg.DiscoveryFile, "discovery-file", "",
0000000000000000000000000000000000000000;;			"A file or url from which to load cluster information")
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().StringVar(
0000000000000000000000000000000000000000;;			&cfg.DiscoveryToken, "discovery-token", "",
0000000000000000000000000000000000000000;;			"A token used to validate cluster information fetched from the master")
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().StringVar(
0000000000000000000000000000000000000000;;			&cfg.NodeName, "node-name", "",
0000000000000000000000000000000000000000;;			"Specify the node name")
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().StringVar(
0000000000000000000000000000000000000000;;			&cfg.TLSBootstrapToken, "tls-bootstrap-token", "",
0000000000000000000000000000000000000000;;			"A token used for TLS bootstrapping")
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().StringVar(
0000000000000000000000000000000000000000;;			&cfg.Token, "token", "",
0000000000000000000000000000000000000000;;			"Use this token for both discovery-token and tls-bootstrap-token")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().BoolVar(
0000000000000000000000000000000000000000;;			&skipPreFlight, "skip-preflight-checks", false,
0000000000000000000000000000000000000000;;			"Skip preflight checks normally run before modifying the system",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Join struct {
0000000000000000000000000000000000000000;;		cfg *kubeadmapi.NodeConfiguration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewJoin(cfgPath string, args []string, cfg *kubeadmapi.NodeConfiguration, skipPreFlight bool) (*Join, error) {
0000000000000000000000000000000000000000;;		fmt.Println("[kubeadm] WARNING: kubeadm is in beta, please do not use it for production clusters.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cfgPath != "" {
0000000000000000000000000000000000000000;;			b, err := ioutil.ReadFile(cfgPath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unable to read config from %q [%v]", cfgPath, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := runtime.DecodeInto(api.Codecs.UniversalDecoder(), b, cfg); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unable to decode config from %q [%v]", cfgPath, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !skipPreFlight {
0000000000000000000000000000000000000000;;			fmt.Println("[preflight] Running pre-flight checks")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Then continue with the others...
0000000000000000000000000000000000000000;;			if err := preflight.RunJoinNodeChecks(cfg); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Try to start the kubelet service in case it's inactive
0000000000000000000000000000000000000000;;			preflight.TryStartKubelet()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			fmt.Println("[preflight] Skipping pre-flight checks")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Join{cfg: cfg}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *Join) Validate(cmd *cobra.Command) error {
0000000000000000000000000000000000000000;;		if err := validation.ValidateMixedArguments(cmd.PersistentFlags()); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return validation.ValidateNodeConfiguration(j.cfg).ToAggregate()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run executes worker node provisioning and tries to join an existing cluster.
0000000000000000000000000000000000000000;;	func (j *Join) Run(out io.Writer) error {
0000000000000000000000000000000000000000;;		cfg, err := discovery.For(j.cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostname := nodeutil.GetHostname(j.cfg.NodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client, err := kubeconfigutil.KubeConfigToClientSet(cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := kubeadmnode.ValidateAPIServer(client); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := kubeadmnode.PerformTLSBootstrap(cfg, hostname); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeconfigFile := filepath.Join(kubeadmapi.GlobalEnvParams.KubernetesDir, kubeadmconstants.KubeletKubeConfigFileName)
0000000000000000000000000000000000000000;;		if err := kubeconfigutil.WriteToDisk(kubeconfigFile, cfg); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write the ca certificate to disk so kubelet can use it for authentication
0000000000000000000000000000000000000000;;		cluster := cfg.Contexts[cfg.CurrentContext].Cluster
0000000000000000000000000000000000000000;;		err = certutil.WriteCert(j.cfg.CACertPath, cfg.Clusters[cluster].CertificateAuthorityData)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("couldn't save the CA certificate to disk: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintf(out, joinDoneMsgf)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
