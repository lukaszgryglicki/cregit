0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
869bed86fc6075b0a701fbfd7839103aef3fafa4;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"text/tabwriter"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/renstrom/dedent"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		clientset "k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		kubeadmapi "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm"
0000000000000000000000000000000000000000;;		kubeadmconstants "k8s.io/kubernetes/cmd/kubeadm/app/constants"
0000000000000000000000000000000000000000;;		tokenphase "k8s.io/kubernetes/cmd/kubeadm/app/phases/token"
0000000000000000000000000000000000000000;;		kubeadmutil "k8s.io/kubernetes/cmd/kubeadm/app/util"
0000000000000000000000000000000000000000;;		kubeconfigutil "k8s.io/kubernetes/cmd/kubeadm/app/util/kubeconfig"
0000000000000000000000000000000000000000;;		tokenutil "k8s.io/kubernetes/cmd/kubeadm/app/util/token"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		bootstrapapi "k8s.io/kubernetes/pkg/bootstrap/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdToken(out io.Writer, errW io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var kubeConfigFile string
0000000000000000000000000000000000000000;;		tokenCmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "token",
0000000000000000000000000000000000000000;;			Short: "Manage bootstrap tokens.",
0000000000000000000000000000000000000000;;			Long: dedent.Dedent(`
0000000000000000000000000000000000000000;;				This command will manage Bootstrap Token for you.
0000000000000000000000000000000000000000;;				  Please note this usage of this command is optional, and mostly for advanced users.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				In short, Bootstrap Tokens are used for establishing bidirectional trust between a client and a server.
0000000000000000000000000000000000000000;;				A Bootstrap Token can be used when a client (for example a node that's about to join the cluster) needs
0000000000000000000000000000000000000000;;				to trust the server it is talking to. Then a Bootstrap Token with the "signing" usage can be used.
0000000000000000000000000000000000000000;;				Bootstrap Tokens can also function as a way to allow short-lived authentication to the API Server
0000000000000000000000000000000000000000;;				(the token serves as a way for the API Server to trust the client), for example for doing the TLS Bootstrap.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				What is a Bootstrap Token more exactly?
0000000000000000000000000000000000000000;;				 - It is a Secret in the kube-system namespace of type "bootstrap.kubernetes.io/token".
0000000000000000000000000000000000000000;;				 - A Bootstrap Token must be of the form "[a-z0-9]{6}.[a-z0-9]{16}"; the former part is the public Token ID,
0000000000000000000000000000000000000000;;				   and the latter is the Token Secret, which must be kept private at all circumstances.
0000000000000000000000000000000000000000;;				 - The name of the Secret must be named "bootstrap-token-(token-id)".
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				You can read more about Bootstrap Tokens in this proposal:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				  https://git.k8s.io/community/contributors/design-proposals/bootstrap-discovery.md
0000000000000000000000000000000000000000;;			`),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Without this callback, if a user runs just the "token"
0000000000000000000000000000000000000000;;			// command without a subcommand, or with an invalid subcommand,
0000000000000000000000000000000000000000;;			// cobra will print usage information, but still exit cleanly.
0000000000000000000000000000000000000000;;			// We want to return an error code in these cases so that the
0000000000000000000000000000000000000000;;			// user knows that their command was invalid.
0000000000000000000000000000000000000000;;			RunE: func(cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;				if len(args) < 1 {
0000000000000000000000000000000000000000;;					return errors.New("missing subcommand; 'token' is not meant to be run on its own")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return fmt.Errorf("invalid subcommand: %s", args[0])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokenCmd.PersistentFlags().StringVar(&kubeConfigFile,
0000000000000000000000000000000000000000;;			"kubeconfig", "/etc/kubernetes/admin.conf", "The KubeConfig file to use for talking to the cluster")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var usages []string
0000000000000000000000000000000000000000;;		var tokenDuration time.Duration
0000000000000000000000000000000000000000;;		var description string
0000000000000000000000000000000000000000;;		createCmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "create [token]",
0000000000000000000000000000000000000000;;			Short: "Create bootstrap tokens on the server.",
0000000000000000000000000000000000000000;;			Long: dedent.Dedent(`
0000000000000000000000000000000000000000;;				This command will create a Bootstrap Token for you.
0000000000000000000000000000000000000000;;				You can specify the usages for this token, the time to live and an optional human friendly description.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				The [token] is the actual token to write.
0000000000000000000000000000000000000000;;				This should be a securely generated random token of the form "[a-z0-9]{6}.[a-z0-9]{16}".
0000000000000000000000000000000000000000;;				If no [token] is given, kubeadm will generate a random token instead.
0000000000000000000000000000000000000000;;			`),
0000000000000000000000000000000000000000;;			Run: func(tokenCmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				token := ""
0000000000000000000000000000000000000000;;				if len(args) != 0 {
0000000000000000000000000000000000000000;;					token = args[0]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				client, err := kubeconfigutil.ClientSetFromFile(kubeConfigFile)
0000000000000000000000000000000000000000;;				kubeadmutil.CheckErr(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = RunCreateToken(out, client, token, tokenDuration, usages, description)
0000000000000000000000000000000000000000;;				kubeadmutil.CheckErr(err)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		createCmd.Flags().DurationVar(&tokenDuration,
0000000000000000000000000000000000000000;;			"ttl", kubeadmconstants.DefaultTokenDuration, "The duration before the token is automatically deleted (e.g. 1s, 2m, 3h). 0 means 'never expires'.")
0000000000000000000000000000000000000000;;		createCmd.Flags().StringSliceVar(&usages,
0000000000000000000000000000000000000000;;			"usages", kubeadmconstants.DefaultTokenUsages, "The ways in which this token can be used. Valid options: [signing,authentication].")
0000000000000000000000000000000000000000;;		createCmd.Flags().StringVar(&description,
0000000000000000000000000000000000000000;;			"description", "", "A human friendly description of how this token is used.")
0000000000000000000000000000000000000000;;		tokenCmd.AddCommand(createCmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokenCmd.AddCommand(NewCmdTokenGenerate(out))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listCmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "list",
0000000000000000000000000000000000000000;;			Short: "List bootstrap tokens on the server.",
0000000000000000000000000000000000000000;;			Long: dedent.Dedent(`
0000000000000000000000000000000000000000;;				This command will list all Bootstrap Tokens for you.
0000000000000000000000000000000000000000;;			`),
0000000000000000000000000000000000000000;;			Run: func(tokenCmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				client, err := kubeconfigutil.ClientSetFromFile(kubeConfigFile)
0000000000000000000000000000000000000000;;				kubeadmutil.CheckErr(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = RunListTokens(out, errW, client)
0000000000000000000000000000000000000000;;				kubeadmutil.CheckErr(err)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tokenCmd.AddCommand(listCmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deleteCmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "delete [token-value]",
0000000000000000000000000000000000000000;;			Short: "Delete bootstrap tokens on the server.",
0000000000000000000000000000000000000000;;			Long: dedent.Dedent(`
0000000000000000000000000000000000000000;;				This command will delete a given Bootstrap Token for you.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				The [token-value] is the full Token of the form "[a-z0-9]{6}.[a-z0-9]{16}" or the
0000000000000000000000000000000000000000;;				Token ID of the form "[a-z0-9]{6}" to delete.
0000000000000000000000000000000000000000;;			`),
0000000000000000000000000000000000000000;;			Run: func(tokenCmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				if len(args) < 1 {
0000000000000000000000000000000000000000;;					kubeadmutil.CheckErr(fmt.Errorf("missing subcommand; 'token delete' is missing token of form [%q]", tokenutil.TokenIDRegexpString))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				client, err := kubeconfigutil.ClientSetFromFile(kubeConfigFile)
0000000000000000000000000000000000000000;;				kubeadmutil.CheckErr(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = RunDeleteToken(out, client, args[0])
0000000000000000000000000000000000000000;;				kubeadmutil.CheckErr(err)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tokenCmd.AddCommand(deleteCmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tokenCmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdTokenGenerate(out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		return &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "generate",
0000000000000000000000000000000000000000;;			Short: "Generate and print a bootstrap token, but do not create it on the server.",
0000000000000000000000000000000000000000;;			Long: dedent.Dedent(`
0000000000000000000000000000000000000000;;				This command will print out a randomly-generated bootstrap token that can be used with
0000000000000000000000000000000000000000;;				the "init" and "join" commands.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				You don't have to use this command in order to generate a token, you can do so
0000000000000000000000000000000000000000;;				yourself as long as it's in the format "[a-z0-9]{6}.[a-z0-9]{16}". This
0000000000000000000000000000000000000000;;				command is provided for convenience to generate tokens in that format.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				You can also use "kubeadm init" without specifying a token, and it will
0000000000000000000000000000000000000000;;				generate and print one for you.
0000000000000000000000000000000000000000;;			`),
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				err := RunGenerateToken(out)
0000000000000000000000000000000000000000;;				kubeadmutil.CheckErr(err)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunCreateToken generates a new bootstrap token and stores it as a secret on the server.
0000000000000000000000000000000000000000;;	func RunCreateToken(out io.Writer, client *clientset.Clientset, token string, tokenDuration time.Duration, usages []string, description string) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(token) == 0 {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			token, err = tokenutil.GenerateToken()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			_, _, err := tokenutil.ParseToken(token)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Validate usages here so we don't allow something unsupported
0000000000000000000000000000000000000000;;		err := tokenphase.CreateNewToken(client, token, tokenDuration, usages, description)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintln(out, token)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunGenerateToken just generates a random token for the user
0000000000000000000000000000000000000000;;	func RunGenerateToken(out io.Writer) error {
0000000000000000000000000000000000000000;;		token, err := tokenutil.GenerateToken()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintln(out, token)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunListTokens lists details on all existing bootstrap tokens on the server.
0000000000000000000000000000000000000000;;	func RunListTokens(out io.Writer, errW io.Writer, client *clientset.Clientset) error {
0000000000000000000000000000000000000000;;		// First, build our selector for bootstrap tokens only
0000000000000000000000000000000000000000;;		tokenSelector := fields.SelectorFromSet(
0000000000000000000000000000000000000000;;			map[string]string{
0000000000000000000000000000000000000000;;				api.SecretTypeField: string(bootstrapapi.SecretTypeBootstrapToken),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		listOptions := metav1.ListOptions{
0000000000000000000000000000000000000000;;			FieldSelector: tokenSelector.String(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secrets, err := client.CoreV1().Secrets(metav1.NamespaceSystem).List(listOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to list bootstrap tokens [%v]", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := tabwriter.NewWriter(out, 10, 4, 3, ' ', 0)
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "TOKEN\tTTL\tEXPIRES\tUSAGES\tDESCRIPTION")
0000000000000000000000000000000000000000;;		for _, secret := range secrets.Items {
0000000000000000000000000000000000000000;;			tokenId := getSecretString(&secret, bootstrapapi.BootstrapTokenIDKey)
0000000000000000000000000000000000000000;;			if len(tokenId) == 0 {
0000000000000000000000000000000000000000;;				fmt.Fprintf(errW, "bootstrap token has no token-id data: %s\n", secret.Name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// enforce the right naming convention
0000000000000000000000000000000000000000;;			if secret.Name != fmt.Sprintf("%s%s", bootstrapapi.BootstrapTokenSecretPrefix, tokenId) {
0000000000000000000000000000000000000000;;				fmt.Fprintf(errW, "bootstrap token name is not of the form '%s(token-id)': %s\n", bootstrapapi.BootstrapTokenSecretPrefix, secret.Name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tokenSecret := getSecretString(&secret, bootstrapapi.BootstrapTokenSecretKey)
0000000000000000000000000000000000000000;;			if len(tokenSecret) == 0 {
0000000000000000000000000000000000000000;;				fmt.Fprintf(errW, "bootstrap token has no token-secret data: %s\n", secret.Name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			td := &kubeadmapi.TokenDiscovery{ID: tokenId, Secret: tokenSecret}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Expiration time is optional, if not specified this implies the token
0000000000000000000000000000000000000000;;			// never expires.
0000000000000000000000000000000000000000;;			ttl := "<forever>"
0000000000000000000000000000000000000000;;			expires := "<never>"
0000000000000000000000000000000000000000;;			secretExpiration := getSecretString(&secret, bootstrapapi.BootstrapTokenExpirationKey)
0000000000000000000000000000000000000000;;			if len(secretExpiration) > 0 {
0000000000000000000000000000000000000000;;				expireTime, err := time.Parse(time.RFC3339, secretExpiration)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					fmt.Fprintf(errW, "can't parse expiration time of bootstrap token %s\n", secret.Name)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ttl = printers.ShortHumanDuration(expireTime.Sub(time.Now()))
0000000000000000000000000000000000000000;;				expires = expireTime.Format(time.RFC3339)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			usages := []string{}
0000000000000000000000000000000000000000;;			for k, v := range secret.Data {
0000000000000000000000000000000000000000;;				// Skip all fields that don't include this prefix
0000000000000000000000000000000000000000;;				if !strings.Contains(k, bootstrapapi.BootstrapTokenUsagePrefix) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Skip those that don't have this usage set to true
0000000000000000000000000000000000000000;;				if string(v) != "true" {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				usages = append(usages, strings.TrimPrefix(k, bootstrapapi.BootstrapTokenUsagePrefix))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Strings(usages)
0000000000000000000000000000000000000000;;			usageString := strings.Join(usages, ",")
0000000000000000000000000000000000000000;;			if len(usageString) == 0 {
0000000000000000000000000000000000000000;;				usageString = "<none>"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			description := getSecretString(&secret, bootstrapapi.BootstrapTokenDescriptionKey)
0000000000000000000000000000000000000000;;			if len(description) == 0 {
0000000000000000000000000000000000000000;;				description = "<none>"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "%s\t%s\t%s\t%s\t%s\n", tokenutil.BearerToken(td), ttl, expires, usageString, description)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Flush()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunDeleteToken removes a bootstrap token from the server.
0000000000000000000000000000000000000000;;	func RunDeleteToken(out io.Writer, client *clientset.Clientset, tokenIdOrToken string) error {
0000000000000000000000000000000000000000;;		// Assume the given first argument is a token id and try to parse it
0000000000000000000000000000000000000000;;		tokenId := tokenIdOrToken
0000000000000000000000000000000000000000;;		if err := tokenutil.ParseTokenID(tokenIdOrToken); err != nil {
0000000000000000000000000000000000000000;;			if tokenId, _, err = tokenutil.ParseToken(tokenIdOrToken); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("given token or token id %q didn't match pattern [%q] or [%q]", tokenIdOrToken, tokenutil.TokenIDRegexpString, tokenutil.TokenRegexpString)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokenSecretName := fmt.Sprintf("%s%s", bootstrapapi.BootstrapTokenSecretPrefix, tokenId)
0000000000000000000000000000000000000000;;		if err := client.CoreV1().Secrets(metav1.NamespaceSystem).Delete(tokenSecretName, nil); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to delete bootstrap token [%v]", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintf(out, "bootstrap token with id %q deleted\n", tokenId)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSecretString(secret *v1.Secret, key string) string {
0000000000000000000000000000000000000000;;		if secret.Data == nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if val, ok := secret.Data[key]; ok {
0000000000000000000000000000000000000000;;			return string(val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
