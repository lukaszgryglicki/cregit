0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
9db0eae9e9d83114763752acc01f8cf31dda41c2;pkg/kubeadm/cmd/init.go[pkg/kubeadm/cmd/init.go][cmd/kubeadm/app/cmd/init.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"text/template"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/renstrom/dedent"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		kubeadmapi "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm"
0000000000000000000000000000000000000000;;		kubeadmapiext "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/validation"
0000000000000000000000000000000000000000;;		cmdphases "k8s.io/kubernetes/cmd/kubeadm/app/cmd/phases"
0000000000000000000000000000000000000000;;		kubeadmconstants "k8s.io/kubernetes/cmd/kubeadm/app/constants"
0000000000000000000000000000000000000000;;		addonsphase "k8s.io/kubernetes/cmd/kubeadm/app/phases/addons"
0000000000000000000000000000000000000000;;		apiconfigphase "k8s.io/kubernetes/cmd/kubeadm/app/phases/apiconfig"
0000000000000000000000000000000000000000;;		controlplanephase "k8s.io/kubernetes/cmd/kubeadm/app/phases/controlplane"
0000000000000000000000000000000000000000;;		kubeconfigphase "k8s.io/kubernetes/cmd/kubeadm/app/phases/kubeconfig"
0000000000000000000000000000000000000000;;		selfhostingphase "k8s.io/kubernetes/cmd/kubeadm/app/phases/selfhosting"
0000000000000000000000000000000000000000;;		tokenphase "k8s.io/kubernetes/cmd/kubeadm/app/phases/token"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/preflight"
0000000000000000000000000000000000000000;;		kubeadmutil "k8s.io/kubernetes/cmd/kubeadm/app/util"
0000000000000000000000000000000000000000;;		configutil "k8s.io/kubernetes/cmd/kubeadm/app/util/config"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/version"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		initDoneTempl = template.Must(template.New("init").Parse(dedent.Dedent(`
0000000000000000000000000000000000000000;;			Your Kubernetes master has initialized successfully!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			To start using your cluster, you need to run (as a regular user):
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			  mkdir -p $HOME/.kube
0000000000000000000000000000000000000000;;			  sudo cp -i {{.KubeConfigPath}} $HOME/.kube/config
0000000000000000000000000000000000000000;;			  sudo chown $(id -u):$(id -g) $HOME/.kube/config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			You should now deploy a pod network to the cluster.
0000000000000000000000000000000000000000;;			Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:
0000000000000000000000000000000000000000;;			  http://kubernetes.io/docs/admin/addons/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			You can now join any number of machines by running the following on each node
0000000000000000000000000000000000000000;;			as root:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			  kubeadm join --token {{.Token}} {{.MasterIP}}:{{.MasterPort}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			`)))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCmdInit returns "kubeadm init" command.
0000000000000000000000000000000000000000;;	func NewCmdInit(out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		cfg := &kubeadmapiext.MasterConfiguration{}
0000000000000000000000000000000000000000;;		api.Scheme.Default(cfg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var cfgPath string
0000000000000000000000000000000000000000;;		var skipPreFlight bool
0000000000000000000000000000000000000000;;		var skipTokenPrint bool
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "init",
0000000000000000000000000000000000000000;;			Short: "Run this in order to set up the Kubernetes master",
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				api.Scheme.Default(cfg)
0000000000000000000000000000000000000000;;				internalcfg := &kubeadmapi.MasterConfiguration{}
0000000000000000000000000000000000000000;;				api.Scheme.Convert(cfg, internalcfg, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				i, err := NewInit(cfgPath, internalcfg, skipPreFlight, skipTokenPrint)
0000000000000000000000000000000000000000;;				kubeadmutil.CheckErr(err)
0000000000000000000000000000000000000000;;				kubeadmutil.CheckErr(i.Validate(cmd))
0000000000000000000000000000000000000000;;				kubeadmutil.CheckErr(i.Run(out))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().StringVar(
0000000000000000000000000000000000000000;;			&cfg.API.AdvertiseAddress, "apiserver-advertise-address", cfg.API.AdvertiseAddress,
0000000000000000000000000000000000000000;;			"The IP address the API Server will advertise it's listening on. 0.0.0.0 means the default network interface's address.",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().Int32Var(
0000000000000000000000000000000000000000;;			&cfg.API.BindPort, "apiserver-bind-port", cfg.API.BindPort,
0000000000000000000000000000000000000000;;			"Port for the API Server to bind to",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().StringVar(
0000000000000000000000000000000000000000;;			&cfg.Networking.ServiceSubnet, "service-cidr", cfg.Networking.ServiceSubnet,
0000000000000000000000000000000000000000;;			"Use alternative range of IP address for service VIPs",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().StringVar(
0000000000000000000000000000000000000000;;			&cfg.Networking.PodSubnet, "pod-network-cidr", cfg.Networking.PodSubnet,
0000000000000000000000000000000000000000;;			"Specify range of IP addresses for the pod network; if set, the control plane will automatically allocate CIDRs for every node",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().StringVar(
0000000000000000000000000000000000000000;;			&cfg.Networking.DNSDomain, "service-dns-domain", cfg.Networking.DNSDomain,
0000000000000000000000000000000000000000;;			`Use alternative domain for services, e.g. "myorg.internal"`,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().StringVar(
0000000000000000000000000000000000000000;;			&cfg.KubernetesVersion, "kubernetes-version", cfg.KubernetesVersion,
0000000000000000000000000000000000000000;;			`Choose a specific Kubernetes version for the control plane`,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().StringVar(
0000000000000000000000000000000000000000;;			&cfg.CertificatesDir, "cert-dir", cfg.CertificatesDir,
0000000000000000000000000000000000000000;;			`The path where to save and store the certificates`,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().StringSliceVar(
0000000000000000000000000000000000000000;;			&cfg.APIServerCertSANs, "apiserver-cert-extra-sans", cfg.APIServerCertSANs,
0000000000000000000000000000000000000000;;			`Optional extra altnames to use for the API Server serving cert. Can be both IP addresses and dns names.`,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().StringVar(
0000000000000000000000000000000000000000;;			&cfg.NodeName, "node-name", cfg.NodeName,
0000000000000000000000000000000000000000;;			`Specify the node name`,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().StringVar(&cfgPath, "config", cfgPath, "Path to kubeadm config file (WARNING: Usage of a configuration file is experimental)")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().BoolVar(
0000000000000000000000000000000000000000;;			&skipPreFlight, "skip-preflight-checks", skipPreFlight,
0000000000000000000000000000000000000000;;			"Skip preflight checks normally run before modifying the system",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().BoolVar(
0000000000000000000000000000000000000000;;			&skipTokenPrint, "skip-token-print", skipTokenPrint,
0000000000000000000000000000000000000000;;			"Skip printing of the default bootstrap token generated by 'kubeadm init'",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().BoolVar(
0000000000000000000000000000000000000000;;			&cfg.SelfHosted, "self-hosted", cfg.SelfHosted,
0000000000000000000000000000000000000000;;			"[experimental] If kubeadm should make this control plane self-hosted",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().StringVar(
0000000000000000000000000000000000000000;;			&cfg.Token, "token", cfg.Token,
0000000000000000000000000000000000000000;;			"The token to use for establishing bidirectional trust between nodes and masters.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().DurationVar(
0000000000000000000000000000000000000000;;			&cfg.TokenTTL, "token-ttl", cfg.TokenTTL,
0000000000000000000000000000000000000000;;			"The duration before the bootstrap token is automatically deleted. 0 means 'never expires'.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewInit(cfgPath string, cfg *kubeadmapi.MasterConfiguration, skipPreFlight, skipTokenPrint bool) (*Init, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Println("[kubeadm] WARNING: kubeadm is in beta, please do not use it for production clusters.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cfgPath != "" {
0000000000000000000000000000000000000000;;			b, err := ioutil.ReadFile(cfgPath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unable to read config from %q [%v]", cfgPath, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := runtime.DecodeInto(api.Codecs.UniversalDecoder(), b, cfg); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unable to decode config from %q [%v]", cfgPath, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set defaults dynamically that the API group defaulting can't (by fetching information from the internet, looking up network interfaces, etc.)
0000000000000000000000000000000000000000;;		err := configutil.SetInitDynamicDefaults(cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Printf("[init] Using Kubernetes version: %s\n", cfg.KubernetesVersion)
0000000000000000000000000000000000000000;;		fmt.Printf("[init] Using Authorization mode: %v\n", cfg.AuthorizationModes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Warn about the limitations with the current cloudprovider solution.
0000000000000000000000000000000000000000;;		if cfg.CloudProvider != "" {
0000000000000000000000000000000000000000;;			fmt.Println("[init] WARNING: For cloudprovider integrations to work --cloud-provider must be set for all kubelets in the cluster.")
0000000000000000000000000000000000000000;;			fmt.Println("\t(/etc/systemd/system/kubelet.service.d/10-kubeadm.conf should be edited for this purpose)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !skipPreFlight {
0000000000000000000000000000000000000000;;			fmt.Println("[preflight] Running pre-flight checks")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := preflight.RunInitMasterChecks(cfg); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Try to start the kubelet service in case it's inactive
0000000000000000000000000000000000000000;;			preflight.TryStartKubelet()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			fmt.Println("[preflight] Skipping pre-flight checks")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Init{cfg: cfg, skipTokenPrint: skipTokenPrint}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Init struct {
0000000000000000000000000000000000000000;;		cfg            *kubeadmapi.MasterConfiguration
0000000000000000000000000000000000000000;;		skipTokenPrint bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate validates configuration passed to "kubeadm init"
0000000000000000000000000000000000000000;;	func (i *Init) Validate(cmd *cobra.Command) error {
0000000000000000000000000000000000000000;;		if err := validation.ValidateMixedArguments(cmd.Flags()); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return validation.ValidateMasterConfiguration(i.cfg).ToAggregate()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run executes master node provisioning, including certificates, needed static pod manifests, etc.
0000000000000000000000000000000000000000;;	func (i *Init) Run(out io.Writer) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PHASE 1: Generate certificates
0000000000000000000000000000000000000000;;		err := cmdphases.CreatePKIAssets(i.cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PHASE 2: Generate kubeconfig files for the admin and the kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		masterEndpoint := fmt.Sprintf("https://%s:%d", i.cfg.API.AdvertiseAddress, i.cfg.API.BindPort)
0000000000000000000000000000000000000000;;		err = kubeconfigphase.CreateInitKubeConfigFiles(masterEndpoint, i.cfg.CertificatesDir, kubeadmapi.GlobalEnvParams.KubernetesDir, i.cfg.NodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PHASE 3: Bootstrap the control plane
0000000000000000000000000000000000000000;;		if err := controlplanephase.WriteStaticPodManifests(i.cfg); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		adminKubeConfigPath := filepath.Join(kubeadmapi.GlobalEnvParams.KubernetesDir, kubeadmconstants.AdminKubeConfigFileName)
0000000000000000000000000000000000000000;;		client, err := kubeadmutil.CreateClientAndWaitForAPI(adminKubeConfigPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := apiconfigphase.UpdateMasterRoleLabelsAndTaints(client, i.cfg.NodeName); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PHASE 4: Set up the bootstrap tokens
0000000000000000000000000000000000000000;;		if !i.skipTokenPrint {
0000000000000000000000000000000000000000;;			fmt.Printf("[token] Using token: %s\n", i.cfg.Token)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokenDescription := "The default bootstrap token generated by 'kubeadm init'."
0000000000000000000000000000000000000000;;		if err := tokenphase.UpdateOrCreateToken(client, i.cfg.Token, false, i.cfg.TokenTTL, kubeadmconstants.DefaultTokenUsages, tokenDescription); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := tokenphase.CreateBootstrapConfigMapIfNotExists(client, adminKubeConfigPath); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PHASE 5: Install and deploy all addons, and configure things as necessary
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		k8sVersion, err := version.ParseSemantic(i.cfg.KubernetesVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("couldn't parse kubernetes version %q: %v", i.cfg.KubernetesVersion, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the necessary ServiceAccounts
0000000000000000000000000000000000000000;;		err = apiconfigphase.CreateServiceAccounts(client)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = apiconfigphase.CreateRBACRules(client, k8sVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := addonsphase.CreateEssentialAddons(i.cfg, client); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is deployment type self-hosted?
0000000000000000000000000000000000000000;;		if i.cfg.SelfHosted {
0000000000000000000000000000000000000000;;			// Temporary control plane is up, now we create our self hosted control
0000000000000000000000000000000000000000;;			// plane components and remove the static manifests:
0000000000000000000000000000000000000000;;			fmt.Println("[self-hosted] Creating self-hosted control plane...")
0000000000000000000000000000000000000000;;			if err := selfhostingphase.CreateSelfHostedControlPlane(i.cfg, client); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx := map[string]string{
0000000000000000000000000000000000000000;;			"KubeConfigPath": filepath.Join(kubeadmapi.GlobalEnvParams.KubernetesDir, kubeadmconstants.AdminKubeConfigFileName),
0000000000000000000000000000000000000000;;			"KubeConfigName": kubeadmconstants.AdminKubeConfigFileName,
0000000000000000000000000000000000000000;;			"Token":          i.cfg.Token,
0000000000000000000000000000000000000000;;			"MasterIP":       i.cfg.API.AdvertiseAddress,
0000000000000000000000000000000000000000;;			"MasterPort":     strconv.Itoa(int(i.cfg.API.BindPort)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i.skipTokenPrint {
0000000000000000000000000000000000000000;;			ctx["Token"] = "<value withheld>"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return initDoneTempl.Execute(out, ctx)
0000000000000000000000000000000000000000;;	}
