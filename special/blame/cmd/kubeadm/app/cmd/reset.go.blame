0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
9f3d2758b7da853e89fac1583aeef4633d4a7d06;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeadmapi "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm"
0000000000000000000000000000000000000000;;		kubeadmapiext "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1alpha1"
0000000000000000000000000000000000000000;;		kubeadmconstants "k8s.io/kubernetes/cmd/kubeadm/app/constants"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/preflight"
0000000000000000000000000000000000000000;;		kubeadmutil "k8s.io/kubernetes/cmd/kubeadm/app/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/initsystem"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCmdReset returns the "kubeadm reset" command
0000000000000000000000000000000000000000;;	func NewCmdReset(out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		var skipPreFlight bool
0000000000000000000000000000000000000000;;		var certsDir string
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "reset",
0000000000000000000000000000000000000000;;			Short: "Run this to revert any changes made to this host by 'kubeadm init' or 'kubeadm join'.",
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				r, err := NewReset(skipPreFlight, certsDir)
0000000000000000000000000000000000000000;;				kubeadmutil.CheckErr(err)
0000000000000000000000000000000000000000;;				kubeadmutil.CheckErr(r.Run(out))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().BoolVar(
0000000000000000000000000000000000000000;;			&skipPreFlight, "skip-preflight-checks", false,
0000000000000000000000000000000000000000;;			"Skip preflight checks normally run before modifying the system",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().StringVar(
0000000000000000000000000000000000000000;;			&certsDir, "cert-dir", kubeadmapiext.DefaultCertificatesDir,
0000000000000000000000000000000000000000;;			"The path to the directory where the certificates are stored. If specified, clean this directory.",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Reset struct {
0000000000000000000000000000000000000000;;		certsDir string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewReset(skipPreFlight bool, certsDir string) (*Reset, error) {
0000000000000000000000000000000000000000;;		if !skipPreFlight {
0000000000000000000000000000000000000000;;			fmt.Println("[preflight] Running pre-flight checks")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := preflight.RunRootCheckOnly(); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			fmt.Println("[preflight] Skipping pre-flight checks")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Reset{
0000000000000000000000000000000000000000;;			certsDir: certsDir,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run reverts any changes made to this host by "kubeadm init" or "kubeadm join".
0000000000000000000000000000000000000000;;	func (r *Reset) Run(out io.Writer) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try to stop the kubelet service
0000000000000000000000000000000000000000;;		initSystem, err := initsystem.GetInitSystem()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Println("[reset] WARNING: The kubelet service couldn't be stopped by kubeadm because no supported init system was detected.")
0000000000000000000000000000000000000000;;			fmt.Println("[reset] WARNING: Please ensure kubelet is stopped manually.")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			fmt.Println("[reset] Stopping the kubelet service")
0000000000000000000000000000000000000000;;			if err := initSystem.ServiceStop("kubelet"); err != nil {
0000000000000000000000000000000000000000;;				fmt.Printf("[reset] WARNING: The kubelet service couldn't be stopped by kubeadm: [%v]\n", err)
0000000000000000000000000000000000000000;;				fmt.Println("[reset] WARNING: Please ensure kubelet is stopped manually.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try to unmount mounted directories under /var/lib/kubelet in order to be able to remove the /var/lib/kubelet directory later
0000000000000000000000000000000000000000;;		fmt.Printf("[reset] Unmounting mounted directories in %q\n", "/var/lib/kubelet")
0000000000000000000000000000000000000000;;		umountDirsCmd := "cat /proc/mounts | awk '{print $2}' | grep '/var/lib/kubelet' | xargs -r umount"
0000000000000000000000000000000000000000;;		umountOutputBytes, err := exec.Command("sh", "-c", umountDirsCmd).Output()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Printf("[reset] Failed to unmount mounted directories in /var/lib/kubelet: %s\n", string(umountOutputBytes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockerCheck := preflight.ServiceCheck{Service: "docker", CheckIfActive: true}
0000000000000000000000000000000000000000;;		if _, errors := dockerCheck.Check(); len(errors) == 0 {
0000000000000000000000000000000000000000;;			fmt.Println("[reset] Removing kubernetes-managed containers")
0000000000000000000000000000000000000000;;			if err := exec.Command("sh", "-c", "docker ps -a --filter name=k8s_ -q | xargs -r docker rm --force --volumes").Run(); err != nil {
0000000000000000000000000000000000000000;;				fmt.Println("[reset] Failed to stop the running containers")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			fmt.Println("[reset] docker doesn't seem to be running, skipping the removal of running kubernetes containers")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dirsToClean := []string{"/var/lib/kubelet", "/etc/cni/net.d", "/var/lib/dockershim"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Only clear etcd data when the etcd manifest is found. In case it is not found, we must assume that the user
0000000000000000000000000000000000000000;;		// provided external etcd endpoints. In that case, it is his own responsibility to reset etcd
0000000000000000000000000000000000000000;;		etcdManifestPath := filepath.Join(kubeadmapi.GlobalEnvParams.KubernetesDir, kubeadmconstants.ManifestsSubDirName, "etcd.yaml")
0000000000000000000000000000000000000000;;		if _, err := os.Stat(etcdManifestPath); err == nil {
0000000000000000000000000000000000000000;;			dirsToClean = append(dirsToClean, "/var/lib/etcd")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			fmt.Printf("[reset] No etcd manifest found in %q, assuming external etcd.\n", etcdManifestPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Then clean contents from the stateful kubelet, etcd and cni directories
0000000000000000000000000000000000000000;;		fmt.Printf("[reset] Deleting contents of stateful directories: %v\n", dirsToClean)
0000000000000000000000000000000000000000;;		for _, dir := range dirsToClean {
0000000000000000000000000000000000000000;;			cleanDir(dir)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove contents from the config and pki directories
0000000000000000000000000000000000000000;;		resetConfigDir(kubeadmapi.GlobalEnvParams.KubernetesDir, r.certsDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cleanDir removes everything in a directory, but not the directory itself
0000000000000000000000000000000000000000;;	func cleanDir(filePath string) error {
0000000000000000000000000000000000000000;;		// If the directory doesn't even exist there's nothing to do, and we do
0000000000000000000000000000000000000000;;		// not consider this an error
0000000000000000000000000000000000000000;;		if _, err := os.Stat(filePath); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d, err := os.Open(filePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer d.Close()
0000000000000000000000000000000000000000;;		names, err := d.Readdirnames(-1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, name := range names {
0000000000000000000000000000000000000000;;			if err = os.RemoveAll(filepath.Join(filePath, name)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resetConfigDir is used to cleanup the files kubeadm writes in /etc/kubernetes/.
0000000000000000000000000000000000000000;;	func resetConfigDir(configPathDir, pkiPathDir string) {
0000000000000000000000000000000000000000;;		dirsToClean := []string{
0000000000000000000000000000000000000000;;			filepath.Join(configPathDir, kubeadmconstants.ManifestsSubDirName),
0000000000000000000000000000000000000000;;			pkiPathDir,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Printf("[reset] Deleting contents of config directories: %v\n", dirsToClean)
0000000000000000000000000000000000000000;;		for _, dir := range dirsToClean {
0000000000000000000000000000000000000000;;			if err := cleanDir(dir); err != nil {
0000000000000000000000000000000000000000;;				fmt.Printf("[reset] Failed to remove directory: %q [%v]\n", dir, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		filesToClean := []string{
0000000000000000000000000000000000000000;;			filepath.Join(configPathDir, kubeadmconstants.AdminKubeConfigFileName),
0000000000000000000000000000000000000000;;			filepath.Join(configPathDir, kubeadmconstants.KubeletKubeConfigFileName),
0000000000000000000000000000000000000000;;			filepath.Join(configPathDir, kubeadmconstants.ControllerManagerKubeConfigFileName),
0000000000000000000000000000000000000000;;			filepath.Join(configPathDir, kubeadmconstants.SchedulerKubeConfigFileName),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Printf("[reset] Deleting files: %v\n", filesToClean)
0000000000000000000000000000000000000000;;		for _, path := range filesToClean {
0000000000000000000000000000000000000000;;			if err := os.RemoveAll(path); err != nil {
0000000000000000000000000000000000000000;;				fmt.Printf("[reset] Failed to remove file: %q [%v]\n", path, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
