0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
106020fc98394e7e914bf13d3b141515d6d530ae;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package phases
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeadmapi "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm"
0000000000000000000000000000000000000000;;		kubeadmapiext "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/validation"
0000000000000000000000000000000000000000;;		kubeadmconstants "k8s.io/kubernetes/cmd/kubeadm/app/constants"
0000000000000000000000000000000000000000;;		certphase "k8s.io/kubernetes/cmd/kubeadm/app/phases/certs"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/phases/certs/pkiutil"
0000000000000000000000000000000000000000;;		kubeadmutil "k8s.io/kubernetes/cmd/kubeadm/app/util"
0000000000000000000000000000000000000000;;		configutil "k8s.io/kubernetes/cmd/kubeadm/app/util/config"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdCerts() *cobra.Command {
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "certs",
0000000000000000000000000000000000000000;;			Aliases: []string{"certificates"},
0000000000000000000000000000000000000000;;			Short:   "Generate certificates for a Kubernetes cluster.",
0000000000000000000000000000000000000000;;			RunE:    subCmdRunE("certs"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.AddCommand(newSubCmdCerts()...)
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newSubCmdCerts returns sub commands for certs phase
0000000000000000000000000000000000000000;;	func newSubCmdCerts() []*cobra.Command {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg := &kubeadmapiext.MasterConfiguration{}
0000000000000000000000000000000000000000;;		// Default values for the cobra help text
0000000000000000000000000000000000000000;;		api.Scheme.Default(cfg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var cfgPath string
0000000000000000000000000000000000000000;;		var subCmds []*cobra.Command
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		subCmdProperties := []struct {
0000000000000000000000000000000000000000;;			use     string
0000000000000000000000000000000000000000;;			short   string
0000000000000000000000000000000000000000;;			cmdFunc func(cfg *kubeadmapi.MasterConfiguration) error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				use:     "all",
0000000000000000000000000000000000000000;;				short:   "Generate all PKI assets necessary to establish the control plane",
0000000000000000000000000000000000000000;;				cmdFunc: CreatePKIAssets,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				use:     "ca",
0000000000000000000000000000000000000000;;				short:   "Generate CA certificate and key for a Kubernetes cluster.",
0000000000000000000000000000000000000000;;				cmdFunc: createOrUseCACertAndKey,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				use:     "apiserver",
0000000000000000000000000000000000000000;;				short:   "Generate API Server serving certificate and key.",
0000000000000000000000000000000000000000;;				cmdFunc: createOrUseAPIServerCertAndKey,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				use:     "apiserver-kubelet-client",
0000000000000000000000000000000000000000;;				short:   "Generate a client certificate for the API Server to connect to the kubelets securely.",
0000000000000000000000000000000000000000;;				cmdFunc: createOrUseAPIServerKubeletClientCertAndKey,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				use:     "sa",
0000000000000000000000000000000000000000;;				short:   "Generate a private key for signing service account tokens along with its public key.",
0000000000000000000000000000000000000000;;				cmdFunc: createOrUseServiceAccountKeyAndPublicKey,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				use:     "front-proxy-ca",
0000000000000000000000000000000000000000;;				short:   "Generate front proxy CA certificate and key for a Kubernetes cluster.",
0000000000000000000000000000000000000000;;				cmdFunc: createOrUseFrontProxyCACertAndKey,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				use:     "front-proxy-client",
0000000000000000000000000000000000000000;;				short:   "Generate front proxy CA client certificate and key for a Kubernetes cluster.",
0000000000000000000000000000000000000000;;				cmdFunc: createOrUseFrontProxyClientCertAndKey,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, properties := range subCmdProperties {
0000000000000000000000000000000000000000;;			// Creates the UX Command
0000000000000000000000000000000000000000;;			cmd := &cobra.Command{
0000000000000000000000000000000000000000;;				Use:   properties.use,
0000000000000000000000000000000000000000;;				Short: properties.short,
0000000000000000000000000000000000000000;;				Run:   runCmdFunc(properties.cmdFunc, &cfgPath, cfg),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add flags to the command
0000000000000000000000000000000000000000;;			cmd.Flags().StringVar(&cfgPath, "config", cfgPath, "Path to kubeadm config file (WARNING: Usage of a configuration file is experimental)")
0000000000000000000000000000000000000000;;			cmd.Flags().StringVar(&cfg.CertificatesDir, "cert-dir", cfg.CertificatesDir, "The path where to save and store the certificates")
0000000000000000000000000000000000000000;;			if properties.use == "all" || properties.use == "apiserver" {
0000000000000000000000000000000000000000;;				cmd.Flags().StringVar(&cfg.Networking.DNSDomain, "service-dns-domain", cfg.Networking.DNSDomain, "Use alternative domain for services, e.g. \"myorg.internal\"")
0000000000000000000000000000000000000000;;				cmd.Flags().StringVar(&cfg.Networking.ServiceSubnet, "service-cidr", cfg.Networking.ServiceSubnet, "Use alternative range of IP address for service VIPs")
0000000000000000000000000000000000000000;;				cmd.Flags().StringSliceVar(&cfg.APIServerCertSANs, "apiserver-cert-extra-sans", []string{}, "Optional extra altnames to use for the API Server serving cert. Can be both IP addresses and dns names.")
0000000000000000000000000000000000000000;;				cmd.Flags().StringVar(&cfg.API.AdvertiseAddress, "apiserver-advertise-address", cfg.API.AdvertiseAddress, "The IP address the API Server will advertise it's listening on. 0.0.0.0 means the default network interface's address.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			subCmds = append(subCmds, cmd)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return subCmds
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// runCmdFunc creates a cobra.Command Run function, by composing the call to the given cmdFunc with necessary additional steps (e.g preparation of inpunt parameters)
0000000000000000000000000000000000000000;;	func runCmdFunc(cmdFunc func(cfg *kubeadmapi.MasterConfiguration) error, cfgPath *string, cfg *kubeadmapiext.MasterConfiguration) func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the following statement build a clousure that wraps a call to a CreateCertFunc, binding
0000000000000000000000000000000000000000;;		// the function itself with the specific parameters of each sub command.
0000000000000000000000000000000000000000;;		// Please note that specific parameter should be passed as value, while other parameters - passed as reference -
0000000000000000000000000000000000000000;;		// are shared between sub commnands and gets access to current value e.g. flags value.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;			internalcfg := &kubeadmapi.MasterConfiguration{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Takes passed flags into account; the defaulting is executed once again enforcing assignement of
0000000000000000000000000000000000000000;;			// static default values to cfg only for values not provided with flags
0000000000000000000000000000000000000000;;			api.Scheme.Default(cfg)
0000000000000000000000000000000000000000;;			api.Scheme.Convert(cfg, internalcfg, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Loads configuration from config file, if provided
0000000000000000000000000000000000000000;;			// Nb. --config overrides command line flags
0000000000000000000000000000000000000000;;			err := configutil.TryLoadMasterConfiguration(*cfgPath, internalcfg)
0000000000000000000000000000000000000000;;			kubeadmutil.CheckErr(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Applies dynamic defaults to settings not provided with flags
0000000000000000000000000000000000000000;;			err = configutil.SetInitDynamicDefaults(internalcfg)
0000000000000000000000000000000000000000;;			kubeadmutil.CheckErr(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Validates cfg (flags/configs + defaults + dynamic defaults)
0000000000000000000000000000000000000000;;			err = validation.ValidateMasterConfiguration(internalcfg).ToAggregate()
0000000000000000000000000000000000000000;;			kubeadmutil.CheckErr(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Execute the cmdFunc
0000000000000000000000000000000000000000;;			err = cmdFunc(internalcfg)
0000000000000000000000000000000000000000;;			kubeadmutil.CheckErr(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreatePKIAssets will create and write to disk all PKI assets necessary to establish the control plane.
0000000000000000000000000000000000000000;;	// Please note that this action is a bulk action calling all the atomic certphase actions
0000000000000000000000000000000000000000;;	func CreatePKIAssets(cfg *kubeadmapi.MasterConfiguration) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certActions := []func(cfg *kubeadmapi.MasterConfiguration) error{
0000000000000000000000000000000000000000;;			createOrUseCACertAndKey,
0000000000000000000000000000000000000000;;			createOrUseAPIServerCertAndKey,
0000000000000000000000000000000000000000;;			createOrUseAPIServerKubeletClientCertAndKey,
0000000000000000000000000000000000000000;;			createOrUseServiceAccountKeyAndPublicKey,
0000000000000000000000000000000000000000;;			createOrUseFrontProxyCACertAndKey,
0000000000000000000000000000000000000000;;			createOrUseFrontProxyClientCertAndKey,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, action := range certActions {
0000000000000000000000000000000000000000;;			err := action(cfg)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Printf("[certificates] Valid certificates and keys now exist in %q\n", cfg.CertificatesDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createOrUseCACertAndKey create a new self signed CA, or use the existing one.
0000000000000000000000000000000000000000;;	func createOrUseCACertAndKey(cfg *kubeadmapi.MasterConfiguration) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return createOrUseCertificateAuthorithy(
0000000000000000000000000000000000000000;;			cfg.CertificatesDir,
0000000000000000000000000000000000000000;;			kubeadmconstants.CACertAndKeyBaseName,
0000000000000000000000000000000000000000;;			"CA",
0000000000000000000000000000000000000000;;			certphase.NewCACertAndKey,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createOrUseAPIServerCertAndKey create a new CA certificate for apiserver, or use the existing one.
0000000000000000000000000000000000000000;;	// It assumes the CA certificates should exists into the CertificatesDir
0000000000000000000000000000000000000000;;	func createOrUseAPIServerCertAndKey(cfg *kubeadmapi.MasterConfiguration) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return createOrUseSignedCertificate(
0000000000000000000000000000000000000000;;			cfg.CertificatesDir,
0000000000000000000000000000000000000000;;			kubeadmconstants.CACertAndKeyBaseName,
0000000000000000000000000000000000000000;;			kubeadmconstants.APIServerCertAndKeyBaseName,
0000000000000000000000000000000000000000;;			"API server",
0000000000000000000000000000000000000000;;			func(caCert *x509.Certificate, caKey *rsa.PrivateKey) (*x509.Certificate, *rsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;				return certphase.NewAPIServerCertAndKey(cfg, caCert, caKey)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// create a new CA certificate for kubelets calling apiserver, or use the existing one
0000000000000000000000000000000000000000;;	// It assumes the CA certificates should exists into the CertificatesDir
0000000000000000000000000000000000000000;;	func createOrUseAPIServerKubeletClientCertAndKey(cfg *kubeadmapi.MasterConfiguration) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return createOrUseSignedCertificate(
0000000000000000000000000000000000000000;;			cfg.CertificatesDir,
0000000000000000000000000000000000000000;;			kubeadmconstants.CACertAndKeyBaseName,
0000000000000000000000000000000000000000;;			kubeadmconstants.APIServerKubeletClientCertAndKeyBaseName,
0000000000000000000000000000000000000000;;			"API server kubelet client",
0000000000000000000000000000000000000000;;			certphase.NewAPIServerKubeletClientCertAndKey,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createOrUseServiceAccountKeyAndPublicKey create a new public/private key pairs for signing service account user, or use the existing one.
0000000000000000000000000000000000000000;;	func createOrUseServiceAccountKeyAndPublicKey(cfg *kubeadmapi.MasterConfiguration) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return createOrUseKeyAndPublicKey(
0000000000000000000000000000000000000000;;			cfg.CertificatesDir,
0000000000000000000000000000000000000000;;			kubeadmconstants.ServiceAccountKeyBaseName,
0000000000000000000000000000000000000000;;			"service account",
0000000000000000000000000000000000000000;;			certphase.NewServiceAccountSigningKey,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createOrUseFrontProxyCACertAndKey create a new self signed front proxy CA, or use the existing one.
0000000000000000000000000000000000000000;;	func createOrUseFrontProxyCACertAndKey(cfg *kubeadmapi.MasterConfiguration) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return createOrUseCertificateAuthorithy(
0000000000000000000000000000000000000000;;			cfg.CertificatesDir,
0000000000000000000000000000000000000000;;			kubeadmconstants.FrontProxyCACertAndKeyBaseName,
0000000000000000000000000000000000000000;;			"front-proxy CA",
0000000000000000000000000000000000000000;;			certphase.NewFrontProxyCACertAndKey,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createOrUseFrontProxyClientCertAndKey create a new certificate for proxy server client, or use the existing one.
0000000000000000000000000000000000000000;;	// It assumes the front proxy CA certificates should exists into the CertificatesDir
0000000000000000000000000000000000000000;;	func createOrUseFrontProxyClientCertAndKey(cfg *kubeadmapi.MasterConfiguration) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return createOrUseSignedCertificate(
0000000000000000000000000000000000000000;;			cfg.CertificatesDir,
0000000000000000000000000000000000000000;;			kubeadmconstants.FrontProxyCACertAndKeyBaseName,
0000000000000000000000000000000000000000;;			kubeadmconstants.FrontProxyClientCertAndKeyBaseName,
0000000000000000000000000000000000000000;;			"front-proxy client",
0000000000000000000000000000000000000000;;			certphase.NewFrontProxyClientCertAndKey,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createOrUseCertificateAuthorithy is a generic function that will create a new certificate Authorithy using the given newFunc,
0000000000000000000000000000000000000000;;	// assign file names according to the given baseName, or use the existing one already present in pkiDir.
0000000000000000000000000000000000000000;;	func createOrUseCertificateAuthorithy(pkiDir string, baseName string, UXName string, newFunc func() (*x509.Certificate, *rsa.PrivateKey, error)) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If cert or key exists, we should try to load them
0000000000000000000000000000000000000000;;		if pkiutil.CertOrKeyExist(pkiDir, baseName) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Try to load .crt and .key from the PKI directory
0000000000000000000000000000000000000000;;			caCert, _, err := pkiutil.TryLoadCertAndKeyFromDisk(pkiDir, baseName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failure loading %s certificate: %v", UXName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check if the existing cert is a CA
0000000000000000000000000000000000000000;;			if !caCert.IsCA {
0000000000000000000000000000000000000000;;				return fmt.Errorf("certificate %s is not a CA", UXName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fmt.Printf("[certificates] Using the existing %s certificate and key.\n", UXName)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// The certificate and the key did NOT exist, let's generate them now
0000000000000000000000000000000000000000;;			caCert, caKey, err := newFunc()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failure while generating %s certificate and key: %v", UXName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Write .crt and .key files to disk
0000000000000000000000000000000000000000;;			if err = pkiutil.WriteCertAndKey(pkiDir, baseName, caCert, caKey); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failure while saving %s certificate and key: %v", UXName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fmt.Printf("[certificates] Generated %s certificate and key.\n", UXName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createOrUseSignedCertificate is a generic function that will create a new signed certificate using the given newFunc,
0000000000000000000000000000000000000000;;	// assign file names according to the given baseName, or use the existing one already present in pkiDir.
0000000000000000000000000000000000000000;;	func createOrUseSignedCertificate(pkiDir string, CABaseName string, baseName string, UXName string, newFunc func(*x509.Certificate, *rsa.PrivateKey) (*x509.Certificate, *rsa.PrivateKey, error)) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Checks if certificate authorithy exists in the PKI directory
0000000000000000000000000000000000000000;;		if !pkiutil.CertOrKeyExist(pkiDir, CABaseName) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("couldn't load certificate authorithy for %s from certificate dir", UXName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try to load certificate authorithy .crt and .key from the PKI directory
0000000000000000000000000000000000000000;;		caCert, caKey, err := pkiutil.TryLoadCertAndKeyFromDisk(pkiDir, CABaseName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failure loading certificate authorithy for %s: %v", UXName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure the loaded CA cert actually is a CA
0000000000000000000000000000000000000000;;		if !caCert.IsCA {
0000000000000000000000000000000000000000;;			return fmt.Errorf("certificate authorithy for %s is not a CA", UXName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Checks if the signed certificate exists in the PKI directory
0000000000000000000000000000000000000000;;		if pkiutil.CertOrKeyExist(pkiDir, baseName) {
0000000000000000000000000000000000000000;;			// Try to load signed certificate .crt and .key from the PKI directory
0000000000000000000000000000000000000000;;			signedCert, _, err := pkiutil.TryLoadCertAndKeyFromDisk(pkiDir, baseName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failure loading %s certificate: %v", UXName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check if the existing cert is signed by the given CA
0000000000000000000000000000000000000000;;			if err := signedCert.CheckSignatureFrom(caCert); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("certificate %s is not signed by corresponding CA", UXName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fmt.Printf("[certificates] Using the existing %s certificate and key.\n", UXName)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// The certificate and the key did NOT exist, let's generate them now
0000000000000000000000000000000000000000;;			signedCert, signedKey, err := newFunc(caCert, caKey)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failure while generating %s key and certificate: %v", UXName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Write .crt and .key files to disk
0000000000000000000000000000000000000000;;			if err = pkiutil.WriteCertAndKey(pkiDir, baseName, signedCert, signedKey); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failure while saving %s certificate and key: %v", UXName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fmt.Printf("[certificates] Generated %s certificate and key.\n", UXName)
0000000000000000000000000000000000000000;;			if pkiutil.HasServerAuth(signedCert) {
0000000000000000000000000000000000000000;;				fmt.Printf("[certificates] %s serving cert is signed for DNS names %v and IPs %v\n", UXName, signedCert.DNSNames, signedCert.IPAddresses)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createOrUseKeyAndPublicKey is a generic function that will create a new public/private key pairs using the given newFunc,
0000000000000000000000000000000000000000;;	// assign file names according to the given baseName, or use the existing one already present in pkiDir.
0000000000000000000000000000000000000000;;	func createOrUseKeyAndPublicKey(pkiDir string, baseName string, UXName string, newFunc func() (*rsa.PrivateKey, error)) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Checks if the key exists in the PKI directory
0000000000000000000000000000000000000000;;		if pkiutil.CertOrKeyExist(pkiDir, baseName) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Try to load .key from the PKI directory
0000000000000000000000000000000000000000;;			_, err := pkiutil.TryLoadKeyFromDisk(pkiDir, baseName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("%s key existed but they could not be loaded properly: %v", UXName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fmt.Printf("[certificates] Using the existing %s key.\n", UXName)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// The key does NOT exist, let's generate it now
0000000000000000000000000000000000000000;;			key, err := newFunc()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failure while generating %s key: %v", UXName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Write .key and .pub files to disk
0000000000000000000000000000000000000000;;			if err = pkiutil.WriteKey(pkiDir, baseName, key); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failure while saving %s key: %v", UXName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err = pkiutil.WritePublicKey(pkiDir, baseName, &key.PublicKey); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failure while saving %s public key: %v", UXName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Printf("[certificates] Generated %s key and public key.\n", UXName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
