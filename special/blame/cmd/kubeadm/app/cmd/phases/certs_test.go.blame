0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
6b4ed7cd80ae3cb36edf5338baa4acbc3ada79ba;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package phases
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"html/template"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/renstrom/dedent"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// required for triggering api machinery startup when running unit tests
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/install"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeadmconstants "k8s.io/kubernetes/cmd/kubeadm/app/constants"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/phases/certs/pkiutil"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSubCmdCertsCreateFiles(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		subCmds := newSubCmdCerts()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			subCmds       []string
0000000000000000000000000000000000000000;;			expectedFiles []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				subCmds: []string{"all"},
0000000000000000000000000000000000000000;;				expectedFiles: []string{
0000000000000000000000000000000000000000;;					kubeadmconstants.CACertName, kubeadmconstants.CAKeyName,
0000000000000000000000000000000000000000;;					kubeadmconstants.APIServerCertName, kubeadmconstants.APIServerKeyName,
0000000000000000000000000000000000000000;;					kubeadmconstants.APIServerKubeletClientCertName, kubeadmconstants.APIServerKubeletClientKeyName,
0000000000000000000000000000000000000000;;					kubeadmconstants.ServiceAccountPrivateKeyName, kubeadmconstants.ServiceAccountPublicKeyName,
0000000000000000000000000000000000000000;;					kubeadmconstants.FrontProxyCACertName, kubeadmconstants.FrontProxyCAKeyName,
0000000000000000000000000000000000000000;;					kubeadmconstants.FrontProxyClientCertName, kubeadmconstants.FrontProxyClientKeyName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				subCmds:       []string{"ca"},
0000000000000000000000000000000000000000;;				expectedFiles: []string{kubeadmconstants.CACertName, kubeadmconstants.CAKeyName},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				subCmds:       []string{"ca", "apiserver"},
0000000000000000000000000000000000000000;;				expectedFiles: []string{kubeadmconstants.CACertName, kubeadmconstants.CAKeyName, kubeadmconstants.APIServerCertName, kubeadmconstants.APIServerKeyName},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				subCmds:       []string{"ca", "apiserver-kubelet-client"},
0000000000000000000000000000000000000000;;				expectedFiles: []string{kubeadmconstants.CACertName, kubeadmconstants.CAKeyName, kubeadmconstants.APIServerKubeletClientCertName, kubeadmconstants.APIServerKubeletClientKeyName},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				subCmds:       []string{"sa"},
0000000000000000000000000000000000000000;;				expectedFiles: []string{kubeadmconstants.ServiceAccountPrivateKeyName, kubeadmconstants.ServiceAccountPublicKeyName},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				subCmds:       []string{"front-proxy-ca"},
0000000000000000000000000000000000000000;;				expectedFiles: []string{kubeadmconstants.FrontProxyCACertName, kubeadmconstants.FrontProxyCAKeyName},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				subCmds:       []string{"front-proxy-ca", "front-proxy-client"},
0000000000000000000000000000000000000000;;				expectedFiles: []string{kubeadmconstants.FrontProxyCACertName, kubeadmconstants.FrontProxyCAKeyName, kubeadmconstants.FrontProxyClientCertName, kubeadmconstants.FrontProxyClientKeyName},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			// Temporary folder for the test case
0000000000000000000000000000000000000000;;			tmpdir, err := ioutil.TempDir("", "")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Couldn't create tmpdir")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer os.RemoveAll(tmpdir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// executes given sub commands
0000000000000000000000000000000000000000;;			for _, subCmdName := range test.subCmds {
0000000000000000000000000000000000000000;;				subCmd := getSubCmd(t, subCmdName, subCmds)
0000000000000000000000000000000000000000;;				subCmd.SetArgs([]string{fmt.Sprintf("--cert-dir=%s", tmpdir)})
0000000000000000000000000000000000000000;;				if err := subCmd.Execute(); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("Could not execute subcommand: %s", subCmdName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// verify expected files are there
0000000000000000000000000000000000000000;;			assertFilesCount(t, tmpdir, len(test.expectedFiles))
0000000000000000000000000000000000000000;;			for _, file := range test.expectedFiles {
0000000000000000000000000000000000000000;;				assertFileExists(t, tmpdir, file)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSubCmdApiServerFlags(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		subCmds := newSubCmdCerts()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Temporary folder for the test case
0000000000000000000000000000000000000000;;		tmpdir, err := ioutil.TempDir("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Couldn't create tmpdir")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpdir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// creates ca cert
0000000000000000000000000000000000000000;;		subCmd := getSubCmd(t, "ca", subCmds)
0000000000000000000000000000000000000000;;		subCmd.SetArgs([]string{fmt.Sprintf("--cert-dir=%s", tmpdir)})
0000000000000000000000000000000000000000;;		if err := subCmd.Execute(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Could not execute subcommand ca")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// creates apiserver cert
0000000000000000000000000000000000000000;;		subCmd = getSubCmd(t, "apiserver", subCmds)
0000000000000000000000000000000000000000;;		subCmd.SetArgs([]string{
0000000000000000000000000000000000000000;;			fmt.Sprintf("--cert-dir=%s", tmpdir),
0000000000000000000000000000000000000000;;			"--apiserver-cert-extra-sans=foo,boo",
0000000000000000000000000000000000000000;;			"--service-cidr=10.0.0.0/24",
0000000000000000000000000000000000000000;;			"--service-dns-domain=mycluster.local",
0000000000000000000000000000000000000000;;			"--apiserver-advertise-address=1.2.3.4",
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err := subCmd.Execute(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Could not execute subcommand apiserver")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		APIserverCert, err := pkiutil.TryLoadCertFromDisk(tmpdir, kubeadmconstants.APIServerCertAndKeyBaseName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error loading API server certificate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostname, err := os.Hostname()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("couldn't get the hostname: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, name := range []string{hostname, "kubernetes", "kubernetes.default", "kubernetes.default.svc", "kubernetes.default.svc.mycluster.local"} {
0000000000000000000000000000000000000000;;			if APIserverCert.DNSNames[i] != name {
0000000000000000000000000000000000000000;;				t.Errorf("APIserverCert.DNSNames[%d] is %s instead of %s", i, APIserverCert.DNSNames[i], name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, ip := range []string{"10.0.0.1", "1.2.3.4"} {
0000000000000000000000000000000000000000;;			if APIserverCert.IPAddresses[i].String() != ip {
0000000000000000000000000000000000000000;;				t.Errorf("APIserverCert.IPAddresses[%d] is %s instead of %s", i, APIserverCert.IPAddresses[i], ip)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSubCmdReadsConfig(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		subCmds := newSubCmdCerts()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			subCmds           []string
0000000000000000000000000000000000000000;;			expectedFileCount int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				subCmds:           []string{"sa"},
0000000000000000000000000000000000000000;;				expectedFileCount: 2,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				subCmds:           []string{"front-proxy-ca", "front-proxy-client"},
0000000000000000000000000000000000000000;;				expectedFileCount: 4,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				subCmds:           []string{"ca", "apiserver", "apiserver-kubelet-client"},
0000000000000000000000000000000000000000;;				expectedFileCount: 6,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				subCmds:           []string{"all"},
0000000000000000000000000000000000000000;;				expectedFileCount: 12,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			// Temporary folder for the test case
0000000000000000000000000000000000000000;;			tmpdir, err := ioutil.TempDir("", "")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Couldn't create tmpdir")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer os.RemoveAll(tmpdir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			configPath := saveDummyCfg(t, tmpdir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// executes given sub commands
0000000000000000000000000000000000000000;;			for _, subCmdName := range test.subCmds {
0000000000000000000000000000000000000000;;				subCmd := getSubCmd(t, subCmdName, subCmds)
0000000000000000000000000000000000000000;;				subCmd.SetArgs([]string{fmt.Sprintf("--config=%s", configPath)})
0000000000000000000000000000000000000000;;				if err := subCmd.Execute(); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("Could not execute command: %s", subCmdName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// verify expected files are there
0000000000000000000000000000000000000000;;			// NB. test.expectedFileCount + 1 because in this test case the tempdir where key/certificates
0000000000000000000000000000000000000000;;			//     are saved contains also the dummy configuration file
0000000000000000000000000000000000000000;;			assertFilesCount(t, tmpdir, test.expectedFileCount+1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSubCmd(t *testing.T, name string, subCmds []*cobra.Command) *cobra.Command {
0000000000000000000000000000000000000000;;		for _, subCmd := range subCmds {
0000000000000000000000000000000000000000;;			if subCmd.Name() == name {
0000000000000000000000000000000000000000;;				return subCmd
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Fatalf("Unable to find sub command %s", name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func assertFilesCount(t *testing.T, dirName string, count int) {
0000000000000000000000000000000000000000;;		files, err := ioutil.ReadDir(dirName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Couldn't read files from tmpdir: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(files) != count {
0000000000000000000000000000000000000000;;			t.Errorf("dir does contains %d, %d expected", len(files), count)
0000000000000000000000000000000000000000;;			for _, f := range files {
0000000000000000000000000000000000000000;;				t.Error(f.Name())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func assertFileExists(t *testing.T, dirName string, fileName string) {
0000000000000000000000000000000000000000;;		path := path.Join(dirName, fileName)
0000000000000000000000000000000000000000;;		if _, err := os.Stat(path); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			t.Errorf("file %s does not exist", fileName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func saveDummyCfg(t *testing.T, dirName string) string {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		path := path.Join(dirName, "dummyconfig.yaml")
0000000000000000000000000000000000000000;;		cfgTemplate := template.Must(template.New("init").Parse(dedent.Dedent(`
0000000000000000000000000000000000000000;;			apiVersion: kubeadm.k8s.io/v1alpha1
0000000000000000000000000000000000000000;;			kind: MasterConfiguration
0000000000000000000000000000000000000000;;			certificatesDir: {{.CertificatesDir}}
0000000000000000000000000000000000000000;;			`)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := os.Create(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error creating dummyconfig file %s: %v", path, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		templateData := struct {
0000000000000000000000000000000000000000;;			CertificatesDir string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			CertificatesDir: dirName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = cfgTemplate.Execute(f, templateData)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error generating dummyconfig file %s: %v", path, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return path
0000000000000000000000000000000000000000;;	}
