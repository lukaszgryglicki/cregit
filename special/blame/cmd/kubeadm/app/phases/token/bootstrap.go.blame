0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
8951cf217715eb02d670eff56c1581cc4389a177;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package token
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		clientset "k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		tokenutil "k8s.io/kubernetes/cmd/kubeadm/app/util/token"
0000000000000000000000000000000000000000;;		bootstrapapi "k8s.io/kubernetes/pkg/bootstrap/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const tokenCreateRetries = 5
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateNewToken tries to create a token and fails if one with the same ID already exists
0000000000000000000000000000000000000000;;	func CreateNewToken(client *clientset.Clientset, token string, tokenDuration time.Duration, usages []string, description string) error {
0000000000000000000000000000000000000000;;		return UpdateOrCreateToken(client, token, true, tokenDuration, usages, description)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateOrCreateToken attempts to update a token with the given ID, or create if it does not already exist.
0000000000000000000000000000000000000000;;	func UpdateOrCreateToken(client *clientset.Clientset, token string, failIfExists bool, tokenDuration time.Duration, usages []string, description string) error {
0000000000000000000000000000000000000000;;		tokenID, tokenSecret, err := tokenutil.ParseToken(token)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		secretName := fmt.Sprintf("%s%s", bootstrapapi.BootstrapTokenSecretPrefix, tokenID)
0000000000000000000000000000000000000000;;		var lastErr error
0000000000000000000000000000000000000000;;		for i := 0; i < tokenCreateRetries; i++ {
0000000000000000000000000000000000000000;;			secret, err := client.Secrets(metav1.NamespaceSystem).Get(secretName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				if failIfExists {
0000000000000000000000000000000000000000;;					return fmt.Errorf("a token with id %q already exists", tokenID)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Secret with this ID already exists, update it:
0000000000000000000000000000000000000000;;				secret.Data = encodeTokenSecretData(tokenID, tokenSecret, tokenDuration, usages, description)
0000000000000000000000000000000000000000;;				if _, err := client.Secrets(metav1.NamespaceSystem).Update(secret); err == nil {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					lastErr = err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Secret does not already exist:
0000000000000000000000000000000000000000;;			if apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				secret = &v1.Secret{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: secretName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Type: v1.SecretType(bootstrapapi.SecretTypeBootstrapToken),
0000000000000000000000000000000000000000;;					Data: encodeTokenSecretData(tokenID, tokenSecret, tokenDuration, usages, description),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, err := client.Secrets(metav1.NamespaceSystem).Create(secret); err == nil {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					lastErr = err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf(
0000000000000000000000000000000000000000;;			"unable to create bootstrap token after %d attempts [%v]",
0000000000000000000000000000000000000000;;			tokenCreateRetries,
0000000000000000000000000000000000000000;;			lastErr,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateBootstrapConfigMapIfNotExists creates the public cluster-info ConfigMap (if it doesn't already exist)
0000000000000000000000000000000000000000;;	func CreateBootstrapConfigMapIfNotExists(client clientset.Interface, file string) error {
0000000000000000000000000000000000000000;;		adminConfig, err := clientcmd.LoadFromFile(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to load admin kubeconfig [%v]", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		adminCluster := adminConfig.Contexts[adminConfig.CurrentContext].Cluster
0000000000000000000000000000000000000000;;		// Copy the cluster from admin.conf to the bootstrap kubeconfig, contains the CA cert and the server URL
0000000000000000000000000000000000000000;;		bootstrapConfig := &clientcmdapi.Config{
0000000000000000000000000000000000000000;;			Clusters: map[string]*clientcmdapi.Cluster{
0000000000000000000000000000000000000000;;				"": adminConfig.Clusters[adminCluster],
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bootstrapBytes, err := clientcmd.Write(*bootstrapConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bootstrapConfigMap := v1.ConfigMap{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: bootstrapapi.ConfigMapClusterInfo},
0000000000000000000000000000000000000000;;			Data: map[string]string{
0000000000000000000000000000000000000000;;				bootstrapapi.KubeConfigKey: string(bootstrapBytes),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := client.CoreV1().ConfigMaps(metav1.NamespacePublic).Create(&bootstrapConfigMap); err != nil {
0000000000000000000000000000000000000000;;			if apierrors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encodeTokenSecretData takes the token discovery object and an optional duration and returns the .Data for the Secret
0000000000000000000000000000000000000000;;	func encodeTokenSecretData(tokenId, tokenSecret string, duration time.Duration, usages []string, description string) map[string][]byte {
0000000000000000000000000000000000000000;;		data := map[string][]byte{
0000000000000000000000000000000000000000;;			bootstrapapi.BootstrapTokenIDKey:     []byte(tokenId),
0000000000000000000000000000000000000000;;			bootstrapapi.BootstrapTokenSecretKey: []byte(tokenSecret),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if duration > 0 {
0000000000000000000000000000000000000000;;			// Get the current time, add the specified duration, and format it accordingly
0000000000000000000000000000000000000000;;			durationString := time.Now().Add(duration).Format(time.RFC3339)
0000000000000000000000000000000000000000;;			data[bootstrapapi.BootstrapTokenExpirationKey] = []byte(durationString)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(description) > 0 {
0000000000000000000000000000000000000000;;			data[bootstrapapi.BootstrapTokenDescriptionKey] = []byte(description)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, usage := range usages {
0000000000000000000000000000000000000000;;			// TODO: Validate the usage string here before
0000000000000000000000000000000000000000;;			data[bootstrapapi.BootstrapTokenUsagePrefix+usage] = []byte("true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return data
0000000000000000000000000000000000000000;;	}
