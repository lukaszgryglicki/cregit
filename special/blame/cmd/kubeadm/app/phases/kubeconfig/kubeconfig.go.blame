0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
a319a60aea1f07d48be655d074e19cd792204fed;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubeconfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		certutil "k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;		kubeadmconstants "k8s.io/kubernetes/cmd/kubeadm/app/constants"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/phases/certs/pkiutil"
0000000000000000000000000000000000000000;;		kubeconfigutil "k8s.io/kubernetes/cmd/kubeadm/app/util/kubeconfig"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildConfigProperties holds some simple information about how this phase should build the KubeConfig object
0000000000000000000000000000000000000000;;	type BuildConfigProperties struct {
0000000000000000000000000000000000000000;;		CertDir         string
0000000000000000000000000000000000000000;;		ClientName      string
0000000000000000000000000000000000000000;;		Organization    []string
0000000000000000000000000000000000000000;;		APIServer       string
0000000000000000000000000000000000000000;;		Token           string
0000000000000000000000000000000000000000;;		MakeClientCerts bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Make an integration test for this function that runs after the certificates phase
0000000000000000000000000000000000000000;;	// and makes sure that those two phases work well together...
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Integration test cases:
0000000000000000000000000000000000000000;;	// /etc/kubernetes/{admin,kubelet}.conf don't exist => generate kubeconfig files
0000000000000000000000000000000000000000;;	// /etc/kubernetes/{admin,kubelet}.conf and certs in /etc/kubernetes/pki exist => don't touch anything as long as everything's valid
0000000000000000000000000000000000000000;;	// /etc/kubernetes/{admin,kubelet}.conf exist but the server URL is invalid in those files => error
0000000000000000000000000000000000000000;;	// /etc/kubernetes/{admin,kubelet}.conf exist but the CA cert doesn't match what's in the pki dir => error
0000000000000000000000000000000000000000;;	// /etc/kubernetes/{admin,kubelet}.conf exist but not certs => certs will be generated and conflict with the kubeconfig files => error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateInitKubeConfigFiles is called from the main init and does the work for the default phase behaviour
0000000000000000000000000000000000000000;;	func CreateInitKubeConfigFiles(masterEndpoint, pkiDir, outDir, nodeName string) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a lightweight specification for what the files should look like
0000000000000000000000000000000000000000;;		filesToCreateFromSpec := map[string]BuildConfigProperties{
0000000000000000000000000000000000000000;;			kubeadmconstants.AdminKubeConfigFileName: {
0000000000000000000000000000000000000000;;				ClientName:      "kubernetes-admin",
0000000000000000000000000000000000000000;;				APIServer:       masterEndpoint,
0000000000000000000000000000000000000000;;				CertDir:         pkiDir,
0000000000000000000000000000000000000000;;				Organization:    []string{kubeadmconstants.MastersGroup},
0000000000000000000000000000000000000000;;				MakeClientCerts: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			kubeadmconstants.KubeletKubeConfigFileName: {
0000000000000000000000000000000000000000;;				ClientName:      fmt.Sprintf("system:node:%s", nodeName),
0000000000000000000000000000000000000000;;				APIServer:       masterEndpoint,
0000000000000000000000000000000000000000;;				CertDir:         pkiDir,
0000000000000000000000000000000000000000;;				Organization:    []string{kubeadmconstants.NodesGroup},
0000000000000000000000000000000000000000;;				MakeClientCerts: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			kubeadmconstants.ControllerManagerKubeConfigFileName: {
0000000000000000000000000000000000000000;;				ClientName:      kubeadmconstants.ControllerManagerUser,
0000000000000000000000000000000000000000;;				APIServer:       masterEndpoint,
0000000000000000000000000000000000000000;;				CertDir:         pkiDir,
0000000000000000000000000000000000000000;;				MakeClientCerts: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			kubeadmconstants.SchedulerKubeConfigFileName: {
0000000000000000000000000000000000000000;;				ClientName:      kubeadmconstants.SchedulerUser,
0000000000000000000000000000000000000000;;				APIServer:       masterEndpoint,
0000000000000000000000000000000000000000;;				CertDir:         pkiDir,
0000000000000000000000000000000000000000;;				MakeClientCerts: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Loop through all specs for kubeconfig files and create them if necessary
0000000000000000000000000000000000000000;;		for filename, config := range filesToCreateFromSpec {
0000000000000000000000000000000000000000;;			kubeconfig, err := buildKubeConfig(config)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			kubeConfigFilePath := filepath.Join(outDir, filename)
0000000000000000000000000000000000000000;;			err = writeKubeconfigToDiskIfNotExists(kubeConfigFilePath, kubeconfig)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetKubeConfigBytesFromSpec takes properties how to build a KubeConfig file and then returns the bytes of that file
0000000000000000000000000000000000000000;;	func GetKubeConfigBytesFromSpec(config BuildConfigProperties) ([]byte, error) {
0000000000000000000000000000000000000000;;		kubeconfig, err := buildKubeConfig(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []byte{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeConfigBytes, err := clientcmd.Write(*kubeconfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []byte{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return kubeConfigBytes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildKubeConfig creates a kubeconfig object from some commonly specified properties in the struct above
0000000000000000000000000000000000000000;;	func buildKubeConfig(config BuildConfigProperties) (*clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try to load ca.crt and ca.key from the PKI directory
0000000000000000000000000000000000000000;;		caCert, caKey, err := pkiutil.TryLoadCertAndKeyFromDisk(config.CertDir, kubeadmconstants.CACertAndKeyBaseName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't create a kubeconfig; the CA files couldn't be loaded: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If this file should have client certs, generate one from the spec
0000000000000000000000000000000000000000;;		if config.MakeClientCerts {
0000000000000000000000000000000000000000;;			certConfig := certutil.Config{
0000000000000000000000000000000000000000;;				CommonName:   config.ClientName,
0000000000000000000000000000000000000000;;				Organization: config.Organization,
0000000000000000000000000000000000000000;;				Usages:       []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cert, key, err := pkiutil.NewCertAndKey(caCert, caKey, certConfig)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("failure while creating %s client certificate [%v]", certConfig.CommonName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return kubeconfigutil.CreateWithCerts(
0000000000000000000000000000000000000000;;				config.APIServer,
0000000000000000000000000000000000000000;;				"kubernetes",
0000000000000000000000000000000000000000;;				config.ClientName,
0000000000000000000000000000000000000000;;				certutil.EncodeCertPEM(caCert),
0000000000000000000000000000000000000000;;				certutil.EncodePrivateKeyPEM(key),
0000000000000000000000000000000000000000;;				certutil.EncodeCertPEM(cert),
0000000000000000000000000000000000000000;;			), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// otherwise, create a kubeconfig with a token
0000000000000000000000000000000000000000;;		return kubeconfigutil.CreateWithToken(
0000000000000000000000000000000000000000;;			config.APIServer,
0000000000000000000000000000000000000000;;			"kubernetes",
0000000000000000000000000000000000000000;;			config.ClientName,
0000000000000000000000000000000000000000;;			certutil.EncodeCertPEM(caCert),
0000000000000000000000000000000000000000;;			config.Token,
0000000000000000000000000000000000000000;;		), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeKubeconfigToDiskIfNotExists saves the KubeConfig struct to disk if there isn't any file at the given path
0000000000000000000000000000000000000000;;	// If there already is a KubeConfig file at the given path; kubeadm tries to load it and check if the values in the
0000000000000000000000000000000000000000;;	// existing and the expected config equals. If they do; kubeadm will just skip writing the file as it's up-to-date,
0000000000000000000000000000000000000000;;	// but if a file exists but has old content or isn't a kubeconfig file, this function returns an error.
0000000000000000000000000000000000000000;;	func writeKubeconfigToDiskIfNotExists(filename string, expectedConfig *clientcmdapi.Config) error {
0000000000000000000000000000000000000000;;		// Check if the file exist, and if it doesn't, just write it to disk
0000000000000000000000000000000000000000;;		if _, err := os.Stat(filename); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return kubeconfigutil.WriteToDisk(filename, expectedConfig)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The kubeconfig already exists, let's check if it has got the same CA and server URL
0000000000000000000000000000000000000000;;		currentConfig, err := clientcmd.LoadFromFile(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to load kubeconfig that already exists on disk [%v]", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedCtx := expectedConfig.CurrentContext
0000000000000000000000000000000000000000;;		expectedCluster := expectedConfig.Contexts[expectedCtx].Cluster
0000000000000000000000000000000000000000;;		currentCtx := currentConfig.CurrentContext
0000000000000000000000000000000000000000;;		currentCluster := currentConfig.Contexts[currentCtx].Cluster
0000000000000000000000000000000000000000;;		// If the current CA cert on disk doesn't match the expected CA cert, error out because we have a file, but it's stale
0000000000000000000000000000000000000000;;		if !bytes.Equal(currentConfig.Clusters[currentCluster].CertificateAuthorityData, expectedConfig.Clusters[expectedCluster].CertificateAuthorityData) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("a kubeconfig file %q exists already but has got the wrong CA cert", filename)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If the current API Server location on disk doesn't match the expected API server, error out because we have a file, but it's stale
0000000000000000000000000000000000000000;;		if currentConfig.Clusters[currentCluster].Server != expectedConfig.Clusters[expectedCluster].Server {
0000000000000000000000000000000000000000;;			return fmt.Errorf("a kubeconfig file %q exists already but has got the wrong API Server URL", filename)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// kubeadm doesn't validate the existing kubeconfig file more than this (kubeadm trusts the client certs to be valid)
0000000000000000000000000000000000000000;;		// Basically, if we find a kubeconfig file with the same path; the same CA cert and the same server URL;
0000000000000000000000000000000000000000;;		// kubeadm thinks those files are equal and doesn't bother writing a new file
0000000000000000000000000000000000000000;;		fmt.Printf("[kubeconfig] Using existing up-to-date KubeConfig file: %q\n", filename)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
