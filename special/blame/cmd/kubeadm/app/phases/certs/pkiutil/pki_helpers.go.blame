0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
9db0eae9e9d83114763752acc01f8cf31dda41c2;pkg/kubeadm/master/pki.go[pkg/kubeadm/master/pki.go][cmd/kubeadm/app/phases/certs/pkiutil/pki_helpers.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package pkiutil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certutil "k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: It should be able to generate different types of private keys, at least: RSA and ECDSA (and in the future maybe Ed25519 as well)
0000000000000000000000000000000000000000;;	// TODO: See if it makes sense to move this package directly to pkg/util/cert
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCertificateAuthority() (*x509.Certificate, *rsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;		key, err := certutil.NewPrivateKey()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("unable to create private key [%v]", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := certutil.Config{
0000000000000000000000000000000000000000;;			CommonName: "kubernetes",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cert, err := certutil.NewSelfSignedCACert(config, key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("unable to create self-signed certificate [%v]", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cert, key, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCertAndKey(caCert *x509.Certificate, caKey *rsa.PrivateKey, config certutil.Config) (*x509.Certificate, *rsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;		key, err := certutil.NewPrivateKey()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("unable to create private key [%v]", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cert, err := certutil.NewSignedCert(config, key, caCert, caKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("unable to sign certificate [%v]", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cert, key, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasServerAuth returns true if the given certificate is a ServerAuth
0000000000000000000000000000000000000000;;	func HasServerAuth(cert *x509.Certificate) bool {
0000000000000000000000000000000000000000;;		for i := range cert.ExtKeyUsage {
0000000000000000000000000000000000000000;;			if cert.ExtKeyUsage[i] == x509.ExtKeyUsageServerAuth {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func WriteCertAndKey(pkiPath string, name string, cert *x509.Certificate, key *rsa.PrivateKey) error {
0000000000000000000000000000000000000000;;		if err := WriteKey(pkiPath, name, key); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := WriteCert(pkiPath, name, cert); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func WriteCert(pkiPath, name string, cert *x509.Certificate) error {
0000000000000000000000000000000000000000;;		if cert == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("certificate cannot be nil when writing to file")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certificatePath := pathForCert(pkiPath, name)
0000000000000000000000000000000000000000;;		if err := certutil.WriteCert(certificatePath, certutil.EncodeCertPEM(cert)); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to write certificate to file %q: [%v]", certificatePath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func WriteKey(pkiPath, name string, key *rsa.PrivateKey) error {
0000000000000000000000000000000000000000;;		if key == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("private key cannot be nil when writing to file")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		privateKeyPath := pathForKey(pkiPath, name)
0000000000000000000000000000000000000000;;		if err := certutil.WriteKey(privateKeyPath, certutil.EncodePrivateKeyPEM(key)); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to write private key to file %q: [%v]", privateKeyPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func WritePublicKey(pkiPath, name string, key *rsa.PublicKey) error {
0000000000000000000000000000000000000000;;		if key == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("public key cannot be nil when writing to file")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		publicKeyBytes, err := certutil.EncodePublicKeyPEM(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		publicKeyPath := pathForPublicKey(pkiPath, name)
0000000000000000000000000000000000000000;;		if err := certutil.WriteKey(publicKeyPath, publicKeyBytes); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to write public key to file %q: [%v]", publicKeyPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CertOrKeyExist retuns a boolean whether the cert or the key exists
0000000000000000000000000000000000000000;;	func CertOrKeyExist(pkiPath, name string) bool {
0000000000000000000000000000000000000000;;		certificatePath, privateKeyPath := pathsForCertAndKey(pkiPath, name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, certErr := os.Stat(certificatePath)
0000000000000000000000000000000000000000;;		_, keyErr := os.Stat(privateKeyPath)
0000000000000000000000000000000000000000;;		if os.IsNotExist(certErr) && os.IsNotExist(keyErr) {
0000000000000000000000000000000000000000;;			// The cert or the key did not exist
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Both files exist or one of them
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TryLoadCertAndKeyFromDisk tries to load a cert and a key from the disk and validates that they are valid
0000000000000000000000000000000000000000;;	func TryLoadCertAndKeyFromDisk(pkiPath, name string) (*x509.Certificate, *rsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;		cert, err := TryLoadCertFromDisk(pkiPath, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key, err := TryLoadKeyFromDisk(pkiPath, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cert, key, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TryLoadCertFromDisk tries to load the cert from the disk and validates that it is valid
0000000000000000000000000000000000000000;;	func TryLoadCertFromDisk(pkiPath, name string) (*x509.Certificate, error) {
0000000000000000000000000000000000000000;;		certificatePath := pathForCert(pkiPath, name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certs, err := certutil.CertsFromFile(certificatePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't load the certificate file %s: %v", certificatePath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We are only putting one certificate in the certificate pem file, so it's safe to just pick the first one
0000000000000000000000000000000000000000;;		// TODO: Support multiple certs here in order to be able to rotate certs
0000000000000000000000000000000000000000;;		cert := certs[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check so that the certificate is valid now
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		if now.Before(cert.NotBefore) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("the certificate is not valid yet")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if now.After(cert.NotAfter) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("the certificate has expired")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cert, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TryLoadKeyFromDisk tries to load the key from the disk and validates that it is valid
0000000000000000000000000000000000000000;;	func TryLoadKeyFromDisk(pkiPath, name string) (*rsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;		privateKeyPath := pathForKey(pkiPath, name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Parse the private key from a file
0000000000000000000000000000000000000000;;		privKey, err := certutil.PrivateKeyFromFile(privateKeyPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't load the private key file %s: %v", privateKeyPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow RSA format only
0000000000000000000000000000000000000000;;		var key *rsa.PrivateKey
0000000000000000000000000000000000000000;;		switch k := privKey.(type) {
0000000000000000000000000000000000000000;;		case *rsa.PrivateKey:
0000000000000000000000000000000000000000;;			key = k
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("the private key file %s isn't in RSA format", privateKeyPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return key, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pathsForCertAndKey(pkiPath, name string) (string, string) {
0000000000000000000000000000000000000000;;		return pathForCert(pkiPath, name), pathForKey(pkiPath, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pathForCert(pkiPath, name string) string {
0000000000000000000000000000000000000000;;		return filepath.Join(pkiPath, fmt.Sprintf("%s.crt", name))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pathForKey(pkiPath, name string) string {
0000000000000000000000000000000000000000;;		return filepath.Join(pkiPath, fmt.Sprintf("%s.key", name))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pathForPublicKey(pkiPath, name string) string {
0000000000000000000000000000000000000000;;		return filepath.Join(pkiPath, fmt.Sprintf("%s.pub", name))
0000000000000000000000000000000000000000;;	}
