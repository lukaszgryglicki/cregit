0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
4c735937864165d6ad7083c0e7dd96889eda61dd;cmd/kubeadm/app/master/pki_test.go[cmd/kubeadm/app/master/pki_test.go][cmd/kubeadm/app/phases/certs/pkiutil/pki_helpers_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package pkiutil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certutil "k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewCertificateAuthority(t *testing.T) {
0000000000000000000000000000000000000000;;		cert, key, err := NewCertificateAuthority()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cert == nil {
0000000000000000000000000000000000000000;;			t.Errorf(
0000000000000000000000000000000000000000;;				"failed NewCertificateAuthority, cert == nil",
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if key == nil {
0000000000000000000000000000000000000000;;			t.Errorf(
0000000000000000000000000000000000000000;;				"failed NewCertificateAuthority, key == nil",
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf(
0000000000000000000000000000000000000000;;				"failed NewCertificateAuthority with an error: %v",
0000000000000000000000000000000000000000;;				err,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewCertAndKey(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			caKeySize int
0000000000000000000000000000000000000000;;			expected  bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// RSA key too small
0000000000000000000000000000000000000000;;				caKeySize: 128,
0000000000000000000000000000000000000000;;				expected:  false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Should succeed
0000000000000000000000000000000000000000;;				caKeySize: 2048,
0000000000000000000000000000000000000000;;				expected:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			caKey, err := rsa.GenerateKey(rand.Reader, rt.caKeySize)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Couldn't create rsa Private Key")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			caCert := &x509.Certificate{}
0000000000000000000000000000000000000000;;			config := certutil.Config{
0000000000000000000000000000000000000000;;				CommonName:   "test",
0000000000000000000000000000000000000000;;				Organization: []string{"test"},
0000000000000000000000000000000000000000;;				Usages:       []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, _, actual := NewCertAndKey(caCert, caKey, config)
0000000000000000000000000000000000000000;;			if (actual == nil) != rt.expected {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed NewCertAndKey:\n\texpected: %t\n\t  actual: %t",
0000000000000000000000000000000000000000;;					rt.expected,
0000000000000000000000000000000000000000;;					(actual == nil),
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHasServerAuth(t *testing.T) {
0000000000000000000000000000000000000000;;		caCert, caKey, _ := NewCertificateAuthority()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			config   certutil.Config
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				config: certutil.Config{
0000000000000000000000000000000000000000;;					CommonName: "test",
0000000000000000000000000000000000000000;;					Usages:     []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				config: certutil.Config{
0000000000000000000000000000000000000000;;					CommonName: "test",
0000000000000000000000000000000000000000;;					Usages:     []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			cert, _, err := NewCertAndKey(caCert, caKey, rt.config)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Couldn't create cert: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			actual := HasServerAuth(cert)
0000000000000000000000000000000000000000;;			if actual != rt.expected {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed HasServerAuth:\n\texpected: %t\n\t  actual: %t",
0000000000000000000000000000000000000000;;					rt.expected,
0000000000000000000000000000000000000000;;					actual,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWriteCertAndKey(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpdir, err := ioutil.TempDir("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Couldn't create tmpdir")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpdir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		caKey, err := rsa.GenerateKey(rand.Reader, 2048)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Couldn't create rsa Private Key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		caCert := &x509.Certificate{}
0000000000000000000000000000000000000000;;		actual := WriteCertAndKey(tmpdir, "foo", caCert, caKey)
0000000000000000000000000000000000000000;;		if actual != nil {
0000000000000000000000000000000000000000;;			t.Errorf(
0000000000000000000000000000000000000000;;				"failed WriteCertAndKey with an error: %v",
0000000000000000000000000000000000000000;;				actual,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWriteCert(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpdir, err := ioutil.TempDir("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Couldn't create tmpdir")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpdir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		caCert := &x509.Certificate{}
0000000000000000000000000000000000000000;;		actual := WriteCert(tmpdir, "foo", caCert)
0000000000000000000000000000000000000000;;		if actual != nil {
0000000000000000000000000000000000000000;;			t.Errorf(
0000000000000000000000000000000000000000;;				"failed WriteCertAndKey with an error: %v",
0000000000000000000000000000000000000000;;				actual,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWriteKey(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpdir, err := ioutil.TempDir("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Couldn't create tmpdir")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpdir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		caKey, err := rsa.GenerateKey(rand.Reader, 2048)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Couldn't create rsa Private Key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		actual := WriteKey(tmpdir, "foo", caKey)
0000000000000000000000000000000000000000;;		if actual != nil {
0000000000000000000000000000000000000000;;			t.Errorf(
0000000000000000000000000000000000000000;;				"failed WriteCertAndKey with an error: %v",
0000000000000000000000000000000000000000;;				actual,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWritePublicKey(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpdir, err := ioutil.TempDir("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Couldn't create tmpdir")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpdir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		caKey, err := rsa.GenerateKey(rand.Reader, 2048)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Couldn't create rsa Private Key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		actual := WritePublicKey(tmpdir, "foo", &caKey.PublicKey)
0000000000000000000000000000000000000000;;		if actual != nil {
0000000000000000000000000000000000000000;;			t.Errorf(
0000000000000000000000000000000000000000;;				"failed WriteCertAndKey with an error: %v",
0000000000000000000000000000000000000000;;				actual,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCertOrKeyExist(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpdir, err := ioutil.TempDir("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Couldn't create tmpdir")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpdir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		caKey, err := rsa.GenerateKey(rand.Reader, 2048)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Couldn't create rsa Private Key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		caCert := &x509.Certificate{}
0000000000000000000000000000000000000000;;		actual := WriteCertAndKey(tmpdir, "foo", caCert, caKey)
0000000000000000000000000000000000000000;;		if actual != nil {
0000000000000000000000000000000000000000;;			t.Errorf(
0000000000000000000000000000000000000000;;				"failed WriteCertAndKey with an error: %v",
0000000000000000000000000000000000000000;;				actual,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			path     string
0000000000000000000000000000000000000000;;			name     string
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				path:     "",
0000000000000000000000000000000000000000;;				name:     "",
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				path:     tmpdir,
0000000000000000000000000000000000000000;;				name:     "foo",
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := CertOrKeyExist(rt.path, rt.name)
0000000000000000000000000000000000000000;;			if actual != rt.expected {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed CertOrKeyExist:\n\texpected: %t\n\t  actual: %t",
0000000000000000000000000000000000000000;;					rt.expected,
0000000000000000000000000000000000000000;;					actual,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTryLoadCertAndKeyFromDisk(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpdir, err := ioutil.TempDir("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Couldn't create tmpdir")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpdir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		caCert, caKey, err := NewCertificateAuthority()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf(
0000000000000000000000000000000000000000;;				"failed to create cert and key with an error: %v",
0000000000000000000000000000000000000000;;				err,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = WriteCertAndKey(tmpdir, "foo", caCert, caKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf(
0000000000000000000000000000000000000000;;				"failed to write cert and key with an error: %v",
0000000000000000000000000000000000000000;;				err,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			path     string
0000000000000000000000000000000000000000;;			name     string
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				path:     "",
0000000000000000000000000000000000000000;;				name:     "",
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				path:     tmpdir,
0000000000000000000000000000000000000000;;				name:     "foo",
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			_, _, actual := TryLoadCertAndKeyFromDisk(rt.path, rt.name)
0000000000000000000000000000000000000000;;			if (actual == nil) != rt.expected {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed TryLoadCertAndKeyFromDisk:\n\texpected: %t\n\t  actual: %t",
0000000000000000000000000000000000000000;;					rt.expected,
0000000000000000000000000000000000000000;;					(actual == nil),
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTryLoadCertFromDisk(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpdir, err := ioutil.TempDir("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Couldn't create tmpdir")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpdir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		caCert, _, err := NewCertificateAuthority()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf(
0000000000000000000000000000000000000000;;				"failed to create cert and key with an error: %v",
0000000000000000000000000000000000000000;;				err,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = WriteCert(tmpdir, "foo", caCert)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf(
0000000000000000000000000000000000000000;;				"failed to write cert and key with an error: %v",
0000000000000000000000000000000000000000;;				err,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			path     string
0000000000000000000000000000000000000000;;			name     string
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				path:     "",
0000000000000000000000000000000000000000;;				name:     "",
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				path:     tmpdir,
0000000000000000000000000000000000000000;;				name:     "foo",
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			_, actual := TryLoadCertFromDisk(rt.path, rt.name)
0000000000000000000000000000000000000000;;			if (actual == nil) != rt.expected {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed TryLoadCertAndKeyFromDisk:\n\texpected: %t\n\t  actual: %t",
0000000000000000000000000000000000000000;;					rt.expected,
0000000000000000000000000000000000000000;;					(actual == nil),
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTryLoadKeyFromDisk(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpdir, err := ioutil.TempDir("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Couldn't create tmpdir")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpdir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, caKey, err := NewCertificateAuthority()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf(
0000000000000000000000000000000000000000;;				"failed to create cert and key with an error: %v",
0000000000000000000000000000000000000000;;				err,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = WriteKey(tmpdir, "foo", caKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf(
0000000000000000000000000000000000000000;;				"failed to write cert and key with an error: %v",
0000000000000000000000000000000000000000;;				err,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			path     string
0000000000000000000000000000000000000000;;			name     string
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				path:     "",
0000000000000000000000000000000000000000;;				name:     "",
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				path:     tmpdir,
0000000000000000000000000000000000000000;;				name:     "foo",
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			_, actual := TryLoadKeyFromDisk(rt.path, rt.name)
0000000000000000000000000000000000000000;;			if (actual == nil) != rt.expected {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed TryLoadCertAndKeyFromDisk:\n\texpected: %t\n\t  actual: %t",
0000000000000000000000000000000000000000;;					rt.expected,
0000000000000000000000000000000000000000;;					(actual == nil),
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPathsForCertAndKey(t *testing.T) {
0000000000000000000000000000000000000000;;		crtPath, keyPath := pathsForCertAndKey("/foo", "bar")
0000000000000000000000000000000000000000;;		if crtPath != "/foo/bar.crt" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected certificate path: %s", crtPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if keyPath != "/foo/bar.key" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected key path: %s", keyPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPathForCert(t *testing.T) {
0000000000000000000000000000000000000000;;		crtPath := pathForCert("/foo", "bar")
0000000000000000000000000000000000000000;;		if crtPath != "/foo/bar.crt" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected certificate path: %s", crtPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPathForKey(t *testing.T) {
0000000000000000000000000000000000000000;;		keyPath := pathForKey("/foo", "bar")
0000000000000000000000000000000000000000;;		if keyPath != "/foo/bar.key" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected certificate path: %s", keyPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPathForPublicKey(t *testing.T) {
0000000000000000000000000000000000000000;;		pubPath := pathForPublicKey("/foo", "bar")
0000000000000000000000000000000000000000;;		if pubPath != "/foo/bar.pub" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected certificate path: %s", pubPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
