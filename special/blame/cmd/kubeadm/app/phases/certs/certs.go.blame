0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
a319a60aea1f07d48be655d074e19cd792204fed;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package certs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation"
0000000000000000000000000000000000000000;;		certutil "k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;		kubeadmapi "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm"
0000000000000000000000000000000000000000;;		kubeadmconstants "k8s.io/kubernetes/cmd/kubeadm/app/constants"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/phases/certs/pkiutil"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/service/ipallocator"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCACertAndKey will generate a self signed CA.
0000000000000000000000000000000000000000;;	func NewCACertAndKey() (*x509.Certificate, *rsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		caCert, caKey, err := pkiutil.NewCertificateAuthority()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("failure while generating CA certificate and key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return caCert, caKey, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAPIServerCertAndKey generate CA certificate for apiserver, signed by the given CA.
0000000000000000000000000000000000000000;;	func NewAPIServerCertAndKey(cfg *kubeadmapi.MasterConfiguration, caCert *x509.Certificate, caKey *rsa.PrivateKey) (*x509.Certificate, *rsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		altNames, err := getAltNames(cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("failure while composing altnames for API server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := certutil.Config{
0000000000000000000000000000000000000000;;			CommonName: kubeadmconstants.APIServerCertCommonName,
0000000000000000000000000000000000000000;;			AltNames:   *altNames,
0000000000000000000000000000000000000000;;			Usages:     []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		apiCert, apiKey, err := pkiutil.NewCertAndKey(caCert, caKey, config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("failure while creating API server key and certificate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return apiCert, apiKey, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAPIServerKubeletClientCertAndKey generate CA certificate for the apiservers to connect to the kubelets securely, signed by the given CA.
0000000000000000000000000000000000000000;;	func NewAPIServerKubeletClientCertAndKey(caCert *x509.Certificate, caKey *rsa.PrivateKey) (*x509.Certificate, *rsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := certutil.Config{
0000000000000000000000000000000000000000;;			CommonName:   kubeadmconstants.APIServerKubeletClientCertCommonName,
0000000000000000000000000000000000000000;;			Organization: []string{kubeadmconstants.MastersGroup},
0000000000000000000000000000000000000000;;			Usages:       []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		apiClientCert, apiClientKey, err := pkiutil.NewCertAndKey(caCert, caKey, config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("failure while creating API server kubelet client key and certificate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return apiClientCert, apiClientKey, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServiceAccountSigningKey generate public/private key pairs for signing service account tokens.
0000000000000000000000000000000000000000;;	func NewServiceAccountSigningKey() (*rsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The key does NOT exist, let's generate it now
0000000000000000000000000000000000000000;;		saSigningKey, err := certutil.NewPrivateKey()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failure while creating service account token signing key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return saSigningKey, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFrontProxyCACertAndKey generate a self signed front proxy CA.
0000000000000000000000000000000000000000;;	// Front proxy CA and client certs are used to secure a front proxy authenticator which is used to assert identity
0000000000000000000000000000000000000000;;	// without the client cert.
0000000000000000000000000000000000000000;;	// This is a separte CA, so that front proxy identities cannot hit the API and normal client certs cannot be used
0000000000000000000000000000000000000000;;	// as front proxies.
0000000000000000000000000000000000000000;;	func NewFrontProxyCACertAndKey() (*x509.Certificate, *rsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		frontProxyCACert, frontProxyCAKey, err := pkiutil.NewCertificateAuthority()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("failure while generating front-proxy CA certificate and key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return frontProxyCACert, frontProxyCAKey, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFrontProxyClientCertAndKey generate CA certificate for proxy server client, signed by the given front proxy CA.
0000000000000000000000000000000000000000;;	func NewFrontProxyClientCertAndKey(frontProxyCACert *x509.Certificate, frontProxyCAKey *rsa.PrivateKey) (*x509.Certificate, *rsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := certutil.Config{
0000000000000000000000000000000000000000;;			CommonName: kubeadmconstants.FrontProxyClientCertCommonName,
0000000000000000000000000000000000000000;;			Usages:     []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		frontProxyClientCert, frontProxyClientKey, err := pkiutil.NewCertAndKey(frontProxyCACert, frontProxyCAKey, config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("failure while creating front-proxy client key and certificate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return frontProxyClientCert, frontProxyClientKey, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getAltNames builds an AltNames object for to be used when generating apiserver certificate
0000000000000000000000000000000000000000;;	func getAltNames(cfg *kubeadmapi.MasterConfiguration) (*certutil.AltNames, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// advertise address
0000000000000000000000000000000000000000;;		advertiseAddress := net.ParseIP(cfg.API.AdvertiseAddress)
0000000000000000000000000000000000000000;;		if advertiseAddress == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing API AdvertiseAddress %v: is not a valid textual representation of an IP address", cfg.API.AdvertiseAddress)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// internal IP address for the API server
0000000000000000000000000000000000000000;;		_, svcSubnet, err := net.ParseCIDR(cfg.Networking.ServiceSubnet)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing CIDR %q: %v", cfg.Networking.ServiceSubnet, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		internalAPIServerVirtualIP, err := ipallocator.GetIndexedIP(svcSubnet, 1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to get first IP address from the given CIDR (%s): %v", svcSubnet.String(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create AltNames with defaults DNSNames/IPs
0000000000000000000000000000000000000000;;		altNames := &certutil.AltNames{
0000000000000000000000000000000000000000;;			DNSNames: []string{
0000000000000000000000000000000000000000;;				cfg.NodeName,
0000000000000000000000000000000000000000;;				"kubernetes",
0000000000000000000000000000000000000000;;				"kubernetes.default",
0000000000000000000000000000000000000000;;				"kubernetes.default.svc",
0000000000000000000000000000000000000000;;				fmt.Sprintf("kubernetes.default.svc.%s", cfg.Networking.DNSDomain),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			IPs: []net.IP{
0000000000000000000000000000000000000000;;				internalAPIServerVirtualIP,
0000000000000000000000000000000000000000;;				advertiseAddress,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// adds additional SAN
0000000000000000000000000000000000000000;;		for _, altname := range cfg.APIServerCertSANs {
0000000000000000000000000000000000000000;;			if ip := net.ParseIP(altname); ip != nil {
0000000000000000000000000000000000000000;;				altNames.IPs = append(altNames.IPs, ip)
0000000000000000000000000000000000000000;;			} else if len(validation.IsDNS1123Subdomain(altname)) == 0 {
0000000000000000000000000000000000000000;;				altNames.DNSNames = append(altNames.DNSNames, altname)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return altNames, nil
0000000000000000000000000000000000000000;;	}
