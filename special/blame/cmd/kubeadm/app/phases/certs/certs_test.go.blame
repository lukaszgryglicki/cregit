0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
8b295c1d6cedf3918c9efd1cb25bf47812f308fb;cmd/kubeadm/app/master/kubeconfig_test.go[cmd/kubeadm/app/master/kubeconfig_test.go][cmd/kubeadm/app/phases/certs/certs_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package certs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeadmapi "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/constants"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewCACertAndKey(t *testing.T) {
0000000000000000000000000000000000000000;;		caCert, _, err := NewCACertAndKey()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed call NewCACertAndKey: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assertIsCa(t, caCert)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewAPIServerCertAndKey(t *testing.T) {
0000000000000000000000000000000000000000;;		hostname := "valid-hostname"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		advertiseIP := "1.2.3.4"
0000000000000000000000000000000000000000;;		cfg := &kubeadmapi.MasterConfiguration{
0000000000000000000000000000000000000000;;			API:        kubeadmapi.API{AdvertiseAddress: advertiseIP},
0000000000000000000000000000000000000000;;			Networking: kubeadmapi.Networking{ServiceSubnet: "10.96.0.0/12", DNSDomain: "cluster.local"},
0000000000000000000000000000000000000000;;			NodeName:   "valid-hostname",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		caCert, caKey, err := NewCACertAndKey()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiServerCert, _, err := NewAPIServerCertAndKey(cfg, caCert, caKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed creation of cert and key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assertIsSignedByCa(t, apiServerCert, caCert)
0000000000000000000000000000000000000000;;		assertHasServerAuth(t, apiServerCert)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, DNSName := range []string{hostname, "kubernetes", "kubernetes.default", "kubernetes.default.svc", "kubernetes.default.svc.cluster.local"} {
0000000000000000000000000000000000000000;;			assertHasDNSNames(t, apiServerCert, DNSName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, IPAddress := range []string{"10.96.0.1", advertiseIP} {
0000000000000000000000000000000000000000;;			assertHasIPAddresses(t, apiServerCert, net.ParseIP(IPAddress))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewAPIServerKubeletClientCertAndKey(t *testing.T) {
0000000000000000000000000000000000000000;;		caCert, caKey, err := NewCACertAndKey()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiClientCert, _, err := NewAPIServerKubeletClientCertAndKey(caCert, caKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed creation of cert and key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assertIsSignedByCa(t, apiClientCert, caCert)
0000000000000000000000000000000000000000;;		assertHasClientAuth(t, apiClientCert)
0000000000000000000000000000000000000000;;		assertHasOrganization(t, apiClientCert, constants.MastersGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewNewServiceAccountSigningKey(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key, err := NewServiceAccountSigningKey()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed creation of key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if key.N.BitLen() < 2048 {
0000000000000000000000000000000000000000;;			t.Error("Service account signing key has less than 2048 bits size")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewFrontProxyCACertAndKey(t *testing.T) {
0000000000000000000000000000000000000000;;		frontProxyCACert, _, err := NewFrontProxyCACertAndKey()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed creation of cert and key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assertIsCa(t, frontProxyCACert)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewFrontProxyClientCertAndKey(t *testing.T) {
0000000000000000000000000000000000000000;;		frontProxyCACert, frontProxyCAKey, err := NewFrontProxyCACertAndKey()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		frontProxyClientCert, _, err := NewFrontProxyClientCertAndKey(frontProxyCACert, frontProxyCAKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed creation of cert and key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assertIsSignedByCa(t, frontProxyClientCert, frontProxyCACert)
0000000000000000000000000000000000000000;;		assertHasClientAuth(t, frontProxyClientCert)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func assertIsCa(t *testing.T, cert *x509.Certificate) {
0000000000000000000000000000000000000000;;		if !cert.IsCA {
0000000000000000000000000000000000000000;;			t.Error("cert is not a valida CA")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func assertIsSignedByCa(t *testing.T, cert *x509.Certificate, ca *x509.Certificate) {
0000000000000000000000000000000000000000;;		if err := cert.CheckSignatureFrom(ca); err != nil {
0000000000000000000000000000000000000000;;			t.Error("cert is not signed by ca")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func assertHasClientAuth(t *testing.T, cert *x509.Certificate) {
0000000000000000000000000000000000000000;;		for i := range cert.ExtKeyUsage {
0000000000000000000000000000000000000000;;			if cert.ExtKeyUsage[i] == x509.ExtKeyUsageClientAuth {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Error("cert is not a ClientAuth")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func assertHasServerAuth(t *testing.T, cert *x509.Certificate) {
0000000000000000000000000000000000000000;;		for i := range cert.ExtKeyUsage {
0000000000000000000000000000000000000000;;			if cert.ExtKeyUsage[i] == x509.ExtKeyUsageServerAuth {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Error("cert is not a ServerAuth")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func assertHasOrganization(t *testing.T, cert *x509.Certificate, OU string) {
0000000000000000000000000000000000000000;;		for i := range cert.Subject.Organization {
0000000000000000000000000000000000000000;;			if cert.Subject.Organization[i] == OU {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Errorf("cert does not contain OU %s", OU)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func assertHasDNSNames(t *testing.T, cert *x509.Certificate, DNSName string) {
0000000000000000000000000000000000000000;;		for i := range cert.DNSNames {
0000000000000000000000000000000000000000;;			if cert.DNSNames[i] == DNSName {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Errorf("cert does not contain DNSName %s", DNSName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func assertHasIPAddresses(t *testing.T, cert *x509.Certificate, IPAddress net.IP) {
0000000000000000000000000000000000000000;;		for i := range cert.IPAddresses {
0000000000000000000000000000000000000000;;			if cert.IPAddresses[i].Equal(IPAddress) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Errorf("cert does not contain IPAddress %s", IPAddress)
0000000000000000000000000000000000000000;;	}
