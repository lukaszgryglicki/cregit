0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
1cd561fae9761c79378ba65c61c10ff88f9c6fcf;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package addons
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		kuberuntime "k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		clientset "k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		kubeadmapi "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm"
0000000000000000000000000000000000000000;;		kubeadmconstants "k8s.io/kubernetes/cmd/kubeadm/app/constants"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/images"
0000000000000000000000000000000000000000;;		kubeadmutil "k8s.io/kubernetes/cmd/kubeadm/app/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateEssentialAddons creates the kube-proxy and kube-dns addons
0000000000000000000000000000000000000000;;	func CreateEssentialAddons(cfg *kubeadmapi.MasterConfiguration, client *clientset.Clientset) error {
0000000000000000000000000000000000000000;;		proxyConfigMapBytes, err := kubeadmutil.ParseTemplate(KubeProxyConfigMap, struct{ MasterEndpoint string }{
0000000000000000000000000000000000000000;;			// Fetch this value from the kubeconfig file
0000000000000000000000000000000000000000;;			MasterEndpoint: fmt.Sprintf("https://%s:%d", cfg.API.AdvertiseAddress, cfg.API.BindPort),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error when parsing kube-proxy configmap template: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxyDaemonSetBytes, err := kubeadmutil.ParseTemplate(KubeProxyDaemonSet, struct{ Image, ClusterCIDR, MasterTaintKey string }{
0000000000000000000000000000000000000000;;			Image:          images.GetCoreImage("proxy", cfg, cfg.UnifiedControlPlaneImage),
0000000000000000000000000000000000000000;;			ClusterCIDR:    getClusterCIDR(cfg.Networking.PodSubnet),
0000000000000000000000000000000000000000;;			MasterTaintKey: kubeadmconstants.LabelNodeRoleMaster,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error when parsing kube-proxy daemonset template: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dnsDeploymentBytes, err := kubeadmutil.ParseTemplate(KubeDNSDeployment, struct{ ImageRepository, Arch, Version, DNSDomain, MasterTaintKey string }{
0000000000000000000000000000000000000000;;			ImageRepository: cfg.ImageRepository,
0000000000000000000000000000000000000000;;			Arch:            runtime.GOARCH,
0000000000000000000000000000000000000000;;			Version:         KubeDNSVersion,
0000000000000000000000000000000000000000;;			DNSDomain:       cfg.Networking.DNSDomain,
0000000000000000000000000000000000000000;;			MasterTaintKey:  kubeadmconstants.LabelNodeRoleMaster,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error when parsing kube-dns deployment template: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dnsip, err := getDNSIP(client)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dnsServiceBytes, err := kubeadmutil.ParseTemplate(KubeDNSService, struct{ DNSIP string }{
0000000000000000000000000000000000000000;;			DNSIP: dnsip.String(),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error when parsing kube-proxy configmap template: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = CreateKubeProxyAddon(proxyConfigMapBytes, proxyDaemonSetBytes, client)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Println("[addons] Applied essential addon: kube-proxy")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = CreateKubeDNSAddon(dnsDeploymentBytes, dnsServiceBytes, client)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Println("[addons] Applied essential addon: kube-dns")
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreateKubeProxyAddon(configMapBytes, daemonSetbytes []byte, client *clientset.Clientset) error {
0000000000000000000000000000000000000000;;		kubeproxyConfigMap := &v1.ConfigMap{}
0000000000000000000000000000000000000000;;		if err := kuberuntime.DecodeInto(api.Codecs.UniversalDecoder(), configMapBytes, kubeproxyConfigMap); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to decode kube-proxy configmap %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := client.CoreV1().ConfigMaps(metav1.NamespaceSystem).Create(kubeproxyConfigMap); err != nil {
0000000000000000000000000000000000000000;;			if !apierrors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to create a new kube-proxy configmap: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, err := client.CoreV1().ConfigMaps(metav1.NamespaceSystem).Update(kubeproxyConfigMap); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to update the kube-proxy configmap: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeproxyDaemonSet := &extensions.DaemonSet{}
0000000000000000000000000000000000000000;;		if err := kuberuntime.DecodeInto(api.Codecs.UniversalDecoder(), daemonSetbytes, kubeproxyDaemonSet); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to decode kube-proxy daemonset %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := client.ExtensionsV1beta1().DaemonSets(metav1.NamespaceSystem).Create(kubeproxyDaemonSet); err != nil {
0000000000000000000000000000000000000000;;			if !apierrors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to create a new kube-proxy daemonset: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, err := client.ExtensionsV1beta1().DaemonSets(metav1.NamespaceSystem).Update(kubeproxyDaemonSet); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to update the kube-proxy daemonset: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreateKubeDNSAddon(deploymentBytes, serviceBytes []byte, client *clientset.Clientset) error {
0000000000000000000000000000000000000000;;		kubednsDeployment := &extensions.Deployment{}
0000000000000000000000000000000000000000;;		if err := kuberuntime.DecodeInto(api.Codecs.UniversalDecoder(), deploymentBytes, kubednsDeployment); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to decode kube-dns deployment %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := client.ExtensionsV1beta1().Deployments(metav1.NamespaceSystem).Create(kubednsDeployment); err != nil {
0000000000000000000000000000000000000000;;			if !apierrors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to create a new kube-dns deployment: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, err := client.ExtensionsV1beta1().Deployments(metav1.NamespaceSystem).Update(kubednsDeployment); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to update the kube-dns deployment: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubednsService := &v1.Service{}
0000000000000000000000000000000000000000;;		if err := kuberuntime.DecodeInto(api.Codecs.UniversalDecoder(), serviceBytes, kubednsService); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to decode kube-dns service %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := client.CoreV1().Services(metav1.NamespaceSystem).Create(kubednsService); err != nil {
0000000000000000000000000000000000000000;;			// Ignore if the Service is invalid with this error message:
0000000000000000000000000000000000000000;;			// 	Service "kube-dns" is invalid: spec.clusterIP: Invalid value: "10.96.0.10": provided IP is already allocated
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !apierrors.IsAlreadyExists(err) && !apierrors.IsInvalid(err) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to create a new kube-dns service: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, err := client.CoreV1().Services(metav1.NamespaceSystem).Update(kubednsService); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to create/update the kube-dns service: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getDNSIP fetches the kubernetes service's ClusterIP and appends a "0" to it in order to get the DNS IP
0000000000000000000000000000000000000000;;	func getDNSIP(client *clientset.Clientset) (net.IP, error) {
0000000000000000000000000000000000000000;;		k8ssvc, err := client.CoreV1().Services(metav1.NamespaceDefault).Get("kubernetes", metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't fetch information about the kubernetes service: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(k8ssvc.Spec.ClusterIP) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't fetch a valid clusterIP from the kubernetes service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Build an IP by taking the kubernetes service's clusterIP and appending a "0" and checking that it's valid
0000000000000000000000000000000000000000;;		dnsIP := net.ParseIP(fmt.Sprintf("%s0", k8ssvc.Spec.ClusterIP))
0000000000000000000000000000000000000000;;		if dnsIP == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("could not parse dns ip %q: %v", dnsIP, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dnsIP, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getClusterCIDR(podsubnet string) string {
0000000000000000000000000000000000000000;;		if len(podsubnet) == 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "- --cluster-cidr=" + podsubnet
0000000000000000000000000000000000000000;;	}
