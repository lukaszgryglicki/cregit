0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
36168089890259145cc8170bc2b5dbdc1f573f61;cmd/kubeadm/app/master/manifests_test.go[cmd/kubeadm/app/master/manifests_test.go][cmd/kubeadm/app/phases/controlplane/manifests_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package controlplane
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/yaml"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm"
0000000000000000000000000000000000000000;;		kubeadmapi "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm"
0000000000000000000000000000000000000000;;		kubeadmconstants "k8s.io/kubernetes/cmd/kubeadm/app/constants"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/version"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		testCertsDir = "/var/lib/certs"
0000000000000000000000000000000000000000;;		etcdDataDir  = "/var/lib/etcd"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWriteStaticPodManifests(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpdir, err := ioutil.TempDir("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Couldn't create tmpdir")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpdir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set up tmp GlobalEnvParams values for testing
0000000000000000000000000000000000000000;;		oldEnv := kubeadmapi.GlobalEnvParams
0000000000000000000000000000000000000000;;		kubeadmapi.GlobalEnvParams.KubernetesDir = fmt.Sprintf("%s/etc/kubernetes", tmpdir)
0000000000000000000000000000000000000000;;		defer func() { kubeadmapi.GlobalEnvParams = oldEnv }()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			cfg                  *kubeadmapi.MasterConfiguration
0000000000000000000000000000000000000000;;			expectErr            bool
0000000000000000000000000000000000000000;;			expectedAPIProbePort int32
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cfg:       &kubeadmapi.MasterConfiguration{},
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cfg: &kubeadmapi.MasterConfiguration{
0000000000000000000000000000000000000000;;					API: kubeadmapi.API{
0000000000000000000000000000000000000000;;						BindPort: 443,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr:            true,
0000000000000000000000000000000000000000;;				expectedAPIProbePort: 443,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := WriteStaticPodManifests(rt.cfg)
0000000000000000000000000000000000000000;;			if (actual == nil) && rt.expectErr {
0000000000000000000000000000000000000000;;				t.Error("expected an error from WriteStaticPodManifests but got none")
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if (actual != nil) && !rt.expectErr {
0000000000000000000000000000000000000000;;				t.Errorf("didn't expect an error from WriteStaticPodManifests but got: %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rt.expectErr {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Below is dead code.
0000000000000000000000000000000000000000;;			if rt.expectedAPIProbePort != 0 {
0000000000000000000000000000000000000000;;				manifest, err := os.Open(filepath.Join(kubeadmapi.GlobalEnvParams.KubernetesDir, kubeadmconstants.ManifestsSubDirName, "kube-apiserver.yaml"))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("WriteStaticPodManifests: %v", err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer manifest.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var pod v1.Pod
0000000000000000000000000000000000000000;;				d := yaml.NewYAMLOrJSONDecoder(manifest, 4096)
0000000000000000000000000000000000000000;;				if err := d.Decode(&pod); err != nil {
0000000000000000000000000000000000000000;;					t.Error("WriteStaticPodManifests: error decoding manifests/kube-apiserver.yaml into Pod")
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Lots of individual checks as we traverse pointers so we don't panic dereferencing a nil on failure
0000000000000000000000000000000000000000;;				containers := pod.Spec.Containers
0000000000000000000000000000000000000000;;				if containers == nil || len(containers) == 0 {
0000000000000000000000000000000000000000;;					t.Error("WriteStaticPodManifests: wrote an apiserver manifest without any containers")
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				probe := containers[0].LivenessProbe
0000000000000000000000000000000000000000;;				if probe == nil {
0000000000000000000000000000000000000000;;					t.Error("WriteStaticPodManifests: wrote an apiserver manifest without a liveness probe")
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				httpGET := probe.Handler.HTTPGet
0000000000000000000000000000000000000000;;				if httpGET == nil {
0000000000000000000000000000000000000000;;					t.Error("WriteStaticPodManifests: wrote an apiserver manifest without an HTTP liveness probe")
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				port := httpGET.Port.IntVal
0000000000000000000000000000000000000000;;				if rt.expectedAPIProbePort != port {
0000000000000000000000000000000000000000;;					t.Errorf("WriteStaticPodManifests: apiserver pod liveness probe port was: %v, wanted %v", port, rt.expectedAPIProbePort)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			name     string
0000000000000000000000000000000000000000;;			path     string
0000000000000000000000000000000000000000;;			expected v1.Volume
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "foo",
0000000000000000000000000000000000000000;;				path: "/etc/foo",
0000000000000000000000000000000000000000;;				expected: v1.Volume{
0000000000000000000000000000000000000000;;					Name: "foo",
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						HostPath: &v1.HostPathVolumeSource{Path: "/etc/foo"},
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := newVolume(rt.name, rt.path)
0000000000000000000000000000000000000000;;			if actual.Name != rt.expected.Name {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed newVolume:\n\texpected: %s\n\t  actual: %s",
0000000000000000000000000000000000000000;;					rt.expected.Name,
0000000000000000000000000000000000000000;;					actual.Name,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actual.VolumeSource.HostPath.Path != rt.expected.VolumeSource.HostPath.Path {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed newVolume:\n\texpected: %s\n\t  actual: %s",
0000000000000000000000000000000000000000;;					rt.expected.VolumeSource.HostPath.Path,
0000000000000000000000000000000000000000;;					actual.VolumeSource.HostPath.Path,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewVolumeMount(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			name     string
0000000000000000000000000000000000000000;;			path     string
0000000000000000000000000000000000000000;;			expected v1.VolumeMount
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "foo",
0000000000000000000000000000000000000000;;				path: "/etc/foo",
0000000000000000000000000000000000000000;;				expected: v1.VolumeMount{
0000000000000000000000000000000000000000;;					Name:      "foo",
0000000000000000000000000000000000000000;;					MountPath: "/etc/foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := newVolumeMount(rt.name, rt.path)
0000000000000000000000000000000000000000;;			if actual.Name != rt.expected.Name {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed newVolumeMount:\n\texpected: %s\n\t  actual: %s",
0000000000000000000000000000000000000000;;					rt.expected.Name,
0000000000000000000000000000000000000000;;					actual.Name,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actual.MountPath != rt.expected.MountPath {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed newVolumeMount:\n\texpected: %s\n\t  actual: %s",
0000000000000000000000000000000000000000;;					rt.expected.MountPath,
0000000000000000000000000000000000000000;;					actual.MountPath,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEtcdVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			cfg      *kubeadmapi.MasterConfiguration
0000000000000000000000000000000000000000;;			expected v1.Volume
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cfg: &kubeadmapi.MasterConfiguration{
0000000000000000000000000000000000000000;;					Etcd: kubeadmapi.Etcd{DataDir: etcdDataDir},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: v1.Volume{
0000000000000000000000000000000000000000;;					Name: "etcd",
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						HostPath: &v1.HostPathVolumeSource{Path: etcdDataDir},
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := etcdVolume(rt.cfg)
0000000000000000000000000000000000000000;;			if actual.Name != rt.expected.Name {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed etcdVolume:\n\texpected: %s\n\t  actual: %s",
0000000000000000000000000000000000000000;;					rt.expected.Name,
0000000000000000000000000000000000000000;;					actual.Name,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actual.VolumeSource.HostPath.Path != rt.expected.VolumeSource.HostPath.Path {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed etcdVolume:\n\texpected: %s\n\t  actual: %s",
0000000000000000000000000000000000000000;;					rt.expected.VolumeSource.HostPath.Path,
0000000000000000000000000000000000000000;;					actual.VolumeSource.HostPath.Path,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEtcdVolumeMount(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			expected v1.VolumeMount
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				expected: v1.VolumeMount{
0000000000000000000000000000000000000000;;					Name:      "etcd",
0000000000000000000000000000000000000000;;					MountPath: etcdDataDir,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := etcdVolumeMount(etcdDataDir)
0000000000000000000000000000000000000000;;			if actual.Name != rt.expected.Name {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed etcdVolumeMount:\n\texpected: %s\n\t  actual: %s",
0000000000000000000000000000000000000000;;					rt.expected.Name,
0000000000000000000000000000000000000000;;					actual.Name,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actual.MountPath != rt.expected.MountPath {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed etcdVolumeMount:\n\texpected: %s\n\t  actual: %s",
0000000000000000000000000000000000000000;;					rt.expected.MountPath,
0000000000000000000000000000000000000000;;					actual.MountPath,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCertsVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			cfg      *kubeadmapi.MasterConfiguration
0000000000000000000000000000000000000000;;			expected v1.Volume
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cfg: &kubeadmapi.MasterConfiguration{},
0000000000000000000000000000000000000000;;				expected: v1.Volume{
0000000000000000000000000000000000000000;;					Name: "certs",
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						HostPath: &v1.HostPathVolumeSource{
0000000000000000000000000000000000000000;;							Path: "/etc/ssl/certs"},
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := certsVolume(rt.cfg)
0000000000000000000000000000000000000000;;			if actual.Name != rt.expected.Name {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed certsVolume:\n\texpected: %s\n\t  actual: %s",
0000000000000000000000000000000000000000;;					rt.expected.Name,
0000000000000000000000000000000000000000;;					actual.Name,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actual.VolumeSource.HostPath.Path != rt.expected.VolumeSource.HostPath.Path {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed certsVolume:\n\texpected: %s\n\t  actual: %s",
0000000000000000000000000000000000000000;;					rt.expected.VolumeSource.HostPath.Path,
0000000000000000000000000000000000000000;;					actual.VolumeSource.HostPath.Path,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCertsVolumeMount(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			expected v1.VolumeMount
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				expected: v1.VolumeMount{
0000000000000000000000000000000000000000;;					Name:      "certs",
0000000000000000000000000000000000000000;;					MountPath: "/etc/ssl/certs",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := certsVolumeMount()
0000000000000000000000000000000000000000;;			if actual.Name != rt.expected.Name {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed certsVolumeMount:\n\texpected: %s\n\t  actual: %s",
0000000000000000000000000000000000000000;;					rt.expected.Name,
0000000000000000000000000000000000000000;;					actual.Name,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actual.MountPath != rt.expected.MountPath {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed certsVolumeMount:\n\texpected: %s\n\t  actual: %s",
0000000000000000000000000000000000000000;;					rt.expected.MountPath,
0000000000000000000000000000000000000000;;					actual.MountPath,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestK8sVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			expected v1.Volume
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				expected: v1.Volume{
0000000000000000000000000000000000000000;;					Name: "k8s",
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						HostPath: &v1.HostPathVolumeSource{
0000000000000000000000000000000000000000;;							Path: kubeadmapi.GlobalEnvParams.KubernetesDir},
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := k8sVolume()
0000000000000000000000000000000000000000;;			if actual.Name != rt.expected.Name {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed k8sVolume:\n\texpected: %s\n\t  actual: %s",
0000000000000000000000000000000000000000;;					rt.expected.Name,
0000000000000000000000000000000000000000;;					actual.Name,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actual.VolumeSource.HostPath.Path != rt.expected.VolumeSource.HostPath.Path {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed k8sVolume:\n\texpected: %s\n\t  actual: %s",
0000000000000000000000000000000000000000;;					rt.expected.VolumeSource.HostPath.Path,
0000000000000000000000000000000000000000;;					actual.VolumeSource.HostPath.Path,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestK8sVolumeMount(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			expected v1.VolumeMount
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				expected: v1.VolumeMount{
0000000000000000000000000000000000000000;;					Name:      "k8s",
0000000000000000000000000000000000000000;;					MountPath: kubeadmapi.GlobalEnvParams.KubernetesDir,
0000000000000000000000000000000000000000;;					ReadOnly:  true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := k8sVolumeMount()
0000000000000000000000000000000000000000;;			if actual.Name != rt.expected.Name {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed k8sVolumeMount:\n\texpected: %s\n\t  actual: %s",
0000000000000000000000000000000000000000;;					rt.expected.Name,
0000000000000000000000000000000000000000;;					actual.Name,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actual.MountPath != rt.expected.MountPath {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed k8sVolumeMount:\n\texpected: %s\n\t  actual: %s",
0000000000000000000000000000000000000000;;					rt.expected.MountPath,
0000000000000000000000000000000000000000;;					actual.MountPath,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actual.ReadOnly != rt.expected.ReadOnly {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed k8sVolumeMount:\n\texpected: %t\n\t  actual: %t",
0000000000000000000000000000000000000000;;					rt.expected.ReadOnly,
0000000000000000000000000000000000000000;;					actual.ReadOnly,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestComponentResources(t *testing.T) {
0000000000000000000000000000000000000000;;		a := componentResources("250m")
0000000000000000000000000000000000000000;;		if a.Requests == nil {
0000000000000000000000000000000000000000;;			t.Errorf(
0000000000000000000000000000000000000000;;				"failed componentResources, return value was nil",
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestComponentProbe(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			port   int
0000000000000000000000000000000000000000;;			path   string
0000000000000000000000000000000000000000;;			scheme v1.URIScheme
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				port:   1,
0000000000000000000000000000000000000000;;				path:   "foo",
0000000000000000000000000000000000000000;;				scheme: v1.URISchemeHTTP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				port:   2,
0000000000000000000000000000000000000000;;				path:   "bar",
0000000000000000000000000000000000000000;;				scheme: v1.URISchemeHTTPS,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := componentProbe(rt.port, rt.path, rt.scheme)
0000000000000000000000000000000000000000;;			if actual.Handler.HTTPGet.Port != intstr.FromInt(rt.port) {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed componentProbe:\n\texpected: %v\n\t  actual: %v",
0000000000000000000000000000000000000000;;					rt.port,
0000000000000000000000000000000000000000;;					actual.Handler.HTTPGet.Port,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actual.Handler.HTTPGet.Path != rt.path {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed componentProbe:\n\texpected: %s\n\t  actual: %s",
0000000000000000000000000000000000000000;;					rt.path,
0000000000000000000000000000000000000000;;					actual.Handler.HTTPGet.Path,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actual.Handler.HTTPGet.Scheme != rt.scheme {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed componentProbe:\n\texpected: %v\n\t  actual: %v",
0000000000000000000000000000000000000000;;					rt.scheme,
0000000000000000000000000000000000000000;;					actual.Handler.HTTPGet.Scheme,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestComponentPod(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			n string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				n: "foo",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			c := v1.Container{Name: rt.n}
0000000000000000000000000000000000000000;;			v := v1.Volume{}
0000000000000000000000000000000000000000;;			actual := componentPod(c, v)
0000000000000000000000000000000000000000;;			if actual.ObjectMeta.Name != rt.n {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"failed componentPod:\n\texpected: %s\n\t  actual: %s",
0000000000000000000000000000000000000000;;					rt.n,
0000000000000000000000000000000000000000;;					actual.ObjectMeta.Name,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetAPIServerCommand(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			cfg      *kubeadmapi.MasterConfiguration
0000000000000000000000000000000000000000;;			expected []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cfg: &kubeadmapi.MasterConfiguration{
0000000000000000000000000000000000000000;;					API:               kubeadm.API{BindPort: 123, AdvertiseAddress: "1.2.3.4"},
0000000000000000000000000000000000000000;;					Networking:        kubeadm.Networking{ServiceSubnet: "bar"},
0000000000000000000000000000000000000000;;					CertificatesDir:   testCertsDir,
0000000000000000000000000000000000000000;;					KubernetesVersion: "v1.7.0",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"kube-apiserver",
0000000000000000000000000000000000000000;;					"--insecure-port=0",
0000000000000000000000000000000000000000;;					"--admission-control=Initializers,NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota",
0000000000000000000000000000000000000000;;					"--service-cluster-ip-range=bar",
0000000000000000000000000000000000000000;;					"--service-account-key-file=" + testCertsDir + "/sa.pub",
0000000000000000000000000000000000000000;;					"--client-ca-file=" + testCertsDir + "/ca.crt",
0000000000000000000000000000000000000000;;					"--tls-cert-file=" + testCertsDir + "/apiserver.crt",
0000000000000000000000000000000000000000;;					"--tls-private-key-file=" + testCertsDir + "/apiserver.key",
0000000000000000000000000000000000000000;;					"--kubelet-client-certificate=" + testCertsDir + "/apiserver-kubelet-client.crt",
0000000000000000000000000000000000000000;;					"--kubelet-client-key=" + testCertsDir + "/apiserver-kubelet-client.key",
0000000000000000000000000000000000000000;;					"--secure-port=123",
0000000000000000000000000000000000000000;;					"--allow-privileged=true",
0000000000000000000000000000000000000000;;					"--kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname",
0000000000000000000000000000000000000000;;					"--experimental-bootstrap-token-auth=true",
0000000000000000000000000000000000000000;;					"--proxy-client-cert-file=/var/lib/certs/front-proxy-client.crt",
0000000000000000000000000000000000000000;;					"--proxy-client-key-file=/var/lib/certs/front-proxy-client.key",
0000000000000000000000000000000000000000;;					"--requestheader-username-headers=X-Remote-User",
0000000000000000000000000000000000000000;;					"--requestheader-group-headers=X-Remote-Group",
0000000000000000000000000000000000000000;;					"--requestheader-extra-headers-prefix=X-Remote-Extra-",
0000000000000000000000000000000000000000;;					"--requestheader-client-ca-file=" + testCertsDir + "/front-proxy-ca.crt",
0000000000000000000000000000000000000000;;					"--requestheader-allowed-names=front-proxy-client",
0000000000000000000000000000000000000000;;					"--authorization-mode=Node,RBAC",
0000000000000000000000000000000000000000;;					"--advertise-address=1.2.3.4",
0000000000000000000000000000000000000000;;					"--etcd-servers=http://127.0.0.1:2379",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cfg: &kubeadmapi.MasterConfiguration{
0000000000000000000000000000000000000000;;					API:               kubeadm.API{BindPort: 123, AdvertiseAddress: "4.3.2.1"},
0000000000000000000000000000000000000000;;					Networking:        kubeadm.Networking{ServiceSubnet: "bar"},
0000000000000000000000000000000000000000;;					CertificatesDir:   testCertsDir,
0000000000000000000000000000000000000000;;					KubernetesVersion: "v1.7.1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"kube-apiserver",
0000000000000000000000000000000000000000;;					"--insecure-port=0",
0000000000000000000000000000000000000000;;					"--admission-control=Initializers,NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota",
0000000000000000000000000000000000000000;;					"--service-cluster-ip-range=bar",
0000000000000000000000000000000000000000;;					"--service-account-key-file=" + testCertsDir + "/sa.pub",
0000000000000000000000000000000000000000;;					"--client-ca-file=" + testCertsDir + "/ca.crt",
0000000000000000000000000000000000000000;;					"--tls-cert-file=" + testCertsDir + "/apiserver.crt",
0000000000000000000000000000000000000000;;					"--tls-private-key-file=" + testCertsDir + "/apiserver.key",
0000000000000000000000000000000000000000;;					"--kubelet-client-certificate=" + testCertsDir + "/apiserver-kubelet-client.crt",
0000000000000000000000000000000000000000;;					"--kubelet-client-key=" + testCertsDir + "/apiserver-kubelet-client.key",
0000000000000000000000000000000000000000;;					"--secure-port=123",
0000000000000000000000000000000000000000;;					"--allow-privileged=true",
0000000000000000000000000000000000000000;;					"--kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname",
0000000000000000000000000000000000000000;;					"--experimental-bootstrap-token-auth=true",
0000000000000000000000000000000000000000;;					"--proxy-client-cert-file=/var/lib/certs/front-proxy-client.crt",
0000000000000000000000000000000000000000;;					"--proxy-client-key-file=/var/lib/certs/front-proxy-client.key",
0000000000000000000000000000000000000000;;					"--requestheader-username-headers=X-Remote-User",
0000000000000000000000000000000000000000;;					"--requestheader-group-headers=X-Remote-Group",
0000000000000000000000000000000000000000;;					"--requestheader-extra-headers-prefix=X-Remote-Extra-",
0000000000000000000000000000000000000000;;					"--requestheader-client-ca-file=" + testCertsDir + "/front-proxy-ca.crt",
0000000000000000000000000000000000000000;;					"--requestheader-allowed-names=front-proxy-client",
0000000000000000000000000000000000000000;;					"--authorization-mode=Node,RBAC",
0000000000000000000000000000000000000000;;					"--advertise-address=4.3.2.1",
0000000000000000000000000000000000000000;;					"--etcd-servers=http://127.0.0.1:2379",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cfg: &kubeadmapi.MasterConfiguration{
0000000000000000000000000000000000000000;;					API:               kubeadm.API{BindPort: 123, AdvertiseAddress: "4.3.2.1"},
0000000000000000000000000000000000000000;;					Networking:        kubeadm.Networking{ServiceSubnet: "bar"},
0000000000000000000000000000000000000000;;					Etcd:              kubeadm.Etcd{CertFile: "fiz", KeyFile: "faz"},
0000000000000000000000000000000000000000;;					CertificatesDir:   testCertsDir,
0000000000000000000000000000000000000000;;					KubernetesVersion: "v1.7.2",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"kube-apiserver",
0000000000000000000000000000000000000000;;					"--insecure-port=0",
0000000000000000000000000000000000000000;;					"--admission-control=Initializers,NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota",
0000000000000000000000000000000000000000;;					"--service-cluster-ip-range=bar",
0000000000000000000000000000000000000000;;					"--service-account-key-file=" + testCertsDir + "/sa.pub",
0000000000000000000000000000000000000000;;					"--client-ca-file=" + testCertsDir + "/ca.crt",
0000000000000000000000000000000000000000;;					"--tls-cert-file=" + testCertsDir + "/apiserver.crt",
0000000000000000000000000000000000000000;;					"--tls-private-key-file=" + testCertsDir + "/apiserver.key",
0000000000000000000000000000000000000000;;					"--kubelet-client-certificate=" + testCertsDir + "/apiserver-kubelet-client.crt",
0000000000000000000000000000000000000000;;					"--kubelet-client-key=" + testCertsDir + "/apiserver-kubelet-client.key",
0000000000000000000000000000000000000000;;					"--secure-port=123",
0000000000000000000000000000000000000000;;					"--allow-privileged=true",
0000000000000000000000000000000000000000;;					"--kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname",
0000000000000000000000000000000000000000;;					"--experimental-bootstrap-token-auth=true",
0000000000000000000000000000000000000000;;					"--proxy-client-cert-file=/var/lib/certs/front-proxy-client.crt",
0000000000000000000000000000000000000000;;					"--proxy-client-key-file=/var/lib/certs/front-proxy-client.key",
0000000000000000000000000000000000000000;;					"--requestheader-username-headers=X-Remote-User",
0000000000000000000000000000000000000000;;					"--requestheader-group-headers=X-Remote-Group",
0000000000000000000000000000000000000000;;					"--requestheader-extra-headers-prefix=X-Remote-Extra-",
0000000000000000000000000000000000000000;;					"--requestheader-client-ca-file=" + testCertsDir + "/front-proxy-ca.crt",
0000000000000000000000000000000000000000;;					"--requestheader-allowed-names=front-proxy-client",
0000000000000000000000000000000000000000;;					"--authorization-mode=Node,RBAC",
0000000000000000000000000000000000000000;;					"--advertise-address=4.3.2.1",
0000000000000000000000000000000000000000;;					"--etcd-servers=http://127.0.0.1:2379",
0000000000000000000000000000000000000000;;					"--etcd-certfile=fiz",
0000000000000000000000000000000000000000;;					"--etcd-keyfile=faz",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cfg: &kubeadmapi.MasterConfiguration{
0000000000000000000000000000000000000000;;					API:               kubeadm.API{BindPort: 123, AdvertiseAddress: "4.3.2.1"},
0000000000000000000000000000000000000000;;					Networking:        kubeadm.Networking{ServiceSubnet: "bar"},
0000000000000000000000000000000000000000;;					Etcd:              kubeadm.Etcd{CertFile: "fiz", KeyFile: "faz"},
0000000000000000000000000000000000000000;;					CertificatesDir:   testCertsDir,
0000000000000000000000000000000000000000;;					KubernetesVersion: "v1.7.3",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"kube-apiserver",
0000000000000000000000000000000000000000;;					"--insecure-port=0",
0000000000000000000000000000000000000000;;					"--admission-control=Initializers,NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota",
0000000000000000000000000000000000000000;;					"--service-cluster-ip-range=bar",
0000000000000000000000000000000000000000;;					"--service-account-key-file=" + testCertsDir + "/sa.pub",
0000000000000000000000000000000000000000;;					"--client-ca-file=" + testCertsDir + "/ca.crt",
0000000000000000000000000000000000000000;;					"--tls-cert-file=" + testCertsDir + "/apiserver.crt",
0000000000000000000000000000000000000000;;					"--tls-private-key-file=" + testCertsDir + "/apiserver.key",
0000000000000000000000000000000000000000;;					"--kubelet-client-certificate=" + testCertsDir + "/apiserver-kubelet-client.crt",
0000000000000000000000000000000000000000;;					"--kubelet-client-key=" + testCertsDir + "/apiserver-kubelet-client.key",
0000000000000000000000000000000000000000;;					fmt.Sprintf("--secure-port=%d", 123),
0000000000000000000000000000000000000000;;					"--allow-privileged=true",
0000000000000000000000000000000000000000;;					"--kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname",
0000000000000000000000000000000000000000;;					"--experimental-bootstrap-token-auth=true",
0000000000000000000000000000000000000000;;					"--proxy-client-cert-file=/var/lib/certs/front-proxy-client.crt",
0000000000000000000000000000000000000000;;					"--proxy-client-key-file=/var/lib/certs/front-proxy-client.key",
0000000000000000000000000000000000000000;;					"--requestheader-username-headers=X-Remote-User",
0000000000000000000000000000000000000000;;					"--requestheader-group-headers=X-Remote-Group",
0000000000000000000000000000000000000000;;					"--requestheader-extra-headers-prefix=X-Remote-Extra-",
0000000000000000000000000000000000000000;;					"--requestheader-client-ca-file=" + testCertsDir + "/front-proxy-ca.crt",
0000000000000000000000000000000000000000;;					"--requestheader-allowed-names=front-proxy-client",
0000000000000000000000000000000000000000;;					"--authorization-mode=Node,RBAC",
0000000000000000000000000000000000000000;;					"--advertise-address=4.3.2.1",
0000000000000000000000000000000000000000;;					"--etcd-servers=http://127.0.0.1:2379",
0000000000000000000000000000000000000000;;					"--etcd-certfile=fiz",
0000000000000000000000000000000000000000;;					"--etcd-keyfile=faz",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cfg: &kubeadmapi.MasterConfiguration{
0000000000000000000000000000000000000000;;					API:               kubeadm.API{BindPort: 123, AdvertiseAddress: "2001:db8::1"},
0000000000000000000000000000000000000000;;					Networking:        kubeadm.Networking{ServiceSubnet: "bar"},
0000000000000000000000000000000000000000;;					Etcd:              kubeadm.Etcd{CertFile: "fiz", KeyFile: "faz"},
0000000000000000000000000000000000000000;;					CertificatesDir:   testCertsDir,
0000000000000000000000000000000000000000;;					KubernetesVersion: "v1.7.0",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"kube-apiserver",
0000000000000000000000000000000000000000;;					"--insecure-port=0",
0000000000000000000000000000000000000000;;					"--admission-control=Initializers,NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota",
0000000000000000000000000000000000000000;;					"--service-cluster-ip-range=bar",
0000000000000000000000000000000000000000;;					"--service-account-key-file=" + testCertsDir + "/sa.pub",
0000000000000000000000000000000000000000;;					"--client-ca-file=" + testCertsDir + "/ca.crt",
0000000000000000000000000000000000000000;;					"--tls-cert-file=" + testCertsDir + "/apiserver.crt",
0000000000000000000000000000000000000000;;					"--tls-private-key-file=" + testCertsDir + "/apiserver.key",
0000000000000000000000000000000000000000;;					"--kubelet-client-certificate=" + testCertsDir + "/apiserver-kubelet-client.crt",
0000000000000000000000000000000000000000;;					"--kubelet-client-key=" + testCertsDir + "/apiserver-kubelet-client.key",
0000000000000000000000000000000000000000;;					fmt.Sprintf("--secure-port=%d", 123),
0000000000000000000000000000000000000000;;					"--allow-privileged=true",
0000000000000000000000000000000000000000;;					"--kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname",
0000000000000000000000000000000000000000;;					"--experimental-bootstrap-token-auth=true",
0000000000000000000000000000000000000000;;					"--proxy-client-cert-file=/var/lib/certs/front-proxy-client.crt",
0000000000000000000000000000000000000000;;					"--proxy-client-key-file=/var/lib/certs/front-proxy-client.key",
0000000000000000000000000000000000000000;;					"--requestheader-username-headers=X-Remote-User",
0000000000000000000000000000000000000000;;					"--requestheader-group-headers=X-Remote-Group",
0000000000000000000000000000000000000000;;					"--requestheader-extra-headers-prefix=X-Remote-Extra-",
0000000000000000000000000000000000000000;;					"--requestheader-client-ca-file=" + testCertsDir + "/front-proxy-ca.crt",
0000000000000000000000000000000000000000;;					"--requestheader-allowed-names=front-proxy-client",
0000000000000000000000000000000000000000;;					"--authorization-mode=Node,RBAC",
0000000000000000000000000000000000000000;;					"--advertise-address=2001:db8::1",
0000000000000000000000000000000000000000;;					"--etcd-servers=http://127.0.0.1:2379",
0000000000000000000000000000000000000000;;					"--etcd-certfile=fiz",
0000000000000000000000000000000000000000;;					"--etcd-keyfile=faz",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := getAPIServerCommand(rt.cfg, false, version.MustParseSemantic(rt.cfg.KubernetesVersion))
0000000000000000000000000000000000000000;;			sort.Strings(actual)
0000000000000000000000000000000000000000;;			sort.Strings(rt.expected)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(actual, rt.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("failed getAPIServerCommand:\nexpected:\n%v\nsaw:\n%v", rt.expected, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetControllerManagerCommand(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			cfg      *kubeadmapi.MasterConfiguration
0000000000000000000000000000000000000000;;			expected []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cfg: &kubeadmapi.MasterConfiguration{
0000000000000000000000000000000000000000;;					CertificatesDir:   testCertsDir,
0000000000000000000000000000000000000000;;					KubernetesVersion: "v1.7.0",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"kube-controller-manager",
0000000000000000000000000000000000000000;;					"--address=127.0.0.1",
0000000000000000000000000000000000000000;;					"--leader-elect=true",
0000000000000000000000000000000000000000;;					"--kubeconfig=" + kubeadmapi.GlobalEnvParams.KubernetesDir + "/controller-manager.conf",
0000000000000000000000000000000000000000;;					"--root-ca-file=" + testCertsDir + "/ca.crt",
0000000000000000000000000000000000000000;;					"--service-account-private-key-file=" + testCertsDir + "/sa.key",
0000000000000000000000000000000000000000;;					"--cluster-signing-cert-file=" + testCertsDir + "/ca.crt",
0000000000000000000000000000000000000000;;					"--cluster-signing-key-file=" + testCertsDir + "/ca.key",
0000000000000000000000000000000000000000;;					"--use-service-account-credentials=true",
0000000000000000000000000000000000000000;;					"--controllers=*,bootstrapsigner,tokencleaner",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cfg: &kubeadmapi.MasterConfiguration{
0000000000000000000000000000000000000000;;					CloudProvider:     "foo",
0000000000000000000000000000000000000000;;					CertificatesDir:   testCertsDir,
0000000000000000000000000000000000000000;;					KubernetesVersion: "v1.7.0",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"kube-controller-manager",
0000000000000000000000000000000000000000;;					"--address=127.0.0.1",
0000000000000000000000000000000000000000;;					"--leader-elect=true",
0000000000000000000000000000000000000000;;					"--kubeconfig=" + kubeadmapi.GlobalEnvParams.KubernetesDir + "/controller-manager.conf",
0000000000000000000000000000000000000000;;					"--root-ca-file=" + testCertsDir + "/ca.crt",
0000000000000000000000000000000000000000;;					"--service-account-private-key-file=" + testCertsDir + "/sa.key",
0000000000000000000000000000000000000000;;					"--cluster-signing-cert-file=" + testCertsDir + "/ca.crt",
0000000000000000000000000000000000000000;;					"--cluster-signing-key-file=" + testCertsDir + "/ca.key",
0000000000000000000000000000000000000000;;					"--use-service-account-credentials=true",
0000000000000000000000000000000000000000;;					"--controllers=*,bootstrapsigner,tokencleaner",
0000000000000000000000000000000000000000;;					"--cloud-provider=foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cfg: &kubeadmapi.MasterConfiguration{
0000000000000000000000000000000000000000;;					Networking:        kubeadm.Networking{PodSubnet: "bar"},
0000000000000000000000000000000000000000;;					CertificatesDir:   testCertsDir,
0000000000000000000000000000000000000000;;					KubernetesVersion: "v1.7.0",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"kube-controller-manager",
0000000000000000000000000000000000000000;;					"--address=127.0.0.1",
0000000000000000000000000000000000000000;;					"--leader-elect=true",
0000000000000000000000000000000000000000;;					"--kubeconfig=" + kubeadmapi.GlobalEnvParams.KubernetesDir + "/controller-manager.conf",
0000000000000000000000000000000000000000;;					"--root-ca-file=" + testCertsDir + "/ca.crt",
0000000000000000000000000000000000000000;;					"--service-account-private-key-file=" + testCertsDir + "/sa.key",
0000000000000000000000000000000000000000;;					"--cluster-signing-cert-file=" + testCertsDir + "/ca.crt",
0000000000000000000000000000000000000000;;					"--cluster-signing-key-file=" + testCertsDir + "/ca.key",
0000000000000000000000000000000000000000;;					"--use-service-account-credentials=true",
0000000000000000000000000000000000000000;;					"--controllers=*,bootstrapsigner,tokencleaner",
0000000000000000000000000000000000000000;;					"--allocate-node-cidrs=true",
0000000000000000000000000000000000000000;;					"--cluster-cidr=bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := getControllerManagerCommand(rt.cfg, false, version.MustParseSemantic(rt.cfg.KubernetesVersion))
0000000000000000000000000000000000000000;;			sort.Strings(actual)
0000000000000000000000000000000000000000;;			sort.Strings(rt.expected)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(actual, rt.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("failed getControllerManagerCommand:\nexpected:\n%v\nsaw:\n%v", rt.expected, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetEtcdCommand(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			cfg      *kubeadmapi.MasterConfiguration
0000000000000000000000000000000000000000;;			expected []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cfg: &kubeadmapi.MasterConfiguration{
0000000000000000000000000000000000000000;;					Etcd: kubeadmapi.Etcd{DataDir: "/var/lib/etcd"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"etcd",
0000000000000000000000000000000000000000;;					"--listen-client-urls=http://127.0.0.1:2379",
0000000000000000000000000000000000000000;;					"--advertise-client-urls=http://127.0.0.1:2379",
0000000000000000000000000000000000000000;;					"--data-dir=/var/lib/etcd",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cfg: &kubeadmapi.MasterConfiguration{
0000000000000000000000000000000000000000;;					Etcd: kubeadmapi.Etcd{
0000000000000000000000000000000000000000;;						DataDir: "/var/lib/etcd",
0000000000000000000000000000000000000000;;						ExtraArgs: map[string]string{
0000000000000000000000000000000000000000;;							"listen-client-urls":    "http://10.0.1.10:2379",
0000000000000000000000000000000000000000;;							"advertise-client-urls": "http://10.0.1.10:2379",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"etcd",
0000000000000000000000000000000000000000;;					"--listen-client-urls=http://10.0.1.10:2379",
0000000000000000000000000000000000000000;;					"--advertise-client-urls=http://10.0.1.10:2379",
0000000000000000000000000000000000000000;;					"--data-dir=/var/lib/etcd",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cfg: &kubeadmapi.MasterConfiguration{
0000000000000000000000000000000000000000;;					Etcd: kubeadmapi.Etcd{DataDir: "/etc/foo"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"etcd",
0000000000000000000000000000000000000000;;					"--listen-client-urls=http://127.0.0.1:2379",
0000000000000000000000000000000000000000;;					"--advertise-client-urls=http://127.0.0.1:2379",
0000000000000000000000000000000000000000;;					"--data-dir=/etc/foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := getEtcdCommand(rt.cfg)
0000000000000000000000000000000000000000;;			sort.Strings(actual)
0000000000000000000000000000000000000000;;			sort.Strings(rt.expected)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(actual, rt.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("failed getEtcdCommand:\nexpected:\n%v\nsaw:\n%v", rt.expected, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetSchedulerCommand(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			cfg      *kubeadmapi.MasterConfiguration
0000000000000000000000000000000000000000;;			expected []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cfg: &kubeadmapi.MasterConfiguration{},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"kube-scheduler",
0000000000000000000000000000000000000000;;					"--address=127.0.0.1",
0000000000000000000000000000000000000000;;					"--leader-elect=true",
0000000000000000000000000000000000000000;;					"--kubeconfig=" + kubeadmapi.GlobalEnvParams.KubernetesDir + "/scheduler.conf",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := getSchedulerCommand(rt.cfg, false)
0000000000000000000000000000000000000000;;			sort.Strings(actual)
0000000000000000000000000000000000000000;;			sort.Strings(rt.expected)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(actual, rt.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("failed getSchedulerCommand:\nexpected:\n%v\nsaw:\n%v", rt.expected, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetAuthzParameters(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			authMode []string
0000000000000000000000000000000000000000;;			expected []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				authMode: []string{},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"--authorization-mode=Node,RBAC",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				authMode: []string{"RBAC"},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"--authorization-mode=RBAC",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				authMode: []string{"AlwaysAllow"},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"--authorization-mode=AlwaysAllow",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				authMode: []string{"AlwaysDeny"},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"--authorization-mode=AlwaysDeny",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				authMode: []string{"ABAC"},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"--authorization-mode=ABAC",
0000000000000000000000000000000000000000;;					"--authorization-policy-file=/etc/kubernetes/abac_policy.json",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				authMode: []string{"ABAC", "Webhook"},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"--authorization-mode=ABAC,Webhook",
0000000000000000000000000000000000000000;;					"--authorization-policy-file=/etc/kubernetes/abac_policy.json",
0000000000000000000000000000000000000000;;					"--authorization-webhook-config-file=/etc/kubernetes/webhook_authz.conf",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				authMode: []string{"ABAC", "RBAC", "Webhook"},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"--authorization-mode=ABAC,RBAC,Webhook",
0000000000000000000000000000000000000000;;					"--authorization-policy-file=/etc/kubernetes/abac_policy.json",
0000000000000000000000000000000000000000;;					"--authorization-webhook-config-file=/etc/kubernetes/webhook_authz.conf",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				authMode: []string{"Node", "RBAC", "Webhook", "ABAC"},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"--authorization-mode=Node,RBAC,Webhook,ABAC",
0000000000000000000000000000000000000000;;					"--authorization-policy-file=/etc/kubernetes/abac_policy.json",
0000000000000000000000000000000000000000;;					"--authorization-webhook-config-file=/etc/kubernetes/webhook_authz.conf",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := getAuthzParameters(rt.authMode)
0000000000000000000000000000000000000000;;			sort.Strings(actual)
0000000000000000000000000000000000000000;;			sort.Strings(rt.expected)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(actual, rt.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("failed getAuthzParameters:\nexpected:\n%v\nsaw:\n%v", rt.expected, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetExtraParameters(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			overrides map[string]string
0000000000000000000000000000000000000000;;			defaults  map[string]string
0000000000000000000000000000000000000000;;			expected  []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				overrides: map[string]string{
0000000000000000000000000000000000000000;;					"admission-control": "NamespaceLifecycle,LimitRanger",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				defaults: map[string]string{
0000000000000000000000000000000000000000;;					"admission-control":     "NamespaceLifecycle",
0000000000000000000000000000000000000000;;					"insecure-bind-address": "127.0.0.1",
0000000000000000000000000000000000000000;;					"allow-privileged":      "true",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"--admission-control=NamespaceLifecycle,LimitRanger",
0000000000000000000000000000000000000000;;					"--insecure-bind-address=127.0.0.1",
0000000000000000000000000000000000000000;;					"--allow-privileged=true",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				overrides: map[string]string{
0000000000000000000000000000000000000000;;					"admission-control": "NamespaceLifecycle,LimitRanger",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				defaults: map[string]string{
0000000000000000000000000000000000000000;;					"insecure-bind-address": "127.0.0.1",
0000000000000000000000000000000000000000;;					"allow-privileged":      "true",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []string{
0000000000000000000000000000000000000000;;					"--admission-control=NamespaceLifecycle,LimitRanger",
0000000000000000000000000000000000000000;;					"--insecure-bind-address=127.0.0.1",
0000000000000000000000000000000000000000;;					"--allow-privileged=true",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rt := range tests {
0000000000000000000000000000000000000000;;			actual := getExtraParameters(rt.overrides, rt.defaults)
0000000000000000000000000000000000000000;;			sort.Strings(actual)
0000000000000000000000000000000000000000;;			sort.Strings(rt.expected)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(actual, rt.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("failed getExtraParameters:\nexpected:\n%v\nsaw:\n%v", rt.expected, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
