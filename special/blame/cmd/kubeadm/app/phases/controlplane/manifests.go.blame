0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
9db0eae9e9d83114763752acc01f8cf31dda41c2;pkg/kubeadm/master/manifests.go[pkg/kubeadm/master/manifests.go][cmd/kubeadm/app/phases/controlplane/manifests.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package controlplane
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/ghodss/yaml"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		kubeadmapi "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm"
0000000000000000000000000000000000000000;;		kubeadmapiext "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1alpha1"
0000000000000000000000000000000000000000;;		kubeadmconstants "k8s.io/kubernetes/cmd/kubeadm/app/constants"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubeadm/app/images"
0000000000000000000000000000000000000000;;		authzmodes "k8s.io/kubernetes/pkg/kubeapiserver/authorizer/modes"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		kubetypes "k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/version"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Static pod definitions in golang form are included below so that `kubeadm init` can get going.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DefaultCloudConfigPath = "/etc/kubernetes/cloud-config"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaultv17AdmissionControl = "Initializers,NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		etcd                  = "etcd"
0000000000000000000000000000000000000000;;		kubeAPIServer         = "kube-apiserver"
0000000000000000000000000000000000000000;;		kubeControllerManager = "kube-controller-manager"
0000000000000000000000000000000000000000;;		kubeScheduler         = "kube-scheduler"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteStaticPodManifests builds manifest objects based on user provided configuration and then dumps it to disk
0000000000000000000000000000000000000000;;	// where kubelet will pick and schedule them.
0000000000000000000000000000000000000000;;	func WriteStaticPodManifests(cfg *kubeadmapi.MasterConfiguration) error {
0000000000000000000000000000000000000000;;		volumes := []v1.Volume{k8sVolume()}
0000000000000000000000000000000000000000;;		volumeMounts := []v1.VolumeMount{k8sVolumeMount()}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isCertsVolumeMountNeeded() {
0000000000000000000000000000000000000000;;			volumes = append(volumes, certsVolume(cfg))
0000000000000000000000000000000000000000;;			volumeMounts = append(volumeMounts, certsVolumeMount())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isPkiVolumeMountNeeded() {
0000000000000000000000000000000000000000;;			volumes = append(volumes, pkiVolume())
0000000000000000000000000000000000000000;;			volumeMounts = append(volumeMounts, pkiVolumeMount())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(cfg.CertificatesDir, kubeadmapiext.DefaultCertificatesDir) {
0000000000000000000000000000000000000000;;			volumes = append(volumes, newVolume("certdir", cfg.CertificatesDir))
0000000000000000000000000000000000000000;;			volumeMounts = append(volumeMounts, newVolumeMount("certdir", cfg.CertificatesDir))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		k8sVersion, err := version.ParseSemantic(cfg.KubernetesVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Prepare static pod specs
0000000000000000000000000000000000000000;;		staticPodSpecs := map[string]v1.Pod{
0000000000000000000000000000000000000000;;			kubeAPIServer: componentPod(v1.Container{
0000000000000000000000000000000000000000;;				Name:          kubeAPIServer,
0000000000000000000000000000000000000000;;				Image:         images.GetCoreImage(images.KubeAPIServerImage, cfg, cfg.UnifiedControlPlaneImage),
0000000000000000000000000000000000000000;;				Command:       getAPIServerCommand(cfg, false, k8sVersion),
0000000000000000000000000000000000000000;;				VolumeMounts:  volumeMounts,
0000000000000000000000000000000000000000;;				LivenessProbe: componentProbe(int(cfg.API.BindPort), "/healthz", v1.URISchemeHTTPS),
0000000000000000000000000000000000000000;;				Resources:     componentResources("250m"),
0000000000000000000000000000000000000000;;				Env:           getProxyEnvVars(),
0000000000000000000000000000000000000000;;			}, volumes...),
0000000000000000000000000000000000000000;;			kubeControllerManager: componentPod(v1.Container{
0000000000000000000000000000000000000000;;				Name:          kubeControllerManager,
0000000000000000000000000000000000000000;;				Image:         images.GetCoreImage(images.KubeControllerManagerImage, cfg, cfg.UnifiedControlPlaneImage),
0000000000000000000000000000000000000000;;				Command:       getControllerManagerCommand(cfg, false, k8sVersion),
0000000000000000000000000000000000000000;;				VolumeMounts:  volumeMounts,
0000000000000000000000000000000000000000;;				LivenessProbe: componentProbe(10252, "/healthz", v1.URISchemeHTTP),
0000000000000000000000000000000000000000;;				Resources:     componentResources("200m"),
0000000000000000000000000000000000000000;;				Env:           getProxyEnvVars(),
0000000000000000000000000000000000000000;;			}, volumes...),
0000000000000000000000000000000000000000;;			kubeScheduler: componentPod(v1.Container{
0000000000000000000000000000000000000000;;				Name:          kubeScheduler,
0000000000000000000000000000000000000000;;				Image:         images.GetCoreImage(images.KubeSchedulerImage, cfg, cfg.UnifiedControlPlaneImage),
0000000000000000000000000000000000000000;;				Command:       getSchedulerCommand(cfg, false),
0000000000000000000000000000000000000000;;				VolumeMounts:  []v1.VolumeMount{k8sVolumeMount()},
0000000000000000000000000000000000000000;;				LivenessProbe: componentProbe(10251, "/healthz", v1.URISchemeHTTP),
0000000000000000000000000000000000000000;;				Resources:     componentResources("100m"),
0000000000000000000000000000000000000000;;				Env:           getProxyEnvVars(),
0000000000000000000000000000000000000000;;			}, k8sVolume()),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add etcd static pod spec only if external etcd is not configured
0000000000000000000000000000000000000000;;		if len(cfg.Etcd.Endpoints) == 0 {
0000000000000000000000000000000000000000;;			etcdPod := componentPod(v1.Container{
0000000000000000000000000000000000000000;;				Name:          etcd,
0000000000000000000000000000000000000000;;				Command:       getEtcdCommand(cfg),
0000000000000000000000000000000000000000;;				VolumeMounts:  []v1.VolumeMount{certsVolumeMount(), etcdVolumeMount(cfg.Etcd.DataDir), k8sVolumeMount()},
0000000000000000000000000000000000000000;;				Image:         images.GetCoreImage(images.KubeEtcdImage, cfg, cfg.Etcd.Image),
0000000000000000000000000000000000000000;;				LivenessProbe: componentProbe(2379, "/health", v1.URISchemeHTTP),
0000000000000000000000000000000000000000;;			}, certsVolume(cfg), etcdVolume(cfg), k8sVolume())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			etcdPod.Spec.SecurityContext = &v1.PodSecurityContext{
0000000000000000000000000000000000000000;;				SELinuxOptions: &v1.SELinuxOptions{
0000000000000000000000000000000000000000;;					// Unconfine the etcd container so it can write to the data dir with SELinux enforcing:
0000000000000000000000000000000000000000;;					Type: "spc_t",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			staticPodSpecs[etcd] = etcdPod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		manifestsPath := filepath.Join(kubeadmapi.GlobalEnvParams.KubernetesDir, kubeadmconstants.ManifestsSubDirName)
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(manifestsPath, 0700); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to create directory %q [%v]", manifestsPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for name, spec := range staticPodSpecs {
0000000000000000000000000000000000000000;;			filename := filepath.Join(manifestsPath, name+".yaml")
0000000000000000000000000000000000000000;;			serialized, err := yaml.Marshal(spec)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to marshal manifest for %q to YAML [%v]", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := cmdutil.DumpReaderToFile(bytes.NewReader(serialized), filename); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to create static pod manifest file for %q (%q) [%v]", name, filename, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newVolume(name, path string) v1.Volume {
0000000000000000000000000000000000000000;;		return v1.Volume{
0000000000000000000000000000000000000000;;			Name: name,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				HostPath: &v1.HostPathVolumeSource{Path: path},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newVolumeMount(name, path string) v1.VolumeMount {
0000000000000000000000000000000000000000;;		return v1.VolumeMount{
0000000000000000000000000000000000000000;;			Name:      name,
0000000000000000000000000000000000000000;;			MountPath: path,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// etcdVolume exposes a path on the host in order to guarantee data survival during reboot.
0000000000000000000000000000000000000000;;	func etcdVolume(cfg *kubeadmapi.MasterConfiguration) v1.Volume {
0000000000000000000000000000000000000000;;		return v1.Volume{
0000000000000000000000000000000000000000;;			Name: "etcd",
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				HostPath: &v1.HostPathVolumeSource{Path: cfg.Etcd.DataDir},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func etcdVolumeMount(dataDir string) v1.VolumeMount {
0000000000000000000000000000000000000000;;		return v1.VolumeMount{
0000000000000000000000000000000000000000;;			Name:      "etcd",
0000000000000000000000000000000000000000;;			MountPath: dataDir,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isCertsVolumeMountNeeded() bool {
0000000000000000000000000000000000000000;;		// Always return true for now. We may add conditional logic here for images which do not require host mounting /etc/ssl
0000000000000000000000000000000000000000;;		// hyperkube for example already has valid ca-certificates installed
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// certsVolume exposes host SSL certificates to pod containers.
0000000000000000000000000000000000000000;;	func certsVolume(cfg *kubeadmapi.MasterConfiguration) v1.Volume {
0000000000000000000000000000000000000000;;		return v1.Volume{
0000000000000000000000000000000000000000;;			Name: "certs",
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				// TODO(phase1+) make path configurable
0000000000000000000000000000000000000000;;				HostPath: &v1.HostPathVolumeSource{Path: "/etc/ssl/certs"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func certsVolumeMount() v1.VolumeMount {
0000000000000000000000000000000000000000;;		return v1.VolumeMount{
0000000000000000000000000000000000000000;;			Name:      "certs",
0000000000000000000000000000000000000000;;			MountPath: "/etc/ssl/certs",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isPkiVolumeMountNeeded() bool {
0000000000000000000000000000000000000000;;		// On some systems were we host-mount /etc/ssl/certs, it is also required to mount /etc/pki. This is needed
0000000000000000000000000000000000000000;;		// due to symlinks pointing from files in /etc/ssl/certs into /etc/pki/
0000000000000000000000000000000000000000;;		if _, err := os.Stat("/etc/pki"); err == nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pkiVolume() v1.Volume {
0000000000000000000000000000000000000000;;		return v1.Volume{
0000000000000000000000000000000000000000;;			Name: "pki",
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				// TODO(phase1+) make path configurable
0000000000000000000000000000000000000000;;				HostPath: &v1.HostPathVolumeSource{Path: "/etc/pki"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pkiVolumeMount() v1.VolumeMount {
0000000000000000000000000000000000000000;;		return v1.VolumeMount{
0000000000000000000000000000000000000000;;			Name:      "pki",
0000000000000000000000000000000000000000;;			MountPath: "/etc/pki",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func k8sVolume() v1.Volume {
0000000000000000000000000000000000000000;;		return v1.Volume{
0000000000000000000000000000000000000000;;			Name: "k8s",
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				HostPath: &v1.HostPathVolumeSource{Path: kubeadmapi.GlobalEnvParams.KubernetesDir},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func k8sVolumeMount() v1.VolumeMount {
0000000000000000000000000000000000000000;;		return v1.VolumeMount{
0000000000000000000000000000000000000000;;			Name:      "k8s",
0000000000000000000000000000000000000000;;			MountPath: kubeadmapi.GlobalEnvParams.KubernetesDir,
0000000000000000000000000000000000000000;;			ReadOnly:  true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func componentResources(cpu string) v1.ResourceRequirements {
0000000000000000000000000000000000000000;;		return v1.ResourceRequirements{
0000000000000000000000000000000000000000;;			Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;				v1.ResourceName(v1.ResourceCPU): resource.MustParse(cpu),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func componentProbe(port int, path string, scheme v1.URIScheme) *v1.Probe {
0000000000000000000000000000000000000000;;		return &v1.Probe{
0000000000000000000000000000000000000000;;			Handler: v1.Handler{
0000000000000000000000000000000000000000;;				HTTPGet: &v1.HTTPGetAction{
0000000000000000000000000000000000000000;;					Host:   "127.0.0.1",
0000000000000000000000000000000000000000;;					Path:   path,
0000000000000000000000000000000000000000;;					Port:   intstr.FromInt(port),
0000000000000000000000000000000000000000;;					Scheme: scheme,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			InitialDelaySeconds: 15,
0000000000000000000000000000000000000000;;			TimeoutSeconds:      15,
0000000000000000000000000000000000000000;;			FailureThreshold:    8,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func componentPod(container v1.Container, volumes ...v1.Volume) v1.Pod {
0000000000000000000000000000000000000000;;		return v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        container.Name,
0000000000000000000000000000000000000000;;				Namespace:   "kube-system",
0000000000000000000000000000000000000000;;				Annotations: map[string]string{kubetypes.CriticalPodAnnotationKey: ""},
0000000000000000000000000000000000000000;;				Labels:      map[string]string{"component": container.Name, "tier": "control-plane"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers:  []v1.Container{container},
0000000000000000000000000000000000000000;;				HostNetwork: true,
0000000000000000000000000000000000000000;;				Volumes:     volumes,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getAPIServerCommand(cfg *kubeadmapi.MasterConfiguration, selfHosted bool, k8sVersion *version.Version) []string {
0000000000000000000000000000000000000000;;		defaultArguments := map[string]string{
0000000000000000000000000000000000000000;;			"insecure-port":                     "0",
0000000000000000000000000000000000000000;;			"admission-control":                 defaultv17AdmissionControl,
0000000000000000000000000000000000000000;;			"service-cluster-ip-range":          cfg.Networking.ServiceSubnet,
0000000000000000000000000000000000000000;;			"service-account-key-file":          filepath.Join(cfg.CertificatesDir, kubeadmconstants.ServiceAccountPublicKeyName),
0000000000000000000000000000000000000000;;			"client-ca-file":                    filepath.Join(cfg.CertificatesDir, kubeadmconstants.CACertName),
0000000000000000000000000000000000000000;;			"tls-cert-file":                     filepath.Join(cfg.CertificatesDir, kubeadmconstants.APIServerCertName),
0000000000000000000000000000000000000000;;			"tls-private-key-file":              filepath.Join(cfg.CertificatesDir, kubeadmconstants.APIServerKeyName),
0000000000000000000000000000000000000000;;			"kubelet-client-certificate":        filepath.Join(cfg.CertificatesDir, kubeadmconstants.APIServerKubeletClientCertName),
0000000000000000000000000000000000000000;;			"kubelet-client-key":                filepath.Join(cfg.CertificatesDir, kubeadmconstants.APIServerKubeletClientKeyName),
0000000000000000000000000000000000000000;;			"secure-port":                       fmt.Sprintf("%d", cfg.API.BindPort),
0000000000000000000000000000000000000000;;			"allow-privileged":                  "true",
0000000000000000000000000000000000000000;;			"experimental-bootstrap-token-auth": "true",
0000000000000000000000000000000000000000;;			"kubelet-preferred-address-types":   "InternalIP,ExternalIP,Hostname",
0000000000000000000000000000000000000000;;			// add options to configure the front proxy.  Without the generated client cert, this will never be useable
0000000000000000000000000000000000000000;;			// so add it unconditionally with recommended values
0000000000000000000000000000000000000000;;			"requestheader-username-headers":     "X-Remote-User",
0000000000000000000000000000000000000000;;			"requestheader-group-headers":        "X-Remote-Group",
0000000000000000000000000000000000000000;;			"requestheader-extra-headers-prefix": "X-Remote-Extra-",
0000000000000000000000000000000000000000;;			"requestheader-client-ca-file":       filepath.Join(cfg.CertificatesDir, kubeadmconstants.FrontProxyCACertName),
0000000000000000000000000000000000000000;;			"requestheader-allowed-names":        "front-proxy-client",
0000000000000000000000000000000000000000;;			"proxy-client-cert-file":             filepath.Join(cfg.CertificatesDir, kubeadmconstants.FrontProxyClientCertName),
0000000000000000000000000000000000000000;;			"proxy-client-key-file":              filepath.Join(cfg.CertificatesDir, kubeadmconstants.FrontProxyClientKeyName),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		command := []string{"kube-apiserver"}
0000000000000000000000000000000000000000;;		command = append(command, getExtraParameters(cfg.APIServerExtraArgs, defaultArguments)...)
0000000000000000000000000000000000000000;;		command = append(command, getAuthzParameters(cfg.AuthorizationModes)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if selfHosted {
0000000000000000000000000000000000000000;;			command = append(command, "--advertise-address=$(POD_IP)")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			command = append(command, fmt.Sprintf("--advertise-address=%s", cfg.API.AdvertiseAddress))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the user decided to use an external etcd cluster
0000000000000000000000000000000000000000;;		if len(cfg.Etcd.Endpoints) > 0 {
0000000000000000000000000000000000000000;;			command = append(command, fmt.Sprintf("--etcd-servers=%s", strings.Join(cfg.Etcd.Endpoints, ",")))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			command = append(command, "--etcd-servers=http://127.0.0.1:2379")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is etcd secured?
0000000000000000000000000000000000000000;;		if cfg.Etcd.CAFile != "" {
0000000000000000000000000000000000000000;;			command = append(command, fmt.Sprintf("--etcd-cafile=%s", cfg.Etcd.CAFile))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cfg.Etcd.CertFile != "" && cfg.Etcd.KeyFile != "" {
0000000000000000000000000000000000000000;;			etcdClientFileArg := fmt.Sprintf("--etcd-certfile=%s", cfg.Etcd.CertFile)
0000000000000000000000000000000000000000;;			etcdKeyFileArg := fmt.Sprintf("--etcd-keyfile=%s", cfg.Etcd.KeyFile)
0000000000000000000000000000000000000000;;			command = append(command, etcdClientFileArg, etcdKeyFileArg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cfg.CloudProvider != "" {
0000000000000000000000000000000000000000;;			command = append(command, "--cloud-provider="+cfg.CloudProvider)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Only append the --cloud-config option if there's a such file
0000000000000000000000000000000000000000;;			if _, err := os.Stat(DefaultCloudConfigPath); err == nil {
0000000000000000000000000000000000000000;;				command = append(command, "--cloud-config="+DefaultCloudConfigPath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return command
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getEtcdCommand(cfg *kubeadmapi.MasterConfiguration) []string {
0000000000000000000000000000000000000000;;		defaultArguments := map[string]string{
0000000000000000000000000000000000000000;;			"listen-client-urls":    "http://127.0.0.1:2379",
0000000000000000000000000000000000000000;;			"advertise-client-urls": "http://127.0.0.1:2379",
0000000000000000000000000000000000000000;;			"data-dir":              cfg.Etcd.DataDir,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		command := []string{"etcd"}
0000000000000000000000000000000000000000;;		command = append(command, getExtraParameters(cfg.Etcd.ExtraArgs, defaultArguments)...)
0000000000000000000000000000000000000000;;		return command
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getControllerManagerCommand(cfg *kubeadmapi.MasterConfiguration, selfHosted bool, k8sVersion *version.Version) []string {
0000000000000000000000000000000000000000;;		defaultArguments := map[string]string{
0000000000000000000000000000000000000000;;			"address":                          "127.0.0.1",
0000000000000000000000000000000000000000;;			"leader-elect":                     "true",
0000000000000000000000000000000000000000;;			"kubeconfig":                       filepath.Join(kubeadmapi.GlobalEnvParams.KubernetesDir, kubeadmconstants.ControllerManagerKubeConfigFileName),
0000000000000000000000000000000000000000;;			"root-ca-file":                     filepath.Join(cfg.CertificatesDir, kubeadmconstants.CACertName),
0000000000000000000000000000000000000000;;			"service-account-private-key-file": filepath.Join(cfg.CertificatesDir, kubeadmconstants.ServiceAccountPrivateKeyName),
0000000000000000000000000000000000000000;;			"cluster-signing-cert-file":        filepath.Join(cfg.CertificatesDir, kubeadmconstants.CACertName),
0000000000000000000000000000000000000000;;			"cluster-signing-key-file":         filepath.Join(cfg.CertificatesDir, kubeadmconstants.CAKeyName),
0000000000000000000000000000000000000000;;			"use-service-account-credentials":  "true",
0000000000000000000000000000000000000000;;			"controllers":                      "*,bootstrapsigner,tokencleaner",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		command := []string{"kube-controller-manager"}
0000000000000000000000000000000000000000;;		command = append(command, getExtraParameters(cfg.ControllerManagerExtraArgs, defaultArguments)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cfg.CloudProvider != "" {
0000000000000000000000000000000000000000;;			command = append(command, "--cloud-provider="+cfg.CloudProvider)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Only append the --cloud-config option if there's a such file
0000000000000000000000000000000000000000;;			if _, err := os.Stat(DefaultCloudConfigPath); err == nil {
0000000000000000000000000000000000000000;;				command = append(command, "--cloud-config="+DefaultCloudConfigPath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Let the controller-manager allocate Node CIDRs for the Pod network.
0000000000000000000000000000000000000000;;		// Each node will get a subspace of the address CIDR provided with --pod-network-cidr.
0000000000000000000000000000000000000000;;		if cfg.Networking.PodSubnet != "" {
0000000000000000000000000000000000000000;;			command = append(command, "--allocate-node-cidrs=true", "--cluster-cidr="+cfg.Networking.PodSubnet)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return command
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSchedulerCommand(cfg *kubeadmapi.MasterConfiguration, selfHosted bool) []string {
0000000000000000000000000000000000000000;;		defaultArguments := map[string]string{
0000000000000000000000000000000000000000;;			"address":      "127.0.0.1",
0000000000000000000000000000000000000000;;			"leader-elect": "true",
0000000000000000000000000000000000000000;;			"kubeconfig":   filepath.Join(kubeadmapi.GlobalEnvParams.KubernetesDir, kubeadmconstants.SchedulerKubeConfigFileName),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		command := []string{"kube-scheduler"}
0000000000000000000000000000000000000000;;		command = append(command, getExtraParameters(cfg.SchedulerExtraArgs, defaultArguments)...)
0000000000000000000000000000000000000000;;		return command
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getProxyEnvVars() []v1.EnvVar {
0000000000000000000000000000000000000000;;		envs := []v1.EnvVar{}
0000000000000000000000000000000000000000;;		for _, env := range os.Environ() {
0000000000000000000000000000000000000000;;			pos := strings.Index(env, "=")
0000000000000000000000000000000000000000;;			if pos == -1 {
0000000000000000000000000000000000000000;;				// malformed environment variable, skip it.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			name := env[:pos]
0000000000000000000000000000000000000000;;			value := env[pos+1:]
0000000000000000000000000000000000000000;;			if strings.HasSuffix(strings.ToLower(name), "_proxy") && value != "" {
0000000000000000000000000000000000000000;;				envVar := v1.EnvVar{Name: name, Value: value}
0000000000000000000000000000000000000000;;				envs = append(envs, envVar)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return envs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getAuthzParameters gets the authorization-related parameters to the api server
0000000000000000000000000000000000000000;;	// At this point, we can assume the list of authorization modes is valid (due to that it has been validated in the API machinery code already)
0000000000000000000000000000000000000000;;	// If the list is empty; it's defaulted (mostly for unit testing)
0000000000000000000000000000000000000000;;	func getAuthzParameters(modes []string) []string {
0000000000000000000000000000000000000000;;		command := []string{}
0000000000000000000000000000000000000000;;		strset := sets.NewString(modes...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(modes) == 0 {
0000000000000000000000000000000000000000;;			return []string{fmt.Sprintf("--authorization-mode=%s", kubeadmapiext.DefaultAuthorizationModes)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if strset.Has(authzmodes.ModeABAC) {
0000000000000000000000000000000000000000;;			command = append(command, "--authorization-policy-file="+kubeadmconstants.AuthorizationPolicyPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strset.Has(authzmodes.ModeWebhook) {
0000000000000000000000000000000000000000;;			command = append(command, "--authorization-webhook-config-file="+kubeadmconstants.AuthorizationWebhookConfigPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		command = append(command, "--authorization-mode="+strings.Join(modes, ","))
0000000000000000000000000000000000000000;;		return command
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getExtraParameters(overrides map[string]string, defaults map[string]string) []string {
0000000000000000000000000000000000000000;;		var command []string
0000000000000000000000000000000000000000;;		for k, v := range overrides {
0000000000000000000000000000000000000000;;			if len(v) > 0 {
0000000000000000000000000000000000000000;;				command = append(command, fmt.Sprintf("--%s=%s", k, v))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range defaults {
0000000000000000000000000000000000000000;;			if _, overrideExists := overrides[k]; !overrideExists {
0000000000000000000000000000000000000000;;				command = append(command, fmt.Sprintf("--%s=%s", k, v))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return command
0000000000000000000000000000000000000000;;	}
