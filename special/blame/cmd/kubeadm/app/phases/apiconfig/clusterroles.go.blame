0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
da22bd0d1e5bd7f02d51558896a42bc9a30591e7;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package apiconfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		rbac "k8s.io/api/rbac/v1beta1"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		clientset "k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		kubeadmconstants "k8s.io/kubernetes/cmd/kubeadm/app/constants"
0000000000000000000000000000000000000000;;		rbachelper "k8s.io/kubernetes/pkg/apis/rbac/v1beta1"
0000000000000000000000000000000000000000;;		bootstrapapi "k8s.io/kubernetes/pkg/bootstrap/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/version"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// KubeProxyClusterRoleName sets the name for the kube-proxy ClusterRole
0000000000000000000000000000000000000000;;		KubeProxyClusterRoleName = "system:node-proxier"
0000000000000000000000000000000000000000;;		// NodeBootstrapperClusterRoleName sets the name for the TLS Node Bootstrapper ClusterRole
0000000000000000000000000000000000000000;;		NodeBootstrapperClusterRoleName = "system:node-bootstrapper"
0000000000000000000000000000000000000000;;		// BootstrapSignerClusterRoleName sets the name for the ClusterRole that allows access to ConfigMaps in the kube-public ns
0000000000000000000000000000000000000000;;		BootstrapSignerClusterRoleName = "system:bootstrap-signer-clusterinfo"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clusterRoleKind          = "ClusterRole"
0000000000000000000000000000000000000000;;		roleKind                 = "Role"
0000000000000000000000000000000000000000;;		serviceAccountKind       = "ServiceAccount"
0000000000000000000000000000000000000000;;		rbacAPIGroup             = "rbac.authorization.k8s.io"
0000000000000000000000000000000000000000;;		anonymousUser            = "system:anonymous"
0000000000000000000000000000000000000000;;		nodeAutoApproveBootstrap = "kubeadm:node-autoapprove-bootstrap"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Are there any unit tests that could be made for this file other than duplicating all values and logic in a separate file?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateServiceAccounts creates the necessary serviceaccounts that kubeadm uses/might use, if they don't already exist.
0000000000000000000000000000000000000000;;	func CreateServiceAccounts(clientset clientset.Interface) error {
0000000000000000000000000000000000000000;;		serviceAccounts := []v1.ServiceAccount{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      kubeadmconstants.KubeDNSServiceAccountName,
0000000000000000000000000000000000000000;;					Namespace: metav1.NamespaceSystem,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      kubeadmconstants.KubeProxyServiceAccountName,
0000000000000000000000000000000000000000;;					Namespace: metav1.NamespaceSystem,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, sa := range serviceAccounts {
0000000000000000000000000000000000000000;;			if _, err := clientset.CoreV1().ServiceAccounts(metav1.NamespaceSystem).Create(&sa); err != nil {
0000000000000000000000000000000000000000;;				if !apierrors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateRBACRules creates the essential RBAC rules for a minimally set-up cluster
0000000000000000000000000000000000000000;;	func CreateRBACRules(clientset *clientset.Clientset, k8sVersion *version.Version) error {
0000000000000000000000000000000000000000;;		if err := createRoles(clientset); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := createRoleBindings(clientset); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := createClusterRoles(clientset); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := createClusterRoleBindings(clientset); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := deletePermissiveNodesBindingWhenUsingNodeAuthorization(clientset, k8sVersion); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to remove the permissive 'system:nodes' Group Subject in the 'system:node' ClusterRoleBinding: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Println("[apiconfig] Created RBAC rules")
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createRoles(clientset *clientset.Clientset) error {
0000000000000000000000000000000000000000;;		roles := []rbac.Role{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      BootstrapSignerClusterRoleName,
0000000000000000000000000000000000000000;;					Namespace: metav1.NamespacePublic,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;					rbachelper.NewRule("get").Groups("").Resources("configmaps").Names("cluster-info").RuleOrDie(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, role := range roles {
0000000000000000000000000000000000000000;;			if _, err := clientset.RbacV1beta1().Roles(role.ObjectMeta.Namespace).Create(&role); err != nil {
0000000000000000000000000000000000000000;;				if !apierrors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;					return fmt.Errorf("unable to create RBAC role: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if _, err := clientset.RbacV1beta1().Roles(role.ObjectMeta.Namespace).Update(&role); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("unable to update RBAC role: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createRoleBindings(clientset *clientset.Clientset) error {
0000000000000000000000000000000000000000;;		roleBindings := []rbac.RoleBinding{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      "kubeadm:bootstrap-signer-clusterinfo",
0000000000000000000000000000000000000000;;					Namespace: metav1.NamespacePublic,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RoleRef: rbac.RoleRef{
0000000000000000000000000000000000000000;;					APIGroup: rbacAPIGroup,
0000000000000000000000000000000000000000;;					Kind:     roleKind,
0000000000000000000000000000000000000000;;					Name:     BootstrapSignerClusterRoleName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Subjects: []rbac.Subject{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Kind: "User",
0000000000000000000000000000000000000000;;						Name: anonymousUser,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, roleBinding := range roleBindings {
0000000000000000000000000000000000000000;;			if _, err := clientset.RbacV1beta1().RoleBindings(roleBinding.ObjectMeta.Namespace).Create(&roleBinding); err != nil {
0000000000000000000000000000000000000000;;				if !apierrors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;					return fmt.Errorf("unable to create RBAC rolebinding: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if _, err := clientset.RbacV1beta1().RoleBindings(roleBinding.ObjectMeta.Namespace).Update(&roleBinding); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("unable to update RBAC rolebinding: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createClusterRoles(clientset *clientset.Clientset) error {
0000000000000000000000000000000000000000;;		clusterRoles := []rbac.ClusterRole{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: nodeAutoApproveBootstrap,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;					rbachelper.NewRule("create").Groups("certificates.k8s.io").Resources("certificatesigningrequests/nodeclient").RuleOrDie(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, roleBinding := range clusterRoles {
0000000000000000000000000000000000000000;;			if _, err := clientset.RbacV1beta1().ClusterRoles().Create(&roleBinding); err != nil {
0000000000000000000000000000000000000000;;				if !apierrors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;					return fmt.Errorf("unable to create RBAC clusterrole: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if _, err := clientset.RbacV1beta1().ClusterRoles().Update(&roleBinding); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("unable to update RBAC clusterrole: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createClusterRoleBindings(clientset *clientset.Clientset) error {
0000000000000000000000000000000000000000;;		clusterRoleBindings := []rbac.ClusterRoleBinding{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "kubeadm:kubelet-bootstrap",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RoleRef: rbac.RoleRef{
0000000000000000000000000000000000000000;;					APIGroup: rbacAPIGroup,
0000000000000000000000000000000000000000;;					Kind:     clusterRoleKind,
0000000000000000000000000000000000000000;;					Name:     NodeBootstrapperClusterRoleName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Subjects: []rbac.Subject{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Kind: "Group",
0000000000000000000000000000000000000000;;						Name: bootstrapapi.BootstrapGroup,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: nodeAutoApproveBootstrap,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RoleRef: rbac.RoleRef{
0000000000000000000000000000000000000000;;					APIGroup: rbacAPIGroup,
0000000000000000000000000000000000000000;;					Kind:     clusterRoleKind,
0000000000000000000000000000000000000000;;					Name:     nodeAutoApproveBootstrap,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Subjects: []rbac.Subject{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Kind: "Group",
0000000000000000000000000000000000000000;;						Name: bootstrapapi.BootstrapGroup,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "kubeadm:node-proxier",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RoleRef: rbac.RoleRef{
0000000000000000000000000000000000000000;;					APIGroup: rbacAPIGroup,
0000000000000000000000000000000000000000;;					Kind:     clusterRoleKind,
0000000000000000000000000000000000000000;;					Name:     KubeProxyClusterRoleName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Subjects: []rbac.Subject{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Kind:      serviceAccountKind,
0000000000000000000000000000000000000000;;						Name:      kubeadmconstants.KubeProxyServiceAccountName,
0000000000000000000000000000000000000000;;						Namespace: metav1.NamespaceSystem,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, clusterRoleBinding := range clusterRoleBindings {
0000000000000000000000000000000000000000;;			if _, err := clientset.RbacV1beta1().ClusterRoleBindings().Create(&clusterRoleBinding); err != nil {
0000000000000000000000000000000000000000;;				if !apierrors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;					return fmt.Errorf("unable to create RBAC clusterrolebinding: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if _, err := clientset.RbacV1beta1().ClusterRoleBindings().Update(&clusterRoleBinding); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("unable to update RBAC clusterrolebinding: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deletePermissiveNodesBindingWhenUsingNodeAuthorization(clientset *clientset.Clientset, k8sVersion *version.Version) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodesRoleBinding, err := clientset.RbacV1beta1().ClusterRoleBindings().Get(kubeadmconstants.NodesClusterRoleBinding, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				// Nothing to do; the RoleBinding doesn't exist
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newSubjects := []rbac.Subject{}
0000000000000000000000000000000000000000;;		for _, subject := range nodesRoleBinding.Subjects {
0000000000000000000000000000000000000000;;			// Skip the subject that binds to the system:nodes group
0000000000000000000000000000000000000000;;			if subject.Name == kubeadmconstants.NodesGroup && subject.Kind == "Group" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newSubjects = append(newSubjects, subject)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodesRoleBinding.Subjects = newSubjects
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := clientset.RbacV1beta1().ClusterRoleBindings().Update(nodesRoleBinding); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
