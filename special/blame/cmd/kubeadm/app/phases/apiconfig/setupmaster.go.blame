0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
00544280d4d2c5b47448154766c2b1039e5563da;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package apiconfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrs "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		clientset "k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		kubeadmconstants "k8s.io/kubernetes/cmd/kubeadm/app/constants"
0000000000000000000000000000000000000000;;		kubeletapis "k8s.io/kubernetes/pkg/kubelet/apis"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const apiCallRetryInterval = 500 * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Can we think of any unit tests here? Or should this code just be covered through integration/e2e tests?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func attemptToUpdateMasterRoleLabelsAndTaints(client *clientset.Clientset, nodeName string) error {
0000000000000000000000000000000000000000;;		var n *v1.Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for current node registration
0000000000000000000000000000000000000000;;		wait.PollInfinite(kubeadmconstants.APICallRetryInterval, func() (bool, error) {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if n, err = client.Nodes().Get(nodeName, metav1.GetOptions{}); err != nil {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// The node may appear to have no labels at first,
0000000000000000000000000000000000000000;;			// so we wait for it to get hostname label.
0000000000000000000000000000000000000000;;			_, found := n.ObjectMeta.Labels[kubeletapis.LabelHostname]
0000000000000000000000000000000000000000;;			return found, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oldData, err := json.Marshal(n)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The master node is tainted and labelled accordingly
0000000000000000000000000000000000000000;;		n.ObjectMeta.Labels[kubeadmconstants.LabelNodeRoleMaster] = ""
0000000000000000000000000000000000000000;;		addTaintIfNotExists(n, v1.Taint{Key: kubeadmconstants.LabelNodeRoleMaster, Value: "", Effect: "NoSchedule"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newData, err := json.Marshal(n)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patchBytes, err := strategicpatch.CreateTwoWayMergePatch(oldData, newData, v1.Node{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := client.Nodes().Patch(n.Name, types.StrategicMergePatchType, patchBytes); err != nil {
0000000000000000000000000000000000000000;;			if apierrs.IsConflict(err) {
0000000000000000000000000000000000000000;;				fmt.Println("[apiclient] Temporarily unable to update master node metadata due to conflict (will retry)")
0000000000000000000000000000000000000000;;				time.Sleep(apiCallRetryInterval)
0000000000000000000000000000000000000000;;				attemptToUpdateMasterRoleLabelsAndTaints(client, nodeName)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addTaintIfNotExists(n *v1.Node, t v1.Taint) {
0000000000000000000000000000000000000000;;		for _, taint := range n.Spec.Taints {
0000000000000000000000000000000000000000;;			if taint == t {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n.Spec.Taints = append(n.Spec.Taints, t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateMasterRoleLabelsAndTaints taints the master and sets the master label
0000000000000000000000000000000000000000;;	func UpdateMasterRoleLabelsAndTaints(client *clientset.Clientset, nodeName string) error {
0000000000000000000000000000000000000000;;		// TODO: Use iterate instead of recursion
0000000000000000000000000000000000000000;;		err := attemptToUpdateMasterRoleLabelsAndTaints(client, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to update master node - [%v]", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
