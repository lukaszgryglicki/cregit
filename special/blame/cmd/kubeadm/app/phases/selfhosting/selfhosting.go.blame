0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
bf686dc8b1b1ee0c13afcf5468e32cd7184d8e2c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package selfhosting
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		kuberuntime "k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		clientset "k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		kubeadmapi "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm"
0000000000000000000000000000000000000000;;		kubeadmconstants "k8s.io/kubernetes/cmd/kubeadm/app/constants"
0000000000000000000000000000000000000000;;		kubeadmutil "k8s.io/kubernetes/cmd/kubeadm/app/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		kubeAPIServer         = "kube-apiserver"
0000000000000000000000000000000000000000;;		kubeControllerManager = "kube-controller-manager"
0000000000000000000000000000000000000000;;		kubeScheduler         = "kube-scheduler"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selfHostingPrefix = "self-hosted-"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateSelfHostedControlPlane is responsible for turning a Static Pod-hosted control plane to a self-hosted one
0000000000000000000000000000000000000000;;	// It achieves that task this way:
0000000000000000000000000000000000000000;;	// 1. Load the Static Pod specification from disk (from /etc/kubernetes/manifests)
0000000000000000000000000000000000000000;;	// 2. Extract the PodSpec from that Static Pod specification
0000000000000000000000000000000000000000;;	// 3. Mutate the PodSpec to be compatible with self-hosting (add the right labels, taints, etc. so it can schedule correctly)
0000000000000000000000000000000000000000;;	// 4. Build a new DaemonSet object for the self-hosted component in question. Use the above mentioned PodSpec
0000000000000000000000000000000000000000;;	// 5. Create the DaemonSet resource. Wait until the Pods are running.
0000000000000000000000000000000000000000;;	// 6. Remove the Static Pod manifest file. The kubelet will stop the original Static Pod-hosted component that was running.
0000000000000000000000000000000000000000;;	// 7. The self-hosted containers should now step up and take over.
0000000000000000000000000000000000000000;;	// 8. In order to avoid race conditions, we're still making sure the API /healthz endpoint is healthy
0000000000000000000000000000000000000000;;	// 9. Do that for the kube-apiserver, kube-controller-manager and kube-scheduler in a loop
0000000000000000000000000000000000000000;;	func CreateSelfHostedControlPlane(cfg *kubeadmapi.MasterConfiguration, client *clientset.Clientset) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := createTLSSecrets(cfg, client); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := createOpaqueSecrets(cfg, client); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The sequence here isn't set in stone, but seems to work well to start with the API server
0000000000000000000000000000000000000000;;		components := []string{kubeAPIServer, kubeControllerManager, kubeScheduler}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, componentName := range components {
0000000000000000000000000000000000000000;;			start := time.Now()
0000000000000000000000000000000000000000;;			manifestPath := buildStaticManifestFilepath(componentName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Load the Static Pod file in order to be able to create a self-hosted variant of that file
0000000000000000000000000000000000000000;;			podSpec, err := loadPodSpecFromFile(manifestPath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Build a DaemonSet object from the loaded PodSpec
0000000000000000000000000000000000000000;;			ds := buildDaemonSet(cfg, componentName, podSpec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create the DaemonSet in the API Server
0000000000000000000000000000000000000000;;			if _, err := client.ExtensionsV1beta1().DaemonSets(metav1.NamespaceSystem).Create(ds); err != nil {
0000000000000000000000000000000000000000;;				if !apierrors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;					return fmt.Errorf("failed to create self-hosted %q daemonset [%v]", componentName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if _, err := client.ExtensionsV1beta1().DaemonSets(metav1.NamespaceSystem).Update(ds); err != nil {
0000000000000000000000000000000000000000;;					// TODO: We should retry on 409 responses
0000000000000000000000000000000000000000;;					return fmt.Errorf("failed to update self-hosted %q daemonset [%v]", componentName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Wait for the self-hosted component to come up
0000000000000000000000000000000000000000;;			kubeadmutil.WaitForPodsWithLabel(client, buildSelfHostedWorkloadLabelQuery(componentName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Remove the old Static Pod manifest
0000000000000000000000000000000000000000;;			if err := os.RemoveAll(manifestPath); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to delete static pod manifest for %s [%v]", componentName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Make sure the API is responsive at /healthz
0000000000000000000000000000000000000000;;			kubeadmutil.WaitForAPI(client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fmt.Printf("[self-hosted] self-hosted %s ready after %f seconds\n", componentName, time.Since(start).Seconds())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildDaemonSet is responsible for mutating the PodSpec and return a DaemonSet which is suitable for the self-hosting purporse
0000000000000000000000000000000000000000;;	func buildDaemonSet(cfg *kubeadmapi.MasterConfiguration, name string, podSpec *v1.PodSpec) *extensions.DaemonSet {
0000000000000000000000000000000000000000;;		// Mutate the PodSpec so it's suitable for self-hosting
0000000000000000000000000000000000000000;;		mutatePodSpec(cfg, name, podSpec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return a DaemonSet based on that Spec
0000000000000000000000000000000000000000;;		return &extensions.DaemonSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      addSelfHostedPrefix(name),
0000000000000000000000000000000000000000;;				Namespace: metav1.NamespaceSystem,
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"k8s-app": addSelfHostedPrefix(name),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.DaemonSetSpec{
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"k8s-app": addSelfHostedPrefix(name),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: *podSpec,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// loadPodSpecFromFile reads and decodes a file containing a specification of a Pod
0000000000000000000000000000000000000000;;	// TODO: Consider using "k8s.io/kubernetes/pkg/volume/util".LoadPodFromFile(filename string) in the future instead.
0000000000000000000000000000000000000000;;	func loadPodSpecFromFile(manifestPath string) (*v1.PodSpec, error) {
0000000000000000000000000000000000000000;;		podBytes, err := ioutil.ReadFile(manifestPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		staticPod := &v1.Pod{}
0000000000000000000000000000000000000000;;		if err := kuberuntime.DecodeInto(api.Codecs.UniversalDecoder(), podBytes, staticPod); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to decode static pod %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &staticPod.Spec, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildStaticManifestFilepath returns the location on the disk where the Static Pod should be present
0000000000000000000000000000000000000000;;	func buildStaticManifestFilepath(componentName string) string {
0000000000000000000000000000000000000000;;		return filepath.Join(kubeadmconstants.KubernetesDir, kubeadmconstants.ManifestsSubDirName, componentName+".yaml")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildSelfHostedWorkloadLabelQuery creates the right query for matching a self-hosted Pod
0000000000000000000000000000000000000000;;	func buildSelfHostedWorkloadLabelQuery(componentName string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("k8s-app=%s", addSelfHostedPrefix(componentName))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addSelfHostedPrefix adds the self-hosted- prefix to the component name
0000000000000000000000000000000000000000;;	func addSelfHostedPrefix(componentName string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s%s", selfHostingPrefix, componentName)
0000000000000000000000000000000000000000;;	}
