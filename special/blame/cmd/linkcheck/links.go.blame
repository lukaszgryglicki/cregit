0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
6cb1ff0a74a5fd79f82010c15031faabc5a26e95;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This tool extracts the links from types.go and .md files, visits the link and
0000000000000000000000000000000000000000;;	// checks the status code of the response.
0000000000000000000000000000000000000000;;	// Usage:
0000000000000000000000000000000000000000;;	// $ linkcheck --root-dir=${ROOT}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/mvdan/xurls"
0000000000000000000000000000000000000000;;		flag "github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		rootDir    = flag.String("root-dir", "", "Root directory containing documents to be processed.")
0000000000000000000000000000000000000000;;		fileSuffix = flag.StringSlice("file-suffix", []string{"types.go", ".md"}, "suffix of files to be checked")
0000000000000000000000000000000000000000;;		// URLs matching the patterns in the regWhiteList won't be checked. Patterns
0000000000000000000000000000000000000000;;		// of dummy URLs should be added to the list to avoid false alerts. Also,
0000000000000000000000000000000000000000;;		// patterns of URLs that we don't care about can be added here to improve
0000000000000000000000000000000000000000;;		// efficiency.
0000000000000000000000000000000000000000;;		regWhiteList = []*regexp.Regexp{
0000000000000000000000000000000000000000;;			regexp.MustCompile(`https://kubernetes-site\.appspot\.com`),
0000000000000000000000000000000000000000;;			// skip url that doesn't start with an English alphabet, e.g., URLs with IP addresses.
0000000000000000000000000000000000000000;;			regexp.MustCompile(`https?://[^A-Za-z].*`),
0000000000000000000000000000000000000000;;			regexp.MustCompile(`https?://localhost.*`),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// URLs listed in the fullURLWhiteList won't be checked. This separated from
0000000000000000000000000000000000000000;;		// the RegWhiteList to improve efficiency. This list includes dummy URLs that
0000000000000000000000000000000000000000;;		// are hard to be generalized by a regex, and URLs that will cause false alerts.
0000000000000000000000000000000000000000;;		fullURLWhiteList = map[string]struct{}{
0000000000000000000000000000000000000000;;			"http://github.com/some/repo.git": {},
0000000000000000000000000000000000000000;;			// This URL returns 404 when visited by this tool, but it works fine if visited by a browser.
0000000000000000000000000000000000000000;;			"http://stackoverflow.com/questions/ask?tags=kubernetes":                                            {},
0000000000000000000000000000000000000000;;			"https://github.com/$YOUR_GITHUB_USERNAME/kubernetes.git":                                           {},
0000000000000000000000000000000000000000;;			"https://github.com/$YOUR_GITHUB_USERNAME/kubernetes":                                               {},
0000000000000000000000000000000000000000;;			"http://storage.googleapis.com/kubernetes-release/release/v${K8S_VERSION}/bin/darwin/amd64/kubectl": {},
0000000000000000000000000000000000000000;;			// It seems this server expects certain User-Agent value, it works fine with Chrome, but returns 404 if we issue a plain cURL to it.
0000000000000000000000000000000000000000;;			"http://supervisord.org/":         {},
0000000000000000000000000000000000000000;;			"http://kubernetes.io/vX.Y/docs":  {},
0000000000000000000000000000000000000000;;			"http://kubernetes.io/vX.Y/docs/": {},
0000000000000000000000000000000000000000;;			"http://kubernetes.io/vX.Y/":      {},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		visitedURLs    = map[string]struct{}{}
0000000000000000000000000000000000000000;;		htmlpreviewReg = regexp.MustCompile(`https://htmlpreview\.github\.io/\?`)
0000000000000000000000000000000000000000;;		httpOrhttpsReg = regexp.MustCompile(`https?.*`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newWalkFunc(invalidLink *bool, client *http.Client) filepath.WalkFunc {
0000000000000000000000000000000000000000;;		return func(filePath string, info os.FileInfo, err error) error {
0000000000000000000000000000000000000000;;			hasSuffix := false
0000000000000000000000000000000000000000;;			for _, suffix := range *fileSuffix {
0000000000000000000000000000000000000000;;				hasSuffix = hasSuffix || strings.HasSuffix(info.Name(), suffix)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !hasSuffix {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fileBytes, err := ioutil.ReadFile(filePath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			foundInvalid := false
0000000000000000000000000000000000000000;;			allURLs := xurls.Strict.FindAll(fileBytes, -1)
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stdout, "\nChecking file %s\n", filePath)
0000000000000000000000000000000000000000;;		URL:
0000000000000000000000000000000000000000;;			for _, URL := range allURLs {
0000000000000000000000000000000000000000;;				// Don't check non http/https URL
0000000000000000000000000000000000000000;;				if !httpOrhttpsReg.Match(URL) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, whiteURL := range regWhiteList {
0000000000000000000000000000000000000000;;					if whiteURL.Match(URL) {
0000000000000000000000000000000000000000;;						continue URL
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, found := fullURLWhiteList[string(URL)]; found {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// remove the htmlpreview Prefix
0000000000000000000000000000000000000000;;				processedURL := htmlpreviewReg.ReplaceAll(URL, []byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// check if we have visited the URL.
0000000000000000000000000000000000000000;;				if _, found := visitedURLs[string(processedURL)]; found {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				visitedURLs[string(processedURL)] = struct{}{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				retry := 0
0000000000000000000000000000000000000000;;				const maxRetry int = 3
0000000000000000000000000000000000000000;;				backoff := 100
0000000000000000000000000000000000000000;;				for retry < maxRetry {
0000000000000000000000000000000000000000;;					fmt.Fprintf(os.Stdout, "Visiting %s\n", string(processedURL))
0000000000000000000000000000000000000000;;					// Use verb HEAD to increase efficiency. However, some servers
0000000000000000000000000000000000000000;;					// do not handle HEAD well, so we need to try a GET to avoid
0000000000000000000000000000000000000000;;					// false alert.
0000000000000000000000000000000000000000;;					resp, err := client.Head(string(processedURL))
0000000000000000000000000000000000000000;;					// URLs with mock host or mock port will cause error. If we report
0000000000000000000000000000000000000000;;					// the error here, people need to add the mock URL to the white
0000000000000000000000000000000000000000;;					// list every time they add a mock URL, which will be a maintenance
0000000000000000000000000000000000000000;;					// nightmare. Hence, we decide to only report 404 to catch the
0000000000000000000000000000000000000000;;					// cases where host and port are legit, but path is not, which
0000000000000000000000000000000000000000;;					// is the most common mistake in our docs.
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if resp.StatusCode == http.StatusTooManyRequests {
0000000000000000000000000000000000000000;;						retryAfter := resp.Header.Get("Retry-After")
0000000000000000000000000000000000000000;;						if seconds, err := strconv.Atoi(retryAfter); err != nil {
0000000000000000000000000000000000000000;;							backoff = seconds + 10
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						fmt.Fprintf(os.Stderr, "Got %d visiting %s, retry after %d seconds.\n", resp.StatusCode, string(URL), backoff)
0000000000000000000000000000000000000000;;						time.Sleep(time.Duration(backoff) * time.Second)
0000000000000000000000000000000000000000;;						backoff *= 2
0000000000000000000000000000000000000000;;						retry++
0000000000000000000000000000000000000000;;					} else if resp.StatusCode == http.StatusNotFound {
0000000000000000000000000000000000000000;;						// We only check for 404 error for now. 401, 403 errors are hard to handle.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// We need to try a GET to avoid false alert.
0000000000000000000000000000000000000000;;						resp, err = client.Get(string(processedURL))
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if resp.StatusCode != http.StatusNotFound {
0000000000000000000000000000000000000000;;							continue URL
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						foundInvalid = true
0000000000000000000000000000000000000000;;						fmt.Fprintf(os.Stderr, "Failed: in file %s, Got %d visiting %s\n", filePath, resp.StatusCode, string(URL))
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if retry == maxRetry {
0000000000000000000000000000000000000000;;					foundInvalid = true
0000000000000000000000000000000000000000;;					fmt.Fprintf(os.Stderr, "Failed: in file %s, still got 429 visiting %s after %d retries\n", filePath, string(URL), maxRetry)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if foundInvalid {
0000000000000000000000000000000000000000;;				*invalidLink = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if *rootDir == "" {
0000000000000000000000000000000000000000;;			flag.Usage()
0000000000000000000000000000000000000000;;			os.Exit(2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client := http.Client{
0000000000000000000000000000000000000000;;			Timeout: time.Duration(5 * time.Second),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		invalidLink := false
0000000000000000000000000000000000000000;;		if err := filepath.Walk(*rootDir, newWalkFunc(&invalidLink, &client)); err != nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "Fail: %v.\n", err)
0000000000000000000000000000000000000000;;			os.Exit(2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if invalidLink {
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
