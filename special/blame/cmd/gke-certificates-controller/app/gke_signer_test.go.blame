0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
fb3b9e794a18c5cc51d95a9b3c0628ba86d23ed3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package app
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"text/template"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certificates "k8s.io/api/certificates/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const kubeConfigTmpl = `
0000000000000000000000000000000000000000;;	clusters:
0000000000000000000000000000000000000000;;	- cluster:
0000000000000000000000000000000000000000;;	    server: {{ .Server }}
0000000000000000000000000000000000000000;;	    name: testcluster
0000000000000000000000000000000000000000;;	users:
0000000000000000000000000000000000000000;;	- user:
0000000000000000000000000000000000000000;;	    username: admin
0000000000000000000000000000000000000000;;	    password: mypass
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGKESigner(t *testing.T) {
0000000000000000000000000000000000000000;;		goodResponse := &certificates.CertificateSigningRequest{
0000000000000000000000000000000000000000;;			Status: certificates.CertificateSigningRequestStatus{
0000000000000000000000000000000000000000;;				Certificate: []byte("fake certificate"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		invalidResponse := "{ \"status\": \"Not a properly formatted CSR response\" }"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			mockResponse interface{}
0000000000000000000000000000000000000000;;			expected     []byte
0000000000000000000000000000000000000000;;			failCalls    int
0000000000000000000000000000000000000000;;			wantErr      bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				mockResponse: goodResponse,
0000000000000000000000000000000000000000;;				expected:     goodResponse.Status.Certificate,
0000000000000000000000000000000000000000;;				wantErr:      false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				mockResponse: goodResponse,
0000000000000000000000000000000000000000;;				expected:     goodResponse.Status.Certificate,
0000000000000000000000000000000000000000;;				failCalls:    3,
0000000000000000000000000000000000000000;;				wantErr:      false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				mockResponse: goodResponse,
0000000000000000000000000000000000000000;;				failCalls:    20,
0000000000000000000000000000000000000000;;				wantErr:      true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				mockResponse: invalidResponse,
0000000000000000000000000000000000000000;;				wantErr:      true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, c := range cases {
0000000000000000000000000000000000000000;;			server, err := newTestServer(c.mockResponse, c.failCalls)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("error creating test server")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			kubeConfig, err := ioutil.TempFile("", "kubeconfig")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("error creating kubeconfig tempfile: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tmpl, err := template.New("kubeconfig").Parse(kubeConfigTmpl)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("error creating kubeconfig template: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			data := struct{ Server string }{server.httpserver.URL}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := tmpl.Execute(kubeConfig, data); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("error executing kubeconfig template: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := kubeConfig.Close(); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("error closing kubeconfig template: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			signer, err := NewGKESigner(kubeConfig.Name(), time.Duration(500)*time.Millisecond, record.NewFakeRecorder(10), nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("error creating GKESigner: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cert, err := signer.sign(&certificates.CertificateSigningRequest{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if c.wantErr {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("wanted error during GKE.Sign() call, got not none")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("error while signing: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !bytes.Equal(cert.Status.Certificate, c.expected) {
0000000000000000000000000000000000000000;;					t.Errorf("response certificate didn't match expected %v: %v", c.expected, cert)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testServer struct {
0000000000000000000000000000000000000000;;		httpserver *httptest.Server
0000000000000000000000000000000000000000;;		failCalls  int
0000000000000000000000000000000000000000;;		response   interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestServer(response interface{}, failCalls int) (*testServer, error) {
0000000000000000000000000000000000000000;;		server := &testServer{
0000000000000000000000000000000000000000;;			response:  response,
0000000000000000000000000000000000000000;;			failCalls: failCalls,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server.httpserver = httptest.NewServer(server)
0000000000000000000000000000000000000000;;		return server, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *testServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		if s.failCalls > 0 {
0000000000000000000000000000000000000000;;			http.Error(w, "Service unavailable", 500)
0000000000000000000000000000000000000000;;			s.failCalls--
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;			json.NewEncoder(w).Encode(s.response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
