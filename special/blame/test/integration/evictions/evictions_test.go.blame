0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
8fc3f033d6dd3aee99412821da2a57b18464bc76;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package evictions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/api/policy/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/disruption"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		numOfEvictions = 10
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestConcurrentEvictionRequests is to make sure pod disruption budgets (PDB) controller is able to
0000000000000000000000000000000000000000;;	// handle concurrent eviction requests. Original issue:#37605
0000000000000000000000000000000000000000;;	func TestConcurrentEvictionRequests(t *testing.T) {
0000000000000000000000000000000000000000;;		podNameFormat := "test-pod-%d"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s, closeFn, rm, informers, clientSet := rmSetup(t)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("concurrent-eviction-requests", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		informers.Start(stopCh)
0000000000000000000000000000000000000000;;		go rm.Run(stopCh)
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := restclient.Config{Host: s.URL}
0000000000000000000000000000000000000000;;		clientSet, err := clientset.NewForConfig(&config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create clientset: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var gracePeriodSeconds int64 = 30
0000000000000000000000000000000000000000;;		deleteOption := &metav1.DeleteOptions{
0000000000000000000000000000000000000000;;			GracePeriodSeconds: &gracePeriodSeconds,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate numOfEvictions pods to evict
0000000000000000000000000000000000000000;;		for i := 0; i < numOfEvictions; i++ {
0000000000000000000000000000000000000000;;			podName := fmt.Sprintf(podNameFormat, i)
0000000000000000000000000000000000000000;;			pod := newPod(podName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, err := clientSet.Core().Pods(ns.Name).Create(pod); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Failed to create pod: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			addPodConditionReady(pod)
0000000000000000000000000000000000000000;;			if _, err := clientSet.Core().Pods(ns.Name).UpdateStatus(pod); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitToObservePods(t, informers.Core().V1().Pods().Informer(), numOfEvictions)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pdb := newPDB()
0000000000000000000000000000000000000000;;		if _, err := clientSet.Policy().PodDisruptionBudgets(ns.Name).Create(pdb); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to create PodDisruptionBudget: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitPDBStable(t, clientSet, numOfEvictions, ns.Name, pdb.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var numberPodsEvicted uint32 = 0
0000000000000000000000000000000000000000;;		errCh := make(chan error, 3*numOfEvictions)
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		// spawn numOfEvictions goroutines to concurrently evict the pods
0000000000000000000000000000000000000000;;		for i := 0; i < numOfEvictions; i++ {
0000000000000000000000000000000000000000;;			wg.Add(1)
0000000000000000000000000000000000000000;;			go func(id int, errCh chan error) {
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;				podName := fmt.Sprintf(podNameFormat, id)
0000000000000000000000000000000000000000;;				eviction := newEviction(ns.Name, podName, deleteOption)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err := wait.PollImmediate(5*time.Second, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;					e := clientSet.Policy().Evictions(ns.Name).Evict(eviction)
0000000000000000000000000000000000000000;;					switch {
0000000000000000000000000000000000000000;;					case errors.IsTooManyRequests(e):
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					case errors.IsConflict(e):
0000000000000000000000000000000000000000;;						return false, fmt.Errorf("Unexpected Conflict (409) error caused by failing to handle concurrent PDB updates: %v", e)
0000000000000000000000000000000000000000;;					case e == nil:
0000000000000000000000000000000000000000;;						return true, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						return false, e
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errCh <- err
0000000000000000000000000000000000000000;;					// should not return here otherwise we would leak the pod
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				_, err = clientSet.Core().Pods(ns.Name).Get(podName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case errors.IsNotFound(err):
0000000000000000000000000000000000000000;;					atomic.AddUint32(&numberPodsEvicted, 1)
0000000000000000000000000000000000000000;;					// pod was evicted and deleted so return from goroutine immediately
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				case err == nil:
0000000000000000000000000000000000000000;;					// this shouldn't happen if the pod was evicted successfully
0000000000000000000000000000000000000000;;					errCh <- fmt.Errorf("Pod %q is expected to be evicted", podName)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					errCh <- err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// delete pod which still exists due to error
0000000000000000000000000000000000000000;;				e := clientSet.Core().Pods(ns.Name).Delete(podName, deleteOption)
0000000000000000000000000000000000000000;;				if e != nil {
0000000000000000000000000000000000000000;;					errCh <- e
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}(i, errCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		close(errCh)
0000000000000000000000000000000000000000;;		var errList []error
0000000000000000000000000000000000000000;;		if err := clientSet.Policy().PodDisruptionBudgets(ns.Name).Delete(pdb.Name, deleteOption); err != nil {
0000000000000000000000000000000000000000;;			errList = append(errList, fmt.Errorf("Failed to delete PodDisruptionBudget: %v", err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for err := range errCh {
0000000000000000000000000000000000000000;;			errList = append(errList, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(errList) > 0 {
0000000000000000000000000000000000000000;;			t.Fatal(utilerrors.NewAggregate(errList))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if atomic.LoadUint32(&numberPodsEvicted) != numOfEvictions {
0000000000000000000000000000000000000000;;			t.Fatalf("fewer number of successful evictions than expected : %d", numberPodsEvicted)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPod(podName string) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:   podName,
0000000000000000000000000000000000000000;;				Labels: map[string]string{"app": "test-evictions"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "fake-name",
0000000000000000000000000000000000000000;;						Image: "fakeimage",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addPodConditionReady(pod *v1.Pod) {
0000000000000000000000000000000000000000;;		pod.Status = v1.PodStatus{
0000000000000000000000000000000000000000;;			Phase: v1.PodRunning,
0000000000000000000000000000000000000000;;			Conditions: []v1.PodCondition{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:   v1.PodReady,
0000000000000000000000000000000000000000;;					Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPDB() *v1beta1.PodDisruptionBudget {
0000000000000000000000000000000000000000;;		return &v1beta1.PodDisruptionBudget{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "test-pdb",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1beta1.PodDisruptionBudgetSpec{
0000000000000000000000000000000000000000;;				MinAvailable: &intstr.IntOrString{
0000000000000000000000000000000000000000;;					Type:   intstr.Int,
0000000000000000000000000000000000000000;;					IntVal: 0,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;					MatchLabels: map[string]string{"app": "test-evictions"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newEviction(ns, evictionName string, deleteOption *metav1.DeleteOptions) *v1beta1.Eviction {
0000000000000000000000000000000000000000;;		return &v1beta1.Eviction{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				APIVersion: "Policy/v1beta1",
0000000000000000000000000000000000000000;;				Kind:       "Eviction",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      evictionName,
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			DeleteOptions: deleteOption,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func rmSetup(t *testing.T) (*httptest.Server, framework.CloseFunc, *disruption.DisruptionController, informers.SharedInformerFactory, clientset.Interface) {
0000000000000000000000000000000000000000;;		masterConfig := framework.NewIntegrationTestMasterConfig()
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(masterConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := restclient.Config{Host: s.URL}
0000000000000000000000000000000000000000;;		clientSet, err := clientset.NewForConfig(&config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error in create clientset: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resyncPeriod := 12 * time.Hour
0000000000000000000000000000000000000000;;		informers := informers.NewSharedInformerFactory(clientset.NewForConfigOrDie(restclient.AddUserAgent(&config, "pdb-informers")), resyncPeriod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rm := disruption.NewDisruptionController(
0000000000000000000000000000000000000000;;			informers.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			informers.Policy().V1beta1().PodDisruptionBudgets(),
0000000000000000000000000000000000000000;;			informers.Core().V1().ReplicationControllers(),
0000000000000000000000000000000000000000;;			informers.Extensions().V1beta1().ReplicaSets(),
0000000000000000000000000000000000000000;;			informers.Extensions().V1beta1().Deployments(),
0000000000000000000000000000000000000000;;			informers.Apps().V1beta1().StatefulSets(),
0000000000000000000000000000000000000000;;			clientset.NewForConfigOrDie(restclient.AddUserAgent(&config, "disruption-controller")),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		return s, closeFn, rm, informers, clientSet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wait for the podInformer to observe the pods. Call this function before
0000000000000000000000000000000000000000;;	// running the RS controller to prevent the rc manager from creating new pods
0000000000000000000000000000000000000000;;	// rather than adopting the existing ones.
0000000000000000000000000000000000000000;;	func waitToObservePods(t *testing.T, podInformer cache.SharedIndexInformer, podNum int) {
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(2*time.Second, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			objects := podInformer.GetIndexer().List()
0000000000000000000000000000000000000000;;			if len(objects) == podNum {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitPDBStable(t *testing.T, clientSet clientset.Interface, podNum int32, ns, pdbName string) {
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(2*time.Second, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			pdb, err := clientSet.Policy().PodDisruptionBudgets(ns).Get(pdbName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pdb.Status.CurrentHealthy != podNum {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
