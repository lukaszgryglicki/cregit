0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
3ad018b73f912fa3310cc5b939db007339b9a385;test/integration/auth_test.go[test/integration/auth_test.go][test/integration/auth/auth_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package auth
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file tests authentication and (soon) authorization of HTTP requests to a master object.
0000000000000000000000000000000000000000;;	// It does not use the client in pkg/client/... because authentication and authorization needs
0000000000000000000000000000000000000000;;	// to work for any client of the HTTP interface.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authenticationv1beta1 "k8s.io/api/authentication/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/authenticator"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/group"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/request/bearertoken"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/serviceaccount"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizerfactory"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/plugin/pkg/authenticator/token/tokentest"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/plugin/pkg/authenticator/token/webhook"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd/api/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/autoscaling"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/auth/authorizer/abac"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/admission/admit"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		AliceToken   string = "abc123" // username: alice.  Present in token file.
0000000000000000000000000000000000000000;;		BobToken     string = "xyz987" // username: bob.  Present in token file.
0000000000000000000000000000000000000000;;		UnknownToken string = "qwerty" // Not present in token file.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTestTokenAuth() authenticator.Request {
0000000000000000000000000000000000000000;;		tokenAuthenticator := tokentest.New()
0000000000000000000000000000000000000000;;		tokenAuthenticator.Tokens[AliceToken] = &user.DefaultInfo{Name: "alice", UID: "1"}
0000000000000000000000000000000000000000;;		tokenAuthenticator.Tokens[BobToken] = &user.DefaultInfo{Name: "bob", UID: "2"}
0000000000000000000000000000000000000000;;		return group.NewGroupAdder(bearertoken.New(tokenAuthenticator), []string{user.AllAuthenticated})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTestWebhookTokenAuth(serverURL string) (authenticator.Request, error) {
0000000000000000000000000000000000000000;;		kubecfgFile, err := ioutil.TempFile("", "webhook-kubecfg")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.Remove(kubecfgFile.Name())
0000000000000000000000000000000000000000;;		config := v1.Config{
0000000000000000000000000000000000000000;;			Clusters: []v1.NamedCluster{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Cluster: v1.Cluster{Server: serverURL},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := json.NewEncoder(kubecfgFile).Encode(config); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		webhookTokenAuth, err := webhook.New(kubecfgFile.Name(), 2*time.Minute)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bearertoken.New(webhookTokenAuth), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func path(resource, namespace, name string) string {
0000000000000000000000000000000000000000;;		return testapi.Default.ResourcePath(resource, namespace, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pathWithPrefix(prefix, resource, namespace, name string) string {
0000000000000000000000000000000000000000;;		return testapi.Default.ResourcePathWithPrefix(prefix, resource, namespace, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func timeoutPath(resource, namespace, name string) string {
0000000000000000000000000000000000000000;;		return addTimeoutFlag(testapi.Default.ResourcePath(resource, namespace, name))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bodies for requests used in subsequent tests.
0000000000000000000000000000000000000000;;	var aPod string = `
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	  "kind": "Pod",
0000000000000000000000000000000000000000;;	  "apiVersion": "` + api.Registry.GroupOrDie(api.GroupName).GroupVersion.String() + `",
0000000000000000000000000000000000000000;;	  "metadata": {
0000000000000000000000000000000000000000;;	    "name": "a",
0000000000000000000000000000000000000000;;	    "creationTimestamp": null%s
0000000000000000000000000000000000000000;;	  },
0000000000000000000000000000000000000000;;	  "spec": {
0000000000000000000000000000000000000000;;	    "containers": [
0000000000000000000000000000000000000000;;	      {
0000000000000000000000000000000000000000;;	        "name": "foo",
0000000000000000000000000000000000000000;;	        "image": "bar/foo"
0000000000000000000000000000000000000000;;	      }
0000000000000000000000000000000000000000;;	    ]
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	var aRC string = `
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	  "kind": "ReplicationController",
0000000000000000000000000000000000000000;;	  "apiVersion": "` + api.Registry.GroupOrDie(api.GroupName).GroupVersion.String() + `",
0000000000000000000000000000000000000000;;	  "metadata": {
0000000000000000000000000000000000000000;;	    "name": "a",
0000000000000000000000000000000000000000;;	    "labels": {
0000000000000000000000000000000000000000;;	      "name": "a"
0000000000000000000000000000000000000000;;	    }%s
0000000000000000000000000000000000000000;;	  },
0000000000000000000000000000000000000000;;	  "spec": {
0000000000000000000000000000000000000000;;	    "replicas": 2,
0000000000000000000000000000000000000000;;	    "selector": {
0000000000000000000000000000000000000000;;	      "name": "a"
0000000000000000000000000000000000000000;;	    },
0000000000000000000000000000000000000000;;	    "template": {
0000000000000000000000000000000000000000;;	      "metadata": {
0000000000000000000000000000000000000000;;	        "labels": {
0000000000000000000000000000000000000000;;	          "name": "a"
0000000000000000000000000000000000000000;;	        }
0000000000000000000000000000000000000000;;	      },
0000000000000000000000000000000000000000;;	      "spec": {
0000000000000000000000000000000000000000;;	        "containers": [
0000000000000000000000000000000000000000;;	          {
0000000000000000000000000000000000000000;;	            "name": "foo",
0000000000000000000000000000000000000000;;	            "image": "bar/foo"
0000000000000000000000000000000000000000;;	          }
0000000000000000000000000000000000000000;;	        ]
0000000000000000000000000000000000000000;;	      }
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	var aService string = `
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	  "kind": "Service",
0000000000000000000000000000000000000000;;	  "apiVersion": "` + api.Registry.GroupOrDie(api.GroupName).GroupVersion.String() + `",
0000000000000000000000000000000000000000;;	  "metadata": {
0000000000000000000000000000000000000000;;	    "name": "a",
0000000000000000000000000000000000000000;;	    "labels": {
0000000000000000000000000000000000000000;;	      "name": "a"
0000000000000000000000000000000000000000;;	    }%s
0000000000000000000000000000000000000000;;	  },
0000000000000000000000000000000000000000;;	  "spec": {
0000000000000000000000000000000000000000;;	    "ports": [
0000000000000000000000000000000000000000;;	      {
0000000000000000000000000000000000000000;;	        "protocol": "TCP",
0000000000000000000000000000000000000000;;	        "port": 8000
0000000000000000000000000000000000000000;;	      }
0000000000000000000000000000000000000000;;	    ],
0000000000000000000000000000000000000000;;	    "selector": {
0000000000000000000000000000000000000000;;	      "name": "a"
0000000000000000000000000000000000000000;;	    },
0000000000000000000000000000000000000000;;	    "clusterIP": "10.0.0.100"
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	var aNode string = `
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	  "kind": "Node",
0000000000000000000000000000000000000000;;	  "apiVersion": "` + api.Registry.GroupOrDie(api.GroupName).GroupVersion.String() + `",
0000000000000000000000000000000000000000;;	  "metadata": {
0000000000000000000000000000000000000000;;	    "name": "a"%s
0000000000000000000000000000000000000000;;	  },
0000000000000000000000000000000000000000;;	  "spec": {
0000000000000000000000000000000000000000;;	    "externalID": "external"
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func aEvent(namespace string) string {
0000000000000000000000000000000000000000;;		return `
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	  "kind": "Event",
0000000000000000000000000000000000000000;;	  "apiVersion": "` + api.Registry.GroupOrDie(api.GroupName).GroupVersion.String() + `",
0000000000000000000000000000000000000000;;	  "metadata": {
0000000000000000000000000000000000000000;;	    "name": "a"%s
0000000000000000000000000000000000000000;;	  },
0000000000000000000000000000000000000000;;	  "involvedObject": {
0000000000000000000000000000000000000000;;	    "kind": "Pod",
0000000000000000000000000000000000000000;;	    "namespace": "` + namespace + `",
0000000000000000000000000000000000000000;;	    "name": "a",
0000000000000000000000000000000000000000;;	    "apiVersion": "v1"
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var aBinding string = `
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	  "kind": "Binding",
0000000000000000000000000000000000000000;;	  "apiVersion": "` + api.Registry.GroupOrDie(api.GroupName).GroupVersion.String() + `",
0000000000000000000000000000000000000000;;	  "metadata": {
0000000000000000000000000000000000000000;;	    "name": "a"%s
0000000000000000000000000000000000000000;;	  },
0000000000000000000000000000000000000000;;	  "target": {
0000000000000000000000000000000000000000;;	    "name": "10.10.10.10"
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var emptyEndpoints string = `
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	  "kind": "Endpoints",
0000000000000000000000000000000000000000;;	  "apiVersion": "v1",
0000000000000000000000000000000000000000;;	  "metadata": {
0000000000000000000000000000000000000000;;	    "name": "a"%s
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var aEndpoints string = `
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	  "kind": "Endpoints",
0000000000000000000000000000000000000000;;	  "apiVersion": "` + api.Registry.GroupOrDie(api.GroupName).GroupVersion.String() + `",
0000000000000000000000000000000000000000;;	  "metadata": {
0000000000000000000000000000000000000000;;	    "name": "a"%s
0000000000000000000000000000000000000000;;	  },
0000000000000000000000000000000000000000;;	  "subsets": [
0000000000000000000000000000000000000000;;	    {
0000000000000000000000000000000000000000;;	      "addresses": [
0000000000000000000000000000000000000000;;	        {
0000000000000000000000000000000000000000;;	          "ip": "10.10.1.1"
0000000000000000000000000000000000000000;;	        }
0000000000000000000000000000000000000000;;	      ],
0000000000000000000000000000000000000000;;	      "ports": [
0000000000000000000000000000000000000000;;	        {
0000000000000000000000000000000000000000;;	          "port": 1909,
0000000000000000000000000000000000000000;;	          "protocol": "TCP"
0000000000000000000000000000000000000000;;	        }
0000000000000000000000000000000000000000;;	      ]
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	  ]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var deleteNow string = `
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	  "kind": "DeleteOptions",
0000000000000000000000000000000000000000;;	  "apiVersion": "` + api.Registry.GroupOrDie(api.GroupName).GroupVersion.String() + `",
0000000000000000000000000000000000000000;;	  "gracePeriodSeconds": 0%s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// To ensure that a POST completes before a dependent GET, set a timeout.
0000000000000000000000000000000000000000;;	func addTimeoutFlag(URLString string) string {
0000000000000000000000000000000000000000;;		u, _ := url.Parse(URLString)
0000000000000000000000000000000000000000;;		values := u.Query()
0000000000000000000000000000000000000000;;		values.Set("timeout", "60s")
0000000000000000000000000000000000000000;;		u.RawQuery = values.Encode()
0000000000000000000000000000000000000000;;		return u.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTestRequests(namespace string) []struct {
0000000000000000000000000000000000000000;;		verb        string
0000000000000000000000000000000000000000;;		URL         string
0000000000000000000000000000000000000000;;		body        string
0000000000000000000000000000000000000000;;		statusCodes map[int]bool // allowed status codes.
0000000000000000000000000000000000000000;;	} {
0000000000000000000000000000000000000000;;		requests := []struct {
0000000000000000000000000000000000000000;;			verb        string
0000000000000000000000000000000000000000;;			URL         string
0000000000000000000000000000000000000000;;			body        string
0000000000000000000000000000000000000000;;			statusCodes map[int]bool // Set of expected resp.StatusCode if all goes well.
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// Normal methods on pods
0000000000000000000000000000000000000000;;			{"GET", path("pods", "", ""), "", integration.Code200},
0000000000000000000000000000000000000000;;			{"GET", path("pods", namespace, ""), "", integration.Code200},
0000000000000000000000000000000000000000;;			{"POST", timeoutPath("pods", namespace, ""), aPod, integration.Code201},
0000000000000000000000000000000000000000;;			{"PUT", timeoutPath("pods", namespace, "a"), aPod, integration.Code200},
0000000000000000000000000000000000000000;;			{"GET", path("pods", namespace, "a"), "", integration.Code200},
0000000000000000000000000000000000000000;;			// GET and POST for /exec should return Bad Request (400) since the pod has not been assigned a node yet.
0000000000000000000000000000000000000000;;			{"GET", path("pods", namespace, "a") + "/exec", "", integration.Code400},
0000000000000000000000000000000000000000;;			{"POST", path("pods", namespace, "a") + "/exec", "", integration.Code400},
0000000000000000000000000000000000000000;;			// PUT for /exec should return Method Not Allowed (405).
0000000000000000000000000000000000000000;;			{"PUT", path("pods", namespace, "a") + "/exec", "", integration.Code405},
0000000000000000000000000000000000000000;;			// GET and POST for /portforward should return Bad Request (400) since the pod has not been assigned a node yet.
0000000000000000000000000000000000000000;;			{"GET", path("pods", namespace, "a") + "/portforward", "", integration.Code400},
0000000000000000000000000000000000000000;;			{"POST", path("pods", namespace, "a") + "/portforward", "", integration.Code400},
0000000000000000000000000000000000000000;;			// PUT for /portforward should return Method Not Allowed (405).
0000000000000000000000000000000000000000;;			{"PUT", path("pods", namespace, "a") + "/portforward", "", integration.Code405},
0000000000000000000000000000000000000000;;			{"PATCH", path("pods", namespace, "a"), "{%v}", integration.Code200},
0000000000000000000000000000000000000000;;			{"DELETE", timeoutPath("pods", namespace, "a"), deleteNow, integration.Code200},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Non-standard methods (not expected to work,
0000000000000000000000000000000000000000;;			// but expected to pass/fail authorization prior to
0000000000000000000000000000000000000000;;			// failing validation.
0000000000000000000000000000000000000000;;			{"OPTIONS", path("pods", namespace, ""), "", integration.Code405},
0000000000000000000000000000000000000000;;			{"OPTIONS", path("pods", namespace, "a"), "", integration.Code405},
0000000000000000000000000000000000000000;;			{"HEAD", path("pods", namespace, ""), "", integration.Code405},
0000000000000000000000000000000000000000;;			{"HEAD", path("pods", namespace, "a"), "", integration.Code405},
0000000000000000000000000000000000000000;;			{"TRACE", path("pods", namespace, ""), "", integration.Code405},
0000000000000000000000000000000000000000;;			{"TRACE", path("pods", namespace, "a"), "", integration.Code405},
0000000000000000000000000000000000000000;;			{"NOSUCHVERB", path("pods", namespace, ""), "", integration.Code405},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Normal methods on services
0000000000000000000000000000000000000000;;			{"GET", path("services", "", ""), "", integration.Code200},
0000000000000000000000000000000000000000;;			{"GET", path("services", namespace, ""), "", integration.Code200},
0000000000000000000000000000000000000000;;			{"POST", timeoutPath("services", namespace, ""), aService, integration.Code201},
0000000000000000000000000000000000000000;;			// Create an endpoint for the service (this is done automatically by endpoint controller
0000000000000000000000000000000000000000;;			// whenever a service is created, but this test does not run that controller)
0000000000000000000000000000000000000000;;			{"POST", timeoutPath("endpoints", namespace, ""), emptyEndpoints, integration.Code201},
0000000000000000000000000000000000000000;;			// Should return service unavailable when endpoint.subset is empty.
0000000000000000000000000000000000000000;;			{"GET", pathWithPrefix("proxy", "services", namespace, "a") + "/", "", integration.Code503},
0000000000000000000000000000000000000000;;			{"PUT", timeoutPath("services", namespace, "a"), aService, integration.Code200},
0000000000000000000000000000000000000000;;			{"GET", path("services", namespace, "a"), "", integration.Code200},
0000000000000000000000000000000000000000;;			{"DELETE", timeoutPath("endpoints", namespace, "a"), "", integration.Code200},
0000000000000000000000000000000000000000;;			{"DELETE", timeoutPath("services", namespace, "a"), "", integration.Code200},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Normal methods on replicationControllers
0000000000000000000000000000000000000000;;			{"GET", path("replicationControllers", "", ""), "", integration.Code200},
0000000000000000000000000000000000000000;;			{"GET", path("replicationControllers", namespace, ""), "", integration.Code200},
0000000000000000000000000000000000000000;;			{"POST", timeoutPath("replicationControllers", namespace, ""), aRC, integration.Code201},
0000000000000000000000000000000000000000;;			{"PUT", timeoutPath("replicationControllers", namespace, "a"), aRC, integration.Code200},
0000000000000000000000000000000000000000;;			{"GET", path("replicationControllers", namespace, "a"), "", integration.Code200},
0000000000000000000000000000000000000000;;			{"DELETE", timeoutPath("replicationControllers", namespace, "a"), "", integration.Code200},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Normal methods on endpoints
0000000000000000000000000000000000000000;;			{"GET", path("endpoints", "", ""), "", integration.Code200},
0000000000000000000000000000000000000000;;			{"GET", path("endpoints", namespace, ""), "", integration.Code200},
0000000000000000000000000000000000000000;;			{"POST", timeoutPath("endpoints", namespace, ""), aEndpoints, integration.Code201},
0000000000000000000000000000000000000000;;			{"PUT", timeoutPath("endpoints", namespace, "a"), aEndpoints, integration.Code200},
0000000000000000000000000000000000000000;;			{"GET", path("endpoints", namespace, "a"), "", integration.Code200},
0000000000000000000000000000000000000000;;			{"DELETE", timeoutPath("endpoints", namespace, "a"), "", integration.Code200},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Normal methods on nodes
0000000000000000000000000000000000000000;;			{"GET", path("nodes", "", ""), "", integration.Code200},
0000000000000000000000000000000000000000;;			{"POST", timeoutPath("nodes", "", ""), aNode, integration.Code201},
0000000000000000000000000000000000000000;;			{"PUT", timeoutPath("nodes", "", "a"), aNode, integration.Code200},
0000000000000000000000000000000000000000;;			{"GET", path("nodes", "", "a"), "", integration.Code200},
0000000000000000000000000000000000000000;;			{"DELETE", timeoutPath("nodes", "", "a"), "", integration.Code200},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Normal methods on events
0000000000000000000000000000000000000000;;			{"GET", path("events", "", ""), "", integration.Code200},
0000000000000000000000000000000000000000;;			{"GET", path("events", namespace, ""), "", integration.Code200},
0000000000000000000000000000000000000000;;			{"POST", timeoutPath("events", namespace, ""), aEvent(namespace), integration.Code201},
0000000000000000000000000000000000000000;;			{"PUT", timeoutPath("events", namespace, "a"), aEvent(namespace), integration.Code200},
0000000000000000000000000000000000000000;;			{"GET", path("events", namespace, "a"), "", integration.Code200},
0000000000000000000000000000000000000000;;			{"DELETE", timeoutPath("events", namespace, "a"), "", integration.Code200},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Normal methods on bindings
0000000000000000000000000000000000000000;;			{"GET", path("bindings", namespace, ""), "", integration.Code405},
0000000000000000000000000000000000000000;;			{"POST", timeoutPath("pods", namespace, ""), aPod, integration.Code201}, // Need a pod to bind or you get a 404
0000000000000000000000000000000000000000;;			{"POST", timeoutPath("bindings", namespace, ""), aBinding, integration.Code201},
0000000000000000000000000000000000000000;;			{"PUT", timeoutPath("bindings", namespace, "a"), aBinding, integration.Code404},
0000000000000000000000000000000000000000;;			{"GET", path("bindings", namespace, "a"), "", integration.Code404}, // No bindings instances
0000000000000000000000000000000000000000;;			{"DELETE", timeoutPath("bindings", namespace, "a"), "", integration.Code404},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Non-existent object type.
0000000000000000000000000000000000000000;;			{"GET", path("foo", "", ""), "", integration.Code404},
0000000000000000000000000000000000000000;;			{"POST", path("foo", namespace, ""), `{"foo": "foo"}`, integration.Code404},
0000000000000000000000000000000000000000;;			{"PUT", path("foo", namespace, "a"), `{"foo": "foo"}`, integration.Code404},
0000000000000000000000000000000000000000;;			{"GET", path("foo", namespace, "a"), "", integration.Code404},
0000000000000000000000000000000000000000;;			{"DELETE", timeoutPath("foo", namespace, ""), "", integration.Code404},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Special verbs on nodes
0000000000000000000000000000000000000000;;			{"GET", pathWithPrefix("proxy", "nodes", namespace, "a"), "", integration.Code404},
0000000000000000000000000000000000000000;;			{"GET", pathWithPrefix("redirect", "nodes", namespace, "a"), "", integration.Code404},
0000000000000000000000000000000000000000;;			// TODO: test .../watch/..., which doesn't end before the test timeout.
0000000000000000000000000000000000000000;;			// TODO: figure out how to create a node so that it can successfully proxy/redirect.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Non-object endpoints
0000000000000000000000000000000000000000;;			{"GET", "/", "", integration.Code200},
0000000000000000000000000000000000000000;;			{"GET", "/api", "", integration.Code200},
0000000000000000000000000000000000000000;;			{"GET", "/healthz", "", integration.Code200},
0000000000000000000000000000000000000000;;			{"GET", "/version", "", integration.Code200},
0000000000000000000000000000000000000000;;			{"GET", "/invalidURL", "", integration.Code404},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return requests
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The TestAuthMode* tests tests a large number of URLs and checks that they
0000000000000000000000000000000000000000;;	// are FORBIDDEN or not, depending on the mode.  They do not attempt to do
0000000000000000000000000000000000000000;;	// detailed verification of behaviour beyond authorization.  They are not
0000000000000000000000000000000000000000;;	// fuzz tests.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO(etune): write a fuzz test of the REST API.
0000000000000000000000000000000000000000;;	func TestAuthModeAlwaysAllow(t *testing.T) {
0000000000000000000000000000000000000000;;		// Set up a master
0000000000000000000000000000000000000000;;		masterConfig := framework.NewIntegrationTestMasterConfig()
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(masterConfig)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("auth-always-allow", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		transport := http.DefaultTransport
0000000000000000000000000000000000000000;;		previousResourceVersion := make(map[string]float64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, r := range getTestRequests(ns.Name) {
0000000000000000000000000000000000000000;;			var bodyStr string
0000000000000000000000000000000000000000;;			if r.body != "" {
0000000000000000000000000000000000000000;;				sub := ""
0000000000000000000000000000000000000000;;				if r.verb == "PUT" {
0000000000000000000000000000000000000000;;					// For update operations, insert previous resource version
0000000000000000000000000000000000000000;;					if resVersion := previousResourceVersion[getPreviousResourceVersionKey(r.URL, "")]; resVersion != 0 {
0000000000000000000000000000000000000000;;						sub += fmt.Sprintf(",\r\n\"resourceVersion\": \"%v\"", resVersion)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					sub += fmt.Sprintf(",\r\n\"namespace\": %q", ns.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				bodyStr = fmt.Sprintf(r.body, sub)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.body = bodyStr
0000000000000000000000000000000000000000;;			bodyBytes := bytes.NewReader([]byte(bodyStr))
0000000000000000000000000000000000000000;;			req, err := http.NewRequest(r.verb, s.URL+r.URL, bodyBytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Logf("case %v", r)
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if r.verb == "PATCH" {
0000000000000000000000000000000000000000;;				req.Header.Set("Content-Type", "application/merge-patch+json")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				resp, err := transport.RoundTrip(req)
0000000000000000000000000000000000000000;;				defer resp.Body.Close()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b, _ := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;				if _, ok := r.statusCodes[resp.StatusCode]; !ok {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Errorf("Expected status one of %v, but got %v", r.statusCodes, resp.StatusCode)
0000000000000000000000000000000000000000;;					t.Errorf("Body: %v", string(b))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if r.verb == "POST" {
0000000000000000000000000000000000000000;;						// For successful create operations, extract resourceVersion
0000000000000000000000000000000000000000;;						id, currentResourceVersion, err := parseResourceVersion(b)
0000000000000000000000000000000000000000;;						if err == nil {
0000000000000000000000000000000000000000;;							key := getPreviousResourceVersionKey(r.URL, id)
0000000000000000000000000000000000000000;;							previousResourceVersion[key] = currentResourceVersion
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							t.Logf("error in trying to extract resource version: %s", err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseResourceVersion(response []byte) (string, float64, error) {
0000000000000000000000000000000000000000;;		var resultBodyMap map[string]interface{}
0000000000000000000000000000000000000000;;		err := json.Unmarshal(response, &resultBodyMap)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", 0, fmt.Errorf("unexpected error unmarshaling resultBody: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metadata, ok := resultBodyMap["metadata"].(map[string]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", 0, fmt.Errorf("unexpected error, metadata not found in JSON response: %v", string(response))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		id, ok := metadata["name"].(string)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", 0, fmt.Errorf("unexpected error, id not found in JSON response: %v", string(response))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceVersionString, ok := metadata["resourceVersion"].(string)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", 0, fmt.Errorf("unexpected error, resourceVersion not found in JSON response: %v", string(response))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceVersion, err := strconv.ParseFloat(resourceVersionString, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", 0, fmt.Errorf("unexpected error, could not parse resourceVersion as float64, err: %s. JSON response: %v", err, string(response))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return id, resourceVersion, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPreviousResourceVersionKey(url, id string) string {
0000000000000000000000000000000000000000;;		baseUrl := strings.Split(url, "?")[0]
0000000000000000000000000000000000000000;;		key := baseUrl
0000000000000000000000000000000000000000;;		if id != "" {
0000000000000000000000000000000000000000;;			key = fmt.Sprintf("%s/%v", baseUrl, id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return key
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAuthModeAlwaysDeny(t *testing.T) {
0000000000000000000000000000000000000000;;		// Set up a master
0000000000000000000000000000000000000000;;		masterConfig := framework.NewIntegrationTestMasterConfig()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authorizer = authorizerfactory.NewAlwaysDenyAuthorizer()
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(masterConfig)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("auth-always-deny", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		transport := http.DefaultTransport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, r := range getTestRequests(ns.Name) {
0000000000000000000000000000000000000000;;			bodyBytes := bytes.NewReader([]byte(r.body))
0000000000000000000000000000000000000000;;			req, err := http.NewRequest(r.verb, s.URL+r.URL, bodyBytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Logf("case %v", r)
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				resp, err := transport.RoundTrip(req)
0000000000000000000000000000000000000000;;				defer resp.Body.Close()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if resp.StatusCode != http.StatusForbidden {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Errorf("Expected status Forbidden but got status %v", resp.Status)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Inject into master an authorizer that uses user info.
0000000000000000000000000000000000000000;;	// TODO(etune): remove this test once a more comprehensive built-in authorizer is implemented.
0000000000000000000000000000000000000000;;	type allowAliceAuthorizer struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (allowAliceAuthorizer) Authorize(a authorizer.Attributes) (bool, string, error) {
0000000000000000000000000000000000000000;;		if a.GetUser() != nil && a.GetUser().GetName() == "alice" {
0000000000000000000000000000000000000000;;			return true, "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, "I can't allow that.  Go ask alice.", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAliceNotForbiddenOrUnauthorized tests a user who is known to
0000000000000000000000000000000000000000;;	// the authentication system and authorized to do any actions.
0000000000000000000000000000000000000000;;	func TestAliceNotForbiddenOrUnauthorized(t *testing.T) {
0000000000000000000000000000000000000000;;		// This file has alice and bob in it.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up a master
0000000000000000000000000000000000000000;;		masterConfig := framework.NewIntegrationTestMasterConfig()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authenticator = getTestTokenAuth()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authorizer = allowAliceAuthorizer{}
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.AdmissionControl = admit.NewAlwaysAdmit()
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(masterConfig)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("auth-alice-not-forbidden", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		previousResourceVersion := make(map[string]float64)
0000000000000000000000000000000000000000;;		transport := http.DefaultTransport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, r := range getTestRequests(ns.Name) {
0000000000000000000000000000000000000000;;			token := AliceToken
0000000000000000000000000000000000000000;;			var bodyStr string
0000000000000000000000000000000000000000;;			if r.body != "" {
0000000000000000000000000000000000000000;;				sub := ""
0000000000000000000000000000000000000000;;				if r.verb == "PUT" {
0000000000000000000000000000000000000000;;					// For update operations, insert previous resource version
0000000000000000000000000000000000000000;;					if resVersion := previousResourceVersion[getPreviousResourceVersionKey(r.URL, "")]; resVersion != 0 {
0000000000000000000000000000000000000000;;						sub += fmt.Sprintf(",\r\n\"resourceVersion\": \"%v\"", resVersion)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					sub += fmt.Sprintf(",\r\n\"namespace\": %q", ns.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				bodyStr = fmt.Sprintf(r.body, sub)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.body = bodyStr
0000000000000000000000000000000000000000;;			bodyBytes := bytes.NewReader([]byte(bodyStr))
0000000000000000000000000000000000000000;;			req, err := http.NewRequest(r.verb, s.URL+r.URL, bodyBytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
0000000000000000000000000000000000000000;;			if r.verb == "PATCH" {
0000000000000000000000000000000000000000;;				req.Header.Set("Content-Type", "application/merge-patch+json")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				resp, err := transport.RoundTrip(req)
0000000000000000000000000000000000000000;;				defer resp.Body.Close()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b, _ := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;				if _, ok := r.statusCodes[resp.StatusCode]; !ok {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Errorf("Expected status one of %v, but got %v", r.statusCodes, resp.StatusCode)
0000000000000000000000000000000000000000;;					t.Errorf("Body: %v", string(b))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if r.verb == "POST" {
0000000000000000000000000000000000000000;;						// For successful create operations, extract resourceVersion
0000000000000000000000000000000000000000;;						id, currentResourceVersion, err := parseResourceVersion(b)
0000000000000000000000000000000000000000;;						if err == nil {
0000000000000000000000000000000000000000;;							key := getPreviousResourceVersionKey(r.URL, id)
0000000000000000000000000000000000000000;;							previousResourceVersion[key] = currentResourceVersion
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestBobIsForbidden tests that a user who is known to
0000000000000000000000000000000000000000;;	// the authentication system but not authorized to do any actions
0000000000000000000000000000000000000000;;	// should receive "Forbidden".
0000000000000000000000000000000000000000;;	func TestBobIsForbidden(t *testing.T) {
0000000000000000000000000000000000000000;;		// This file has alice and bob in it.
0000000000000000000000000000000000000000;;		masterConfig := framework.NewIntegrationTestMasterConfig()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authenticator = getTestTokenAuth()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authorizer = allowAliceAuthorizer{}
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(masterConfig)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("auth-bob-forbidden", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		transport := http.DefaultTransport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, r := range getTestRequests(ns.Name) {
0000000000000000000000000000000000000000;;			token := BobToken
0000000000000000000000000000000000000000;;			bodyBytes := bytes.NewReader([]byte(r.body))
0000000000000000000000000000000000000000;;			req, err := http.NewRequest(r.verb, s.URL+r.URL, bodyBytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				resp, err := transport.RoundTrip(req)
0000000000000000000000000000000000000000;;				defer resp.Body.Close()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Expect all of bob's actions to return Forbidden
0000000000000000000000000000000000000000;;				if resp.StatusCode != http.StatusForbidden {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Errorf("Expected not status Forbidden, but got %s", resp.Status)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestUnknownUserIsUnauthorized tests that a user who is unknown
0000000000000000000000000000000000000000;;	// to the authentication system get status code "Unauthorized".
0000000000000000000000000000000000000000;;	// An authorization module is installed in this scenario for integration
0000000000000000000000000000000000000000;;	// test purposes, but requests aren't expected to reach it.
0000000000000000000000000000000000000000;;	func TestUnknownUserIsUnauthorized(t *testing.T) {
0000000000000000000000000000000000000000;;		// This file has alice and bob in it.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up a master
0000000000000000000000000000000000000000;;		masterConfig := framework.NewIntegrationTestMasterConfig()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authenticator = getTestTokenAuth()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authorizer = allowAliceAuthorizer{}
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(masterConfig)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("auth-unknown-unauthorized", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		transport := http.DefaultTransport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, r := range getTestRequests(ns.Name) {
0000000000000000000000000000000000000000;;			token := UnknownToken
0000000000000000000000000000000000000000;;			bodyBytes := bytes.NewReader([]byte(r.body))
0000000000000000000000000000000000000000;;			req, err := http.NewRequest(r.verb, s.URL+r.URL, bodyBytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				resp, err := transport.RoundTrip(req)
0000000000000000000000000000000000000000;;				defer resp.Body.Close()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Expect all of unauthenticated user's request to be "Unauthorized"
0000000000000000000000000000000000000000;;				if resp.StatusCode != http.StatusUnauthorized {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Errorf("Expected status %v, but got %v", http.StatusUnauthorized, resp.StatusCode)
0000000000000000000000000000000000000000;;					b, _ := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;					t.Errorf("Body: %v", string(b))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type impersonateAuthorizer struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// alice can't act as anyone and bob can't do anything but act-as someone
0000000000000000000000000000000000000000;;	func (impersonateAuthorizer) Authorize(a authorizer.Attributes) (bool, string, error) {
0000000000000000000000000000000000000000;;		// alice can impersonate service accounts and do other actions
0000000000000000000000000000000000000000;;		if a.GetUser() != nil && a.GetUser().GetName() == "alice" && a.GetVerb() == "impersonate" && a.GetResource() == "serviceaccounts" {
0000000000000000000000000000000000000000;;			return true, "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.GetUser() != nil && a.GetUser().GetName() == "alice" && a.GetVerb() != "impersonate" {
0000000000000000000000000000000000000000;;			return true, "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// bob can impersonate anyone, but that it
0000000000000000000000000000000000000000;;		if a.GetUser() != nil && a.GetUser().GetName() == "bob" && a.GetVerb() == "impersonate" {
0000000000000000000000000000000000000000;;			return true, "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// service accounts can do everything
0000000000000000000000000000000000000000;;		if a.GetUser() != nil && strings.HasPrefix(a.GetUser().GetName(), serviceaccount.ServiceAccountUsernamePrefix) {
0000000000000000000000000000000000000000;;			return true, "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, "I can't allow that.  Go ask alice.", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestImpersonateIsForbidden(t *testing.T) {
0000000000000000000000000000000000000000;;		// Set up a master
0000000000000000000000000000000000000000;;		masterConfig := framework.NewIntegrationTestMasterConfig()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authenticator = getTestTokenAuth()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authorizer = impersonateAuthorizer{}
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(masterConfig)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("auth-impersonate-forbidden", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		transport := http.DefaultTransport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// bob can't perform actions himself
0000000000000000000000000000000000000000;;		for _, r := range getTestRequests(ns.Name) {
0000000000000000000000000000000000000000;;			token := BobToken
0000000000000000000000000000000000000000;;			bodyBytes := bytes.NewReader([]byte(r.body))
0000000000000000000000000000000000000000;;			req, err := http.NewRequest(r.verb, s.URL+r.URL, bodyBytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				resp, err := transport.RoundTrip(req)
0000000000000000000000000000000000000000;;				defer resp.Body.Close()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Expect all of bob's actions to return Forbidden
0000000000000000000000000000000000000000;;				if resp.StatusCode != http.StatusForbidden {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Errorf("Expected not status Forbidden, but got %s", resp.Status)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// bob can impersonate alice to do other things
0000000000000000000000000000000000000000;;		for _, r := range getTestRequests(ns.Name) {
0000000000000000000000000000000000000000;;			token := BobToken
0000000000000000000000000000000000000000;;			bodyBytes := bytes.NewReader([]byte(r.body))
0000000000000000000000000000000000000000;;			req, err := http.NewRequest(r.verb, s.URL+r.URL, bodyBytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
0000000000000000000000000000000000000000;;			req.Header.Set("Impersonate-User", "alice")
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				resp, err := transport.RoundTrip(req)
0000000000000000000000000000000000000000;;				defer resp.Body.Close()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Expect all the requests to be allowed, don't care what they actually do
0000000000000000000000000000000000000000;;				if resp.StatusCode == http.StatusForbidden {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Errorf("Expected status not %v, but got %v", http.StatusForbidden, resp.StatusCode)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// alice can't impersonate bob
0000000000000000000000000000000000000000;;		for _, r := range getTestRequests(ns.Name) {
0000000000000000000000000000000000000000;;			token := AliceToken
0000000000000000000000000000000000000000;;			bodyBytes := bytes.NewReader([]byte(r.body))
0000000000000000000000000000000000000000;;			req, err := http.NewRequest(r.verb, s.URL+r.URL, bodyBytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
0000000000000000000000000000000000000000;;			req.Header.Set("Impersonate-User", "bob")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				resp, err := transport.RoundTrip(req)
0000000000000000000000000000000000000000;;				defer resp.Body.Close()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Expect all of bob's actions to return Forbidden
0000000000000000000000000000000000000000;;				if resp.StatusCode != http.StatusForbidden {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Errorf("Expected not status Forbidden, but got %s", resp.Status)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// alice can impersonate a service account
0000000000000000000000000000000000000000;;		for _, r := range getTestRequests(ns.Name) {
0000000000000000000000000000000000000000;;			token := BobToken
0000000000000000000000000000000000000000;;			bodyBytes := bytes.NewReader([]byte(r.body))
0000000000000000000000000000000000000000;;			req, err := http.NewRequest(r.verb, s.URL+r.URL, bodyBytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
0000000000000000000000000000000000000000;;			req.Header.Set("Impersonate-User", serviceaccount.MakeUsername("default", "default"))
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				resp, err := transport.RoundTrip(req)
0000000000000000000000000000000000000000;;				defer resp.Body.Close()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Expect all the requests to be allowed, don't care what they actually do
0000000000000000000000000000000000000000;;				if resp.StatusCode == http.StatusForbidden {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Errorf("Expected status not %v, but got %v", http.StatusForbidden, resp.StatusCode)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newAuthorizerWithContents(t *testing.T, contents string) authorizer.Authorizer {
0000000000000000000000000000000000000000;;		f, err := ioutil.TempFile("", "auth_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error creating policyfile: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.Close()
0000000000000000000000000000000000000000;;		defer os.Remove(f.Name())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(f.Name(), []byte(contents), 0700); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error writing policyfile: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pl, err := abac.NewFromFile(f.Name())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error creating authorizer from policyfile: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pl
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type trackingAuthorizer struct {
0000000000000000000000000000000000000000;;		requestAttributes []authorizer.Attributes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *trackingAuthorizer) Authorize(attributes authorizer.Attributes) (bool, string, error) {
0000000000000000000000000000000000000000;;		a.requestAttributes = append(a.requestAttributes, attributes)
0000000000000000000000000000000000000000;;		return true, "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestAuthorizationAttributeDetermination tests that authorization attributes are built correctly
0000000000000000000000000000000000000000;;	func TestAuthorizationAttributeDetermination(t *testing.T) {
0000000000000000000000000000000000000000;;		trackingAuthorizer := &trackingAuthorizer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up a master
0000000000000000000000000000000000000000;;		masterConfig := framework.NewIntegrationTestMasterConfig()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authenticator = getTestTokenAuth()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authorizer = trackingAuthorizer
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(masterConfig)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("auth-attribute-determination", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		transport := http.DefaultTransport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requests := map[string]struct {
0000000000000000000000000000000000000000;;			verb               string
0000000000000000000000000000000000000000;;			URL                string
0000000000000000000000000000000000000000;;			expectedAttributes authorizer.Attributes
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"prefix/version/resource":        {"GET", "/api/v1/pods", authorizer.AttributesRecord{APIGroup: api.GroupName, Resource: "pods"}},
0000000000000000000000000000000000000000;;			"prefix/group/version/resource":  {"GET", "/apis/extensions/v1/pods", authorizer.AttributesRecord{APIGroup: extensions.GroupName, Resource: "pods"}},
0000000000000000000000000000000000000000;;			"prefix/group/version/resource2": {"GET", "/apis/autoscaling/v1/horizontalpodautoscalers", authorizer.AttributesRecord{APIGroup: autoscaling.GroupName, Resource: "horizontalpodautoscalers"}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currentAuthorizationAttributesIndex := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for testName, r := range requests {
0000000000000000000000000000000000000000;;			token := BobToken
0000000000000000000000000000000000000000;;			req, err := http.NewRequest(r.verb, s.URL+r.URL, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Logf("case %v", testName)
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				resp, err := transport.RoundTrip(req)
0000000000000000000000000000000000000000;;				defer resp.Body.Close()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				found := false
0000000000000000000000000000000000000000;;				for i := currentAuthorizationAttributesIndex; i < len(trackingAuthorizer.requestAttributes); i++ {
0000000000000000000000000000000000000000;;					if trackingAuthorizer.requestAttributes[i].GetAPIGroup() == r.expectedAttributes.GetAPIGroup() &&
0000000000000000000000000000000000000000;;						trackingAuthorizer.requestAttributes[i].GetResource() == r.expectedAttributes.GetResource() {
0000000000000000000000000000000000000000;;						found = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					t.Logf("%#v did not match %#v", r.expectedAttributes, trackingAuthorizer.requestAttributes[i].(*authorizer.AttributesRecord))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !found {
0000000000000000000000000000000000000000;;					t.Errorf("did not find %#v in %#v", r.expectedAttributes, trackingAuthorizer.requestAttributes[currentAuthorizationAttributesIndex:])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				currentAuthorizationAttributesIndex = len(trackingAuthorizer.requestAttributes)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestNamespaceAuthorization tests that authorization can be controlled
0000000000000000000000000000000000000000;;	// by namespace.
0000000000000000000000000000000000000000;;	func TestNamespaceAuthorization(t *testing.T) {
0000000000000000000000000000000000000000;;		// This file has alice and bob in it.
0000000000000000000000000000000000000000;;		a := newAuthorizerWithContents(t, `{"namespace": "auth-namespace"}
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up a master
0000000000000000000000000000000000000000;;		masterConfig := framework.NewIntegrationTestMasterConfig()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authenticator = getTestTokenAuth()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authorizer = a
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(masterConfig)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("auth-namespace", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		previousResourceVersion := make(map[string]float64)
0000000000000000000000000000000000000000;;		transport := http.DefaultTransport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requests := []struct {
0000000000000000000000000000000000000000;;			verb        string
0000000000000000000000000000000000000000;;			URL         string
0000000000000000000000000000000000000000;;			namespace   string
0000000000000000000000000000000000000000;;			body        string
0000000000000000000000000000000000000000;;			statusCodes map[int]bool // allowed status codes.
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"POST", timeoutPath("pods", ns.Name, ""), "foo", aPod, integration.Code201},
0000000000000000000000000000000000000000;;			{"GET", path("pods", ns.Name, ""), "foo", "", integration.Code200},
0000000000000000000000000000000000000000;;			{"GET", path("pods", ns.Name, "a"), "foo", "", integration.Code200},
0000000000000000000000000000000000000000;;			{"DELETE", timeoutPath("pods", ns.Name, "a"), "foo", "", integration.Code200},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"POST", timeoutPath("pods", "foo", ""), "bar", aPod, integration.Code403},
0000000000000000000000000000000000000000;;			{"GET", path("pods", "foo", ""), "bar", "", integration.Code403},
0000000000000000000000000000000000000000;;			{"GET", path("pods", "foo", "a"), "bar", "", integration.Code403},
0000000000000000000000000000000000000000;;			{"DELETE", timeoutPath("pods", "foo", "a"), "bar", "", integration.Code403},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"POST", timeoutPath("pods", metav1.NamespaceDefault, ""), "", aPod, integration.Code403},
0000000000000000000000000000000000000000;;			{"GET", path("pods", "", ""), "", "", integration.Code403},
0000000000000000000000000000000000000000;;			{"GET", path("pods", metav1.NamespaceDefault, "a"), "", "", integration.Code403},
0000000000000000000000000000000000000000;;			{"DELETE", timeoutPath("pods", metav1.NamespaceDefault, "a"), "", "", integration.Code403},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, r := range requests {
0000000000000000000000000000000000000000;;			token := BobToken
0000000000000000000000000000000000000000;;			var bodyStr string
0000000000000000000000000000000000000000;;			if r.body != "" {
0000000000000000000000000000000000000000;;				sub := ""
0000000000000000000000000000000000000000;;				if r.verb == "PUT" && r.body != "" {
0000000000000000000000000000000000000000;;					// For update operations, insert previous resource version
0000000000000000000000000000000000000000;;					if resVersion := previousResourceVersion[getPreviousResourceVersionKey(r.URL, "")]; resVersion != 0 {
0000000000000000000000000000000000000000;;						sub += fmt.Sprintf(",\r\n\"resourceVersion\": \"%v\"", resVersion)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					namespace := r.namespace
0000000000000000000000000000000000000000;;					// FIXME: Is that correct?
0000000000000000000000000000000000000000;;					if len(namespace) == 0 {
0000000000000000000000000000000000000000;;						namespace = "default"
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					sub += fmt.Sprintf(",\r\n\"namespace\": %q", namespace)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				bodyStr = fmt.Sprintf(r.body, sub)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.body = bodyStr
0000000000000000000000000000000000000000;;			bodyBytes := bytes.NewReader([]byte(bodyStr))
0000000000000000000000000000000000000000;;			req, err := http.NewRequest(r.verb, s.URL+r.URL, bodyBytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Logf("case %v", r)
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				resp, err := transport.RoundTrip(req)
0000000000000000000000000000000000000000;;				defer resp.Body.Close()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b, _ := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;				if _, ok := r.statusCodes[resp.StatusCode]; !ok {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Errorf("Expected status one of %v, but got %v", r.statusCodes, resp.StatusCode)
0000000000000000000000000000000000000000;;					t.Errorf("Body: %v", string(b))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if r.verb == "POST" {
0000000000000000000000000000000000000000;;						// For successful create operations, extract resourceVersion
0000000000000000000000000000000000000000;;						id, currentResourceVersion, err := parseResourceVersion(b)
0000000000000000000000000000000000000000;;						if err == nil {
0000000000000000000000000000000000000000;;							key := getPreviousResourceVersionKey(r.URL, id)
0000000000000000000000000000000000000000;;							previousResourceVersion[key] = currentResourceVersion
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestKindAuthorization tests that authorization can be controlled
0000000000000000000000000000000000000000;;	// by namespace.
0000000000000000000000000000000000000000;;	func TestKindAuthorization(t *testing.T) {
0000000000000000000000000000000000000000;;		// This file has alice and bob in it.
0000000000000000000000000000000000000000;;		a := newAuthorizerWithContents(t, `{"resource": "services"}
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up a master
0000000000000000000000000000000000000000;;		masterConfig := framework.NewIntegrationTestMasterConfig()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authenticator = getTestTokenAuth()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authorizer = a
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(masterConfig)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("auth-kind", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		previousResourceVersion := make(map[string]float64)
0000000000000000000000000000000000000000;;		transport := http.DefaultTransport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requests := []struct {
0000000000000000000000000000000000000000;;			verb        string
0000000000000000000000000000000000000000;;			URL         string
0000000000000000000000000000000000000000;;			body        string
0000000000000000000000000000000000000000;;			statusCodes map[int]bool // allowed status codes.
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"POST", timeoutPath("services", ns.Name, ""), aService, integration.Code201},
0000000000000000000000000000000000000000;;			{"GET", path("services", ns.Name, ""), "", integration.Code200},
0000000000000000000000000000000000000000;;			{"GET", path("services", ns.Name, "a"), "", integration.Code200},
0000000000000000000000000000000000000000;;			{"DELETE", timeoutPath("services", ns.Name, "a"), "", integration.Code200},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"POST", timeoutPath("pods", ns.Name, ""), aPod, integration.Code403},
0000000000000000000000000000000000000000;;			{"GET", path("pods", "", ""), "", integration.Code403},
0000000000000000000000000000000000000000;;			{"GET", path("pods", ns.Name, "a"), "", integration.Code403},
0000000000000000000000000000000000000000;;			{"DELETE", timeoutPath("pods", ns.Name, "a"), "", integration.Code403},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, r := range requests {
0000000000000000000000000000000000000000;;			token := BobToken
0000000000000000000000000000000000000000;;			var bodyStr string
0000000000000000000000000000000000000000;;			if r.body != "" {
0000000000000000000000000000000000000000;;				bodyStr = fmt.Sprintf(r.body, "")
0000000000000000000000000000000000000000;;				if r.verb == "PUT" && r.body != "" {
0000000000000000000000000000000000000000;;					// For update operations, insert previous resource version
0000000000000000000000000000000000000000;;					if resVersion := previousResourceVersion[getPreviousResourceVersionKey(r.URL, "")]; resVersion != 0 {
0000000000000000000000000000000000000000;;						resourceVersionJson := fmt.Sprintf(",\r\n\"resourceVersion\": \"%v\"", resVersion)
0000000000000000000000000000000000000000;;						bodyStr = fmt.Sprintf(r.body, resourceVersionJson)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.body = bodyStr
0000000000000000000000000000000000000000;;			bodyBytes := bytes.NewReader([]byte(bodyStr))
0000000000000000000000000000000000000000;;			req, err := http.NewRequest(r.verb, s.URL+r.URL, bodyBytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Logf("case %v", r)
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				resp, err := transport.RoundTrip(req)
0000000000000000000000000000000000000000;;				defer resp.Body.Close()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b, _ := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;				if _, ok := r.statusCodes[resp.StatusCode]; !ok {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Errorf("Expected status one of %v, but got %v", r.statusCodes, resp.StatusCode)
0000000000000000000000000000000000000000;;					t.Errorf("Body: %v", string(b))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if r.verb == "POST" {
0000000000000000000000000000000000000000;;						// For successful create operations, extract resourceVersion
0000000000000000000000000000000000000000;;						id, currentResourceVersion, err := parseResourceVersion(b)
0000000000000000000000000000000000000000;;						if err == nil {
0000000000000000000000000000000000000000;;							key := getPreviousResourceVersionKey(r.URL, id)
0000000000000000000000000000000000000000;;							previousResourceVersion[key] = currentResourceVersion
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestReadOnlyAuthorization tests that authorization can be controlled
0000000000000000000000000000000000000000;;	// by namespace.
0000000000000000000000000000000000000000;;	func TestReadOnlyAuthorization(t *testing.T) {
0000000000000000000000000000000000000000;;		// This file has alice and bob in it.
0000000000000000000000000000000000000000;;		a := newAuthorizerWithContents(t, `{"readonly": true}`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up a master
0000000000000000000000000000000000000000;;		masterConfig := framework.NewIntegrationTestMasterConfig()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authenticator = getTestTokenAuth()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authorizer = a
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(masterConfig)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("auth-read-only", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		transport := http.DefaultTransport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requests := []struct {
0000000000000000000000000000000000000000;;			verb        string
0000000000000000000000000000000000000000;;			URL         string
0000000000000000000000000000000000000000;;			body        string
0000000000000000000000000000000000000000;;			statusCodes map[int]bool // allowed status codes.
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"POST", path("pods", ns.Name, ""), aPod, integration.Code403},
0000000000000000000000000000000000000000;;			{"GET", path("pods", ns.Name, ""), "", integration.Code200},
0000000000000000000000000000000000000000;;			{"GET", path("pods", metav1.NamespaceDefault, "a"), "", integration.Code404},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, r := range requests {
0000000000000000000000000000000000000000;;			token := BobToken
0000000000000000000000000000000000000000;;			bodyBytes := bytes.NewReader([]byte(r.body))
0000000000000000000000000000000000000000;;			req, err := http.NewRequest(r.verb, s.URL+r.URL, bodyBytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				resp, err := transport.RoundTrip(req)
0000000000000000000000000000000000000000;;				defer resp.Body.Close()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, ok := r.statusCodes[resp.StatusCode]; !ok {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Errorf("Expected status one of %v, but got %v", r.statusCodes, resp.StatusCode)
0000000000000000000000000000000000000000;;					b, _ := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;					t.Errorf("Body: %v", string(b))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestWebhookTokenAuthenticator tests that a master can use the webhook token
0000000000000000000000000000000000000000;;	// authenticator to call out to a remote web server for authentication
0000000000000000000000000000000000000000;;	// decisions.
0000000000000000000000000000000000000000;;	func TestWebhookTokenAuthenticator(t *testing.T) {
0000000000000000000000000000000000000000;;		authServer := newTestWebhookTokenAuthServer()
0000000000000000000000000000000000000000;;		defer authServer.Close()
0000000000000000000000000000000000000000;;		authenticator, err := getTestWebhookTokenAuth(authServer.URL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error starting webhook token authenticator server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up a master
0000000000000000000000000000000000000000;;		masterConfig := framework.NewIntegrationTestMasterConfig()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authenticator = authenticator
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authorizer = allowAliceAuthorizer{}
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(masterConfig)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("auth-webhook-token", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		transport := http.DefaultTransport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, r := range getTestRequests(ns.Name) {
0000000000000000000000000000000000000000;;			// Expect Bob's requests to all fail.
0000000000000000000000000000000000000000;;			token := BobToken
0000000000000000000000000000000000000000;;			bodyBytes := bytes.NewReader([]byte(r.body))
0000000000000000000000000000000000000000;;			req, err := http.NewRequest(r.verb, s.URL+r.URL, bodyBytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				resp, err := transport.RoundTrip(req)
0000000000000000000000000000000000000000;;				defer resp.Body.Close()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Expect all of Bob's actions to return Forbidden
0000000000000000000000000000000000000000;;				if resp.StatusCode != http.StatusForbidden {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Errorf("Expected http.Forbidden, but got %s", resp.Status)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			// Expect Alice's requests to succeed.
0000000000000000000000000000000000000000;;			token = AliceToken
0000000000000000000000000000000000000000;;			bodyBytes = bytes.NewReader([]byte(r.body))
0000000000000000000000000000000000000000;;			req, err = http.NewRequest(r.verb, s.URL+r.URL, bodyBytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				resp, err := transport.RoundTrip(req)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer resp.Body.Close()
0000000000000000000000000000000000000000;;				// Expect all of Alice's actions to at least get past authn/authz.
0000000000000000000000000000000000000000;;				if resp.StatusCode == http.StatusUnauthorized || resp.StatusCode == http.StatusForbidden {
0000000000000000000000000000000000000000;;					t.Logf("case %v", r)
0000000000000000000000000000000000000000;;					t.Errorf("Expected something other than Unauthorized/Forbidden, but got %s", resp.Status)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newTestWebhookTokenAuthServer creates an http token authentication server
0000000000000000000000000000000000000000;;	// that knows about both Alice and Bob.
0000000000000000000000000000000000000000;;	func newTestWebhookTokenAuthServer() *httptest.Server {
0000000000000000000000000000000000000000;;		serveHTTP := func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			var review authenticationv1beta1.TokenReview
0000000000000000000000000000000000000000;;			if err := json.NewDecoder(r.Body).Decode(&review); err != nil {
0000000000000000000000000000000000000000;;				http.Error(w, fmt.Sprintf("failed to decode body: %v", err), http.StatusBadRequest)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			type userInfo struct {
0000000000000000000000000000000000000000;;				Username string   `json:"username"`
0000000000000000000000000000000000000000;;				UID      string   `json:"uid"`
0000000000000000000000000000000000000000;;				Groups   []string `json:"groups"`
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			type status struct {
0000000000000000000000000000000000000000;;				Authenticated bool     `json:"authenticated"`
0000000000000000000000000000000000000000;;				User          userInfo `json:"user"`
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var username, uid string
0000000000000000000000000000000000000000;;			authenticated := false
0000000000000000000000000000000000000000;;			if review.Spec.Token == AliceToken {
0000000000000000000000000000000000000000;;				authenticated, username, uid = true, "alice", "1"
0000000000000000000000000000000000000000;;			} else if review.Spec.Token == BobToken {
0000000000000000000000000000000000000000;;				authenticated, username, uid = true, "bob", "2"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resp := struct {
0000000000000000000000000000000000000000;;				APIVersion string `json:"apiVersion"`
0000000000000000000000000000000000000000;;				Status     status `json:"status"`
0000000000000000000000000000000000000000;;			}{
0000000000000000000000000000000000000000;;				APIVersion: authenticationv1beta1.SchemeGroupVersion.String(),
0000000000000000000000000000000000000000;;				Status: status{
0000000000000000000000000000000000000000;;					authenticated,
0000000000000000000000000000000000000000;;					userInfo{
0000000000000000000000000000000000000000;;						Username: username,
0000000000000000000000000000000000000000;;						UID:      uid,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;			json.NewEncoder(w).Encode(resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server := httptest.NewUnstartedServer(http.HandlerFunc(serveHTTP))
0000000000000000000000000000000000000000;;		server.Start()
0000000000000000000000000000000000000000;;		return server
0000000000000000000000000000000000000000;;	}
