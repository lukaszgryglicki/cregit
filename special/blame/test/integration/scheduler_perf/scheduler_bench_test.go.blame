0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
1643b37e8d8753761e7d0446ae4f768c9ae37417;test/component/scheduler/perf/scheduler_bench_test.go[test/component/scheduler/perf/scheduler_bench_test.go][test/integration/scheduler_perf/scheduler_bench_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package benchmark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration/framework"
0000000000000000000000000000000000000000;;		testutils "k8s.io/kubernetes/test/utils"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BenchmarkScheduling100Nodes0Pods benchmarks the scheduling rate
0000000000000000000000000000000000000000;;	// when the cluster has 100 nodes and 0 scheduled pods
0000000000000000000000000000000000000000;;	func BenchmarkScheduling100Nodes0Pods(b *testing.B) {
0000000000000000000000000000000000000000;;		benchmarkScheduling(100, 0, b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BenchmarkScheduling100Nodes1000Pods benchmarks the scheduling rate
0000000000000000000000000000000000000000;;	// when the cluster has 100 nodes and 1000 scheduled pods
0000000000000000000000000000000000000000;;	func BenchmarkScheduling100Nodes1000Pods(b *testing.B) {
0000000000000000000000000000000000000000;;		benchmarkScheduling(100, 1000, b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BenchmarkScheduling1000Nodes0Pods benchmarks the scheduling rate
0000000000000000000000000000000000000000;;	// when the cluster has 1000 nodes and 0 scheduled pods
0000000000000000000000000000000000000000;;	func BenchmarkScheduling1000Nodes0Pods(b *testing.B) {
0000000000000000000000000000000000000000;;		benchmarkScheduling(1000, 0, b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BenchmarkScheduling1000Nodes1000Pods benchmarks the scheduling rate
0000000000000000000000000000000000000000;;	// when the cluster has 1000 nodes and 1000 scheduled pods
0000000000000000000000000000000000000000;;	func BenchmarkScheduling1000Nodes1000Pods(b *testing.B) {
0000000000000000000000000000000000000000;;		benchmarkScheduling(1000, 1000, b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// benchmarkScheduling benchmarks scheduling rate with specific number of nodes
0000000000000000000000000000000000000000;;	// and specific number of pods already scheduled. Since an operation takes relatively
0000000000000000000000000000000000000000;;	// long time, b.N should be small: 10 - 100.
0000000000000000000000000000000000000000;;	func benchmarkScheduling(numNodes, numScheduledPods int, b *testing.B) {
0000000000000000000000000000000000000000;;		schedulerConfigFactory, finalFunc := mustSetupScheduler()
0000000000000000000000000000000000000000;;		defer finalFunc()
0000000000000000000000000000000000000000;;		c := schedulerConfigFactory.GetClient()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodePreparer := framework.NewIntegrationTestNodePreparer(
0000000000000000000000000000000000000000;;			c,
0000000000000000000000000000000000000000;;			[]testutils.CountToStrategy{{Count: numNodes, Strategy: &testutils.TrivialNodePrepareStrategy{}}},
0000000000000000000000000000000000000000;;			"scheduler-perf-",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err := nodePreparer.PrepareNodes(); err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer nodePreparer.CleanupNodes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := testutils.NewTestPodCreatorConfig()
0000000000000000000000000000000000000000;;		config.AddStrategy("sched-test", numScheduledPods, testutils.NewSimpleWithControllerCreatePodStrategy("rc1"))
0000000000000000000000000000000000000000;;		podCreator := testutils.NewTestPodCreator(c, config)
0000000000000000000000000000000000000000;;		podCreator.CreatePods()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			scheduled, err := schedulerConfigFactory.GetScheduledPodLister().List(labels.Everything())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Fatalf("%v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(scheduled) >= numScheduledPods {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			time.Sleep(1 * time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// start benchmark
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		config = testutils.NewTestPodCreatorConfig()
0000000000000000000000000000000000000000;;		config.AddStrategy("sched-test", b.N, testutils.NewSimpleWithControllerCreatePodStrategy("rc2"))
0000000000000000000000000000000000000000;;		podCreator = testutils.NewTestPodCreator(c, config)
0000000000000000000000000000000000000000;;		podCreator.CreatePods()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// This can potentially affect performance of scheduler, since List() is done under mutex.
0000000000000000000000000000000000000000;;			// TODO: Setup watch on apiserver and wait until all pods scheduled.
0000000000000000000000000000000000000000;;			scheduled, err := schedulerConfigFactory.GetScheduledPodLister().List(labels.Everything())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Fatalf("%v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(scheduled) >= numScheduledPods+b.N {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Note: This might introduce slight deviation in accuracy of benchmark results.
0000000000000000000000000000000000000000;;			// Since the total amount of time is relatively large, it might not be a concern.
0000000000000000000000000000000000000000;;			time.Sleep(100 * time.Millisecond)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
