0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
1643b37e8d8753761e7d0446ae4f768c9ae37417;test/component/scheduler/perf/util.go[test/component/scheduler/perf/util.go][test/integration/scheduler_perf/util.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package benchmark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1core "k8s.io/client-go/kubernetes/typed/core/v1"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/plugin/pkg/scheduler/algorithmprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/factory"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mustSetupScheduler starts the following components:
0000000000000000000000000000000000000000;;	// - k8s api server (a.k.a. master)
0000000000000000000000000000000000000000;;	// - scheduler
0000000000000000000000000000000000000000;;	// It returns scheduler config factory and destroyFunc which should be used to
0000000000000000000000000000000000000000;;	// remove resources after finished.
0000000000000000000000000000000000000000;;	// Notes on rate limiter:
0000000000000000000000000000000000000000;;	//   - client rate limit is set to 5000.
0000000000000000000000000000000000000000;;	func mustSetupScheduler() (schedulerConfigurator scheduler.Configurator, destroyFunc func()) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := &framework.MasterHolder{Initialized: make(chan struct{})}
0000000000000000000000000000000000000000;;		s := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			<-h.Initialized
0000000000000000000000000000000000000000;;			h.M.GenericAPIServer.Handler.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.RunAMasterUsingServer(framework.NewIntegrationTestMasterConfig(), s, h)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientSet := clientset.NewForConfigOrDie(&restclient.Config{
0000000000000000000000000000000000000000;;			Host:          s.URL,
0000000000000000000000000000000000000000;;			ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion},
0000000000000000000000000000000000000000;;			QPS:           5000.0,
0000000000000000000000000000000000000000;;			Burst:         5000,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(clientSet, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		schedulerConfigurator = factory.NewConfigFactory(
0000000000000000000000000000000000000000;;			v1.DefaultSchedulerName,
0000000000000000000000000000000000000000;;			clientSet,
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumeClaims(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().ReplicationControllers(),
0000000000000000000000000000000000000000;;			informerFactory.Extensions().V1beta1().ReplicaSets(),
0000000000000000000000000000000000000000;;			informerFactory.Apps().V1beta1().StatefulSets(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Services(),
0000000000000000000000000000000000000000;;			v1.DefaultHardPodAffinitySymmetricWeight,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		eventBroadcaster.StartRecordingToSink(&clientv1core.EventSinkImpl{Interface: clientv1core.New(clientSet.Core().RESTClient()).Events("")})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sched, err := scheduler.NewFromConfigurator(schedulerConfigurator, func(conf *scheduler.Config) {
0000000000000000000000000000000000000000;;			conf.Recorder = eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "scheduler"})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Error creating scheduler: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		informerFactory.Start(stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sched.Run()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		destroyFunc = func() {
0000000000000000000000000000000000000000;;			glog.Infof("destroying")
0000000000000000000000000000000000000000;;			sched.StopEverything()
0000000000000000000000000000000000000000;;			close(stop)
0000000000000000000000000000000000000000;;			s.Close()
0000000000000000000000000000000000000000;;			glog.Infof("destroyed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
