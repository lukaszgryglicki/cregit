0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f423d4aa3d3cbd9845f1d3c99865ffb90b90d5f9;test/integration/garbage_collector_test.go[test/integration/garbage_collector_test.go][test/integration/garbagecollector/garbage_collector_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package garbagecollector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/discovery"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/dynamic"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/garbagecollector"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/garbagecollector/metaonly"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getForegroundOptions() *metav1.DeleteOptions {
0000000000000000000000000000000000000000;;		policy := metav1.DeletePropagationForeground
0000000000000000000000000000000000000000;;		return &metav1.DeleteOptions{PropagationPolicy: &policy}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getOrphanOptions() *metav1.DeleteOptions {
0000000000000000000000000000000000000000;;		var trueVar = true
0000000000000000000000000000000000000000;;		return &metav1.DeleteOptions{OrphanDependents: &trueVar}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNonOrphanOptions() *metav1.DeleteOptions {
0000000000000000000000000000000000000000;;		var falseVar = false
0000000000000000000000000000000000000000;;		return &metav1.DeleteOptions{OrphanDependents: &falseVar}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const garbageCollectedPodName = "test.pod.1"
0000000000000000000000000000000000000000;;	const independentPodName = "test.pod.2"
0000000000000000000000000000000000000000;;	const oneValidOwnerPodName = "test.pod.3"
0000000000000000000000000000000000000000;;	const toBeDeletedRCName = "test.rc.1"
0000000000000000000000000000000000000000;;	const remainingRCName = "test.rc.2"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPod(podName, podNamespace string, ownerReferences []metav1.OwnerReference) *v1.Pod {
0000000000000000000000000000000000000000;;		for i := 0; i < len(ownerReferences); i++ {
0000000000000000000000000000000000000000;;			if len(ownerReferences[i].Kind) == 0 {
0000000000000000000000000000000000000000;;				ownerReferences[i].Kind = "ReplicationController"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ownerReferences[i].APIVersion = "v1"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            podName,
0000000000000000000000000000000000000000;;				Namespace:       podNamespace,
0000000000000000000000000000000000000000;;				OwnerReferences: ownerReferences,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "fake-name",
0000000000000000000000000000000000000000;;						Image: "fakeimage",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newOwnerRC(name, namespace string) *v1.ReplicationController {
0000000000000000000000000000000000000000;;		return &v1.ReplicationController{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "ReplicationController",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{"name": "test"},
0000000000000000000000000000000000000000;;				Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"name": "test"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "fake-name",
0000000000000000000000000000000000000000;;								Image: "fakeimage",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setup(t *testing.T, stop chan struct{}) (*httptest.Server, framework.CloseFunc, *garbagecollector.GarbageCollector, clientset.Interface) {
0000000000000000000000000000000000000000;;		masterConfig := framework.NewIntegrationTestMasterConfig()
0000000000000000000000000000000000000000;;		masterConfig.EnableCoreControllers = false
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(masterConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientSet, err := clientset.NewForConfig(&restclient.Config{Host: s.URL})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error in create clientset: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		preferredResources, err := clientSet.Discovery().ServerPreferredResources()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to get supported resources from server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deletableResources := discovery.FilteredBy(discovery.SupportsAllVerbs{Verbs: []string{"delete"}}, preferredResources)
0000000000000000000000000000000000000000;;		deletableGroupVersionResources, err := discovery.GroupVersionResources(deletableResources)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to parse supported resources from server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config := &restclient.Config{Host: s.URL}
0000000000000000000000000000000000000000;;		config.ContentConfig.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: metaonly.NewMetadataCodecFactory()}
0000000000000000000000000000000000000000;;		metaOnlyClientPool := dynamic.NewClientPool(config, api.Registry.RESTMapper(), dynamic.LegacyAPIPathResolverFunc)
0000000000000000000000000000000000000000;;		config.ContentConfig.NegotiatedSerializer = nil
0000000000000000000000000000000000000000;;		clientPool := dynamic.NewClientPool(config, api.Registry.RESTMapper(), dynamic.LegacyAPIPathResolverFunc)
0000000000000000000000000000000000000000;;		sharedInformers := informers.NewSharedInformerFactory(clientSet, 0)
0000000000000000000000000000000000000000;;		gc, err := garbagecollector.NewGarbageCollector(
0000000000000000000000000000000000000000;;			metaOnlyClientPool,
0000000000000000000000000000000000000000;;			clientPool,
0000000000000000000000000000000000000000;;			api.Registry.RESTMapper(),
0000000000000000000000000000000000000000;;			deletableGroupVersionResources,
0000000000000000000000000000000000000000;;			garbagecollector.DefaultIgnoredResources(),
0000000000000000000000000000000000000000;;			sharedInformers,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create garbage collector")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go sharedInformers.Start(stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s, closeFn, gc, clientSet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This test simulates the cascading deletion.
0000000000000000000000000000000000000000;;	func TestCascadingDeletion(t *testing.T) {
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(6).Infof("TestCascadingDeletion starts")
0000000000000000000000000000000000000000;;		defer glog.V(6).Infof("TestCascadingDeletion ends")
0000000000000000000000000000000000000000;;		s, closeFn, gc, clientSet := setup(t, stopCh)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			// We have to close the stop channel first, so the shared informers can terminate their watches;
0000000000000000000000000000000000000000;;			// otherwise closeFn() will hang waiting for active client connections to finish.
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;			closeFn()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("gc-cascading-deletion", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rcClient := clientSet.Core().ReplicationControllers(ns.Name)
0000000000000000000000000000000000000000;;		podClient := clientSet.Core().Pods(ns.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		toBeDeletedRC, err := rcClient.Create(newOwnerRC(toBeDeletedRCName, ns.Name))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create replication controller: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		remainingRC, err := rcClient.Create(newOwnerRC(remainingRCName, ns.Name))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create replication controller: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rcs, err := rcClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to list replication controllers: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rcs.Items) != 2 {
0000000000000000000000000000000000000000;;			t.Fatalf("Expect only 2 replication controller")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this pod should be cascadingly deleted.
0000000000000000000000000000000000000000;;		pod := newPod(garbageCollectedPodName, ns.Name, []metav1.OwnerReference{{UID: toBeDeletedRC.ObjectMeta.UID, Name: toBeDeletedRCName}})
0000000000000000000000000000000000000000;;		_, err = podClient.Create(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create Pod: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this pod shouldn't be cascadingly deleted, because it has a valid reference.
0000000000000000000000000000000000000000;;		pod = newPod(oneValidOwnerPodName, ns.Name, []metav1.OwnerReference{
0000000000000000000000000000000000000000;;			{UID: toBeDeletedRC.ObjectMeta.UID, Name: toBeDeletedRCName},
0000000000000000000000000000000000000000;;			{UID: remainingRC.ObjectMeta.UID, Name: remainingRCName},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		_, err = podClient.Create(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create Pod: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this pod shouldn't be cascadingly deleted, because it doesn't have an owner.
0000000000000000000000000000000000000000;;		pod = newPod(independentPodName, ns.Name, []metav1.OwnerReference{})
0000000000000000000000000000000000000000;;		_, err = podClient.Create(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create Pod: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set up watch
0000000000000000000000000000000000000000;;		pods, err := podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to list pods: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pods.Items) != 3 {
0000000000000000000000000000000000000000;;			t.Fatalf("Expect only 3 pods")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go gc.Run(5, stopCh)
0000000000000000000000000000000000000000;;		// delete one of the replication controller
0000000000000000000000000000000000000000;;		if err := rcClient.Delete(toBeDeletedRCName, getNonOrphanOptions()); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to delete replication controller: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// sometimes the deletion of the RC takes long time to be observed by
0000000000000000000000000000000000000000;;		// the gc, so wait for the garbage collector to observe the deletion of
0000000000000000000000000000000000000000;;		// the toBeDeletedRC
0000000000000000000000000000000000000000;;		if err := wait.Poll(10*time.Second, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			return !gc.GraphHasUID([]types.UID{toBeDeletedRC.ObjectMeta.UID}), nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := integration.WaitForPodToDisappear(podClient, garbageCollectedPodName, 5*time.Second, 30*time.Second); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expect pod %s to be garbage collected, got err= %v", garbageCollectedPodName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// checks the garbage collect doesn't delete pods it shouldn't delete.
0000000000000000000000000000000000000000;;		if _, err := podClient.Get(independentPodName, metav1.GetOptions{}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := podClient.Get(oneValidOwnerPodName, metav1.GetOptions{}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This test simulates the case where an object is created with an owner that
0000000000000000000000000000000000000000;;	// doesn't exist. It verifies the GC will delete such an object.
0000000000000000000000000000000000000000;;	func TestCreateWithNonExistentOwner(t *testing.T) {
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		s, closeFn, gc, clientSet := setup(t, stopCh)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			// We have to close the stop channel first, so the shared informers can terminate their watches;
0000000000000000000000000000000000000000;;			// otherwise closeFn() will hang waiting for active client connections to finish.
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;			closeFn()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("gc-non-existing-owner", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podClient := clientSet.Core().Pods(ns.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := newPod(garbageCollectedPodName, ns.Name, []metav1.OwnerReference{{UID: "doesn't matter", Name: toBeDeletedRCName}})
0000000000000000000000000000000000000000;;		_, err := podClient.Create(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create Pod: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set up watch
0000000000000000000000000000000000000000;;		pods, err := podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to list pods: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pods.Items) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("Expect only 1 pod")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go gc.Run(5, stopCh)
0000000000000000000000000000000000000000;;		// wait for the garbage collector to delete the pod
0000000000000000000000000000000000000000;;		if err := integration.WaitForPodToDisappear(podClient, garbageCollectedPodName, 5*time.Second, 30*time.Second); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expect pod %s to be garbage collected, got err= %v", garbageCollectedPodName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setupRCsPods(t *testing.T, gc *garbagecollector.GarbageCollector, clientSet clientset.Interface, nameSuffix, namespace string, initialFinalizers []string, options *metav1.DeleteOptions, wg *sync.WaitGroup, rcUIDs chan types.UID) {
0000000000000000000000000000000000000000;;		defer wg.Done()
0000000000000000000000000000000000000000;;		rcClient := clientSet.Core().ReplicationControllers(namespace)
0000000000000000000000000000000000000000;;		podClient := clientSet.Core().Pods(namespace)
0000000000000000000000000000000000000000;;		// create rc.
0000000000000000000000000000000000000000;;		rcName := "test.rc." + nameSuffix
0000000000000000000000000000000000000000;;		rc := newOwnerRC(rcName, namespace)
0000000000000000000000000000000000000000;;		rc.ObjectMeta.Finalizers = initialFinalizers
0000000000000000000000000000000000000000;;		rc, err := rcClient.Create(rc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create replication controller: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rcUIDs <- rc.ObjectMeta.UID
0000000000000000000000000000000000000000;;		// create pods.
0000000000000000000000000000000000000000;;		var podUIDs []types.UID
0000000000000000000000000000000000000000;;		for j := 0; j < 3; j++ {
0000000000000000000000000000000000000000;;			podName := "test.pod." + nameSuffix + "-" + strconv.Itoa(j)
0000000000000000000000000000000000000000;;			pod := newPod(podName, namespace, []metav1.OwnerReference{{UID: rc.ObjectMeta.UID, Name: rc.ObjectMeta.Name}})
0000000000000000000000000000000000000000;;			_, err = podClient.Create(pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed to create Pod: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podUIDs = append(podUIDs, pod.ObjectMeta.UID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		orphan := (options != nil && options.OrphanDependents != nil && *options.OrphanDependents) || (options == nil && len(initialFinalizers) != 0 && initialFinalizers[0] == metav1.FinalizerOrphanDependents)
0000000000000000000000000000000000000000;;		// if we intend to orphan the pods, we need wait for the gc to observe the
0000000000000000000000000000000000000000;;		// creation of the pods, otherwise if the deletion of RC is observed before
0000000000000000000000000000000000000000;;		// the creation of the pods, the pods will not be orphaned.
0000000000000000000000000000000000000000;;		if orphan {
0000000000000000000000000000000000000000;;			wait.Poll(5*time.Second, 60*time.Second, func() (bool, error) { return gc.GraphHasUID(podUIDs), nil })
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// delete the rc
0000000000000000000000000000000000000000;;		if err := rcClient.Delete(rc.ObjectMeta.Name, options); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to delete replication controller: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyRemainingObjects(t *testing.T, clientSet clientset.Interface, namespace string, rcNum, podNum int) (bool, error) {
0000000000000000000000000000000000000000;;		rcClient := clientSet.Core().ReplicationControllers(namespace)
0000000000000000000000000000000000000000;;		podClient := clientSet.Core().Pods(namespace)
0000000000000000000000000000000000000000;;		pods, err := podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Failed to list pods: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var ret = true
0000000000000000000000000000000000000000;;		if len(pods.Items) != podNum {
0000000000000000000000000000000000000000;;			ret = false
0000000000000000000000000000000000000000;;			t.Logf("expect %d pods, got %d pods", podNum, len(pods.Items))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rcs, err := rcClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Failed to list replication controllers: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rcs.Items) != rcNum {
0000000000000000000000000000000000000000;;			ret = false
0000000000000000000000000000000000000000;;			t.Logf("expect %d RCs, got %d RCs", rcNum, len(rcs.Items))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The stress test is not very stressful, because we need to control the running
0000000000000000000000000000000000000000;;	// time of our pre-submit tests to increase submit-queue throughput. We'll add
0000000000000000000000000000000000000000;;	// e2e tests that put more stress.
0000000000000000000000000000000000000000;;	func TestStressingCascadingDeletion(t *testing.T) {
0000000000000000000000000000000000000000;;		t.Logf("starts garbage collector stress test")
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		s, closeFn, gc, clientSet := setup(t, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			// We have to close the stop channel first, so the shared informers can terminate their watches;
0000000000000000000000000000000000000000;;			// otherwise closeFn() will hang waiting for active client connections to finish.
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;			closeFn()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("gc-stressing-cascading-deletion", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go gc.Run(5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const collections = 10
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		wg.Add(collections * 4)
0000000000000000000000000000000000000000;;		rcUIDs := make(chan types.UID, collections*4)
0000000000000000000000000000000000000000;;		for i := 0; i < collections; i++ {
0000000000000000000000000000000000000000;;			// rc is created with empty finalizers, deleted with nil delete options, pods will remain.
0000000000000000000000000000000000000000;;			go setupRCsPods(t, gc, clientSet, "collection1-"+strconv.Itoa(i), ns.Name, []string{}, nil, &wg, rcUIDs)
0000000000000000000000000000000000000000;;			// rc is created with the orphan finalizer, deleted with nil options, pods will remain.
0000000000000000000000000000000000000000;;			go setupRCsPods(t, gc, clientSet, "collection2-"+strconv.Itoa(i), ns.Name, []string{metav1.FinalizerOrphanDependents}, nil, &wg, rcUIDs)
0000000000000000000000000000000000000000;;			// rc is created with the orphan finalizer, deleted with DeleteOptions.OrphanDependents=false, pods will be deleted.
0000000000000000000000000000000000000000;;			go setupRCsPods(t, gc, clientSet, "collection3-"+strconv.Itoa(i), ns.Name, []string{metav1.FinalizerOrphanDependents}, getNonOrphanOptions(), &wg, rcUIDs)
0000000000000000000000000000000000000000;;			// rc is created with empty finalizers, deleted with DeleteOptions.OrphanDependents=true, pods will remain.
0000000000000000000000000000000000000000;;			go setupRCsPods(t, gc, clientSet, "collection4-"+strconv.Itoa(i), ns.Name, []string{}, getOrphanOptions(), &wg, rcUIDs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		t.Logf("all pods are created, all replications controllers are created then deleted")
0000000000000000000000000000000000000000;;		// wait for the RCs and Pods to reach the expected numbers.
0000000000000000000000000000000000000000;;		if err := wait.Poll(5*time.Second, 300*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			podsInEachCollection := 3
0000000000000000000000000000000000000000;;			// see the comments on the calls to setupRCsPods for details
0000000000000000000000000000000000000000;;			remainingGroups := 3
0000000000000000000000000000000000000000;;			return verifyRemainingObjects(t, clientSet, ns.Name, 0, collections*podsInEachCollection*remainingGroups)
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Logf("number of remaining replication controllers and pods are as expected")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify the remaining pods all have "orphan" in their names.
0000000000000000000000000000000000000000;;		podClient := clientSet.Core().Pods(ns.Name)
0000000000000000000000000000000000000000;;		pods, err := podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;			if !strings.Contains(pod.ObjectMeta.Name, "collection1-") && !strings.Contains(pod.ObjectMeta.Name, "collection2-") && !strings.Contains(pod.ObjectMeta.Name, "collection4-") {
0000000000000000000000000000000000000000;;				t.Errorf("got unexpected remaining pod: %#v", pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify there is no node representing replication controllers in the gc's graph
0000000000000000000000000000000000000000;;		uids := make([]types.UID, 0, collections)
0000000000000000000000000000000000000000;;		for i := 0; i < collections; i++ {
0000000000000000000000000000000000000000;;			uid := <-rcUIDs
0000000000000000000000000000000000000000;;			uids = append(uids, uid)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if gc.GraphHasUID(uids) {
0000000000000000000000000000000000000000;;			t.Errorf("Expect all nodes representing replication controllers are removed from the Propagator's graph")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOrphaning(t *testing.T) {
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		s, closeFn, gc, clientSet := setup(t, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			// We have to close the stop channel first, so the shared informers can terminate their watches;
0000000000000000000000000000000000000000;;			// otherwise closeFn() will hang waiting for active client connections to finish.
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;			closeFn()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("gc-orphaning", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podClient := clientSet.Core().Pods(ns.Name)
0000000000000000000000000000000000000000;;		rcClient := clientSet.Core().ReplicationControllers(ns.Name)
0000000000000000000000000000000000000000;;		// create the RC with the orphan finalizer set
0000000000000000000000000000000000000000;;		toBeDeletedRC := newOwnerRC(toBeDeletedRCName, ns.Name)
0000000000000000000000000000000000000000;;		toBeDeletedRC, err := rcClient.Create(toBeDeletedRC)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create replication controller: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// these pods should be orphaned.
0000000000000000000000000000000000000000;;		var podUIDs []types.UID
0000000000000000000000000000000000000000;;		podsNum := 3
0000000000000000000000000000000000000000;;		for i := 0; i < podsNum; i++ {
0000000000000000000000000000000000000000;;			podName := garbageCollectedPodName + strconv.Itoa(i)
0000000000000000000000000000000000000000;;			pod := newPod(podName, ns.Name, []metav1.OwnerReference{{UID: toBeDeletedRC.ObjectMeta.UID, Name: toBeDeletedRCName}})
0000000000000000000000000000000000000000;;			_, err = podClient.Create(pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed to create Pod: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podUIDs = append(podUIDs, pod.ObjectMeta.UID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go gc.Run(5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we need wait for the gc to observe the creation of the pods, otherwise if
0000000000000000000000000000000000000000;;		// the deletion of RC is observed before the creation of the pods, the pods
0000000000000000000000000000000000000000;;		// will not be orphaned.
0000000000000000000000000000000000000000;;		wait.Poll(5*time.Second, 60*time.Second, func() (bool, error) { return gc.GraphHasUID(podUIDs), nil })
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = rcClient.Delete(toBeDeletedRCName, getOrphanOptions())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to gracefully delete the rc: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// verify the toBeDeleteRC is deleted
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(5*time.Second, 30*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			rcs, err := rcClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(rcs.Items) == 0 {
0000000000000000000000000000000000000000;;				t.Logf("Still has %d RCs", len(rcs.Items))
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify pods don't have the ownerPod as an owner anymore
0000000000000000000000000000000000000000;;		pods, err := podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to list pods: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pods.Items) != podsNum {
0000000000000000000000000000000000000000;;			t.Errorf("Expect %d pod(s), but got %#v", podsNum, pods)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;			if len(pod.ObjectMeta.OwnerReferences) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("pod %s still has non-empty OwnerReferences: %v", pod.ObjectMeta.Name, pod.ObjectMeta.OwnerReferences)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSolidOwnerDoesNotBlockWaitingOwner(t *testing.T) {
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		s, closeFn, gc, clientSet := setup(t, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			// We have to close the stop channel first, so the shared informers can terminate their watches;
0000000000000000000000000000000000000000;;			// otherwise closeFn() will hang waiting for active client connections to finish.
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;			closeFn()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("gc-foreground1", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podClient := clientSet.Core().Pods(ns.Name)
0000000000000000000000000000000000000000;;		rcClient := clientSet.Core().ReplicationControllers(ns.Name)
0000000000000000000000000000000000000000;;		// create the RC with the orphan finalizer set
0000000000000000000000000000000000000000;;		toBeDeletedRC, err := rcClient.Create(newOwnerRC(toBeDeletedRCName, ns.Name))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create replication controller: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		remainingRC, err := rcClient.Create(newOwnerRC(remainingRCName, ns.Name))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create replication controller: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		trueVar := true
0000000000000000000000000000000000000000;;		pod := newPod("pod", ns.Name, []metav1.OwnerReference{
0000000000000000000000000000000000000000;;			{UID: toBeDeletedRC.ObjectMeta.UID, Name: toBeDeletedRC.Name, BlockOwnerDeletion: &trueVar},
0000000000000000000000000000000000000000;;			{UID: remainingRC.ObjectMeta.UID, Name: remainingRC.Name},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		_, err = podClient.Create(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create Pod: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go gc.Run(5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = rcClient.Delete(toBeDeletedRCName, getForegroundOptions())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to delete the rc: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// verify the toBeDeleteRC is deleted
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(5*time.Second, 30*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			_, err := rcClient.Get(toBeDeletedRC.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify pods don't have the toBeDeleteRC as an owner anymore
0000000000000000000000000000000000000000;;		pod, err = podClient.Get("pod", metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to list pods: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pod.ObjectMeta.OwnerReferences) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expect pod to have only one ownerReference: got %#v", pod.ObjectMeta.OwnerReferences)
0000000000000000000000000000000000000000;;		} else if pod.ObjectMeta.OwnerReferences[0].Name != remainingRC.Name {
0000000000000000000000000000000000000000;;			t.Errorf("expect pod to have an ownerReference pointing to %s, got %#v", remainingRC.Name, pod.ObjectMeta.OwnerReferences)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNonBlockingOwnerRefDoesNotBlock(t *testing.T) {
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		s, closeFn, gc, clientSet := setup(t, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			// We have to close the stop channel first, so the shared informers can terminate their watches;
0000000000000000000000000000000000000000;;			// otherwise closeFn() will hang waiting for active client connections to finish.
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;			closeFn()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("gc-foreground2", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podClient := clientSet.Core().Pods(ns.Name)
0000000000000000000000000000000000000000;;		rcClient := clientSet.Core().ReplicationControllers(ns.Name)
0000000000000000000000000000000000000000;;		// create the RC with the orphan finalizer set
0000000000000000000000000000000000000000;;		toBeDeletedRC, err := rcClient.Create(newOwnerRC(toBeDeletedRCName, ns.Name))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create replication controller: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// BlockingOwnerDeletion is not set
0000000000000000000000000000000000000000;;		pod1 := newPod("pod1", ns.Name, []metav1.OwnerReference{
0000000000000000000000000000000000000000;;			{UID: toBeDeletedRC.ObjectMeta.UID, Name: toBeDeletedRC.Name},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		// adding finalizer that no controller handles, so that the pod won't be deleted
0000000000000000000000000000000000000000;;		pod1.ObjectMeta.Finalizers = []string{"x/y"}
0000000000000000000000000000000000000000;;		// BlockingOwnerDeletion is false
0000000000000000000000000000000000000000;;		falseVar := false
0000000000000000000000000000000000000000;;		pod2 := newPod("pod2", ns.Name, []metav1.OwnerReference{
0000000000000000000000000000000000000000;;			{UID: toBeDeletedRC.ObjectMeta.UID, Name: toBeDeletedRC.Name, BlockOwnerDeletion: &falseVar},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		// adding finalizer that no controller handles, so that the pod won't be deleted
0000000000000000000000000000000000000000;;		pod2.ObjectMeta.Finalizers = []string{"x/y"}
0000000000000000000000000000000000000000;;		_, err = podClient.Create(pod1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create Pod: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = podClient.Create(pod2)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create Pod: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go gc.Run(5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = rcClient.Delete(toBeDeletedRCName, getForegroundOptions())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to delete the rc: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// verify the toBeDeleteRC is deleted
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(5*time.Second, 30*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			_, err := rcClient.Get(toBeDeletedRC.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify pods are still there
0000000000000000000000000000000000000000;;		pods, err := podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to list pods: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pods.Items) != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("expect there to be 2 pods, got %#v", pods.Items)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBlockingOwnerRefDoesBlock(t *testing.T) {
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		s, closeFn, gc, clientSet := setup(t, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			// We have to close the stop channel first, so the shared informers can terminate their watches;
0000000000000000000000000000000000000000;;			// otherwise closeFn() will hang waiting for active client connections to finish.
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;			closeFn()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("gc-foreground3", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podClient := clientSet.Core().Pods(ns.Name)
0000000000000000000000000000000000000000;;		rcClient := clientSet.Core().ReplicationControllers(ns.Name)
0000000000000000000000000000000000000000;;		// create the RC with the orphan finalizer set
0000000000000000000000000000000000000000;;		toBeDeletedRC, err := rcClient.Create(newOwnerRC(toBeDeletedRCName, ns.Name))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create replication controller: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		trueVar := true
0000000000000000000000000000000000000000;;		pod := newPod("pod", ns.Name, []metav1.OwnerReference{
0000000000000000000000000000000000000000;;			{UID: toBeDeletedRC.ObjectMeta.UID, Name: toBeDeletedRC.Name, BlockOwnerDeletion: &trueVar},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		// adding finalizer that no controller handles, so that the pod won't be deleted
0000000000000000000000000000000000000000;;		pod.ObjectMeta.Finalizers = []string{"x/y"}
0000000000000000000000000000000000000000;;		_, err = podClient.Create(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create Pod: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go gc.Run(5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this makes sure the garbage collector will have added the pod to its
0000000000000000000000000000000000000000;;		// dependency graph before handling the foreground deletion of the rc.
0000000000000000000000000000000000000000;;		timeout := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-time.After(5 * time.Second):
0000000000000000000000000000000000000000;;				close(timeout)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if !cache.WaitForCacheSync(timeout, gc.HasSynced) {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to wait for garbage collector to be synced")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = rcClient.Delete(toBeDeletedRCName, getForegroundOptions())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to delete the rc: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		time.Sleep(30 * time.Second)
0000000000000000000000000000000000000000;;		// verify the toBeDeleteRC is NOT deleted
0000000000000000000000000000000000000000;;		_, err = rcClient.Get(toBeDeletedRC.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify pods are still there
0000000000000000000000000000000000000000;;		pods, err := podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to list pods: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pods.Items) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expect there to be 1 pods, got %#v", pods.Items)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
