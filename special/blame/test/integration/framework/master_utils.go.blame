0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
504af5c458a768632e4c3354ff785d8ea8ef20ac;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		goruntime "runtime"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		"github.com/pborman/uuid"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		apps "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		autoscaling "k8s.io/api/autoscaling/v1"
0000000000000000000000000000000000000000;;		certificates "k8s.io/api/certificates/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		rbac "k8s.io/api/rbac/v1alpha1"
0000000000000000000000000000000000000000;;		storage "k8s.io/api/storage/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		authauthenticator "k8s.io/apiserver/pkg/authentication/authenticator"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/authenticatorfactory"
0000000000000000000000000000000000000000;;		authenticatorunion "k8s.io/apiserver/pkg/authentication/request/union"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		authauthorizer "k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizerfactory"
0000000000000000000000000000000000000000;;		authorizerunion "k8s.io/apiserver/pkg/authorization/union"
0000000000000000000000000000000000000000;;		genericapiserver "k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/options"
0000000000000000000000000000000000000000;;		serverstorage "k8s.io/apiserver/pkg/server/storage"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/storagebackend"
0000000000000000000000000000000000000000;;		extinformers "k8s.io/client-go/informers"
0000000000000000000000000000000000000000;;		extclient "k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/batch"
0000000000000000000000000000000000000000;;		policy "k8s.io/kubernetes/pkg/apis/policy/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		replicationcontroller "k8s.io/kubernetes/pkg/controller/replication"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/generated/openapi"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		kubeletclient "k8s.io/kubernetes/pkg/kubelet/client"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/master"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/env"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/version"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/admission/admit"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Timeout used in benchmarks, to eg: scale an rc
0000000000000000000000000000000000000000;;		DefaultTimeout = 30 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rc manifest used to create pods for benchmarks.
0000000000000000000000000000000000000000;;		// TODO: Convert this to a full path?
0000000000000000000000000000000000000000;;		TestRCManifest = "benchmark-controller.json"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MasterComponents is a control struct for all master components started via NewMasterComponents.
0000000000000000000000000000000000000000;;	// TODO: Include all master components (scheduler, nodecontroller).
0000000000000000000000000000000000000000;;	// TODO: Reconcile with integration.go, currently the master used there doesn't understand
0000000000000000000000000000000000000000;;	// how to restart cleanly, which is required for each iteration of a benchmark. The integration
0000000000000000000000000000000000000000;;	// tests also don't make it easy to isolate and turn off components at will.
0000000000000000000000000000000000000000;;	type MasterComponents struct {
0000000000000000000000000000000000000000;;		// Raw http server in front of the master
0000000000000000000000000000000000000000;;		ApiServer *httptest.Server
0000000000000000000000000000000000000000;;		// Kubernetes master, contains an embedded etcd storage
0000000000000000000000000000000000000000;;		KubeMaster *master.Master
0000000000000000000000000000000000000000;;		// Restclient used to talk to the kubernetes master
0000000000000000000000000000000000000000;;		ClientSet clientset.Interface
0000000000000000000000000000000000000000;;		// Replication controller manager
0000000000000000000000000000000000000000;;		ControllerManager *replicationcontroller.ReplicationManager
0000000000000000000000000000000000000000;;		// CloseFn shuts down the server
0000000000000000000000000000000000000000;;		CloseFn CloseFunc
0000000000000000000000000000000000000000;;		// Channel for stop signals to rc manager
0000000000000000000000000000000000000000;;		rcStopCh chan struct{}
0000000000000000000000000000000000000000;;		// Used to stop master components individually, and via MasterComponents.Stop
0000000000000000000000000000000000000000;;		once sync.Once
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config is a struct of configuration directives for NewMasterComponents.
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		// If nil, a default is used, partially filled configs will not get populated.
0000000000000000000000000000000000000000;;		MasterConfig            *master.Config
0000000000000000000000000000000000000000;;		StartReplicationManager bool
0000000000000000000000000000000000000000;;		// Client throttling qps
0000000000000000000000000000000000000000;;		QPS float32
0000000000000000000000000000000000000000;;		// Client burst qps, also burst replicas allowed in rc manager
0000000000000000000000000000000000000000;;		Burst int
0000000000000000000000000000000000000000;;		// TODO: Add configs for endpoints controller, scheduler etc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewMasterComponents creates, initializes and starts master components based on the given config.
0000000000000000000000000000000000000000;;	func NewMasterComponents(c *Config) *MasterComponents {
0000000000000000000000000000000000000000;;		m, s, closeFn := startMasterOrDie(c.MasterConfig, nil, nil)
0000000000000000000000000000000000000000;;		// TODO: Allow callers to pipe through a different master url and create a client/start components using it.
0000000000000000000000000000000000000000;;		glog.Infof("Master %+v", s.URL)
0000000000000000000000000000000000000000;;		// TODO: caesarxuchao: remove this client when the refactoring of client libraray is done.
0000000000000000000000000000000000000000;;		clientset := clientset.NewForConfigOrDie(&restclient.Config{Host: s.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}, QPS: c.QPS, Burst: c.Burst})
0000000000000000000000000000000000000000;;		rcStopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(clientset, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		controllerManager := replicationcontroller.NewReplicationManager(informerFactory.Core().V1().Pods(), informerFactory.Core().V1().ReplicationControllers(), clientset, c.Burst)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Support events once we can cleanly shutdown an event recorder.
0000000000000000000000000000000000000000;;		controllerManager.SetEventRecorder(&record.FakeRecorder{})
0000000000000000000000000000000000000000;;		if c.StartReplicationManager {
0000000000000000000000000000000000000000;;			informerFactory.Start(rcStopCh)
0000000000000000000000000000000000000000;;			go controllerManager.Run(goruntime.NumCPU(), rcStopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &MasterComponents{
0000000000000000000000000000000000000000;;			ApiServer:         s,
0000000000000000000000000000000000000000;;			KubeMaster:        m,
0000000000000000000000000000000000000000;;			ClientSet:         clientset,
0000000000000000000000000000000000000000;;			ControllerManager: controllerManager,
0000000000000000000000000000000000000000;;			CloseFn:           closeFn,
0000000000000000000000000000000000000000;;			rcStopCh:          rcStopCh,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// alwaysAllow always allows an action
0000000000000000000000000000000000000000;;	type alwaysAllow struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (alwaysAllow) Authorize(requestAttributes authauthorizer.Attributes) (bool, string, error) {
0000000000000000000000000000000000000000;;		return true, "always allow", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// alwaysEmpty simulates "no authentication" for old tests
0000000000000000000000000000000000000000;;	func alwaysEmpty(req *http.Request) (user.Info, bool, error) {
0000000000000000000000000000000000000000;;		return &user.DefaultInfo{
0000000000000000000000000000000000000000;;			Name: "",
0000000000000000000000000000000000000000;;		}, true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MasterReceiver can be used to provide the master to a custom incoming server function
0000000000000000000000000000000000000000;;	type MasterReceiver interface {
0000000000000000000000000000000000000000;;		SetMaster(m *master.Master)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MasterHolder implements
0000000000000000000000000000000000000000;;	type MasterHolder struct {
0000000000000000000000000000000000000000;;		Initialized chan struct{}
0000000000000000000000000000000000000000;;		M           *master.Master
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *MasterHolder) SetMaster(m *master.Master) {
0000000000000000000000000000000000000000;;		h.M = m
0000000000000000000000000000000000000000;;		close(h.Initialized)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// startMasterOrDie starts a kubernetes master and an httpserver to handle api requests
0000000000000000000000000000000000000000;;	func startMasterOrDie(masterConfig *master.Config, incomingServer *httptest.Server, masterReceiver MasterReceiver) (*master.Master, *httptest.Server, CloseFunc) {
0000000000000000000000000000000000000000;;		var m *master.Master
0000000000000000000000000000000000000000;;		var s *httptest.Server
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if incomingServer != nil {
0000000000000000000000000000000000000000;;			s = incomingServer
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;				m.GenericAPIServer.Handler.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		closeFn := func() {
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;			s.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if masterConfig == nil {
0000000000000000000000000000000000000000;;			masterConfig = NewMasterConfig()
0000000000000000000000000000000000000000;;			masterConfig.GenericConfig.EnableProfiling = true
0000000000000000000000000000000000000000;;			masterConfig.GenericConfig.EnableMetrics = true
0000000000000000000000000000000000000000;;			masterConfig.GenericConfig.OpenAPIConfig = genericapiserver.DefaultOpenAPIConfig(openapi.GetOpenAPIDefinitions, api.Scheme)
0000000000000000000000000000000000000000;;			masterConfig.GenericConfig.OpenAPIConfig.Info = &spec.Info{
0000000000000000000000000000000000000000;;				InfoProps: spec.InfoProps{
0000000000000000000000000000000000000000;;					Title:   "Kubernetes",
0000000000000000000000000000000000000000;;					Version: "unversioned",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			masterConfig.GenericConfig.OpenAPIConfig.DefaultResponse = &spec.Response{
0000000000000000000000000000000000000000;;				ResponseProps: spec.ResponseProps{
0000000000000000000000000000000000000000;;					Description: "Default Response.",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			masterConfig.GenericConfig.OpenAPIConfig.GetDefinitions = openapi.GetOpenAPIDefinitions
0000000000000000000000000000000000000000;;			masterConfig.GenericConfig.SwaggerConfig = genericapiserver.DefaultSwaggerConfig()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set the loopback client config
0000000000000000000000000000000000000000;;		if masterConfig.GenericConfig.LoopbackClientConfig == nil {
0000000000000000000000000000000000000000;;			masterConfig.GenericConfig.LoopbackClientConfig = &restclient.Config{QPS: 50, Burst: 100, ContentConfig: restclient.ContentConfig{NegotiatedSerializer: api.Codecs}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.LoopbackClientConfig.Host = s.URL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		privilegedLoopbackToken := uuid.NewRandom().String()
0000000000000000000000000000000000000000;;		// wrap any available authorizer
0000000000000000000000000000000000000000;;		tokens := make(map[string]*user.DefaultInfo)
0000000000000000000000000000000000000000;;		tokens[privilegedLoopbackToken] = &user.DefaultInfo{
0000000000000000000000000000000000000000;;			Name:   user.APIServerUser,
0000000000000000000000000000000000000000;;			UID:    uuid.NewRandom().String(),
0000000000000000000000000000000000000000;;			Groups: []string{user.SystemPrivilegedGroup},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokenAuthenticator := authenticatorfactory.NewFromTokens(tokens)
0000000000000000000000000000000000000000;;		if masterConfig.GenericConfig.Authenticator == nil {
0000000000000000000000000000000000000000;;			masterConfig.GenericConfig.Authenticator = authenticatorunion.New(tokenAuthenticator, authauthenticator.RequestFunc(alwaysEmpty))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			masterConfig.GenericConfig.Authenticator = authenticatorunion.New(tokenAuthenticator, masterConfig.GenericConfig.Authenticator)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if masterConfig.GenericConfig.Authorizer != nil {
0000000000000000000000000000000000000000;;			tokenAuthorizer := authorizerfactory.NewPrivilegedGroups(user.SystemPrivilegedGroup)
0000000000000000000000000000000000000000;;			masterConfig.GenericConfig.Authorizer = authorizerunion.New(tokenAuthorizer, masterConfig.GenericConfig.Authorizer)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			masterConfig.GenericConfig.Authorizer = alwaysAllow{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.LoopbackClientConfig.BearerToken = privilegedLoopbackToken
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientset, err := extclient.NewForConfig(masterConfig.GenericConfig.LoopbackClientConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.SharedInformerFactory = extinformers.NewSharedInformerFactory(clientset, masterConfig.GenericConfig.LoopbackClientConfig.Timeout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m, err = masterConfig.Complete().New(genericapiserver.EmptyDelegate)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			closeFn()
0000000000000000000000000000000000000000;;			glog.Fatalf("error in bringing up the master: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if masterReceiver != nil {
0000000000000000000000000000000000000000;;			masterReceiver.SetMaster(m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO have this start method actually use the normal start sequence for the API server
0000000000000000000000000000000000000000;;		// this method never actually calls the `Run` method for the API server
0000000000000000000000000000000000000000;;		// fire the post hooks ourselves
0000000000000000000000000000000000000000;;		m.GenericAPIServer.PrepareRun()
0000000000000000000000000000000000000000;;		m.GenericAPIServer.RunPostStartHooks(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg := *masterConfig.GenericConfig.LoopbackClientConfig
0000000000000000000000000000000000000000;;		cfg.ContentConfig.GroupVersion = &schema.GroupVersion{}
0000000000000000000000000000000000000000;;		privilegedClient, err := restclient.RESTClientFor(&cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			closeFn()
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(100*time.Millisecond, 30*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			result := privilegedClient.Get().AbsPath("/healthz").Do()
0000000000000000000000000000000000000000;;			status := 0
0000000000000000000000000000000000000000;;			result.StatusCode(&status)
0000000000000000000000000000000000000000;;			if status == 200 {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			closeFn()
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return m, s, closeFn
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseCIDROrDie(cidr string) *net.IPNet {
0000000000000000000000000000000000000000;;		_, parsed, err := net.ParseCIDR(cidr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("error while parsing CIDR: %s", cidr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parsed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// return the EtcdURL
0000000000000000000000000000000000000000;;	func GetEtcdURLFromEnv() string {
0000000000000000000000000000000000000000;;		url := env.GetEnvAsStringOrFallback("KUBE_INTEGRATION_ETCD_URL", "http://127.0.0.1:2379")
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Using KUBE_INTEGRATION_ETCD_URL=%q", url)
0000000000000000000000000000000000000000;;		return url
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a basic master config.
0000000000000000000000000000000000000000;;	func NewMasterConfig() *master.Config {
0000000000000000000000000000000000000000;;		// This causes the integration tests to exercise the etcd
0000000000000000000000000000000000000000;;		// prefix code, so please don't change without ensuring
0000000000000000000000000000000000000000;;		// sufficient coverage in other ways.
0000000000000000000000000000000000000000;;		etcdOptions := options.NewEtcdOptions(storagebackend.NewDefaultConfig(uuid.New(), api.Scheme, nil))
0000000000000000000000000000000000000000;;		etcdOptions.StorageConfig.ServerList = []string{GetEtcdURLFromEnv()}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info, _ := runtime.SerializerInfoForMediaType(api.Codecs.SupportedMediaTypes(), runtime.ContentTypeJSON)
0000000000000000000000000000000000000000;;		ns := NewSingleContentTypeSerializer(api.Scheme, info)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storageFactory := serverstorage.NewDefaultStorageFactory(etcdOptions.StorageConfig, runtime.ContentTypeJSON, ns, serverstorage.NewDefaultResourceEncodingConfig(api.Registry), master.DefaultAPIResourceConfigSource())
0000000000000000000000000000000000000000;;		storageFactory.SetSerializer(
0000000000000000000000000000000000000000;;			schema.GroupResource{Group: v1.GroupName, Resource: serverstorage.AllResources},
0000000000000000000000000000000000000000;;			"",
0000000000000000000000000000000000000000;;			ns)
0000000000000000000000000000000000000000;;		storageFactory.SetSerializer(
0000000000000000000000000000000000000000;;			schema.GroupResource{Group: autoscaling.GroupName, Resource: serverstorage.AllResources},
0000000000000000000000000000000000000000;;			"",
0000000000000000000000000000000000000000;;			ns)
0000000000000000000000000000000000000000;;		storageFactory.SetSerializer(
0000000000000000000000000000000000000000;;			schema.GroupResource{Group: batch.GroupName, Resource: serverstorage.AllResources},
0000000000000000000000000000000000000000;;			"",
0000000000000000000000000000000000000000;;			ns)
0000000000000000000000000000000000000000;;		storageFactory.SetSerializer(
0000000000000000000000000000000000000000;;			schema.GroupResource{Group: apps.GroupName, Resource: serverstorage.AllResources},
0000000000000000000000000000000000000000;;			"",
0000000000000000000000000000000000000000;;			ns)
0000000000000000000000000000000000000000;;		storageFactory.SetSerializer(
0000000000000000000000000000000000000000;;			schema.GroupResource{Group: extensions.GroupName, Resource: serverstorage.AllResources},
0000000000000000000000000000000000000000;;			"",
0000000000000000000000000000000000000000;;			ns)
0000000000000000000000000000000000000000;;		storageFactory.SetSerializer(
0000000000000000000000000000000000000000;;			schema.GroupResource{Group: policy.GroupName, Resource: serverstorage.AllResources},
0000000000000000000000000000000000000000;;			"",
0000000000000000000000000000000000000000;;			ns)
0000000000000000000000000000000000000000;;		storageFactory.SetSerializer(
0000000000000000000000000000000000000000;;			schema.GroupResource{Group: rbac.GroupName, Resource: serverstorage.AllResources},
0000000000000000000000000000000000000000;;			"",
0000000000000000000000000000000000000000;;			ns)
0000000000000000000000000000000000000000;;		storageFactory.SetSerializer(
0000000000000000000000000000000000000000;;			schema.GroupResource{Group: certificates.GroupName, Resource: serverstorage.AllResources},
0000000000000000000000000000000000000000;;			"",
0000000000000000000000000000000000000000;;			ns)
0000000000000000000000000000000000000000;;		storageFactory.SetSerializer(
0000000000000000000000000000000000000000;;			schema.GroupResource{Group: storage.GroupName, Resource: serverstorage.AllResources},
0000000000000000000000000000000000000000;;			"",
0000000000000000000000000000000000000000;;			ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		genericConfig := genericapiserver.NewConfig(api.Codecs)
0000000000000000000000000000000000000000;;		kubeVersion := version.Get()
0000000000000000000000000000000000000000;;		genericConfig.Version = &kubeVersion
0000000000000000000000000000000000000000;;		genericConfig.Authorizer = authorizerfactory.NewAlwaysAllowAuthorizer()
0000000000000000000000000000000000000000;;		genericConfig.AdmissionControl = admit.NewAlwaysAdmit()
0000000000000000000000000000000000000000;;		genericConfig.EnableMetrics = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := etcdOptions.ApplyWithStorageFactoryTo(storageFactory, genericConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &master.Config{
0000000000000000000000000000000000000000;;			GenericConfig:           genericConfig,
0000000000000000000000000000000000000000;;			APIResourceConfigSource: master.DefaultAPIResourceConfigSource(),
0000000000000000000000000000000000000000;;			StorageFactory:          storageFactory,
0000000000000000000000000000000000000000;;			EnableCoreControllers:   true,
0000000000000000000000000000000000000000;;			KubeletClientConfig:     kubeletclient.KubeletClientConfig{Port: 10250},
0000000000000000000000000000000000000000;;			APIServerServicePort:    443,
0000000000000000000000000000000000000000;;			MasterCount:             1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the master config appropriate for most integration tests.
0000000000000000000000000000000000000000;;	func NewIntegrationTestMasterConfig() *master.Config {
0000000000000000000000000000000000000000;;		masterConfig := NewMasterConfig()
0000000000000000000000000000000000000000;;		masterConfig.EnableCoreControllers = true
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.PublicAddress = net.ParseIP("192.168.10.4")
0000000000000000000000000000000000000000;;		masterConfig.APIResourceConfigSource = master.DefaultAPIResourceConfigSource()
0000000000000000000000000000000000000000;;		return masterConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MasterComponents) stopRCManager() {
0000000000000000000000000000000000000000;;		close(m.rcStopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MasterComponents) Stop(apiServer, rcManager bool) {
0000000000000000000000000000000000000000;;		glog.Infof("Stopping master components")
0000000000000000000000000000000000000000;;		if rcManager {
0000000000000000000000000000000000000000;;			// Ordering matters because the apiServer will only shutdown when pending
0000000000000000000000000000000000000000;;			// requests are done
0000000000000000000000000000000000000000;;			m.once.Do(m.stopRCManager)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if apiServer {
0000000000000000000000000000000000000000;;			m.CloseFn()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreateTestingNamespace(baseName string, apiserver *httptest.Server, t *testing.T) *v1.Namespace {
0000000000000000000000000000000000000000;;		// TODO: Create a namespace with a given basename.
0000000000000000000000000000000000000000;;		// Currently we neither create the namespace nor delete all its contents at the end.
0000000000000000000000000000000000000000;;		// But as long as tests are not using the same namespaces, this should work fine.
0000000000000000000000000000000000000000;;		return &v1.Namespace{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				// TODO: Once we start creating namespaces, switch to GenerateName.
0000000000000000000000000000000000000000;;				Name: baseName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DeleteTestingNamespace(ns *v1.Namespace, apiserver *httptest.Server, t *testing.T) {
0000000000000000000000000000000000000000;;		// TODO: Remove all resources from a given namespace once we implement CreateTestingNamespace.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RCFromManifest reads a .json file and returns the rc in it.
0000000000000000000000000000000000000000;;	func RCFromManifest(fileName string) *v1.ReplicationController {
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile(fileName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Unexpected error reading rc manifest %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var controller v1.ReplicationController
0000000000000000000000000000000000000000;;		if err := runtime.DecodeInto(testapi.Default.Codec(), data, &controller); err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Unexpected error reading rc manifest %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &controller
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StopRC stops the rc via kubectl's stop library
0000000000000000000000000000000000000000;;	func StopRC(rc *v1.ReplicationController, clientset internalclientset.Interface) error {
0000000000000000000000000000000000000000;;		reaper, err := kubectl.ReaperFor(api.Kind("ReplicationController"), clientset)
0000000000000000000000000000000000000000;;		if err != nil || reaper == nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = reaper.Stop(rc.Namespace, rc.Name, 0, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScaleRC scales the given rc to the given replicas.
0000000000000000000000000000000000000000;;	func ScaleRC(name, ns string, replicas int32, clientset internalclientset.Interface) (*api.ReplicationController, error) {
0000000000000000000000000000000000000000;;		scaler, err := kubectl.ScalerFor(api.Kind("ReplicationController"), clientset)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		retry := &kubectl.RetryParams{Interval: 50 * time.Millisecond, Timeout: DefaultTimeout}
0000000000000000000000000000000000000000;;		waitForReplicas := &kubectl.RetryParams{Interval: 50 * time.Millisecond, Timeout: DefaultTimeout}
0000000000000000000000000000000000000000;;		err = scaler.Scale(ns, name, uint(replicas), nil, retry, waitForReplicas)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		scaled, err := clientset.Core().ReplicationControllers(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return scaled, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CloseFunc can be called to cleanup the master
0000000000000000000000000000000000000000;;	type CloseFunc func()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunAMaster(masterConfig *master.Config) (*master.Master, *httptest.Server, CloseFunc) {
0000000000000000000000000000000000000000;;		if masterConfig == nil {
0000000000000000000000000000000000000000;;			masterConfig = NewMasterConfig()
0000000000000000000000000000000000000000;;			masterConfig.GenericConfig.EnableProfiling = true
0000000000000000000000000000000000000000;;			masterConfig.GenericConfig.EnableMetrics = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return startMasterOrDie(masterConfig, nil, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunAMasterUsingServer(masterConfig *master.Config, s *httptest.Server, masterReceiver MasterReceiver) (*master.Master, *httptest.Server, CloseFunc) {
0000000000000000000000000000000000000000;;		return startMasterOrDie(masterConfig, s, masterReceiver)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Task is a function passed to worker goroutines by RunParallel.
0000000000000000000000000000000000000000;;	// The function needs to implement its own thread safety.
0000000000000000000000000000000000000000;;	type Task func(id int) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunParallel spawns a goroutine per task in the given queue
0000000000000000000000000000000000000000;;	func RunParallel(task Task, numTasks, numWorkers int) {
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;		if numWorkers <= 0 {
0000000000000000000000000000000000000000;;			numWorkers = numTasks
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			glog.Infof("RunParallel took %v for %d tasks and %d workers", time.Since(start), numTasks, numWorkers)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		semCh := make(chan struct{}, numWorkers)
0000000000000000000000000000000000000000;;		wg.Add(numTasks)
0000000000000000000000000000000000000000;;		for id := 0; id < numTasks; id++ {
0000000000000000000000000000000000000000;;			go func(id int) {
0000000000000000000000000000000000000000;;				semCh <- struct{}{}
0000000000000000000000000000000000000000;;				err := task(id)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Fatalf("Worker failed with %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				<-semCh
0000000000000000000000000000000000000000;;				wg.Done()
0000000000000000000000000000000000000000;;			}(id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		close(semCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindFreeLocalPort returns the number of an available port number on
0000000000000000000000000000000000000000;;	// the loopback interface.  Useful for determining the port to launch
0000000000000000000000000000000000000000;;	// a server on.  Error handling required - there is a non-zero chance
0000000000000000000000000000000000000000;;	// that the returned port number will be bound by another process
0000000000000000000000000000000000000000;;	// after this function returns.
0000000000000000000000000000000000000000;;	func FindFreeLocalPort() (int, error) {
0000000000000000000000000000000000000000;;		l, err := net.Listen("tcp", ":0")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer l.Close()
0000000000000000000000000000000000000000;;		_, portStr, err := net.SplitHostPort(l.Addr().String())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		port, err := strconv.Atoi(portStr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return port, nil
0000000000000000000000000000000000000000;;	}
