0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
c507aab7c3e12a6fd7aae5913db7610c2cbc52a4;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		federationapi "k8s.io/kubernetes/federation/apis/federation/v1beta1"
0000000000000000000000000000000000000000;;		federationclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset"
0000000000000000000000000000000000000000;;		clustercontroller "k8s.io/kubernetes/federation/pkg/federation-controller/cluster"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/master"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e_node/services"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MemberCluster struct {
0000000000000000000000000000000000000000;;		CloseFn             framework.CloseFunc
0000000000000000000000000000000000000000;;		Config              *master.Config
0000000000000000000000000000000000000000;;		Client              clientset.Interface
0000000000000000000000000000000000000000;;		Host                string
0000000000000000000000000000000000000000;;		namespaceController *services.NamespaceController
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FederationFixture manages a federation api server and a set of member clusters
0000000000000000000000000000000000000000;;	type FederationFixture struct {
0000000000000000000000000000000000000000;;		APIFixture          *FederationAPIFixture
0000000000000000000000000000000000000000;;		DesiredClusterCount int
0000000000000000000000000000000000000000;;		Clusters            []*MemberCluster
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ClusterClients    []clientset.Interface
0000000000000000000000000000000000000000;;		ClusterController *clustercontroller.ClusterController
0000000000000000000000000000000000000000;;		fedClient         federationclientset.Interface
0000000000000000000000000000000000000000;;		stopChan          chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FederationFixture) SetUp(t *testing.T) {
0000000000000000000000000000000000000000;;		if f.APIFixture != nil {
0000000000000000000000000000000000000000;;			t.Fatal("Fixture already started")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.DesiredClusterCount < 1 {
0000000000000000000000000000000000000000;;			f.DesiredClusterCount = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer TearDownOnPanic(t, f)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Starting a federation of %d clusters", f.DesiredClusterCount)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.APIFixture = &FederationAPIFixture{}
0000000000000000000000000000000000000000;;		f.APIFixture.SetUp(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.stopChan = make(chan struct{})
0000000000000000000000000000000000000000;;		monitorPeriod := 1 * time.Second
0000000000000000000000000000000000000000;;		clustercontroller.StartClusterController(f.APIFixture.NewConfig(), f.stopChan, monitorPeriod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.fedClient = f.APIFixture.NewClient("federation-fixture")
0000000000000000000000000000000000000000;;		for i := 0; i < f.DesiredClusterCount; i++ {
0000000000000000000000000000000000000000;;			f.StartCluster(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FederationFixture) StartCluster(t *testing.T) {
0000000000000000000000000000000000000000;;		config := framework.NewMasterConfig()
0000000000000000000000000000000000000000;;		_, _, closeFn := framework.RunAMaster(config)
0000000000000000000000000000000000000000;;		host := config.GenericConfig.LoopbackClientConfig.Host
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clusterClient := clientset.NewForConfigOrDie(config.GenericConfig.LoopbackClientConfig)
0000000000000000000000000000000000000000;;		f.ClusterClients = append(f.ClusterClients, clusterClient)
0000000000000000000000000000000000000000;;		memberCluster := &MemberCluster{
0000000000000000000000000000000000000000;;			CloseFn:             closeFn,
0000000000000000000000000000000000000000;;			Config:              config,
0000000000000000000000000000000000000000;;			Client:              clusterClient,
0000000000000000000000000000000000000000;;			Host:                host,
0000000000000000000000000000000000000000;;			namespaceController: services.NewNamespaceController(host),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.Clusters = append(f.Clusters, memberCluster)
0000000000000000000000000000000000000000;;		err := memberCluster.namespaceController.Start()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clusterId := len(f.ClusterClients)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Federated cluster %d serving on %s", clusterId, host)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cluster := &federationapi.Cluster{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:   fmt.Sprintf("cluster-%d", clusterId),
0000000000000000000000000000000000000000;;				Labels: map[string]string{"cluster": fmt.Sprintf("%d", clusterId)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: federationapi.ClusterSpec{
0000000000000000000000000000000000000000;;				ServerAddressByClientCIDRs: []federationapi.ServerAddressByClientCIDR{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ClientCIDR:    "0.0.0.0/0",
0000000000000000000000000000000000000000;;						ServerAddress: host,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				// Use insecure access
0000000000000000000000000000000000000000;;				SecretRef: nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.fedClient.FederationV1beta1().Clusters().Create(cluster)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FederationFixture) TearDown(t *testing.T) {
0000000000000000000000000000000000000000;;		if f.stopChan != nil {
0000000000000000000000000000000000000000;;			close(f.stopChan)
0000000000000000000000000000000000000000;;			f.stopChan = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, cluster := range f.Clusters {
0000000000000000000000000000000000000000;;			// Need to close controllers with active connections to the
0000000000000000000000000000000000000000;;			// cluster api before stopping the api or the connections will
0000000000000000000000000000000000000000;;			// hang until tcp timeout.
0000000000000000000000000000000000000000;;			cluster.namespaceController.Stop()
0000000000000000000000000000000000000000;;			cluster.CloseFn()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.Clusters = nil
0000000000000000000000000000000000000000;;		if f.APIFixture != nil {
0000000000000000000000000000000000000000;;			f.APIFixture.TearDown(t)
0000000000000000000000000000000000000000;;			f.APIFixture = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
