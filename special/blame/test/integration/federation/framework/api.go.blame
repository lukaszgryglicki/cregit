0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
2cc1111931f03f6ca628c9838d7669dc5ad44f4a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/pborman/uuid"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		federationclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/cmd/federation-apiserver/app"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/cmd/federation-apiserver/app/options"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const apiNoun = "federation apiserver"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetRunOptions returns the default run options that can be used to run a test federation apiserver.
0000000000000000000000000000000000000000;;	func GetRunOptions() *options.ServerRunOptions {
0000000000000000000000000000000000000000;;		r := options.NewServerRunOptions()
0000000000000000000000000000000000000000;;		r.Etcd.StorageConfig.ServerList = []string{framework.GetEtcdURLFromEnv()}
0000000000000000000000000000000000000000;;		// Use a unique prefix to ensure isolation from other tests using the same etcd instance
0000000000000000000000000000000000000000;;		r.Etcd.StorageConfig.Prefix = uuid.New()
0000000000000000000000000000000000000000;;		// Disable secure serving
0000000000000000000000000000000000000000;;		r.SecureServing.BindPort = 0
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FederationAPIFixture manages a federation api server
0000000000000000000000000000000000000000;;	type FederationAPIFixture struct {
0000000000000000000000000000000000000000;;		Host     string
0000000000000000000000000000000000000000;;		stopChan chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUp runs federation apiserver with default run options.
0000000000000000000000000000000000000000;;	func (f *FederationAPIFixture) SetUp(t *testing.T) {
0000000000000000000000000000000000000000;;		f.SetUpWithRunOptions(t, GetRunOptions())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUpWithRunOptions runs federation apiserver with the given run options.
0000000000000000000000000000000000000000;;	// Uses default run options if runOptions is nil.
0000000000000000000000000000000000000000;;	func (f *FederationAPIFixture) SetUpWithRunOptions(t *testing.T, runOptions *options.ServerRunOptions) {
0000000000000000000000000000000000000000;;		if f.stopChan != nil {
0000000000000000000000000000000000000000;;			t.Fatal("SetUp() already called")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer TearDownOnPanic(t, f)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.stopChan = make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := startServer(t, runOptions, f.stopChan)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.Host = fmt.Sprintf("http://%s:%d", runOptions.InsecureServing.BindAddress, runOptions.InsecureServing.BindPort)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = waitForServer(t, f.Host)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FederationAPIFixture) TearDown(t *testing.T) {
0000000000000000000000000000000000000000;;		if f.stopChan != nil {
0000000000000000000000000000000000000000;;			close(f.stopChan)
0000000000000000000000000000000000000000;;			f.stopChan = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FederationAPIFixture) NewConfig() *restclient.Config {
0000000000000000000000000000000000000000;;		return &restclient.Config{Host: f.Host}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FederationAPIFixture) NewClient(userAgent string) federationclientset.Interface {
0000000000000000000000000000000000000000;;		config := f.NewConfig()
0000000000000000000000000000000000000000;;		restclient.AddUserAgent(config, userAgent)
0000000000000000000000000000000000000000;;		return federationclientset.NewForConfigOrDie(config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startServer(t *testing.T, runOptions *options.ServerRunOptions, stopChan <-chan struct{}) error {
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(DefaultWaitInterval, wait.ForeverTestTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			port, err := framework.FindFreeLocalPort()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Logf("Error allocating an ephemeral port: %v", err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			runOptions.InsecureServing.BindPort = port
0000000000000000000000000000000000000000;;			err = app.NonBlockingRun(runOptions, stopChan)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Logf("Error starting the %s: %v", apiNoun, err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Timed out waiting for the %s: %v", apiNoun, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForServer(t *testing.T, host string) error {
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(DefaultWaitInterval, wait.ForeverTestTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			_, err := http.Get(host)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Logf("Error when trying to contact the API: %v", err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Timed out waiting for the %s: %v", apiNoun, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
