0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
1235c082585357ece58374d0bbe98308109a6d9d;test/integration/quota_test.go[test/integration/quota_test.go][test/integration/quota/quota_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package quota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		clientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		internalinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		replicationcontroller "k8s.io/kubernetes/pkg/controller/replication"
0000000000000000000000000000000000000000;;		resourcequotacontroller "k8s.io/kubernetes/pkg/controller/resourcequota"
0000000000000000000000000000000000000000;;		kubeadmission "k8s.io/kubernetes/pkg/kubeapiserver/admission"
0000000000000000000000000000000000000000;;		quotainstall "k8s.io/kubernetes/pkg/quota/install"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/admission/resourcequota"
0000000000000000000000000000000000000000;;		resourcequotaapi "k8s.io/kubernetes/plugin/pkg/admission/resourcequota/apis/resourcequota"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// 1.2 code gets:
0000000000000000000000000000000000000000;;	// 	quota_test.go:95: Took 4.218619579s to scale up without quota
0000000000000000000000000000000000000000;;	// 	quota_test.go:199: unexpected error: timed out waiting for the condition, ended with 342 pods (1 minute)
0000000000000000000000000000000000000000;;	// 1.3+ code gets:
0000000000000000000000000000000000000000;;	// 	quota_test.go:100: Took 4.196205966s to scale up without quota
0000000000000000000000000000000000000000;;	// 	quota_test.go:115: Took 12.021640372s to scale up with quota
0000000000000000000000000000000000000000;;	func TestQuota(t *testing.T) {
0000000000000000000000000000000000000000;;		// Set up a master
0000000000000000000000000000000000000000;;		h := &framework.MasterHolder{Initialized: make(chan struct{})}
0000000000000000000000000000000000000000;;		s := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			<-h.Initialized
0000000000000000000000000000000000000000;;			h.M.GenericAPIServer.Handler.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		admissionCh := make(chan struct{})
0000000000000000000000000000000000000000;;		clientset := clientset.NewForConfigOrDie(&restclient.Config{QPS: -1, Host: s.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		internalClientset := internalclientset.NewForConfigOrDie(&restclient.Config{QPS: -1, Host: s.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{}
0000000000000000000000000000000000000000;;		admission, err := resourcequota.NewResourceQuota(config, 5, admissionCh)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		admission.(kubeadmission.WantsInternalKubeClientSet).SetInternalKubeClientSet(internalClientset)
0000000000000000000000000000000000000000;;		internalInformers := internalinformers.NewSharedInformerFactory(internalClientset, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		admission.(kubeadmission.WantsInternalKubeInformerFactory).SetInternalKubeInformerFactory(internalInformers)
0000000000000000000000000000000000000000;;		quotaRegistry := quotainstall.NewRegistry(nil, nil)
0000000000000000000000000000000000000000;;		admission.(kubeadmission.WantsQuotaRegistry).SetQuotaRegistry(quotaRegistry)
0000000000000000000000000000000000000000;;		defer close(admissionCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		masterConfig := framework.NewIntegrationTestMasterConfig()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.AdmissionControl = admission
0000000000000000000000000000000000000000;;		_, _, closeFn := framework.RunAMasterUsingServer(masterConfig, s, h)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("quotaed", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;		ns2 := framework.CreateTestingNamespace("non-quotaed", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns2, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controllerCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(controllerCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informers := informers.NewSharedInformerFactory(clientset, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		rm := replicationcontroller.NewReplicationManager(
0000000000000000000000000000000000000000;;			informers.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			informers.Core().V1().ReplicationControllers(),
0000000000000000000000000000000000000000;;			clientset,
0000000000000000000000000000000000000000;;			replicationcontroller.BurstReplicas,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		rm.SetEventRecorder(&record.FakeRecorder{})
0000000000000000000000000000000000000000;;		go rm.Run(3, controllerCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resourceQuotaRegistry := quotainstall.NewRegistry(clientset, nil)
0000000000000000000000000000000000000000;;		groupKindsToReplenish := []schema.GroupKind{
0000000000000000000000000000000000000000;;			api.Kind("Pod"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceQuotaControllerOptions := &resourcequotacontroller.ResourceQuotaControllerOptions{
0000000000000000000000000000000000000000;;			KubeClient:                clientset,
0000000000000000000000000000000000000000;;			ResourceQuotaInformer:     informers.Core().V1().ResourceQuotas(),
0000000000000000000000000000000000000000;;			ResyncPeriod:              controller.NoResyncPeriodFunc,
0000000000000000000000000000000000000000;;			Registry:                  resourceQuotaRegistry,
0000000000000000000000000000000000000000;;			GroupKindsToReplenish:     groupKindsToReplenish,
0000000000000000000000000000000000000000;;			ReplenishmentResyncPeriod: controller.NoResyncPeriodFunc,
0000000000000000000000000000000000000000;;			ControllerFactory:         resourcequotacontroller.NewReplenishmentControllerFactory(informers),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go resourcequotacontroller.NewResourceQuotaController(resourceQuotaControllerOptions).Run(2, controllerCh)
0000000000000000000000000000000000000000;;		internalInformers.Start(controllerCh)
0000000000000000000000000000000000000000;;		informers.Start(controllerCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		scale(t, ns2.Name, clientset)
0000000000000000000000000000000000000000;;		endTime := time.Now()
0000000000000000000000000000000000000000;;		t.Logf("Took %v to scale up without quota", endTime.Sub(startTime))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		quota := &v1.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "quota",
0000000000000000000000000000000000000000;;				Namespace: ns.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ResourceQuotaSpec{
0000000000000000000000000000000000000000;;				Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourcePods: resource.MustParse("1000"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForQuota(t, quota, clientset)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		startTime = time.Now()
0000000000000000000000000000000000000000;;		scale(t, "quotaed", clientset)
0000000000000000000000000000000000000000;;		endTime = time.Now()
0000000000000000000000000000000000000000;;		t.Logf("Took %v to scale up with quota", endTime.Sub(startTime))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForQuota(t *testing.T, quota *v1.ResourceQuota, clientset *clientset.Clientset) {
0000000000000000000000000000000000000000;;		w, err := clientset.Core().ResourceQuotas(quota.Namespace).Watch(metav1.SingleObject(metav1.ObjectMeta{Name: quota.Name}))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := clientset.Core().ResourceQuotas(quota.Namespace).Create(quota); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = watch.Until(1*time.Minute, w, func(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;			switch event.Type {
0000000000000000000000000000000000000000;;			case watch.Modified:
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch cast := event.Object.(type) {
0000000000000000000000000000000000000000;;			case *v1.ResourceQuota:
0000000000000000000000000000000000000000;;				if len(cast.Status.Hard) > 0 {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func scale(t *testing.T, namespace string, clientset *clientset.Clientset) {
0000000000000000000000000000000000000000;;		target := int32(100)
0000000000000000000000000000000000000000;;		rc := &v1.ReplicationController{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;				Replicas: &target,
0000000000000000000000000000000000000000;;				Selector: map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;				Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"foo": "bar",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "container",
0000000000000000000000000000000000000000;;								Image: "busybox",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w, err := clientset.Core().ReplicationControllers(namespace).Watch(metav1.SingleObject(metav1.ObjectMeta{Name: rc.Name}))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := clientset.Core().ReplicationControllers(namespace).Create(rc); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = watch.Until(3*time.Minute, w, func(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;			switch event.Type {
0000000000000000000000000000000000000000;;			case watch.Modified:
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch cast := event.Object.(type) {
0000000000000000000000000000000000000000;;			case *v1.ReplicationController:
0000000000000000000000000000000000000000;;				fmt.Printf("Found %v of %v replicas\n", int(cast.Status.Replicas), target)
0000000000000000000000000000000000000000;;				if cast.Status.Replicas == target {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			pods, _ := clientset.Core().Pods(namespace).List(metav1.ListOptions{LabelSelector: labels.Everything().String(), FieldSelector: fields.Everything().String()})
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v, ended with %v pods", err, len(pods.Items))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestQuotaLimitedResourceDenial(t *testing.T) {
0000000000000000000000000000000000000000;;		// Set up a master
0000000000000000000000000000000000000000;;		h := &framework.MasterHolder{Initialized: make(chan struct{})}
0000000000000000000000000000000000000000;;		s := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			<-h.Initialized
0000000000000000000000000000000000000000;;			h.M.GenericAPIServer.Handler.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		admissionCh := make(chan struct{})
0000000000000000000000000000000000000000;;		clientset := clientset.NewForConfigOrDie(&restclient.Config{QPS: -1, Host: s.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		internalClientset := internalclientset.NewForConfigOrDie(&restclient.Config{QPS: -1, Host: s.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// stop creation of a pod resource unless there is a quota
0000000000000000000000000000000000000000;;		config := &resourcequotaapi.Configuration{
0000000000000000000000000000000000000000;;			LimitedResources: []resourcequotaapi.LimitedResource{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Resource:      "pods",
0000000000000000000000000000000000000000;;					MatchContains: []string{"pods"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		quotaRegistry := quotainstall.NewRegistry(nil, nil)
0000000000000000000000000000000000000000;;		admission, err := resourcequota.NewResourceQuota(config, 5, admissionCh)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		admission.(kubeadmission.WantsInternalKubeClientSet).SetInternalKubeClientSet(internalClientset)
0000000000000000000000000000000000000000;;		internalInformers := internalinformers.NewSharedInformerFactory(internalClientset, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		admission.(kubeadmission.WantsInternalKubeInformerFactory).SetInternalKubeInformerFactory(internalInformers)
0000000000000000000000000000000000000000;;		admission.(kubeadmission.WantsQuotaRegistry).SetQuotaRegistry(quotaRegistry)
0000000000000000000000000000000000000000;;		defer close(admissionCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		masterConfig := framework.NewIntegrationTestMasterConfig()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.AdmissionControl = admission
0000000000000000000000000000000000000000;;		_, _, closeFn := framework.RunAMasterUsingServer(masterConfig, s, h)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("quota", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controllerCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(controllerCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informers := informers.NewSharedInformerFactory(clientset, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		rm := replicationcontroller.NewReplicationManager(
0000000000000000000000000000000000000000;;			informers.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			informers.Core().V1().ReplicationControllers(),
0000000000000000000000000000000000000000;;			clientset,
0000000000000000000000000000000000000000;;			replicationcontroller.BurstReplicas,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		rm.SetEventRecorder(&record.FakeRecorder{})
0000000000000000000000000000000000000000;;		go rm.Run(3, controllerCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resourceQuotaRegistry := quotainstall.NewRegistry(clientset, nil)
0000000000000000000000000000000000000000;;		groupKindsToReplenish := []schema.GroupKind{
0000000000000000000000000000000000000000;;			api.Kind("Pod"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceQuotaControllerOptions := &resourcequotacontroller.ResourceQuotaControllerOptions{
0000000000000000000000000000000000000000;;			KubeClient:                clientset,
0000000000000000000000000000000000000000;;			ResourceQuotaInformer:     informers.Core().V1().ResourceQuotas(),
0000000000000000000000000000000000000000;;			ResyncPeriod:              controller.NoResyncPeriodFunc,
0000000000000000000000000000000000000000;;			Registry:                  resourceQuotaRegistry,
0000000000000000000000000000000000000000;;			GroupKindsToReplenish:     groupKindsToReplenish,
0000000000000000000000000000000000000000;;			ReplenishmentResyncPeriod: controller.NoResyncPeriodFunc,
0000000000000000000000000000000000000000;;			ControllerFactory:         resourcequotacontroller.NewReplenishmentControllerFactory(informers),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go resourcequotacontroller.NewResourceQuotaController(resourceQuotaControllerOptions).Run(2, controllerCh)
0000000000000000000000000000000000000000;;		internalInformers.Start(controllerCh)
0000000000000000000000000000000000000000;;		informers.Start(controllerCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// try to create a pod
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: ns.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "container",
0000000000000000000000000000000000000000;;						Image: "busybox",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := clientset.Core().Pods(ns.Name).Create(pod); err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expected error for insufficient quota")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// now create a covering quota
0000000000000000000000000000000000000000;;		quota := &v1.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "quota",
0000000000000000000000000000000000000000;;				Namespace: ns.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ResourceQuotaSpec{
0000000000000000000000000000000000000000;;				Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourcePods: resource.MustParse("1000"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForQuota(t, quota, clientset)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// attempt to create a new pod once the quota is propagated
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(5*time.Second, time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			// retry until we succeed (to allow time for all changes to propagate)
0000000000000000000000000000000000000000;;			if _, err := clientset.Core().Pods(ns.Name).Create(pod); err == nil {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
