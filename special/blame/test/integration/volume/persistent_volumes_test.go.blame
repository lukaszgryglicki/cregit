0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
762ae2aafd446b93018fb98831980eba8aff8ea2;test/integration/persistent_volumes_test.go[test/integration/persistent_volumes_test.go][test/integration/volume/persistent_volumes_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package volume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		storage "k8s.io/api/storage/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/v1/ref"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		fakecloud "k8s.io/kubernetes/pkg/cloudprovider/providers/fake"
0000000000000000000000000000000000000000;;		persistentvolumecontroller "k8s.io/kubernetes/pkg/controller/volume/persistentvolume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetest "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Several tests in this file are configurable by environment variables:
0000000000000000000000000000000000000000;;	// KUBE_INTEGRATION_PV_OBJECTS - nr. of PVs/PVCs to be created
0000000000000000000000000000000000000000;;	//      (100 by default)
0000000000000000000000000000000000000000;;	// KUBE_INTEGRATION_PV_SYNC_PERIOD - volume controller sync period
0000000000000000000000000000000000000000;;	//      (1s by default)
0000000000000000000000000000000000000000;;	// KUBE_INTEGRATION_PV_END_SLEEP - for how long should
0000000000000000000000000000000000000000;;	//      TestPersistentVolumeMultiPVsPVCs sleep when it's finished (0s by
0000000000000000000000000000000000000000;;	//      default). This is useful to test how long does it take for periodic sync
0000000000000000000000000000000000000000;;	//      to process bound PVs/PVCs.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	const defaultObjectCount = 100
0000000000000000000000000000000000000000;;	const defaultSyncPeriod = 1 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const provisionerPluginName = "kubernetes.io/mock-provisioner"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getObjectCount() int {
0000000000000000000000000000000000000000;;		objectCount := defaultObjectCount
0000000000000000000000000000000000000000;;		if s := os.Getenv("KUBE_INTEGRATION_PV_OBJECTS"); s != "" {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			objectCount, err = strconv.Atoi(s)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Fatalf("cannot parse value of KUBE_INTEGRATION_PV_OBJECTS: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("using KUBE_INTEGRATION_PV_OBJECTS=%d", objectCount)
0000000000000000000000000000000000000000;;		return objectCount
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSyncPeriod(syncPeriod time.Duration) time.Duration {
0000000000000000000000000000000000000000;;		period := syncPeriod
0000000000000000000000000000000000000000;;		if s := os.Getenv("KUBE_INTEGRATION_PV_SYNC_PERIOD"); s != "" {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			period, err = time.ParseDuration(s)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Fatalf("cannot parse value of KUBE_INTEGRATION_PV_SYNC_PERIOD: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("using KUBE_INTEGRATION_PV_SYNC_PERIOD=%v", period)
0000000000000000000000000000000000000000;;		return period
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testSleep() {
0000000000000000000000000000000000000000;;		var period time.Duration
0000000000000000000000000000000000000000;;		if s := os.Getenv("KUBE_INTEGRATION_PV_END_SLEEP"); s != "" {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			period, err = time.ParseDuration(s)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Fatalf("cannot parse value of KUBE_INTEGRATION_PV_END_SLEEP: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("using KUBE_INTEGRATION_PV_END_SLEEP=%v", period)
0000000000000000000000000000000000000000;;		if period != 0 {
0000000000000000000000000000000000000000;;			time.Sleep(period)
0000000000000000000000000000000000000000;;			glog.V(2).Infof("sleep finished")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPersistentVolumeRecycler(t *testing.T) {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeRecycler started")
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(nil)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("pv-recycler", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient, ctrl, informers, watchPV, watchPVC := createClients(ns, t, s, defaultSyncPeriod)
0000000000000000000000000000000000000000;;		defer watchPV.Stop()
0000000000000000000000000000000000000000;;		defer watchPVC.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NOTE: This test cannot run in parallel, because it is creating and deleting
0000000000000000000000000000000000000000;;		// non-namespaced objects (PersistenceVolumes).
0000000000000000000000000000000000000000;;		defer testClient.Core().PersistentVolumes().DeleteCollection(nil, metav1.ListOptions{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		informers.Start(stopCh)
0000000000000000000000000000000000000000;;		go ctrl.Run(stopCh)
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This PV will be claimed, released, and recycled.
0000000000000000000000000000000000000000;;		pv := createPV("fake-pv-recycler", "/tmp/foo", "10G", []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}, v1.PersistentVolumeReclaimRecycle)
0000000000000000000000000000000000000000;;		pvc := createPVC("fake-pvc-recycler", ns.Name, "5G", []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}, "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := testClient.PersistentVolumes().Create(pv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to create PersistentVolume: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeRecycler pvc created")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = testClient.PersistentVolumeClaims(ns.Name).Create(pvc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to create PersistentVolumeClaim: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeRecycler pvc created")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait until the controller pairs the volume and claim
0000000000000000000000000000000000000000;;		waitForPersistentVolumePhase(testClient, pv.Name, watchPV, v1.VolumeBound)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeRecycler pv bound")
0000000000000000000000000000000000000000;;		waitForPersistentVolumeClaimPhase(testClient, pvc.Name, ns.Name, watchPVC, v1.ClaimBound)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeRecycler pvc bound")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// deleting a claim releases the volume, after which it can be recycled
0000000000000000000000000000000000000000;;		if err := testClient.PersistentVolumeClaims(ns.Name).Delete(pvc.Name, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error deleting claim %s", pvc.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeRecycler pvc deleted")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitForPersistentVolumePhase(testClient, pv.Name, watchPV, v1.VolumeReleased)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeRecycler pv released")
0000000000000000000000000000000000000000;;		waitForPersistentVolumePhase(testClient, pv.Name, watchPV, v1.VolumeAvailable)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeRecycler pv available")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPersistentVolumeDeleter(t *testing.T) {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeDeleter started")
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(nil)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("pv-deleter", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient, ctrl, informers, watchPV, watchPVC := createClients(ns, t, s, defaultSyncPeriod)
0000000000000000000000000000000000000000;;		defer watchPV.Stop()
0000000000000000000000000000000000000000;;		defer watchPVC.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NOTE: This test cannot run in parallel, because it is creating and deleting
0000000000000000000000000000000000000000;;		// non-namespaced objects (PersistenceVolumes).
0000000000000000000000000000000000000000;;		defer testClient.Core().PersistentVolumes().DeleteCollection(nil, metav1.ListOptions{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		informers.Start(stopCh)
0000000000000000000000000000000000000000;;		go ctrl.Run(stopCh)
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This PV will be claimed, released, and deleted.
0000000000000000000000000000000000000000;;		pv := createPV("fake-pv-deleter", "/tmp/foo", "10G", []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}, v1.PersistentVolumeReclaimDelete)
0000000000000000000000000000000000000000;;		pvc := createPVC("fake-pvc-deleter", ns.Name, "5G", []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}, "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := testClient.PersistentVolumes().Create(pv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to create PersistentVolume: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeDeleter pv created")
0000000000000000000000000000000000000000;;		_, err = testClient.PersistentVolumeClaims(ns.Name).Create(pvc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to create PersistentVolumeClaim: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeDeleter pvc created")
0000000000000000000000000000000000000000;;		waitForPersistentVolumePhase(testClient, pv.Name, watchPV, v1.VolumeBound)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeDeleter pv bound")
0000000000000000000000000000000000000000;;		waitForPersistentVolumeClaimPhase(testClient, pvc.Name, ns.Name, watchPVC, v1.ClaimBound)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeDeleter pvc bound")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// deleting a claim releases the volume, after which it can be recycled
0000000000000000000000000000000000000000;;		if err := testClient.PersistentVolumeClaims(ns.Name).Delete(pvc.Name, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error deleting claim %s", pvc.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeDeleter pvc deleted")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitForPersistentVolumePhase(testClient, pv.Name, watchPV, v1.VolumeReleased)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeDeleter pv released")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			event := <-watchPV.ResultChan()
0000000000000000000000000000000000000000;;			if event.Type == watch.Deleted {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeDeleter pv deleted")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPersistentVolumeBindRace(t *testing.T) {
0000000000000000000000000000000000000000;;		// Test a race binding many claims to a PV that is pre-bound to a specific
0000000000000000000000000000000000000000;;		// PVC. Only this specific PVC should get bound.
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeBindRace started")
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(nil)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("pv-bind-race", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient, ctrl, informers, watchPV, watchPVC := createClients(ns, t, s, defaultSyncPeriod)
0000000000000000000000000000000000000000;;		defer watchPV.Stop()
0000000000000000000000000000000000000000;;		defer watchPVC.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NOTE: This test cannot run in parallel, because it is creating and deleting
0000000000000000000000000000000000000000;;		// non-namespaced objects (PersistenceVolumes).
0000000000000000000000000000000000000000;;		defer testClient.Core().PersistentVolumes().DeleteCollection(nil, metav1.ListOptions{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		informers.Start(stopCh)
0000000000000000000000000000000000000000;;		go ctrl.Run(stopCh)
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv := createPV("fake-pv-race", "/tmp/foo", "10G", []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}, v1.PersistentVolumeReclaimRetain)
0000000000000000000000000000000000000000;;		pvc := createPVC("fake-pvc-race", ns.Name, "5G", []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}, "")
0000000000000000000000000000000000000000;;		counter := 0
0000000000000000000000000000000000000000;;		maxClaims := 100
0000000000000000000000000000000000000000;;		claims := []*v1.PersistentVolumeClaim{}
0000000000000000000000000000000000000000;;		for counter <= maxClaims {
0000000000000000000000000000000000000000;;			counter += 1
0000000000000000000000000000000000000000;;			clone, _ := api.Scheme.DeepCopy(pvc)
0000000000000000000000000000000000000000;;			newPvc, _ := clone.(*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;			newPvc.ObjectMeta = metav1.ObjectMeta{Name: fmt.Sprintf("fake-pvc-race-%d", counter)}
0000000000000000000000000000000000000000;;			claim, err := testClient.PersistentVolumeClaims(ns.Name).Create(newPvc)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Error creating newPvc: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			claims = append(claims, claim)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeBindRace claims created")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// putting a bind manually on a pv should only match the claim it is bound to
0000000000000000000000000000000000000000;;		rand.Seed(time.Now().Unix())
0000000000000000000000000000000000000000;;		claim := claims[rand.Intn(maxClaims-1)]
0000000000000000000000000000000000000000;;		claimRef, err := ref.GetReference(api.Scheme, claim)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error getting claimRef: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pv.Spec.ClaimRef = claimRef
0000000000000000000000000000000000000000;;		pv.Spec.ClaimRef.UID = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv, err = testClient.PersistentVolumes().Create(pv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error creating pv: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeBindRace pv created, pre-bound to %s", claim.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitForPersistentVolumePhase(testClient, pv.Name, watchPV, v1.VolumeBound)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeBindRace pv bound")
0000000000000000000000000000000000000000;;		waitForAnyPersistentVolumeClaimPhase(watchPVC, v1.ClaimBound)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeBindRace pvc bound")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv, err = testClient.PersistentVolumes().Get(pv.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error getting pv: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.ClaimRef == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected nil claimRef")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.ClaimRef.Namespace != claimRef.Namespace || pv.Spec.ClaimRef.Name != claimRef.Name {
0000000000000000000000000000000000000000;;			t.Fatalf("Bind mismatch! Expected %s/%s but got %s/%s", claimRef.Namespace, claimRef.Name, pv.Spec.ClaimRef.Namespace, pv.Spec.ClaimRef.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestPersistentVolumeClaimLabelSelector test binding using label selectors
0000000000000000000000000000000000000000;;	func TestPersistentVolumeClaimLabelSelector(t *testing.T) {
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(nil)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("pvc-label-selector", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient, controller, informers, watchPV, watchPVC := createClients(ns, t, s, defaultSyncPeriod)
0000000000000000000000000000000000000000;;		defer watchPV.Stop()
0000000000000000000000000000000000000000;;		defer watchPVC.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NOTE: This test cannot run in parallel, because it is creating and deleting
0000000000000000000000000000000000000000;;		// non-namespaced objects (PersistenceVolumes).
0000000000000000000000000000000000000000;;		defer testClient.Core().PersistentVolumes().DeleteCollection(nil, metav1.ListOptions{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		informers.Start(stopCh)
0000000000000000000000000000000000000000;;		go controller.Run(stopCh)
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			err     error
0000000000000000000000000000000000000000;;			modes   = []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}
0000000000000000000000000000000000000000;;			reclaim = v1.PersistentVolumeReclaimRetain
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pv_true  = createPV("pv-true", "/tmp/foo-label", "1G", modes, reclaim)
0000000000000000000000000000000000000000;;			pv_false = createPV("pv-false", "/tmp/foo-label", "1G", modes, reclaim)
0000000000000000000000000000000000000000;;			pvc      = createPVC("pvc-ls-1", ns.Name, "1G", modes, "")
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv_true.ObjectMeta.SetLabels(map[string]string{"foo": "true"})
0000000000000000000000000000000000000000;;		pv_false.ObjectMeta.SetLabels(map[string]string{"foo": "false"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = testClient.PersistentVolumes().Create(pv_true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create PersistentVolume: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = testClient.PersistentVolumes().Create(pv_false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create PersistentVolume: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Log("volumes created")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pvc.Spec.Selector = &metav1.LabelSelector{
0000000000000000000000000000000000000000;;			MatchLabels: map[string]string{
0000000000000000000000000000000000000000;;				"foo": "true",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = testClient.PersistentVolumeClaims(ns.Name).Create(pvc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create PersistentVolumeClaim: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Log("claim created")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitForAnyPersistentVolumePhase(watchPV, v1.VolumeBound)
0000000000000000000000000000000000000000;;		t.Log("volume bound")
0000000000000000000000000000000000000000;;		waitForPersistentVolumeClaimPhase(testClient, pvc.Name, ns.Name, watchPVC, v1.ClaimBound)
0000000000000000000000000000000000000000;;		t.Log("claim bound")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv, err := testClient.PersistentVolumes().Get("pv-false", metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error getting pv: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.ClaimRef != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("False PV shouldn't be bound")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pv, err = testClient.PersistentVolumes().Get("pv-true", metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error getting pv: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.ClaimRef == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("True PV should be bound")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.ClaimRef.Namespace != pvc.Namespace || pv.Spec.ClaimRef.Name != pvc.Name {
0000000000000000000000000000000000000000;;			t.Fatalf("Bind mismatch! Expected %s/%s but got %s/%s", pvc.Namespace, pvc.Name, pv.Spec.ClaimRef.Namespace, pv.Spec.ClaimRef.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestPersistentVolumeClaimLabelSelectorMatchExpressions test binding using
0000000000000000000000000000000000000000;;	// MatchExpressions label selectors
0000000000000000000000000000000000000000;;	func TestPersistentVolumeClaimLabelSelectorMatchExpressions(t *testing.T) {
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(nil)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("pvc-match-expressions", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient, controller, informers, watchPV, watchPVC := createClients(ns, t, s, defaultSyncPeriod)
0000000000000000000000000000000000000000;;		defer watchPV.Stop()
0000000000000000000000000000000000000000;;		defer watchPVC.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NOTE: This test cannot run in parallel, because it is creating and deleting
0000000000000000000000000000000000000000;;		// non-namespaced objects (PersistenceVolumes).
0000000000000000000000000000000000000000;;		defer testClient.Core().PersistentVolumes().DeleteCollection(nil, metav1.ListOptions{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		informers.Start(stopCh)
0000000000000000000000000000000000000000;;		go controller.Run(stopCh)
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			err     error
0000000000000000000000000000000000000000;;			modes   = []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}
0000000000000000000000000000000000000000;;			reclaim = v1.PersistentVolumeReclaimRetain
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pv_true  = createPV("pv-true", "/tmp/foo-label", "1G", modes, reclaim)
0000000000000000000000000000000000000000;;			pv_false = createPV("pv-false", "/tmp/foo-label", "1G", modes, reclaim)
0000000000000000000000000000000000000000;;			pvc      = createPVC("pvc-ls-1", ns.Name, "1G", modes, "")
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv_true.ObjectMeta.SetLabels(map[string]string{"foo": "valA", "bar": ""})
0000000000000000000000000000000000000000;;		pv_false.ObjectMeta.SetLabels(map[string]string{"foo": "valB", "baz": ""})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = testClient.PersistentVolumes().Create(pv_true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create PersistentVolume: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = testClient.PersistentVolumes().Create(pv_false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create PersistentVolume: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Log("volumes created")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pvc.Spec.Selector = &metav1.LabelSelector{
0000000000000000000000000000000000000000;;			MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Key:      "foo",
0000000000000000000000000000000000000000;;					Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;					Values:   []string{"valA"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Key:      "foo",
0000000000000000000000000000000000000000;;					Operator: metav1.LabelSelectorOpNotIn,
0000000000000000000000000000000000000000;;					Values:   []string{"valB"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Key:      "bar",
0000000000000000000000000000000000000000;;					Operator: metav1.LabelSelectorOpExists,
0000000000000000000000000000000000000000;;					Values:   []string{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Key:      "baz",
0000000000000000000000000000000000000000;;					Operator: metav1.LabelSelectorOpDoesNotExist,
0000000000000000000000000000000000000000;;					Values:   []string{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = testClient.PersistentVolumeClaims(ns.Name).Create(pvc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create PersistentVolumeClaim: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Log("claim created")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitForAnyPersistentVolumePhase(watchPV, v1.VolumeBound)
0000000000000000000000000000000000000000;;		t.Log("volume bound")
0000000000000000000000000000000000000000;;		waitForPersistentVolumeClaimPhase(testClient, pvc.Name, ns.Name, watchPVC, v1.ClaimBound)
0000000000000000000000000000000000000000;;		t.Log("claim bound")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv, err := testClient.PersistentVolumes().Get("pv-false", metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error getting pv: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.ClaimRef != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("False PV shouldn't be bound")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pv, err = testClient.PersistentVolumes().Get("pv-true", metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error getting pv: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.ClaimRef == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("True PV should be bound")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.ClaimRef.Namespace != pvc.Namespace || pv.Spec.ClaimRef.Name != pvc.Name {
0000000000000000000000000000000000000000;;			t.Fatalf("Bind mismatch! Expected %s/%s but got %s/%s", pvc.Namespace, pvc.Name, pv.Spec.ClaimRef.Namespace, pv.Spec.ClaimRef.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestPersistentVolumeMultiPVs tests binding of one PVC to 100 PVs with
0000000000000000000000000000000000000000;;	// different size.
0000000000000000000000000000000000000000;;	func TestPersistentVolumeMultiPVs(t *testing.T) {
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(nil)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("multi-pvs", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient, controller, informers, watchPV, watchPVC := createClients(ns, t, s, defaultSyncPeriod)
0000000000000000000000000000000000000000;;		defer watchPV.Stop()
0000000000000000000000000000000000000000;;		defer watchPVC.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NOTE: This test cannot run in parallel, because it is creating and deleting
0000000000000000000000000000000000000000;;		// non-namespaced objects (PersistenceVolumes).
0000000000000000000000000000000000000000;;		defer testClient.Core().PersistentVolumes().DeleteCollection(nil, metav1.ListOptions{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		informers.Start(stopCh)
0000000000000000000000000000000000000000;;		go controller.Run(stopCh)
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		maxPVs := getObjectCount()
0000000000000000000000000000000000000000;;		pvs := make([]*v1.PersistentVolume, maxPVs)
0000000000000000000000000000000000000000;;		for i := 0; i < maxPVs; i++ {
0000000000000000000000000000000000000000;;			// This PV will be claimed, released, and deleted
0000000000000000000000000000000000000000;;			pvs[i] = createPV("pv-"+strconv.Itoa(i), "/tmp/foo"+strconv.Itoa(i), strconv.Itoa(i)+"G",
0000000000000000000000000000000000000000;;				[]v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}, v1.PersistentVolumeReclaimRetain)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pvc := createPVC("pvc-2", ns.Name, strconv.Itoa(maxPVs/2)+"G", []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}, "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < maxPVs; i++ {
0000000000000000000000000000000000000000;;			_, err := testClient.PersistentVolumes().Create(pvs[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Failed to create PersistentVolume %d: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			waitForPersistentVolumePhase(testClient, pvs[i].Name, watchPV, v1.VolumeAvailable)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Log("volumes created")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := testClient.PersistentVolumeClaims(ns.Name).Create(pvc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to create PersistentVolumeClaim: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Log("claim created")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait until the binder pairs the claim with a volume
0000000000000000000000000000000000000000;;		waitForAnyPersistentVolumePhase(watchPV, v1.VolumeBound)
0000000000000000000000000000000000000000;;		t.Log("volume bound")
0000000000000000000000000000000000000000;;		waitForPersistentVolumeClaimPhase(testClient, pvc.Name, ns.Name, watchPVC, v1.ClaimBound)
0000000000000000000000000000000000000000;;		t.Log("claim bound")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// only one PV is bound
0000000000000000000000000000000000000000;;		bound := 0
0000000000000000000000000000000000000000;;		for i := 0; i < maxPVs; i++ {
0000000000000000000000000000000000000000;;			pv, err := testClient.PersistentVolumes().Get(pvs[i].Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected error getting pv: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pv.Spec.ClaimRef == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// found a bounded PV
0000000000000000000000000000000000000000;;			p := pv.Spec.Capacity[v1.ResourceStorage]
0000000000000000000000000000000000000000;;			pvCap := p.Value()
0000000000000000000000000000000000000000;;			expectedCap := resource.MustParse(strconv.Itoa(maxPVs/2) + "G")
0000000000000000000000000000000000000000;;			expectedCapVal := expectedCap.Value()
0000000000000000000000000000000000000000;;			if pv.Spec.ClaimRef.Name != pvc.Name || pvCap != expectedCapVal {
0000000000000000000000000000000000000000;;				t.Fatalf("Bind mismatch! Expected %s capacity %d but got %s capacity %d", pvc.Name, expectedCapVal, pv.Spec.ClaimRef.Name, pvCap)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Logf("claim bounded to %s capacity %v", pv.Name, pv.Spec.Capacity[v1.ResourceStorage])
0000000000000000000000000000000000000000;;			bound += 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Log("volumes checked")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if bound != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("Only 1 PV should be bound but got %d", bound)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// deleting a claim releases the volume
0000000000000000000000000000000000000000;;		if err := testClient.PersistentVolumeClaims(ns.Name).Delete(pvc.Name, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error deleting claim %s", pvc.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Log("claim deleted")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitForAnyPersistentVolumePhase(watchPV, v1.VolumeReleased)
0000000000000000000000000000000000000000;;		t.Log("volumes released")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestPersistentVolumeMultiPVsPVCs tests binding of 100 PVC to 100 PVs.
0000000000000000000000000000000000000000;;	// This test is configurable by KUBE_INTEGRATION_PV_* variables.
0000000000000000000000000000000000000000;;	func TestPersistentVolumeMultiPVsPVCs(t *testing.T) {
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(nil)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("multi-pvs-pvcs", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient, binder, informers, watchPV, watchPVC := createClients(ns, t, s, defaultSyncPeriod)
0000000000000000000000000000000000000000;;		defer watchPV.Stop()
0000000000000000000000000000000000000000;;		defer watchPVC.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NOTE: This test cannot run in parallel, because it is creating and deleting
0000000000000000000000000000000000000000;;		// non-namespaced objects (PersistenceVolumes).
0000000000000000000000000000000000000000;;		defer testClient.Core().PersistentVolumes().DeleteCollection(nil, metav1.ListOptions{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controllerStopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		informers.Start(controllerStopCh)
0000000000000000000000000000000000000000;;		go binder.Run(controllerStopCh)
0000000000000000000000000000000000000000;;		defer close(controllerStopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objCount := getObjectCount()
0000000000000000000000000000000000000000;;		pvs := make([]*v1.PersistentVolume, objCount)
0000000000000000000000000000000000000000;;		pvcs := make([]*v1.PersistentVolumeClaim, objCount)
0000000000000000000000000000000000000000;;		for i := 0; i < objCount; i++ {
0000000000000000000000000000000000000000;;			// This PV will be claimed, released, and deleted
0000000000000000000000000000000000000000;;			pvs[i] = createPV("pv-"+strconv.Itoa(i), "/tmp/foo"+strconv.Itoa(i), "1G",
0000000000000000000000000000000000000000;;				[]v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}, v1.PersistentVolumeReclaimRetain)
0000000000000000000000000000000000000000;;			pvcs[i] = createPVC("pvc-"+strconv.Itoa(i), ns.Name, "1G", []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create PVs first
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeMultiPVsPVCs: start")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the volumes in a separate goroutine to pop events from
0000000000000000000000000000000000000000;;		// watchPV early - it seems it has limited capacity and it gets stuck
0000000000000000000000000000000000000000;;		// with >3000 volumes.
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for i := 0; i < objCount; i++ {
0000000000000000000000000000000000000000;;				_, _ = testClient.PersistentVolumes().Create(pvs[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		// Wait for them to get Available
0000000000000000000000000000000000000000;;		for i := 0; i < objCount; i++ {
0000000000000000000000000000000000000000;;			waitForAnyPersistentVolumePhase(watchPV, v1.VolumeAvailable)
0000000000000000000000000000000000000000;;			glog.V(1).Infof("%d volumes available", i+1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeMultiPVsPVCs: volumes are Available")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start a separate goroutine that randomly modifies PVs and PVCs while the
0000000000000000000000000000000000000000;;		// binder is working. We test that the binder can bind volumes despite
0000000000000000000000000000000000000000;;		// users modifying objects underneath.
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{}, 0)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				// Roll a dice and decide a PV or PVC to modify
0000000000000000000000000000000000000000;;				if rand.Intn(2) == 0 {
0000000000000000000000000000000000000000;;					// Modify PV
0000000000000000000000000000000000000000;;					i := rand.Intn(objCount)
0000000000000000000000000000000000000000;;					name := "pv-" + strconv.Itoa(i)
0000000000000000000000000000000000000000;;					pv, err := testClient.PersistentVolumes().Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						// Silently ignore error, the PV may have be already deleted
0000000000000000000000000000000000000000;;						// or not exists yet.
0000000000000000000000000000000000000000;;						glog.V(4).Infof("Failed to read PV %s: %v", name, err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if pv.Annotations == nil {
0000000000000000000000000000000000000000;;						pv.Annotations = map[string]string{"TestAnnotation": fmt.Sprint(rand.Int())}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						pv.Annotations["TestAnnotation"] = fmt.Sprint(rand.Int())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					_, err = testClient.PersistentVolumes().Update(pv)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						// Silently ignore error, the PV may have been updated by
0000000000000000000000000000000000000000;;						// the controller.
0000000000000000000000000000000000000000;;						glog.V(4).Infof("Failed to update PV %s: %v", pv.Name, err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Updated PV %s", pv.Name)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Modify PVC
0000000000000000000000000000000000000000;;					i := rand.Intn(objCount)
0000000000000000000000000000000000000000;;					name := "pvc-" + strconv.Itoa(i)
0000000000000000000000000000000000000000;;					pvc, err := testClient.PersistentVolumeClaims(metav1.NamespaceDefault).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						// Silently ignore error, the PVC may have be already
0000000000000000000000000000000000000000;;						// deleted or not exists yet.
0000000000000000000000000000000000000000;;						glog.V(4).Infof("Failed to read PVC %s: %v", name, err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if pvc.Annotations == nil {
0000000000000000000000000000000000000000;;						pvc.Annotations = map[string]string{"TestAnnotation": fmt.Sprint(rand.Int())}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						pvc.Annotations["TestAnnotation"] = fmt.Sprint(rand.Int())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					_, err = testClient.PersistentVolumeClaims(metav1.NamespaceDefault).Update(pvc)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						// Silently ignore error, the PVC may have been updated by
0000000000000000000000000000000000000000;;						// the controller.
0000000000000000000000000000000000000000;;						glog.V(4).Infof("Failed to update PVC %s: %v", pvc.Name, err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Updated PVC %s", pvc.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-stopCh:
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the claims, again in a separate goroutine.
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for i := 0; i < objCount; i++ {
0000000000000000000000000000000000000000;;				_, _ = testClient.PersistentVolumeClaims(ns.Name).Create(pvcs[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait until the binder pairs all claims
0000000000000000000000000000000000000000;;		for i := 0; i < objCount; i++ {
0000000000000000000000000000000000000000;;			waitForAnyPersistentVolumeClaimPhase(watchPVC, v1.ClaimBound)
0000000000000000000000000000000000000000;;			glog.V(1).Infof("%d claims bound", i+1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// wait until the binder pairs all volumes
0000000000000000000000000000000000000000;;		for i := 0; i < objCount; i++ {
0000000000000000000000000000000000000000;;			waitForPersistentVolumePhase(testClient, pvs[i].Name, watchPV, v1.VolumeBound)
0000000000000000000000000000000000000000;;			glog.V(1).Infof("%d claims bound", i+1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeMultiPVsPVCs: claims are bound")
0000000000000000000000000000000000000000;;		stopCh <- struct{}{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check that everything is bound to something
0000000000000000000000000000000000000000;;		for i := 0; i < objCount; i++ {
0000000000000000000000000000000000000000;;			pv, err := testClient.PersistentVolumes().Get(pvs[i].Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected error getting pv: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pv.Spec.ClaimRef == nil {
0000000000000000000000000000000000000000;;				t.Fatalf("PV %q is not bound", pv.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("PV %q is bound to PVC %q", pv.Name, pv.Spec.ClaimRef.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pvc, err := testClient.PersistentVolumeClaims(ns.Name).Get(pvcs[i].Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected error getting pvc: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pvc.Spec.VolumeName == "" {
0000000000000000000000000000000000000000;;				t.Fatalf("PVC %q is not bound", pvc.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("PVC %q is bound to PV %q", pvc.Name, pvc.Spec.VolumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testSleep()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestPersistentVolumeControllerStartup tests startup of the controller.
0000000000000000000000000000000000000000;;	// The controller should not unbind any volumes when it starts.
0000000000000000000000000000000000000000;;	func TestPersistentVolumeControllerStartup(t *testing.T) {
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(nil)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("controller-startup", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objCount := getObjectCount()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const shortSyncPeriod = 2 * time.Second
0000000000000000000000000000000000000000;;		syncPeriod := getSyncPeriod(shortSyncPeriod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient, binder, informers, watchPV, watchPVC := createClients(ns, t, s, shortSyncPeriod)
0000000000000000000000000000000000000000;;		defer watchPV.Stop()
0000000000000000000000000000000000000000;;		defer watchPVC.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create *bound* volumes and PVCs
0000000000000000000000000000000000000000;;		pvs := make([]*v1.PersistentVolume, objCount)
0000000000000000000000000000000000000000;;		pvcs := make([]*v1.PersistentVolumeClaim, objCount)
0000000000000000000000000000000000000000;;		for i := 0; i < objCount; i++ {
0000000000000000000000000000000000000000;;			pvName := "pv-startup-" + strconv.Itoa(i)
0000000000000000000000000000000000000000;;			pvcName := "pvc-startup-" + strconv.Itoa(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pvc := createPVC(pvcName, ns.Name, "1G", []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}, "")
0000000000000000000000000000000000000000;;			pvc.Annotations = map[string]string{"annBindCompleted": ""}
0000000000000000000000000000000000000000;;			pvc.Spec.VolumeName = pvName
0000000000000000000000000000000000000000;;			newPVC, err := testClient.PersistentVolumeClaims(ns.Name).Create(pvc)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Cannot create claim %q: %v", pvc.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Save Bound status as a separate transaction
0000000000000000000000000000000000000000;;			newPVC.Status.Phase = v1.ClaimBound
0000000000000000000000000000000000000000;;			newPVC, err = testClient.PersistentVolumeClaims(ns.Name).UpdateStatus(newPVC)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Cannot update claim status %q: %v", pvc.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pvcs[i] = newPVC
0000000000000000000000000000000000000000;;			// Drain watchPVC with all events generated by the PVC until it's bound
0000000000000000000000000000000000000000;;			// We don't want to catch "PVC created with Status.Phase == Pending"
0000000000000000000000000000000000000000;;			// later in this test.
0000000000000000000000000000000000000000;;			waitForAnyPersistentVolumeClaimPhase(watchPVC, v1.ClaimBound)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pv := createPV(pvName, "/tmp/foo"+strconv.Itoa(i), "1G",
0000000000000000000000000000000000000000;;				[]v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}, v1.PersistentVolumeReclaimRetain)
0000000000000000000000000000000000000000;;			claimRef, err := ref.GetReference(api.Scheme, newPVC)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(3).Infof("unexpected error getting claim reference: %v", err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pv.Spec.ClaimRef = claimRef
0000000000000000000000000000000000000000;;			newPV, err := testClient.PersistentVolumes().Create(pv)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Cannot create volume %q: %v", pv.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Save Bound status as a separate transaction
0000000000000000000000000000000000000000;;			newPV.Status.Phase = v1.VolumeBound
0000000000000000000000000000000000000000;;			newPV, err = testClient.PersistentVolumes().UpdateStatus(newPV)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Cannot update volume status %q: %v", pv.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pvs[i] = newPV
0000000000000000000000000000000000000000;;			// Drain watchPV with all events generated by the PV until it's bound
0000000000000000000000000000000000000000;;			// We don't want to catch "PV created with Status.Phase == Pending"
0000000000000000000000000000000000000000;;			// later in this test.
0000000000000000000000000000000000000000;;			waitForAnyPersistentVolumePhase(watchPV, v1.VolumeBound)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start the controller when all PVs and PVCs are already saved in etcd
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		informers.Start(stopCh)
0000000000000000000000000000000000000000;;		go binder.Run(stopCh)
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait for at least two sync periods for changes. No volume should be
0000000000000000000000000000000000000000;;		// Released and no claim should be Lost during this time.
0000000000000000000000000000000000000000;;		timer := time.NewTimer(2 * syncPeriod)
0000000000000000000000000000000000000000;;		defer timer.Stop()
0000000000000000000000000000000000000000;;		finished := false
0000000000000000000000000000000000000000;;		for !finished {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case volumeEvent := <-watchPV.ResultChan():
0000000000000000000000000000000000000000;;				volume, ok := volumeEvent.Object.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if volume.Status.Phase != v1.VolumeBound {
0000000000000000000000000000000000000000;;					t.Errorf("volume %s unexpectedly changed state to %s", volume.Name, volume.Status.Phase)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case claimEvent := <-watchPVC.ResultChan():
0000000000000000000000000000000000000000;;				claim, ok := claimEvent.Object.(*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if claim.Status.Phase != v1.ClaimBound {
0000000000000000000000000000000000000000;;					t.Errorf("claim %s unexpectedly changed state to %s", claim.Name, claim.Status.Phase)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case <-timer.C:
0000000000000000000000000000000000000000;;				// Wait finished
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Wait finished")
0000000000000000000000000000000000000000;;				finished = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check that everything is bound to something
0000000000000000000000000000000000000000;;		for i := 0; i < objCount; i++ {
0000000000000000000000000000000000000000;;			pv, err := testClient.PersistentVolumes().Get(pvs[i].Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected error getting pv: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pv.Spec.ClaimRef == nil {
0000000000000000000000000000000000000000;;				t.Fatalf("PV %q is not bound", pv.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("PV %q is bound to PVC %q", pv.Name, pv.Spec.ClaimRef.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pvc, err := testClient.PersistentVolumeClaims(ns.Name).Get(pvcs[i].Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected error getting pvc: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pvc.Spec.VolumeName == "" {
0000000000000000000000000000000000000000;;				t.Fatalf("PVC %q is not bound", pvc.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("PVC %q is bound to PV %q", pvc.Name, pvc.Spec.VolumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestPersistentVolumeProvisionMultiPVCs tests provisioning of many PVCs.
0000000000000000000000000000000000000000;;	// This test is configurable by KUBE_INTEGRATION_PV_* variables.
0000000000000000000000000000000000000000;;	func TestPersistentVolumeProvisionMultiPVCs(t *testing.T) {
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(nil)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("provision-multi-pvs", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient, binder, informers, watchPV, watchPVC := createClients(ns, t, s, defaultSyncPeriod)
0000000000000000000000000000000000000000;;		defer watchPV.Stop()
0000000000000000000000000000000000000000;;		defer watchPVC.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NOTE: This test cannot run in parallel, because it is creating and deleting
0000000000000000000000000000000000000000;;		// non-namespaced objects (PersistenceVolumes and StorageClasses).
0000000000000000000000000000000000000000;;		defer testClient.Core().PersistentVolumes().DeleteCollection(nil, metav1.ListOptions{})
0000000000000000000000000000000000000000;;		defer testClient.StorageV1().StorageClasses().DeleteCollection(nil, metav1.ListOptions{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storageClass := storage.StorageClass{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind: "StorageClass",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "gold",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Provisioner: provisionerPluginName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testClient.StorageV1().StorageClasses().Create(&storageClass)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		informers.Start(stopCh)
0000000000000000000000000000000000000000;;		go binder.Run(stopCh)
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objCount := getObjectCount()
0000000000000000000000000000000000000000;;		pvcs := make([]*v1.PersistentVolumeClaim, objCount)
0000000000000000000000000000000000000000;;		for i := 0; i < objCount; i++ {
0000000000000000000000000000000000000000;;			pvc := createPVC("pvc-provision-"+strconv.Itoa(i), ns.Name, "1G", []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}, "gold")
0000000000000000000000000000000000000000;;			pvcs[i] = pvc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeProvisionMultiPVCs: start")
0000000000000000000000000000000000000000;;		// Create the claims in a separate goroutine to pop events from watchPVC
0000000000000000000000000000000000000000;;		// early. It gets stuck with >3000 claims.
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for i := 0; i < objCount; i++ {
0000000000000000000000000000000000000000;;				_, _ = testClient.PersistentVolumeClaims(ns.Name).Create(pvcs[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait until the controller provisions and binds all of them
0000000000000000000000000000000000000000;;		for i := 0; i < objCount; i++ {
0000000000000000000000000000000000000000;;			waitForAnyPersistentVolumeClaimPhase(watchPVC, v1.ClaimBound)
0000000000000000000000000000000000000000;;			glog.V(1).Infof("%d claims bound", i+1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeProvisionMultiPVCs: claims are bound")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check that we have enough bound PVs
0000000000000000000000000000000000000000;;		pvList, err := testClient.PersistentVolumes().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to list volumes: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pvList.Items) != objCount {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected to get %d volumes, got %d", objCount, len(pvList.Items))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < objCount; i++ {
0000000000000000000000000000000000000000;;			pv := &pvList.Items[i]
0000000000000000000000000000000000000000;;			if pv.Status.Phase != v1.VolumeBound {
0000000000000000000000000000000000000000;;				t.Fatalf("Expected volume %s to be bound, is %s instead", pv.Name, pv.Status.Phase)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("PV %q is bound to PVC %q", pv.Name, pv.Spec.ClaimRef.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete the claims
0000000000000000000000000000000000000000;;		for i := 0; i < objCount; i++ {
0000000000000000000000000000000000000000;;			_ = testClient.PersistentVolumeClaims(ns.Name).Delete(pvcs[i].Name, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for the PVs to get deleted by listing remaining volumes
0000000000000000000000000000000000000000;;		// (delete events were unreliable)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			volumes, err := testClient.PersistentVolumes().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed to list volumes: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(1).Infof("%d volumes remaining", len(volumes.Items))
0000000000000000000000000000000000000000;;			if len(volumes.Items) == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			time.Sleep(time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("TestPersistentVolumeProvisionMultiPVCs: volumes are deleted")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestPersistentVolumeMultiPVsDiffAccessModes tests binding of one PVC to two
0000000000000000000000000000000000000000;;	// PVs with different access modes.
0000000000000000000000000000000000000000;;	func TestPersistentVolumeMultiPVsDiffAccessModes(t *testing.T) {
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(nil)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("multi-pvs-diff-access", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient, controller, informers, watchPV, watchPVC := createClients(ns, t, s, defaultSyncPeriod)
0000000000000000000000000000000000000000;;		defer watchPV.Stop()
0000000000000000000000000000000000000000;;		defer watchPVC.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NOTE: This test cannot run in parallel, because it is creating and deleting
0000000000000000000000000000000000000000;;		// non-namespaced objects (PersistenceVolumes).
0000000000000000000000000000000000000000;;		defer testClient.Core().PersistentVolumes().DeleteCollection(nil, metav1.ListOptions{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		informers.Start(stopCh)
0000000000000000000000000000000000000000;;		go controller.Run(stopCh)
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This PV will be claimed, released, and deleted
0000000000000000000000000000000000000000;;		pv_rwo := createPV("pv-rwo", "/tmp/foo", "10G",
0000000000000000000000000000000000000000;;			[]v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}, v1.PersistentVolumeReclaimRetain)
0000000000000000000000000000000000000000;;		pv_rwm := createPV("pv-rwm", "/tmp/bar", "10G",
0000000000000000000000000000000000000000;;			[]v1.PersistentVolumeAccessMode{v1.ReadWriteMany}, v1.PersistentVolumeReclaimRetain)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pvc := createPVC("pvc-rwm", ns.Name, "5G", []v1.PersistentVolumeAccessMode{v1.ReadWriteMany}, "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := testClient.PersistentVolumes().Create(pv_rwm)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to create PersistentVolume: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = testClient.PersistentVolumes().Create(pv_rwo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to create PersistentVolume: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Log("volumes created")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = testClient.PersistentVolumeClaims(ns.Name).Create(pvc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to create PersistentVolumeClaim: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Log("claim created")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait until the controller pairs the volume and claim
0000000000000000000000000000000000000000;;		waitForAnyPersistentVolumePhase(watchPV, v1.VolumeBound)
0000000000000000000000000000000000000000;;		t.Log("volume bound")
0000000000000000000000000000000000000000;;		waitForPersistentVolumeClaimPhase(testClient, pvc.Name, ns.Name, watchPVC, v1.ClaimBound)
0000000000000000000000000000000000000000;;		t.Log("claim bound")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// only RWM PV is bound
0000000000000000000000000000000000000000;;		pv, err := testClient.PersistentVolumes().Get("pv-rwo", metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error getting pv: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.ClaimRef != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("ReadWriteOnce PV shouldn't be bound")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pv, err = testClient.PersistentVolumes().Get("pv-rwm", metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error getting pv: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.ClaimRef == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("ReadWriteMany PV should be bound")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.ClaimRef.Name != pvc.Name {
0000000000000000000000000000000000000000;;			t.Fatalf("Bind mismatch! Expected %s but got %s", pvc.Name, pv.Spec.ClaimRef.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// deleting a claim releases the volume
0000000000000000000000000000000000000000;;		if err := testClient.PersistentVolumeClaims(ns.Name).Delete(pvc.Name, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error deleting claim %s", pvc.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Log("claim deleted")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitForAnyPersistentVolumePhase(watchPV, v1.VolumeReleased)
0000000000000000000000000000000000000000;;		t.Log("volume released")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForPersistentVolumePhase(client *clientset.Clientset, pvName string, w watch.Interface, phase v1.PersistentVolumePhase) {
0000000000000000000000000000000000000000;;		// Check if the volume is already in requested phase
0000000000000000000000000000000000000000;;		volume, err := client.Core().PersistentVolumes().Get(pvName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err == nil && volume.Status.Phase == phase {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for the phase
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			event := <-w.ResultChan()
0000000000000000000000000000000000000000;;			volume, ok := event.Object.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if volume.Status.Phase == phase && volume.Name == pvName {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("volume %q is %s", volume.Name, phase)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForPersistentVolumeClaimPhase(client *clientset.Clientset, claimName, namespace string, w watch.Interface, phase v1.PersistentVolumeClaimPhase) {
0000000000000000000000000000000000000000;;		// Check if the claim is already in requested phase
0000000000000000000000000000000000000000;;		claim, err := client.Core().PersistentVolumeClaims(namespace).Get(claimName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err == nil && claim.Status.Phase == phase {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for the phase
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			event := <-w.ResultChan()
0000000000000000000000000000000000000000;;			claim, ok := event.Object.(*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if claim.Status.Phase == phase && claim.Name == claimName {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("claim %q is %s", claim.Name, phase)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForAnyPersistentVolumePhase(w watch.Interface, phase v1.PersistentVolumePhase) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			event := <-w.ResultChan()
0000000000000000000000000000000000000000;;			volume, ok := event.Object.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if volume.Status.Phase == phase {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("volume %q is %s", volume.Name, phase)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForAnyPersistentVolumeClaimPhase(w watch.Interface, phase v1.PersistentVolumeClaimPhase) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			event := <-w.ResultChan()
0000000000000000000000000000000000000000;;			claim, ok := event.Object.(*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if claim.Status.Phase == phase {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("claim %q is %s", claim.Name, phase)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createClients(ns *v1.Namespace, t *testing.T, s *httptest.Server, syncPeriod time.Duration) (*clientset.Clientset, *persistentvolumecontroller.PersistentVolumeController, informers.SharedInformerFactory, watch.Interface, watch.Interface) {
0000000000000000000000000000000000000000;;		// Use higher QPS and Burst, there is a test for race conditions which
0000000000000000000000000000000000000000;;		// creates many objects and default values were too low.
0000000000000000000000000000000000000000;;		binderClient := clientset.NewForConfigOrDie(&restclient.Config{
0000000000000000000000000000000000000000;;			Host:          s.URL,
0000000000000000000000000000000000000000;;			ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion},
0000000000000000000000000000000000000000;;			QPS:           1000000,
0000000000000000000000000000000000000000;;			Burst:         1000000,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		testClient := clientset.NewForConfigOrDie(&restclient.Config{
0000000000000000000000000000000000000000;;			Host:          s.URL,
0000000000000000000000000000000000000000;;			ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion},
0000000000000000000000000000000000000000;;			QPS:           1000000,
0000000000000000000000000000000000000000;;			Burst:         1000000,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		host := volumetest.NewFakeVolumeHost("/tmp/fake", nil, nil)
0000000000000000000000000000000000000000;;		plugin := &volumetest.FakeVolumePlugin{
0000000000000000000000000000000000000000;;			PluginName:             provisionerPluginName,
0000000000000000000000000000000000000000;;			Host:                   host,
0000000000000000000000000000000000000000;;			Config:                 volume.VolumeConfig{},
0000000000000000000000000000000000000000;;			LastProvisionerOptions: volume.VolumeOptions{},
0000000000000000000000000000000000000000;;			NewAttacherCallCount:   0,
0000000000000000000000000000000000000000;;			NewDetacherCallCount:   0,
0000000000000000000000000000000000000000;;			Mounters:               nil,
0000000000000000000000000000000000000000;;			Unmounters:             nil,
0000000000000000000000000000000000000000;;			Attachers:              nil,
0000000000000000000000000000000000000000;;			Detachers:              nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plugins := []volume.VolumePlugin{plugin}
0000000000000000000000000000000000000000;;		cloud := &fakecloud.FakeCloud{}
0000000000000000000000000000000000000000;;		informers := informers.NewSharedInformerFactory(testClient, getSyncPeriod(syncPeriod))
0000000000000000000000000000000000000000;;		ctrl, err := persistentvolumecontroller.NewController(
0000000000000000000000000000000000000000;;			persistentvolumecontroller.ControllerParameters{
0000000000000000000000000000000000000000;;				KubeClient:                binderClient,
0000000000000000000000000000000000000000;;				SyncPeriod:                getSyncPeriod(syncPeriod),
0000000000000000000000000000000000000000;;				VolumePlugins:             plugins,
0000000000000000000000000000000000000000;;				Cloud:                     cloud,
0000000000000000000000000000000000000000;;				VolumeInformer:            informers.Core().V1().PersistentVolumes(),
0000000000000000000000000000000000000000;;				ClaimInformer:             informers.Core().V1().PersistentVolumeClaims(),
0000000000000000000000000000000000000000;;				ClassInformer:             informers.Storage().V1().StorageClasses(),
0000000000000000000000000000000000000000;;				EnableDynamicProvisioning: true,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to construct PersistentVolumes: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		watchPV, err := testClient.PersistentVolumes().Watch(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to watch PersistentVolumes: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		watchPVC, err := testClient.PersistentVolumeClaims(ns.Name).Watch(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to watch PersistentVolumeClaims: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return testClient, ctrl, informers, watchPV, watchPVC
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPV(name, path, cap string, mode []v1.PersistentVolumeAccessMode, reclaim v1.PersistentVolumeReclaimPolicy) *v1.PersistentVolume {
0000000000000000000000000000000000000000;;		return &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: name},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeSource:        v1.PersistentVolumeSource{HostPath: &v1.HostPathVolumeSource{Path: path}},
0000000000000000000000000000000000000000;;				Capacity:                      v1.ResourceList{v1.ResourceName(v1.ResourceStorage): resource.MustParse(cap)},
0000000000000000000000000000000000000000;;				AccessModes:                   mode,
0000000000000000000000000000000000000000;;				PersistentVolumeReclaimPolicy: reclaim,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPVC(name, namespace, cap string, mode []v1.PersistentVolumeAccessMode, class string) *v1.PersistentVolumeClaim {
0000000000000000000000000000000000000000;;		return &v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				Resources:        v1.ResourceRequirements{Requests: v1.ResourceList{v1.ResourceName(v1.ResourceStorage): resource.MustParse(cap)}},
0000000000000000000000000000000000000000;;				AccessModes:      mode,
0000000000000000000000000000000000000000;;				StorageClassName: &class,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
