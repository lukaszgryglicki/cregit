0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
e9fa7ba5aaf051ab6f0bef679beccb16c032c40c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package volume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		fakecloud "k8s.io/kubernetes/pkg/cloudprovider/providers/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/volume/attachdetach"
0000000000000000000000000000000000000000;;		volumecache "k8s.io/kubernetes/pkg/controller/volume/attachdetach/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetest "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fakePodWithVol(namespace string) *v1.Pod {
0000000000000000000000000000000000000000;;		fakePod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Name:      "fakepod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "fake-container",
0000000000000000000000000000000000000000;;						Image: "nginx",
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      "fake-mount",
0000000000000000000000000000000000000000;;								MountPath: "/var/www/html",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "fake-mount",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							HostPath: &v1.HostPathVolumeSource{
0000000000000000000000000000000000000000;;								Path: "/var/www/html",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				NodeName: "node-sandbox",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fakePod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type podCountFunc func(int) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Via integration test we can verify that if pod delete
0000000000000000000000000000000000000000;;	// event is somehow missed by AttachDetach controller - it still
0000000000000000000000000000000000000000;;	// gets cleaned up by Desired State of World populator.
0000000000000000000000000000000000000000;;	func TestPodDeletionWithDswp(t *testing.T) {
0000000000000000000000000000000000000000;;		_, server, closeFn := framework.RunAMaster(framework.NewIntegrationTestMasterConfig())
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;		namespaceName := "test-pod-deletion"
0000000000000000000000000000000000000000;;		node := &v1.Node{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "node-sandbox",
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					volumehelper.ControllerManagedAttachAnnotation: "true",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace(namespaceName, server, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, server, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient, ctrl, informers := createAdClients(ns, t, server, defaultSyncPeriod)
0000000000000000000000000000000000000000;;		pod := fakePodWithVol(namespaceName)
0000000000000000000000000000000000000000;;		podStopCh := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := testClient.Core().Nodes().Create(node); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to created node : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go informers.Core().V1().Nodes().Informer().Run(podStopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := testClient.Core().Pods(ns.Name).Create(pod); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to create pod : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podInformer := informers.Core().V1().Pods().Informer()
0000000000000000000000000000000000000000;;		go podInformer.Run(podStopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// start controller loop
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		go informers.Core().V1().PersistentVolumeClaims().Informer().Run(stopCh)
0000000000000000000000000000000000000000;;		go informers.Core().V1().PersistentVolumes().Informer().Run(stopCh)
0000000000000000000000000000000000000000;;		go ctrl.Run(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitToObservePods(t, podInformer, 1)
0000000000000000000000000000000000000000;;		podKey, err := cache.MetaNamespaceKeyFunc(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("MetaNamespaceKeyFunc failed with : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podInformerObj, _, err := podInformer.GetStore().GetByKey(podKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Pod not found in Pod Informer cache : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitForPodsInDSWP(t, ctrl.GetDesiredStateOfWorld())
0000000000000000000000000000000000000000;;		// let's stop pod events from getting triggered
0000000000000000000000000000000000000000;;		close(podStopCh)
0000000000000000000000000000000000000000;;		err = podInformer.GetStore().Delete(podInformerObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error deleting pod : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitToObservePods(t, podInformer, 0)
0000000000000000000000000000000000000000;;		// the populator loop turns every 1 minute
0000000000000000000000000000000000000000;;		waitForPodFuncInDSWP(t, ctrl.GetDesiredStateOfWorld(), 80*time.Second, "expected 0 pods in dsw after pod delete", 0)
0000000000000000000000000000000000000000;;		close(stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodUpdateWithWithADC(t *testing.T) {
0000000000000000000000000000000000000000;;		_, server, closeFn := framework.RunAMaster(framework.NewIntegrationTestMasterConfig())
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;		namespaceName := "test-pod-update"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node := &v1.Node{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "node-sandbox",
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					volumehelper.ControllerManagedAttachAnnotation: "true",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace(namespaceName, server, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, server, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient, ctrl, informers := createAdClients(ns, t, server, defaultSyncPeriod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := fakePodWithVol(namespaceName)
0000000000000000000000000000000000000000;;		podStopCh := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := testClient.Core().Nodes().Create(node); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to created node : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go informers.Core().V1().Nodes().Informer().Run(podStopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := testClient.Core().Pods(ns.Name).Create(pod); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to create pod : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podInformer := informers.Core().V1().Pods().Informer()
0000000000000000000000000000000000000000;;		go podInformer.Run(podStopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// start controller loop
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		go informers.Core().V1().PersistentVolumeClaims().Informer().Run(stopCh)
0000000000000000000000000000000000000000;;		go informers.Core().V1().PersistentVolumes().Informer().Run(stopCh)
0000000000000000000000000000000000000000;;		go ctrl.Run(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitToObservePods(t, podInformer, 1)
0000000000000000000000000000000000000000;;		podKey, err := cache.MetaNamespaceKeyFunc(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("MetaNamespaceKeyFunc failed with : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, _, err = podInformer.GetStore().GetByKey(podKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Pod not found in Pod Informer cache : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitForPodsInDSWP(t, ctrl.GetDesiredStateOfWorld())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod.Status.Phase = v1.PodSucceeded
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := testClient.Core().Pods(ns.Name).UpdateStatus(pod); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to update pod : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitForPodFuncInDSWP(t, ctrl.GetDesiredStateOfWorld(), 20*time.Second, "expected 0 pods in dsw after pod completion", 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		close(podStopCh)
0000000000000000000000000000000000000000;;		close(stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodUpdateWithKeepTerminatedPodVolumes(t *testing.T) {
0000000000000000000000000000000000000000;;		_, server, closeFn := framework.RunAMaster(framework.NewIntegrationTestMasterConfig())
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;		namespaceName := "test-pod-update"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node := &v1.Node{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "node-sandbox",
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					volumehelper.ControllerManagedAttachAnnotation:  "true",
0000000000000000000000000000000000000000;;					volumehelper.KeepTerminatedPodVolumesAnnotation: "true",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace(namespaceName, server, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, server, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient, ctrl, informers := createAdClients(ns, t, server, defaultSyncPeriod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := fakePodWithVol(namespaceName)
0000000000000000000000000000000000000000;;		podStopCh := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := testClient.Core().Nodes().Create(node); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to created node : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go informers.Core().V1().Nodes().Informer().Run(podStopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := testClient.Core().Pods(ns.Name).Create(pod); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to create pod : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podInformer := informers.Core().V1().Pods().Informer()
0000000000000000000000000000000000000000;;		go podInformer.Run(podStopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// start controller loop
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		go informers.Core().V1().PersistentVolumeClaims().Informer().Run(stopCh)
0000000000000000000000000000000000000000;;		go informers.Core().V1().PersistentVolumes().Informer().Run(stopCh)
0000000000000000000000000000000000000000;;		go ctrl.Run(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitToObservePods(t, podInformer, 1)
0000000000000000000000000000000000000000;;		podKey, err := cache.MetaNamespaceKeyFunc(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("MetaNamespaceKeyFunc failed with : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, _, err = podInformer.GetStore().GetByKey(podKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Pod not found in Pod Informer cache : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitForPodsInDSWP(t, ctrl.GetDesiredStateOfWorld())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod.Status.Phase = v1.PodSucceeded
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := testClient.Core().Pods(ns.Name).UpdateStatus(pod); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to update pod : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitForPodFuncInDSWP(t, ctrl.GetDesiredStateOfWorld(), 20*time.Second, "expected non-zero pods in dsw if KeepTerminatedPodVolumesAnnotation is set", 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		close(podStopCh)
0000000000000000000000000000000000000000;;		close(stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wait for the podInformer to observe the pods. Call this function before
0000000000000000000000000000000000000000;;	// running the RC manager to prevent the rc manager from creating new pods
0000000000000000000000000000000000000000;;	// rather than adopting the existing ones.
0000000000000000000000000000000000000000;;	func waitToObservePods(t *testing.T, podInformer cache.SharedIndexInformer, podNum int) {
0000000000000000000000000000000000000000;;		if err := wait.Poll(100*time.Millisecond, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			objects := podInformer.GetIndexer().List()
0000000000000000000000000000000000000000;;			if len(objects) == podNum {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wait for pods to be observed in desired state of world
0000000000000000000000000000000000000000;;	func waitForPodsInDSWP(t *testing.T, dswp volumecache.DesiredStateOfWorld) {
0000000000000000000000000000000000000000;;		if err := wait.Poll(time.Millisecond*500, wait.ForeverTestTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			pods := dswp.GetPodToAdd()
0000000000000000000000000000000000000000;;			if len(pods) > 0 {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Pod not added to desired state of world : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wait for pods to be observed in desired state of world
0000000000000000000000000000000000000000;;	func waitForPodFuncInDSWP(t *testing.T, dswp volumecache.DesiredStateOfWorld, checkTimeout time.Duration, failMessage string, podCount int) {
0000000000000000000000000000000000000000;;		if err := wait.Poll(time.Millisecond*500, checkTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			pods := dswp.GetPodToAdd()
0000000000000000000000000000000000000000;;			if len(pods) == podCount {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("%s but got error %v", failMessage, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createAdClients(ns *v1.Namespace, t *testing.T, server *httptest.Server, syncPeriod time.Duration) (*clientset.Clientset, attachdetach.AttachDetachController, informers.SharedInformerFactory) {
0000000000000000000000000000000000000000;;		config := restclient.Config{
0000000000000000000000000000000000000000;;			Host:          server.URL,
0000000000000000000000000000000000000000;;			ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion},
0000000000000000000000000000000000000000;;			QPS:           1000000,
0000000000000000000000000000000000000000;;			Burst:         1000000,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resyncPeriod := 12 * time.Hour
0000000000000000000000000000000000000000;;		testClient := clientset.NewForConfigOrDie(&config)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		host := volumetest.NewFakeVolumeHost("/tmp/fake", nil, nil)
0000000000000000000000000000000000000000;;		plugin := &volumetest.FakeVolumePlugin{
0000000000000000000000000000000000000000;;			PluginName:             provisionerPluginName,
0000000000000000000000000000000000000000;;			Host:                   host,
0000000000000000000000000000000000000000;;			Config:                 volume.VolumeConfig{},
0000000000000000000000000000000000000000;;			LastProvisionerOptions: volume.VolumeOptions{},
0000000000000000000000000000000000000000;;			NewAttacherCallCount:   0,
0000000000000000000000000000000000000000;;			NewDetacherCallCount:   0,
0000000000000000000000000000000000000000;;			Mounters:               nil,
0000000000000000000000000000000000000000;;			Unmounters:             nil,
0000000000000000000000000000000000000000;;			Attachers:              nil,
0000000000000000000000000000000000000000;;			Detachers:              nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plugins := []volume.VolumePlugin{plugin}
0000000000000000000000000000000000000000;;		cloud := &fakecloud.FakeCloud{}
0000000000000000000000000000000000000000;;		informers := informers.NewSharedInformerFactory(testClient, resyncPeriod)
0000000000000000000000000000000000000000;;		timers := attachdetach.TimerConfig{
0000000000000000000000000000000000000000;;			ReconcilerLoopPeriod:                              100 * time.Millisecond,
0000000000000000000000000000000000000000;;			ReconcilerMaxWaitForUnmountDuration:               6 * time.Second,
0000000000000000000000000000000000000000;;			DesiredStateOfWorldPopulatorLoopSleepPeriod:       1 * time.Second,
0000000000000000000000000000000000000000;;			DesiredStateOfWorldPopulatorListPodsRetryDuration: 3 * time.Second,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ctrl, err := attachdetach.NewAttachDetachController(
0000000000000000000000000000000000000000;;			testClient,
0000000000000000000000000000000000000000;;			informers.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			informers.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			informers.Core().V1().PersistentVolumeClaims(),
0000000000000000000000000000000000000000;;			informers.Core().V1().PersistentVolumes(),
0000000000000000000000000000000000000000;;			cloud,
0000000000000000000000000000000000000000;;			plugins,
0000000000000000000000000000000000000000;;			false,
0000000000000000000000000000000000000000;;			5*time.Second,
0000000000000000000000000000000000000000;;			timers)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error creating AttachDetach : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return testClient, ctrl, informers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Via integration test we can verify that if pod add
0000000000000000000000000000000000000000;;	// event is somehow missed by AttachDetach controller - it still
0000000000000000000000000000000000000000;;	// gets added by Desired State of World populator.
0000000000000000000000000000000000000000;;	func TestPodAddedByDswp(t *testing.T) {
0000000000000000000000000000000000000000;;		_, server, closeFn := framework.RunAMaster(framework.NewIntegrationTestMasterConfig())
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;		namespaceName := "test-pod-deletion"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node := &v1.Node{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "node-sandbox",
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					volumehelper.ControllerManagedAttachAnnotation: "true",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace(namespaceName, server, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, server, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient, ctrl, informers := createAdClients(ns, t, server, defaultSyncPeriod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := fakePodWithVol(namespaceName)
0000000000000000000000000000000000000000;;		podStopCh := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := testClient.Core().Nodes().Create(node); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to created node : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go informers.Core().V1().Nodes().Informer().Run(podStopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := testClient.Core().Pods(ns.Name).Create(pod); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to create pod : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podInformer := informers.Core().V1().Pods().Informer()
0000000000000000000000000000000000000000;;		go podInformer.Run(podStopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// start controller loop
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		go informers.Core().V1().PersistentVolumeClaims().Informer().Run(stopCh)
0000000000000000000000000000000000000000;;		go informers.Core().V1().PersistentVolumes().Informer().Run(stopCh)
0000000000000000000000000000000000000000;;		go ctrl.Run(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitToObservePods(t, podInformer, 1)
0000000000000000000000000000000000000000;;		podKey, err := cache.MetaNamespaceKeyFunc(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("MetaNamespaceKeyFunc failed with : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, _, err = podInformer.GetStore().GetByKey(podKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Pod not found in Pod Informer cache : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitForPodsInDSWP(t, ctrl.GetDesiredStateOfWorld())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// let's stop pod events from getting triggered
0000000000000000000000000000000000000000;;		close(podStopCh)
0000000000000000000000000000000000000000;;		podObj, err := api.Scheme.DeepCopy(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error copying pod : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podNew, ok := podObj.(*v1.Pod)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("Error converting pod : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newPodName := "newFakepod"
0000000000000000000000000000000000000000;;		podNew.SetName(newPodName)
0000000000000000000000000000000000000000;;		err = podInformer.GetStore().Add(podNew)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error adding pod : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitToObservePods(t, podInformer, 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the findAndAddActivePods loop turns every 3 minute
0000000000000000000000000000000000000000;;		waitForPodFuncInDSWP(t, ctrl.GetDesiredStateOfWorld(), 200*time.Second, "expected 2 pods in dsw after pod addition", 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		close(stopCh)
0000000000000000000000000000000000000000;;	}
