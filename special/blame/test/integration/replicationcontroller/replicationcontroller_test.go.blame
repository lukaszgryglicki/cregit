0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
1d7fd89366610183b0a5af56fda802cd6f9458b7;test/integration/replicationcontroller_test.go[test/integration/replicationcontroller_test.go][test/integration/replicationcontroller/replicationcontroller_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package replicationcontroller
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/replication"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testLabels() map[string]string {
0000000000000000000000000000000000000000;;		return map[string]string{"name": "test"}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRC(name, namespace string, replicas int) *v1.ReplicationController {
0000000000000000000000000000000000000000;;		replicasCopy := int32(replicas)
0000000000000000000000000000000000000000;;		return &v1.ReplicationController{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "ReplicationController",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;				Selector: testLabels(),
0000000000000000000000000000000000000000;;				Replicas: &replicasCopy,
0000000000000000000000000000000000000000;;				Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: testLabels(),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "fake-name",
0000000000000000000000000000000000000000;;								Image: "fakeimage",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMatchingPod(podName, namespace string) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      podName,
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Labels:    testLabels(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "fake-name",
0000000000000000000000000000000000000000;;						Image: "fakeimage",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PodStatus{
0000000000000000000000000000000000000000;;				Phase: v1.PodRunning,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifyRemainingObjects verifies if the number of the remaining replication
0000000000000000000000000000000000000000;;	// controllers and pods are rcNum and podNum. It returns error if the
0000000000000000000000000000000000000000;;	// communication with the API server fails.
0000000000000000000000000000000000000000;;	func verifyRemainingObjects(t *testing.T, clientSet clientset.Interface, namespace string, rcNum, podNum int) (bool, error) {
0000000000000000000000000000000000000000;;		rcClient := clientSet.Core().ReplicationControllers(namespace)
0000000000000000000000000000000000000000;;		podClient := clientSet.Core().Pods(namespace)
0000000000000000000000000000000000000000;;		pods, err := podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Failed to list pods: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var ret = true
0000000000000000000000000000000000000000;;		if len(pods.Items) != podNum {
0000000000000000000000000000000000000000;;			ret = false
0000000000000000000000000000000000000000;;			t.Logf("expect %d pods, got %d pods", podNum, len(pods.Items))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rcs, err := rcClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Failed to list replication controllers: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rcs.Items) != rcNum {
0000000000000000000000000000000000000000;;			ret = false
0000000000000000000000000000000000000000;;			t.Logf("expect %d RCs, got %d RCs", rcNum, len(rcs.Items))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func rmSetup(t *testing.T, stopCh chan struct{}) (*httptest.Server, framework.CloseFunc, *replication.ReplicationManager, informers.SharedInformerFactory, clientset.Interface) {
0000000000000000000000000000000000000000;;		masterConfig := framework.NewIntegrationTestMasterConfig()
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(masterConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := restclient.Config{Host: s.URL}
0000000000000000000000000000000000000000;;		clientSet, err := clientset.NewForConfig(&config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error in create clientset: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resyncPeriod := 12 * time.Hour
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informers := informers.NewSharedInformerFactory(clientSet, resyncPeriod)
0000000000000000000000000000000000000000;;		rm := replication.NewReplicationManager(informers.Core().V1().Pods(), informers.Core().V1().ReplicationControllers(), clientSet, replication.BurstReplicas)
0000000000000000000000000000000000000000;;		informers.Start(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s, closeFn, rm, informers, clientSet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wait for the podInformer to observe the pods. Call this function before
0000000000000000000000000000000000000000;;	// running the RC manager to prevent the rc manager from creating new pods
0000000000000000000000000000000000000000;;	// rather than adopting the existing ones.
0000000000000000000000000000000000000000;;	func waitToObservePods(t *testing.T, podInformer cache.SharedIndexInformer, podNum int) {
0000000000000000000000000000000000000000;;		if err := wait.Poll(10*time.Second, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			objects := podInformer.GetIndexer().List()
0000000000000000000000000000000000000000;;			if len(objects) == podNum {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdoption(t *testing.T) {
0000000000000000000000000000000000000000;;		boolPtr := func(b bool) *bool { return &b }
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			name                    string
0000000000000000000000000000000000000000;;			existingOwnerReferences func(rc *v1.ReplicationController) []metav1.OwnerReference
0000000000000000000000000000000000000000;;			expectedOwnerReferences func(rc *v1.ReplicationController) []metav1.OwnerReference
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"pod refers rc as an owner, not a controller",
0000000000000000000000000000000000000000;;				func(rc *v1.ReplicationController) []metav1.OwnerReference {
0000000000000000000000000000000000000000;;					return []metav1.OwnerReference{{UID: rc.UID, Name: rc.Name, APIVersion: "v1", Kind: "ReplicationController"}}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				func(rc *v1.ReplicationController) []metav1.OwnerReference {
0000000000000000000000000000000000000000;;					return []metav1.OwnerReference{{UID: rc.UID, Name: rc.Name, APIVersion: "v1", Kind: "ReplicationController", Controller: boolPtr(true), BlockOwnerDeletion: boolPtr(true)}}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"pod doesn't have owner references",
0000000000000000000000000000000000000000;;				func(rc *v1.ReplicationController) []metav1.OwnerReference {
0000000000000000000000000000000000000000;;					return []metav1.OwnerReference{}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				func(rc *v1.ReplicationController) []metav1.OwnerReference {
0000000000000000000000000000000000000000;;					return []metav1.OwnerReference{{UID: rc.UID, Name: rc.Name, APIVersion: "v1", Kind: "ReplicationController", Controller: boolPtr(true), BlockOwnerDeletion: boolPtr(true)}}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"pod refers rc as a controller",
0000000000000000000000000000000000000000;;				func(rc *v1.ReplicationController) []metav1.OwnerReference {
0000000000000000000000000000000000000000;;					return []metav1.OwnerReference{{UID: rc.UID, Name: rc.Name, APIVersion: "v1", Kind: "ReplicationController", Controller: boolPtr(true)}}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				func(rc *v1.ReplicationController) []metav1.OwnerReference {
0000000000000000000000000000000000000000;;					return []metav1.OwnerReference{{UID: rc.UID, Name: rc.Name, APIVersion: "v1", Kind: "ReplicationController", Controller: boolPtr(true)}}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"pod refers other rc as the controller, refers the rc as an owner",
0000000000000000000000000000000000000000;;				func(rc *v1.ReplicationController) []metav1.OwnerReference {
0000000000000000000000000000000000000000;;					return []metav1.OwnerReference{
0000000000000000000000000000000000000000;;						{UID: "1", Name: "anotherRC", APIVersion: "v1", Kind: "ReplicationController", Controller: boolPtr(true)},
0000000000000000000000000000000000000000;;						{UID: rc.UID, Name: rc.Name, APIVersion: "v1", Kind: "ReplicationController"},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				func(rc *v1.ReplicationController) []metav1.OwnerReference {
0000000000000000000000000000000000000000;;					return []metav1.OwnerReference{
0000000000000000000000000000000000000000;;						{UID: "1", Name: "anotherRC", APIVersion: "v1", Kind: "ReplicationController", Controller: boolPtr(true)},
0000000000000000000000000000000000000000;;						{UID: rc.UID, Name: rc.Name, APIVersion: "v1", Kind: "ReplicationController"},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;			s, closeFn, rm, informers, clientSet := rmSetup(t, stopCh)
0000000000000000000000000000000000000000;;			defer closeFn()
0000000000000000000000000000000000000000;;			ns := framework.CreateTestingNamespace(fmt.Sprintf("adoption-%d", i), s, t)
0000000000000000000000000000000000000000;;			defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			rcClient := clientSet.Core().ReplicationControllers(ns.Name)
0000000000000000000000000000000000000000;;			podClient := clientSet.Core().Pods(ns.Name)
0000000000000000000000000000000000000000;;			const rcName = "rc"
0000000000000000000000000000000000000000;;			rc, err := rcClient.Create(newRC(rcName, ns.Name, 1))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed to create replication controller: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podName := fmt.Sprintf("pod%d", i)
0000000000000000000000000000000000000000;;			pod := newMatchingPod(podName, ns.Name)
0000000000000000000000000000000000000000;;			pod.OwnerReferences = tc.existingOwnerReferences(rc)
0000000000000000000000000000000000000000;;			_, err = podClient.Create(pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed to create Pod: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			informers.Start(stopCh)
0000000000000000000000000000000000000000;;			waitToObservePods(t, informers.Core().V1().Pods().Informer(), 1)
0000000000000000000000000000000000000000;;			go rm.Run(5, stopCh)
0000000000000000000000000000000000000000;;			if err := wait.Poll(10*time.Second, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;				updatedPod, err := podClient.Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := tc.expectedOwnerReferences(rc), updatedPod.OwnerReferences; reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					t.Logf("ownerReferences don't match, expect %v, got %v", e, a)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("test %q failed: %v", tc.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createRCsPods(t *testing.T, clientSet clientset.Interface, rcs []*v1.ReplicationController, pods []*v1.Pod, ns string) {
0000000000000000000000000000000000000000;;		rcClient := clientSet.Core().ReplicationControllers(ns)
0000000000000000000000000000000000000000;;		podClient := clientSet.Core().Pods(ns)
0000000000000000000000000000000000000000;;		for _, rc := range rcs {
0000000000000000000000000000000000000000;;			if _, err := rcClient.Create(rc); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed to create replication controller %s: %v", rc.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			if _, err := podClient.Create(pod); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed to create pod %s: %v", pod.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitRCStable(t *testing.T, clientSet clientset.Interface, rc *v1.ReplicationController, ns string) {
0000000000000000000000000000000000000000;;		rcClient := clientSet.Core().ReplicationControllers(ns)
0000000000000000000000000000000000000000;;		if err := wait.Poll(10*time.Second, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			updatedRC, err := rcClient.Get(rc.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if updatedRC.Status.Replicas != *rc.Spec.Replicas {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateSelectorToAdopt(t *testing.T) {
0000000000000000000000000000000000000000;;		// We have pod1, pod2 and rc. rc.spec.replicas=1. At first rc.Selector
0000000000000000000000000000000000000000;;		// matches pod1 only; change the selector to match pod2 as well. Verify
0000000000000000000000000000000000000000;;		// there is only one pod left.
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		s, closeFn, rm, _, clientSet := rmSetup(t, stopCh)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("update-selector-to-adopt", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;		rc := newRC("rc", ns.Name, 1)
0000000000000000000000000000000000000000;;		// let rc's selector only match pod1
0000000000000000000000000000000000000000;;		rc.Spec.Selector["uniqueKey"] = "1"
0000000000000000000000000000000000000000;;		rc.Spec.Template.Labels["uniqueKey"] = "1"
0000000000000000000000000000000000000000;;		pod1 := newMatchingPod("pod1", ns.Name)
0000000000000000000000000000000000000000;;		pod1.Labels["uniqueKey"] = "1"
0000000000000000000000000000000000000000;;		pod2 := newMatchingPod("pod2", ns.Name)
0000000000000000000000000000000000000000;;		pod2.Labels["uniqueKey"] = "2"
0000000000000000000000000000000000000000;;		createRCsPods(t, clientSet, []*v1.ReplicationController{rc}, []*v1.Pod{pod1, pod2}, ns.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go rm.Run(5, stopCh)
0000000000000000000000000000000000000000;;		waitRCStable(t, clientSet, rc, ns.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// change the rc's selector to match both pods
0000000000000000000000000000000000000000;;		patch := `{"spec":{"selector":{"uniqueKey":null}}}`
0000000000000000000000000000000000000000;;		rcClient := clientSet.Core().ReplicationControllers(ns.Name)
0000000000000000000000000000000000000000;;		rc, err := rcClient.Patch(rc.Name, types.StrategicMergePatchType, []byte(patch))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to patch replication controller: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Logf("patched rc = %#v", rc)
0000000000000000000000000000000000000000;;		// wait for the rc select both pods and delete one of them
0000000000000000000000000000000000000000;;		if err := wait.Poll(10*time.Second, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			return verifyRemainingObjects(t, clientSet, ns.Name, 1, 1)
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		close(stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateSelectorToRemoveControllerRef(t *testing.T) {
0000000000000000000000000000000000000000;;		// We have pod1, pod2 and rc. rc.spec.replicas=2. At first rc.Selector
0000000000000000000000000000000000000000;;		// matches pod1 and pod2; change the selector to match only pod1. Verify
0000000000000000000000000000000000000000;;		// that rc creates one more pod, so there are 3 pods. Also verify that
0000000000000000000000000000000000000000;;		// pod2's controllerRef is cleared.
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		s, closeFn, rm, informers, clientSet := rmSetup(t, stopCh)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("update-selector-to-remove-controllerref", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;		rc := newRC("rc", ns.Name, 2)
0000000000000000000000000000000000000000;;		pod1 := newMatchingPod("pod1", ns.Name)
0000000000000000000000000000000000000000;;		pod1.Labels["uniqueKey"] = "1"
0000000000000000000000000000000000000000;;		pod2 := newMatchingPod("pod2", ns.Name)
0000000000000000000000000000000000000000;;		pod2.Labels["uniqueKey"] = "2"
0000000000000000000000000000000000000000;;		createRCsPods(t, clientSet, []*v1.ReplicationController{rc}, []*v1.Pod{pod1, pod2}, ns.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitToObservePods(t, informers.Core().V1().Pods().Informer(), 2)
0000000000000000000000000000000000000000;;		go rm.Run(5, stopCh)
0000000000000000000000000000000000000000;;		waitRCStable(t, clientSet, rc, ns.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// change the rc's selector to match both pods
0000000000000000000000000000000000000000;;		patch := `{"spec":{"selector":{"uniqueKey":"1"},"template":{"metadata":{"labels":{"uniqueKey":"1"}}}}}`
0000000000000000000000000000000000000000;;		rcClient := clientSet.Core().ReplicationControllers(ns.Name)
0000000000000000000000000000000000000000;;		rc, err := rcClient.Patch(rc.Name, types.StrategicMergePatchType, []byte(patch))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to patch replication controller: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Logf("patched rc = %#v", rc)
0000000000000000000000000000000000000000;;		// wait for the rc to create one more pod
0000000000000000000000000000000000000000;;		if err := wait.Poll(10*time.Second, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			return verifyRemainingObjects(t, clientSet, ns.Name, 1, 3)
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podClient := clientSet.Core().Pods(ns.Name)
0000000000000000000000000000000000000000;;		pod2, err = podClient.Get(pod2.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to get pod2: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pod2.OwnerReferences) != 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("ownerReferences of pod2 is not cleared, got %#v", pod2.OwnerReferences)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		close(stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateLabelToRemoveControllerRef(t *testing.T) {
0000000000000000000000000000000000000000;;		// We have pod1, pod2 and rc. rc.spec.replicas=2. At first rc.Selector
0000000000000000000000000000000000000000;;		// matches pod1 and pod2; change pod2's labels to non-matching. Verify
0000000000000000000000000000000000000000;;		// that rc creates one more pod, so there are 3 pods. Also verify that
0000000000000000000000000000000000000000;;		// pod2's controllerRef is cleared.
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		s, closeFn, rm, _, clientSet := rmSetup(t, stopCh)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("update-label-to-remove-controllerref", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;		rc := newRC("rc", ns.Name, 2)
0000000000000000000000000000000000000000;;		pod1 := newMatchingPod("pod1", ns.Name)
0000000000000000000000000000000000000000;;		pod2 := newMatchingPod("pod2", ns.Name)
0000000000000000000000000000000000000000;;		createRCsPods(t, clientSet, []*v1.ReplicationController{rc}, []*v1.Pod{pod1, pod2}, ns.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go rm.Run(5, stopCh)
0000000000000000000000000000000000000000;;		waitRCStable(t, clientSet, rc, ns.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// change the rc's selector to match both pods
0000000000000000000000000000000000000000;;		patch := `{"metadata":{"labels":{"name":null}}}`
0000000000000000000000000000000000000000;;		podClient := clientSet.Core().Pods(ns.Name)
0000000000000000000000000000000000000000;;		pod2, err := podClient.Patch(pod2.Name, types.StrategicMergePatchType, []byte(patch))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to patch pod2: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Logf("patched pod2 = %#v", pod2)
0000000000000000000000000000000000000000;;		// wait for the rc to create one more pod
0000000000000000000000000000000000000000;;		if err := wait.Poll(10*time.Second, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			return verifyRemainingObjects(t, clientSet, ns.Name, 1, 3)
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod2, err = podClient.Get(pod2.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to get pod2: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pod2.OwnerReferences) != 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("ownerReferences of pod2 is not cleared, got %#v", pod2.OwnerReferences)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		close(stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateLabelToBeAdopted(t *testing.T) {
0000000000000000000000000000000000000000;;		// We have pod1, pod2 and rc. rc.spec.replicas=1. At first rc.Selector
0000000000000000000000000000000000000000;;		// matches pod1 only; change pod2's labels to be matching. Verify the RC
0000000000000000000000000000000000000000;;		// controller adopts pod2 and delete one of them, so there is only 1 pod
0000000000000000000000000000000000000000;;		// left.
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		s, closeFn, rm, _, clientSet := rmSetup(t, stopCh)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("update-label-to-be-adopted", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;		rc := newRC("rc", ns.Name, 1)
0000000000000000000000000000000000000000;;		// let rc's selector only matches pod1
0000000000000000000000000000000000000000;;		rc.Spec.Selector["uniqueKey"] = "1"
0000000000000000000000000000000000000000;;		rc.Spec.Template.Labels["uniqueKey"] = "1"
0000000000000000000000000000000000000000;;		pod1 := newMatchingPod("pod1", ns.Name)
0000000000000000000000000000000000000000;;		pod1.Labels["uniqueKey"] = "1"
0000000000000000000000000000000000000000;;		pod2 := newMatchingPod("pod2", ns.Name)
0000000000000000000000000000000000000000;;		pod2.Labels["uniqueKey"] = "2"
0000000000000000000000000000000000000000;;		createRCsPods(t, clientSet, []*v1.ReplicationController{rc}, []*v1.Pod{pod1, pod2}, ns.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go rm.Run(5, stopCh)
0000000000000000000000000000000000000000;;		waitRCStable(t, clientSet, rc, ns.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// change the rc's selector to match both pods
0000000000000000000000000000000000000000;;		patch := `{"metadata":{"labels":{"uniqueKey":"1"}}}`
0000000000000000000000000000000000000000;;		podClient := clientSet.Core().Pods(ns.Name)
0000000000000000000000000000000000000000;;		pod2, err := podClient.Patch(pod2.Name, types.StrategicMergePatchType, []byte(patch))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to patch pod2: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Logf("patched pod2 = %#v", pod2)
0000000000000000000000000000000000000000;;		// wait for the rc to select both pods and delete one of them
0000000000000000000000000000000000000000;;		if err := wait.Poll(10*time.Second, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			return verifyRemainingObjects(t, clientSet, ns.Name, 1, 1)
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		close(stopCh)
0000000000000000000000000000000000000000;;	}
