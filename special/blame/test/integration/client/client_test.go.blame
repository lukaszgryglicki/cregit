0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
26b635ce3d5315e8aebd1fddef130bd38f8ee941;test/integration/client_test.go[test/integration/client_test.go][test/integration/client/client_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		rt "runtime"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/version"
0000000000000000000000000000000000000000;;		e2e "k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestClient(t *testing.T) {
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(nil)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := clientset.NewForConfigOrDie(&restclient.Config{Host: s.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("client", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info, err := client.Discovery().ServerVersion()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := version.Get(), *info; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("expected %#v, got %#v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods, err := client.Core().Pods(ns.Name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pods.Items) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("expected no pods, got %#v", pods)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get a validation error
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				GenerateName: "test",
0000000000000000000000000000000000000000;;				Namespace:    ns.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "test",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		got, err := client.Core().Pods(ns.Name).Create(pod)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected non-error: %v", got)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get a created pod
0000000000000000000000000000000000000000;;		pod.Spec.Containers[0].Image = "an-image"
0000000000000000000000000000000000000000;;		got, err = client.Core().Pods(ns.Name).Create(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if got.Name == "" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected empty pod Name %v", got)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pod is shown, but not scheduled
0000000000000000000000000000000000000000;;		pods, err = client.Core().Pods(ns.Name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pods.Items) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected one pod, got %#v", pods)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		actual := pods.Items[0]
0000000000000000000000000000000000000000;;		if actual.Name != got.Name {
0000000000000000000000000000000000000000;;			t.Errorf("expected pod %#v, got %#v", got, actual)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if actual.Spec.NodeName != "" {
0000000000000000000000000000000000000000;;			t.Errorf("expected pod to be unscheduled, got %#v", actual)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAtomicPut(t *testing.T) {
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(nil)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := clientset.NewForConfigOrDie(&restclient.Config{Host: s.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("atomic-put", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rcBody := v1.ReplicationController{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				APIVersion: c.Core().RESTClient().APIVersion().String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "atomicrc",
0000000000000000000000000000000000000000;;				Namespace: ns.Name,
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"name": "atomicrc",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;				Replicas: func(i int32) *int32 { return &i }(0),
0000000000000000000000000000000000000000;;				Selector: map[string]string{
0000000000000000000000000000000000000000;;					"foo": "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"foo": "bar",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{Name: "name", Image: "image"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rcs := c.Core().ReplicationControllers(ns.Name)
0000000000000000000000000000000000000000;;		rc, err := rcs.Create(&rcBody)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed creating atomicRC: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testLabels := labels.Set{
0000000000000000000000000000000000000000;;			"foo": "bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < 5; i++ {
0000000000000000000000000000000000000000;;			// a: z, b: y, etc...
0000000000000000000000000000000000000000;;			testLabels[string([]byte{byte('a' + i)})] = string([]byte{byte('z' - i)})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		wg.Add(len(testLabels))
0000000000000000000000000000000000000000;;		for label, value := range testLabels {
0000000000000000000000000000000000000000;;			go func(l, v string) {
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;				for {
0000000000000000000000000000000000000000;;					tmpRC, err := rcs.Get(rc.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("Error getting atomicRC: %v", err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if tmpRC.Spec.Selector == nil {
0000000000000000000000000000000000000000;;						tmpRC.Spec.Selector = map[string]string{l: v}
0000000000000000000000000000000000000000;;						tmpRC.Spec.Template.Labels = map[string]string{l: v}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						tmpRC.Spec.Selector[l] = v
0000000000000000000000000000000000000000;;						tmpRC.Spec.Template.Labels[l] = v
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					tmpRC, err = rcs.Update(tmpRC)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						if apierrors.IsConflict(err) {
0000000000000000000000000000000000000000;;							// This is what we expect.
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						t.Errorf("Unexpected error putting atomicRC: %v", err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}(label, value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		rc, err = rcs.Get(rc.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed getting atomicRC after writers are complete: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(testLabels, labels.Set(rc.Spec.Selector)) {
0000000000000000000000000000000000000000;;			t.Errorf("Selector PUTs were not atomic: wanted %v, got %v", testLabels, rc.Spec.Selector)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPatch(t *testing.T) {
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(nil)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := clientset.NewForConfigOrDie(&restclient.Config{Host: s.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("patch", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := "patchpod"
0000000000000000000000000000000000000000;;		resource := "pods"
0000000000000000000000000000000000000000;;		podBody := v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				APIVersion: c.Core().RESTClient().APIVersion().String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;				Namespace: ns.Name,
0000000000000000000000000000000000000000;;				Labels:    map[string]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{Name: "name", Image: "image"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pods := c.Core().Pods(ns.Name)
0000000000000000000000000000000000000000;;		pod, err := pods.Create(&podBody)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed creating patchpods: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patchBodies := map[schema.GroupVersion]map[types.PatchType]struct {
0000000000000000000000000000000000000000;;			AddLabelBody        []byte
0000000000000000000000000000000000000000;;			RemoveLabelBody     []byte
0000000000000000000000000000000000000000;;			RemoveAllLabelsBody []byte
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			v1.SchemeGroupVersion: {
0000000000000000000000000000000000000000;;				types.JSONPatchType: {
0000000000000000000000000000000000000000;;					[]byte(`[{"op":"add","path":"/metadata/labels","value":{"foo":"bar","baz":"qux"}}]`),
0000000000000000000000000000000000000000;;					[]byte(`[{"op":"remove","path":"/metadata/labels/foo"}]`),
0000000000000000000000000000000000000000;;					[]byte(`[{"op":"remove","path":"/metadata/labels"}]`),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				types.MergePatchType: {
0000000000000000000000000000000000000000;;					[]byte(`{"metadata":{"labels":{"foo":"bar","baz":"qux"}}}`),
0000000000000000000000000000000000000000;;					[]byte(`{"metadata":{"labels":{"foo":null}}}`),
0000000000000000000000000000000000000000;;					[]byte(`{"metadata":{"labels":null}}`),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				types.StrategicMergePatchType: {
0000000000000000000000000000000000000000;;					[]byte(`{"metadata":{"labels":{"foo":"bar","baz":"qux"}}}`),
0000000000000000000000000000000000000000;;					[]byte(`{"metadata":{"labels":{"foo":null}}}`),
0000000000000000000000000000000000000000;;					[]byte(`{"metadata":{"labels":{"$patch":"replace"}}}`),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pb := patchBodies[c.Core().RESTClient().APIVersion()]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		execPatch := func(pt types.PatchType, body []byte) error {
0000000000000000000000000000000000000000;;			result := c.Core().RESTClient().Patch(pt).
0000000000000000000000000000000000000000;;				Resource(resource).
0000000000000000000000000000000000000000;;				Namespace(ns.Name).
0000000000000000000000000000000000000000;;				Name(name).
0000000000000000000000000000000000000000;;				Body(body).
0000000000000000000000000000000000000000;;				Do()
0000000000000000000000000000000000000000;;			if result.Error() != nil {
0000000000000000000000000000000000000000;;				return result.Error()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// trying to chase flakes, this should give us resource versions of objects as we step through
0000000000000000000000000000000000000000;;			jsonObj, err := result.Raw()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Log(err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				t.Logf("%v", string(jsonObj))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj, err := result.Get()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			metadata, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// this call waits for the resourceVersion to be reached in the cache before returning.  We need to do this because
0000000000000000000000000000000000000000;;			// the patch gets its initial object from the storage, and the cache serves that.  If it is out of date,
0000000000000000000000000000000000000000;;			// then our initial patch is applied to an old resource version, which conflicts and then the updated object shows
0000000000000000000000000000000000000000;;			// a conflicting diff, which permanently fails the patch.  This gives expected stability in the patch without
0000000000000000000000000000000000000000;;			// retrying on an known number of conflicts below in the test.
0000000000000000000000000000000000000000;;			if _, err := c.Core().Pods(ns.Name).Get(name, metav1.GetOptions{ResourceVersion: metadata.GetResourceVersion()}); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range pb {
0000000000000000000000000000000000000000;;			// add label
0000000000000000000000000000000000000000;;			err := execPatch(k, v.AddLabelBody)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed updating patchpod with patch type %s: %v", k, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod, err = pods.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed getting patchpod: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(pod.Labels) != 2 || pod.Labels["foo"] != "bar" || pod.Labels["baz"] != "qux" {
0000000000000000000000000000000000000000;;				t.Errorf("Failed updating patchpod with patch type %s: labels are: %v", k, pod.Labels)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// remove one label
0000000000000000000000000000000000000000;;			err = execPatch(k, v.RemoveLabelBody)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed updating patchpod with patch type %s: %v", k, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod, err = pods.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed getting patchpod: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(pod.Labels) != 1 || pod.Labels["baz"] != "qux" {
0000000000000000000000000000000000000000;;				t.Errorf("Failed updating patchpod with patch type %s: labels are: %v", k, pod.Labels)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// remove all labels
0000000000000000000000000000000000000000;;			err = execPatch(k, v.RemoveAllLabelsBody)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed updating patchpod with patch type %s: %v", k, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod, err = pods.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed getting patchpod: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pod.Labels != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Failed remove all labels from patchpod with patch type %s: %v", k, pod.Labels)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPatchWithCreateOnUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(nil)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := clientset.NewForConfigOrDie(&restclient.Config{Host: s.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("patch-with-create", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpointTemplate := &v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "patchendpoint",
0000000000000000000000000000000000000000;;				Namespace: ns.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Addresses: []v1.EndpointAddress{{IP: "1.2.3.4"}},
0000000000000000000000000000000000000000;;					Ports:     []v1.EndpointPort{{Port: 80, Protocol: v1.ProtocolTCP}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patchEndpoint := func(json []byte) (runtime.Object, error) {
0000000000000000000000000000000000000000;;			return c.Core().RESTClient().Patch(types.MergePatchType).Resource("endpoints").Namespace(ns.Name).Name("patchendpoint").Body(json).Do().Get()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure patch doesn't get to CreateOnUpdate
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			endpointJSON, err := runtime.Encode(api.Codecs.LegacyCodec(v1.SchemeGroupVersion), endpointTemplate)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed creating endpoint JSON: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if obj, err := patchEndpoint(endpointJSON); !apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected notfound creating from patch, got error=%v and object: %#v", err, obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the endpoint (endpoints set AllowCreateOnUpdate=true) to get a UID and resource version
0000000000000000000000000000000000000000;;		createdEndpoint, err := c.Core().Endpoints(ns.Name).Update(endpointTemplate)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed creating endpoint: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure identity patch is accepted
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			endpointJSON, err := runtime.Encode(api.Codecs.LegacyCodec(v1.SchemeGroupVersion), createdEndpoint)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed creating endpoint JSON: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := patchEndpoint(endpointJSON); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Failed patching endpoint: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure patch complains about a mismatched resourceVersion
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			endpointTemplate.Name = ""
0000000000000000000000000000000000000000;;			endpointTemplate.UID = ""
0000000000000000000000000000000000000000;;			endpointTemplate.ResourceVersion = "1"
0000000000000000000000000000000000000000;;			endpointJSON, err := runtime.Encode(api.Codecs.LegacyCodec(v1.SchemeGroupVersion), endpointTemplate)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed creating endpoint JSON: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := patchEndpoint(endpointJSON); !apierrors.IsConflict(err) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected error, got %#v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure patch complains about mutating the UID
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			endpointTemplate.Name = ""
0000000000000000000000000000000000000000;;			endpointTemplate.UID = "abc"
0000000000000000000000000000000000000000;;			endpointTemplate.ResourceVersion = ""
0000000000000000000000000000000000000000;;			endpointJSON, err := runtime.Encode(api.Codecs.LegacyCodec(v1.SchemeGroupVersion), endpointTemplate)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed creating endpoint JSON: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := patchEndpoint(endpointJSON); !apierrors.IsInvalid(err) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected error, got %#v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure patch complains about a mismatched name
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			endpointTemplate.Name = "changedname"
0000000000000000000000000000000000000000;;			endpointTemplate.UID = ""
0000000000000000000000000000000000000000;;			endpointTemplate.ResourceVersion = ""
0000000000000000000000000000000000000000;;			endpointJSON, err := runtime.Encode(api.Codecs.LegacyCodec(v1.SchemeGroupVersion), endpointTemplate)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed creating endpoint JSON: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := patchEndpoint(endpointJSON); !apierrors.IsBadRequest(err) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected error, got %#v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure patch containing originally submitted JSON is accepted
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			endpointTemplate.Name = ""
0000000000000000000000000000000000000000;;			endpointTemplate.UID = ""
0000000000000000000000000000000000000000;;			endpointTemplate.ResourceVersion = ""
0000000000000000000000000000000000000000;;			endpointJSON, err := runtime.Encode(api.Codecs.LegacyCodec(v1.SchemeGroupVersion), endpointTemplate)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed creating endpoint JSON: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := patchEndpoint(endpointJSON); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Failed patching endpoint: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAPIVersions(t *testing.T) {
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(nil)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := clientset.NewForConfigOrDie(&restclient.Config{Host: s.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientVersion := c.Core().RESTClient().APIVersion().String()
0000000000000000000000000000000000000000;;		g, err := c.Discovery().ServerGroups()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to get api versions: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		versions := metav1.ExtractGroupVersions(g)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify that the server supports the API version used by the client.
0000000000000000000000000000000000000000;;		for _, version := range versions {
0000000000000000000000000000000000000000;;			if version == clientVersion {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Errorf("Server does not support APIVersion used by client. Server supported APIVersions: '%v', client APIVersion: '%v'", versions, clientVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSingleWatch(t *testing.T) {
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(nil)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("single-watch", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := clientset.NewForConfigOrDie(&restclient.Config{Host: s.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mkEvent := func(i int) *v1.Event {
0000000000000000000000000000000000000000;;			name := fmt.Sprintf("event-%v", i)
0000000000000000000000000000000000000000;;			return &v1.Event{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: ns.Name,
0000000000000000000000000000000000000000;;					Name:      name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				InvolvedObject: v1.ObjectReference{
0000000000000000000000000000000000000000;;					Namespace: ns.Name,
0000000000000000000000000000000000000000;;					Name:      name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Reason: fmt.Sprintf("event %v", i),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rv1 := ""
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;			event := mkEvent(i)
0000000000000000000000000000000000000000;;			got, err := client.Core().Events(ns.Name).Create(event)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed creating event %#q: %v", event, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rv1 == "" {
0000000000000000000000000000000000000000;;				rv1 = got.ResourceVersion
0000000000000000000000000000000000000000;;				if rv1 == "" {
0000000000000000000000000000000000000000;;					t.Fatal("did not get a resource version.")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Logf("Created event %#v", got.ObjectMeta)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w, err := client.Core().RESTClient().Get().
0000000000000000000000000000000000000000;;			Namespace(ns.Name).
0000000000000000000000000000000000000000;;			Resource("events").
0000000000000000000000000000000000000000;;			Param("resourceVersion", rv1).
0000000000000000000000000000000000000000;;			Param("watch", "true").
0000000000000000000000000000000000000000;;			FieldsSelectorParam(fields.OneTermEqualSelector("metadata.name", "event-9")).
0000000000000000000000000000000000000000;;			Watch()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed watch: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer w.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Fatalf("watch took longer than %s", wait.ForeverTestTimeout.String())
0000000000000000000000000000000000000000;;		case got, ok := <-w.ResultChan():
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				t.Fatal("Watch channel closed unexpectedly.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We expect to see an ADD of event-9 and only event-9. (This
0000000000000000000000000000000000000000;;			// catches a bug where all the events would have been sent down
0000000000000000000000000000000000000000;;			// the channel.)
0000000000000000000000000000000000000000;;			if e, a := watch.Added, got.Type; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("Wanted %v, got %v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch o := got.Object.(type) {
0000000000000000000000000000000000000000;;			case *v1.Event:
0000000000000000000000000000000000000000;;				if e, a := "event-9", o.Name; e != a {
0000000000000000000000000000000000000000;;					t.Errorf("Wanted %v, got %v", e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected watch event containing object %#q", got)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMultiWatch(t *testing.T) {
0000000000000000000000000000000000000000;;		// Disable this test as long as it demonstrates a problem.
0000000000000000000000000000000000000000;;		// TODO: Reenable this test when we get #6059 resolved.
0000000000000000000000000000000000000000;;		t.Skip()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const watcherCount = 50
0000000000000000000000000000000000000000;;		rt.GOMAXPROCS(watcherCount)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(nil)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("multi-watch", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := clientset.NewForConfigOrDie(&restclient.Config{Host: s.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dummyEvent := func(i int) *v1.Event {
0000000000000000000000000000000000000000;;			name := fmt.Sprintf("unrelated-%v", i)
0000000000000000000000000000000000000000;;			return &v1.Event{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      fmt.Sprintf("%v.%x", name, time.Now().UnixNano()),
0000000000000000000000000000000000000000;;					Namespace: ns.Name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				InvolvedObject: v1.ObjectReference{
0000000000000000000000000000000000000000;;					Name:      name,
0000000000000000000000000000000000000000;;					Namespace: ns.Name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Reason: fmt.Sprintf("unrelated change %v", i),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type timePair struct {
0000000000000000000000000000000000000000;;			t    time.Time
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		receivedTimes := make(chan timePair, watcherCount*2)
0000000000000000000000000000000000000000;;		watchesStarted := sync.WaitGroup{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// make a bunch of pods and watch them
0000000000000000000000000000000000000000;;		for i := 0; i < watcherCount; i++ {
0000000000000000000000000000000000000000;;			watchesStarted.Add(1)
0000000000000000000000000000000000000000;;			name := fmt.Sprintf("multi-watch-%v", i)
0000000000000000000000000000000000000000;;			got, err := client.Core().Pods(ns.Name).Create(&v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:   name,
0000000000000000000000000000000000000000;;					Labels: labels.Set{"watchlabel": name},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{{
0000000000000000000000000000000000000000;;						Name:  "pause",
0000000000000000000000000000000000000000;;						Image: e2e.GetPauseImageName(client),
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Couldn't make %v: %v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			go func(name, rv string) {
0000000000000000000000000000000000000000;;				options := metav1.ListOptions{
0000000000000000000000000000000000000000;;					LabelSelector:   labels.Set{"watchlabel": name}.AsSelector().String(),
0000000000000000000000000000000000000000;;					ResourceVersion: rv,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w, err := client.Core().Pods(ns.Name).Watch(options)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					panic(fmt.Sprintf("watch error for %v: %v", name, err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer w.Stop()
0000000000000000000000000000000000000000;;				watchesStarted.Done()
0000000000000000000000000000000000000000;;				e, ok := <-w.ResultChan() // should get the update (that we'll do below)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					panic(fmt.Sprintf("%v ended early?", name))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e.Type != watch.Modified {
0000000000000000000000000000000000000000;;					panic(fmt.Sprintf("Got unexpected watch notification:\n%v: %+v %+v", name, e, e.Object))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				receivedTimes <- timePair{time.Now(), name}
0000000000000000000000000000000000000000;;			}(name, got.ObjectMeta.ResourceVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		log.Printf("%v: %v pods made and watchers started", time.Now(), watcherCount)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait for watches to start before we start spamming the system with
0000000000000000000000000000000000000000;;		// objects below, otherwise we'll hit the watch window restriction.
0000000000000000000000000000000000000000;;		watchesStarted.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			useEventsAsUnrelatedType = false
0000000000000000000000000000000000000000;;			usePodsAsUnrelatedType   = true
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// make a bunch of unrelated changes in parallel
0000000000000000000000000000000000000000;;		if useEventsAsUnrelatedType {
0000000000000000000000000000000000000000;;			const unrelatedCount = 3000
0000000000000000000000000000000000000000;;			var wg sync.WaitGroup
0000000000000000000000000000000000000000;;			defer wg.Wait()
0000000000000000000000000000000000000000;;			changeToMake := make(chan int, unrelatedCount*2)
0000000000000000000000000000000000000000;;			changeMade := make(chan int, unrelatedCount*2)
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				for i := 0; i < unrelatedCount; i++ {
0000000000000000000000000000000000000000;;					changeToMake <- i
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				close(changeToMake)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			for i := 0; i < 50; i++ {
0000000000000000000000000000000000000000;;				wg.Add(1)
0000000000000000000000000000000000000000;;				go func() {
0000000000000000000000000000000000000000;;					defer wg.Done()
0000000000000000000000000000000000000000;;					for {
0000000000000000000000000000000000000000;;						i, ok := <-changeToMake
0000000000000000000000000000000000000000;;						if !ok {
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if _, err := client.Core().Events(ns.Name).Create(dummyEvent(i)); err != nil {
0000000000000000000000000000000000000000;;							panic(fmt.Sprintf("couldn't make an event: %v", err))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						changeMade <- i
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i := 0; i < 2000; i++ {
0000000000000000000000000000000000000000;;				<-changeMade
0000000000000000000000000000000000000000;;				if (i+1)%50 == 0 {
0000000000000000000000000000000000000000;;					log.Printf("%v: %v unrelated changes made", time.Now(), i+1)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if usePodsAsUnrelatedType {
0000000000000000000000000000000000000000;;			const unrelatedCount = 3000
0000000000000000000000000000000000000000;;			var wg sync.WaitGroup
0000000000000000000000000000000000000000;;			defer wg.Wait()
0000000000000000000000000000000000000000;;			changeToMake := make(chan int, unrelatedCount*2)
0000000000000000000000000000000000000000;;			changeMade := make(chan int, unrelatedCount*2)
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				for i := 0; i < unrelatedCount; i++ {
0000000000000000000000000000000000000000;;					changeToMake <- i
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				close(changeToMake)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			for i := 0; i < 50; i++ {
0000000000000000000000000000000000000000;;				wg.Add(1)
0000000000000000000000000000000000000000;;				go func() {
0000000000000000000000000000000000000000;;					defer wg.Done()
0000000000000000000000000000000000000000;;					for {
0000000000000000000000000000000000000000;;						i, ok := <-changeToMake
0000000000000000000000000000000000000000;;						if !ok {
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						name := fmt.Sprintf("unrelated-%v", i)
0000000000000000000000000000000000000000;;						_, err := client.Core().Pods(ns.Name).Create(&v1.Pod{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name: name,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;								Containers: []v1.Container{{
0000000000000000000000000000000000000000;;									Name:  "nothing",
0000000000000000000000000000000000000000;;									Image: e2e.GetPauseImageName(client),
0000000000000000000000000000000000000000;;								}},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							panic(fmt.Sprintf("couldn't make unrelated pod: %v", err))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						changeMade <- i
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i := 0; i < 2000; i++ {
0000000000000000000000000000000000000000;;				<-changeMade
0000000000000000000000000000000000000000;;				if (i+1)%50 == 0 {
0000000000000000000000000000000000000000;;					log.Printf("%v: %v unrelated changes made", time.Now(), i+1)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now we still have changes being made in parallel, but at least 1000 have been made.
0000000000000000000000000000000000000000;;		// Make some updates to send down the watches.
0000000000000000000000000000000000000000;;		sentTimes := make(chan timePair, watcherCount*2)
0000000000000000000000000000000000000000;;		for i := 0; i < watcherCount; i++ {
0000000000000000000000000000000000000000;;			go func(i int) {
0000000000000000000000000000000000000000;;				name := fmt.Sprintf("multi-watch-%v", i)
0000000000000000000000000000000000000000;;				pod, err := client.Core().Pods(ns.Name).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					panic(fmt.Sprintf("Couldn't get %v: %v", name, err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pod.Spec.Containers[0].Image = e2e.GetPauseImageName(client)
0000000000000000000000000000000000000000;;				sentTimes <- timePair{time.Now(), name}
0000000000000000000000000000000000000000;;				if _, err := client.Core().Pods(ns.Name).Update(pod); err != nil {
0000000000000000000000000000000000000000;;					panic(fmt.Sprintf("Couldn't make %v: %v", name, err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sent := map[string]time.Time{}
0000000000000000000000000000000000000000;;		for i := 0; i < watcherCount; i++ {
0000000000000000000000000000000000000000;;			tp := <-sentTimes
0000000000000000000000000000000000000000;;			sent[tp.name] = tp.t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		log.Printf("all changes made")
0000000000000000000000000000000000000000;;		dur := map[string]time.Duration{}
0000000000000000000000000000000000000000;;		for i := 0; i < watcherCount; i++ {
0000000000000000000000000000000000000000;;			tp := <-receivedTimes
0000000000000000000000000000000000000000;;			delta := tp.t.Sub(sent[tp.name])
0000000000000000000000000000000000000000;;			dur[tp.name] = delta
0000000000000000000000000000000000000000;;			log.Printf("%v: %v", tp.name, delta)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		log.Printf("all watches ended")
0000000000000000000000000000000000000000;;		t.Errorf("durations: %v", dur)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func runSelfLinkTestOnNamespace(t *testing.T, c clientset.Interface, namespace string) {
0000000000000000000000000000000000000000;;		podBody := v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "selflinktest",
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"name": "selflinktest",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{Name: "name", Image: "image"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod, err := c.Core().Pods(namespace).Create(&podBody)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed creating selflinktest pod: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = c.Core().RESTClient().Get().RequestURI(pod.SelfLink).Do().Into(pod); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed listing pod with supplied self link '%v': %v", pod.SelfLink, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podList, err := c.Core().Pods(namespace).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed listing pods: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = c.Core().RESTClient().Get().RequestURI(podList.SelfLink).Do().Into(podList); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed listing pods with supplied self link '%v': %v", podList.SelfLink, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		found := false
0000000000000000000000000000000000000000;;		for i := range podList.Items {
0000000000000000000000000000000000000000;;			item := &podList.Items[i]
0000000000000000000000000000000000000000;;			if item.Name != "selflinktest" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			found = true
0000000000000000000000000000000000000000;;			err = c.Core().RESTClient().Get().RequestURI(item.SelfLink).Do().Into(pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Failed listing pod with supplied self link '%v': %v", item.SelfLink, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			t.Errorf("never found selflinktest pod in namespace %s", namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSelfLinkOnNamespace(t *testing.T) {
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(nil)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("selflink", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := clientset.NewForConfigOrDie(&restclient.Config{Host: s.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runSelfLinkTestOnNamespace(t, c, ns.Name)
0000000000000000000000000000000000000000;;	}
