0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
1d7fd89366610183b0a5af56fda802cd6f9458b7;test/integration/replicationcontroller_test.go[test/integration/replicationcontroller_test.go][test/integration/replicaset/replicaset_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package replicaset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/replicaset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testLabels() map[string]string {
0000000000000000000000000000000000000000;;		return map[string]string{"name": "test"}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRS(name, namespace string, replicas int) *v1beta1.ReplicaSet {
0000000000000000000000000000000000000000;;		replicasCopy := int32(replicas)
0000000000000000000000000000000000000000;;		return &v1beta1.ReplicaSet{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "ReplicaSet",
0000000000000000000000000000000000000000;;				APIVersion: "extensions/v1beta1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1beta1.ReplicaSetSpec{
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;					MatchLabels: testLabels(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Replicas: &replicasCopy,
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: testLabels(),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "fake-name",
0000000000000000000000000000000000000000;;								Image: "fakeimage",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMatchingPod(podName, namespace string) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      podName,
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Labels:    testLabels(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "fake-name",
0000000000000000000000000000000000000000;;						Image: "fakeimage",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PodStatus{
0000000000000000000000000000000000000000;;				Phase: v1.PodRunning,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifyRemainingObjects verifies if the number of the remaining replica
0000000000000000000000000000000000000000;;	// sets and pods are rsNum and podNum. It returns error if the
0000000000000000000000000000000000000000;;	// communication with the API server fails.
0000000000000000000000000000000000000000;;	func verifyRemainingObjects(t *testing.T, clientSet clientset.Interface, namespace string, rsNum, podNum int) (bool, error) {
0000000000000000000000000000000000000000;;		rsClient := clientSet.Extensions().ReplicaSets(namespace)
0000000000000000000000000000000000000000;;		podClient := clientSet.Core().Pods(namespace)
0000000000000000000000000000000000000000;;		pods, err := podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Failed to list pods: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var ret = true
0000000000000000000000000000000000000000;;		if len(pods.Items) != podNum {
0000000000000000000000000000000000000000;;			ret = false
0000000000000000000000000000000000000000;;			t.Logf("expect %d pods, got %d pods", podNum, len(pods.Items))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rss, err := rsClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Failed to list replica sets: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rss.Items) != rsNum {
0000000000000000000000000000000000000000;;			ret = false
0000000000000000000000000000000000000000;;			t.Logf("expect %d RSs, got %d RSs", rsNum, len(rss.Items))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func rmSetup(t *testing.T) (*httptest.Server, framework.CloseFunc, *replicaset.ReplicaSetController, informers.SharedInformerFactory, clientset.Interface) {
0000000000000000000000000000000000000000;;		masterConfig := framework.NewIntegrationTestMasterConfig()
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(masterConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := restclient.Config{Host: s.URL}
0000000000000000000000000000000000000000;;		clientSet, err := clientset.NewForConfig(&config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error in create clientset: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resyncPeriod := 12 * time.Hour
0000000000000000000000000000000000000000;;		informers := informers.NewSharedInformerFactory(clientset.NewForConfigOrDie(restclient.AddUserAgent(&config, "rs-informers")), resyncPeriod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rm := replicaset.NewReplicaSetController(
0000000000000000000000000000000000000000;;			informers.Extensions().V1beta1().ReplicaSets(),
0000000000000000000000000000000000000000;;			informers.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			clientset.NewForConfigOrDie(restclient.AddUserAgent(&config, "replicaset-controller")),
0000000000000000000000000000000000000000;;			replicaset.BurstReplicas,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create replicaset controller")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s, closeFn, rm, informers, clientSet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wait for the podInformer to observe the pods. Call this function before
0000000000000000000000000000000000000000;;	// running the RS controller to prevent the rc manager from creating new pods
0000000000000000000000000000000000000000;;	// rather than adopting the existing ones.
0000000000000000000000000000000000000000;;	func waitToObservePods(t *testing.T, podInformer cache.SharedIndexInformer, podNum int) {
0000000000000000000000000000000000000000;;		if err := wait.Poll(10*time.Second, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			objects := podInformer.GetIndexer().List()
0000000000000000000000000000000000000000;;			if len(objects) == podNum {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdoption(t *testing.T) {
0000000000000000000000000000000000000000;;		boolPtr := func(b bool) *bool { return &b }
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			name                    string
0000000000000000000000000000000000000000;;			existingOwnerReferences func(rs *v1beta1.ReplicaSet) []metav1.OwnerReference
0000000000000000000000000000000000000000;;			expectedOwnerReferences func(rs *v1beta1.ReplicaSet) []metav1.OwnerReference
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"pod refers rs as an owner, not a controller",
0000000000000000000000000000000000000000;;				func(rs *v1beta1.ReplicaSet) []metav1.OwnerReference {
0000000000000000000000000000000000000000;;					return []metav1.OwnerReference{{UID: rs.UID, Name: rs.Name, APIVersion: "extensions/v1beta1", Kind: "ReplicaSet"}}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				func(rs *v1beta1.ReplicaSet) []metav1.OwnerReference {
0000000000000000000000000000000000000000;;					return []metav1.OwnerReference{{UID: rs.UID, Name: rs.Name, APIVersion: "extensions/v1beta1", Kind: "ReplicaSet", Controller: boolPtr(true), BlockOwnerDeletion: boolPtr(true)}}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"pod doesn't have owner references",
0000000000000000000000000000000000000000;;				func(rs *v1beta1.ReplicaSet) []metav1.OwnerReference {
0000000000000000000000000000000000000000;;					return []metav1.OwnerReference{}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				func(rs *v1beta1.ReplicaSet) []metav1.OwnerReference {
0000000000000000000000000000000000000000;;					return []metav1.OwnerReference{{UID: rs.UID, Name: rs.Name, APIVersion: "extensions/v1beta1", Kind: "ReplicaSet", Controller: boolPtr(true), BlockOwnerDeletion: boolPtr(true)}}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"pod refers rs as a controller",
0000000000000000000000000000000000000000;;				func(rs *v1beta1.ReplicaSet) []metav1.OwnerReference {
0000000000000000000000000000000000000000;;					return []metav1.OwnerReference{{UID: rs.UID, Name: rs.Name, APIVersion: "extensions/v1beta1", Kind: "ReplicaSet", Controller: boolPtr(true)}}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				func(rs *v1beta1.ReplicaSet) []metav1.OwnerReference {
0000000000000000000000000000000000000000;;					return []metav1.OwnerReference{{UID: rs.UID, Name: rs.Name, APIVersion: "extensions/v1beta1", Kind: "ReplicaSet", Controller: boolPtr(true)}}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"pod refers other rs as the controller, refers the rs as an owner",
0000000000000000000000000000000000000000;;				func(rs *v1beta1.ReplicaSet) []metav1.OwnerReference {
0000000000000000000000000000000000000000;;					return []metav1.OwnerReference{
0000000000000000000000000000000000000000;;						{UID: "1", Name: "anotherRS", APIVersion: "extensions/v1beta1", Kind: "ReplicaSet", Controller: boolPtr(true)},
0000000000000000000000000000000000000000;;						{UID: rs.UID, Name: rs.Name, APIVersion: "extensions/v1beta1", Kind: "ReplicaSet"},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				func(rs *v1beta1.ReplicaSet) []metav1.OwnerReference {
0000000000000000000000000000000000000000;;					return []metav1.OwnerReference{
0000000000000000000000000000000000000000;;						{UID: "1", Name: "anotherRS", APIVersion: "extensions/v1beta1", Kind: "ReplicaSet", Controller: boolPtr(true)},
0000000000000000000000000000000000000000;;						{UID: rs.UID, Name: rs.Name, APIVersion: "extensions/v1beta1", Kind: "ReplicaSet"},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			s, closeFn, rm, informers, clientSet := rmSetup(t)
0000000000000000000000000000000000000000;;			defer closeFn()
0000000000000000000000000000000000000000;;			podInformer := informers.Core().V1().Pods().Informer()
0000000000000000000000000000000000000000;;			ns := framework.CreateTestingNamespace(fmt.Sprintf("rs-adoption-%d", i), s, t)
0000000000000000000000000000000000000000;;			defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			rsClient := clientSet.Extensions().ReplicaSets(ns.Name)
0000000000000000000000000000000000000000;;			podClient := clientSet.Core().Pods(ns.Name)
0000000000000000000000000000000000000000;;			const rsName = "rs"
0000000000000000000000000000000000000000;;			rs, err := rsClient.Create(newRS(rsName, ns.Name, 1))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed to create replica set: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podName := fmt.Sprintf("pod%d", i)
0000000000000000000000000000000000000000;;			pod := newMatchingPod(podName, ns.Name)
0000000000000000000000000000000000000000;;			pod.OwnerReferences = tc.existingOwnerReferences(rs)
0000000000000000000000000000000000000000;;			_, err = podClient.Create(pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed to create Pod: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;			informers.Start(stopCh)
0000000000000000000000000000000000000000;;			waitToObservePods(t, podInformer, 1)
0000000000000000000000000000000000000000;;			go rm.Run(5, stopCh)
0000000000000000000000000000000000000000;;			if err := wait.Poll(10*time.Second, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;				updatedPod, err := podClient.Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := tc.expectedOwnerReferences(rs), updatedPod.OwnerReferences; reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					t.Logf("ownerReferences don't match, expect %v, got %v", e, a)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("test %q failed: %v", tc.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createRSsPods(t *testing.T, clientSet clientset.Interface, rss []*v1beta1.ReplicaSet, pods []*v1.Pod, ns string) {
0000000000000000000000000000000000000000;;		rsClient := clientSet.Extensions().ReplicaSets(ns)
0000000000000000000000000000000000000000;;		podClient := clientSet.Core().Pods(ns)
0000000000000000000000000000000000000000;;		for _, rs := range rss {
0000000000000000000000000000000000000000;;			if _, err := rsClient.Create(rs); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed to create replica set %s: %v", rs.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			if _, err := podClient.Create(pod); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed to create pod %s: %v", pod.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitRSStable(t *testing.T, clientSet clientset.Interface, rs *v1beta1.ReplicaSet, ns string) {
0000000000000000000000000000000000000000;;		rsClient := clientSet.Extensions().ReplicaSets(ns)
0000000000000000000000000000000000000000;;		if err := wait.Poll(10*time.Second, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			updatedRS, err := rsClient.Get(rs.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if updatedRS.Status.Replicas != *rs.Spec.Replicas {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateSelectorToAdopt(t *testing.T) {
0000000000000000000000000000000000000000;;		// We have pod1, pod2 and rs. rs.spec.replicas=1. At first rs.Selector
0000000000000000000000000000000000000000;;		// matches pod1 only; change the selector to match pod2 as well. Verify
0000000000000000000000000000000000000000;;		// there is only one pod left.
0000000000000000000000000000000000000000;;		s, closeFn, rm, informers, clientSet := rmSetup(t)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("rs-update-selector-to-adopt", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;		rs := newRS("rs", ns.Name, 1)
0000000000000000000000000000000000000000;;		// let rs's selector only match pod1
0000000000000000000000000000000000000000;;		rs.Spec.Selector.MatchLabels["uniqueKey"] = "1"
0000000000000000000000000000000000000000;;		rs.Spec.Template.Labels["uniqueKey"] = "1"
0000000000000000000000000000000000000000;;		pod1 := newMatchingPod("pod1", ns.Name)
0000000000000000000000000000000000000000;;		pod1.Labels["uniqueKey"] = "1"
0000000000000000000000000000000000000000;;		pod2 := newMatchingPod("pod2", ns.Name)
0000000000000000000000000000000000000000;;		pod2.Labels["uniqueKey"] = "2"
0000000000000000000000000000000000000000;;		createRSsPods(t, clientSet, []*v1beta1.ReplicaSet{rs}, []*v1.Pod{pod1, pod2}, ns.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		informers.Start(stopCh)
0000000000000000000000000000000000000000;;		go rm.Run(5, stopCh)
0000000000000000000000000000000000000000;;		waitRSStable(t, clientSet, rs, ns.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// change the rs's selector to match both pods
0000000000000000000000000000000000000000;;		patch := `{"spec":{"selector":{"matchLabels": {"uniqueKey":null}}}}`
0000000000000000000000000000000000000000;;		rsClient := clientSet.Extensions().ReplicaSets(ns.Name)
0000000000000000000000000000000000000000;;		rs, err := rsClient.Patch(rs.Name, types.StrategicMergePatchType, []byte(patch))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to patch replica set: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Logf("patched rs = %#v", rs)
0000000000000000000000000000000000000000;;		// wait for the rs select both pods and delete one of them
0000000000000000000000000000000000000000;;		if err := wait.Poll(10*time.Second, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			return verifyRemainingObjects(t, clientSet, ns.Name, 1, 1)
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		close(stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateSelectorToRemoveControllerRef(t *testing.T) {
0000000000000000000000000000000000000000;;		// We have pod1, pod2 and rs. rs.spec.replicas=2. At first rs.Selector
0000000000000000000000000000000000000000;;		// matches pod1 and pod2; change the selector to match only pod1. Verify
0000000000000000000000000000000000000000;;		// that rs creates one more pod, so there are 3 pods. Also verify that
0000000000000000000000000000000000000000;;		// pod2's controllerRef is cleared.
0000000000000000000000000000000000000000;;		s, closeFn, rm, informers, clientSet := rmSetup(t)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;		podInformer := informers.Core().V1().Pods().Informer()
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("rs-update-selector-to-remove-controllerref", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;		rs := newRS("rs", ns.Name, 2)
0000000000000000000000000000000000000000;;		pod1 := newMatchingPod("pod1", ns.Name)
0000000000000000000000000000000000000000;;		pod1.Labels["uniqueKey"] = "1"
0000000000000000000000000000000000000000;;		pod2 := newMatchingPod("pod2", ns.Name)
0000000000000000000000000000000000000000;;		pod2.Labels["uniqueKey"] = "2"
0000000000000000000000000000000000000000;;		createRSsPods(t, clientSet, []*v1beta1.ReplicaSet{rs}, []*v1.Pod{pod1, pod2}, ns.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		informers.Start(stopCh)
0000000000000000000000000000000000000000;;		waitToObservePods(t, podInformer, 2)
0000000000000000000000000000000000000000;;		go rm.Run(5, stopCh)
0000000000000000000000000000000000000000;;		waitRSStable(t, clientSet, rs, ns.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// change the rs's selector to match both pods
0000000000000000000000000000000000000000;;		patch := `{"spec":{"selector":{"matchLabels": {"uniqueKey":"1"}},"template":{"metadata":{"labels":{"uniqueKey":"1"}}}}}`
0000000000000000000000000000000000000000;;		rsClient := clientSet.Extensions().ReplicaSets(ns.Name)
0000000000000000000000000000000000000000;;		rs, err := rsClient.Patch(rs.Name, types.StrategicMergePatchType, []byte(patch))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to patch replica set: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Logf("patched rs = %#v", rs)
0000000000000000000000000000000000000000;;		// wait for the rs to create one more pod
0000000000000000000000000000000000000000;;		if err := wait.Poll(10*time.Second, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			return verifyRemainingObjects(t, clientSet, ns.Name, 1, 3)
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podClient := clientSet.Core().Pods(ns.Name)
0000000000000000000000000000000000000000;;		pod2, err = podClient.Get(pod2.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to get pod2: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pod2.OwnerReferences) != 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("ownerReferences of pod2 is not cleared, got %#v", pod2.OwnerReferences)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		close(stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateLabelToRemoveControllerRef(t *testing.T) {
0000000000000000000000000000000000000000;;		// We have pod1, pod2 and rs. rs.spec.replicas=2. At first rs.Selector
0000000000000000000000000000000000000000;;		// matches pod1 and pod2; change pod2's labels to non-matching. Verify
0000000000000000000000000000000000000000;;		// that rs creates one more pod, so there are 3 pods. Also verify that
0000000000000000000000000000000000000000;;		// pod2's controllerRef is cleared.
0000000000000000000000000000000000000000;;		s, closeFn, rm, informers, clientSet := rmSetup(t)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("rs-update-label-to-remove-controllerref", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;		rs := newRS("rs", ns.Name, 2)
0000000000000000000000000000000000000000;;		pod1 := newMatchingPod("pod1", ns.Name)
0000000000000000000000000000000000000000;;		pod2 := newMatchingPod("pod2", ns.Name)
0000000000000000000000000000000000000000;;		createRSsPods(t, clientSet, []*v1beta1.ReplicaSet{rs}, []*v1.Pod{pod1, pod2}, ns.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		informers.Start(stopCh)
0000000000000000000000000000000000000000;;		go rm.Run(5, stopCh)
0000000000000000000000000000000000000000;;		waitRSStable(t, clientSet, rs, ns.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// change the rs's selector to match both pods
0000000000000000000000000000000000000000;;		patch := `{"metadata":{"labels":{"name":null}}}`
0000000000000000000000000000000000000000;;		podClient := clientSet.Core().Pods(ns.Name)
0000000000000000000000000000000000000000;;		pod2, err := podClient.Patch(pod2.Name, types.StrategicMergePatchType, []byte(patch))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to patch pod2: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Logf("patched pod2 = %#v", pod2)
0000000000000000000000000000000000000000;;		// wait for the rs to create one more pod
0000000000000000000000000000000000000000;;		if err := wait.Poll(10*time.Second, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			return verifyRemainingObjects(t, clientSet, ns.Name, 1, 3)
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod2, err = podClient.Get(pod2.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to get pod2: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pod2.OwnerReferences) != 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("ownerReferences of pod2 is not cleared, got %#v", pod2.OwnerReferences)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		close(stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateLabelToBeAdopted(t *testing.T) {
0000000000000000000000000000000000000000;;		// We have pod1, pod2 and rs. rs.spec.replicas=1. At first rs.Selector
0000000000000000000000000000000000000000;;		// matches pod1 only; change pod2's labels to be matching. Verify the RS
0000000000000000000000000000000000000000;;		// controller adopts pod2 and delete one of them, so there is only 1 pod
0000000000000000000000000000000000000000;;		// left.
0000000000000000000000000000000000000000;;		s, closeFn, rm, informers, clientSet := rmSetup(t)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("rs-update-label-to-be-adopted", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;		rs := newRS("rs", ns.Name, 1)
0000000000000000000000000000000000000000;;		// let rs's selector only matches pod1
0000000000000000000000000000000000000000;;		rs.Spec.Selector.MatchLabels["uniqueKey"] = "1"
0000000000000000000000000000000000000000;;		rs.Spec.Template.Labels["uniqueKey"] = "1"
0000000000000000000000000000000000000000;;		pod1 := newMatchingPod("pod1", ns.Name)
0000000000000000000000000000000000000000;;		pod1.Labels["uniqueKey"] = "1"
0000000000000000000000000000000000000000;;		pod2 := newMatchingPod("pod2", ns.Name)
0000000000000000000000000000000000000000;;		pod2.Labels["uniqueKey"] = "2"
0000000000000000000000000000000000000000;;		createRSsPods(t, clientSet, []*v1beta1.ReplicaSet{rs}, []*v1.Pod{pod1, pod2}, ns.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		informers.Start(stopCh)
0000000000000000000000000000000000000000;;		go rm.Run(5, stopCh)
0000000000000000000000000000000000000000;;		waitRSStable(t, clientSet, rs, ns.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// change the rs's selector to match both pods
0000000000000000000000000000000000000000;;		patch := `{"metadata":{"labels":{"uniqueKey":"1"}}}`
0000000000000000000000000000000000000000;;		podClient := clientSet.Core().Pods(ns.Name)
0000000000000000000000000000000000000000;;		pod2, err := podClient.Patch(pod2.Name, types.StrategicMergePatchType, []byte(patch))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to patch pod2: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Logf("patched pod2 = %#v", pod2)
0000000000000000000000000000000000000000;;		// wait for the rs to select both pods and delete one of them
0000000000000000000000000000000000000000;;		if err := wait.Poll(10*time.Second, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			return verifyRemainingObjects(t, clientSet, ns.Name, 1, 1)
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		close(stopCh)
0000000000000000000000000000000000000000;;	}
