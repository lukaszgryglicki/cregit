0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
d7da13ea77f3a47537cebb919c8cad149c9bfbb0;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package apiserver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/pborman/uuid"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/handlers"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tests that the apiserver retries non-overlapping conflicts on patches
0000000000000000000000000000000000000000;;	func TestPatchConflicts(t *testing.T) {
0000000000000000000000000000000000000000;;		s, clientSet, closeFn := setup(t)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("status-code", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the object we're going to conflict on
0000000000000000000000000000000000000000;;		clientSet.Core().Secrets(ns.Name).Create(&v1.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "test",
0000000000000000000000000000000000000000;;				// Populate annotations so the strategic patch descends, compares, and notices the $patch directive
0000000000000000000000000000000000000000;;				Annotations: map[string]string{"initial": "value"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		client := clientSet.Core().RESTClient()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		successes := int32(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run a lot of simultaneous patch operations to exercise internal API server retry of patch application.
0000000000000000000000000000000000000000;;		// Internally, a patch API call retries up to MaxRetryWhenPatchConflicts times if the resource version of the object has changed.
0000000000000000000000000000000000000000;;		// If the resource version of the object changed between attempts, that means another one of our patch requests succeeded.
0000000000000000000000000000000000000000;;		// That means if we run 2*MaxRetryWhenPatchConflicts patch attempts, we should see at least MaxRetryWhenPatchConflicts succeed.
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		for i := 0; i < (2 * handlers.MaxRetryWhenPatchConflicts); i++ {
0000000000000000000000000000000000000000;;			wg.Add(1)
0000000000000000000000000000000000000000;;			go func(i int) {
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;				annotationName := fmt.Sprintf("annotation-%d", i)
0000000000000000000000000000000000000000;;				labelName := fmt.Sprintf("label-%d", i)
0000000000000000000000000000000000000000;;				value := uuid.NewRandom().String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				obj, err := client.Patch(types.StrategicMergePatchType).
0000000000000000000000000000000000000000;;					Namespace(ns.Name).
0000000000000000000000000000000000000000;;					Resource("secrets").
0000000000000000000000000000000000000000;;					Name("test").
0000000000000000000000000000000000000000;;					Body([]byte(fmt.Sprintf(`{"metadata":{"labels":{"%s":"%s"}, "annotations":{"$patch":"replace","%s":"%s"}}}`, labelName, value, annotationName, value))).
0000000000000000000000000000000000000000;;					Do().
0000000000000000000000000000000000000000;;					Get()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if errors.IsConflict(err) {
0000000000000000000000000000000000000000;;					t.Logf("tolerated conflict error patching %s: %v", "secrets", err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("error patching %s: %v", "secrets", err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				accessor, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("error getting object from %s: %v", "secrets", err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// make sure the label we wanted was effective
0000000000000000000000000000000000000000;;				if accessor.GetLabels()[labelName] != value {
0000000000000000000000000000000000000000;;					t.Errorf("patch of %s was ineffective, expected %s=%s, got labels %#v", "secrets", labelName, value, accessor.GetLabels())
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// make sure the patch directive didn't get lost, and that the entire annotation map was replaced
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(accessor.GetAnnotations(), map[string]string{annotationName: value}) {
0000000000000000000000000000000000000000;;					t.Errorf("patch of %s with $patch directive was ineffective, didn't replace entire annotations map: %#v", "secrets", accessor.GetAnnotations())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				atomic.AddInt32(&successes, 1)
0000000000000000000000000000000000000000;;			}(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if successes < handlers.MaxRetryWhenPatchConflicts {
0000000000000000000000000000000000000000;;			t.Errorf("Expected at least %d successful patches for %s, got %d", handlers.MaxRetryWhenPatchConflicts, "secrets", successes)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t.Logf("Got %d successful patches for %s", successes, "secrets")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
