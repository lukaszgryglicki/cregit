0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
4e73616ef7dec89f93a74029e9a739f017b62386;test/integration/kubectl_test.go[test/integration/kubectl_test.go][test/integration/kubectl/kubectl_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestKubectlValidation(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			data string
0000000000000000000000000000000000000000;;			// Validation should not fail on missing type information.
0000000000000000000000000000000000000000;;			err bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{`{"apiVersion": "v1", "kind": "thisObjectShouldNotExistInAnyGroup"}`, true},
0000000000000000000000000000000000000000;;			{`{"apiVersion": "invalidVersion", "kind": "Pod"}`, false},
0000000000000000000000000000000000000000;;			{`{"apiVersion": "v1", "kind": "Pod"}`, false},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// The following test the experimental api.
0000000000000000000000000000000000000000;;			// TODO: Replace with something more robust. These may move.
0000000000000000000000000000000000000000;;			{`{"apiVersion": "extensions/v1beta1", "kind": "Ingress"}`, false},
0000000000000000000000000000000000000000;;			{`{"apiVersion": "extensions/v1beta1", "kind": "DaemonSet"}`, false},
0000000000000000000000000000000000000000;;			{`{"apiVersion": "vNotAVersion", "kind": "DaemonSet"}`, false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		components := framework.NewMasterComponents(&framework.Config{})
0000000000000000000000000000000000000000;;		defer components.Stop(true, true)
0000000000000000000000000000000000000000;;		ctx := clientcmdapi.NewContext()
0000000000000000000000000000000000000000;;		cfg := clientcmdapi.NewConfig()
0000000000000000000000000000000000000000;;		cluster := clientcmdapi.NewCluster()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cluster.Server = components.ApiServer.URL
0000000000000000000000000000000000000000;;		cluster.InsecureSkipTLSVerify = true
0000000000000000000000000000000000000000;;		cfg.Contexts = map[string]*clientcmdapi.Context{"test": ctx}
0000000000000000000000000000000000000000;;		cfg.CurrentContext = "test"
0000000000000000000000000000000000000000;;		overrides := clientcmd.ConfigOverrides{
0000000000000000000000000000000000000000;;			ClusterInfo: *cluster,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdConfig := clientcmd.NewNonInteractiveClientConfig(*cfg, "test", &overrides, nil)
0000000000000000000000000000000000000000;;		factory := util.NewFactory(cmdConfig)
0000000000000000000000000000000000000000;;		schema, err := factory.Validator(true, "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("failed to get validator: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range testCases {
0000000000000000000000000000000000000000;;			err := schema.ValidateBytes([]byte(test.data))
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				if test.err {
0000000000000000000000000000000000000000;;					t.Errorf("case %d: expected error", i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if !test.err {
0000000000000000000000000000000000000000;;					t.Errorf("case %d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
