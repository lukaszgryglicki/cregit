0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
c5d79780c48c3e23a5ccdd39933c8c5ea024462e;examples/apiserver/apiserver_test.go[examples/apiserver/apiserver_test.go][test/integration/examples/apiserver_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package apiserver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		genericapiserver "k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		client "k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;		apiregistrationv1beta1 "k8s.io/kube-aggregator/pkg/apis/apiregistration/v1beta1"
0000000000000000000000000000000000000000;;		aggregatorclient "k8s.io/kube-aggregator/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		kubeaggregatorserver "k8s.io/kube-aggregator/pkg/cmd/server"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kube-apiserver/app"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kube-apiserver/app/options"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration/framework"
0000000000000000000000000000000000000000;;		"k8s.io/sample-apiserver/pkg/apis/wardle/v1alpha1"
0000000000000000000000000000000000000000;;		sampleserver "k8s.io/sample-apiserver/pkg/cmd/server"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var groupVersion = v1alpha1.SchemeGroupVersion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var groupVersionForDiscovery = metav1.GroupVersionForDiscovery{
0000000000000000000000000000000000000000;;		GroupVersion: groupVersion.String(),
0000000000000000000000000000000000000000;;		Version:      groupVersion.Version,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAggregatedAPIServer(t *testing.T) {
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certDir, _ := ioutil.TempDir("", "test-integration-apiserver")
0000000000000000000000000000000000000000;;		defer os.RemoveAll(certDir)
0000000000000000000000000000000000000000;;		_, defaultServiceClusterIPRange, _ := net.ParseCIDR("10.0.0.0/24")
0000000000000000000000000000000000000000;;		proxySigningKey, err := cert.NewPrivateKey()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		proxySigningCert, err := cert.NewSelfSignedCACert(cert.Config{CommonName: "front-proxy-ca"}, proxySigningKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		proxyCACertFile, _ := ioutil.TempFile(certDir, "proxy-ca.crt")
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(proxyCACertFile.Name(), cert.EncodeCertPEM(proxySigningCert), 0644); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clientSigningKey, err := cert.NewPrivateKey()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clientSigningCert, err := cert.NewSelfSignedCACert(cert.Config{CommonName: "client-ca"}, clientSigningKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clientCACertFile, _ := ioutil.TempFile(certDir, "client-ca.crt")
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(clientCACertFile.Name(), cert.EncodeCertPEM(clientSigningCert), 0644); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClientConfigValue := atomic.Value{}
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				// always get a fresh port in case something claimed the old one
0000000000000000000000000000000000000000;;				kubePort, err := framework.FindFreeLocalPort()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatal(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				kubeAPIServerOptions := options.NewServerRunOptions()
0000000000000000000000000000000000000000;;				kubeAPIServerOptions.SecureServing.BindAddress = net.ParseIP("127.0.0.1")
0000000000000000000000000000000000000000;;				kubeAPIServerOptions.SecureServing.BindPort = kubePort
0000000000000000000000000000000000000000;;				kubeAPIServerOptions.SecureServing.ServerCert.CertDirectory = certDir
0000000000000000000000000000000000000000;;				kubeAPIServerOptions.InsecureServing.BindPort = 0
0000000000000000000000000000000000000000;;				kubeAPIServerOptions.Etcd.StorageConfig.ServerList = []string{framework.GetEtcdURLFromEnv()}
0000000000000000000000000000000000000000;;				kubeAPIServerOptions.ServiceClusterIPRange = *defaultServiceClusterIPRange
0000000000000000000000000000000000000000;;				kubeAPIServerOptions.Authentication.RequestHeader.UsernameHeaders = []string{"X-Remote-User"}
0000000000000000000000000000000000000000;;				kubeAPIServerOptions.Authentication.RequestHeader.GroupHeaders = []string{"X-Remote-Group"}
0000000000000000000000000000000000000000;;				kubeAPIServerOptions.Authentication.RequestHeader.ExtraHeaderPrefixes = []string{"X-Remote-Extra-"}
0000000000000000000000000000000000000000;;				kubeAPIServerOptions.Authentication.RequestHeader.AllowedNames = []string{"kube-aggregator"}
0000000000000000000000000000000000000000;;				kubeAPIServerOptions.Authentication.RequestHeader.ClientCAFile = proxyCACertFile.Name()
0000000000000000000000000000000000000000;;				kubeAPIServerOptions.Authentication.ClientCert.ClientCA = clientCACertFile.Name()
0000000000000000000000000000000000000000;;				kubeAPIServerOptions.Authorization.Mode = "RBAC"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				tunneler, proxyTransport, err := app.CreateNodeDialer(kubeAPIServerOptions)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatal(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				kubeAPIServerConfig, sharedInformers, _, _, _, err := app.CreateKubeAPIServerConfig(kubeAPIServerOptions, tunneler, proxyTransport)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatal(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				kubeClientConfigValue.Store(kubeAPIServerConfig.GenericConfig.LoopbackClientConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				kubeAPIServer, err := app.CreateKubeAPIServer(kubeAPIServerConfig, genericapiserver.EmptyDelegate, sharedInformers)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatal(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := kubeAPIServer.GenericAPIServer.PrepareRun().Run(wait.NeverStop); err != nil {
0000000000000000000000000000000000000000;;					t.Log(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				time.Sleep(100 * time.Millisecond)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// just use json because everyone speaks it
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(100*time.Millisecond, 10*time.Second, func() (done bool, err error) {
0000000000000000000000000000000000000000;;			obj := kubeClientConfigValue.Load()
0000000000000000000000000000000000000000;;			if obj == nil {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			kubeClientConfig := kubeClientConfigValue.Load().(*rest.Config)
0000000000000000000000000000000000000000;;			kubeClientConfig.ContentType = ""
0000000000000000000000000000000000000000;;			kubeClientConfig.AcceptContentTypes = ""
0000000000000000000000000000000000000000;;			kubeClient, err := client.NewForConfig(kubeClientConfig)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// this happens because we race the API server start
0000000000000000000000000000000000000000;;				t.Log(err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := kubeClient.Discovery().ServerVersion(); err != nil {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// after this point we won't be mutating, so the race detector will be fine
0000000000000000000000000000000000000000;;		kubeClientConfig := kubeClientConfigValue.Load().(*rest.Config)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// write a kubeconfig out for starting other API servers with delegated auth.  remember, no in-cluster config
0000000000000000000000000000000000000000;;		adminKubeConfig := createKubeConfig(kubeClientConfig)
0000000000000000000000000000000000000000;;		kubeconfigFile, _ := ioutil.TempFile("", "")
0000000000000000000000000000000000000000;;		defer os.Remove(kubeconfigFile.Name())
0000000000000000000000000000000000000000;;		clientcmd.WriteToFile(*adminKubeConfig, kubeconfigFile.Name())
0000000000000000000000000000000000000000;;		wardleCertDir, _ := ioutil.TempDir("", "test-integration-wardle-server")
0000000000000000000000000000000000000000;;		defer os.RemoveAll(wardleCertDir)
0000000000000000000000000000000000000000;;		wardlePort := new(int32)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// start the wardle server to prove we can aggregate it
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				// always get a fresh port in case something claimed the old one
0000000000000000000000000000000000000000;;				wardlePortInt, err := framework.FindFreeLocalPort()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatal(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				atomic.StoreInt32(wardlePort, int32(wardlePortInt))
0000000000000000000000000000000000000000;;				wardleCmd := sampleserver.NewCommandStartWardleServer(os.Stdout, os.Stderr, stopCh)
0000000000000000000000000000000000000000;;				wardleCmd.SetArgs([]string{
0000000000000000000000000000000000000000;;					"--bind-address", "127.0.0.1",
0000000000000000000000000000000000000000;;					"--secure-port", strconv.Itoa(wardlePortInt),
0000000000000000000000000000000000000000;;					"--requestheader-username-headers=X-Remote-User",
0000000000000000000000000000000000000000;;					"--requestheader-group-headers=X-Remote-Group",
0000000000000000000000000000000000000000;;					"--requestheader-extra-headers-prefix=X-Remote-Extra-",
0000000000000000000000000000000000000000;;					"--requestheader-client-ca-file=" + proxyCACertFile.Name(),
0000000000000000000000000000000000000000;;					"--requestheader-allowed-names=kube-aggregator",
0000000000000000000000000000000000000000;;					"--authentication-kubeconfig", kubeconfigFile.Name(),
0000000000000000000000000000000000000000;;					"--authorization-kubeconfig", kubeconfigFile.Name(),
0000000000000000000000000000000000000000;;					"--etcd-servers", framework.GetEtcdURLFromEnv(),
0000000000000000000000000000000000000000;;					"--cert-dir", wardleCertDir,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				if err := wardleCmd.Execute(); err != nil {
0000000000000000000000000000000000000000;;					t.Log(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				time.Sleep(100 * time.Millisecond)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wardleClientConfig := rest.AnonymousClientConfig(kubeClientConfig)
0000000000000000000000000000000000000000;;		wardleClientConfig.CAFile = path.Join(wardleCertDir, "apiserver.crt")
0000000000000000000000000000000000000000;;		wardleClientConfig.CAData = nil
0000000000000000000000000000000000000000;;		wardleClientConfig.ServerName = ""
0000000000000000000000000000000000000000;;		wardleClientConfig.BearerToken = kubeClientConfig.BearerToken
0000000000000000000000000000000000000000;;		var wardleClient client.Interface
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(100*time.Millisecond, 10*time.Second, func() (done bool, err error) {
0000000000000000000000000000000000000000;;			wardleClientConfig.Host = fmt.Sprintf("https://127.0.0.1:%d", atomic.LoadInt32(wardlePort))
0000000000000000000000000000000000000000;;			wardleClient, err = client.NewForConfig(wardleClientConfig)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// this happens because we race the API server start
0000000000000000000000000000000000000000;;				t.Log(err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := wardleClient.Discovery().ServerVersion(); err != nil {
0000000000000000000000000000000000000000;;				t.Log(err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// start the aggregator
0000000000000000000000000000000000000000;;		aggregatorCertDir, _ := ioutil.TempDir("", "test-integration-aggregator")
0000000000000000000000000000000000000000;;		defer os.RemoveAll(aggregatorCertDir)
0000000000000000000000000000000000000000;;		proxyClientKey, err := cert.NewPrivateKey()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		proxyClientCert, err := cert.NewSignedCert(
0000000000000000000000000000000000000000;;			cert.Config{
0000000000000000000000000000000000000000;;				CommonName: "kube-aggregator",
0000000000000000000000000000000000000000;;				Usages:     []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			proxyClientKey, proxySigningCert, proxySigningKey,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		proxyClientCertFile, _ := ioutil.TempFile(aggregatorCertDir, "proxy-client.crt")
0000000000000000000000000000000000000000;;		proxyClientKeyFile, _ := ioutil.TempFile(aggregatorCertDir, "proxy-client.key")
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(proxyClientCertFile.Name(), cert.EncodeCertPEM(proxyClientCert), 0600); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(proxyClientKeyFile.Name(), cert.EncodePrivateKeyPEM(proxyClientKey), 0644); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		aggregatorPort := new(int32)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				// always get a fresh port in case something claimed the old one
0000000000000000000000000000000000000000;;				aggregatorPortInt, err := framework.FindFreeLocalPort()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatal(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				atomic.StoreInt32(aggregatorPort, int32(aggregatorPortInt))
0000000000000000000000000000000000000000;;				aggregatorCmd := kubeaggregatorserver.NewCommandStartAggregator(os.Stdout, os.Stderr, stopCh)
0000000000000000000000000000000000000000;;				aggregatorCmd.SetArgs([]string{
0000000000000000000000000000000000000000;;					"--bind-address", "127.0.0.1",
0000000000000000000000000000000000000000;;					"--secure-port", strconv.Itoa(aggregatorPortInt),
0000000000000000000000000000000000000000;;					"--requestheader-username-headers", "",
0000000000000000000000000000000000000000;;					"--proxy-client-cert-file", proxyClientCertFile.Name(),
0000000000000000000000000000000000000000;;					"--proxy-client-key-file", proxyClientKeyFile.Name(),
0000000000000000000000000000000000000000;;					"--core-kubeconfig", kubeconfigFile.Name(),
0000000000000000000000000000000000000000;;					"--authentication-kubeconfig", kubeconfigFile.Name(),
0000000000000000000000000000000000000000;;					"--authorization-kubeconfig", kubeconfigFile.Name(),
0000000000000000000000000000000000000000;;					"--etcd-servers", framework.GetEtcdURLFromEnv(),
0000000000000000000000000000000000000000;;					"--cert-dir", aggregatorCertDir,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				if err := aggregatorCmd.Execute(); err != nil {
0000000000000000000000000000000000000000;;					t.Log(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				time.Sleep(100 * time.Millisecond)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		aggregatorClientConfig := rest.AnonymousClientConfig(kubeClientConfig)
0000000000000000000000000000000000000000;;		aggregatorClientConfig.CAFile = path.Join(aggregatorCertDir, "apiserver.crt")
0000000000000000000000000000000000000000;;		aggregatorClientConfig.CAData = nil
0000000000000000000000000000000000000000;;		aggregatorClientConfig.ServerName = ""
0000000000000000000000000000000000000000;;		aggregatorClientConfig.BearerToken = kubeClientConfig.BearerToken
0000000000000000000000000000000000000000;;		var aggregatorDiscoveryClient client.Interface
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(100*time.Millisecond, 10*time.Second, func() (done bool, err error) {
0000000000000000000000000000000000000000;;			aggregatorClientConfig.Host = fmt.Sprintf("https://127.0.0.1:%d", atomic.LoadInt32(aggregatorPort))
0000000000000000000000000000000000000000;;			aggregatorDiscoveryClient, err = client.NewForConfig(aggregatorClientConfig)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// this happens if we race the API server for writing the cert
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := aggregatorDiscoveryClient.Discovery().ServerVersion(); err != nil {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// now we're finally ready to test. These are what's run by defautl now
0000000000000000000000000000000000000000;;		testAPIGroupList(t, wardleClient.Discovery().RESTClient())
0000000000000000000000000000000000000000;;		testAPIGroup(t, wardleClient.Discovery().RESTClient())
0000000000000000000000000000000000000000;;		testAPIResourceList(t, wardleClient.Discovery().RESTClient())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wardleCA, err := ioutil.ReadFile(wardleClientConfig.CAFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		aggregatorClient := aggregatorclient.NewForConfigOrDie(aggregatorClientConfig)
0000000000000000000000000000000000000000;;		_, err = aggregatorClient.ApiregistrationV1beta1().APIServices().Create(&apiregistrationv1beta1.APIService{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "v1alpha1.wardle.k8s.io"},
0000000000000000000000000000000000000000;;			Spec: apiregistrationv1beta1.APIServiceSpec{
0000000000000000000000000000000000000000;;				Service: &apiregistrationv1beta1.ServiceReference{
0000000000000000000000000000000000000000;;					Namespace: "kube-wardle",
0000000000000000000000000000000000000000;;					Name:      "api",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Group:                "wardle.k8s.io",
0000000000000000000000000000000000000000;;				Version:              "v1alpha1",
0000000000000000000000000000000000000000;;				CABundle:             wardleCA,
0000000000000000000000000000000000000000;;				GroupPriorityMinimum: 200,
0000000000000000000000000000000000000000;;				VersionPriority:      200,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this is ugly, but sleep just a little bit so that the watch is probably observed.  Since nothing will actually be added to discovery
0000000000000000000000000000000000000000;;		// (the service is missing), we don't have an external signal.
0000000000000000000000000000000000000000;;		time.Sleep(100 * time.Millisecond)
0000000000000000000000000000000000000000;;		if _, err := aggregatorDiscoveryClient.Discovery().ServerResources(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = aggregatorClient.ApiregistrationV1beta1().APIServices().Create(&apiregistrationv1beta1.APIService{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "v1."},
0000000000000000000000000000000000000000;;			Spec: apiregistrationv1beta1.APIServiceSpec{
0000000000000000000000000000000000000000;;				// register this as a loca service so it doesn't try to lookup the default kubernetes service
0000000000000000000000000000000000000000;;				// which will have an unroutable IP address since its fake.
0000000000000000000000000000000000000000;;				Group:                "",
0000000000000000000000000000000000000000;;				Version:              "v1",
0000000000000000000000000000000000000000;;				GroupPriorityMinimum: 100,
0000000000000000000000000000000000000000;;				VersionPriority:      100,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this is ugly, but sleep just a little bit so that the watch is probably observed.  Since nothing will actually be added to discovery
0000000000000000000000000000000000000000;;		// (the service is missing), we don't have an external signal.
0000000000000000000000000000000000000000;;		time.Sleep(100 * time.Millisecond)
0000000000000000000000000000000000000000;;		_, err = aggregatorDiscoveryClient.Discovery().ServerResources()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO figure out how to turn on enough of services and dns to run more
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createKubeConfig(clientCfg *rest.Config) *clientcmdapi.Config {
0000000000000000000000000000000000000000;;		clusterNick := "cluster"
0000000000000000000000000000000000000000;;		userNick := "user"
0000000000000000000000000000000000000000;;		contextNick := "context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := clientcmdapi.NewConfig()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		credentials := clientcmdapi.NewAuthInfo()
0000000000000000000000000000000000000000;;		credentials.Token = clientCfg.BearerToken
0000000000000000000000000000000000000000;;		credentials.ClientCertificate = clientCfg.TLSClientConfig.CertFile
0000000000000000000000000000000000000000;;		if len(credentials.ClientCertificate) == 0 {
0000000000000000000000000000000000000000;;			credentials.ClientCertificateData = clientCfg.TLSClientConfig.CertData
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		credentials.ClientKey = clientCfg.TLSClientConfig.KeyFile
0000000000000000000000000000000000000000;;		if len(credentials.ClientKey) == 0 {
0000000000000000000000000000000000000000;;			credentials.ClientKeyData = clientCfg.TLSClientConfig.KeyData
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config.AuthInfos[userNick] = credentials
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cluster := clientcmdapi.NewCluster()
0000000000000000000000000000000000000000;;		cluster.Server = clientCfg.Host
0000000000000000000000000000000000000000;;		cluster.CertificateAuthority = clientCfg.CAFile
0000000000000000000000000000000000000000;;		if len(cluster.CertificateAuthority) == 0 {
0000000000000000000000000000000000000000;;			cluster.CertificateAuthorityData = clientCfg.CAData
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cluster.InsecureSkipTLSVerify = clientCfg.Insecure
0000000000000000000000000000000000000000;;		config.Clusters[clusterNick] = cluster
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		context := clientcmdapi.NewContext()
0000000000000000000000000000000000000000;;		context.Cluster = clusterNick
0000000000000000000000000000000000000000;;		context.AuthInfo = userNick
0000000000000000000000000000000000000000;;		config.Contexts[contextNick] = context
0000000000000000000000000000000000000000;;		config.CurrentContext = contextNick
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readResponse(client rest.Interface, location string) ([]byte, error) {
0000000000000000000000000000000000000000;;		return client.Get().AbsPath(location).DoRaw()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testAPIGroupList(t *testing.T, client rest.Interface) {
0000000000000000000000000000000000000000;;		contents, err := readResponse(client, "/apis")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Log(string(contents))
0000000000000000000000000000000000000000;;		var apiGroupList metav1.APIGroupList
0000000000000000000000000000000000000000;;		err = json.Unmarshal(contents, &apiGroupList)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error in unmarshalling response from server %s: %v", "/apis", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		assert.Equal(t, 1, len(apiGroupList.Groups))
0000000000000000000000000000000000000000;;		assert.Equal(t, groupVersion.Group, apiGroupList.Groups[0].Name)
0000000000000000000000000000000000000000;;		assert.Equal(t, 1, len(apiGroupList.Groups[0].Versions))
0000000000000000000000000000000000000000;;		assert.Equal(t, groupVersionForDiscovery, apiGroupList.Groups[0].Versions[0])
0000000000000000000000000000000000000000;;		assert.Equal(t, groupVersionForDiscovery, apiGroupList.Groups[0].PreferredVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testAPIGroup(t *testing.T, client rest.Interface) {
0000000000000000000000000000000000000000;;		contents, err := readResponse(client, "/apis/wardle.k8s.io")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Log(string(contents))
0000000000000000000000000000000000000000;;		var apiGroup metav1.APIGroup
0000000000000000000000000000000000000000;;		err = json.Unmarshal(contents, &apiGroup)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error in unmarshalling response from server %s: %v", "/apis/wardle.k8s.io", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		assert.Equal(t, groupVersion.Group, apiGroup.Name)
0000000000000000000000000000000000000000;;		assert.Equal(t, 1, len(apiGroup.Versions))
0000000000000000000000000000000000000000;;		assert.Equal(t, groupVersion.String(), apiGroup.Versions[0].GroupVersion)
0000000000000000000000000000000000000000;;		assert.Equal(t, groupVersion.Version, apiGroup.Versions[0].Version)
0000000000000000000000000000000000000000;;		assert.Equal(t, apiGroup.PreferredVersion, apiGroup.Versions[0])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testAPIResourceList(t *testing.T, client rest.Interface) {
0000000000000000000000000000000000000000;;		contents, err := readResponse(client, "/apis/wardle.k8s.io/v1alpha1")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Log(string(contents))
0000000000000000000000000000000000000000;;		var apiResourceList metav1.APIResourceList
0000000000000000000000000000000000000000;;		err = json.Unmarshal(contents, &apiResourceList)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error in unmarshalling response from server %s: %v", "/apis/wardle.k8s.io/v1alpha1", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		assert.Equal(t, groupVersion.String(), apiResourceList.GroupVersion)
0000000000000000000000000000000000000000;;		assert.Equal(t, 2, len(apiResourceList.APIResources))
0000000000000000000000000000000000000000;;		assert.Equal(t, "fischers", apiResourceList.APIResources[0].Name)
0000000000000000000000000000000000000000;;		assert.False(t, apiResourceList.APIResources[0].Namespaced)
0000000000000000000000000000000000000000;;		assert.Equal(t, "flunders", apiResourceList.APIResources[1].Name)
0000000000000000000000000000000000000000;;		assert.True(t, apiResourceList.APIResources[1].Namespaced)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		policyCachePollInterval = 100 * time.Millisecond
0000000000000000000000000000000000000000;;		policyCachePollTimeout  = 5 * time.Second
0000000000000000000000000000000000000000;;	)
