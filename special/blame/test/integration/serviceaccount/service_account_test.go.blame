0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ca3a89854e7596bb795ae96f88546e2f396e9ab;test/integration/service_account_test.go[test/integration/service_account_test.go][test/integration/serviceaccount/service_account_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package serviceaccount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file tests authentication and (soon) authorization of HTTP requests to a master object.
0000000000000000000000000000000000000000;;	// It does not use the client in pkg/client/... because authentication and authorization needs
0000000000000000000000000000000000000000;;	// to work for any client of the HTTP interface.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/authenticator"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/request/bearertoken"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/request/union"
0000000000000000000000000000000000000000;;		serviceaccountapiserver "k8s.io/apiserver/pkg/authentication/serviceaccount"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		internalinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		serviceaccountcontroller "k8s.io/kubernetes/pkg/controller/serviceaccount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/serviceaccount"
0000000000000000000000000000000000000000;;		serviceaccountadmission "k8s.io/kubernetes/plugin/pkg/admission/serviceaccount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		rootUserName = "root"
0000000000000000000000000000000000000000;;		rootToken    = "root-user-token"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		readOnlyServiceAccountName  = "ro"
0000000000000000000000000000000000000000;;		readWriteServiceAccountName = "rw"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceAccountAutoCreate(t *testing.T) {
0000000000000000000000000000000000000000;;		c, _, stopFunc := startServiceAccountTestServer(t)
0000000000000000000000000000000000000000;;		defer stopFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := "test-service-account-creation"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create namespace
0000000000000000000000000000000000000000;;		_, err := c.Core().Namespaces().Create(&v1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: ns}})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("could not create namespace: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get service account
0000000000000000000000000000000000000000;;		defaultUser, err := getServiceAccount(c, ns, "default", true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Default serviceaccount not created: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete service account
0000000000000000000000000000000000000000;;		err = c.Core().ServiceAccounts(ns).Delete(defaultUser.Name, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Could not delete default serviceaccount: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get recreated service account
0000000000000000000000000000000000000000;;		defaultUser2, err := getServiceAccount(c, ns, "default", true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Default serviceaccount not created: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if defaultUser2.UID == defaultUser.UID {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected different UID with recreated serviceaccount")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceAccountTokenAutoCreate(t *testing.T) {
0000000000000000000000000000000000000000;;		c, _, stopFunc := startServiceAccountTestServer(t)
0000000000000000000000000000000000000000;;		defer stopFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := "test-service-account-token-creation"
0000000000000000000000000000000000000000;;		name := "my-service-account"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create namespace
0000000000000000000000000000000000000000;;		_, err := c.Core().Namespaces().Create(&v1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: ns}})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("could not create namespace: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create service account
0000000000000000000000000000000000000000;;		serviceAccount, err := c.Core().ServiceAccounts(ns).Create(&v1.ServiceAccount{ObjectMeta: metav1.ObjectMeta{Name: name}})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Service Account not created: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get token
0000000000000000000000000000000000000000;;		token1Name, token1, err := getReferencedServiceAccountToken(c, ns, name, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete token
0000000000000000000000000000000000000000;;		err = c.Core().Secrets(ns).Delete(token1Name, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Could not delete token: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get recreated token
0000000000000000000000000000000000000000;;		token2Name, token2, err := getReferencedServiceAccountToken(c, ns, name, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if token1Name == token2Name {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected new auto-created token name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if token1 == token2 {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected new auto-created token value")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Trigger creation of a new referenced token
0000000000000000000000000000000000000000;;		serviceAccount, err = c.Core().ServiceAccounts(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		serviceAccount.Secrets = []v1.ObjectReference{}
0000000000000000000000000000000000000000;;		_, err = c.Core().ServiceAccounts(ns).Update(serviceAccount)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get rotated token
0000000000000000000000000000000000000000;;		token3Name, token3, err := getReferencedServiceAccountToken(c, ns, name, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if token3Name == token2Name {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected new auto-created token name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if token3 == token2 {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected new auto-created token value")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete service account
0000000000000000000000000000000000000000;;		err = c.Core().ServiceAccounts(ns).Delete(name, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for tokens to be deleted
0000000000000000000000000000000000000000;;		tokensToCleanup := sets.NewString(token1Name, token2Name, token3Name)
0000000000000000000000000000000000000000;;		err = wait.Poll(time.Second, 10*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			// Get all secrets in the namespace
0000000000000000000000000000000000000000;;			secrets, err := c.Core().Secrets(ns).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			// Retrieval errors should fail
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, s := range secrets.Items {
0000000000000000000000000000000000000000;;				if tokensToCleanup.Has(s.Name) {
0000000000000000000000000000000000000000;;					// Still waiting for tokens to be cleaned up
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// All clean
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error waiting for tokens to be deleted: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceAccountTokenAutoMount(t *testing.T) {
0000000000000000000000000000000000000000;;		c, _, stopFunc := startServiceAccountTestServer(t)
0000000000000000000000000000000000000000;;		defer stopFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := "auto-mount-ns"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create "my" namespace
0000000000000000000000000000000000000000;;		_, err := c.Core().Namespaces().Create(&v1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: ns}})
0000000000000000000000000000000000000000;;		if err != nil && !errors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;			t.Fatalf("could not create namespace: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get default token
0000000000000000000000000000000000000000;;		defaultTokenName, _, err := getReferencedServiceAccountToken(c, ns, serviceaccountadmission.DefaultServiceAccountName, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pod to create
0000000000000000000000000000000000000000;;		protoPod := v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "protopod"},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "container-1",
0000000000000000000000000000000000000000;;						Image: "container-1-image",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "container-2",
0000000000000000000000000000000000000000;;						Image: "container-2-image",
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{Name: "empty-dir", MountPath: serviceaccountadmission.DefaultAPITokenMountPath},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:         "empty-dir",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{EmptyDir: &v1.EmptyDirVolumeSource{}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pod we expect to get created
0000000000000000000000000000000000000000;;		defaultMode := int32(0644)
0000000000000000000000000000000000000000;;		expectedServiceAccount := serviceaccountadmission.DefaultServiceAccountName
0000000000000000000000000000000000000000;;		expectedVolumes := append(protoPod.Spec.Volumes, v1.Volume{
0000000000000000000000000000000000000000;;			Name: defaultTokenName,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				Secret: &v1.SecretVolumeSource{
0000000000000000000000000000000000000000;;					SecretName:  defaultTokenName,
0000000000000000000000000000000000000000;;					DefaultMode: &defaultMode,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		expectedContainer1VolumeMounts := []v1.VolumeMount{
0000000000000000000000000000000000000000;;			{Name: defaultTokenName, MountPath: serviceaccountadmission.DefaultAPITokenMountPath, ReadOnly: true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedContainer2VolumeMounts := protoPod.Spec.Containers[1].VolumeMounts
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		createdPod, err := c.Core().Pods(ns).Create(&protoPod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if createdPod.Spec.ServiceAccountName != expectedServiceAccount {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected %s, got %s", expectedServiceAccount, createdPod.Spec.ServiceAccountName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(&expectedVolumes, &createdPod.Spec.Volumes) {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected\n\t%#v\n\tgot\n\t%#v", expectedVolumes, createdPod.Spec.Volumes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(&expectedContainer1VolumeMounts, &createdPod.Spec.Containers[0].VolumeMounts) {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected\n\t%#v\n\tgot\n\t%#v", expectedContainer1VolumeMounts, createdPod.Spec.Containers[0].VolumeMounts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(&expectedContainer2VolumeMounts, &createdPod.Spec.Containers[1].VolumeMounts) {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected\n\t%#v\n\tgot\n\t%#v", expectedContainer2VolumeMounts, createdPod.Spec.Containers[1].VolumeMounts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceAccountTokenAuthentication(t *testing.T) {
0000000000000000000000000000000000000000;;		c, config, stopFunc := startServiceAccountTestServer(t)
0000000000000000000000000000000000000000;;		defer stopFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		myns := "auth-ns"
0000000000000000000000000000000000000000;;		otherns := "other-ns"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create "my" namespace
0000000000000000000000000000000000000000;;		_, err := c.Core().Namespaces().Create(&v1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: myns}})
0000000000000000000000000000000000000000;;		if err != nil && !errors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;			t.Fatalf("could not create namespace: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create "other" namespace
0000000000000000000000000000000000000000;;		_, err = c.Core().Namespaces().Create(&v1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: otherns}})
0000000000000000000000000000000000000000;;		if err != nil && !errors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;			t.Fatalf("could not create namespace: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create "ro" user in myns
0000000000000000000000000000000000000000;;		_, err = c.Core().ServiceAccounts(myns).Create(&v1.ServiceAccount{ObjectMeta: metav1.ObjectMeta{Name: readOnlyServiceAccountName}})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Service Account not created: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		roTokenName, roToken, err := getReferencedServiceAccountToken(c, myns, readOnlyServiceAccountName, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		roClientConfig := config
0000000000000000000000000000000000000000;;		roClientConfig.BearerToken = roToken
0000000000000000000000000000000000000000;;		roClient := clientset.NewForConfigOrDie(&roClientConfig)
0000000000000000000000000000000000000000;;		doServiceAccountAPIRequests(t, roClient, myns, true, true, false)
0000000000000000000000000000000000000000;;		doServiceAccountAPIRequests(t, roClient, otherns, true, false, false)
0000000000000000000000000000000000000000;;		err = c.Core().Secrets(myns).Delete(roTokenName, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("could not delete token: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		doServiceAccountAPIRequests(t, roClient, myns, false, false, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create "rw" user in myns
0000000000000000000000000000000000000000;;		_, err = c.Core().ServiceAccounts(myns).Create(&v1.ServiceAccount{ObjectMeta: metav1.ObjectMeta{Name: readWriteServiceAccountName}})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Service Account not created: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, rwToken, err := getReferencedServiceAccountToken(c, myns, readWriteServiceAccountName, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rwClientConfig := config
0000000000000000000000000000000000000000;;		rwClientConfig.BearerToken = rwToken
0000000000000000000000000000000000000000;;		rwClient := clientset.NewForConfigOrDie(&rwClientConfig)
0000000000000000000000000000000000000000;;		doServiceAccountAPIRequests(t, rwClient, myns, true, true, true)
0000000000000000000000000000000000000000;;		doServiceAccountAPIRequests(t, rwClient, otherns, true, false, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get default user and token which should have been automatically created
0000000000000000000000000000000000000000;;		_, defaultToken, err := getReferencedServiceAccountToken(c, myns, "default", true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("could not get default user and token: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defaultClientConfig := config
0000000000000000000000000000000000000000;;		defaultClientConfig.BearerToken = defaultToken
0000000000000000000000000000000000000000;;		defaultClient := clientset.NewForConfigOrDie(&defaultClientConfig)
0000000000000000000000000000000000000000;;		doServiceAccountAPIRequests(t, defaultClient, myns, true, false, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// startServiceAccountTestServer returns a started server
0000000000000000000000000000000000000000;;	// It is the responsibility of the caller to ensure the returned stopFunc is called
0000000000000000000000000000000000000000;;	func startServiceAccountTestServer(t *testing.T) (*clientset.Clientset, restclient.Config, func()) {
0000000000000000000000000000000000000000;;		// Listener
0000000000000000000000000000000000000000;;		h := &framework.MasterHolder{Initialized: make(chan struct{})}
0000000000000000000000000000000000000000;;		apiServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			<-h.Initialized
0000000000000000000000000000000000000000;;			h.M.GenericAPIServer.Handler.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Anonymous client config
0000000000000000000000000000000000000000;;		clientConfig := restclient.Config{Host: apiServer.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}}
0000000000000000000000000000000000000000;;		// Root client
0000000000000000000000000000000000000000;;		// TODO: remove rootClient after we refactor pkg/admission to use the clientset.
0000000000000000000000000000000000000000;;		rootClientset := clientset.NewForConfigOrDie(&restclient.Config{Host: apiServer.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}, BearerToken: rootToken})
0000000000000000000000000000000000000000;;		internalRootClientset := internalclientset.NewForConfigOrDie(&restclient.Config{Host: apiServer.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}, BearerToken: rootToken})
0000000000000000000000000000000000000000;;		// Set up two authenticators:
0000000000000000000000000000000000000000;;		// 1. A token authenticator that maps the rootToken to the "root" user
0000000000000000000000000000000000000000;;		// 2. A ServiceAccountToken authenticator that validates ServiceAccount tokens
0000000000000000000000000000000000000000;;		rootTokenAuth := authenticator.TokenFunc(func(token string) (user.Info, bool, error) {
0000000000000000000000000000000000000000;;			if token == rootToken {
0000000000000000000000000000000000000000;;				return &user.DefaultInfo{Name: rootUserName}, true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		serviceAccountKey, _ := rsa.GenerateKey(rand.Reader, 2048)
0000000000000000000000000000000000000000;;		serviceAccountTokenGetter := serviceaccountcontroller.NewGetterFromClient(rootClientset)
0000000000000000000000000000000000000000;;		serviceAccountTokenAuth := serviceaccount.JWTTokenAuthenticator([]interface{}{&serviceAccountKey.PublicKey}, true, serviceAccountTokenGetter)
0000000000000000000000000000000000000000;;		authenticator := union.New(
0000000000000000000000000000000000000000;;			bearertoken.New(rootTokenAuth),
0000000000000000000000000000000000000000;;			bearertoken.New(serviceAccountTokenAuth),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up a stub authorizer:
0000000000000000000000000000000000000000;;		// 1. The "root" user is allowed to do anything
0000000000000000000000000000000000000000;;		// 2. ServiceAccounts named "ro" are allowed read-only operations in their namespace
0000000000000000000000000000000000000000;;		// 3. ServiceAccounts named "rw" are allowed any operation in their namespace
0000000000000000000000000000000000000000;;		authorizer := authorizer.AuthorizerFunc(func(attrs authorizer.Attributes) (bool, string, error) {
0000000000000000000000000000000000000000;;			username := ""
0000000000000000000000000000000000000000;;			if user := attrs.GetUser(); user != nil {
0000000000000000000000000000000000000000;;				username = user.GetName()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ns := attrs.GetNamespace()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If the user is "root"...
0000000000000000000000000000000000000000;;			if username == rootUserName {
0000000000000000000000000000000000000000;;				// allow them to do anything
0000000000000000000000000000000000000000;;				return true, "", nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If the user is a service account...
0000000000000000000000000000000000000000;;			if serviceAccountNamespace, serviceAccountName, err := serviceaccountapiserver.SplitUsername(username); err == nil {
0000000000000000000000000000000000000000;;				// Limit them to their own namespace
0000000000000000000000000000000000000000;;				if serviceAccountNamespace == ns {
0000000000000000000000000000000000000000;;					switch serviceAccountName {
0000000000000000000000000000000000000000;;					case readOnlyServiceAccountName:
0000000000000000000000000000000000000000;;						if attrs.IsReadOnly() {
0000000000000000000000000000000000000000;;							return true, "", nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case readWriteServiceAccountName:
0000000000000000000000000000000000000000;;						return true, "", nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return false, fmt.Sprintf("User %s is denied (ns=%s, readonly=%v, resource=%s)", username, ns, attrs.IsReadOnly(), attrs.GetResource()), nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up admission plugin to auto-assign serviceaccounts to pods
0000000000000000000000000000000000000000;;		serviceAccountAdmission := serviceaccountadmission.NewServiceAccount()
0000000000000000000000000000000000000000;;		serviceAccountAdmission.SetInternalKubeClientSet(internalRootClientset)
0000000000000000000000000000000000000000;;		internalInformers := internalinformers.NewSharedInformerFactory(internalRootClientset, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		serviceAccountAdmission.SetInternalKubeInformerFactory(internalInformers)
0000000000000000000000000000000000000000;;		informers := informers.NewSharedInformerFactory(rootClientset, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		masterConfig := framework.NewMasterConfig()
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.EnableIndex = true
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authenticator = authenticator
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.Authorizer = authorizer
0000000000000000000000000000000000000000;;		masterConfig.GenericConfig.AdmissionControl = serviceAccountAdmission
0000000000000000000000000000000000000000;;		framework.RunAMasterUsingServer(masterConfig, apiServer, h)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start the service account and service account token controllers
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		tokenController := serviceaccountcontroller.NewTokensController(
0000000000000000000000000000000000000000;;			informers.Core().V1().ServiceAccounts(),
0000000000000000000000000000000000000000;;			informers.Core().V1().Secrets(),
0000000000000000000000000000000000000000;;			rootClientset,
0000000000000000000000000000000000000000;;			serviceaccountcontroller.TokensControllerOptions{TokenGenerator: serviceaccount.JWTTokenGenerator(serviceAccountKey)},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		go tokenController.Run(1, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serviceAccountController := serviceaccountcontroller.NewServiceAccountsController(
0000000000000000000000000000000000000000;;			informers.Core().V1().ServiceAccounts(),
0000000000000000000000000000000000000000;;			informers.Core().V1().Namespaces(),
0000000000000000000000000000000000000000;;			rootClientset,
0000000000000000000000000000000000000000;;			serviceaccountcontroller.DefaultServiceAccountsControllerOptions(),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		informers.Start(stopCh)
0000000000000000000000000000000000000000;;		internalInformers.Start(stopCh)
0000000000000000000000000000000000000000;;		go serviceAccountController.Run(5, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stop := func() {
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;			apiServer.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rootClientset, clientConfig, stop
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getServiceAccount(c *clientset.Clientset, ns string, name string, shouldWait bool) (*v1.ServiceAccount, error) {
0000000000000000000000000000000000000000;;		if !shouldWait {
0000000000000000000000000000000000000000;;			return c.Core().ServiceAccounts(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var user *v1.ServiceAccount
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		err = wait.Poll(time.Second, 10*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			user, err = c.Core().ServiceAccounts(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return user, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getReferencedServiceAccountToken(c *clientset.Clientset, ns string, name string, shouldWait bool) (string, string, error) {
0000000000000000000000000000000000000000;;		tokenName := ""
0000000000000000000000000000000000000000;;		token := ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		findToken := func() (bool, error) {
0000000000000000000000000000000000000000;;			user, err := c.Core().ServiceAccounts(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, ref := range user.Secrets {
0000000000000000000000000000000000000000;;				secret, err := c.Core().Secrets(ns).Get(ref.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if secret.Type != v1.SecretTypeServiceAccountToken {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				name := secret.Annotations[v1.ServiceAccountNameKey]
0000000000000000000000000000000000000000;;				uid := secret.Annotations[v1.ServiceAccountUIDKey]
0000000000000000000000000000000000000000;;				tokenData := secret.Data[v1.ServiceAccountTokenKey]
0000000000000000000000000000000000000000;;				if name == user.Name && uid == string(user.UID) && len(tokenData) > 0 {
0000000000000000000000000000000000000000;;					tokenName = secret.Name
0000000000000000000000000000000000000000;;					token = string(tokenData)
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if shouldWait {
0000000000000000000000000000000000000000;;			err := wait.Poll(time.Second, 10*time.Second, findToken)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ok, err := findToken()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return "", "", fmt.Errorf("No token found for %s/%s", ns, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tokenName, token, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testOperation func() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doServiceAccountAPIRequests(t *testing.T, c *clientset.Clientset, ns string, authenticated bool, canRead bool, canWrite bool) {
0000000000000000000000000000000000000000;;		testSecret := &v1.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "testSecret"},
0000000000000000000000000000000000000000;;			Data:       map[string][]byte{"test": []byte("data")},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		readOps := []testOperation{
0000000000000000000000000000000000000000;;			func() error {
0000000000000000000000000000000000000000;;				_, err := c.Core().Secrets(ns).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func() error {
0000000000000000000000000000000000000000;;				_, err := c.Core().Pods(ns).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		writeOps := []testOperation{
0000000000000000000000000000000000000000;;			func() error { _, err := c.Core().Secrets(ns).Create(testSecret); return err },
0000000000000000000000000000000000000000;;			func() error { return c.Core().Secrets(ns).Delete(testSecret.Name, nil) },
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, op := range readOps {
0000000000000000000000000000000000000000;;			err := op()
0000000000000000000000000000000000000000;;			unauthorizedError := errors.IsUnauthorized(err)
0000000000000000000000000000000000000000;;			forbiddenError := errors.IsForbidden(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case !authenticated && !unauthorizedError:
0000000000000000000000000000000000000000;;				t.Fatalf("expected unauthorized error, got %v", err)
0000000000000000000000000000000000000000;;			case authenticated && unauthorizedError:
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected unauthorized error: %v", err)
0000000000000000000000000000000000000000;;			case authenticated && canRead && forbiddenError:
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected forbidden error: %v", err)
0000000000000000000000000000000000000000;;			case authenticated && !canRead && !forbiddenError:
0000000000000000000000000000000000000000;;				t.Fatalf("expected forbidden error, got: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, op := range writeOps {
0000000000000000000000000000000000000000;;			err := op()
0000000000000000000000000000000000000000;;			unauthorizedError := errors.IsUnauthorized(err)
0000000000000000000000000000000000000000;;			forbiddenError := errors.IsForbidden(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case !authenticated && !unauthorizedError:
0000000000000000000000000000000000000000;;				t.Fatalf("expected unauthorized error, got %v", err)
0000000000000000000000000000000000000000;;			case authenticated && unauthorizedError:
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected unauthorized error: %v", err)
0000000000000000000000000000000000000000;;			case authenticated && canWrite && forbiddenError:
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected forbidden error: %v", err)
0000000000000000000000000000000000000000;;			case authenticated && !canWrite && !forbiddenError:
0000000000000000000000000000000000000000;;				t.Fatalf("expected forbidden error, got: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
