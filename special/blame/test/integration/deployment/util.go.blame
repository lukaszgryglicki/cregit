0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
dce10711c9faf4e720c7430f04ef29f7de5e7f04;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package deployment
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/deployment"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/replicaset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration/framework"
0000000000000000000000000000000000000000;;		testutil "k8s.io/kubernetes/test/utils"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		pollInterval = 1 * time.Second
0000000000000000000000000000000000000000;;		pollTimeout  = 60 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeImageName = "fake-name"
0000000000000000000000000000000000000000;;		fakeImage     = "fakeimage"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type deploymentTester struct {
0000000000000000000000000000000000000000;;		t          *testing.T
0000000000000000000000000000000000000000;;		c          clientset.Interface
0000000000000000000000000000000000000000;;		deployment *v1beta1.Deployment
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testLabels() map[string]string {
0000000000000000000000000000000000000000;;		return map[string]string{"name": "test"}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newDeployment returns a RollingUpdate Deployment with with a fake container image
0000000000000000000000000000000000000000;;	func newDeployment(name, ns string, replicas int32) *v1beta1.Deployment {
0000000000000000000000000000000000000000;;		return &v1beta1.Deployment{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Deployment",
0000000000000000000000000000000000000000;;				APIVersion: "extensions/v1beta1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1beta1.DeploymentSpec{
0000000000000000000000000000000000000000;;				Replicas: &replicas,
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{MatchLabels: testLabels()},
0000000000000000000000000000000000000000;;				Strategy: v1beta1.DeploymentStrategy{
0000000000000000000000000000000000000000;;					Type: v1beta1.RollingUpdateDeploymentStrategyType,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: testLabels(),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  fakeImageName,
0000000000000000000000000000000000000000;;								Image: fakeImage,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dcSetup sets up necessities for Deployment integration test, including master, apiserver, informers, and clientset
0000000000000000000000000000000000000000;;	func dcSetup(t *testing.T) (*httptest.Server, framework.CloseFunc, *replicaset.ReplicaSetController, *deployment.DeploymentController, informers.SharedInformerFactory, clientset.Interface) {
0000000000000000000000000000000000000000;;		masterConfig := framework.NewIntegrationTestMasterConfig()
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(masterConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := restclient.Config{Host: s.URL}
0000000000000000000000000000000000000000;;		clientSet, err := clientset.NewForConfig(&config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error in create clientset: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resyncPeriod := 12 * time.Hour
0000000000000000000000000000000000000000;;		informers := informers.NewSharedInformerFactory(clientset.NewForConfigOrDie(restclient.AddUserAgent(&config, "deployment-informers")), resyncPeriod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc := deployment.NewDeploymentController(
0000000000000000000000000000000000000000;;			informers.Extensions().V1beta1().Deployments(),
0000000000000000000000000000000000000000;;			informers.Extensions().V1beta1().ReplicaSets(),
0000000000000000000000000000000000000000;;			informers.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			clientset.NewForConfigOrDie(restclient.AddUserAgent(&config, "deployment-controller")),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		rm := replicaset.NewReplicaSetController(
0000000000000000000000000000000000000000;;			informers.Extensions().V1beta1().ReplicaSets(),
0000000000000000000000000000000000000000;;			informers.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			clientset.NewForConfigOrDie(restclient.AddUserAgent(&config, "replicaset-controller")),
0000000000000000000000000000000000000000;;			replicaset.BurstReplicas,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		return s, closeFn, rm, dc, informers, clientSet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addPodConditionReady sets given pod status to ready at given time
0000000000000000000000000000000000000000;;	func addPodConditionReady(pod *v1.Pod, time metav1.Time) {
0000000000000000000000000000000000000000;;		pod.Status = v1.PodStatus{
0000000000000000000000000000000000000000;;			Phase: v1.PodRunning,
0000000000000000000000000000000000000000;;			Conditions: []v1.PodCondition{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:               v1.PodReady,
0000000000000000000000000000000000000000;;					Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;					LastTransitionTime: time,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *deploymentTester) waitForDeploymentRevisionAndImage(revision, image string) error {
0000000000000000000000000000000000000000;;		return testutil.WaitForDeploymentRevisionAndImage(d.c, d.deployment.Namespace, d.deployment.Name, revision, image, d.t.Logf, pollInterval, pollTimeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// markAllPodsReady manually updates all Deployment pods status to ready
0000000000000000000000000000000000000000;;	func (d *deploymentTester) markAllPodsReady() {
0000000000000000000000000000000000000000;;		ns := d.deployment.Namespace
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(d.deployment.Spec.Selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			d.t.Fatalf("failed to parse Deployment selector: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var readyPods int32
0000000000000000000000000000000000000000;;		err = wait.Poll(100*time.Millisecond, pollTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			readyPods = 0
0000000000000000000000000000000000000000;;			pods, err := d.c.Core().Pods(ns).List(metav1.ListOptions{LabelSelector: selector.String()})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				d.t.Logf("failed to list Deployment pods, will retry later: %v", err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := range pods.Items {
0000000000000000000000000000000000000000;;				pod := pods.Items[i]
0000000000000000000000000000000000000000;;				if podutil.IsPodReady(&pod) {
0000000000000000000000000000000000000000;;					readyPods++
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				addPodConditionReady(&pod, metav1.Now())
0000000000000000000000000000000000000000;;				if _, err = d.c.Core().Pods(ns).UpdateStatus(&pod); err != nil {
0000000000000000000000000000000000000000;;					d.t.Logf("failed to update Deployment pod %s, will retry later: %v", pod.Name, err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					readyPods++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if readyPods >= *d.deployment.Spec.Replicas {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			d.t.Fatalf("failed to mark all Deployment pods to ready: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *deploymentTester) waitForDeploymentStatusValid() error {
0000000000000000000000000000000000000000;;		return testutil.WaitForDeploymentStatusValid(d.c, d.deployment, d.t.Logf, pollInterval, pollTimeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForDeploymentStatusValidAndMarkPodsReady waits for the Deployment status to become valid
0000000000000000000000000000000000000000;;	// while marking all Deployment pods as ready at the same time.
0000000000000000000000000000000000000000;;	func (d *deploymentTester) waitForDeploymentStatusValidAndMarkPodsReady() {
0000000000000000000000000000000000000000;;		// Manually mark all Deployment pods as ready in a separate goroutine
0000000000000000000000000000000000000000;;		go d.markAllPodsReady()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure the Deployment status is valid while Deployment pods are becoming ready
0000000000000000000000000000000000000000;;		err := d.waitForDeploymentStatusValid()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			d.t.Fatalf("failed to wait for Deployment status %s: %v", d.deployment.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
