0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
184f19e39f4665efa1da538e9d9290d4e50f48e5;test/integration/extender_test.go[test/integration/extender_test.go][test/integration/scheduler/extender_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package scheduler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file tests scheduler extender.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		v1core "k8s.io/client-go/kubernetes/typed/core/v1"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/plugin/pkg/scheduler/algorithmprovider"
0000000000000000000000000000000000000000;;		schedulerapi "k8s.io/kubernetes/plugin/pkg/scheduler/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/factory"
0000000000000000000000000000000000000000;;		e2e "k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		filter     = "filter"
0000000000000000000000000000000000000000;;		prioritize = "prioritize"
0000000000000000000000000000000000000000;;		bind       = "bind"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fitPredicate func(pod *v1.Pod, node *v1.Node) (bool, error)
0000000000000000000000000000000000000000;;	type priorityFunc func(pod *v1.Pod, nodes *v1.NodeList) (*schedulerapi.HostPriorityList, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type priorityConfig struct {
0000000000000000000000000000000000000000;;		function priorityFunc
0000000000000000000000000000000000000000;;		weight   int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Extender struct {
0000000000000000000000000000000000000000;;		name             string
0000000000000000000000000000000000000000;;		predicates       []fitPredicate
0000000000000000000000000000000000000000;;		prioritizers     []priorityConfig
0000000000000000000000000000000000000000;;		nodeCacheCapable bool
0000000000000000000000000000000000000000;;		Client           clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Extender) serveHTTP(t *testing.T, w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		decoder := json.NewDecoder(req.Body)
0000000000000000000000000000000000000000;;		defer req.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encoder := json.NewEncoder(w)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if strings.Contains(req.URL.Path, filter) || strings.Contains(req.URL.Path, prioritize) {
0000000000000000000000000000000000000000;;			var args schedulerapi.ExtenderArgs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := decoder.Decode(&args); err != nil {
0000000000000000000000000000000000000000;;				http.Error(w, "Decode error", http.StatusBadRequest)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if strings.Contains(req.URL.Path, filter) {
0000000000000000000000000000000000000000;;				resp := &schedulerapi.ExtenderFilterResult{}
0000000000000000000000000000000000000000;;				resp, err := e.Filter(&args)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					resp.Error = err.Error()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := encoder.Encode(resp); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("Failed to encode %v", resp)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if strings.Contains(req.URL.Path, prioritize) {
0000000000000000000000000000000000000000;;				// Prioritize errors are ignored. Default k8s priorities or another extender's
0000000000000000000000000000000000000000;;				// priorities may be applied.
0000000000000000000000000000000000000000;;				priorities, _ := e.Prioritize(&args)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := encoder.Encode(priorities); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("Failed to encode %+v", priorities)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if strings.Contains(req.URL.Path, bind) {
0000000000000000000000000000000000000000;;			var args schedulerapi.ExtenderBindingArgs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := decoder.Decode(&args); err != nil {
0000000000000000000000000000000000000000;;				http.Error(w, "Decode error", http.StatusBadRequest)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resp := &schedulerapi.ExtenderBindingResult{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := e.Bind(&args); err != nil {
0000000000000000000000000000000000000000;;				resp.Error = err.Error()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := encoder.Encode(resp); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed to encode %+v", resp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			http.Error(w, "Unknown method", http.StatusNotFound)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Extender) filterUsingNodeCache(args *schedulerapi.ExtenderArgs) (*schedulerapi.ExtenderFilterResult, error) {
0000000000000000000000000000000000000000;;		nodeSlice := make([]string, 0)
0000000000000000000000000000000000000000;;		failedNodesMap := schedulerapi.FailedNodesMap{}
0000000000000000000000000000000000000000;;		for _, nodeName := range *args.NodeNames {
0000000000000000000000000000000000000000;;			fits := true
0000000000000000000000000000000000000000;;			for _, predicate := range e.predicates {
0000000000000000000000000000000000000000;;				fit, err := predicate(&args.Pod,
0000000000000000000000000000000000000000;;					&v1.Node{ObjectMeta: metav1.ObjectMeta{Name: nodeName}})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return &schedulerapi.ExtenderFilterResult{
0000000000000000000000000000000000000000;;						Nodes:       nil,
0000000000000000000000000000000000000000;;						NodeNames:   nil,
0000000000000000000000000000000000000000;;						FailedNodes: schedulerapi.FailedNodesMap{},
0000000000000000000000000000000000000000;;						Error:       err.Error(),
0000000000000000000000000000000000000000;;					}, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !fit {
0000000000000000000000000000000000000000;;					fits = false
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fits {
0000000000000000000000000000000000000000;;				nodeSlice = append(nodeSlice, nodeName)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				failedNodesMap[nodeName] = fmt.Sprintf("extender failed: %s", e.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &schedulerapi.ExtenderFilterResult{
0000000000000000000000000000000000000000;;			Nodes:       nil,
0000000000000000000000000000000000000000;;			NodeNames:   &nodeSlice,
0000000000000000000000000000000000000000;;			FailedNodes: failedNodesMap,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Extender) Filter(args *schedulerapi.ExtenderArgs) (*schedulerapi.ExtenderFilterResult, error) {
0000000000000000000000000000000000000000;;		filtered := []v1.Node{}
0000000000000000000000000000000000000000;;		failedNodesMap := schedulerapi.FailedNodesMap{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e.nodeCacheCapable {
0000000000000000000000000000000000000000;;			return e.filterUsingNodeCache(args)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, node := range args.Nodes.Items {
0000000000000000000000000000000000000000;;				fits := true
0000000000000000000000000000000000000000;;				for _, predicate := range e.predicates {
0000000000000000000000000000000000000000;;					fit, err := predicate(&args.Pod, &node)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return &schedulerapi.ExtenderFilterResult{
0000000000000000000000000000000000000000;;							Nodes:       &v1.NodeList{},
0000000000000000000000000000000000000000;;							NodeNames:   nil,
0000000000000000000000000000000000000000;;							FailedNodes: schedulerapi.FailedNodesMap{},
0000000000000000000000000000000000000000;;							Error:       err.Error(),
0000000000000000000000000000000000000000;;						}, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !fit {
0000000000000000000000000000000000000000;;						fits = false
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if fits {
0000000000000000000000000000000000000000;;					filtered = append(filtered, node)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					failedNodesMap[node.Name] = fmt.Sprintf("extender failed: %s", e.name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return &schedulerapi.ExtenderFilterResult{
0000000000000000000000000000000000000000;;				Nodes:       &v1.NodeList{Items: filtered},
0000000000000000000000000000000000000000;;				NodeNames:   nil,
0000000000000000000000000000000000000000;;				FailedNodes: failedNodesMap,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Extender) Prioritize(args *schedulerapi.ExtenderArgs) (*schedulerapi.HostPriorityList, error) {
0000000000000000000000000000000000000000;;		result := schedulerapi.HostPriorityList{}
0000000000000000000000000000000000000000;;		combinedScores := map[string]int{}
0000000000000000000000000000000000000000;;		var nodes = &v1.NodeList{Items: []v1.Node{}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e.nodeCacheCapable {
0000000000000000000000000000000000000000;;			for _, nodeName := range *args.NodeNames {
0000000000000000000000000000000000000000;;				nodes.Items = append(nodes.Items, v1.Node{ObjectMeta: metav1.ObjectMeta{Name: nodeName}})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			nodes = args.Nodes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, prioritizer := range e.prioritizers {
0000000000000000000000000000000000000000;;			weight := prioritizer.weight
0000000000000000000000000000000000000000;;			if weight == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			priorityFunc := prioritizer.function
0000000000000000000000000000000000000000;;			prioritizedList, err := priorityFunc(&args.Pod, nodes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return &schedulerapi.HostPriorityList{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, hostEntry := range *prioritizedList {
0000000000000000000000000000000000000000;;				combinedScores[hostEntry.Host] += hostEntry.Score * weight
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for host, score := range combinedScores {
0000000000000000000000000000000000000000;;			result = append(result, schedulerapi.HostPriority{Host: host, Score: score})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Extender) Bind(binding *schedulerapi.ExtenderBindingArgs) error {
0000000000000000000000000000000000000000;;		b := &v1.Binding{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: binding.PodNamespace, Name: binding.PodName, UID: binding.PodUID},
0000000000000000000000000000000000000000;;			Target: v1.ObjectReference{
0000000000000000000000000000000000000000;;				Kind: "Node",
0000000000000000000000000000000000000000;;				Name: binding.Node,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return e.Client.CoreV1().Pods(b.Namespace).Bind(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func machine_1_2_3_Predicate(pod *v1.Pod, node *v1.Node) (bool, error) {
0000000000000000000000000000000000000000;;		if node.Name == "machine1" || node.Name == "machine2" || node.Name == "machine3" {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func machine_2_3_5_Predicate(pod *v1.Pod, node *v1.Node) (bool, error) {
0000000000000000000000000000000000000000;;		if node.Name == "machine2" || node.Name == "machine3" || node.Name == "machine5" {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func machine_2_Prioritizer(pod *v1.Pod, nodes *v1.NodeList) (*schedulerapi.HostPriorityList, error) {
0000000000000000000000000000000000000000;;		result := schedulerapi.HostPriorityList{}
0000000000000000000000000000000000000000;;		for _, node := range nodes.Items {
0000000000000000000000000000000000000000;;			score := 1
0000000000000000000000000000000000000000;;			if node.Name == "machine2" {
0000000000000000000000000000000000000000;;				score = 10
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = append(result, schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;				Host:  node.Name,
0000000000000000000000000000000000000000;;				Score: score,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func machine_3_Prioritizer(pod *v1.Pod, nodes *v1.NodeList) (*schedulerapi.HostPriorityList, error) {
0000000000000000000000000000000000000000;;		result := schedulerapi.HostPriorityList{}
0000000000000000000000000000000000000000;;		for _, node := range nodes.Items {
0000000000000000000000000000000000000000;;			score := 1
0000000000000000000000000000000000000000;;			if node.Name == "machine3" {
0000000000000000000000000000000000000000;;				score = 10
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = append(result, schedulerapi.HostPriority{
0000000000000000000000000000000000000000;;				Host:  node.Name,
0000000000000000000000000000000000000000;;				Score: score,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSchedulerExtender(t *testing.T) {
0000000000000000000000000000000000000000;;		_, s, closeFn := framework.RunAMaster(nil)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := framework.CreateTestingNamespace("scheduler-extender", s, t)
0000000000000000000000000000000000000000;;		defer framework.DeleteTestingNamespace(ns, s, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientSet := clientset.NewForConfigOrDie(&restclient.Config{Host: s.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extender1 := &Extender{
0000000000000000000000000000000000000000;;			name:         "extender1",
0000000000000000000000000000000000000000;;			predicates:   []fitPredicate{machine_1_2_3_Predicate},
0000000000000000000000000000000000000000;;			prioritizers: []priorityConfig{{machine_2_Prioritizer, 1}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		es1 := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			extender1.serveHTTP(t, w, req)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer es1.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extender2 := &Extender{
0000000000000000000000000000000000000000;;			name:         "extender2",
0000000000000000000000000000000000000000;;			predicates:   []fitPredicate{machine_2_3_5_Predicate},
0000000000000000000000000000000000000000;;			prioritizers: []priorityConfig{{machine_3_Prioritizer, 1}},
0000000000000000000000000000000000000000;;			Client:       clientSet,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		es2 := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			extender2.serveHTTP(t, w, req)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer es2.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extender3 := &Extender{
0000000000000000000000000000000000000000;;			name:             "extender3",
0000000000000000000000000000000000000000;;			predicates:       []fitPredicate{machine_1_2_3_Predicate},
0000000000000000000000000000000000000000;;			prioritizers:     []priorityConfig{{machine_2_Prioritizer, 5}},
0000000000000000000000000000000000000000;;			nodeCacheCapable: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		es3 := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			extender3.serveHTTP(t, w, req)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer es3.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		policy := schedulerapi.Policy{
0000000000000000000000000000000000000000;;			ExtenderConfigs: []schedulerapi.ExtenderConfig{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					URLPrefix:      es1.URL,
0000000000000000000000000000000000000000;;					FilterVerb:     filter,
0000000000000000000000000000000000000000;;					PrioritizeVerb: prioritize,
0000000000000000000000000000000000000000;;					Weight:         3,
0000000000000000000000000000000000000000;;					EnableHttps:    false,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					URLPrefix:      es2.URL,
0000000000000000000000000000000000000000;;					FilterVerb:     filter,
0000000000000000000000000000000000000000;;					PrioritizeVerb: prioritize,
0000000000000000000000000000000000000000;;					BindVerb:       bind,
0000000000000000000000000000000000000000;;					Weight:         4,
0000000000000000000000000000000000000000;;					EnableHttps:    false,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					URLPrefix:        es3.URL,
0000000000000000000000000000000000000000;;					FilterVerb:       filter,
0000000000000000000000000000000000000000;;					PrioritizeVerb:   prioritize,
0000000000000000000000000000000000000000;;					Weight:           10,
0000000000000000000000000000000000000000;;					EnableHttps:      false,
0000000000000000000000000000000000000000;;					NodeCacheCapable: true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		policy.APIVersion = api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(clientSet, 0)
0000000000000000000000000000000000000000;;		schedulerConfigFactory := factory.NewConfigFactory(
0000000000000000000000000000000000000000;;			v1.DefaultSchedulerName,
0000000000000000000000000000000000000000;;			clientSet,
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumeClaims(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().ReplicationControllers(),
0000000000000000000000000000000000000000;;			informerFactory.Extensions().V1beta1().ReplicaSets(),
0000000000000000000000000000000000000000;;			informerFactory.Apps().V1beta1().StatefulSets(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Services(),
0000000000000000000000000000000000000000;;			v1.DefaultHardPodAffinitySymmetricWeight,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		schedulerConfig, err := schedulerConfigFactory.CreateFromConfig(policy)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Couldn't create scheduler config: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		schedulerConfig.Recorder = eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: v1.DefaultSchedulerName})
0000000000000000000000000000000000000000;;		eventBroadcaster.StartRecordingToSink(&v1core.EventSinkImpl{Interface: v1core.New(clientSet.Core().RESTClient()).Events("")})
0000000000000000000000000000000000000000;;		scheduler, _ := scheduler.NewFromConfigurator(&scheduler.FakeConfigurator{Config: schedulerConfig}, nil...)
0000000000000000000000000000000000000000;;		informerFactory.Start(schedulerConfig.StopEverything)
0000000000000000000000000000000000000000;;		scheduler.Run()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer close(schedulerConfig.StopEverything)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		DoTestPodScheduling(ns, t, clientSet)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DoTestPodScheduling(ns *v1.Namespace, t *testing.T, cs clientset.Interface) {
0000000000000000000000000000000000000000;;		// NOTE: This test cannot run in parallel, because it is creating and deleting
0000000000000000000000000000000000000000;;		// non-namespaced objects (Nodes).
0000000000000000000000000000000000000000;;		defer cs.Core().Nodes().DeleteCollection(nil, metav1.ListOptions{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		goodCondition := v1.NodeCondition{
0000000000000000000000000000000000000000;;			Type:              v1.NodeReady,
0000000000000000000000000000000000000000;;			Status:            v1.ConditionTrue,
0000000000000000000000000000000000000000;;			Reason:            fmt.Sprintf("schedulable condition"),
0000000000000000000000000000000000000000;;			LastHeartbeatTime: metav1.Time{Time: time.Now()},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		node := &v1.Node{
0000000000000000000000000000000000000000;;			Spec: v1.NodeSpec{Unschedulable: false},
0000000000000000000000000000000000000000;;			Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourcePods: *resource.NewQuantity(32, resource.DecimalSI),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Conditions: []v1.NodeCondition{goodCondition},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for ii := 0; ii < 5; ii++ {
0000000000000000000000000000000000000000;;			node.Name = fmt.Sprintf("machine%d", ii+1)
0000000000000000000000000000000000000000;;			if _, err := cs.Core().Nodes().Create(node); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Failed to create nodes: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "extender-test-pod"},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{{Name: "container", Image: e2e.GetPauseImageName(cs)}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		myPod, err := cs.Core().Pods(ns.Name).Create(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create pod: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = wait.Poll(time.Second, wait.ForeverTestTimeout, podScheduled(cs, myPod.Namespace, myPod.Name))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to schedule pod: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		myPod, err = cs.Core().Pods(ns.Name).Get(myPod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to get pod: %v", err)
0000000000000000000000000000000000000000;;		} else if myPod.Spec.NodeName != "machine2" {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to schedule using extender, expected machine2, got %v", myPod.Spec.NodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var gracePeriod int64
0000000000000000000000000000000000000000;;		if err := cs.Core().Pods(ns.Name).Delete(myPod.Name, &metav1.DeleteOptions{GracePeriodSeconds: &gracePeriod}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to delete pod: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = cs.Core().Pods(ns.Name).Get(myPod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to delete pod: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Logf("Scheduled pod using extenders")
0000000000000000000000000000000000000000;;	}
