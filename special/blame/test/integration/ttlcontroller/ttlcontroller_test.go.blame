0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
c512f5cb0ffb330b83793e24dd2085b006671f75;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package ttlcontroller
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		listers "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/ttl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/integration/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createClientAndInformers(t *testing.T, server *httptest.Server) (*clientset.Clientset, informers.SharedInformerFactory) {
0000000000000000000000000000000000000000;;		config := restclient.Config{
0000000000000000000000000000000000000000;;			Host:  server.URL,
0000000000000000000000000000000000000000;;			QPS:   500,
0000000000000000000000000000000000000000;;			Burst: 500,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testClient := clientset.NewForConfigOrDie(&config)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informers := informers.NewSharedInformerFactory(testClient, time.Second)
0000000000000000000000000000000000000000;;		return testClient, informers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createNodes(t *testing.T, client *clientset.Clientset, startIndex, endIndex int) {
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		for i := startIndex; i < endIndex; i++ {
0000000000000000000000000000000000000000;;			wg.Add(1)
0000000000000000000000000000000000000000;;			go func(idx int) {
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;				node := &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: fmt.Sprintf("node-%d", idx),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, err := client.Core().Nodes().Create(node); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("Failed to create node: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deleteNodes(t *testing.T, client *clientset.Clientset, startIndex, endIndex int) {
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		for i := startIndex; i < endIndex; i++ {
0000000000000000000000000000000000000000;;			wg.Add(1)
0000000000000000000000000000000000000000;;			go func(idx int) {
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;				name := fmt.Sprintf("node-%d", idx)
0000000000000000000000000000000000000000;;				if err := client.Core().Nodes().Delete(name, &metav1.DeleteOptions{}); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("Failed to create node: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForNodesWithTTLAnnotation(t *testing.T, nodeLister listers.NodeLister, numNodes, ttlSeconds int) {
0000000000000000000000000000000000000000;;		if err := wait.Poll(time.Second, 30*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			nodes, err := nodeLister.List(labels.Everything())
0000000000000000000000000000000000000000;;			if err != nil || len(nodes) != numNodes {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, node := range nodes {
0000000000000000000000000000000000000000;;				if node.Annotations == nil {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				value, ok := node.Annotations[v1.ObjectTTLAnnotationKey]
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				currentTTL, err := strconv.Atoi(value)
0000000000000000000000000000000000000000;;				if err != nil || currentTTL != ttlSeconds {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed waiting for all nodes with annotation: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test whether ttlcontroller sets correct ttl annotations.
0000000000000000000000000000000000000000;;	func TestTTLAnnotations(t *testing.T) {
0000000000000000000000000000000000000000;;		_, server, closeFn := framework.RunAMaster(nil)
0000000000000000000000000000000000000000;;		defer closeFn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient, informers := createClientAndInformers(t, server)
0000000000000000000000000000000000000000;;		nodeInformer := informers.Core().V1().Nodes()
0000000000000000000000000000000000000000;;		ttlc := ttl.NewTTLController(nodeInformer, testClient)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;		go nodeInformer.Informer().Run(stopCh)
0000000000000000000000000000000000000000;;		go ttlc.Run(1, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create 100 nodes all should have annotation equal to 0.
0000000000000000000000000000000000000000;;		createNodes(t, testClient, 0, 100)
0000000000000000000000000000000000000000;;		waitForNodesWithTTLAnnotation(t, informers.Core().V1().Nodes().Lister(), 100, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create 1 more node, all annotation should change to 15.
0000000000000000000000000000000000000000;;		createNodes(t, testClient, 100, 101)
0000000000000000000000000000000000000000;;		waitForNodesWithTTLAnnotation(t, informers.Core().V1().Nodes().Lister(), 101, 15)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete 11 nodes, it should still remain at the level of 15.
0000000000000000000000000000000000000000;;		deleteNodes(t, testClient, 90, 101)
0000000000000000000000000000000000000000;;		waitForNodesWithTTLAnnotation(t, informers.Core().V1().Nodes().Lister(), 90, 15)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete 1 more node, all should be decreased to 0.
0000000000000000000000000000000000000000;;		deleteNodes(t, testClient, 89, 90)
0000000000000000000000000000000000000000;;		waitForNodesWithTTLAnnotation(t, informers.Core().V1().Nodes().Lister(), 89, 0)
0000000000000000000000000000000000000000;;	}
