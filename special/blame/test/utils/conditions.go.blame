0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
e2b02ea310425e6817d3a6c0b79a00d3cae96b92;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package utils
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ContainerFailures struct {
0000000000000000000000000000000000000000;;		status   *v1.ContainerStateTerminated
0000000000000000000000000000000000000000;;		Restarts int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodRunningReady checks whether pod p's phase is running and it has a ready
0000000000000000000000000000000000000000;;	// condition of status true.
0000000000000000000000000000000000000000;;	func PodRunningReady(p *v1.Pod) (bool, error) {
0000000000000000000000000000000000000000;;		// Check the phase is running.
0000000000000000000000000000000000000000;;		if p.Status.Phase != v1.PodRunning {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("want pod '%s' on '%s' to be '%v' but was '%v'",
0000000000000000000000000000000000000000;;				p.ObjectMeta.Name, p.Spec.NodeName, v1.PodRunning, p.Status.Phase)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Check the ready condition is true.
0000000000000000000000000000000000000000;;		if !PodReady(p) {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("pod '%s' on '%s' didn't have condition {%v %v}; conditions: %v",
0000000000000000000000000000000000000000;;				p.ObjectMeta.Name, p.Spec.NodeName, v1.PodReady, v1.ConditionTrue, p.Status.Conditions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PodRunningReadyOrSucceeded(p *v1.Pod) (bool, error) {
0000000000000000000000000000000000000000;;		// Check if the phase is succeeded.
0000000000000000000000000000000000000000;;		if p.Status.Phase == v1.PodSucceeded {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return PodRunningReady(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FailedContainers inspects all containers in a pod and returns failure
0000000000000000000000000000000000000000;;	// information for containers that have failed or been restarted.
0000000000000000000000000000000000000000;;	// A map is returned where the key is the containerID and the value is a
0000000000000000000000000000000000000000;;	// struct containing the restart and failure information
0000000000000000000000000000000000000000;;	func FailedContainers(pod *v1.Pod) map[string]ContainerFailures {
0000000000000000000000000000000000000000;;		var state ContainerFailures
0000000000000000000000000000000000000000;;		states := make(map[string]ContainerFailures)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		statuses := pod.Status.ContainerStatuses
0000000000000000000000000000000000000000;;		if len(statuses) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, status := range statuses {
0000000000000000000000000000000000000000;;				if status.State.Terminated != nil {
0000000000000000000000000000000000000000;;					states[status.ContainerID] = ContainerFailures{status: status.State.Terminated}
0000000000000000000000000000000000000000;;				} else if status.LastTerminationState.Terminated != nil {
0000000000000000000000000000000000000000;;					states[status.ContainerID] = ContainerFailures{status: status.LastTerminationState.Terminated}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if status.RestartCount > 0 {
0000000000000000000000000000000000000000;;					var ok bool
0000000000000000000000000000000000000000;;					if state, ok = states[status.ContainerID]; !ok {
0000000000000000000000000000000000000000;;						state = ContainerFailures{}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					state.Restarts = int(status.RestartCount)
0000000000000000000000000000000000000000;;					states[status.ContainerID] = state
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return states
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TerminatedContainers inspects all containers in a pod and returns a map
0000000000000000000000000000000000000000;;	// of "container name: termination reason", for all currently terminated
0000000000000000000000000000000000000000;;	// containers.
0000000000000000000000000000000000000000;;	func TerminatedContainers(pod *v1.Pod) map[string]string {
0000000000000000000000000000000000000000;;		states := make(map[string]string)
0000000000000000000000000000000000000000;;		statuses := pod.Status.ContainerStatuses
0000000000000000000000000000000000000000;;		if len(statuses) == 0 {
0000000000000000000000000000000000000000;;			return states
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, status := range statuses {
0000000000000000000000000000000000000000;;			if status.State.Terminated != nil {
0000000000000000000000000000000000000000;;				states[status.Name] = status.State.Terminated.Reason
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return states
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodNotReady checks whether pod p's has a ready condition of status false.
0000000000000000000000000000000000000000;;	func PodNotReady(p *v1.Pod) (bool, error) {
0000000000000000000000000000000000000000;;		// Check the ready condition is false.
0000000000000000000000000000000000000000;;		if PodReady(p) {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("pod '%s' on '%s' didn't have condition {%v %v}; conditions: %v",
0000000000000000000000000000000000000000;;				p.ObjectMeta.Name, p.Spec.NodeName, v1.PodReady, v1.ConditionFalse, p.Status.Conditions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// podReady returns whether pod has a condition of Ready with a status of true.
0000000000000000000000000000000000000000;;	// TODO: should be replaced with podutil.IsPodReady
0000000000000000000000000000000000000000;;	func PodReady(pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		for _, cond := range pod.Status.Conditions {
0000000000000000000000000000000000000000;;			if cond.Type == v1.PodReady && cond.Status == v1.ConditionTrue {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
