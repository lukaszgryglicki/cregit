0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
e2b02ea310425e6817d3a6c0b79a00d3cae96b92;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package utils
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		batch "k8s.io/api/batch/v1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		apierrs "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		batchinternal "k8s.io/kubernetes/pkg/apis/batch"
0000000000000000000000000000000000000000;;		extensionsinternal "k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// String used to mark pod deletion
0000000000000000000000000000000000000000;;		nonExist = "NonExist"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func removePtr(replicas *int32) int32 {
0000000000000000000000000000000000000000;;		if replicas == nil {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *replicas
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func WaitUntilPodIsScheduled(c clientset.Interface, name, namespace string, timeout time.Duration) (*v1.Pod, error) {
0000000000000000000000000000000000000000;;		// Wait until it's scheduled
0000000000000000000000000000000000000000;;		p, err := c.Core().Pods(namespace).Get(name, metav1.GetOptions{ResourceVersion: "0"})
0000000000000000000000000000000000000000;;		if err == nil && p.Spec.NodeName != "" {
0000000000000000000000000000000000000000;;			return p, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pollingPeriod := 200 * time.Millisecond
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		for startTime.Add(timeout).After(time.Now()) {
0000000000000000000000000000000000000000;;			time.Sleep(pollingPeriod)
0000000000000000000000000000000000000000;;			p, err := c.Core().Pods(namespace).Get(name, metav1.GetOptions{ResourceVersion: "0"})
0000000000000000000000000000000000000000;;			if err == nil && p.Spec.NodeName != "" {
0000000000000000000000000000000000000000;;				return p, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Timed out after %v when waiting for pod %v/%v to start.", timeout, namespace, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunPodAndGetNodeName(c clientset.Interface, pod *v1.Pod, timeout time.Duration) (string, error) {
0000000000000000000000000000000000000000;;		name := pod.Name
0000000000000000000000000000000000000000;;		namespace := pod.Namespace
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		// Create a Pod
0000000000000000000000000000000000000000;;		for i := 0; i < retries; i++ {
0000000000000000000000000000000000000000;;			_, err = c.Core().Pods(namespace).Create(pod)
0000000000000000000000000000000000000000;;			if err == nil || apierrs.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil && !apierrs.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p, err := WaitUntilPodIsScheduled(c, name, namespace, timeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.Spec.NodeName, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RunObjectConfig interface {
0000000000000000000000000000000000000000;;		Run() error
0000000000000000000000000000000000000000;;		GetName() string
0000000000000000000000000000000000000000;;		GetNamespace() string
0000000000000000000000000000000000000000;;		GetKind() schema.GroupKind
0000000000000000000000000000000000000000;;		GetClient() clientset.Interface
0000000000000000000000000000000000000000;;		GetInternalClient() internalclientset.Interface
0000000000000000000000000000000000000000;;		SetClient(clientset.Interface)
0000000000000000000000000000000000000000;;		SetInternalClient(internalclientset.Interface)
0000000000000000000000000000000000000000;;		GetReplicas() int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RCConfig struct {
0000000000000000000000000000000000000000;;		Affinity       *v1.Affinity
0000000000000000000000000000000000000000;;		Client         clientset.Interface
0000000000000000000000000000000000000000;;		InternalClient internalclientset.Interface
0000000000000000000000000000000000000000;;		Image          string
0000000000000000000000000000000000000000;;		Command        []string
0000000000000000000000000000000000000000;;		Name           string
0000000000000000000000000000000000000000;;		Namespace      string
0000000000000000000000000000000000000000;;		PollInterval   time.Duration
0000000000000000000000000000000000000000;;		Timeout        time.Duration
0000000000000000000000000000000000000000;;		PodStatusFile  *os.File
0000000000000000000000000000000000000000;;		Replicas       int
0000000000000000000000000000000000000000;;		CpuRequest     int64 // millicores
0000000000000000000000000000000000000000;;		CpuLimit       int64 // millicores
0000000000000000000000000000000000000000;;		MemRequest     int64 // bytes
0000000000000000000000000000000000000000;;		MemLimit       int64 // bytes
0000000000000000000000000000000000000000;;		ReadinessProbe *v1.Probe
0000000000000000000000000000000000000000;;		DNSPolicy      *v1.DNSPolicy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Env vars, set the same for every pod.
0000000000000000000000000000000000000000;;		Env map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Extra labels added to every pod.
0000000000000000000000000000000000000000;;		Labels map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Node selector for pods in the RC.
0000000000000000000000000000000000000000;;		NodeSelector map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ports to declare in the container (map of name to containerPort).
0000000000000000000000000000000000000000;;		Ports map[string]int
0000000000000000000000000000000000000000;;		// Ports to declare in the container as host and container ports.
0000000000000000000000000000000000000000;;		HostPorts map[string]int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Volumes      []v1.Volume
0000000000000000000000000000000000000000;;		VolumeMounts []v1.VolumeMount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pointer to a list of pods; if non-nil, will be set to a list of pods
0000000000000000000000000000000000000000;;		// created by this RC by RunRC.
0000000000000000000000000000000000000000;;		CreatedPods *[]*v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Maximum allowable container failures. If exceeded, RunRC returns an error.
0000000000000000000000000000000000000000;;		// Defaults to replicas*0.1 if unspecified.
0000000000000000000000000000000000000000;;		MaxContainerFailures *int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If set to false starting RC will print progress, otherwise only errors will be printed.
0000000000000000000000000000000000000000;;		Silent bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If set this function will be used to print log lines instead of glog.
0000000000000000000000000000000000000000;;		LogFunc func(fmt string, args ...interface{})
0000000000000000000000000000000000000000;;		// If set those functions will be used to gather data from Nodes - in integration tests where no
0000000000000000000000000000000000000000;;		// kubelets are running those variables should be nil.
0000000000000000000000000000000000000000;;		NodeDumpFunc      func(c clientset.Interface, nodeNames []string, logFunc func(fmt string, args ...interface{}))
0000000000000000000000000000000000000000;;		ContainerDumpFunc func(c clientset.Interface, ns string, logFunc func(ftm string, args ...interface{}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Names of the secrets and configmaps to mount.
0000000000000000000000000000000000000000;;		SecretNames    []string
0000000000000000000000000000000000000000;;		ConfigMapNames []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *RCConfig) RCConfigLog(fmt string, args ...interface{}) {
0000000000000000000000000000000000000000;;		if rc.LogFunc != nil {
0000000000000000000000000000000000000000;;			rc.LogFunc(fmt, args...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof(fmt, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DeploymentConfig struct {
0000000000000000000000000000000000000000;;		RCConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ReplicaSetConfig struct {
0000000000000000000000000000000000000000;;		RCConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type JobConfig struct {
0000000000000000000000000000000000000000;;		RCConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// podInfo contains pod information useful for debugging e2e tests.
0000000000000000000000000000000000000000;;	type podInfo struct {
0000000000000000000000000000000000000000;;		oldHostname string
0000000000000000000000000000000000000000;;		oldPhase    string
0000000000000000000000000000000000000000;;		hostname    string
0000000000000000000000000000000000000000;;		phase       string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodDiff is a map of pod name to podInfos
0000000000000000000000000000000000000000;;	type PodDiff map[string]*podInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Print formats and prints the give PodDiff.
0000000000000000000000000000000000000000;;	func (p PodDiff) String(ignorePhases sets.String) string {
0000000000000000000000000000000000000000;;		ret := ""
0000000000000000000000000000000000000000;;		for name, info := range p {
0000000000000000000000000000000000000000;;			if ignorePhases.Has(info.phase) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if info.phase == nonExist {
0000000000000000000000000000000000000000;;				ret += fmt.Sprintf("Pod %v was deleted, had phase %v and host %v\n", name, info.oldPhase, info.oldHostname)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			phaseChange, hostChange := false, false
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("Pod %v ", name)
0000000000000000000000000000000000000000;;			if info.oldPhase != info.phase {
0000000000000000000000000000000000000000;;				phaseChange = true
0000000000000000000000000000000000000000;;				if info.oldPhase == nonExist {
0000000000000000000000000000000000000000;;					msg += fmt.Sprintf("in phase %v ", info.phase)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					msg += fmt.Sprintf("went from phase: %v -> %v ", info.oldPhase, info.phase)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if info.oldHostname != info.hostname {
0000000000000000000000000000000000000000;;				hostChange = true
0000000000000000000000000000000000000000;;				if info.oldHostname == nonExist || info.oldHostname == "" {
0000000000000000000000000000000000000000;;					msg += fmt.Sprintf("assigned host %v ", info.hostname)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					msg += fmt.Sprintf("went from host: %v -> %v ", info.oldHostname, info.hostname)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if phaseChange || hostChange {
0000000000000000000000000000000000000000;;				ret += msg + "\n"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Diff computes a PodDiff given 2 lists of pods.
0000000000000000000000000000000000000000;;	func Diff(oldPods []*v1.Pod, curPods []*v1.Pod) PodDiff {
0000000000000000000000000000000000000000;;		podInfoMap := PodDiff{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// New pods will show up in the curPods list but not in oldPods. They have oldhostname/phase == nonexist.
0000000000000000000000000000000000000000;;		for _, pod := range curPods {
0000000000000000000000000000000000000000;;			podInfoMap[pod.Name] = &podInfo{hostname: pod.Spec.NodeName, phase: string(pod.Status.Phase), oldHostname: nonExist, oldPhase: nonExist}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Deleted pods will show up in the oldPods list but not in curPods. They have a hostname/phase == nonexist.
0000000000000000000000000000000000000000;;		for _, pod := range oldPods {
0000000000000000000000000000000000000000;;			if info, ok := podInfoMap[pod.Name]; ok {
0000000000000000000000000000000000000000;;				info.oldHostname, info.oldPhase = pod.Spec.NodeName, string(pod.Status.Phase)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				podInfoMap[pod.Name] = &podInfo{hostname: nonExist, phase: nonExist, oldHostname: pod.Spec.NodeName, oldPhase: string(pod.Status.Phase)}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return podInfoMap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunDeployment Launches (and verifies correctness) of a Deployment
0000000000000000000000000000000000000000;;	// and will wait for all pods it spawns to become "Running".
0000000000000000000000000000000000000000;;	// It's the caller's responsibility to clean up externally (i.e. use the
0000000000000000000000000000000000000000;;	// namespace lifecycle for handling Cleanup).
0000000000000000000000000000000000000000;;	func RunDeployment(config DeploymentConfig) error {
0000000000000000000000000000000000000000;;		err := config.create()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return config.start()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *DeploymentConfig) Run() error {
0000000000000000000000000000000000000000;;		return RunDeployment(*config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *DeploymentConfig) GetKind() schema.GroupKind {
0000000000000000000000000000000000000000;;		return extensionsinternal.Kind("Deployment")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *DeploymentConfig) create() error {
0000000000000000000000000000000000000000;;		deployment := &extensions.Deployment{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: config.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.DeploymentSpec{
0000000000000000000000000000000000000000;;				Replicas: func(i int) *int32 { x := int32(i); return &x }(config.Replicas),
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;					MatchLabels: map[string]string{
0000000000000000000000000000000000000000;;						"name": config.Name,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"name": config.Name},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:    config.Name,
0000000000000000000000000000000000000000;;								Image:   config.Image,
0000000000000000000000000000000000000000;;								Command: config.Command,
0000000000000000000000000000000000000000;;								Ports:   []v1.ContainerPort{{ContainerPort: 80}},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(config.SecretNames) > 0 {
0000000000000000000000000000000000000000;;			attachSecrets(&deployment.Spec.Template, config.SecretNames)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(config.ConfigMapNames) > 0 {
0000000000000000000000000000000000000000;;			attachConfigMaps(&deployment.Spec.Template, config.ConfigMapNames)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.applyTo(&deployment.Spec.Template)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := config.Client.Extensions().Deployments(config.Namespace).Create(deployment)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error creating deployment: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config.RCConfigLog("Created deployment with name: %v, namespace: %v, replica count: %v", deployment.Name, config.Namespace, removePtr(deployment.Spec.Replicas))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunReplicaSet launches (and verifies correctness) of a ReplicaSet
0000000000000000000000000000000000000000;;	// and waits until all the pods it launches to reach the "Running" state.
0000000000000000000000000000000000000000;;	// It's the caller's responsibility to clean up externally (i.e. use the
0000000000000000000000000000000000000000;;	// namespace lifecycle for handling Cleanup).
0000000000000000000000000000000000000000;;	func RunReplicaSet(config ReplicaSetConfig) error {
0000000000000000000000000000000000000000;;		err := config.create()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return config.start()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *ReplicaSetConfig) Run() error {
0000000000000000000000000000000000000000;;		return RunReplicaSet(*config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *ReplicaSetConfig) GetKind() schema.GroupKind {
0000000000000000000000000000000000000000;;		return extensionsinternal.Kind("ReplicaSet")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *ReplicaSetConfig) create() error {
0000000000000000000000000000000000000000;;		rs := &extensions.ReplicaSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: config.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.ReplicaSetSpec{
0000000000000000000000000000000000000000;;				Replicas: func(i int) *int32 { x := int32(i); return &x }(config.Replicas),
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;					MatchLabels: map[string]string{
0000000000000000000000000000000000000000;;						"name": config.Name,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"name": config.Name},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:    config.Name,
0000000000000000000000000000000000000000;;								Image:   config.Image,
0000000000000000000000000000000000000000;;								Command: config.Command,
0000000000000000000000000000000000000000;;								Ports:   []v1.ContainerPort{{ContainerPort: 80}},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(config.SecretNames) > 0 {
0000000000000000000000000000000000000000;;			attachSecrets(&rs.Spec.Template, config.SecretNames)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(config.ConfigMapNames) > 0 {
0000000000000000000000000000000000000000;;			attachConfigMaps(&rs.Spec.Template, config.ConfigMapNames)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.applyTo(&rs.Spec.Template)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := config.Client.Extensions().ReplicaSets(config.Namespace).Create(rs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error creating replica set: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config.RCConfigLog("Created replica set with name: %v, namespace: %v, replica count: %v", rs.Name, config.Namespace, removePtr(rs.Spec.Replicas))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunJob baunches (and verifies correctness) of a Job
0000000000000000000000000000000000000000;;	// and will wait for all pods it spawns to become "Running".
0000000000000000000000000000000000000000;;	// It's the caller's responsibility to clean up externally (i.e. use the
0000000000000000000000000000000000000000;;	// namespace lifecycle for handling Cleanup).
0000000000000000000000000000000000000000;;	func RunJob(config JobConfig) error {
0000000000000000000000000000000000000000;;		err := config.create()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return config.start()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *JobConfig) Run() error {
0000000000000000000000000000000000000000;;		return RunJob(*config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *JobConfig) GetKind() schema.GroupKind {
0000000000000000000000000000000000000000;;		return batchinternal.Kind("Job")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *JobConfig) create() error {
0000000000000000000000000000000000000000;;		job := &batch.Job{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: config.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: batch.JobSpec{
0000000000000000000000000000000000000000;;				Parallelism: func(i int) *int32 { x := int32(i); return &x }(config.Replicas),
0000000000000000000000000000000000000000;;				Completions: func(i int) *int32 { x := int32(i); return &x }(config.Replicas),
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"name": config.Name},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:    config.Name,
0000000000000000000000000000000000000000;;								Image:   config.Image,
0000000000000000000000000000000000000000;;								Command: config.Command,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						RestartPolicy: v1.RestartPolicyOnFailure,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(config.SecretNames) > 0 {
0000000000000000000000000000000000000000;;			attachSecrets(&job.Spec.Template, config.SecretNames)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(config.ConfigMapNames) > 0 {
0000000000000000000000000000000000000000;;			attachConfigMaps(&job.Spec.Template, config.ConfigMapNames)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.applyTo(&job.Spec.Template)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := config.Client.Batch().Jobs(config.Namespace).Create(job)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error creating job: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config.RCConfigLog("Created job with name: %v, namespace: %v, parallelism/completions: %v", job.Name, config.Namespace, job.Spec.Parallelism)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunRC Launches (and verifies correctness) of a Replication Controller
0000000000000000000000000000000000000000;;	// and will wait for all pods it spawns to become "Running".
0000000000000000000000000000000000000000;;	// It's the caller's responsibility to clean up externally (i.e. use the
0000000000000000000000000000000000000000;;	// namespace lifecycle for handling Cleanup).
0000000000000000000000000000000000000000;;	func RunRC(config RCConfig) error {
0000000000000000000000000000000000000000;;		err := config.create()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return config.start()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *RCConfig) Run() error {
0000000000000000000000000000000000000000;;		return RunRC(*config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *RCConfig) GetName() string {
0000000000000000000000000000000000000000;;		return config.Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *RCConfig) GetNamespace() string {
0000000000000000000000000000000000000000;;		return config.Namespace
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *RCConfig) GetKind() schema.GroupKind {
0000000000000000000000000000000000000000;;		return api.Kind("ReplicationController")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *RCConfig) GetClient() clientset.Interface {
0000000000000000000000000000000000000000;;		return config.Client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *RCConfig) GetInternalClient() internalclientset.Interface {
0000000000000000000000000000000000000000;;		return config.InternalClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *RCConfig) SetClient(c clientset.Interface) {
0000000000000000000000000000000000000000;;		config.Client = c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *RCConfig) SetInternalClient(c internalclientset.Interface) {
0000000000000000000000000000000000000000;;		config.InternalClient = c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *RCConfig) GetReplicas() int {
0000000000000000000000000000000000000000;;		return config.Replicas
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *RCConfig) create() error {
0000000000000000000000000000000000000000;;		dnsDefault := v1.DNSDefault
0000000000000000000000000000000000000000;;		if config.DNSPolicy == nil {
0000000000000000000000000000000000000000;;			config.DNSPolicy = &dnsDefault
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		one := int64(1)
0000000000000000000000000000000000000000;;		rc := &v1.ReplicationController{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: config.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;				Replicas: func(i int) *int32 { x := int32(i); return &x }(config.Replicas),
0000000000000000000000000000000000000000;;				Selector: map[string]string{
0000000000000000000000000000000000000000;;					"name": config.Name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"name": config.Name},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Affinity: config.Affinity,
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:           config.Name,
0000000000000000000000000000000000000000;;								Image:          config.Image,
0000000000000000000000000000000000000000;;								Command:        config.Command,
0000000000000000000000000000000000000000;;								Ports:          []v1.ContainerPort{{ContainerPort: 80}},
0000000000000000000000000000000000000000;;								ReadinessProbe: config.ReadinessProbe,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						DNSPolicy:                     *config.DNSPolicy,
0000000000000000000000000000000000000000;;						NodeSelector:                  config.NodeSelector,
0000000000000000000000000000000000000000;;						TerminationGracePeriodSeconds: &one,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(config.SecretNames) > 0 {
0000000000000000000000000000000000000000;;			attachSecrets(rc.Spec.Template, config.SecretNames)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(config.ConfigMapNames) > 0 {
0000000000000000000000000000000000000000;;			attachConfigMaps(rc.Spec.Template, config.ConfigMapNames)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.applyTo(rc.Spec.Template)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := config.Client.Core().ReplicationControllers(config.Namespace).Create(rc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error creating replication controller: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config.RCConfigLog("Created replication controller with name: %v, namespace: %v, replica count: %v", rc.Name, config.Namespace, removePtr(rc.Spec.Replicas))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *RCConfig) applyTo(template *v1.PodTemplateSpec) {
0000000000000000000000000000000000000000;;		if config.Env != nil {
0000000000000000000000000000000000000000;;			for k, v := range config.Env {
0000000000000000000000000000000000000000;;				c := &template.Spec.Containers[0]
0000000000000000000000000000000000000000;;				c.Env = append(c.Env, v1.EnvVar{Name: k, Value: v})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.Labels != nil {
0000000000000000000000000000000000000000;;			for k, v := range config.Labels {
0000000000000000000000000000000000000000;;				template.ObjectMeta.Labels[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.NodeSelector != nil {
0000000000000000000000000000000000000000;;			template.Spec.NodeSelector = make(map[string]string)
0000000000000000000000000000000000000000;;			for k, v := range config.NodeSelector {
0000000000000000000000000000000000000000;;				template.Spec.NodeSelector[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.Ports != nil {
0000000000000000000000000000000000000000;;			for k, v := range config.Ports {
0000000000000000000000000000000000000000;;				c := &template.Spec.Containers[0]
0000000000000000000000000000000000000000;;				c.Ports = append(c.Ports, v1.ContainerPort{Name: k, ContainerPort: int32(v)})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.HostPorts != nil {
0000000000000000000000000000000000000000;;			for k, v := range config.HostPorts {
0000000000000000000000000000000000000000;;				c := &template.Spec.Containers[0]
0000000000000000000000000000000000000000;;				c.Ports = append(c.Ports, v1.ContainerPort{Name: k, ContainerPort: int32(v), HostPort: int32(v)})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.CpuLimit > 0 || config.MemLimit > 0 {
0000000000000000000000000000000000000000;;			template.Spec.Containers[0].Resources.Limits = v1.ResourceList{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.CpuLimit > 0 {
0000000000000000000000000000000000000000;;			template.Spec.Containers[0].Resources.Limits[v1.ResourceCPU] = *resource.NewMilliQuantity(config.CpuLimit, resource.DecimalSI)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.MemLimit > 0 {
0000000000000000000000000000000000000000;;			template.Spec.Containers[0].Resources.Limits[v1.ResourceMemory] = *resource.NewQuantity(config.MemLimit, resource.DecimalSI)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.CpuRequest > 0 || config.MemRequest > 0 {
0000000000000000000000000000000000000000;;			template.Spec.Containers[0].Resources.Requests = v1.ResourceList{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.CpuRequest > 0 {
0000000000000000000000000000000000000000;;			template.Spec.Containers[0].Resources.Requests[v1.ResourceCPU] = *resource.NewMilliQuantity(config.CpuRequest, resource.DecimalSI)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.MemRequest > 0 {
0000000000000000000000000000000000000000;;			template.Spec.Containers[0].Resources.Requests[v1.ResourceMemory] = *resource.NewQuantity(config.MemRequest, resource.DecimalSI)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(config.Volumes) > 0 {
0000000000000000000000000000000000000000;;			template.Spec.Volumes = config.Volumes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(config.VolumeMounts) > 0 {
0000000000000000000000000000000000000000;;			template.Spec.Containers[0].VolumeMounts = config.VolumeMounts
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RCStartupStatus struct {
0000000000000000000000000000000000000000;;		Expected              int
0000000000000000000000000000000000000000;;		Terminating           int
0000000000000000000000000000000000000000;;		Running               int
0000000000000000000000000000000000000000;;		RunningButNotReady    int
0000000000000000000000000000000000000000;;		Waiting               int
0000000000000000000000000000000000000000;;		Pending               int
0000000000000000000000000000000000000000;;		Unknown               int
0000000000000000000000000000000000000000;;		Inactive              int
0000000000000000000000000000000000000000;;		FailedContainers      int
0000000000000000000000000000000000000000;;		Created               []*v1.Pod
0000000000000000000000000000000000000000;;		ContainerRestartNodes sets.String
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *RCStartupStatus) String(name string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%v Pods: %d out of %d created, %d running, %d pending, %d waiting, %d inactive, %d terminating, %d unknown, %d runningButNotReady ",
0000000000000000000000000000000000000000;;			name, len(s.Created), s.Expected, s.Running, s.Pending, s.Waiting, s.Inactive, s.Terminating, s.Unknown, s.RunningButNotReady)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ComputeRCStartupStatus(pods []*v1.Pod, expected int) RCStartupStatus {
0000000000000000000000000000000000000000;;		startupStatus := RCStartupStatus{
0000000000000000000000000000000000000000;;			Expected:              expected,
0000000000000000000000000000000000000000;;			Created:               make([]*v1.Pod, 0, expected),
0000000000000000000000000000000000000000;;			ContainerRestartNodes: sets.NewString(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, p := range pods {
0000000000000000000000000000000000000000;;			if p.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;				startupStatus.Terminating++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			startupStatus.Created = append(startupStatus.Created, p)
0000000000000000000000000000000000000000;;			if p.Status.Phase == v1.PodRunning {
0000000000000000000000000000000000000000;;				ready := false
0000000000000000000000000000000000000000;;				for _, c := range p.Status.Conditions {
0000000000000000000000000000000000000000;;					if c.Type == v1.PodReady && c.Status == v1.ConditionTrue {
0000000000000000000000000000000000000000;;						ready = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if ready {
0000000000000000000000000000000000000000;;					// Only count a pod is running when it is also ready.
0000000000000000000000000000000000000000;;					startupStatus.Running++
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					startupStatus.RunningButNotReady++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, v := range FailedContainers(p) {
0000000000000000000000000000000000000000;;					startupStatus.FailedContainers = startupStatus.FailedContainers + v.Restarts
0000000000000000000000000000000000000000;;					startupStatus.ContainerRestartNodes.Insert(p.Spec.NodeName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if p.Status.Phase == v1.PodPending {
0000000000000000000000000000000000000000;;				if p.Spec.NodeName == "" {
0000000000000000000000000000000000000000;;					startupStatus.Waiting++
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					startupStatus.Pending++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if p.Status.Phase == v1.PodSucceeded || p.Status.Phase == v1.PodFailed {
0000000000000000000000000000000000000000;;				startupStatus.Inactive++
0000000000000000000000000000000000000000;;			} else if p.Status.Phase == v1.PodUnknown {
0000000000000000000000000000000000000000;;				startupStatus.Unknown++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return startupStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *RCConfig) start() error {
0000000000000000000000000000000000000000;;		// Don't force tests to fail if they don't care about containers restarting.
0000000000000000000000000000000000000000;;		var maxContainerFailures int
0000000000000000000000000000000000000000;;		if config.MaxContainerFailures == nil {
0000000000000000000000000000000000000000;;			maxContainerFailures = int(math.Max(1.0, float64(config.Replicas)*.01))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			maxContainerFailures = *config.MaxContainerFailures
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		label := labels.SelectorFromSet(labels.Set(map[string]string{"name": config.Name}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		PodStore := NewPodStore(config.Client, config.Namespace, label, fields.Everything())
0000000000000000000000000000000000000000;;		defer PodStore.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		interval := config.PollInterval
0000000000000000000000000000000000000000;;		if interval <= 0 {
0000000000000000000000000000000000000000;;			interval = 10 * time.Second
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		timeout := config.Timeout
0000000000000000000000000000000000000000;;		if timeout <= 0 {
0000000000000000000000000000000000000000;;			timeout = 5 * time.Minute
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldPods := make([]*v1.Pod, 0)
0000000000000000000000000000000000000000;;		oldRunning := 0
0000000000000000000000000000000000000000;;		lastChange := time.Now()
0000000000000000000000000000000000000000;;		for oldRunning != config.Replicas {
0000000000000000000000000000000000000000;;			time.Sleep(interval)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pods := PodStore.List()
0000000000000000000000000000000000000000;;			startupStatus := ComputeRCStartupStatus(pods, config.Replicas)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pods = startupStatus.Created
0000000000000000000000000000000000000000;;			if config.CreatedPods != nil {
0000000000000000000000000000000000000000;;				*config.CreatedPods = pods
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !config.Silent {
0000000000000000000000000000000000000000;;				config.RCConfigLog(startupStatus.String(config.Name))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if config.PodStatusFile != nil {
0000000000000000000000000000000000000000;;				fmt.Fprintf(config.PodStatusFile, "%d, running, %d, pending, %d, waiting, %d, inactive, %d, unknown, %d, runningButNotReady\n", startupStatus.Running, startupStatus.Pending, startupStatus.Waiting, startupStatus.Inactive, startupStatus.Unknown, startupStatus.RunningButNotReady)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if startupStatus.FailedContainers > maxContainerFailures {
0000000000000000000000000000000000000000;;				if config.NodeDumpFunc != nil {
0000000000000000000000000000000000000000;;					config.NodeDumpFunc(config.Client, startupStatus.ContainerRestartNodes.List(), config.RCConfigLog)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if config.ContainerDumpFunc != nil {
0000000000000000000000000000000000000000;;					// Get the logs from the failed containers to help diagnose what caused them to fail
0000000000000000000000000000000000000000;;					config.ContainerDumpFunc(config.Client, config.Namespace, config.RCConfigLog)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return fmt.Errorf("%d containers failed which is more than allowed %d", startupStatus.FailedContainers, maxContainerFailures)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(pods) < len(oldPods) || len(pods) > config.Replicas {
0000000000000000000000000000000000000000;;				// This failure mode includes:
0000000000000000000000000000000000000000;;				// kubelet is dead, so node controller deleted pods and rc creates more
0000000000000000000000000000000000000000;;				//	- diagnose by noting the pod diff below.
0000000000000000000000000000000000000000;;				// pod is unhealthy, so replication controller creates another to take its place
0000000000000000000000000000000000000000;;				//	- diagnose by comparing the previous "2 Pod states" lines for inactive pods
0000000000000000000000000000000000000000;;				errorStr := fmt.Sprintf("Number of reported pods for %s changed: %d vs %d", config.Name, len(pods), len(oldPods))
0000000000000000000000000000000000000000;;				config.RCConfigLog("%v, pods that changed since the last iteration:", errorStr)
0000000000000000000000000000000000000000;;				config.RCConfigLog(Diff(oldPods, pods).String(sets.NewString()))
0000000000000000000000000000000000000000;;				return fmt.Errorf(errorStr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(pods) > len(oldPods) || startupStatus.Running > oldRunning {
0000000000000000000000000000000000000000;;				lastChange = time.Now()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			oldPods = pods
0000000000000000000000000000000000000000;;			oldRunning = startupStatus.Running
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if time.Since(lastChange) > timeout {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if oldRunning != config.Replicas {
0000000000000000000000000000000000000000;;			// List only pods from a given replication controller.
0000000000000000000000000000000000000000;;			options := metav1.ListOptions{LabelSelector: label.String()}
0000000000000000000000000000000000000000;;			if pods, err := config.Client.Core().Pods(metav1.NamespaceAll).List(options); err == nil {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;					config.RCConfigLog("Pod %s\t%s\t%s\t%s", pod.Name, pod.Spec.NodeName, pod.Status.Phase, pod.DeletionTimestamp)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				config.RCConfigLog("Can't list pod debug info: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Errorf("Only %d pods started out of %d", oldRunning, config.Replicas)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Simplified version of RunRC, that does not create RC, but creates plain Pods.
0000000000000000000000000000000000000000;;	// Optionally waits for pods to start running (if waitForRunning == true).
0000000000000000000000000000000000000000;;	// The number of replicas must be non-zero.
0000000000000000000000000000000000000000;;	func StartPods(c clientset.Interface, replicas int, namespace string, podNamePrefix string,
0000000000000000000000000000000000000000;;		pod v1.Pod, waitForRunning bool, logFunc func(fmt string, args ...interface{})) error {
0000000000000000000000000000000000000000;;		// no pod to start
0000000000000000000000000000000000000000;;		if replicas < 1 {
0000000000000000000000000000000000000000;;			panic("StartPods: number of replicas must be non-zero")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		startPodsID := string(uuid.NewUUID()) // So that we can label and find them
0000000000000000000000000000000000000000;;		for i := 0; i < replicas; i++ {
0000000000000000000000000000000000000000;;			podName := fmt.Sprintf("%v-%v", podNamePrefix, i)
0000000000000000000000000000000000000000;;			pod.ObjectMeta.Name = podName
0000000000000000000000000000000000000000;;			pod.ObjectMeta.Labels["name"] = podName
0000000000000000000000000000000000000000;;			pod.ObjectMeta.Labels["startPodsID"] = startPodsID
0000000000000000000000000000000000000000;;			pod.Spec.Containers[0].Name = podName
0000000000000000000000000000000000000000;;			_, err := c.Core().Pods(namespace).Create(&pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logFunc("Waiting for running...")
0000000000000000000000000000000000000000;;		if waitForRunning {
0000000000000000000000000000000000000000;;			label := labels.SelectorFromSet(labels.Set(map[string]string{"startPodsID": startPodsID}))
0000000000000000000000000000000000000000;;			err := WaitForPodsWithLabelRunning(c, namespace, label)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Error waiting for %d pods to be running - probably a timeout: %v", replicas, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait up to 10 minutes for all matching pods to become Running and at least one
0000000000000000000000000000000000000000;;	// matching pod exists.
0000000000000000000000000000000000000000;;	func WaitForPodsWithLabelRunning(c clientset.Interface, ns string, label labels.Selector) error {
0000000000000000000000000000000000000000;;		running := false
0000000000000000000000000000000000000000;;		PodStore := NewPodStore(c, ns, label, fields.Everything())
0000000000000000000000000000000000000000;;		defer PodStore.Stop()
0000000000000000000000000000000000000000;;	waitLoop:
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < 10*time.Minute; time.Sleep(5 * time.Second) {
0000000000000000000000000000000000000000;;			pods := PodStore.List()
0000000000000000000000000000000000000000;;			if len(pods) == 0 {
0000000000000000000000000000000000000000;;				continue waitLoop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, p := range pods {
0000000000000000000000000000000000000000;;				if p.Status.Phase != v1.PodRunning {
0000000000000000000000000000000000000000;;					continue waitLoop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			running = true
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !running {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Timeout while waiting for pods with labels %q to be running", label.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CountToStrategy struct {
0000000000000000000000000000000000000000;;		Count    int
0000000000000000000000000000000000000000;;		Strategy PrepareNodeStrategy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TestNodePreparer interface {
0000000000000000000000000000000000000000;;		PrepareNodes() error
0000000000000000000000000000000000000000;;		CleanupNodes() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PrepareNodeStrategy interface {
0000000000000000000000000000000000000000;;		PreparePatch(node *v1.Node) []byte
0000000000000000000000000000000000000000;;		CleanupNode(node *v1.Node) *v1.Node
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TrivialNodePrepareStrategy struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*TrivialNodePrepareStrategy) PreparePatch(*v1.Node) []byte {
0000000000000000000000000000000000000000;;		return []byte{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*TrivialNodePrepareStrategy) CleanupNode(node *v1.Node) *v1.Node {
0000000000000000000000000000000000000000;;		nodeCopy := *node
0000000000000000000000000000000000000000;;		return &nodeCopy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type LabelNodePrepareStrategy struct {
0000000000000000000000000000000000000000;;		labelKey   string
0000000000000000000000000000000000000000;;		labelValue string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewLabelNodePrepareStrategy(labelKey string, labelValue string) *LabelNodePrepareStrategy {
0000000000000000000000000000000000000000;;		return &LabelNodePrepareStrategy{
0000000000000000000000000000000000000000;;			labelKey:   labelKey,
0000000000000000000000000000000000000000;;			labelValue: labelValue,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *LabelNodePrepareStrategy) PreparePatch(*v1.Node) []byte {
0000000000000000000000000000000000000000;;		labelString := fmt.Sprintf("{\"%v\":\"%v\"}", s.labelKey, s.labelValue)
0000000000000000000000000000000000000000;;		patch := fmt.Sprintf(`{"metadata":{"labels":%v}}`, labelString)
0000000000000000000000000000000000000000;;		return []byte(patch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *LabelNodePrepareStrategy) CleanupNode(node *v1.Node) *v1.Node {
0000000000000000000000000000000000000000;;		objCopy, err := api.Scheme.Copy(node)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return &v1.Node{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeCopy, ok := (objCopy).(*v1.Node)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return &v1.Node{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if node.Labels != nil && len(node.Labels[s.labelKey]) != 0 {
0000000000000000000000000000000000000000;;			delete(nodeCopy.Labels, s.labelKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodeCopy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DoPrepareNode(client clientset.Interface, node *v1.Node, strategy PrepareNodeStrategy) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		patch := strategy.PreparePatch(node)
0000000000000000000000000000000000000000;;		if len(patch) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for attempt := 0; attempt < retries; attempt++ {
0000000000000000000000000000000000000000;;			if _, err = client.Core().Nodes().Patch(node.Name, types.MergePatchType, []byte(patch)); err == nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !apierrs.IsConflict(err) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Error while applying patch %v to Node %v: %v", string(patch), node.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			time.Sleep(100 * time.Millisecond)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("To many conflicts when applying patch %v to Node %v", string(patch), node.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DoCleanupNode(client clientset.Interface, nodeName string, strategy PrepareNodeStrategy) error {
0000000000000000000000000000000000000000;;		for attempt := 0; attempt < retries; attempt++ {
0000000000000000000000000000000000000000;;			node, err := client.Core().Nodes().Get(nodeName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Skipping cleanup of Node: failed to get Node %v: %v", nodeName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			updatedNode := strategy.CleanupNode(node)
0000000000000000000000000000000000000000;;			if apiequality.Semantic.DeepEqual(node, updatedNode) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err = client.Core().Nodes().Update(updatedNode); err == nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !apierrs.IsConflict(err) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Error when updating Node %v: %v", nodeName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			time.Sleep(100 * time.Millisecond)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("To many conflicts when trying to cleanup Node %v", nodeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TestPodCreateStrategy func(client clientset.Interface, namespace string, podCount int) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CountToPodStrategy struct {
0000000000000000000000000000000000000000;;		Count    int
0000000000000000000000000000000000000000;;		Strategy TestPodCreateStrategy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TestPodCreatorConfig map[string][]CountToPodStrategy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewTestPodCreatorConfig() *TestPodCreatorConfig {
0000000000000000000000000000000000000000;;		config := make(TestPodCreatorConfig)
0000000000000000000000000000000000000000;;		return &config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *TestPodCreatorConfig) AddStrategy(
0000000000000000000000000000000000000000;;		namespace string, podCount int, strategy TestPodCreateStrategy) {
0000000000000000000000000000000000000000;;		(*c)[namespace] = append((*c)[namespace], CountToPodStrategy{Count: podCount, Strategy: strategy})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TestPodCreator struct {
0000000000000000000000000000000000000000;;		Client clientset.Interface
0000000000000000000000000000000000000000;;		// namespace -> count -> strategy
0000000000000000000000000000000000000000;;		Config *TestPodCreatorConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewTestPodCreator(client clientset.Interface, config *TestPodCreatorConfig) *TestPodCreator {
0000000000000000000000000000000000000000;;		return &TestPodCreator{
0000000000000000000000000000000000000000;;			Client: client,
0000000000000000000000000000000000000000;;			Config: config,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *TestPodCreator) CreatePods() error {
0000000000000000000000000000000000000000;;		for ns, v := range *(c.Config) {
0000000000000000000000000000000000000000;;			for _, countToStrategy := range v {
0000000000000000000000000000000000000000;;				if err := countToStrategy.Strategy(c.Client, ns, countToStrategy.Count); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MakePodSpec() v1.PodSpec {
0000000000000000000000000000000000000000;;		return v1.PodSpec{
0000000000000000000000000000000000000000;;			Containers: []v1.Container{{
0000000000000000000000000000000000000000;;				Name:  "pause",
0000000000000000000000000000000000000000;;				Image: "kubernetes/pause",
0000000000000000000000000000000000000000;;				Ports: []v1.ContainerPort{{ContainerPort: 80}},
0000000000000000000000000000000000000000;;				Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;					Limits: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceCPU:    resource.MustParse("100m"),
0000000000000000000000000000000000000000;;						v1.ResourceMemory: resource.MustParse("500Mi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceCPU:    resource.MustParse("100m"),
0000000000000000000000000000000000000000;;						v1.ResourceMemory: resource.MustParse("500Mi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeCreatePod(client clientset.Interface, namespace string, podTemplate *v1.Pod) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for attempt := 0; attempt < retries; attempt++ {
0000000000000000000000000000000000000000;;			if _, err := client.Core().Pods(namespace).Create(podTemplate); err == nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Errorf("Error while creating pod, maybe retry: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("Terminal error while creating pod, won't retry: %v", err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPod(client clientset.Interface, namespace string, podCount int, podTemplate *v1.Pod) error {
0000000000000000000000000000000000000000;;		var createError error
0000000000000000000000000000000000000000;;		lock := sync.Mutex{}
0000000000000000000000000000000000000000;;		createPodFunc := func(i int) {
0000000000000000000000000000000000000000;;			if err := makeCreatePod(client, namespace, podTemplate); err != nil {
0000000000000000000000000000000000000000;;				lock.Lock()
0000000000000000000000000000000000000000;;				defer lock.Unlock()
0000000000000000000000000000000000000000;;				createError = err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if podCount < 30 {
0000000000000000000000000000000000000000;;			workqueue.Parallelize(podCount, podCount, createPodFunc)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			workqueue.Parallelize(30, podCount, createPodFunc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return createError
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createController(client clientset.Interface, controllerName, namespace string, podCount int, podTemplate *v1.Pod) error {
0000000000000000000000000000000000000000;;		rc := &v1.ReplicationController{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: controllerName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;				Replicas: func(i int) *int32 { x := int32(i); return &x }(podCount),
0000000000000000000000000000000000000000;;				Selector: map[string]string{"name": controllerName},
0000000000000000000000000000000000000000;;				Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"name": controllerName},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: podTemplate.Spec,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for attempt := 0; attempt < retries; attempt++ {
0000000000000000000000000000000000000000;;			if _, err := client.Core().ReplicationControllers(namespace).Create(rc); err == nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Errorf("Error while creating rc, maybe retry: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("Terminal error while creating rc, won't retry: %v", err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCustomCreatePodStrategy(podTemplate *v1.Pod) TestPodCreateStrategy {
0000000000000000000000000000000000000000;;		return func(client clientset.Interface, namespace string, podCount int) error {
0000000000000000000000000000000000000000;;			return createPod(client, namespace, podCount, podTemplate)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSimpleCreatePodStrategy() TestPodCreateStrategy {
0000000000000000000000000000000000000000;;		basePod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				GenerateName: "simple-pod-",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: MakePodSpec(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return NewCustomCreatePodStrategy(basePod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSimpleWithControllerCreatePodStrategy(controllerName string) TestPodCreateStrategy {
0000000000000000000000000000000000000000;;		return func(client clientset.Interface, namespace string, podCount int) error {
0000000000000000000000000000000000000000;;			basePod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					GenerateName: controllerName + "-pod-",
0000000000000000000000000000000000000000;;					Labels:       map[string]string{"name": controllerName},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: MakePodSpec(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := createController(client, controllerName, namespace, podCount, basePod); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return createPod(client, namespace, podCount, basePod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SecretConfig struct {
0000000000000000000000000000000000000000;;		Content   map[string]string
0000000000000000000000000000000000000000;;		Client    clientset.Interface
0000000000000000000000000000000000000000;;		Name      string
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;		// If set this function will be used to print log lines instead of glog.
0000000000000000000000000000000000000000;;		LogFunc func(fmt string, args ...interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *SecretConfig) Run() error {
0000000000000000000000000000000000000000;;		secret := &v1.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: config.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			StringData: map[string]string{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range config.Content {
0000000000000000000000000000000000000000;;			secret.StringData[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := config.Client.Core().Secrets(config.Namespace).Create(secret)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error creating secret: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config.LogFunc("Created secret %v/%v", config.Namespace, config.Name)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *SecretConfig) Stop() error {
0000000000000000000000000000000000000000;;		if err := config.Client.Core().Secrets(config.Namespace).Delete(config.Name, &metav1.DeleteOptions{}); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error deleting secret: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config.LogFunc("Deleted secret %v/%v", config.Namespace, config.Name)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: attach secrets using different possibilities: env vars, image pull secrets.
0000000000000000000000000000000000000000;;	func attachSecrets(template *v1.PodTemplateSpec, secretNames []string) {
0000000000000000000000000000000000000000;;		volumes := make([]v1.Volume, 0, len(secretNames))
0000000000000000000000000000000000000000;;		mounts := make([]v1.VolumeMount, 0, len(secretNames))
0000000000000000000000000000000000000000;;		for _, name := range secretNames {
0000000000000000000000000000000000000000;;			volumes = append(volumes, v1.Volume{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					Secret: &v1.SecretVolumeSource{
0000000000000000000000000000000000000000;;						SecretName: name,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			mounts = append(mounts, v1.VolumeMount{
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;				MountPath: fmt.Sprintf("/%v", name),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		template.Spec.Volumes = volumes
0000000000000000000000000000000000000000;;		template.Spec.Containers[0].VolumeMounts = mounts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ConfigMapConfig struct {
0000000000000000000000000000000000000000;;		Content   map[string]string
0000000000000000000000000000000000000000;;		Client    clientset.Interface
0000000000000000000000000000000000000000;;		Name      string
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;		// If set this function will be used to print log lines instead of glog.
0000000000000000000000000000000000000000;;		LogFunc func(fmt string, args ...interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *ConfigMapConfig) Run() error {
0000000000000000000000000000000000000000;;		configMap := &v1.ConfigMap{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: config.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: map[string]string{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range config.Content {
0000000000000000000000000000000000000000;;			configMap.Data[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := config.Client.Core().ConfigMaps(config.Namespace).Create(configMap)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error creating configmap: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config.LogFunc("Created configmap %v/%v", config.Namespace, config.Name)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *ConfigMapConfig) Stop() error {
0000000000000000000000000000000000000000;;		if err := config.Client.Core().ConfigMaps(config.Namespace).Delete(config.Name, &metav1.DeleteOptions{}); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error deleting configmap: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config.LogFunc("Deleted configmap %v/%v", config.Namespace, config.Name)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: attach configmaps using different possibilities: env vars.
0000000000000000000000000000000000000000;;	func attachConfigMaps(template *v1.PodTemplateSpec, configMapNames []string) {
0000000000000000000000000000000000000000;;		volumes := make([]v1.Volume, 0, len(configMapNames))
0000000000000000000000000000000000000000;;		mounts := make([]v1.VolumeMount, 0, len(configMapNames))
0000000000000000000000000000000000000000;;		for _, name := range configMapNames {
0000000000000000000000000000000000000000;;			volumes = append(volumes, v1.Volume{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					ConfigMap: &v1.ConfigMapVolumeSource{
0000000000000000000000000000000000000000;;						LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;							Name: name,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			mounts = append(mounts, v1.VolumeMount{
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;				MountPath: fmt.Sprintf("/%v", name),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		template.Spec.Volumes = volumes
0000000000000000000000000000000000000000;;		template.Spec.Containers[0].VolumeMounts = mounts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DaemonConfig struct {
0000000000000000000000000000000000000000;;		Client    clientset.Interface
0000000000000000000000000000000000000000;;		Name      string
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;		Image     string
0000000000000000000000000000000000000000;;		// If set this function will be used to print log lines instead of glog.
0000000000000000000000000000000000000000;;		LogFunc func(fmt string, args ...interface{})
0000000000000000000000000000000000000000;;		// How long we wait for DaemonSet to become running.
0000000000000000000000000000000000000000;;		Timeout time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *DaemonConfig) Run() error {
0000000000000000000000000000000000000000;;		if config.Image == "" {
0000000000000000000000000000000000000000;;			config.Image = "kubernetes/pause"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nameLabel := map[string]string{
0000000000000000000000000000000000000000;;			"name": config.Name + "-daemon",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		daemon := &extensions.DaemonSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: config.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.DaemonSetSpec{
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: nameLabel,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  config.Name,
0000000000000000000000000000000000000000;;								Image: config.Image,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := config.Client.Extensions().DaemonSets(config.Namespace).Create(daemon)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error creating DaemonSet %v: %v", config.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var nodes *v1.NodeList
0000000000000000000000000000000000000000;;		for i := 0; i < retries; i++ {
0000000000000000000000000000000000000000;;			// Wait for all daemons to be running
0000000000000000000000000000000000000000;;			nodes, err = config.Client.Core().Nodes().List(metav1.ListOptions{ResourceVersion: "0"})
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			} else if i+1 == retries {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Error listing Nodes while waiting for DaemonSet %v: %v", config.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timeout := config.Timeout
0000000000000000000000000000000000000000;;		if timeout <= 0 {
0000000000000000000000000000000000000000;;			timeout = 5 * time.Minute
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podStore := NewPodStore(config.Client, config.Namespace, labels.SelectorFromSet(nameLabel), fields.Everything())
0000000000000000000000000000000000000000;;		defer podStore.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = wait.Poll(time.Second, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			pods := podStore.List()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nodeHasDaemon := sets.NewString()
0000000000000000000000000000000000000000;;			for _, pod := range pods {
0000000000000000000000000000000000000000;;				podReady, _ := PodRunningReady(pod)
0000000000000000000000000000000000000000;;				if pod.Spec.NodeName != "" && podReady {
0000000000000000000000000000000000000000;;					nodeHasDaemon.Insert(pod.Spec.NodeName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			running := len(nodeHasDaemon)
0000000000000000000000000000000000000000;;			config.LogFunc("Found %v/%v Daemons %v running", running, config.Name, len(nodes.Items))
0000000000000000000000000000000000000000;;			return running == len(nodes.Items), nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			config.LogFunc("Timed out while waiting for DaemonsSet %v/%v to be running.", config.Namespace, config.Name)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			config.LogFunc("Created Daemon %v/%v", config.Namespace, config.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
