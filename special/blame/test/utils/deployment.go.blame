0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
921aa7aeed3370053e7941d5e7b784ea504662c0;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package utils
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/davecgh/go-spew/spew"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		deploymentutil "k8s.io/kubernetes/pkg/controller/deployment/util"
0000000000000000000000000000000000000000;;		labelsutil "k8s.io/kubernetes/pkg/util/labels"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type LogfFn func(format string, args ...interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LogReplicaSetsOfDeployment(deployment *extensions.Deployment, allOldRSs []*extensions.ReplicaSet, newRS *extensions.ReplicaSet, logf LogfFn) {
0000000000000000000000000000000000000000;;		if newRS != nil {
0000000000000000000000000000000000000000;;			logf(spew.Sprintf("New ReplicaSet %q of Deployment %q:\n%+v", newRS.Name, deployment.Name, *newRS))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			logf("New ReplicaSet of Deployment %q is nil.", deployment.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(allOldRSs) > 0 {
0000000000000000000000000000000000000000;;			logf("All old ReplicaSets of Deployment %q:", deployment.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range allOldRSs {
0000000000000000000000000000000000000000;;			logf(spew.Sprintf("%+v", *allOldRSs[i]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LogPodsOfDeployment(c clientset.Interface, deployment *extensions.Deployment, rsList []*extensions.ReplicaSet, logf LogfFn) {
0000000000000000000000000000000000000000;;		minReadySeconds := deployment.Spec.MinReadySeconds
0000000000000000000000000000000000000000;;		podListFunc := func(namespace string, options metav1.ListOptions) (*v1.PodList, error) {
0000000000000000000000000000000000000000;;			return c.Core().Pods(namespace).List(options)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podList, err := deploymentutil.ListPods(deployment, rsList, podListFunc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			logf("Failed to list Pods of Deployment %q: %v", deployment.Name, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pod := range podList.Items {
0000000000000000000000000000000000000000;;			availability := "not available"
0000000000000000000000000000000000000000;;			if podutil.IsPodAvailable(&pod, minReadySeconds, metav1.Now()) {
0000000000000000000000000000000000000000;;				availability = "available"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			logf(spew.Sprintf("Pod %q is %s:\n%+v", pod.Name, availability, pod))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Waits for the deployment status to become valid (i.e. max unavailable and max surge aren't violated anymore).
0000000000000000000000000000000000000000;;	// Note that the status should stay valid at all times unless shortly after a scaling event or the deployment is just created.
0000000000000000000000000000000000000000;;	// To verify that the deployment status is valid and wait for the rollout to finish, use WaitForDeploymentStatus instead.
0000000000000000000000000000000000000000;;	func WaitForDeploymentStatusValid(c clientset.Interface, d *extensions.Deployment, logf LogfFn, pollInterval, pollTimeout time.Duration) error {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			oldRSs, allOldRSs, allRSs []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;			newRS                     *extensions.ReplicaSet
0000000000000000000000000000000000000000;;			deployment                *extensions.Deployment
0000000000000000000000000000000000000000;;			reason                    string
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := wait.Poll(pollInterval, pollTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			deployment, err = c.Extensions().Deployments(d.Namespace).Get(d.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			oldRSs, allOldRSs, newRS, err = deploymentutil.GetAllReplicaSets(deployment, c)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if newRS == nil {
0000000000000000000000000000000000000000;;				// New RC hasn't been created yet.
0000000000000000000000000000000000000000;;				reason = "new replica set hasn't been created yet"
0000000000000000000000000000000000000000;;				logf(reason)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allRSs = append(oldRSs, newRS)
0000000000000000000000000000000000000000;;			// The old/new ReplicaSets need to contain the pod-template-hash label
0000000000000000000000000000000000000000;;			for i := range allRSs {
0000000000000000000000000000000000000000;;				if !labelsutil.SelectorHasLabel(allRSs[i].Spec.Selector, extensions.DefaultDeploymentUniqueLabelKey) {
0000000000000000000000000000000000000000;;					reason = "all replica sets need to contain the pod-template-hash label"
0000000000000000000000000000000000000000;;					logf(reason)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			totalCreated := deploymentutil.GetReplicaCountForReplicaSets(allRSs)
0000000000000000000000000000000000000000;;			maxCreated := *(deployment.Spec.Replicas) + deploymentutil.MaxSurge(*deployment)
0000000000000000000000000000000000000000;;			if totalCreated > maxCreated {
0000000000000000000000000000000000000000;;				reason = fmt.Sprintf("total pods created: %d, more than the max allowed: %d", totalCreated, maxCreated)
0000000000000000000000000000000000000000;;				logf(reason)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			minAvailable := deploymentutil.MinAvailable(deployment)
0000000000000000000000000000000000000000;;			if deployment.Status.AvailableReplicas < minAvailable {
0000000000000000000000000000000000000000;;				reason = fmt.Sprintf("total pods available: %d, less than the min required: %d", deployment.Status.AvailableReplicas, minAvailable)
0000000000000000000000000000000000000000;;				logf(reason)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// When the deployment status and its underlying resources reach the desired state, we're done
0000000000000000000000000000000000000000;;			if deploymentutil.DeploymentComplete(deployment, &deployment.Status) {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			reason = fmt.Sprintf("deployment status: %#v", deployment.Status)
0000000000000000000000000000000000000000;;			logf(reason)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			LogReplicaSetsOfDeployment(deployment, allOldRSs, newRS, logf)
0000000000000000000000000000000000000000;;			LogPodsOfDeployment(c, deployment, allRSs, logf)
0000000000000000000000000000000000000000;;			err = fmt.Errorf("%s", reason)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error waiting for deployment %q status to match expectation: %v", d.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForDeploymentRevisionAndImage waits for the deployment's and its new RS's revision and container image to match the given revision and image.
0000000000000000000000000000000000000000;;	// Note that deployment revision and its new RS revision should be updated shortly, so we only wait for 1 minute here to fail early.
0000000000000000000000000000000000000000;;	func WaitForDeploymentRevisionAndImage(c clientset.Interface, ns, deploymentName string, revision, image string, logf LogfFn, pollInterval, pollTimeout time.Duration) error {
0000000000000000000000000000000000000000;;		var deployment *extensions.Deployment
0000000000000000000000000000000000000000;;		var newRS *extensions.ReplicaSet
0000000000000000000000000000000000000000;;		var reason string
0000000000000000000000000000000000000000;;		err := wait.Poll(pollInterval, pollTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			deployment, err = c.Extensions().Deployments(ns).Get(deploymentName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// The new ReplicaSet needs to be non-nil and contain the pod-template-hash label
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			newRS, err = deploymentutil.GetNewReplicaSet(deployment, c)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if newRS == nil {
0000000000000000000000000000000000000000;;				reason = fmt.Sprintf("New replica set for deployment %q is yet to be created", deployment.Name)
0000000000000000000000000000000000000000;;				logf(reason)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !labelsutil.SelectorHasLabel(newRS.Spec.Selector, extensions.DefaultDeploymentUniqueLabelKey) {
0000000000000000000000000000000000000000;;				reason = fmt.Sprintf("New replica set %q doesn't have DefaultDeploymentUniqueLabelKey", newRS.Name)
0000000000000000000000000000000000000000;;				logf(reason)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Check revision of this deployment, and of the new replica set of this deployment
0000000000000000000000000000000000000000;;			if deployment.Annotations == nil || deployment.Annotations[deploymentutil.RevisionAnnotation] != revision {
0000000000000000000000000000000000000000;;				reason = fmt.Sprintf("Deployment %q doesn't have the required revision set", deployment.Name)
0000000000000000000000000000000000000000;;				logf(reason)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if deployment.Spec.Template.Spec.Containers[0].Image != image {
0000000000000000000000000000000000000000;;				reason = fmt.Sprintf("Deployment %q doesn't have the required image set", deployment.Name)
0000000000000000000000000000000000000000;;				logf(reason)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if newRS.Annotations == nil || newRS.Annotations[deploymentutil.RevisionAnnotation] != revision {
0000000000000000000000000000000000000000;;				reason = fmt.Sprintf("New replica set %q doesn't have the required revision set", newRS.Name)
0000000000000000000000000000000000000000;;				logf(reason)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if newRS.Spec.Template.Spec.Containers[0].Image != image {
0000000000000000000000000000000000000000;;				reason = fmt.Sprintf("New replica set %q doesn't have the required image set", newRS.Name)
0000000000000000000000000000000000000000;;				logf(reason)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			LogReplicaSetsOfDeployment(deployment, nil, newRS, logf)
0000000000000000000000000000000000000000;;			err = fmt.Errorf(reason)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if newRS == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("deployment %q failed to create new replica set", deploymentName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error waiting for deployment %q (got %s / %s) and new replica set %q (got %s / %s) revision and image to match expectation (expected %s / %s): %v", deploymentName, deployment.Annotations[deploymentutil.RevisionAnnotation], deployment.Spec.Template.Spec.Containers[0].Image, newRS.Name, newRS.Annotations[deploymentutil.RevisionAnnotation], newRS.Spec.Template.Spec.Containers[0].Image, revision, image, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
