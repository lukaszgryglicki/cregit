0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
45be65257bc252c2a28c185e4061db469c31c2b0;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/flag"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/logs"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ip = target for /whoami query
0000000000000000000000000000000000000000;;	// rip = returned ip
0000000000000000000000000000000000000000;;	// pip = this pod's ip
0000000000000000000000000000000000000000;;	// nip = this node's ip
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MasqTester struct {
0000000000000000000000000000000000000000;;		Port string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewMasqTester() *MasqTester {
0000000000000000000000000000000000000000;;		return &MasqTester{
0000000000000000000000000000000000000000;;			Port: "8080",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MasqTester) AddFlags(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		fs.StringVar(&m.Port, "port", m.Port, "The port to serve /checknosnat and /whoami endpoints on.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		m := NewMasqTester()
0000000000000000000000000000000000000000;;		m.AddFlags(pflag.CommandLine)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flag.InitFlags()
0000000000000000000000000000000000000000;;		logs.InitLogs()
0000000000000000000000000000000000000000;;		defer logs.FlushLogs()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := m.Run(); err != nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "%v\n", err)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MasqTester) Run() error {
0000000000000000000000000000000000000000;;		// pip is the current pod's IP and nip is the current node's IP
0000000000000000000000000000000000000000;;		// pull the pip and nip out of the env
0000000000000000000000000000000000000000;;		pip, ok := os.LookupEnv("POD_IP")
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("POD_IP env var was not present in the environment")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nip, ok := os.LookupEnv("NODE_IP")
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("NODE_IP env var was not present in the environment")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// validate that pip and nip are ip addresses.
0000000000000000000000000000000000000000;;		if net.ParseIP(pip) == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("POD_IP env var contained %q, which is not an IP address", pip)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if net.ParseIP(nip) == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("NODE_IP env var contained %q, which is not an IP address", nip)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// register handlers
0000000000000000000000000000000000000000;;		http.HandleFunc("/whoami", whoami)
0000000000000000000000000000000000000000;;		http.HandleFunc("/checknosnat", mkChecknosnat(pip, nip))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// spin up the server
0000000000000000000000000000000000000000;;		return http.ListenAndServe(":"+m.Port, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type handler func(http.ResponseWriter, *http.Request)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func joinErrors(errs []error, sep string) string {
0000000000000000000000000000000000000000;;		strs := make([]string, len(errs))
0000000000000000000000000000000000000000;;		for i, err := range errs {
0000000000000000000000000000000000000000;;			strs[i] = err.Error()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(strs, sep)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Builds checknosnat handler, using pod and node ip of current location
0000000000000000000000000000000000000000;;	func mkChecknosnat(pip string, nip string) handler {
0000000000000000000000000000000000000000;;		// Queries /whoami for each provided ip, resp 200 if all resp bodies match this Pod's ip, 500 otherwise
0000000000000000000000000000000000000000;;		return func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			errs := []error{}
0000000000000000000000000000000000000000;;			ips := strings.Split(req.URL.Query().Get("ips"), ",")
0000000000000000000000000000000000000000;;			for _, ip := range ips {
0000000000000000000000000000000000000000;;				if err := check(ip, pip, nip); err != nil {
0000000000000000000000000000000000000000;;					errs = append(errs, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(errs) > 0 {
0000000000000000000000000000000000000000;;				w.WriteHeader(500)
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, "%s", joinErrors(errs, ", "))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.WriteHeader(200)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Writes the req.RemoteAddr into the response, req.RemoteAddr is the address of the incoming connection
0000000000000000000000000000000000000000;;	func whoami(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "%s", req.RemoteAddr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Queries ip/whoami and compares response to pip, uses nip to differentiate SNAT from other potential failure modes
0000000000000000000000000000000000000000;;	func check(ip string, pip string, nip string) error {
0000000000000000000000000000000000000000;;		url := fmt.Sprintf("http://%s/whoami", ip)
0000000000000000000000000000000000000000;;		resp, err := http.Get(url)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rips := strings.Split(string(body), ":")
0000000000000000000000000000000000000000;;		if rips == nil || len(rips) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Invalid returned ip %q from %q", string(body), url)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rip := rips[0]
0000000000000000000000000000000000000000;;		if rip != pip {
0000000000000000000000000000000000000000;;			if rip == nip {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Returned ip %q != my Pod ip %q, == my Node ip %q - SNAT", rip, pip, nip)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Returned ip %q != my Pod ip %q or my Node ip %q - SNAT to unexpected ip (possible SNAT through unexpected interface on the way into another node)", rip, pip, nip)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
