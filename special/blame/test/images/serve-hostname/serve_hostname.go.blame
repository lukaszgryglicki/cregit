0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
1c2557ab40d8dd6549e5856d145aaca34b466a50;test/images/serve_hostname/serve_hostname.go[test/images/serve_hostname/serve_hostname.go][test/images/serve-hostname/serve_hostname.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A small utility to just serve the hostname on TCP and/or UDP.
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/signal"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		doTCP  = flag.Bool("tcp", false, "Serve raw over TCP.")
0000000000000000000000000000000000000000;;		doUDP  = flag.Bool("udp", false, "Serve raw over UDP.")
0000000000000000000000000000000000000000;;		doHTTP = flag.Bool("http", true, "Serve HTTP.")
0000000000000000000000000000000000000000;;		port   = flag.Int("port", 9376, "Port number.")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if *doHTTP && (*doTCP || *doUDP) {
0000000000000000000000000000000000000000;;			log.Fatalf("Can't server TCP/UDP mode and HTTP mode at the same time")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostname, err := os.Hostname()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Fatalf("Error from os.Hostname(): %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if *doTCP {
0000000000000000000000000000000000000000;;			listener, err := net.Listen("tcp", fmt.Sprintf(":%d", *port))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				log.Fatalf("Error from net.Listen(): %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				for {
0000000000000000000000000000000000000000;;					conn, err := listener.Accept()
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						log.Fatalf("Error from Accept(): %s", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					log.Printf("TCP request from %s", conn.RemoteAddr().String())
0000000000000000000000000000000000000000;;					conn.Write([]byte(hostname))
0000000000000000000000000000000000000000;;					conn.Close()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if *doUDP {
0000000000000000000000000000000000000000;;			addr, err := net.ResolveUDPAddr("udp", fmt.Sprintf(":%d", *port))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				log.Fatalf("Error from net.ResolveUDPAddr(): %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sock, err := net.ListenUDP("udp", addr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				log.Fatalf("Error from ListenUDP(): %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				var buffer [16]byte
0000000000000000000000000000000000000000;;				for {
0000000000000000000000000000000000000000;;					_, cliAddr, err := sock.ReadFrom(buffer[0:])
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						log.Fatalf("Error from ReadFrom(): %s", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					log.Printf("UDP request from %s", cliAddr.String())
0000000000000000000000000000000000000000;;					sock.WriteTo([]byte(hostname), cliAddr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if *doHTTP {
0000000000000000000000000000000000000000;;			http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;				log.Printf("HTTP request from %s", r.RemoteAddr)
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, "%s", hostname)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				// Run in a closure so http.ListenAndServe doesn't block
0000000000000000000000000000000000000000;;				log.Fatal(http.ListenAndServe(fmt.Sprintf(":%d", *port), nil))
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write to stdout after receiving SIGTERM and SIGINT to help with debugging kubernetes issue #21605
0000000000000000000000000000000000000000;;		signals := make(chan os.Signal)
0000000000000000000000000000000000000000;;		signal.Notify(signals, syscall.SIGTERM, syscall.SIGINT)
0000000000000000000000000000000000000000;;		sig := <-signals
0000000000000000000000000000000000000000;;		// Keep behavior consistent with how the signal is handled by default (default is to panic)
0000000000000000000000000000000000000000;;		log.Panicf("Terminating after receiving signal: %s.\n", sig)
0000000000000000000000000000000000000000;;	}
