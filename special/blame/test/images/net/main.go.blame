0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
81895b6d734a23f6736a4b135f1385475ef7441d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/images/net/common"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/images/net/nat"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type runnerMap map[string]common.Runner
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type runRequestJSON struct {
0000000000000000000000000000000000000000;;		runner  string
0000000000000000000000000000000000000000;;		options interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// flags for the command line. See usage args below for
0000000000000000000000000000000000000000;;		// descriptions.
0000000000000000000000000000000000000000;;		flags struct {
0000000000000000000000000000000000000000;;			Serve   string
0000000000000000000000000000000000000000;;			Runner  string
0000000000000000000000000000000000000000;;			Options string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// runners is a map from runner name to runner instance.
0000000000000000000000000000000000000000;;		runners = makeRunnerMap()
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type logOutput struct {
0000000000000000000000000000000000000000;;		b bytes.Buffer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		initFlags()
0000000000000000000000000000000000000000;;		log.SetFlags(log.Flags() | log.Lshortfile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if flags.Serve == "" {
0000000000000000000000000000000000000000;;			output, err := executeRunner(flags.Runner, flags.Options)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				fmt.Print("output:\n\n" + output.b.String())
0000000000000000000000000000000000000000;;				os.Exit(0)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				log.Printf("Error: %v", err)
0000000000000000000000000000000000000000;;				fmt.Print("output:\n\n" + output.b.String())
0000000000000000000000000000000000000000;;				os.Exit(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			http.HandleFunc("/run/", handleRunRequest)
0000000000000000000000000000000000000000;;			log.Printf("Running server on %v", flags.Serve)
0000000000000000000000000000000000000000;;			log.Fatal(http.ListenAndServe(flags.Serve, nil))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func initFlags() {
0000000000000000000000000000000000000000;;		legalRunners := ""
0000000000000000000000000000000000000000;;		for k := range runners {
0000000000000000000000000000000000000000;;			legalRunners += " " + k
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		flag.StringVar(
0000000000000000000000000000000000000000;;			&flags.Serve, "serve", "",
0000000000000000000000000000000000000000;;			"Address and port to bind to (e.g. 127.0.0.1:8080). Setting this will "+
0000000000000000000000000000000000000000;;				"run the network tester in server mode runner are triggered through "+
0000000000000000000000000000000000000000;;				"HTTP requests.")
0000000000000000000000000000000000000000;;		flag.StringVar(
0000000000000000000000000000000000000000;;			&flags.Runner, "runner", "",
0000000000000000000000000000000000000000;;			"Runner to execute (available:"+legalRunners+")")
0000000000000000000000000000000000000000;;		flag.StringVar(
0000000000000000000000000000000000000000;;			&flags.Options, "options", "",
0000000000000000000000000000000000000000;;			"JSON options to the Runner")
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if flags.Runner == "" && flags.Serve == "" {
0000000000000000000000000000000000000000;;			log.Fatalf("Must set either -runner or -serve, see --help")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeRunnerMap() runnerMap {
0000000000000000000000000000000000000000;;		// runner name is <pkg>-<file>-<specific>.
0000000000000000000000000000000000000000;;		return runnerMap{
0000000000000000000000000000000000000000;;			"nat-closewait-client": nat.NewCloseWaitClient(),
0000000000000000000000000000000000000000;;			"nat-closewait-server": nat.NewCloseWaitServer(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func executeRunner(name string, rawOptions string) (logOutput, error) {
0000000000000000000000000000000000000000;;		runner, ok := runners[name]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			options := runner.NewOptions()
0000000000000000000000000000000000000000;;			if err := json.Unmarshal([]byte(rawOptions), options); err != nil {
0000000000000000000000000000000000000000;;				return logOutput{}, fmt.Errorf("Invalid options JSON: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			log.Printf("Options: %+v", options)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			output := logOutput{}
0000000000000000000000000000000000000000;;			logger := log.New(&output.b, "# ", log.Lshortfile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return output, runner.Run(logger, options)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return logOutput{}, fmt.Errorf("Invalid runner: '%v', see --help", runner)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handleRunRequest handles a request JSON to the network tester.
0000000000000000000000000000000000000000;;	func handleRunRequest(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		log.Printf("handleRunRequest %v", *r)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		urlParts := strings.Split(r.URL.Path, "/")
0000000000000000000000000000000000000000;;		if len(urlParts) != 3 {
0000000000000000000000000000000000000000;;			http.Error(w, fmt.Sprintf("invalid request to run: %v", urlParts), 400)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner := urlParts[2]
0000000000000000000000000000000000000000;;		if r.Body == nil {
0000000000000000000000000000000000000000;;			http.Error(w, "Missing request body", 400)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(r.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			http.Error(w, fmt.Sprintf("error reading body: %v", err), 400)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var output logOutput
0000000000000000000000000000000000000000;;		if output, err = executeRunner(runner, string(body)); err != nil {
0000000000000000000000000000000000000000;;			contents := fmt.Sprintf("Error from runner: %v\noutput:\n\n%s",
0000000000000000000000000000000000000000;;				err, output.b.String())
0000000000000000000000000000000000000000;;			http.Error(w, contents, 500)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "ok\noutput:\n\n"+output.b.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setupLogger() {
0000000000000000000000000000000000000000;;	}
