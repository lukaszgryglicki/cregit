0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
81895b6d734a23f6736a4b135f1385475ef7441d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package nat
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	client/server for testing CLOSE_WAIT timeout condition in iptables NAT.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	client              server
0000000000000000000000000000000000000000;;	  |                   |
0000000000000000000000000000000000000000;;	  |<--tcp handshake-->|
0000000000000000000000000000000000000000;;	  |<-------fin--------| half-close from server
0000000000000000000000000000000000000000;;	  |                   | client is in CLOSE_WAIT
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/images/net/common"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// leakedConnection is a global variable that should leak the active
0000000000000000000000000000000000000000;;	// connection assigned here.
0000000000000000000000000000000000000000;;	var leakedConnection *net.TCPConn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Server JSON options.
0000000000000000000000000000000000000000;;	type CloseWaitServerOptions struct {
0000000000000000000000000000000000000000;;		// Address to bind for the test
0000000000000000000000000000000000000000;;		LocalAddr string
0000000000000000000000000000000000000000;;		// Timeout to wait after sending the FIN.
0000000000000000000000000000000000000000;;		PostFinTimeoutSeconds int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type closeWaitServer struct {
0000000000000000000000000000000000000000;;		options *CloseWaitServerOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCloseWaitServer returns a new Runner.
0000000000000000000000000000000000000000;;	func NewCloseWaitServer() common.Runner {
0000000000000000000000000000000000000000;;		return &closeWaitServer{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewOptions allocates new options structure.
0000000000000000000000000000000000000000;;	func (server *closeWaitServer) NewOptions() interface{} {
0000000000000000000000000000000000000000;;		return &CloseWaitServerOptions{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run the server-side of the test.
0000000000000000000000000000000000000000;;	func (server *closeWaitServer) Run(logger *log.Logger, rawOptions interface{}) error {
0000000000000000000000000000000000000000;;		if options, ok := rawOptions.(*CloseWaitServerOptions); ok {
0000000000000000000000000000000000000000;;			server.options = options
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return errors.New("invalid type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logger.Printf("Run %v", server.options)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addr, err := net.ResolveTCPAddr("tcp", server.options.LocalAddr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listener, err := net.ListenTCP("tcp", addr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer listener.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logger.Printf("Server listening on %v", addr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn, err := listener.AcceptTCP()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer conn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logger.Printf("Client connected")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Send client half-close FIN so client is now in CLOSE_WAIT. We keep
0000000000000000000000000000000000000000;;		// the client -> server pipe open to verify whether or not the NAT
0000000000000000000000000000000000000000;;		// dropped our connection.
0000000000000000000000000000000000000000;;		if err := conn.CloseWrite(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logger.Printf("Server sent FIN, waiting %v seconds",
0000000000000000000000000000000000000000;;			server.options.PostFinTimeoutSeconds)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-time.After(time.Duration(server.options.PostFinTimeoutSeconds) * time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logger.Printf("Done")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Client JSON options
0000000000000000000000000000000000000000;;	type CloseWaitClientOptions struct {
0000000000000000000000000000000000000000;;		// RemoteAddr of the server to connect to.
0000000000000000000000000000000000000000;;		RemoteAddr string
0000000000000000000000000000000000000000;;		// TimeoutSeconds on I/O with the server.
0000000000000000000000000000000000000000;;		TimeoutSeconds int
0000000000000000000000000000000000000000;;		// Half-close timeout (to give the test time to check the status of the
0000000000000000000000000000000000000000;;		// conntrack table entry.
0000000000000000000000000000000000000000;;		PostFinTimeoutSeconds int
0000000000000000000000000000000000000000;;		// Leak connection (assign to global variable so connection persists
0000000000000000000000000000000000000000;;		// as long as the process remains.
0000000000000000000000000000000000000000;;		LeakConnection bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type closeWaitClient struct {
0000000000000000000000000000000000000000;;		options *CloseWaitClientOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCloseWaitClient creates a new runner
0000000000000000000000000000000000000000;;	func NewCloseWaitClient() common.Runner {
0000000000000000000000000000000000000000;;		return &closeWaitClient{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewOptions allocates new options structure.
0000000000000000000000000000000000000000;;	func (client *closeWaitClient) NewOptions() interface{} {
0000000000000000000000000000000000000000;;		return &CloseWaitClientOptions{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run the client.m
0000000000000000000000000000000000000000;;	func (client *closeWaitClient) Run(logger *log.Logger, rawOptions interface{}) error {
0000000000000000000000000000000000000000;;		if options, ok := rawOptions.(*CloseWaitClientOptions); ok {
0000000000000000000000000000000000000000;;			client.options = options
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return errors.New("invalid type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logger.Printf("Run %v", client.options)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addr, err := net.ResolveTCPAddr("tcp", client.options.RemoteAddr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn, err := net.DialTCP("tcp", nil, addr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !client.options.LeakConnection {
0000000000000000000000000000000000000000;;			defer conn.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logger.Printf("Connected to server")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if client.options.TimeoutSeconds > 0 {
0000000000000000000000000000000000000000;;			delay := time.Duration(client.options.TimeoutSeconds) * time.Second
0000000000000000000000000000000000000000;;			conn.SetReadDeadline(time.Now().Add(delay))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := make([]byte, 1, 1)
0000000000000000000000000000000000000000;;		size, err := conn.Read(buf)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if size != 0 {
0000000000000000000000000000000000000000;;			return errors.New("Got data but expected EOF")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logger.Printf("Server has half-closed the connection, waiting %v seconds",
0000000000000000000000000000000000000000;;			client.options.PostFinTimeoutSeconds)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if client.options.LeakConnection {
0000000000000000000000000000000000000000;;			logger.Printf("Leaking client connection (assigning to global variable)")
0000000000000000000000000000000000000000;;			leakedConnection = conn
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-time.After(
0000000000000000000000000000000000000000;;			time.Duration(client.options.PostFinTimeoutSeconds) * time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logger.Printf("Done")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
