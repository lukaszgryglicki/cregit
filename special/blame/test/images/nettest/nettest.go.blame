0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
01ade6984921519f10650c7b3f2089225191e125;contrib/for-tests/network-tester/webserver.go[contrib/for-tests/network-tester/webserver.go][test/images/nettest/nettest.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A tiny web server for checking networking connectivity.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Will dial out to, and expect to hear from, every pod that is a member of
0000000000000000000000000000000000000000;;	// the service passed in the flag -service.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Will serve a webserver on given -port.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Visit /read to see the current state, or /quit to shut down.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Visit /status to see pass/running/fail determination. (literally, it will
0000000000000000000000000000000000000000;;	// return one of those words.)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// /write is used by other network test pods to register connectivity.
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/signal"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		clientset "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		port          = flag.Int("port", 8080, "Port number to serve at.")
0000000000000000000000000000000000000000;;		peerCount     = flag.Int("peers", 8, "Must find at least this many peers for the test to pass.")
0000000000000000000000000000000000000000;;		service       = flag.String("service", "nettest", "Service to find other network test pods in.")
0000000000000000000000000000000000000000;;		namespace     = flag.String("namespace", "default", "Namespace of this pod. TODO: kubernetes should make this discoverable.")
0000000000000000000000000000000000000000;;		delayShutdown = flag.Int("delay-shutdown", 0, "Number of seconds to delay shutdown when receiving SIGTERM.")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// State tracks the internal state of our little http server.
0000000000000000000000000000000000000000;;	// It's returned verbatim over the /read endpoint.
0000000000000000000000000000000000000000;;	type State struct {
0000000000000000000000000000000000000000;;		// Hostname is set once and never changed-- it's always safe to read.
0000000000000000000000000000000000000000;;		Hostname string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The below fields require that lock is held before reading or writing.
0000000000000000000000000000000000000000;;		Sent                 map[string]int
0000000000000000000000000000000000000000;;		Received             map[string]int
0000000000000000000000000000000000000000;;		Errors               []string
0000000000000000000000000000000000000000;;		Log                  []string
0000000000000000000000000000000000000000;;		StillContactingPeers bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lock sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *State) doneContactingPeers() {
0000000000000000000000000000000000000000;;		s.lock.Lock()
0000000000000000000000000000000000000000;;		defer s.lock.Unlock()
0000000000000000000000000000000000000000;;		s.StillContactingPeers = false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serveStatus returns "pass", "running", or "fail".
0000000000000000000000000000000000000000;;	func (s *State) serveStatus(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		s.lock.Lock()
0000000000000000000000000000000000000000;;		defer s.lock.Unlock()
0000000000000000000000000000000000000000;;		if len(s.Sent) >= *peerCount && len(s.Received) >= *peerCount {
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "pass")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.StillContactingPeers {
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "running")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Logf can't be called while holding the lock, so defer using a goroutine
0000000000000000000000000000000000000000;;		go s.Logf("Declaring failure for %s/%s with %d sent and %d received and %d peers", *namespace, *service, len(s.Sent), len(s.Received), *peerCount)
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "fail")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serveRead writes our json encoded state
0000000000000000000000000000000000000000;;	func (s *State) serveRead(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		s.lock.Lock()
0000000000000000000000000000000000000000;;		defer s.lock.Unlock()
0000000000000000000000000000000000000000;;		w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;		b, err := json.MarshalIndent(s, "", "\t")
0000000000000000000000000000000000000000;;		s.appendErr(err)
0000000000000000000000000000000000000000;;		_, err = w.Write(b)
0000000000000000000000000000000000000000;;		s.appendErr(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WritePost is the format that (json encoded) requests to the /write handler should take.
0000000000000000000000000000000000000000;;	type WritePost struct {
0000000000000000000000000000000000000000;;		Source string
0000000000000000000000000000000000000000;;		Dest   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteResp is returned by /write
0000000000000000000000000000000000000000;;	type WriteResp struct {
0000000000000000000000000000000000000000;;		Hostname string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serveWrite records the contact in our state.
0000000000000000000000000000000000000000;;	func (s *State) serveWrite(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		defer r.Body.Close()
0000000000000000000000000000000000000000;;		s.lock.Lock()
0000000000000000000000000000000000000000;;		defer s.lock.Unlock()
0000000000000000000000000000000000000000;;		w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;		var wp WritePost
0000000000000000000000000000000000000000;;		s.appendErr(json.NewDecoder(r.Body).Decode(&wp))
0000000000000000000000000000000000000000;;		if wp.Source == "" {
0000000000000000000000000000000000000000;;			s.appendErr(fmt.Errorf("%v: Got request with no source", s.Hostname))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if s.Received == nil {
0000000000000000000000000000000000000000;;				s.Received = map[string]int{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.Received[wp.Source] += 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.appendErr(json.NewEncoder(w).Encode(&WriteResp{Hostname: s.Hostname}))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// appendErr adds err to the list, if err is not nil. s must be locked.
0000000000000000000000000000000000000000;;	func (s *State) appendErr(err error) {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			s.Errors = append(s.Errors, err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Logf writes to the log message list. s must not be locked.
0000000000000000000000000000000000000000;;	// s's Log member will drop an old message if it would otherwise
0000000000000000000000000000000000000000;;	// become longer than 500 messages.
0000000000000000000000000000000000000000;;	func (s *State) Logf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		s.lock.Lock()
0000000000000000000000000000000000000000;;		defer s.lock.Unlock()
0000000000000000000000000000000000000000;;		s.Log = append(s.Log, fmt.Sprintf(format, args...))
0000000000000000000000000000000000000000;;		if len(s.Log) > 500 {
0000000000000000000000000000000000000000;;			s.Log = s.Log[1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// s must not be locked
0000000000000000000000000000000000000000;;	func (s *State) appendSuccessfulSend(toHostname string) {
0000000000000000000000000000000000000000;;		s.lock.Lock()
0000000000000000000000000000000000000000;;		defer s.lock.Unlock()
0000000000000000000000000000000000000000;;		if s.Sent == nil {
0000000000000000000000000000000000000000;;			s.Sent = map[string]int{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.Sent[toHostname] += 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Our one and only state object
0000000000000000000000000000000000000000;;		state State
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if *service == "" {
0000000000000000000000000000000000000000;;			log.Fatal("Must provide -service flag.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostname, err := os.Hostname()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Fatalf("Error getting hostname: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if *delayShutdown > 0 {
0000000000000000000000000000000000000000;;			termCh := make(chan os.Signal)
0000000000000000000000000000000000000000;;			signal.Notify(termCh, syscall.SIGTERM)
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				<-termCh
0000000000000000000000000000000000000000;;				log.Printf("Sleeping %d seconds before exit ...", *delayShutdown)
0000000000000000000000000000000000000000;;				time.Sleep(time.Duration(*delayShutdown) * time.Second)
0000000000000000000000000000000000000000;;				os.Exit(0)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		state := State{
0000000000000000000000000000000000000000;;			Hostname:             hostname,
0000000000000000000000000000000000000000;;			StillContactingPeers: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go contactOthers(&state)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		http.HandleFunc("/quit", func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			os.Exit(0)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		http.HandleFunc("/read", state.serveRead)
0000000000000000000000000000000000000000;;		http.HandleFunc("/write", state.serveWrite)
0000000000000000000000000000000000000000;;		http.HandleFunc("/status", state.serveStatus)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go log.Fatal(http.ListenAndServe(fmt.Sprintf("0.0.0.0:%d", *port), nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Find all sibling pods in the service and post to their /write handler.
0000000000000000000000000000000000000000;;	func contactOthers(state *State) {
0000000000000000000000000000000000000000;;		sleepTime := 5 * time.Second
0000000000000000000000000000000000000000;;		// In large cluster getting all endpoints is pretty expensive.
0000000000000000000000000000000000000000;;		// Thus, we will limit ourselves to send on average at most 10 such
0000000000000000000000000000000000000000;;		// requests per second
0000000000000000000000000000000000000000;;		if sleepTime < time.Duration(*peerCount/10)*time.Second {
0000000000000000000000000000000000000000;;			sleepTime = time.Duration(*peerCount/10) * time.Second
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		timeout := 5 * time.Minute
0000000000000000000000000000000000000000;;		// Similarly we need to bump timeout so that it is reasonable in large
0000000000000000000000000000000000000000;;		// clusters.
0000000000000000000000000000000000000000;;		if timeout < time.Duration(*peerCount)*time.Second {
0000000000000000000000000000000000000000;;			timeout = time.Duration(*peerCount) * time.Second
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer state.doneContactingPeers()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config, err := restclient.InClusterConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Fatalf("Unable to create config; error: %v\n", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config.ContentType = "application/vnd.kubernetes.protobuf"
0000000000000000000000000000000000000000;;		client, err := clientset.NewForConfig(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Fatalf("Unable to create client; error: %v\n", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Double check that that worked by getting the server version.
0000000000000000000000000000000000000000;;		if v, err := client.Discovery().ServerVersion(); err != nil {
0000000000000000000000000000000000000000;;			log.Fatalf("Unable to get server version: %v\n", err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			log.Printf("Server version: %#v\n", v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < timeout; time.Sleep(sleepTime) {
0000000000000000000000000000000000000000;;			eps := getWebserverEndpoints(client)
0000000000000000000000000000000000000000;;			if eps.Len() >= *peerCount {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			state.Logf("%v/%v has %v endpoints (%v), which is less than %v as expected. Waiting for all endpoints to come up.", *namespace, *service, len(eps), eps.List(), *peerCount)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Do this repeatedly, in case there's some propagation delay with getting
0000000000000000000000000000000000000000;;		// newly started pods into the endpoints list.
0000000000000000000000000000000000000000;;		for i := 0; i < 15; i++ {
0000000000000000000000000000000000000000;;			eps := getWebserverEndpoints(client)
0000000000000000000000000000000000000000;;			for ep := range eps {
0000000000000000000000000000000000000000;;				state.Logf("Attempting to contact %s", ep)
0000000000000000000000000000000000000000;;				contactSingle(ep, state)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			time.Sleep(sleepTime)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//getWebserverEndpoints returns the webserver endpoints as a set of String, each in the format like "http://{ip}:{port}"
0000000000000000000000000000000000000000;;	func getWebserverEndpoints(client clientset.Interface) sets.String {
0000000000000000000000000000000000000000;;		endpoints, err := client.Core().Endpoints(*namespace).Get(*service, v1.GetOptions{})
0000000000000000000000000000000000000000;;		eps := sets.String{}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			state.Logf("Unable to read the endpoints for %v/%v: %v.", *namespace, *service, err)
0000000000000000000000000000000000000000;;			return eps
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ss := range endpoints.Subsets {
0000000000000000000000000000000000000000;;			for _, a := range ss.Addresses {
0000000000000000000000000000000000000000;;				for _, p := range ss.Ports {
0000000000000000000000000000000000000000;;					eps.Insert(fmt.Sprintf("http://%s:%d", a.IP, p.Port))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return eps
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// contactSingle dials the address 'e' and tries to POST to its /write address.
0000000000000000000000000000000000000000;;	func contactSingle(e string, state *State) {
0000000000000000000000000000000000000000;;		body, err := json.Marshal(&WritePost{
0000000000000000000000000000000000000000;;			Dest:   e,
0000000000000000000000000000000000000000;;			Source: state.Hostname,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Fatalf("json marshal error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := http.Post(e+"/write", "application/json", bytes.NewReader(body))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			state.Logf("Warning: unable to contact the endpoint %q: %v", e, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err = ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			state.Logf("Warning: unable to read response from '%v': '%v'", e, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var wr WriteResp
0000000000000000000000000000000000000000;;		err = json.Unmarshal(body, &wr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			state.Logf("Warning: unable to unmarshal response (%v) from '%v': '%v'", string(body), e, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		state.appendSuccessfulSend(wr.Hostname)
0000000000000000000000000000000000000000;;	}
