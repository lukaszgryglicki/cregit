0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2017 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	set -o errexit
0000000000000000000000000000000000000000;;	set -o nounset
0000000000000000000000000000000000000000;;	set -o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	TASK=$1
0000000000000000000000000000000000000000;;	IMAGE=$2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_ROOT="$(cd "$(dirname "${BASH_SOURCE}")/../.." && pwd -P)"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Mapping of go ARCH to actual architectures shipped part of multiarch/qemu-user-static project
0000000000000000000000000000000000000000;;	declare -A QEMUARCHS=( ["amd64"]="x86_64" ["arm"]="arm" ["arm64"]="aarch64" ["ppc64le"]="ppc64le" ["s390x"]="s390x" )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Returns list of all supported architectures from BASEIMAGE file
0000000000000000000000000000000000000000;;	listArchs() {
0000000000000000000000000000000000000000;;	  cut -d "=" -f 1 ${IMAGE}/BASEIMAGE
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Returns baseimage need to used in Dockerfile for any given architecture
0000000000000000000000000000000000000000;;	getBaseImage() {
0000000000000000000000000000000000000000;;	  arch=$1
0000000000000000000000000000000000000000;;	  echo $(grep "${arch}=" BASEIMAGE | cut -d= -f2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This function will build test image for all the architectures
0000000000000000000000000000000000000000;;	# mentioned in BASEIMAGE file. In the absence of BASEIMAGE file,
0000000000000000000000000000000000000000;;	# it will build for all the supported arch list - amd64, arm,
0000000000000000000000000000000000000000;;	# arm64, ppc64le, s390x
0000000000000000000000000000000000000000;;	build() {
0000000000000000000000000000000000000000;;	  if [[ -f ${IMAGE}/BASEIMAGE ]]; then
0000000000000000000000000000000000000000;;	    archs=$(listArchs)
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    archs=${!QEMUARCHS[@]}
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for arch in ${archs}; do
0000000000000000000000000000000000000000;;	    echo "Building image for ${IMAGE} ARCH: ${arch}..."
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Create a temporary directory for every architecture and copy the image content
0000000000000000000000000000000000000000;;	    # and build the image from temporary directory
0000000000000000000000000000000000000000;;	    temp_dir=$(mktemp -d)
0000000000000000000000000000000000000000;;	    cp -r ${IMAGE}/* ${temp_dir}
0000000000000000000000000000000000000000;;	    if [[ -f ${IMAGE}/Makefile ]]; then
0000000000000000000000000000000000000000;;	      # make bin will take care of all the prerequisites needed
0000000000000000000000000000000000000000;;	      # for building the docker image
0000000000000000000000000000000000000000;;	      make -C ${IMAGE} bin ARCH=${arch} TARGET=${temp_dir}
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    pushd ${temp_dir}
0000000000000000000000000000000000000000;;	    # image tag
0000000000000000000000000000000000000000;;	    TAG=$(<VERSION)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if [[ -f BASEIMAGE ]]; then
0000000000000000000000000000000000000000;;	      BASEIMAGE=$(getBaseImage ${arch})
0000000000000000000000000000000000000000;;	      sed -i "s|BASEIMAGE|${BASEIMAGE}|g" Dockerfile
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # copy the qemu-*-static binary to docker image to build the multi architecture image on x86 platform
0000000000000000000000000000000000000000;;	    if [[ $(grep "CROSS_BUILD_" Dockerfile) ]]; then
0000000000000000000000000000000000000000;;	      if [[ "${arch}" == "amd64" ]]; then
0000000000000000000000000000000000000000;;	        sed -i "/CROSS_BUILD_/d" Dockerfile
0000000000000000000000000000000000000000;;	      else
0000000000000000000000000000000000000000;;	        sed -i "s|QEMUARCH|${QEMUARCHS[$arch]}|g" Dockerfile
0000000000000000000000000000000000000000;;	        # Register qemu-*-static for all supported processors except the current one
0000000000000000000000000000000000000000;;	        docker run --rm --privileged multiarch/qemu-user-static:register --reset
0000000000000000000000000000000000000000;;	        curl -sSL https://github.com/multiarch/qemu-user-static/releases/download/${QEMUVERSION}/x86_64_qemu-${QEMUARCHS[$arch]}-static.tar.gz | tar -xz -C ${temp_dir}
0000000000000000000000000000000000000000;;	        sed -i "s/CROSS_BUILD_//g" Dockerfile
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    docker build --pull -t ${REGISTRY}/${IMAGE}-${arch}:${TAG} .
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    popd
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This function will push the docker images
0000000000000000000000000000000000000000;;	push() {
0000000000000000000000000000000000000000;;	  if [[ -f ${IMAGE}/BASEIMAGE ]]; then
0000000000000000000000000000000000000000;;	    archs=$(listArchs)
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    archs=${!QEMUARCHS[@]}
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  for arch in ${archs}; do
0000000000000000000000000000000000000000;;	    TAG=$(<${IMAGE}/VERSION)
0000000000000000000000000000000000000000;;	    gcloud docker -- push ${REGISTRY}/${IMAGE}-${arch}:${TAG}
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This function is for building the go code
0000000000000000000000000000000000000000;;	bin() {
0000000000000000000000000000000000000000;;	  for SRC in $@;
0000000000000000000000000000000000000000;;	  do
0000000000000000000000000000000000000000;;	  docker run --rm -it -v ${TARGET}:${TARGET}:Z -v ${KUBE_ROOT}:/go/src/k8s.io/kubernetes:Z \
0000000000000000000000000000000000000000;;	        golang:${GOLANG_VERSION} \
0000000000000000000000000000000000000000;;	        /bin/bash -c "\
0000000000000000000000000000000000000000;;	                cd /go/src/k8s.io/kubernetes/test/images/${SRC_DIR} && \
0000000000000000000000000000000000000000;;	                CGO_ENABLED=0 GOARM=${GOARM} GOARCH=${ARCH} go build -a -installsuffix cgo --ldflags '-w' -o ${TARGET}/${SRC} ./$(dirname ${SRC})"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	shift
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	eval ${TASK} "$@"
