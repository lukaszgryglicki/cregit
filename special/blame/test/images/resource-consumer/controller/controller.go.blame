0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
db93cd2e7da6e7cdf4e189c7094f5997048477a0;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "k8s.io/kubernetes/test/images/resource-consumer/common"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var port = flag.Int("port", 8080, "Port number.")
0000000000000000000000000000000000000000;;	var consumerPort = flag.Int("consumer-port", 8080, "Port number of consumers.")
0000000000000000000000000000000000000000;;	var consumerServiceName = flag.String("consumer-service-name", "resource-consumer", "Name of service containing resource consumers.")
0000000000000000000000000000000000000000;;	var consumerServiceNamespace = flag.String("consumer-service-namespace", "default", "Namespace of service containing resource consumers.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;		mgr := NewController()
0000000000000000000000000000000000000000;;		log.Fatal(http.ListenAndServe(fmt.Sprintf(":%d", *port), mgr))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Controller struct {
0000000000000000000000000000000000000000;;		responseWriterLock sync.Mutex
0000000000000000000000000000000000000000;;		waitGroup          sync.WaitGroup
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewController() *Controller {
0000000000000000000000000000000000000000;;		c := &Controller{}
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *Controller) ServeHTTP(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		if req.Method != "POST" {
0000000000000000000000000000000000000000;;			http.Error(w, BadRequest, http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// parsing POST request data and URL data
0000000000000000000000000000000000000000;;		if err := req.ParseForm(); err != nil {
0000000000000000000000000000000000000000;;			http.Error(w, err.Error(), http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// handle consumeCPU
0000000000000000000000000000000000000000;;		if req.URL.Path == ConsumeCPUAddress {
0000000000000000000000000000000000000000;;			handler.handleConsumeCPU(w, req.Form)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// handle consumeMem
0000000000000000000000000000000000000000;;		if req.URL.Path == ConsumeMemAddress {
0000000000000000000000000000000000000000;;			handler.handleConsumeMem(w, req.Form)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// handle bumpMetric
0000000000000000000000000000000000000000;;		if req.URL.Path == BumpMetricAddress {
0000000000000000000000000000000000000000;;			handler.handleBumpMetric(w, req.Form)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		http.Error(w, UnknownFunction, http.StatusNotFound)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *Controller) handleConsumeCPU(w http.ResponseWriter, query url.Values) {
0000000000000000000000000000000000000000;;		// geting string data for consumeCPU
0000000000000000000000000000000000000000;;		durationSecString := query.Get(DurationSecQuery)
0000000000000000000000000000000000000000;;		millicoresString := query.Get(MillicoresQuery)
0000000000000000000000000000000000000000;;		requestSizeInMillicoresString := query.Get(RequestSizeInMillicoresQuery)
0000000000000000000000000000000000000000;;		if durationSecString == "" || millicoresString == "" || requestSizeInMillicoresString == "" {
0000000000000000000000000000000000000000;;			http.Error(w, NotGivenFunctionArgument, http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// convert data (strings to ints) for consumeCPU
0000000000000000000000000000000000000000;;		durationSec, durationSecError := strconv.Atoi(durationSecString)
0000000000000000000000000000000000000000;;		millicores, millicoresError := strconv.Atoi(millicoresString)
0000000000000000000000000000000000000000;;		requestSizeInMillicores, requestSizeInMillicoresError := strconv.Atoi(requestSizeInMillicoresString)
0000000000000000000000000000000000000000;;		if durationSecError != nil || millicoresError != nil || requestSizeInMillicoresError != nil || requestSizeInMillicores <= 0 {
0000000000000000000000000000000000000000;;			http.Error(w, IncorrectFunctionArgument, http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		count := millicores / requestSizeInMillicores
0000000000000000000000000000000000000000;;		rest := millicores - count*requestSizeInMillicores
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "RC manager: sending %v requests to consume %v millicores each and 1 request to consume %v millicores\n", count, requestSizeInMillicores, rest)
0000000000000000000000000000000000000000;;		if count > 0 {
0000000000000000000000000000000000000000;;			handler.waitGroup.Add(count)
0000000000000000000000000000000000000000;;			handler.sendConsumeCPURequests(w, count, requestSizeInMillicores, durationSec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rest > 0 {
0000000000000000000000000000000000000000;;			handler.waitGroup.Add(1)
0000000000000000000000000000000000000000;;			go handler.sendOneConsumeCPURequest(w, rest, durationSec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler.waitGroup.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *Controller) handleConsumeMem(w http.ResponseWriter, query url.Values) {
0000000000000000000000000000000000000000;;		// geting string data for consumeMem
0000000000000000000000000000000000000000;;		durationSecString := query.Get(DurationSecQuery)
0000000000000000000000000000000000000000;;		megabytesString := query.Get(MegabytesQuery)
0000000000000000000000000000000000000000;;		requestSizeInMegabytesString := query.Get(RequestSizeInMegabytesQuery)
0000000000000000000000000000000000000000;;		if durationSecString == "" || megabytesString == "" || requestSizeInMegabytesString == "" {
0000000000000000000000000000000000000000;;			http.Error(w, NotGivenFunctionArgument, http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// convert data (strings to ints) for consumeMem
0000000000000000000000000000000000000000;;		durationSec, durationSecError := strconv.Atoi(durationSecString)
0000000000000000000000000000000000000000;;		megabytes, megabytesError := strconv.Atoi(megabytesString)
0000000000000000000000000000000000000000;;		requestSizeInMegabytes, requestSizeInMegabytesError := strconv.Atoi(requestSizeInMegabytesString)
0000000000000000000000000000000000000000;;		if durationSecError != nil || megabytesError != nil || requestSizeInMegabytesError != nil || requestSizeInMegabytes <= 0 {
0000000000000000000000000000000000000000;;			http.Error(w, IncorrectFunctionArgument, http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		count := megabytes / requestSizeInMegabytes
0000000000000000000000000000000000000000;;		rest := megabytes - count*requestSizeInMegabytes
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "RC manager: sending %v requests to consume %v MB each and 1 request to consume %v MB\n", count, requestSizeInMegabytes, rest)
0000000000000000000000000000000000000000;;		if count > 0 {
0000000000000000000000000000000000000000;;			handler.waitGroup.Add(count)
0000000000000000000000000000000000000000;;			handler.sendConsumeMemRequests(w, count, requestSizeInMegabytes, durationSec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rest > 0 {
0000000000000000000000000000000000000000;;			handler.waitGroup.Add(1)
0000000000000000000000000000000000000000;;			go handler.sendOneConsumeMemRequest(w, rest, durationSec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler.waitGroup.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *Controller) handleBumpMetric(w http.ResponseWriter, query url.Values) {
0000000000000000000000000000000000000000;;		// geting string data for handleBumpMetric
0000000000000000000000000000000000000000;;		metric := query.Get(MetricNameQuery)
0000000000000000000000000000000000000000;;		deltaString := query.Get(DeltaQuery)
0000000000000000000000000000000000000000;;		durationSecString := query.Get(DurationSecQuery)
0000000000000000000000000000000000000000;;		requestSizeCustomMetricString := query.Get(RequestSizeCustomMetricQuery)
0000000000000000000000000000000000000000;;		if durationSecString == "" || metric == "" || deltaString == "" || requestSizeCustomMetricString == "" {
0000000000000000000000000000000000000000;;			http.Error(w, NotGivenFunctionArgument, http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// convert data (strings to ints/floats) for handleBumpMetric
0000000000000000000000000000000000000000;;		durationSec, durationSecError := strconv.Atoi(durationSecString)
0000000000000000000000000000000000000000;;		delta, deltaError := strconv.Atoi(deltaString)
0000000000000000000000000000000000000000;;		requestSizeCustomMetric, requestSizeCustomMetricError := strconv.Atoi(requestSizeCustomMetricString)
0000000000000000000000000000000000000000;;		if durationSecError != nil || deltaError != nil || requestSizeCustomMetricError != nil || requestSizeCustomMetric <= 0 {
0000000000000000000000000000000000000000;;			http.Error(w, IncorrectFunctionArgument, http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		count := delta / requestSizeCustomMetric
0000000000000000000000000000000000000000;;		rest := delta - count*requestSizeCustomMetric
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "RC manager: sending %v requests to bump custom metric by %v each and 1 request to bump by %v\n", count, requestSizeCustomMetric, rest)
0000000000000000000000000000000000000000;;		if count > 0 {
0000000000000000000000000000000000000000;;			handler.waitGroup.Add(count)
0000000000000000000000000000000000000000;;			handler.sendConsumeCustomMetric(w, metric, count, requestSizeCustomMetric, durationSec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rest > 0 {
0000000000000000000000000000000000000000;;			handler.waitGroup.Add(1)
0000000000000000000000000000000000000000;;			go handler.sendOneConsumeCustomMetric(w, metric, rest, durationSec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler.waitGroup.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (manager *Controller) sendConsumeCPURequests(w http.ResponseWriter, requests, millicores, durationSec int) {
0000000000000000000000000000000000000000;;		for i := 0; i < requests; i++ {
0000000000000000000000000000000000000000;;			go manager.sendOneConsumeCPURequest(w, millicores, durationSec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (manager *Controller) sendConsumeMemRequests(w http.ResponseWriter, requests, megabytes, durationSec int) {
0000000000000000000000000000000000000000;;		for i := 0; i < requests; i++ {
0000000000000000000000000000000000000000;;			go manager.sendOneConsumeMemRequest(w, megabytes, durationSec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (manager *Controller) sendConsumeCustomMetric(w http.ResponseWriter, metric string, requests, delta, durationSec int) {
0000000000000000000000000000000000000000;;		for i := 0; i < requests; i++ {
0000000000000000000000000000000000000000;;			go manager.sendOneConsumeCustomMetric(w, metric, delta, durationSec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createConsumerURL(suffix string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("http://%s.%s.svc.cluster.local:%d%s", *consumerServiceName, *consumerServiceNamespace, *consumerPort, suffix)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sendOneConsumeCPURequest sends POST request for cpu consumption
0000000000000000000000000000000000000000;;	func (c *Controller) sendOneConsumeCPURequest(w http.ResponseWriter, millicores int, durationSec int) {
0000000000000000000000000000000000000000;;		defer c.waitGroup.Done()
0000000000000000000000000000000000000000;;		query := createConsumerURL(ConsumeCPUAddress)
0000000000000000000000000000000000000000;;		_, err := http.PostForm(query, url.Values{MillicoresQuery: {strconv.Itoa(millicores)}, DurationSecQuery: {strconv.Itoa(durationSec)}})
0000000000000000000000000000000000000000;;		c.responseWriterLock.Lock()
0000000000000000000000000000000000000000;;		defer c.responseWriterLock.Unlock()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "Failed to connect to consumer: %v\n", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "Consumed %d millicores\n", millicores)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sendOneConsumeMemRequest sends POST request for memory consumption
0000000000000000000000000000000000000000;;	func (c *Controller) sendOneConsumeMemRequest(w http.ResponseWriter, megabytes int, durationSec int) {
0000000000000000000000000000000000000000;;		defer c.waitGroup.Done()
0000000000000000000000000000000000000000;;		query := createConsumerURL(ConsumeMemAddress)
0000000000000000000000000000000000000000;;		_, err := http.PostForm(query, url.Values{MegabytesQuery: {strconv.Itoa(megabytes)}, DurationSecQuery: {strconv.Itoa(durationSec)}})
0000000000000000000000000000000000000000;;		c.responseWriterLock.Lock()
0000000000000000000000000000000000000000;;		defer c.responseWriterLock.Unlock()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "Failed to connect to consumer: %v\n", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "Consumed %d megabytes\n", megabytes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sendOneConsumeCustomMetric sends POST request for custom metric consumption
0000000000000000000000000000000000000000;;	func (c *Controller) sendOneConsumeCustomMetric(w http.ResponseWriter, customMetricName string, delta int, durationSec int) {
0000000000000000000000000000000000000000;;		defer c.waitGroup.Done()
0000000000000000000000000000000000000000;;		query := createConsumerURL(BumpMetricAddress)
0000000000000000000000000000000000000000;;		_, err := http.PostForm(query,
0000000000000000000000000000000000000000;;			url.Values{MetricNameQuery: {customMetricName}, DurationSecQuery: {strconv.Itoa(durationSec)}, DeltaQuery: {strconv.Itoa(delta)}})
0000000000000000000000000000000000000000;;		c.responseWriterLock.Lock()
0000000000000000000000000000000000000000;;		defer c.responseWriterLock.Unlock()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "Failed to connect to consumer: %v\n", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "Bumped metric %s by %d\n", customMetricName, delta)
0000000000000000000000000000000000000000;;	}
