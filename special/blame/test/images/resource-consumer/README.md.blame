0000000000000000000000000000000000000000;;	# Resource Consumer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Overview
0000000000000000000000000000000000000000;;	Resource Consumer is a tool which allows to generate cpu/memory utilization in a container.
0000000000000000000000000000000000000000;;	The reason why it was created is testing kubernetes autoscaling.
0000000000000000000000000000000000000000;;	Resource Consumer can help with autoscaling tests for:
0000000000000000000000000000000000000000;;	- cluster size autoscaling,
0000000000000000000000000000000000000000;;	- horizontal autoscaling of pod - changing the size of replication controller,
0000000000000000000000000000000000000000;;	- vertical autoscaling of pod - changing its resource limits.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Usage
0000000000000000000000000000000000000000;;	Resource Consumer starts an HTTP server and handle sent requests.
0000000000000000000000000000000000000000;;	It listens on port given as a flag (default 8080).
0000000000000000000000000000000000000000;;	Action of consuming resources is send to the container by a POST http request.
0000000000000000000000000000000000000000;;	Each http request creates new process.
0000000000000000000000000000000000000000;;	Http request handler is in file resource_consumer_handler.go 
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The container consumes specified amount of resources:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	- CPU in millicores,
0000000000000000000000000000000000000000;;	- Memory in megabytes,
0000000000000000000000000000000000000000;;	- Fake custom metrics.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	###Consume CPU http request
0000000000000000000000000000000000000000;;	- suffix "ConsumeCPU",
0000000000000000000000000000000000000000;;	- parameters "millicores" and "durationSec".
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Consumes specified amount of millicores for durationSec seconds.
0000000000000000000000000000000000000000;;	Consume CPU uses "./consume-cpu/consume-cpu" binary (file consume-cpu/consume_cpu.go).
0000000000000000000000000000000000000000;;	When CPU consumption is too low this binary uses cpu by calculating math.sqrt(0) 10^7 times
0000000000000000000000000000000000000000;;	and if consumption is too high binary sleeps for 10 millisecond.
0000000000000000000000000000000000000000;;	One replica of Resource Consumer cannot consume more that 1 cpu.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	###Consume Memory http request
0000000000000000000000000000000000000000;;	- suffix "ConsumeMem",
0000000000000000000000000000000000000000;;	- parameters "megabytes" and "durationSec".
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Consumes specified amount of megabytes for durationSec seconds.
0000000000000000000000000000000000000000;;	Consume Memory uses stress tool (stress -m 1 --vm-bytes megabytes --vm-hang 0 -t durationSec).
0000000000000000000000000000000000000000;;	Request leading to consuming more memory then container limit will be ignored.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	###Bump value of a fake custom metric
0000000000000000000000000000000000000000;;	- suffix "BumpMetric",
0000000000000000000000000000000000000000;;	- parameters "metric", "delta" and "durationSec".
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Bumps metric with given name by delta for durationSec seconds.
0000000000000000000000000000000000000000;;	Custom metrics in Prometheus format are exposed on "/metrics" endpoint.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	###CURL example
0000000000000000000000000000000000000000;;	```console
0000000000000000000000000000000000000000;;	$ kubectl run resource-consumer --image=gcr.io/google_containers/resource_consumer:beta --expose --service-overrides='{ "spec": { "type": "LoadBalancer" } }' --port 8080
0000000000000000000000000000000000000000;;	$ kubectl get services resource-consumer
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	There are two IPs.  The first one is internal, while the second one is the external load-balanced IP.  Both serve port 8080. (Use second one)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```console
0000000000000000000000000000000000000000;;	$ curl --data "millicores=300&durationSec=600" http://<EXTERNAL-IP>:8080/ConsumeCPU
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	300 millicores will be consumed for 600 seconds.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Image
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Docker image of Resource Consumer can be found in Google Container Registry as gcr.io/google_containers/resource_consumer:beta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Use cases
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	###Cluster size autoscaling
0000000000000000000000000000000000000000;;	1. Consume more resources on each node that is specified for autoscaler
0000000000000000000000000000000000000000;;	2. Observe that cluster size increased
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	###Horizontal autoscaling of pod
0000000000000000000000000000000000000000;;	1. Create consuming RC and start consuming appropriate amount of resources
0000000000000000000000000000000000000000;;	2. Observe that RC has been resized
0000000000000000000000000000000000000000;;	3. Observe that usage on each replica decreased
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	###Vertical autoscaling of pod
0000000000000000000000000000000000000000;;	1. Create consuming pod and start consuming appropriate amount of resources
0000000000000000000000000000000000000000;;	2. Observed that limits has been increased
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[![Analytics](https://kubernetes-site.appspot.com/UA-36037335-10/GitHub/test/images/resource-consumer/README.md?pixel)]()
