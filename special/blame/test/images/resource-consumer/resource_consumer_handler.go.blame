0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
8bf183d3a2fdb51bfc6a5452d9a05816b9fb6036;contrib/for-tests/resource-consumer/resource_consumer_handler.go[contrib/for-tests/resource-consumer/resource_consumer_handler.go][test/images/resource-consumer/resource_consumer_handler.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "k8s.io/kubernetes/test/images/resource-consumer/common"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ResourceConsumerHandler struct {
0000000000000000000000000000000000000000;;		metrics     map[string]float64
0000000000000000000000000000000000000000;;		metricsLock sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewResourceConsumerHandler() *ResourceConsumerHandler {
0000000000000000000000000000000000000000;;		return &ResourceConsumerHandler{metrics: map[string]float64{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *ResourceConsumerHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		// handle exposing metrics in Prometheus format (both GET & POST)
0000000000000000000000000000000000000000;;		if req.URL.Path == MetricsAddress {
0000000000000000000000000000000000000000;;			handler.handleMetrics(w)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if req.Method != "POST" {
0000000000000000000000000000000000000000;;			http.Error(w, BadRequest, http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// parsing POST request data and URL data
0000000000000000000000000000000000000000;;		if err := req.ParseForm(); err != nil {
0000000000000000000000000000000000000000;;			http.Error(w, err.Error(), http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// handle consumeCPU
0000000000000000000000000000000000000000;;		if req.URL.Path == ConsumeCPUAddress {
0000000000000000000000000000000000000000;;			handler.handleConsumeCPU(w, req.Form)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// handle consumeMem
0000000000000000000000000000000000000000;;		if req.URL.Path == ConsumeMemAddress {
0000000000000000000000000000000000000000;;			handler.handleConsumeMem(w, req.Form)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// handle getCurrentStatus
0000000000000000000000000000000000000000;;		if req.URL.Path == GetCurrentStatusAddress {
0000000000000000000000000000000000000000;;			handler.handleGetCurrentStatus(w)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// handle bumpMetric
0000000000000000000000000000000000000000;;		if req.URL.Path == BumpMetricAddress {
0000000000000000000000000000000000000000;;			handler.handleBumpMetric(w, req.Form)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		http.Error(w, fmt.Sprintf("%s: %s", UnknownFunction, req.URL.Path), http.StatusNotFound)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *ResourceConsumerHandler) handleConsumeCPU(w http.ResponseWriter, query url.Values) {
0000000000000000000000000000000000000000;;		// geting string data for consumeCPU
0000000000000000000000000000000000000000;;		durationSecString := query.Get(DurationSecQuery)
0000000000000000000000000000000000000000;;		millicoresString := query.Get(MillicoresQuery)
0000000000000000000000000000000000000000;;		if durationSecString == "" || millicoresString == "" {
0000000000000000000000000000000000000000;;			http.Error(w, NotGivenFunctionArgument, http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// convert data (strings to ints) for consumeCPU
0000000000000000000000000000000000000000;;		durationSec, durationSecError := strconv.Atoi(durationSecString)
0000000000000000000000000000000000000000;;		millicores, millicoresError := strconv.Atoi(millicoresString)
0000000000000000000000000000000000000000;;		if durationSecError != nil || millicoresError != nil {
0000000000000000000000000000000000000000;;			http.Error(w, IncorrectFunctionArgument, http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go ConsumeCPU(millicores, durationSec)
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, ConsumeCPUAddress[1:])
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, millicores, MillicoresQuery)
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, durationSec, DurationSecQuery)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *ResourceConsumerHandler) handleConsumeMem(w http.ResponseWriter, query url.Values) {
0000000000000000000000000000000000000000;;		// geting string data for consumeMem
0000000000000000000000000000000000000000;;		durationSecString := query.Get(DurationSecQuery)
0000000000000000000000000000000000000000;;		megabytesString := query.Get(MegabytesQuery)
0000000000000000000000000000000000000000;;		if durationSecString == "" || megabytesString == "" {
0000000000000000000000000000000000000000;;			http.Error(w, NotGivenFunctionArgument, http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// convert data (strings to ints) for consumeMem
0000000000000000000000000000000000000000;;		durationSec, durationSecError := strconv.Atoi(durationSecString)
0000000000000000000000000000000000000000;;		megabytes, megabytesError := strconv.Atoi(megabytesString)
0000000000000000000000000000000000000000;;		if durationSecError != nil || megabytesError != nil {
0000000000000000000000000000000000000000;;			http.Error(w, IncorrectFunctionArgument, http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go ConsumeMem(megabytes, durationSec)
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, ConsumeMemAddress[1:])
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, megabytes, MegabytesQuery)
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, durationSec, DurationSecQuery)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *ResourceConsumerHandler) handleGetCurrentStatus(w http.ResponseWriter) {
0000000000000000000000000000000000000000;;		GetCurrentStatus()
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "Warning: not implemented!")
0000000000000000000000000000000000000000;;		fmt.Fprint(w, GetCurrentStatusAddress[1:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *ResourceConsumerHandler) handleMetrics(w http.ResponseWriter) {
0000000000000000000000000000000000000000;;		handler.metricsLock.Lock()
0000000000000000000000000000000000000000;;		defer handler.metricsLock.Unlock()
0000000000000000000000000000000000000000;;		for k, v := range handler.metrics {
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "# HELP %s info message.\n", k)
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "# TYPE %s gauge\n", k)
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "%s %f\n", k, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *ResourceConsumerHandler) bumpMetric(metric string, delta float64, duration time.Duration) {
0000000000000000000000000000000000000000;;		handler.metricsLock.Lock()
0000000000000000000000000000000000000000;;		if _, ok := handler.metrics[metric]; ok {
0000000000000000000000000000000000000000;;			handler.metrics[metric] += delta
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			handler.metrics[metric] = delta
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler.metricsLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		time.Sleep(duration)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler.metricsLock.Lock()
0000000000000000000000000000000000000000;;		handler.metrics[metric] -= delta
0000000000000000000000000000000000000000;;		handler.metricsLock.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *ResourceConsumerHandler) handleBumpMetric(w http.ResponseWriter, query url.Values) {
0000000000000000000000000000000000000000;;		// geting string data for handleBumpMetric
0000000000000000000000000000000000000000;;		metric := query.Get(MetricNameQuery)
0000000000000000000000000000000000000000;;		deltaString := query.Get(DeltaQuery)
0000000000000000000000000000000000000000;;		durationSecString := query.Get(DurationSecQuery)
0000000000000000000000000000000000000000;;		if durationSecString == "" || metric == "" || deltaString == "" {
0000000000000000000000000000000000000000;;			http.Error(w, NotGivenFunctionArgument, http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// convert data (strings to ints/floats) for handleBumpMetric
0000000000000000000000000000000000000000;;		durationSec, durationSecError := strconv.Atoi(durationSecString)
0000000000000000000000000000000000000000;;		delta, deltaError := strconv.ParseFloat(deltaString, 64)
0000000000000000000000000000000000000000;;		if durationSecError != nil || deltaError != nil {
0000000000000000000000000000000000000000;;			http.Error(w, IncorrectFunctionArgument, http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go handler.bumpMetric(metric, delta, time.Duration(durationSec)*time.Second)
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, BumpMetricAddress[1:])
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, metric, MetricNameQuery)
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, delta, DeltaQuery)
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, durationSec, DurationSecQuery)
0000000000000000000000000000000000000000;;	}
