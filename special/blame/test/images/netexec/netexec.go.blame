0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
19943fbc5cdcf4f106b0dd797c2a4f8e14e3616c;contrib/for-tests/netexec/netexec.go[contrib/for-tests/netexec/netexec.go][test/images/netexec/netexec.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		httpPort    = 8080
0000000000000000000000000000000000000000;;		udpPort     = 8081
0000000000000000000000000000000000000000;;		shellPath   = "/bin/sh"
0000000000000000000000000000000000000000;;		serverReady = &atomicBool{0}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// atomicBool uses load/store operations on an int32 to simulate an atomic boolean.
0000000000000000000000000000000000000000;;	type atomicBool struct {
0000000000000000000000000000000000000000;;		v int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// set sets the int32 to the given boolean.
0000000000000000000000000000000000000000;;	func (a *atomicBool) set(value bool) {
0000000000000000000000000000000000000000;;		if value {
0000000000000000000000000000000000000000;;			atomic.StoreInt32(&a.v, 1)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		atomic.StoreInt32(&a.v, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// get returns true if the int32 == 1
0000000000000000000000000000000000000000;;	func (a *atomicBool) get() bool {
0000000000000000000000000000000000000000;;		return atomic.LoadInt32(&a.v) == 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type output struct {
0000000000000000000000000000000000000000;;		responses []string
0000000000000000000000000000000000000000;;		errors    []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		flag.IntVar(&httpPort, "http-port", 8080, "HTTP Listen Port")
0000000000000000000000000000000000000000;;		flag.IntVar(&udpPort, "udp-port", 8081, "UDP Listen Port")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;		go startUDPServer(udpPort)
0000000000000000000000000000000000000000;;		startHTTPServer(httpPort)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startHTTPServer(httpPort int) {
0000000000000000000000000000000000000000;;		http.HandleFunc("/", rootHandler)
0000000000000000000000000000000000000000;;		http.HandleFunc("/clientip", clientIpHandler)
0000000000000000000000000000000000000000;;		http.HandleFunc("/echo", echoHandler)
0000000000000000000000000000000000000000;;		http.HandleFunc("/exit", exitHandler)
0000000000000000000000000000000000000000;;		http.HandleFunc("/hostname", hostnameHandler)
0000000000000000000000000000000000000000;;		http.HandleFunc("/shell", shellHandler)
0000000000000000000000000000000000000000;;		http.HandleFunc("/upload", uploadHandler)
0000000000000000000000000000000000000000;;		http.HandleFunc("/dial", dialHandler)
0000000000000000000000000000000000000000;;		http.HandleFunc("/healthz", healthzHandler)
0000000000000000000000000000000000000000;;		// older handlers
0000000000000000000000000000000000000000;;		http.HandleFunc("/hostName", hostNameHandler)
0000000000000000000000000000000000000000;;		http.HandleFunc("/shutdown", shutdownHandler)
0000000000000000000000000000000000000000;;		log.Fatal(http.ListenAndServe(fmt.Sprintf(":%d", httpPort), nil))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func rootHandler(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		log.Printf("GET /")
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "NOW: %v", time.Now())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func echoHandler(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		log.Printf("GET /echo?msg=%s", r.FormValue("msg"))
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "%s", r.FormValue("msg"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func clientIpHandler(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		log.Printf("GET /clientip")
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, r.RemoteAddr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func exitHandler(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		log.Printf("GET /exit?code=%s", r.FormValue("code"))
0000000000000000000000000000000000000000;;		code, err := strconv.Atoi(r.FormValue("code"))
0000000000000000000000000000000000000000;;		if err == nil || r.FormValue("code") == "" {
0000000000000000000000000000000000000000;;			os.Exit(code)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "argument 'code' must be an integer [0-127] or empty, got %q", r.FormValue("code"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hostnameHandler(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		log.Printf("GET /hostname")
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, getHostName())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// healthHandler response with a 200 if the UDP server is ready. It also serves
0000000000000000000000000000000000000000;;	// as a health check of the HTTP server by virtue of being a HTTP handler.
0000000000000000000000000000000000000000;;	func healthzHandler(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		log.Printf("GET /healthz")
0000000000000000000000000000000000000000;;		if serverReady.get() {
0000000000000000000000000000000000000000;;			w.WriteHeader(200)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.WriteHeader(http.StatusPreconditionFailed)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func shutdownHandler(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		log.Printf("GET /shutdown")
0000000000000000000000000000000000000000;;		os.Exit(0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func dialHandler(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		values, err := url.Parse(r.URL.RequestURI())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			http.Error(w, fmt.Sprintf("%v", err), http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		host := values.Query().Get("host")
0000000000000000000000000000000000000000;;		port := values.Query().Get("port")
0000000000000000000000000000000000000000;;		request := values.Query().Get("request") // hostName
0000000000000000000000000000000000000000;;		protocol := values.Query().Get("protocol")
0000000000000000000000000000000000000000;;		tryParam := values.Query().Get("tries")
0000000000000000000000000000000000000000;;		log.Printf("GET /dial?host=%s&protocol=%s&port=%s&request=%s&tries=%s", host, protocol, port, request, tryParam)
0000000000000000000000000000000000000000;;		tries := 1
0000000000000000000000000000000000000000;;		if len(tryParam) > 0 {
0000000000000000000000000000000000000000;;			tries, err = strconv.Atoi(tryParam)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			http.Error(w, fmt.Sprintf("tries parameter is invalid. %v", err), http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(request) == 0 {
0000000000000000000000000000000000000000;;			http.Error(w, fmt.Sprintf("request parameter not specified. %v", err), http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(protocol) == 0 {
0000000000000000000000000000000000000000;;			protocol = "http"
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			protocol = strings.ToLower(protocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if protocol != "http" && protocol != "udp" {
0000000000000000000000000000000000000000;;			http.Error(w, fmt.Sprintf("unsupported protocol. %s", protocol), http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostPort := net.JoinHostPort(host, port)
0000000000000000000000000000000000000000;;		var udpAddress *net.UDPAddr
0000000000000000000000000000000000000000;;		if protocol == "udp" {
0000000000000000000000000000000000000000;;			udpAddress, err = net.ResolveUDPAddr("udp", hostPort)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				http.Error(w, fmt.Sprintf("host and/or port param are invalid. %v", err), http.StatusBadRequest)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			_, err = net.ResolveTCPAddr("tcp", hostPort)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				http.Error(w, fmt.Sprintf("host and/or port param are invalid. %v", err), http.StatusBadRequest)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errors := make([]string, 0)
0000000000000000000000000000000000000000;;		responses := make([]string, 0)
0000000000000000000000000000000000000000;;		var response string
0000000000000000000000000000000000000000;;		for i := 0; i < tries; i++ {
0000000000000000000000000000000000000000;;			if protocol == "udp" {
0000000000000000000000000000000000000000;;				response, err = dialUDP(request, udpAddress)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				response, err = dialHTTP(request, hostPort)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, fmt.Sprintf("%v", err))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				responses = append(responses, response)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output := map[string][]string{}
0000000000000000000000000000000000000000;;		if len(response) > 0 {
0000000000000000000000000000000000000000;;			output["responses"] = responses
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(errors) > 0 {
0000000000000000000000000000000000000000;;			output["errors"] = errors
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bytes, err := json.Marshal(output)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, string(bytes))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			http.Error(w, fmt.Sprintf("response could not be serialized. %v", err), http.StatusExpectationFailed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func dialHTTP(request, hostPort string) (string, error) {
0000000000000000000000000000000000000000;;		transport := utilnet.SetTransportDefaults(&http.Transport{})
0000000000000000000000000000000000000000;;		httpClient := createHTTPClient(transport)
0000000000000000000000000000000000000000;;		resp, err := httpClient.Get(fmt.Sprintf("http://%s/%s", hostPort, request))
0000000000000000000000000000000000000000;;		defer transport.CloseIdleConnections()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			defer resp.Body.Close()
0000000000000000000000000000000000000000;;			body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return string(body), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createHTTPClient(transport *http.Transport) *http.Client {
0000000000000000000000000000000000000000;;		client := &http.Client{
0000000000000000000000000000000000000000;;			Transport: transport,
0000000000000000000000000000000000000000;;			Timeout:   5 * time.Second,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func dialUDP(request string, remoteAddress *net.UDPAddr) (string, error) {
0000000000000000000000000000000000000000;;		Conn, err := net.DialUDP("udp", nil, remoteAddress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("udp dial failed. err:%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer Conn.Close()
0000000000000000000000000000000000000000;;		buf := []byte(request)
0000000000000000000000000000000000000000;;		_, err = Conn.Write(buf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("udp connection write failed. err:%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		udpResponse := make([]byte, 1024)
0000000000000000000000000000000000000000;;		Conn.SetReadDeadline(time.Now().Add(5 * time.Second))
0000000000000000000000000000000000000000;;		count, err := Conn.Read(udpResponse)
0000000000000000000000000000000000000000;;		if err != nil || count == 0 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("reading from udp connection failed. err:'%v'", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(udpResponse[0:count]), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func shellHandler(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		cmd := r.FormValue("shellCommand")
0000000000000000000000000000000000000000;;		if cmd == "" {
0000000000000000000000000000000000000000;;			cmd = r.FormValue("cmd")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		log.Printf("GET /shell?cmd=%s", cmd)
0000000000000000000000000000000000000000;;		cmdOut, err := exec.Command(shellPath, "-c", cmd).CombinedOutput()
0000000000000000000000000000000000000000;;		output := map[string]string{}
0000000000000000000000000000000000000000;;		if len(cmdOut) > 0 {
0000000000000000000000000000000000000000;;			output["output"] = string(cmdOut)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			output["error"] = fmt.Sprintf("%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		log.Printf("Output: %s", output)
0000000000000000000000000000000000000000;;		bytes, err := json.Marshal(output)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, string(bytes))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			http.Error(w, fmt.Sprintf("response could not be serialized. %v", err), http.StatusExpectationFailed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func uploadHandler(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		log.Printf("GET /upload")
0000000000000000000000000000000000000000;;		result := map[string]string{}
0000000000000000000000000000000000000000;;		file, _, err := r.FormFile("file")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			result["error"] = "Unable to upload file."
0000000000000000000000000000000000000000;;			bytes, err := json.Marshal(result)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, string(bytes))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				http.Error(w, fmt.Sprintf("%s. Also unable to serialize output. %v", result["error"], err), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			log.Printf("Unable to upload file: %s", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := ioutil.TempFile("/uploads", "upload")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			result["error"] = "Unable to open file for write"
0000000000000000000000000000000000000000;;			bytes, err := json.Marshal(result)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, string(bytes))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				http.Error(w, fmt.Sprintf("%s. Also unable to serialize output. %v", result["error"], err), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			log.Printf("Unable to open file for write: %s", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;		if _, err = io.Copy(f, file); err != nil {
0000000000000000000000000000000000000000;;			result["error"] = "Unable to write file."
0000000000000000000000000000000000000000;;			bytes, err := json.Marshal(result)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, string(bytes))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				http.Error(w, fmt.Sprintf("%s. Also unable to serialize output. %v", result["error"], err), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			log.Printf("Unable to write file: %s", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		UploadFile := f.Name()
0000000000000000000000000000000000000000;;		if err := os.Chmod(UploadFile, 0700); err != nil {
0000000000000000000000000000000000000000;;			result["error"] = "Unable to chmod file."
0000000000000000000000000000000000000000;;			bytes, err := json.Marshal(result)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, string(bytes))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				http.Error(w, fmt.Sprintf("%s. Also unable to serialize output. %v", result["error"], err), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			log.Printf("Unable to chmod file: %s", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		log.Printf("Wrote upload to %s", UploadFile)
0000000000000000000000000000000000000000;;		result["output"] = UploadFile
0000000000000000000000000000000000000000;;		w.WriteHeader(http.StatusCreated)
0000000000000000000000000000000000000000;;		bytes, err := json.Marshal(result)
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, string(bytes))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hostNameHandler(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		log.Printf("GET /hostName")
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, getHostName())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// udp server supports the hostName, echo and clientIP commands.
0000000000000000000000000000000000000000;;	func startUDPServer(udpPort int) {
0000000000000000000000000000000000000000;;		serverAddress, err := net.ResolveUDPAddr("udp", fmt.Sprintf(":%d", udpPort))
0000000000000000000000000000000000000000;;		assertNoError(err)
0000000000000000000000000000000000000000;;		serverConn, err := net.ListenUDP("udp", serverAddress)
0000000000000000000000000000000000000000;;		defer serverConn.Close()
0000000000000000000000000000000000000000;;		buf := make([]byte, 1024)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		log.Printf("Started UDP server")
0000000000000000000000000000000000000000;;		// Start responding to readiness probes.
0000000000000000000000000000000000000000;;		serverReady.set(true)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			log.Printf("UDP server exited")
0000000000000000000000000000000000000000;;			serverReady.set(false)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			n, clientAddress, err := serverConn.ReadFromUDP(buf)
0000000000000000000000000000000000000000;;			assertNoError(err)
0000000000000000000000000000000000000000;;			receivedText := strings.ToLower(strings.TrimSpace(string(buf[0:n])))
0000000000000000000000000000000000000000;;			if receivedText == "hostname" {
0000000000000000000000000000000000000000;;				log.Println("Sending udp hostName response")
0000000000000000000000000000000000000000;;				_, err = serverConn.WriteToUDP([]byte(getHostName()), clientAddress)
0000000000000000000000000000000000000000;;				assertNoError(err)
0000000000000000000000000000000000000000;;			} else if strings.HasPrefix(receivedText, "echo ") {
0000000000000000000000000000000000000000;;				parts := strings.SplitN(receivedText, " ", 2)
0000000000000000000000000000000000000000;;				resp := ""
0000000000000000000000000000000000000000;;				if len(parts) == 2 {
0000000000000000000000000000000000000000;;					resp = parts[1]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				log.Printf("Echoing %v\n", resp)
0000000000000000000000000000000000000000;;				_, err = serverConn.WriteToUDP([]byte(resp), clientAddress)
0000000000000000000000000000000000000000;;				assertNoError(err)
0000000000000000000000000000000000000000;;			} else if receivedText == "clientip" {
0000000000000000000000000000000000000000;;				log.Printf("Sending back clientip to %s", clientAddress.String())
0000000000000000000000000000000000000000;;				_, err = serverConn.WriteToUDP([]byte(clientAddress.String()), clientAddress)
0000000000000000000000000000000000000000;;				assertNoError(err)
0000000000000000000000000000000000000000;;			} else if len(receivedText) > 0 {
0000000000000000000000000000000000000000;;				log.Printf("Unknown udp command received: %v\n", receivedText)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getHostName() string {
0000000000000000000000000000000000000000;;		hostName, err := os.Hostname()
0000000000000000000000000000000000000000;;		assertNoError(err)
0000000000000000000000000000000000000000;;		return hostName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func assertNoError(err error) {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Fatal("Error occurred. error:", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
