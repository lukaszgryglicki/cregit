0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
49793dcd7bb0c1ef9f211592e382ef145cf2458a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A tiny binary for testing port forwarding. The following environment variables
0000000000000000000000000000000000000000;;	// control the binary's logic:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// BIND_PORT - the TCP port to use for the listener
0000000000000000000000000000000000000000;;	// EXPECTED_CLIENT_DATA - data that we expect to receive from the client; may be "".
0000000000000000000000000000000000000000;;	// CHUNKS - how many chunks of data we should send to the client
0000000000000000000000000000000000000000;;	// CHUNK_SIZE - how large each chunk should be
0000000000000000000000000000000000000000;;	// CHUNK_INTERVAL - the delay in between sending each chunk
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Log messages are written to stdout at various stages of the binary's execution.
0000000000000000000000000000000000000000;;	// Test code can retrieve this container's log and validate that the expected
0000000000000000000000000000000000000000;;	// behavior is taking place.
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getEnvInt(name string) int {
0000000000000000000000000000000000000000;;		s := os.Getenv(name)
0000000000000000000000000000000000000000;;		value, err := strconv.Atoi(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Printf("Error parsing %s %q: %v\n", name, s, err)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// taken from net/http/server.go:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// rstAvoidanceDelay is the amount of time we sleep after closing the
0000000000000000000000000000000000000000;;	// write side of a TCP connection before closing the entire socket.
0000000000000000000000000000000000000000;;	// By sleeping, we increase the chances that the client sees our FIN
0000000000000000000000000000000000000000;;	// and processes its final data before they process the subsequent RST
0000000000000000000000000000000000000000;;	// from closing a connection with known unread data.
0000000000000000000000000000000000000000;;	// This RST seems to occur mostly on BSD systems. (And Windows?)
0000000000000000000000000000000000000000;;	// This timeout is somewhat arbitrary (~latency around the planet).
0000000000000000000000000000000000000000;;	const rstAvoidanceDelay = 500 * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		bindAddress := os.Getenv("BIND_ADDRESS")
0000000000000000000000000000000000000000;;		if bindAddress == "" {
0000000000000000000000000000000000000000;;			bindAddress = "localhost"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bindPort := os.Getenv("BIND_PORT")
0000000000000000000000000000000000000000;;		addr, err := net.ResolveTCPAddr("tcp", net.JoinHostPort(bindAddress, bindPort))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Printf("Error resolving: %v\n", err)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		listener, err := net.ListenTCP("tcp", addr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Printf("Error listening: %v\n", err)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn, err := listener.AcceptTCP()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Printf("Error accepting connection: %v\n", err)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Println("Accepted client connection")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedClientData := os.Getenv("EXPECTED_CLIENT_DATA")
0000000000000000000000000000000000000000;;		if len(expectedClientData) > 0 {
0000000000000000000000000000000000000000;;			buf := make([]byte, len(expectedClientData))
0000000000000000000000000000000000000000;;			read, err := conn.Read(buf)
0000000000000000000000000000000000000000;;			if read != len(expectedClientData) {
0000000000000000000000000000000000000000;;				fmt.Printf("Expected to read %d bytes from client, but got %d instead. err=%v\n", len(expectedClientData), read, err)
0000000000000000000000000000000000000000;;				os.Exit(2)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if expectedClientData != string(buf) {
0000000000000000000000000000000000000000;;				fmt.Printf("Expect to read %q, but got %q. err=%v\n", expectedClientData, string(buf), err)
0000000000000000000000000000000000000000;;				os.Exit(3)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				fmt.Printf("Read err: %v\n", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Println("Received expected client data")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		chunks := getEnvInt("CHUNKS")
0000000000000000000000000000000000000000;;		chunkSize := getEnvInt("CHUNK_SIZE")
0000000000000000000000000000000000000000;;		chunkInterval := getEnvInt("CHUNK_INTERVAL")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stringData := strings.Repeat("x", chunkSize)
0000000000000000000000000000000000000000;;		data := []byte(stringData)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < chunks; i++ {
0000000000000000000000000000000000000000;;			written, err := conn.Write(data)
0000000000000000000000000000000000000000;;			if written != chunkSize {
0000000000000000000000000000000000000000;;				fmt.Printf("Expected to write %d bytes from client, but wrote %d instead. err=%v\n", chunkSize, written, err)
0000000000000000000000000000000000000000;;				os.Exit(4)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				fmt.Printf("Write err: %v\n", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i+1 < chunks {
0000000000000000000000000000000000000000;;				time.Sleep(time.Duration(chunkInterval) * time.Millisecond)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Println("Shutting down connection")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set linger timeout to flush buffers. This is the official way according to the go api docs. But
0000000000000000000000000000000000000000;;		// there are controversial discussions whether this value has any impact on most platforms
0000000000000000000000000000000000000000;;		// (compare https://codereview.appspot.com/95320043).
0000000000000000000000000000000000000000;;		conn.SetLinger(-1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Flush the connection cleanly, following https://blog.netherlabs.nl/articles/2009/01/18/the-ultimate-so_linger-page-or-why-is-my-tcp-not-reliable:
0000000000000000000000000000000000000000;;		// 1. close write half of connection which sends a FIN packet
0000000000000000000000000000000000000000;;		// 2. give client some time to receive the FIN
0000000000000000000000000000000000000000;;		// 3. close the complete connection
0000000000000000000000000000000000000000;;		conn.CloseWrite()
0000000000000000000000000000000000000000;;		time.Sleep(rstAvoidanceDelay)
0000000000000000000000000000000000000000;;		conn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Println("Done")
0000000000000000000000000000000000000000;;	}
