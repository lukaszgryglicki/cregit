0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
699817b5cb8a7b3673e5b0977ed5cf874ff25e2e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addMasterReplica(zone string) error {
0000000000000000000000000000000000000000;;		framework.Logf(fmt.Sprintf("Adding a new master replica, zone: %s", zone))
0000000000000000000000000000000000000000;;		v, _, err := framework.RunCmd(path.Join(framework.TestContext.RepoRoot, "hack/e2e-internal/e2e-grow-cluster.sh"), zone, "true", "true", "false")
0000000000000000000000000000000000000000;;		framework.Logf("%s", v)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func removeMasterReplica(zone string) error {
0000000000000000000000000000000000000000;;		framework.Logf(fmt.Sprintf("Removing an existing master replica, zone: %s", zone))
0000000000000000000000000000000000000000;;		v, _, err := framework.RunCmd(path.Join(framework.TestContext.RepoRoot, "hack/e2e-internal/e2e-shrink-cluster.sh"), zone, "true", "false", "false")
0000000000000000000000000000000000000000;;		framework.Logf("%s", v)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addWorkerNodes(zone string) error {
0000000000000000000000000000000000000000;;		framework.Logf(fmt.Sprintf("Adding worker nodes, zone: %s", zone))
0000000000000000000000000000000000000000;;		v, _, err := framework.RunCmd(path.Join(framework.TestContext.RepoRoot, "hack/e2e-internal/e2e-grow-cluster.sh"), zone, "true", "false", "true")
0000000000000000000000000000000000000000;;		framework.Logf("%s", v)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func removeWorkerNodes(zone string) error {
0000000000000000000000000000000000000000;;		framework.Logf(fmt.Sprintf("Removing worker nodes, zone: %s", zone))
0000000000000000000000000000000000000000;;		v, _, err := framework.RunCmd(path.Join(framework.TestContext.RepoRoot, "hack/e2e-internal/e2e-shrink-cluster.sh"), zone, "true", "true", "true")
0000000000000000000000000000000000000000;;		framework.Logf("%s", v)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyRCs(c clientset.Interface, ns string, names []string) {
0000000000000000000000000000000000000000;;		for _, name := range names {
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.VerifyPods(c, ns, name, true, 1))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createNewRC(c clientset.Interface, ns string, name string) {
0000000000000000000000000000000000000000;;		_, err := newRCByName(c, ns, name, 1, nil)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findRegionForZone(zone string) string {
0000000000000000000000000000000000000000;;		region, err := exec.Command("gcloud", "compute", "zones", "list", zone, "--quiet", "--format=[no-heading](region)").CombinedOutput()
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		if string(region) == "" {
0000000000000000000000000000000000000000;;			framework.Failf("Region not found; zone: %s", zone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(region)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findZonesForRegion(region string) []string {
0000000000000000000000000000000000000000;;		output, err := exec.Command("gcloud", "compute", "zones", "list", "--filter=region="+region,
0000000000000000000000000000000000000000;;			"--quiet", "--format=[no-heading](name)").CombinedOutput()
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		zones := strings.Split(string(output), "\n")
0000000000000000000000000000000000000000;;		return zones
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeZoneFromZones removes zone from zones slide.
0000000000000000000000000000000000000000;;	// Please note that entries in zones can be repeated. In such situation only one replica is removed.
0000000000000000000000000000000000000000;;	func removeZoneFromZones(zones []string, zone string) []string {
0000000000000000000000000000000000000000;;		idx := -1
0000000000000000000000000000000000000000;;		for j, z := range zones {
0000000000000000000000000000000000000000;;			if z == zone {
0000000000000000000000000000000000000000;;				idx = j
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if idx >= 0 {
0000000000000000000000000000000000000000;;			return zones[:idx+copy(zones[idx:], zones[idx+1:])]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return zones
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("HA-master [Feature:HAMaster]", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("ha-master")
0000000000000000000000000000000000000000;;		var c clientset.Interface
0000000000000000000000000000000000000000;;		var ns string
0000000000000000000000000000000000000000;;		var additionalReplicaZones []string
0000000000000000000000000000000000000000;;		var additionalNodesZones []string
0000000000000000000000000000000000000000;;		var existingRCs []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			framework.SkipUnlessProviderIs("gce")
0000000000000000000000000000000000000000;;			c = f.ClientSet
0000000000000000000000000000000000000000;;			ns = f.Namespace.Name
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.WaitForMasters(framework.TestContext.CloudConfig.MasterName, c, 1, 10*time.Minute))
0000000000000000000000000000000000000000;;			additionalReplicaZones = make([]string, 0)
0000000000000000000000000000000000000000;;			existingRCs = make([]string, 0)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		AfterEach(func() {
0000000000000000000000000000000000000000;;			// Clean-up additional worker nodes if the test execution was broken.
0000000000000000000000000000000000000000;;			for _, zone := range additionalNodesZones {
0000000000000000000000000000000000000000;;				removeWorkerNodes(zone)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.AllNodesReady(c, 5*time.Minute))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Clean-up additional master replicas if the test execution was broken.
0000000000000000000000000000000000000000;;			for _, zone := range additionalReplicaZones {
0000000000000000000000000000000000000000;;				removeMasterReplica(zone)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.WaitForMasters(framework.TestContext.CloudConfig.MasterName, c, 1, 10*time.Minute))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type Action int
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			None Action = iota
0000000000000000000000000000000000000000;;			AddReplica
0000000000000000000000000000000000000000;;			RemoveReplica
0000000000000000000000000000000000000000;;			AddNodes
0000000000000000000000000000000000000000;;			RemoveNodes
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		step := func(action Action, zone string) {
0000000000000000000000000000000000000000;;			switch action {
0000000000000000000000000000000000000000;;			case None:
0000000000000000000000000000000000000000;;			case AddReplica:
0000000000000000000000000000000000000000;;				framework.ExpectNoError(addMasterReplica(zone))
0000000000000000000000000000000000000000;;				additionalReplicaZones = append(additionalReplicaZones, zone)
0000000000000000000000000000000000000000;;			case RemoveReplica:
0000000000000000000000000000000000000000;;				framework.ExpectNoError(removeMasterReplica(zone))
0000000000000000000000000000000000000000;;				additionalReplicaZones = removeZoneFromZones(additionalReplicaZones, zone)
0000000000000000000000000000000000000000;;			case AddNodes:
0000000000000000000000000000000000000000;;				framework.ExpectNoError(addWorkerNodes(zone))
0000000000000000000000000000000000000000;;				additionalNodesZones = append(additionalNodesZones, zone)
0000000000000000000000000000000000000000;;			case RemoveNodes:
0000000000000000000000000000000000000000;;				framework.ExpectNoError(removeWorkerNodes(zone))
0000000000000000000000000000000000000000;;				additionalNodesZones = removeZoneFromZones(additionalNodesZones, zone)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.WaitForMasters(framework.TestContext.CloudConfig.MasterName, c, len(additionalReplicaZones)+1, 10*time.Minute))
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.AllNodesReady(c, 5*time.Minute))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Verify that API server works correctly with HA master.
0000000000000000000000000000000000000000;;			rcName := "ha-master-" + strconv.Itoa(len(existingRCs))
0000000000000000000000000000000000000000;;			createNewRC(c, ns, rcName)
0000000000000000000000000000000000000000;;			existingRCs = append(existingRCs, rcName)
0000000000000000000000000000000000000000;;			verifyRCs(c, ns, existingRCs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("survive addition/removal replicas same zone [Serial][Disruptive]", func() {
0000000000000000000000000000000000000000;;			zone := framework.TestContext.CloudConfig.Zone
0000000000000000000000000000000000000000;;			step(None, "")
0000000000000000000000000000000000000000;;			numAdditionalReplicas := 2
0000000000000000000000000000000000000000;;			for i := 0; i < numAdditionalReplicas; i++ {
0000000000000000000000000000000000000000;;				step(AddReplica, zone)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := 0; i < numAdditionalReplicas; i++ {
0000000000000000000000000000000000000000;;				step(RemoveReplica, zone)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("survive addition/removal replicas different zones [Serial][Disruptive]", func() {
0000000000000000000000000000000000000000;;			zone := framework.TestContext.CloudConfig.Zone
0000000000000000000000000000000000000000;;			region := findRegionForZone(zone)
0000000000000000000000000000000000000000;;			zones := findZonesForRegion(region)
0000000000000000000000000000000000000000;;			zones = removeZoneFromZones(zones, zone)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			step(None, "")
0000000000000000000000000000000000000000;;			// If numAdditionalReplicas is larger then the number of remaining zones in the region,
0000000000000000000000000000000000000000;;			// we create a few masters in the same zone and zone entry is repeated in additionalReplicaZones.
0000000000000000000000000000000000000000;;			numAdditionalReplicas := 2
0000000000000000000000000000000000000000;;			for i := 0; i < numAdditionalReplicas; i++ {
0000000000000000000000000000000000000000;;				step(AddReplica, zones[i%len(zones)])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := 0; i < numAdditionalReplicas; i++ {
0000000000000000000000000000000000000000;;				step(RemoveReplica, zones[i%len(zones)])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("survive addition/removal replicas multizone workers [Serial][Disruptive]", func() {
0000000000000000000000000000000000000000;;			zone := framework.TestContext.CloudConfig.Zone
0000000000000000000000000000000000000000;;			region := findRegionForZone(zone)
0000000000000000000000000000000000000000;;			zones := findZonesForRegion(region)
0000000000000000000000000000000000000000;;			zones = removeZoneFromZones(zones, zone)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			step(None, "")
0000000000000000000000000000000000000000;;			numAdditionalReplicas := 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add worker nodes.
0000000000000000000000000000000000000000;;			for i := 0; i < numAdditionalReplicas && i < len(zones); i++ {
0000000000000000000000000000000000000000;;				step(AddNodes, zones[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add master repilcas.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// If numAdditionalReplicas is larger then the number of remaining zones in the region,
0000000000000000000000000000000000000000;;			// we create a few masters in the same zone and zone entry is repeated in additionalReplicaZones.
0000000000000000000000000000000000000000;;			for i := 0; i < numAdditionalReplicas; i++ {
0000000000000000000000000000000000000000;;				step(AddReplica, zones[i%len(zones)])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Remove master repilcas.
0000000000000000000000000000000000000000;;			for i := 0; i < numAdditionalReplicas; i++ {
0000000000000000000000000000000000000000;;				step(RemoveReplica, zones[i%len(zones)])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Remove worker nodes.
0000000000000000000000000000000000000000;;			for i := 0; i < numAdditionalReplicas && i < len(zones); i++ {
0000000000000000000000000000000000000000;;				step(RemoveNodes, zones[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
