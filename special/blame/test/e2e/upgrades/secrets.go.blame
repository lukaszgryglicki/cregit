0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
cb04626a005c73b2ec4f196883a9e0745b049036;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package upgrades
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SecretUpgradeTest test that a secret is available before and after
0000000000000000000000000000000000000000;;	// a cluster upgrade.
0000000000000000000000000000000000000000;;	type SecretUpgradeTest struct {
0000000000000000000000000000000000000000;;		secret *v1.Secret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (SecretUpgradeTest) Name() string { return "secret-upgrade" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Setup creates a secret and then verifies that a pod can consume it.
0000000000000000000000000000000000000000;;	func (t *SecretUpgradeTest) Setup(f *framework.Framework) {
0000000000000000000000000000000000000000;;		secretName := "upgrade-secret"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := f.Namespace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.secret = &v1.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: ns.Name,
0000000000000000000000000000000000000000;;				Name:      secretName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: map[string][]byte{
0000000000000000000000000000000000000000;;				"data": []byte("keep it secret"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating a secret")
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if t.secret, err = f.ClientSet.Core().Secrets(ns.Name).Create(t.secret); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("unable to create test secret %s: %v", t.secret.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Making sure the secret is consumable")
0000000000000000000000000000000000000000;;		t.testPod(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test waits for the upgrade to complete, and then verifies that a
0000000000000000000000000000000000000000;;	// pod can still consume the secret.
0000000000000000000000000000000000000000;;	func (t *SecretUpgradeTest) Test(f *framework.Framework, done <-chan struct{}, upgrade UpgradeType) {
0000000000000000000000000000000000000000;;		<-done
0000000000000000000000000000000000000000;;		By("Consuming the secret after upgrade")
0000000000000000000000000000000000000000;;		t.testPod(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Teardown cleans up any remaining resources.
0000000000000000000000000000000000000000;;	func (t *SecretUpgradeTest) Teardown(f *framework.Framework) {
0000000000000000000000000000000000000000;;		// rely on the namespace deletion to clean up everything
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testPod creates a pod that consumes a secret and prints it out. The
0000000000000000000000000000000000000000;;	// output is then verified.
0000000000000000000000000000000000000000;;	func (t *SecretUpgradeTest) testPod(f *framework.Framework) {
0000000000000000000000000000000000000000;;		volumeName := "secret-volume"
0000000000000000000000000000000000000000;;		volumeMountPath := "/etc/secret-volume"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "pod-secrets-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				Namespace: t.secret.ObjectMeta.Namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: volumeName,
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							Secret: &v1.SecretVolumeSource{
0000000000000000000000000000000000000000;;								SecretName: t.secret.ObjectMeta.Name,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "secret-volume-test",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/mounttest:0.7",
0000000000000000000000000000000000000000;;						Args: []string{
0000000000000000000000000000000000000000;;							fmt.Sprintf("--file_content=%s/data", volumeMountPath),
0000000000000000000000000000000000000000;;							fmt.Sprintf("--file_mode=%s/data", volumeMountPath),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      volumeName,
0000000000000000000000000000000000000000;;								MountPath: volumeMountPath,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:    "secret-env-test",
0000000000000000000000000000000000000000;;						Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;						Command: []string{"sh", "-c", "env"},
0000000000000000000000000000000000000000;;						Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: "SECRET_DATA",
0000000000000000000000000000000000000000;;								ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;									SecretKeyRef: &v1.SecretKeySelector{
0000000000000000000000000000000000000000;;										LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;											Name: t.secret.ObjectMeta.Name,
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										Key: "data",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedOutput := []string{
0000000000000000000000000000000000000000;;			"content of file \"/etc/secret-volume/data\": keep it secret",
0000000000000000000000000000000000000000;;			"mode of file \"/etc/secret-volume/data\": -rw-r--r--",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.TestContainerOutput("volume consume secrets", pod, 0, expectedOutput)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedOutput = []string{"SECRET_DATA=keep it secret"}
0000000000000000000000000000000000000000;;		f.TestContainerOutput("env consume secrets", pod, 1, expectedOutput)
0000000000000000000000000000000000000000;;	}
