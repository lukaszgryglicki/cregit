0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
73ba215d69abf1884556cfb6245cc6c1596e2b5e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package upgrades
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		deploymentutil "k8s.io/kubernetes/pkg/controller/deployment/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/version"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Test that the deployment stays available during master (and maybe
0000000000000000000000000000000000000000;;	// node and cluster upgrades).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeploymentUpgradeTest tests that a deployment is using the same replica
0000000000000000000000000000000000000000;;	// sets before and after a cluster upgrade.
0000000000000000000000000000000000000000;;	type DeploymentUpgradeTest struct {
0000000000000000000000000000000000000000;;		oldD     *extensions.Deployment
0000000000000000000000000000000000000000;;		updatedD *extensions.Deployment
0000000000000000000000000000000000000000;;		oldRS    *extensions.ReplicaSet
0000000000000000000000000000000000000000;;		newRS    *extensions.ReplicaSet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (DeploymentUpgradeTest) Name() string { return "[sig-apps] deployment-upgrade" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (DeploymentUpgradeTest) Skip(upgCtx UpgradeContext) bool {
0000000000000000000000000000000000000000;;		// The Deployment upgrade test currently relies on implementation details to probe the
0000000000000000000000000000000000000000;;		// ReplicaSets belonging to a Deployment. As of 1.7, the client code we call into no
0000000000000000000000000000000000000000;;		// longer supports talking to a server <1.6. (see #47685)
0000000000000000000000000000000000000000;;		minVersion := version.MustParseSemantic("v1.6.0")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, vCtx := range upgCtx.Versions {
0000000000000000000000000000000000000000;;			if vCtx.Version.LessThan(minVersion) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ Skippable = DeploymentUpgradeTest{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Setup creates a deployment and makes sure it has a new and an old replica set running.
0000000000000000000000000000000000000000;;	// This calls in to client code and should not be expected to work against a cluster more than one minor version away from the current version.
0000000000000000000000000000000000000000;;	func (t *DeploymentUpgradeTest) Setup(f *framework.Framework) {
0000000000000000000000000000000000000000;;		deploymentName := "deployment-hash-test"
0000000000000000000000000000000000000000;;		c := f.ClientSet
0000000000000000000000000000000000000000;;		nginxImage := "gcr.io/google_containers/nginx-slim:0.8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating a deployment %q in namespace %q", deploymentName, ns))
0000000000000000000000000000000000000000;;		d := framework.NewDeployment(deploymentName, int32(1), map[string]string{"test": "upgrade"}, "nginx", nginxImage, extensions.RollingUpdateDeploymentStrategyType)
0000000000000000000000000000000000000000;;		deployment, err := c.Extensions().Deployments(ns).Create(d)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for it to be updated to revision 1
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Waiting deployment %q to be updated to revision 1", deploymentName))
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRevisionAndImage(c, ns, deploymentName, "1", nginxImage)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Waiting deployment %q to complete", deploymentName))
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.WaitForDeploymentStatusValid(c, deployment))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs, err := deploymentutil.GetNewReplicaSet(deployment, c)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		if rs == nil {
0000000000000000000000000000000000000000;;			framework.ExpectNoError(fmt.Errorf("expected a new replica set for deployment %q, found none", deployment.Name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Store the old replica set - should be the same after the upgrade.
0000000000000000000000000000000000000000;;		t.oldRS = rs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Trigger a new rollout so that we have some history.
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Triggering a new rollout for deployment %q", deploymentName))
0000000000000000000000000000000000000000;;		deployment, err = framework.UpdateDeploymentWithRetries(c, ns, deploymentName, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;			update.Spec.Template.Spec.Containers[0].Name = "updated-name"
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use observedGeneration to determine if the controller noticed the pod template update.
0000000000000000000000000000000000000000;;		framework.Logf("Wait deployment %q to be observed by the deployment controller", deploymentName)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.WaitForObservedDeployment(c, ns, deploymentName, deployment.Generation))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for it to be updated to revision 2
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Waiting deployment %q to be updated to revision 2", deploymentName))
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.WaitForDeploymentRevisionAndImage(c, ns, deploymentName, "2", nginxImage))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Waiting deployment %q to complete", deploymentName))
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.WaitForDeploymentStatus(c, deployment))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs, err = deploymentutil.GetNewReplicaSet(deployment, c)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		if rs == nil {
0000000000000000000000000000000000000000;;			framework.ExpectNoError(fmt.Errorf("expected a new replica set for deployment %q", deployment.Name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rs.UID == t.oldRS.UID {
0000000000000000000000000000000000000000;;			framework.ExpectNoError(fmt.Errorf("expected a new replica set different from the previous one"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Store new replica set - should be the same after the upgrade.
0000000000000000000000000000000000000000;;		t.newRS = rs
0000000000000000000000000000000000000000;;		deployment, err = c.Extensions().Deployments(ns).Get(deployment.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		t.oldD = deployment
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test checks whether the replica sets for a deployment are the same after an upgrade.
0000000000000000000000000000000000000000;;	func (t *DeploymentUpgradeTest) Test(f *framework.Framework, done <-chan struct{}, upgrade UpgradeType) {
0000000000000000000000000000000000000000;;		// Block until upgrade is done
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Waiting for upgrade to finish before checking replica sets for deployment %q", t.oldD.Name))
0000000000000000000000000000000000000000;;		<-done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := f.ClientSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deployment, err := c.Extensions().Deployments(t.oldD.Namespace).Get(t.oldD.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		t.updatedD = deployment
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Waiting for deployment %q to complete adoption", deployment.Name))
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.WaitForDeploymentStatus(c, deployment))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Checking that replica sets for deployment %q are the same as prior to the upgrade", t.updatedD.Name))
0000000000000000000000000000000000000000;;		_, allOldRSs, newRS, err := deploymentutil.GetAllReplicaSets(t.updatedD, c)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		if newRS == nil {
0000000000000000000000000000000000000000;;			By(t.spewDeploymentAndReplicaSets(newRS, allOldRSs))
0000000000000000000000000000000000000000;;			framework.ExpectNoError(fmt.Errorf("expected a new replica set for deployment %q", t.updatedD.Name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if newRS.UID != t.newRS.UID {
0000000000000000000000000000000000000000;;			By(t.spewDeploymentAndReplicaSets(newRS, allOldRSs))
0000000000000000000000000000000000000000;;			framework.ExpectNoError(fmt.Errorf("expected new replica set:\n%#v\ngot new replica set:\n%#v\n", t.newRS, newRS))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(allOldRSs) != 1 {
0000000000000000000000000000000000000000;;			By(t.spewDeploymentAndReplicaSets(newRS, allOldRSs))
0000000000000000000000000000000000000000;;			errString := fmt.Sprintf("expected one old replica set, got %d\n", len(allOldRSs))
0000000000000000000000000000000000000000;;			for i := range allOldRSs {
0000000000000000000000000000000000000000;;				rs := allOldRSs[i]
0000000000000000000000000000000000000000;;				errString += fmt.Sprintf("%#v\n", rs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.ExpectNoError(fmt.Errorf(errString))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if allOldRSs[0].UID != t.oldRS.UID {
0000000000000000000000000000000000000000;;			By(t.spewDeploymentAndReplicaSets(newRS, allOldRSs))
0000000000000000000000000000000000000000;;			framework.ExpectNoError(fmt.Errorf("expected old replica set:\n%#v\ngot old replica set:\n%#v\n", t.oldRS, allOldRSs[0]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Teardown cleans up any remaining resources.
0000000000000000000000000000000000000000;;	func (t *DeploymentUpgradeTest) Teardown(f *framework.Framework) {
0000000000000000000000000000000000000000;;		// rely on the namespace deletion to clean up everything
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *DeploymentUpgradeTest) spewDeploymentAndReplicaSets(newRS *extensions.ReplicaSet, allOldRSs []*extensions.ReplicaSet) string {
0000000000000000000000000000000000000000;;		msg := fmt.Sprintf("deployment prior to the upgrade:\n%#v\n", t.oldD)
0000000000000000000000000000000000000000;;		msg += fmt.Sprintf("old replica sets prior to the upgrade:\n%#v\n", t.oldRS)
0000000000000000000000000000000000000000;;		msg += fmt.Sprintf("new replica sets prior to the upgrade:\n%#v\n", t.newRS)
0000000000000000000000000000000000000000;;		msg += fmt.Sprintf("deployment after the upgrade:\n%#v\n", t.updatedD)
0000000000000000000000000000000000000000;;		msg += fmt.Sprintf("new replica set after the upgrade:\n%#v\n", newRS)
0000000000000000000000000000000000000000;;		msg += fmt.Sprintf("old replica sets after the upgrade:\n")
0000000000000000000000000000000000000000;;		for i := range allOldRSs {
0000000000000000000000000000000000000000;;			msg += fmt.Sprintf("%#v\n", allOldRSs[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msg
0000000000000000000000000000000000000000;;	}
