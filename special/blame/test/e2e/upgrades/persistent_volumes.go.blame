0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
612624b02993e78549cd4a347efb85f2a637588e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package upgrades
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumeUpgradeTest test that a pv is available before and after a cluster upgrade.
0000000000000000000000000000000000000000;;	type PersistentVolumeUpgradeTest struct {
0000000000000000000000000000000000000000;;		pvSource *v1.PersistentVolumeSource
0000000000000000000000000000000000000000;;		pv       *v1.PersistentVolume
0000000000000000000000000000000000000000;;		pvc      *v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (PersistentVolumeUpgradeTest) Name() string { return "persistent-volume-upgrade" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		pvTestFile string = "/mnt/volume1/pv_upgrade_test"
0000000000000000000000000000000000000000;;		pvTestData string = "keep it pv"
0000000000000000000000000000000000000000;;		pvWriteCmd string = "echo \"" + pvTestData + "\" > " + pvTestFile
0000000000000000000000000000000000000000;;		pvReadCmd  string = "cat " + pvTestFile
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *PersistentVolumeUpgradeTest) createGCEVolume() *v1.PersistentVolumeSource {
0000000000000000000000000000000000000000;;		diskName, err := framework.CreatePDWithRetry()
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		return &v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;			GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;				PDName:   diskName,
0000000000000000000000000000000000000000;;				FSType:   "ext3",
0000000000000000000000000000000000000000;;				ReadOnly: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (t *PersistentVolumeUpgradeTest) deleteGCEVolume(pvSource *v1.PersistentVolumeSource) error {
0000000000000000000000000000000000000000;;		return framework.DeletePDWithRetry(pvSource.GCEPersistentDisk.PDName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Setup creates a pv and then verifies that a pod can consume it.  The pod writes data to the volume.
0000000000000000000000000000000000000000;;	func (t *PersistentVolumeUpgradeTest) Setup(f *framework.Framework) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		// TODO: generalize this to other providers
0000000000000000000000000000000000000000;;		framework.SkipUnlessProviderIs("gce", "gke")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Initializing PV source")
0000000000000000000000000000000000000000;;		t.pvSource = t.createGCEVolume()
0000000000000000000000000000000000000000;;		pvConfig := framework.PersistentVolumeConfig{
0000000000000000000000000000000000000000;;			NamePrefix: "pv-upgrade",
0000000000000000000000000000000000000000;;			PVSource:   *t.pvSource,
0000000000000000000000000000000000000000;;			Prebind:    nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pvcConfig := framework.PersistentVolumeClaimConfig{
0000000000000000000000000000000000000000;;			Annotations: map[string]string{
0000000000000000000000000000000000000000;;				v1.BetaStorageClassAnnotation: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating the PV and PVC")
0000000000000000000000000000000000000000;;		t.pv, t.pvc, err = framework.CreatePVPVC(f.ClientSet, pvConfig, pvcConfig, ns, true)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.WaitOnPVandPVC(f.ClientSet, ns, t.pv, t.pvc))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Consuming the PV before upgrade")
0000000000000000000000000000000000000000;;		t.testPod(f, pvWriteCmd+";"+pvReadCmd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test waits for the upgrade to complete, and then verifies that a pod can still consume the pv
0000000000000000000000000000000000000000;;	// and that the volume data persists.
0000000000000000000000000000000000000000;;	func (t *PersistentVolumeUpgradeTest) Test(f *framework.Framework, done <-chan struct{}, upgrade UpgradeType) {
0000000000000000000000000000000000000000;;		<-done
0000000000000000000000000000000000000000;;		By("Consuming the PV after upgrade")
0000000000000000000000000000000000000000;;		t.testPod(f, pvReadCmd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Teardown cleans up any remaining resources.
0000000000000000000000000000000000000000;;	func (t *PersistentVolumeUpgradeTest) Teardown(f *framework.Framework) {
0000000000000000000000000000000000000000;;		errs := framework.PVPVCCleanup(f.ClientSet, f.Namespace.Name, t.pv, t.pvc)
0000000000000000000000000000000000000000;;		if err := t.deleteGCEVolume(t.pvSource); err != nil {
0000000000000000000000000000000000000000;;			errs = append(errs, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(errs) > 0 {
0000000000000000000000000000000000000000;;			framework.Failf("Failed to delete 1 or more PVs/PVCs and/or the GCE volume. Errors: %v", utilerrors.NewAggregate(errs))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testPod creates a pod that consumes a pv and prints it out. The output is then verified.
0000000000000000000000000000000000000000;;	func (t *PersistentVolumeUpgradeTest) testPod(f *framework.Framework, cmd string) {
0000000000000000000000000000000000000000;;		pod := framework.MakePod(f.Namespace.Name, []*v1.PersistentVolumeClaim{t.pvc}, false, cmd)
0000000000000000000000000000000000000000;;		expectedOutput := []string{pvTestData}
0000000000000000000000000000000000000000;;		f.TestContainerOutput("pod consumes pv", pod, 0, expectedOutput)
0000000000000000000000000000000000000000;;	}
