0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
c0c298ad4f7444498c030f9085593b58ae0da3df;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package upgrades
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IngressUpgradeTest adapts the Ingress e2e for upgrade testing
0000000000000000000000000000000000000000;;	type IngressUpgradeTest struct {
0000000000000000000000000000000000000000;;		gceController *framework.GCEIngressController
0000000000000000000000000000000000000000;;		jig           *framework.IngressTestJig
0000000000000000000000000000000000000000;;		httpClient    *http.Client
0000000000000000000000000000000000000000;;		ip            string
0000000000000000000000000000000000000000;;		ipName        string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (IngressUpgradeTest) Name() string { return "ingress-upgrade" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Setup creates a GLBC, allocates an ip, and an ingress resource,
0000000000000000000000000000000000000000;;	// then waits for a successful connectivity check to the ip.
0000000000000000000000000000000000000000;;	func (t *IngressUpgradeTest) Setup(f *framework.Framework) {
0000000000000000000000000000000000000000;;		framework.SkipUnlessProviderIs("gce", "gke")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// jig handles all Kubernetes testing logic
0000000000000000000000000000000000000000;;		jig := framework.NewIngressTestJig(f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := f.Namespace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// gceController handles all cloud testing logic
0000000000000000000000000000000000000000;;		gceController := &framework.GCEIngressController{
0000000000000000000000000000000000000000;;			Ns:     ns.Name,
0000000000000000000000000000000000000000;;			Client: jig.Client,
0000000000000000000000000000000000000000;;			Cloud:  framework.TestContext.CloudConfig,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gceController.Init()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.gceController = gceController
0000000000000000000000000000000000000000;;		t.jig = jig
0000000000000000000000000000000000000000;;		t.httpClient = framework.BuildInsecureClient(framework.IngressReqTimeout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allocate a static-ip for the Ingress, this IP is cleaned up via CleanupGCEIngressController
0000000000000000000000000000000000000000;;		t.ipName = fmt.Sprintf("%s-static-ip", ns.Name)
0000000000000000000000000000000000000000;;		t.ip = t.gceController.CreateStaticIP(t.ipName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a working basic Ingress
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("allocated static ip %v: %v through the GCE cloud provider", t.ipName, t.ip))
0000000000000000000000000000000000000000;;		jig.CreateIngress(filepath.Join(framework.IngressManifestPath, "static-ip"), ns.Name, map[string]string{
0000000000000000000000000000000000000000;;			"kubernetes.io/ingress.global-static-ip-name": t.ipName,
0000000000000000000000000000000000000000;;			"kubernetes.io/ingress.allow-http":            "false",
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("waiting for Ingress to come up with ip: " + t.ip)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.PollURL(fmt.Sprintf("https://%v/", t.ip), "", framework.LoadBalancerPollTimeout, jig.PollInterval, t.httpClient, false))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test waits for the upgrade to complete, and then verifies
0000000000000000000000000000000000000000;;	// with a connectvity check to the loadbalancer ip.
0000000000000000000000000000000000000000;;	func (t *IngressUpgradeTest) Test(f *framework.Framework, done <-chan struct{}, upgrade UpgradeType) {
0000000000000000000000000000000000000000;;		switch upgrade {
0000000000000000000000000000000000000000;;		case MasterUpgrade:
0000000000000000000000000000000000000000;;			// Restarting the ingress controller shouldn't disrupt a steady state
0000000000000000000000000000000000000000;;			// Ingress. Restarting the ingress controller and deleting ingresses
0000000000000000000000000000000000000000;;			// while it's down will leak cloud resources, because the ingress
0000000000000000000000000000000000000000;;			// controller doesn't checkpoint to disk.
0000000000000000000000000000000000000000;;			t.verify(f, done, true)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// Currently ingress gets disrupted across node upgrade, because endpoints
0000000000000000000000000000000000000000;;			// get killed and we don't have any guarantees that 2 nodes don't overlap
0000000000000000000000000000000000000000;;			// their upgrades (even on cloud platforms like GCE, because VM level
0000000000000000000000000000000000000000;;			// rolling upgrades are not Kubernetes aware).
0000000000000000000000000000000000000000;;			t.verify(f, done, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Teardown cleans up any remaining resources.
0000000000000000000000000000000000000000;;	func (t *IngressUpgradeTest) Teardown(f *framework.Framework) {
0000000000000000000000000000000000000000;;		if CurrentGinkgoTestDescription().Failed {
0000000000000000000000000000000000000000;;			framework.DescribeIng(t.gceController.Ns)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.jig.Ingress != nil {
0000000000000000000000000000000000000000;;			By("Deleting ingress")
0000000000000000000000000000000000000000;;			t.jig.TryDeleteIngress()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			By("No ingress created, no cleanup necessary")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Cleaning up cloud resources")
0000000000000000000000000000000000000000;;		framework.CleanupGCEIngressController(t.gceController)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *IngressUpgradeTest) verify(f *framework.Framework, done <-chan struct{}, testDuringDisruption bool) {
0000000000000000000000000000000000000000;;		if testDuringDisruption {
0000000000000000000000000000000000000000;;			By("continuously hitting the Ingress IP")
0000000000000000000000000000000000000000;;			wait.Until(func() {
0000000000000000000000000000000000000000;;				framework.ExpectNoError(framework.PollURL(fmt.Sprintf("https://%v/", t.ip), "", framework.LoadBalancerPollTimeout, t.jig.PollInterval, t.httpClient, false))
0000000000000000000000000000000000000000;;			}, t.jig.PollInterval, done)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			By("waiting for upgrade to finish without checking if Ingress remains up")
0000000000000000000000000000000000000000;;			<-done
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		By("hitting the Ingress IP " + t.ip)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.PollURL(fmt.Sprintf("https://%v/", t.ip), "", framework.LoadBalancerPollTimeout, t.jig.PollInterval, t.httpClient, false))
0000000000000000000000000000000000000000;;	}
