0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
9738c82d39c98b2fd2586e160995a8fb49681347;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package upgrades
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceUpgradeTest tests that a service is available before and
0000000000000000000000000000000000000000;;	// after a cluster upgrade. During a master-only upgrade, it will test
0000000000000000000000000000000000000000;;	// that a service remains available during the upgrade.
0000000000000000000000000000000000000000;;	type ServiceUpgradeTest struct {
0000000000000000000000000000000000000000;;		jig          *framework.ServiceTestJig
0000000000000000000000000000000000000000;;		tcpService   *v1.Service
0000000000000000000000000000000000000000;;		tcpIngressIP string
0000000000000000000000000000000000000000;;		svcPort      int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ServiceUpgradeTest) Name() string { return "service-upgrade" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func shouldTestPDBs() bool { return framework.ProviderIs("gce", "gke") }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Setup creates a service with a load balancer and makes sure it's reachable.
0000000000000000000000000000000000000000;;	func (t *ServiceUpgradeTest) Setup(f *framework.Framework) {
0000000000000000000000000000000000000000;;		serviceName := "service-test"
0000000000000000000000000000000000000000;;		jig := framework.NewServiceTestJig(f.ClientSet, serviceName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := f.Namespace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("creating a TCP service " + serviceName + " with type=LoadBalancer in namespace " + ns.Name)
0000000000000000000000000000000000000000;;		tcpService := jig.CreateTCPServiceOrFail(ns.Name, func(s *v1.Service) {
0000000000000000000000000000000000000000;;			s.Spec.Type = v1.ServiceTypeLoadBalancer
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		tcpService = jig.WaitForLoadBalancerOrFail(ns.Name, tcpService.Name, framework.LoadBalancerCreateTimeoutDefault)
0000000000000000000000000000000000000000;;		jig.SanityCheckService(tcpService, v1.ServiceTypeLoadBalancer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get info to hit it with
0000000000000000000000000000000000000000;;		tcpIngressIP := framework.GetIngressPoint(&tcpService.Status.LoadBalancer.Ingress[0])
0000000000000000000000000000000000000000;;		svcPort := int(tcpService.Spec.Ports[0].Port)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("creating pod to be part of service " + serviceName)
0000000000000000000000000000000000000000;;		rc := jig.RunOrFail(ns.Name, jig.AddRCAntiAffinity)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if shouldTestPDBs() {
0000000000000000000000000000000000000000;;			By("creating a PodDisruptionBudget to cover the ReplicationController")
0000000000000000000000000000000000000000;;			jig.CreatePDBOrFail(ns.Name, rc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Hit it once before considering ourselves ready
0000000000000000000000000000000000000000;;		By("hitting the pod through the service's LoadBalancer")
0000000000000000000000000000000000000000;;		jig.TestReachableHTTP(tcpIngressIP, svcPort, framework.LoadBalancerLagTimeoutDefault)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.jig = jig
0000000000000000000000000000000000000000;;		t.tcpService = tcpService
0000000000000000000000000000000000000000;;		t.tcpIngressIP = tcpIngressIP
0000000000000000000000000000000000000000;;		t.svcPort = svcPort
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test runs a connectivity check to the service.
0000000000000000000000000000000000000000;;	func (t *ServiceUpgradeTest) Test(f *framework.Framework, done <-chan struct{}, upgrade UpgradeType) {
0000000000000000000000000000000000000000;;		switch upgrade {
0000000000000000000000000000000000000000;;		case MasterUpgrade:
0000000000000000000000000000000000000000;;			t.test(f, done, true)
0000000000000000000000000000000000000000;;		case NodeUpgrade:
0000000000000000000000000000000000000000;;			// Node upgrades should test during disruption only on GCE/GKE for now.
0000000000000000000000000000000000000000;;			t.test(f, done, shouldTestPDBs())
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			t.test(f, done, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Teardown cleans up any remaining resources.
0000000000000000000000000000000000000000;;	func (t *ServiceUpgradeTest) Teardown(f *framework.Framework) {
0000000000000000000000000000000000000000;;		// rely on the namespace deletion to clean up everything
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *ServiceUpgradeTest) test(f *framework.Framework, done <-chan struct{}, testDuringDisruption bool) {
0000000000000000000000000000000000000000;;		if testDuringDisruption {
0000000000000000000000000000000000000000;;			// Continuous validation
0000000000000000000000000000000000000000;;			By("continuously hitting the pod through the service's LoadBalancer")
0000000000000000000000000000000000000000;;			wait.Until(func() {
0000000000000000000000000000000000000000;;				t.jig.TestReachableHTTP(t.tcpIngressIP, t.svcPort, framework.LoadBalancerLagTimeoutDefault)
0000000000000000000000000000000000000000;;			}, framework.Poll, done)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Block until upgrade is done
0000000000000000000000000000000000000000;;			By("waiting for upgrade to finish without checking if service remains up")
0000000000000000000000000000000000000000;;			<-done
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sanity check and hit it once more
0000000000000000000000000000000000000000;;		By("hitting the pod through the service's LoadBalancer")
0000000000000000000000000000000000000000;;		t.jig.TestReachableHTTP(t.tcpIngressIP, t.svcPort, framework.LoadBalancerLagTimeoutDefault)
0000000000000000000000000000000000000000;;		t.jig.SanityCheckService(t.tcpService, v1.ServiceTypeLoadBalancer)
0000000000000000000000000000000000000000;;	}
