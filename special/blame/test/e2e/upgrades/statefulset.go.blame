0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
23e6e0d7074962817554d82608eba0c21c60cac6;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package upgrades
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apps "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/version"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatefulSetUpgradeTest implements an upgrade test harness for StatefulSet upgrade testing.
0000000000000000000000000000000000000000;;	type StatefulSetUpgradeTest struct {
0000000000000000000000000000000000000000;;		tester  *framework.StatefulSetTester
0000000000000000000000000000000000000000;;		service *v1.Service
0000000000000000000000000000000000000000;;		set     *apps.StatefulSet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (StatefulSetUpgradeTest) Name() string { return "[sig-apps] statefulset-upgrade" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (StatefulSetUpgradeTest) Skip(upgCtx UpgradeContext) bool {
0000000000000000000000000000000000000000;;		minVersion := version.MustParseSemantic("1.5.0")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, vCtx := range upgCtx.Versions {
0000000000000000000000000000000000000000;;			if vCtx.Version.LessThan(minVersion) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Setup creates a StatefulSet and a HeadlessService. It verifies the basic SatefulSet properties
0000000000000000000000000000000000000000;;	func (t *StatefulSetUpgradeTest) Setup(f *framework.Framework) {
0000000000000000000000000000000000000000;;		ssName := "ss"
0000000000000000000000000000000000000000;;		labels := map[string]string{
0000000000000000000000000000000000000000;;			"foo": "bar",
0000000000000000000000000000000000000000;;			"baz": "blah",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headlessSvcName := "test"
0000000000000000000000000000000000000000;;		statefulPodMounts := []v1.VolumeMount{{Name: "datadir", MountPath: "/data/"}}
0000000000000000000000000000000000000000;;		podMounts := []v1.VolumeMount{{Name: "home", MountPath: "/home"}}
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;		t.set = framework.NewStatefulSet(ssName, ns, headlessSvcName, 2, statefulPodMounts, podMounts, labels)
0000000000000000000000000000000000000000;;		t.service = framework.CreateStatefulSetService(ssName, labels)
0000000000000000000000000000000000000000;;		*(t.set.Spec.Replicas) = 3
0000000000000000000000000000000000000000;;		framework.SetStatefulSetInitializedAnnotation(t.set, "false")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating service " + headlessSvcName + " in namespace " + ns)
0000000000000000000000000000000000000000;;		_, err := f.ClientSet.Core().Services(ns).Create(t.service)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		t.tester = framework.NewStatefulSetTester(f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating statefulset " + ssName + " in namespace " + ns)
0000000000000000000000000000000000000000;;		*(t.set.Spec.Replicas) = 3
0000000000000000000000000000000000000000;;		_, err = f.ClientSet.Apps().StatefulSets(ns).Create(t.set)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Saturating stateful set " + t.set.Name)
0000000000000000000000000000000000000000;;		t.tester.Saturate(t.set)
0000000000000000000000000000000000000000;;		t.verify()
0000000000000000000000000000000000000000;;		t.restart()
0000000000000000000000000000000000000000;;		t.verify()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Waits for the upgrade to complete and verifies the StatefulSet basic functionality
0000000000000000000000000000000000000000;;	func (t *StatefulSetUpgradeTest) Test(f *framework.Framework, done <-chan struct{}, upgrade UpgradeType) {
0000000000000000000000000000000000000000;;		<-done
0000000000000000000000000000000000000000;;		t.verify()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Deletes all StatefulSets
0000000000000000000000000000000000000000;;	func (t *StatefulSetUpgradeTest) Teardown(f *framework.Framework) {
0000000000000000000000000000000000000000;;		framework.DeleteAllStatefulSets(f.ClientSet, t.set.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *StatefulSetUpgradeTest) verify() {
0000000000000000000000000000000000000000;;		By("Verifying statefulset mounted data directory is usable")
0000000000000000000000000000000000000000;;		framework.ExpectNoError(t.tester.CheckMount(t.set, "/data"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Verifying statefulset provides a stable hostname for each pod")
0000000000000000000000000000000000000000;;		framework.ExpectNoError(t.tester.CheckHostname(t.set))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Verifying statefulset set proper service name")
0000000000000000000000000000000000000000;;		framework.ExpectNoError(t.tester.CheckServiceName(t.set, t.set.Spec.ServiceName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := "echo $(hostname) > /data/hostname; sync;"
0000000000000000000000000000000000000000;;		By("Running " + cmd + " in all stateful pods")
0000000000000000000000000000000000000000;;		framework.ExpectNoError(t.tester.ExecInStatefulPods(t.set, cmd))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *StatefulSetUpgradeTest) restart() {
0000000000000000000000000000000000000000;;		By("Restarting statefulset " + t.set.Name)
0000000000000000000000000000000000000000;;		t.tester.Restart(t.set)
0000000000000000000000000000000000000000;;		t.tester.Saturate(t.set)
0000000000000000000000000000000000000000;;	}
