0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
a52e526387eeee6d48ee37d3c6940680edcaae00;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package upgrades
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/sysctl"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SecretUpgradeTest tests that a pod with sysctls runs before and after an upgrade. During
0000000000000000000000000000000000000000;;	// a master upgrade, the exact pod is expected to stay running. A pod with unsafe sysctls is
0000000000000000000000000000000000000000;;	// expected to keep failing before and after the upgrade.
0000000000000000000000000000000000000000;;	type SysctlUpgradeTest struct {
0000000000000000000000000000000000000000;;		validPod   *v1.Pod
0000000000000000000000000000000000000000;;		invalidPod *v1.Pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Setup creates two pods: one with safe sysctls, one with unsafe sysctls. It checks that the former
0000000000000000000000000000000000000000;;	// launched and the later is rejected.
0000000000000000000000000000000000000000;;	func (t *SysctlUpgradeTest) Setup(f *framework.Framework) {
0000000000000000000000000000000000000000;;		t.validPod = t.verifySafeSysctlWork(f)
0000000000000000000000000000000000000000;;		t.invalidPod = t.verifyUnsafeSysctlsAreRejected(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test waits for the upgrade to complete, and then verifies that a
0000000000000000000000000000000000000000;;	// pod can still consume the ConfigMap.
0000000000000000000000000000000000000000;;	func (t *SysctlUpgradeTest) Test(f *framework.Framework, done <-chan struct{}, upgrade UpgradeType) {
0000000000000000000000000000000000000000;;		<-done
0000000000000000000000000000000000000000;;		switch upgrade {
0000000000000000000000000000000000000000;;		case MasterUpgrade:
0000000000000000000000000000000000000000;;			By("Checking the safe sysctl pod keeps running on master upgrade")
0000000000000000000000000000000000000000;;			pod, err := f.ClientSet.Core().Pods(t.validPod.Namespace).Get(t.validPod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(pod.Status.Phase).To(Equal(v1.PodRunning))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Checking the old unsafe sysctl pod was not suddenly started during an upgrade")
0000000000000000000000000000000000000000;;		pod, err := f.ClientSet.Core().Pods(t.invalidPod.Namespace).Get(t.invalidPod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil && !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			Expect(pod.Status.Phase).NotTo(Equal(v1.PodRunning))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.verifySafeSysctlWork(f)
0000000000000000000000000000000000000000;;		t.verifyUnsafeSysctlsAreRejected(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Teardown cleans up any remaining resources.
0000000000000000000000000000000000000000;;	func (t *SysctlUpgradeTest) Teardown(f *framework.Framework) {
0000000000000000000000000000000000000000;;		// rely on the namespace deletion to clean up everything
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *SysctlUpgradeTest) verifySafeSysctlWork(f *framework.Framework) *v1.Pod {
0000000000000000000000000000000000000000;;		By("Creating a pod with safe sysctls")
0000000000000000000000000000000000000000;;		safeSysctl := "net.ipv4.ip_local_port_range"
0000000000000000000000000000000000000000;;		safeSysctlValue := "1024 1042"
0000000000000000000000000000000000000000;;		validPod := sysctlTestPod("valid-sysctls", map[string]string{safeSysctl: safeSysctlValue})
0000000000000000000000000000000000000000;;		validPod = f.PodClient().Create(t.validPod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Making sure the valid pod launches")
0000000000000000000000000000000000000000;;		ev, err := f.PodClient().WaitForErrorEventOrSuccess(t.validPod)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		if ev != nil && ev.Reason == sysctl.UnsupportedReason {
0000000000000000000000000000000000000000;;			framework.Skipf("No sysctl support in Docker <1.12")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.TestContainerOutput("pod with safe sysctl launched", t.validPod, 0, []string{fmt.Sprintf("%s = %s", safeSysctl, safeSysctlValue)})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return validPod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *SysctlUpgradeTest) verifyUnsafeSysctlsAreRejected(f *framework.Framework) *v1.Pod {
0000000000000000000000000000000000000000;;		By("Creating a pod with unsafe sysctls")
0000000000000000000000000000000000000000;;		invalidPod := sysctlTestPod("valid-sysctls-"+string(uuid.NewUUID()), map[string]string{
0000000000000000000000000000000000000000;;			"fs.mount-max": "1000000",
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		invalidPod = f.PodClient().Create(invalidPod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Making sure the invalid pod failed")
0000000000000000000000000000000000000000;;		ev, err := f.PodClient().WaitForErrorEventOrSuccess(invalidPod)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		if ev != nil && ev.Reason == sysctl.UnsupportedReason {
0000000000000000000000000000000000000000;;			framework.Skipf("No sysctl support in Docker <1.12")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Expect(ev.Reason).To(Equal(sysctl.ForbiddenReason))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return invalidPod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sysctlTestPod(name string, sysctls map[string]string) *v1.Pod {
0000000000000000000000000000000000000000;;		sysctlList := []v1.Sysctl{}
0000000000000000000000000000000000000000;;		keys := []string{}
0000000000000000000000000000000000000000;;		for k, v := range sysctls {
0000000000000000000000000000000000000000;;			sysctlList = append(sysctlList, v1.Sysctl{Name: k, Value: v})
0000000000000000000000000000000000000000;;			keys = append(keys, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					v1.SysctlsPodAnnotationKey: v1helper.PodAnnotationsFromSysctls(sysctlList),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:    "test-container",
0000000000000000000000000000000000000000;;						Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;						Command: append([]string{"/bin/sysctl"}, keys...),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
