0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
c80a4b8bfd150e67045743b07747181b0d9f3fd6;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package upgrades
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/version"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const manifestPath = "test/e2e/testing-manifests/statefulset/etcd"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EtcdUpgradeTest struct {
0000000000000000000000000000000000000000;;		ip               string
0000000000000000000000000000000000000000;;		successfulWrites int
0000000000000000000000000000000000000000;;		ssTester         *framework.StatefulSetTester
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (EtcdUpgradeTest) Name() string { return "etcd-upgrade" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (EtcdUpgradeTest) Skip(upgCtx UpgradeContext) bool {
0000000000000000000000000000000000000000;;		minVersion := version.MustParseSemantic("1.6.0")
0000000000000000000000000000000000000000;;		for _, vCtx := range upgCtx.Versions {
0000000000000000000000000000000000000000;;			if vCtx.Version.LessThan(minVersion) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func kubectlCreate(ns, file string) {
0000000000000000000000000000000000000000;;		path := filepath.Join(framework.TestContext.RepoRoot, manifestPath, file)
0000000000000000000000000000000000000000;;		framework.RunKubectlOrDie("create", "-f", path, fmt.Sprintf("--namespace=%s", ns))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *EtcdUpgradeTest) Setup(f *framework.Framework) {
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;		statefulsetPoll := 30 * time.Second
0000000000000000000000000000000000000000;;		statefulsetTimeout := 10 * time.Minute
0000000000000000000000000000000000000000;;		t.ssTester = framework.NewStatefulSetTester(f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating a PDB")
0000000000000000000000000000000000000000;;		kubectlCreate(ns, "pdb.yaml")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating an etcd StatefulSet")
0000000000000000000000000000000000000000;;		t.ssTester.CreateStatefulSet(manifestPath, ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating an etcd--test-server deployment")
0000000000000000000000000000000000000000;;		kubectlCreate(ns, "tester.yaml")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Getting the ingress IPs from the services")
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(statefulsetPoll, statefulsetTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			if t.ip = t.getServiceIP(f, ns, "test-server"); t.ip == "" {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := t.listUsers(); err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Service endpoint is up but isn't responding")
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		framework.Logf("Service endpoint is up")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Adding 2 dummy users")
0000000000000000000000000000000000000000;;		Expect(t.addUser("Alice")).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(t.addUser("Bob")).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		t.successfulWrites = 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Verifying that the users exist")
0000000000000000000000000000000000000000;;		users, err := t.listUsers()
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(len(users)).To(Equal(2))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *EtcdUpgradeTest) listUsers() ([]string, error) {
0000000000000000000000000000000000000000;;		r, err := http.Get(fmt.Sprintf("http://%s:8080/list", t.ip))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer r.Body.Close()
0000000000000000000000000000000000000000;;		if r.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			b, err := ioutil.ReadAll(r.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf(string(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var names []string
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(r.Body).Decode(&names); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return names, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *EtcdUpgradeTest) addUser(name string) error {
0000000000000000000000000000000000000000;;		val := map[string][]string{"name": {name}}
0000000000000000000000000000000000000000;;		r, err := http.PostForm(fmt.Sprintf("http://%s:8080/add", t.ip), val)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer r.Body.Close()
0000000000000000000000000000000000000000;;		if r.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			b, err := ioutil.ReadAll(r.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Errorf(string(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *EtcdUpgradeTest) getServiceIP(f *framework.Framework, ns, svcName string) string {
0000000000000000000000000000000000000000;;		svc, err := f.ClientSet.CoreV1().Services(ns).Get(svcName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		ingress := svc.Status.LoadBalancer.Ingress
0000000000000000000000000000000000000000;;		if len(ingress) == 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ingress[0].IP
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *EtcdUpgradeTest) Test(f *framework.Framework, done <-chan struct{}, upgrade UpgradeType) {
0000000000000000000000000000000000000000;;		By("Continuously polling the database during upgrade.")
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			success, failures, writeAttempts, lastUserCount int
0000000000000000000000000000000000000000;;			mu                                              sync.Mutex
0000000000000000000000000000000000000000;;			errors                                          = map[string]int{}
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		// Write loop.
0000000000000000000000000000000000000000;;		go wait.Until(func() {
0000000000000000000000000000000000000000;;			writeAttempts++
0000000000000000000000000000000000000000;;			if err := t.addUser(fmt.Sprintf("user-%d", writeAttempts)); err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Unable to add user: %v", err)
0000000000000000000000000000000000000000;;				mu.Lock()
0000000000000000000000000000000000000000;;				errors[err.Error()]++
0000000000000000000000000000000000000000;;				mu.Unlock()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.successfulWrites++
0000000000000000000000000000000000000000;;		}, 10*time.Millisecond, done)
0000000000000000000000000000000000000000;;		// Read loop.
0000000000000000000000000000000000000000;;		wait.Until(func() {
0000000000000000000000000000000000000000;;			users, err := t.listUsers()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Could not retrieve users: %v", err)
0000000000000000000000000000000000000000;;				failures++
0000000000000000000000000000000000000000;;				mu.Lock()
0000000000000000000000000000000000000000;;				errors[err.Error()]++
0000000000000000000000000000000000000000;;				mu.Unlock()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			success++
0000000000000000000000000000000000000000;;			lastUserCount = len(users)
0000000000000000000000000000000000000000;;		}, 10*time.Millisecond, done)
0000000000000000000000000000000000000000;;		framework.Logf("got %d users; want >=%d", lastUserCount, t.successfulWrites)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Expect(lastUserCount >= t.successfulWrites).To(BeTrue())
0000000000000000000000000000000000000000;;		ratio := float64(success) / float64(success+failures)
0000000000000000000000000000000000000000;;		framework.Logf("Successful gets %d/%d=%v", success, success+failures, ratio)
0000000000000000000000000000000000000000;;		ratio = float64(t.successfulWrites) / float64(writeAttempts)
0000000000000000000000000000000000000000;;		framework.Logf("Successful writes %d/%d=%v", t.successfulWrites, writeAttempts, ratio)
0000000000000000000000000000000000000000;;		framework.Logf("Errors: %v", errors)
0000000000000000000000000000000000000000;;		// TODO(maisem): tweak this value once we have a few test runs.
0000000000000000000000000000000000000000;;		Expect(ratio > 0.75).To(BeTrue())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Teardown does one final check of the data's availability.
0000000000000000000000000000000000000000;;	func (t *EtcdUpgradeTest) Teardown(f *framework.Framework) {
0000000000000000000000000000000000000000;;		users, err := t.listUsers()
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(len(users) >= t.successfulWrites).To(BeTrue())
0000000000000000000000000000000000000000;;	}
