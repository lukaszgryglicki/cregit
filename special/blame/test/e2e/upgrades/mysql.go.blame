0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
728d49c171132ad06cd84ab10deec063d20e7000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package upgrades
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/version"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const mysqlManifestPath = "test/e2e/testing-manifests/statefulset/mysql-upgrade"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MySqlUpgradeTest implements an upgrade test harness that polls a replicated sql database.
0000000000000000000000000000000000000000;;	type MySqlUpgradeTest struct {
0000000000000000000000000000000000000000;;		ip               string
0000000000000000000000000000000000000000;;		successfulWrites int
0000000000000000000000000000000000000000;;		nextWrite        int
0000000000000000000000000000000000000000;;		ssTester         *framework.StatefulSetTester
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (MySqlUpgradeTest) Name() string { return "mysql-upgrade" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (MySqlUpgradeTest) Skip(upgCtx UpgradeContext) bool {
0000000000000000000000000000000000000000;;		minVersion := version.MustParseSemantic("1.5.0")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, vCtx := range upgCtx.Versions {
0000000000000000000000000000000000000000;;			if vCtx.Version.LessThan(minVersion) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mysqlKubectlCreate(ns, file string) {
0000000000000000000000000000000000000000;;		path := filepath.Join(framework.TestContext.RepoRoot, mysqlManifestPath, file)
0000000000000000000000000000000000000000;;		framework.RunKubectlOrDie("create", "-f", path, fmt.Sprintf("--namespace=%s", ns))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *MySqlUpgradeTest) getServiceIP(f *framework.Framework, ns, svcName string) string {
0000000000000000000000000000000000000000;;		svc, err := f.ClientSet.CoreV1().Services(ns).Get(svcName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		ingress := svc.Status.LoadBalancer.Ingress
0000000000000000000000000000000000000000;;		if len(ingress) == 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ingress[0].IP
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Setup creates a StatefulSet, HeadlessService, a Service to write to the db, and a Service to read
0000000000000000000000000000000000000000;;	// from the db. It then connects to the db with the write Service and populates the db with a table
0000000000000000000000000000000000000000;;	// and a few entries. Finally, it connects to the db with the read Service, and confirms the data is
0000000000000000000000000000000000000000;;	// available. The db connections are left open to be used later in the test.
0000000000000000000000000000000000000000;;	func (t *MySqlUpgradeTest) Setup(f *framework.Framework) {
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;		statefulsetPoll := 30 * time.Second
0000000000000000000000000000000000000000;;		statefulsetTimeout := 10 * time.Minute
0000000000000000000000000000000000000000;;		t.ssTester = framework.NewStatefulSetTester(f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating a configmap")
0000000000000000000000000000000000000000;;		mysqlKubectlCreate(ns, "configmap.yaml")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating a mysql StatefulSet")
0000000000000000000000000000000000000000;;		t.ssTester.CreateStatefulSet(mysqlManifestPath, ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating a mysql-test-server deployment")
0000000000000000000000000000000000000000;;		mysqlKubectlCreate(ns, "tester.yaml")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Getting the ingress IPs from the test-service")
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(statefulsetPoll, statefulsetTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			if t.ip = t.getServiceIP(f, ns, "test-server"); t.ip == "" {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := t.countNames(); err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Service endpoint is up but isn't responding")
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		framework.Logf("Service endpoint is up")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Adding 2 names to the database")
0000000000000000000000000000000000000000;;		Expect(t.addName(strconv.Itoa(t.nextWrite))).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(t.addName(strconv.Itoa(t.nextWrite))).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Verifying that the 2 names have been inserted")
0000000000000000000000000000000000000000;;		count, err := t.countNames()
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(count).To(Equal(2))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test continually polls the db using the read and write connections, inserting data, and checking
0000000000000000000000000000000000000000;;	// that all the data is readable.
0000000000000000000000000000000000000000;;	func (t *MySqlUpgradeTest) Test(f *framework.Framework, done <-chan struct{}, upgrade UpgradeType) {
0000000000000000000000000000000000000000;;		var writeSuccess, readSuccess, writeFailure, readFailure int
0000000000000000000000000000000000000000;;		By("Continuously polling the database during upgrade.")
0000000000000000000000000000000000000000;;		go wait.Until(func() {
0000000000000000000000000000000000000000;;			_, err := t.countNames()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Error while trying to read data: %v", err)
0000000000000000000000000000000000000000;;				readFailure++
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				readSuccess++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}, framework.Poll, done)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wait.Until(func() {
0000000000000000000000000000000000000000;;			err := t.addName(strconv.Itoa(t.nextWrite))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Error while trying to write data: %v", err)
0000000000000000000000000000000000000000;;				writeFailure++
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				writeSuccess++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}, framework.Poll, done)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.successfulWrites = writeSuccess
0000000000000000000000000000000000000000;;		framework.Logf("Successful reads: %d", readSuccess)
0000000000000000000000000000000000000000;;		framework.Logf("Successful writes: %d", writeSuccess)
0000000000000000000000000000000000000000;;		framework.Logf("Failed reads: %d", readFailure)
0000000000000000000000000000000000000000;;		framework.Logf("Failed writes: %d", writeFailure)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Not sure what the ratio defining a successful test run should be. At time of writing the
0000000000000000000000000000000000000000;;		// test, failures only seem to happen when a race condition occurs (read/write starts, doesn't
0000000000000000000000000000000000000000;;		// finish before upgrade interferes).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		readRatio := float64(readSuccess) / float64(readSuccess+readFailure)
0000000000000000000000000000000000000000;;		writeRatio := float64(writeSuccess) / float64(writeSuccess+writeFailure)
0000000000000000000000000000000000000000;;		if readRatio < 0.75 {
0000000000000000000000000000000000000000;;			framework.Failf("Too many failures reading data. Success ratio: %f", readRatio)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if writeRatio < 0.75 {
0000000000000000000000000000000000000000;;			framework.Failf("Too many failures writing data. Success ratio: %f", writeRatio)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Teardown performs one final check of the data's availability.
0000000000000000000000000000000000000000;;	func (t *MySqlUpgradeTest) Teardown(f *framework.Framework) {
0000000000000000000000000000000000000000;;		count, err := t.countNames()
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(count >= t.successfulWrites).To(BeTrue())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addName adds a new value to the db.
0000000000000000000000000000000000000000;;	func (t *MySqlUpgradeTest) addName(name string) error {
0000000000000000000000000000000000000000;;		val := map[string][]string{"name": {name}}
0000000000000000000000000000000000000000;;		t.nextWrite++
0000000000000000000000000000000000000000;;		r, err := http.PostForm(fmt.Sprintf("http://%s:8080/addName", t.ip), val)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer r.Body.Close()
0000000000000000000000000000000000000000;;		if r.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			b, err := ioutil.ReadAll(r.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Errorf(string(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// countNames checks to make sure the values in testing.users are available, and returns
0000000000000000000000000000000000000000;;	// the count of them.
0000000000000000000000000000000000000000;;	func (t *MySqlUpgradeTest) countNames() (int, error) {
0000000000000000000000000000000000000000;;		r, err := http.Get(fmt.Sprintf("http://%s:8080/countNames", t.ip))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer r.Body.Close()
0000000000000000000000000000000000000000;;		if r.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			b, err := ioutil.ReadAll(r.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf(string(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var count int
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(r.Body).Decode(&count); err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return count, nil
0000000000000000000000000000000000000000;;	}
