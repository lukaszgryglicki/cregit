0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
ac8d42f5233c42ee4522d60b965eec51432a33b1;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package upgrades
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfigMapUpgradeTest tests that a ConfigMap is available before and after
0000000000000000000000000000000000000000;;	// a cluster upgrade.
0000000000000000000000000000000000000000;;	type ConfigMapUpgradeTest struct {
0000000000000000000000000000000000000000;;		configMap *v1.ConfigMap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ConfigMapUpgradeTest) Name() string { return "configmap-upgrade" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Setup creates a ConfigMap and then verifies that a pod can consume it.
0000000000000000000000000000000000000000;;	func (t *ConfigMapUpgradeTest) Setup(f *framework.Framework) {
0000000000000000000000000000000000000000;;		configMapName := "upgrade-configmap"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := f.Namespace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.configMap = &v1.ConfigMap{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: ns.Name,
0000000000000000000000000000000000000000;;				Name:      configMapName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: map[string]string{
0000000000000000000000000000000000000000;;				"data": "some configmap data",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating a ConfigMap")
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if t.configMap, err = f.ClientSet.Core().ConfigMaps(ns.Name).Create(t.configMap); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("unable to create test ConfigMap %s: %v", t.configMap.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Making sure the ConfigMap is consumable")
0000000000000000000000000000000000000000;;		t.testPod(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test waits for the upgrade to complete, and then verifies that a
0000000000000000000000000000000000000000;;	// pod can still consume the ConfigMap.
0000000000000000000000000000000000000000;;	func (t *ConfigMapUpgradeTest) Test(f *framework.Framework, done <-chan struct{}, upgrade UpgradeType) {
0000000000000000000000000000000000000000;;		<-done
0000000000000000000000000000000000000000;;		By("Consuming the ConfigMap after upgrade")
0000000000000000000000000000000000000000;;		t.testPod(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Teardown cleans up any remaining resources.
0000000000000000000000000000000000000000;;	func (t *ConfigMapUpgradeTest) Teardown(f *framework.Framework) {
0000000000000000000000000000000000000000;;		// rely on the namespace deletion to clean up everything
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testPod creates a pod that consumes a ConfigMap and prints it out. The
0000000000000000000000000000000000000000;;	// output is then verified.
0000000000000000000000000000000000000000;;	func (t *ConfigMapUpgradeTest) testPod(f *framework.Framework) {
0000000000000000000000000000000000000000;;		volumeName := "configmap-volume"
0000000000000000000000000000000000000000;;		volumeMountPath := "/etc/configmap-volume"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "pod-configmap-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				Namespace: t.configMap.ObjectMeta.Namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: volumeName,
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							ConfigMap: &v1.ConfigMapVolumeSource{
0000000000000000000000000000000000000000;;								LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;									Name: t.configMap.ObjectMeta.Name,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "configmap-volume-test",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/mounttest:0.7",
0000000000000000000000000000000000000000;;						Args: []string{
0000000000000000000000000000000000000000;;							fmt.Sprintf("--file_content=%s/data", volumeMountPath),
0000000000000000000000000000000000000000;;							fmt.Sprintf("--file_mode=%s/data", volumeMountPath),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      volumeName,
0000000000000000000000000000000000000000;;								MountPath: volumeMountPath,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:    "configmap-env-test",
0000000000000000000000000000000000000000;;						Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;						Command: []string{"sh", "-c", "env"},
0000000000000000000000000000000000000000;;						Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: "CONFIGMAP_DATA",
0000000000000000000000000000000000000000;;								ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;									ConfigMapKeyRef: &v1.ConfigMapKeySelector{
0000000000000000000000000000000000000000;;										LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;											Name: t.configMap.ObjectMeta.Name,
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;										Key: "data",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedOutput := []string{
0000000000000000000000000000000000000000;;			"content of file \"/etc/configmap-volume/data\": some configmap data",
0000000000000000000000000000000000000000;;			"mode of file \"/etc/configmap-volume/data\": -rw-r--r--",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.TestContainerOutput("volume consume configmap", pod, 0, expectedOutput)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedOutput = []string{"CONFIGMAP_DATA=some configmap data"}
0000000000000000000000000000000000000000;;		f.TestContainerOutput("env consume configmap", pod, 1, expectedOutput)
0000000000000000000000000000000000000000;;	}
