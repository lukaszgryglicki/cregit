0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ca3a89854e7596bb795ae96f88546e2f396e9ab;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		utilversion "k8s.io/kubernetes/pkg/util/version"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/admission/serviceaccount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var serviceAccountTokenNamespaceVersion = utilversion.MustParseSemantic("v1.2.0")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var serviceAccountTokenAutomountVersion = utilversion.MustParseSemantic("v1.6.0-alpha.2")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("ServiceAccounts", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("svcaccounts")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should ensure a single API token exists", func() {
0000000000000000000000000000000000000000;;			// wait for the service account to reference a single secret
0000000000000000000000000000000000000000;;			var secrets []v1.ObjectReference
0000000000000000000000000000000000000000;;			framework.ExpectNoError(wait.Poll(time.Millisecond*500, time.Second*10, func() (bool, error) {
0000000000000000000000000000000000000000;;				By("waiting for a single token reference")
0000000000000000000000000000000000000000;;				sa, err := f.ClientSet.Core().ServiceAccounts(f.Namespace.Name).Get("default", metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					framework.Logf("default service account was not found")
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Logf("error getting default service account: %v", err)
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch len(sa.Secrets) {
0000000000000000000000000000000000000000;;				case 0:
0000000000000000000000000000000000000000;;					framework.Logf("default service account has no secret references")
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				case 1:
0000000000000000000000000000000000000000;;					framework.Logf("default service account has a single secret reference")
0000000000000000000000000000000000000000;;					secrets = sa.Secrets
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("default service account has too many secret references: %#v", sa.Secrets)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// make sure the reference doesn't flutter
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				By("ensuring the single token reference persists")
0000000000000000000000000000000000000000;;				time.Sleep(2 * time.Second)
0000000000000000000000000000000000000000;;				sa, err := f.ClientSet.Core().ServiceAccounts(f.Namespace.Name).Get("default", metav1.GetOptions{})
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;				Expect(sa.Secrets).To(Equal(secrets))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// delete the referenced secret
0000000000000000000000000000000000000000;;			By("deleting the service account token")
0000000000000000000000000000000000000000;;			framework.ExpectNoError(f.ClientSet.Core().Secrets(f.Namespace.Name).Delete(secrets[0].Name, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// wait for the referenced secret to be removed, and another one autocreated
0000000000000000000000000000000000000000;;			framework.ExpectNoError(wait.Poll(time.Millisecond*500, framework.ServiceAccountProvisionTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;				By("waiting for a new token reference")
0000000000000000000000000000000000000000;;				sa, err := f.ClientSet.Core().ServiceAccounts(f.Namespace.Name).Get("default", metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Logf("error getting default service account: %v", err)
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch len(sa.Secrets) {
0000000000000000000000000000000000000000;;				case 0:
0000000000000000000000000000000000000000;;					framework.Logf("default service account has no secret references")
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				case 1:
0000000000000000000000000000000000000000;;					if sa.Secrets[0] == secrets[0] {
0000000000000000000000000000000000000000;;						framework.Logf("default service account still has the deleted secret reference")
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					framework.Logf("default service account has a new single secret reference")
0000000000000000000000000000000000000000;;					secrets = sa.Secrets
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("default service account has too many secret references: %#v", sa.Secrets)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// make sure the reference doesn't flutter
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				By("ensuring the single token reference persists")
0000000000000000000000000000000000000000;;				time.Sleep(2 * time.Second)
0000000000000000000000000000000000000000;;				sa, err := f.ClientSet.Core().ServiceAccounts(f.Namespace.Name).Get("default", metav1.GetOptions{})
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;				Expect(sa.Secrets).To(Equal(secrets))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// delete the reference from the service account
0000000000000000000000000000000000000000;;			By("deleting the reference to the service account token")
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				sa, err := f.ClientSet.Core().ServiceAccounts(f.Namespace.Name).Get("default", metav1.GetOptions{})
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;				sa.Secrets = nil
0000000000000000000000000000000000000000;;				_, updateErr := f.ClientSet.Core().ServiceAccounts(f.Namespace.Name).Update(sa)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(updateErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// wait for another one to be autocreated
0000000000000000000000000000000000000000;;			framework.ExpectNoError(wait.Poll(time.Millisecond*500, framework.ServiceAccountProvisionTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;				By("waiting for a new token to be created and added")
0000000000000000000000000000000000000000;;				sa, err := f.ClientSet.Core().ServiceAccounts(f.Namespace.Name).Get("default", metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Logf("error getting default service account: %v", err)
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch len(sa.Secrets) {
0000000000000000000000000000000000000000;;				case 0:
0000000000000000000000000000000000000000;;					framework.Logf("default service account has no secret references")
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				case 1:
0000000000000000000000000000000000000000;;					framework.Logf("default service account has a new single secret reference")
0000000000000000000000000000000000000000;;					secrets = sa.Secrets
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("default service account has too many secret references: %#v", sa.Secrets)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// make sure the reference doesn't flutter
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				By("ensuring the single token reference persists")
0000000000000000000000000000000000000000;;				time.Sleep(2 * time.Second)
0000000000000000000000000000000000000000;;				sa, err := f.ClientSet.Core().ServiceAccounts(f.Namespace.Name).Get("default", metav1.GetOptions{})
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;				Expect(sa.Secrets).To(Equal(secrets))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should mount an API token into pods [Conformance]", func() {
0000000000000000000000000000000000000000;;			var tokenContent string
0000000000000000000000000000000000000000;;			var rootCAContent string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Standard get, update retry loop
0000000000000000000000000000000000000000;;			framework.ExpectNoError(wait.Poll(time.Millisecond*500, framework.ServiceAccountProvisionTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;				By("getting the auto-created API token")
0000000000000000000000000000000000000000;;				sa, err := f.ClientSet.Core().ServiceAccounts(f.Namespace.Name).Get("default", metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					framework.Logf("default service account was not found")
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Logf("error getting default service account: %v", err)
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(sa.Secrets) == 0 {
0000000000000000000000000000000000000000;;					framework.Logf("default service account has no secret references")
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, secretRef := range sa.Secrets {
0000000000000000000000000000000000000000;;					secret, err := f.ClientSet.Core().Secrets(f.Namespace.Name).Get(secretRef.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						framework.Logf("Error getting secret %s: %v", secretRef.Name, err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if secret.Type == v1.SecretTypeServiceAccountToken {
0000000000000000000000000000000000000000;;						tokenContent = string(secret.Data[v1.ServiceAccountTokenKey])
0000000000000000000000000000000000000000;;						rootCAContent = string(secret.Data[v1.ServiceAccountRootCAKey])
0000000000000000000000000000000000000000;;						return true, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				framework.Logf("default service account has no secret references to valid service account tokens")
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					GenerateName: "pod-service-account-" + string(uuid.NewUUID()) + "-",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "token-test",
0000000000000000000000000000000000000000;;							Image: "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;							Args: []string{
0000000000000000000000000000000000000000;;								fmt.Sprintf("--file_content=%s/%s", serviceaccount.DefaultAPITokenMountPath, v1.ServiceAccountTokenKey),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "root-ca-test",
0000000000000000000000000000000000000000;;							Image: "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;							Args: []string{
0000000000000000000000000000000000000000;;								fmt.Sprintf("--file_content=%s/%s", serviceaccount.DefaultAPITokenMountPath, v1.ServiceAccountRootCAKey),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			supportsTokenNamespace, _ := framework.ServerVersionGTE(serviceAccountTokenNamespaceVersion, f.ClientSet.Discovery())
0000000000000000000000000000000000000000;;			if supportsTokenNamespace {
0000000000000000000000000000000000000000;;				pod.Spec.Containers = append(pod.Spec.Containers, v1.Container{
0000000000000000000000000000000000000000;;					Name:  "namespace-test",
0000000000000000000000000000000000000000;;					Image: "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;					Args: []string{
0000000000000000000000000000000000000000;;						fmt.Sprintf("--file_content=%s/%s", serviceaccount.DefaultAPITokenMountPath, v1.ServiceAccountNamespaceKey),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("consume service account token", pod, 0, []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf(`content of file "%s/%s": %s`, serviceaccount.DefaultAPITokenMountPath, v1.ServiceAccountTokenKey, tokenContent),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			f.TestContainerOutput("consume service account root CA", pod, 1, []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf(`content of file "%s/%s": %s`, serviceaccount.DefaultAPITokenMountPath, v1.ServiceAccountRootCAKey, rootCAContent),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if supportsTokenNamespace {
0000000000000000000000000000000000000000;;				f.TestContainerOutput("consume service account namespace", pod, 2, []string{
0000000000000000000000000000000000000000;;					fmt.Sprintf(`content of file "%s/%s": %s`, serviceaccount.DefaultAPITokenMountPath, v1.ServiceAccountNamespaceKey, f.Namespace.Name),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should allow opting out of API token automount [Conformance]", func() {
0000000000000000000000000000000000000000;;			framework.SkipUnlessServerVersionGTE(serviceAccountTokenAutomountVersion, f.ClientSet.Discovery())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			trueValue := true
0000000000000000000000000000000000000000;;			falseValue := false
0000000000000000000000000000000000000000;;			mountSA := &v1.ServiceAccount{ObjectMeta: metav1.ObjectMeta{Name: "mount"}, AutomountServiceAccountToken: &trueValue}
0000000000000000000000000000000000000000;;			nomountSA := &v1.ServiceAccount{ObjectMeta: metav1.ObjectMeta{Name: "nomount"}, AutomountServiceAccountToken: &falseValue}
0000000000000000000000000000000000000000;;			mountSA, err = f.ClientSet.Core().ServiceAccounts(f.Namespace.Name).Create(mountSA)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			nomountSA, err = f.ClientSet.Core().ServiceAccounts(f.Namespace.Name).Create(nomountSA)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Standard get, update retry loop
0000000000000000000000000000000000000000;;			framework.ExpectNoError(wait.Poll(time.Millisecond*500, framework.ServiceAccountProvisionTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;				By("getting the auto-created API token")
0000000000000000000000000000000000000000;;				sa, err := f.ClientSet.Core().ServiceAccounts(f.Namespace.Name).Get(mountSA.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					framework.Logf("mount service account was not found")
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Logf("error getting mount service account: %v", err)
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(sa.Secrets) == 0 {
0000000000000000000000000000000000000000;;					framework.Logf("mount service account has no secret references")
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, secretRef := range sa.Secrets {
0000000000000000000000000000000000000000;;					secret, err := f.ClientSet.Core().Secrets(f.Namespace.Name).Get(secretRef.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						framework.Logf("Error getting secret %s: %v", secretRef.Name, err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if secret.Type == v1.SecretTypeServiceAccountToken {
0000000000000000000000000000000000000000;;						return true, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				framework.Logf("default service account has no secret references to valid service account tokens")
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			testcases := []struct {
0000000000000000000000000000000000000000;;				PodName            string
0000000000000000000000000000000000000000;;				ServiceAccountName string
0000000000000000000000000000000000000000;;				AutomountPodSpec   *bool
0000000000000000000000000000000000000000;;				ExpectTokenVolume  bool
0000000000000000000000000000000000000000;;			}{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					PodName:            "pod-service-account-defaultsa",
0000000000000000000000000000000000000000;;					ServiceAccountName: "default",
0000000000000000000000000000000000000000;;					AutomountPodSpec:   nil,
0000000000000000000000000000000000000000;;					ExpectTokenVolume:  true, // default is true
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					PodName:            "pod-service-account-mountsa",
0000000000000000000000000000000000000000;;					ServiceAccountName: mountSA.Name,
0000000000000000000000000000000000000000;;					AutomountPodSpec:   nil,
0000000000000000000000000000000000000000;;					ExpectTokenVolume:  true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					PodName:            "pod-service-account-nomountsa",
0000000000000000000000000000000000000000;;					ServiceAccountName: nomountSA.Name,
0000000000000000000000000000000000000000;;					AutomountPodSpec:   nil,
0000000000000000000000000000000000000000;;					ExpectTokenVolume:  false,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Make sure pod spec trumps when opting in
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					PodName:            "pod-service-account-defaultsa-mountspec",
0000000000000000000000000000000000000000;;					ServiceAccountName: "default",
0000000000000000000000000000000000000000;;					AutomountPodSpec:   &trueValue,
0000000000000000000000000000000000000000;;					ExpectTokenVolume:  true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					PodName:            "pod-service-account-mountsa-mountspec",
0000000000000000000000000000000000000000;;					ServiceAccountName: mountSA.Name,
0000000000000000000000000000000000000000;;					AutomountPodSpec:   &trueValue,
0000000000000000000000000000000000000000;;					ExpectTokenVolume:  true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					PodName:            "pod-service-account-nomountsa-mountspec",
0000000000000000000000000000000000000000;;					ServiceAccountName: nomountSA.Name,
0000000000000000000000000000000000000000;;					AutomountPodSpec:   &trueValue,
0000000000000000000000000000000000000000;;					ExpectTokenVolume:  true, // pod spec trumps
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Make sure pod spec trumps when opting out
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					PodName:            "pod-service-account-defaultsa-nomountspec",
0000000000000000000000000000000000000000;;					ServiceAccountName: "default",
0000000000000000000000000000000000000000;;					AutomountPodSpec:   &falseValue,
0000000000000000000000000000000000000000;;					ExpectTokenVolume:  false, // pod spec trumps
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					PodName:            "pod-service-account-mountsa-nomountspec",
0000000000000000000000000000000000000000;;					ServiceAccountName: mountSA.Name,
0000000000000000000000000000000000000000;;					AutomountPodSpec:   &falseValue,
0000000000000000000000000000000000000000;;					ExpectTokenVolume:  false, // pod spec trumps
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					PodName:            "pod-service-account-nomountsa-nomountspec",
0000000000000000000000000000000000000000;;					ServiceAccountName: nomountSA.Name,
0000000000000000000000000000000000000000;;					AutomountPodSpec:   &falseValue,
0000000000000000000000000000000000000000;;					ExpectTokenVolume:  false, // pod spec trumps
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, tc := range testcases {
0000000000000000000000000000000000000000;;				pod := &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: tc.PodName},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers:                   []v1.Container{{Name: "token-test", Image: "gcr.io/google_containers/mounttest:0.7"}},
0000000000000000000000000000000000000000;;						RestartPolicy:                v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;						ServiceAccountName:           tc.ServiceAccountName,
0000000000000000000000000000000000000000;;						AutomountServiceAccountToken: tc.AutomountPodSpec,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				createdPod, err := f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;				framework.Logf("created pod %s", tc.PodName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				hasServiceAccountTokenVolume := false
0000000000000000000000000000000000000000;;				for _, c := range createdPod.Spec.Containers {
0000000000000000000000000000000000000000;;					for _, vm := range c.VolumeMounts {
0000000000000000000000000000000000000000;;						if vm.MountPath == serviceaccount.DefaultAPITokenMountPath {
0000000000000000000000000000000000000000;;							hasServiceAccountTokenVolume = true
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if hasServiceAccountTokenVolume != tc.ExpectTokenVolume {
0000000000000000000000000000000000000000;;					framework.Failf("%s: expected volume=%v, got %v (%#v)", tc.PodName, tc.ExpectTokenVolume, hasServiceAccountTokenVolume, createdPod)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					framework.Logf("pod %s service account token volume mount: %v", tc.PodName, hasServiceAccountTokenVolume)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
