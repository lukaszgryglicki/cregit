0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
7378a0cb38d21d9c5b6304002e679b9e0c9d364d;test/e2e/pod_update.go[test/e2e/pod_update.go][test/e2e/common/pods.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package common
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/websocket"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		buildBackOffDuration = time.Minute
0000000000000000000000000000000000000000;;		syncLoopFrequency    = 10 * time.Second
0000000000000000000000000000000000000000;;		maxBackOffTolerance  = time.Duration(1.3 * float64(kubelet.MaxContainerBackOff))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testHostIP tests that a pod gets a host IP
0000000000000000000000000000000000000000;;	func testHostIP(podClient *framework.PodClient, pod *v1.Pod) {
0000000000000000000000000000000000000000;;		By("creating pod")
0000000000000000000000000000000000000000;;		podClient.CreateSync(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try to make sure we get a hostIP for each pod.
0000000000000000000000000000000000000000;;		hostIPTimeout := 2 * time.Minute
0000000000000000000000000000000000000000;;		t := time.Now()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			p, err := podClient.Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "Failed to get pod %q", pod.Name)
0000000000000000000000000000000000000000;;			if p.Status.HostIP != "" {
0000000000000000000000000000000000000000;;				framework.Logf("Pod %s has hostIP: %s", p.Name, p.Status.HostIP)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if time.Since(t) >= hostIPTimeout {
0000000000000000000000000000000000000000;;				framework.Failf("Gave up waiting for hostIP of pod %s after %v seconds",
0000000000000000000000000000000000000000;;					p.Name, time.Since(t).Seconds())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.Logf("Retrying to get the hostIP of pod %s", p.Name)
0000000000000000000000000000000000000000;;			time.Sleep(5 * time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startPodAndGetBackOffs(podClient *framework.PodClient, pod *v1.Pod, sleepAmount time.Duration) (time.Duration, time.Duration) {
0000000000000000000000000000000000000000;;		podClient.CreateSync(pod)
0000000000000000000000000000000000000000;;		time.Sleep(sleepAmount)
0000000000000000000000000000000000000000;;		Expect(pod.Spec.Containers).NotTo(BeEmpty())
0000000000000000000000000000000000000000;;		podName := pod.Name
0000000000000000000000000000000000000000;;		containerName := pod.Spec.Containers[0].Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("getting restart delay-0")
0000000000000000000000000000000000000000;;		_, err := getRestartDelay(podClient, podName, containerName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("timed out waiting for container restart in pod=%s/%s", podName, containerName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("getting restart delay-1")
0000000000000000000000000000000000000000;;		delay1, err := getRestartDelay(podClient, podName, containerName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("timed out waiting for container restart in pod=%s/%s", podName, containerName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("getting restart delay-2")
0000000000000000000000000000000000000000;;		delay2, err := getRestartDelay(podClient, podName, containerName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("timed out waiting for container restart in pod=%s/%s", podName, containerName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return delay1, delay2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getRestartDelay(podClient *framework.PodClient, podName string, containerName string) (time.Duration, error) {
0000000000000000000000000000000000000000;;		beginTime := time.Now()
0000000000000000000000000000000000000000;;		for time.Since(beginTime) < (2 * maxBackOffTolerance) { // may just miss the 1st MaxContainerBackOff delay
0000000000000000000000000000000000000000;;			time.Sleep(time.Second)
0000000000000000000000000000000000000000;;			pod, err := podClient.Get(podName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err, fmt.Sprintf("getting pod %s", podName))
0000000000000000000000000000000000000000;;			status, ok := podutil.GetContainerStatus(pod.Status.ContainerStatuses, containerName)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				framework.Logf("getRestartDelay: status missing")
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if status.State.Waiting == nil && status.State.Running != nil && status.LastTerminationState.Terminated != nil && status.State.Running.StartedAt.Time.After(beginTime) {
0000000000000000000000000000000000000000;;				startedAt := status.State.Running.StartedAt.Time
0000000000000000000000000000000000000000;;				finishedAt := status.LastTerminationState.Terminated.FinishedAt.Time
0000000000000000000000000000000000000000;;				framework.Logf("getRestartDelay: restartCount = %d, finishedAt=%s restartedAt=%s (%s)", status.RestartCount, finishedAt, startedAt, startedAt.Sub(finishedAt))
0000000000000000000000000000000000000000;;				return startedAt.Sub(finishedAt), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, fmt.Errorf("timeout getting pod restart delay")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Pods", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("pods")
0000000000000000000000000000000000000000;;		var podClient *framework.PodClient
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			podClient = f.PodClient()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should get a host IP [Conformance]", func() {
0000000000000000000000000000000000000000;;			name := "pod-hostip-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			testHostIP(podClient, &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "test",
0000000000000000000000000000000000000000;;							Image: framework.GetPauseImageName(f.ClientSet),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be submitted and removed [Conformance]", func() {
0000000000000000000000000000000000000000;;			By("creating the pod")
0000000000000000000000000000000000000000;;			name := "pod-submit-remove-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			value := strconv.Itoa(time.Now().Nanosecond())
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: name,
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						"name": "foo",
0000000000000000000000000000000000000000;;						"time": value,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "nginx",
0000000000000000000000000000000000000000;;							Image: "gcr.io/google_containers/nginx-slim:0.7",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("setting up watch")
0000000000000000000000000000000000000000;;			selector := labels.SelectorFromSet(labels.Set(map[string]string{"time": value}))
0000000000000000000000000000000000000000;;			options := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;			pods, err := podClient.List(options)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "failed to query for pods")
0000000000000000000000000000000000000000;;			Expect(len(pods.Items)).To(Equal(0))
0000000000000000000000000000000000000000;;			options = metav1.ListOptions{
0000000000000000000000000000000000000000;;				LabelSelector:   selector.String(),
0000000000000000000000000000000000000000;;				ResourceVersion: pods.ListMeta.ResourceVersion,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w, err := podClient.Watch(options)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "failed to set up watch")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("submitting the pod to kubernetes")
0000000000000000000000000000000000000000;;			podClient.Create(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("verifying the pod is in kubernetes")
0000000000000000000000000000000000000000;;			selector = labels.SelectorFromSet(labels.Set(map[string]string{"time": value}))
0000000000000000000000000000000000000000;;			options = metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;			pods, err = podClient.List(options)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "failed to query for pods")
0000000000000000000000000000000000000000;;			Expect(len(pods.Items)).To(Equal(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("verifying pod creation was observed")
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case event, _ := <-w.ResultChan():
0000000000000000000000000000000000000000;;				if event.Type != watch.Added {
0000000000000000000000000000000000000000;;					framework.Failf("Failed to observe pod creation: %v", event)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-time.After(framework.PodStartTimeout):
0000000000000000000000000000000000000000;;				framework.Failf("Timeout while waiting for pod creation")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We need to wait for the pod to be running, otherwise the deletion
0000000000000000000000000000000000000000;;			// may be carried out immediately rather than gracefully.
0000000000000000000000000000000000000000;;			framework.ExpectNoError(f.WaitForPodRunning(pod.Name))
0000000000000000000000000000000000000000;;			// save the running pod
0000000000000000000000000000000000000000;;			pod, err = podClient.Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "failed to GET scheduled pod")
0000000000000000000000000000000000000000;;			framework.Logf("running pod: %#v", pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("deleting the pod gracefully")
0000000000000000000000000000000000000000;;			err = podClient.Delete(pod.Name, metav1.NewDeleteOptions(30))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "failed to delete pod")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("verifying the kubelet observed the termination notice")
0000000000000000000000000000000000000000;;			Expect(wait.Poll(time.Second*5, time.Second*30, func() (bool, error) {
0000000000000000000000000000000000000000;;				podList, err := framework.GetKubeletPods(f.ClientSet, pod.Spec.NodeName)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Logf("Unable to retrieve kubelet pods for node %v: %v", pod.Spec.NodeName, err)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, kubeletPod := range podList.Items {
0000000000000000000000000000000000000000;;					if pod.Name != kubeletPod.Name {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if kubeletPod.ObjectMeta.DeletionTimestamp == nil {
0000000000000000000000000000000000000000;;						framework.Logf("deletion has not yet been observed")
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.Logf("no pod exists with the name we were looking for, assuming the termination request was observed and completed")
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			})).NotTo(HaveOccurred(), "kubelet never observed the termination notice")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("verifying pod deletion was observed")
0000000000000000000000000000000000000000;;			deleted := false
0000000000000000000000000000000000000000;;			var lastPod *v1.Pod
0000000000000000000000000000000000000000;;			timer := time.After(framework.DefaultPodDeletionTimeout)
0000000000000000000000000000000000000000;;			for !deleted {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case event, _ := <-w.ResultChan():
0000000000000000000000000000000000000000;;					switch event.Type {
0000000000000000000000000000000000000000;;					case watch.Deleted:
0000000000000000000000000000000000000000;;						lastPod = event.Object.(*v1.Pod)
0000000000000000000000000000000000000000;;						deleted = true
0000000000000000000000000000000000000000;;					case watch.Error:
0000000000000000000000000000000000000000;;						framework.Logf("received a watch error: %v", event.Object)
0000000000000000000000000000000000000000;;						framework.Failf("watch closed with error")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case <-timer:
0000000000000000000000000000000000000000;;					framework.Failf("timed out waiting for pod deletion")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !deleted {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to observe pod deletion")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Expect(lastPod.DeletionTimestamp).ToNot(BeNil())
0000000000000000000000000000000000000000;;			Expect(lastPod.Spec.TerminationGracePeriodSeconds).ToNot(BeZero())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			selector = labels.SelectorFromSet(labels.Set(map[string]string{"time": value}))
0000000000000000000000000000000000000000;;			options = metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;			pods, err = podClient.List(options)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "failed to query for pods")
0000000000000000000000000000000000000000;;			Expect(len(pods.Items)).To(Equal(0))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be updated [Conformance]", func() {
0000000000000000000000000000000000000000;;			By("creating the pod")
0000000000000000000000000000000000000000;;			name := "pod-update-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			value := strconv.Itoa(time.Now().Nanosecond())
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: name,
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						"name": "foo",
0000000000000000000000000000000000000000;;						"time": value,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "nginx",
0000000000000000000000000000000000000000;;							Image: "gcr.io/google_containers/nginx-slim:0.7",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("submitting the pod to kubernetes")
0000000000000000000000000000000000000000;;			pod = podClient.CreateSync(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("verifying the pod is in kubernetes")
0000000000000000000000000000000000000000;;			selector := labels.SelectorFromSet(labels.Set(map[string]string{"time": value}))
0000000000000000000000000000000000000000;;			options := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;			pods, err := podClient.List(options)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "failed to query for pods")
0000000000000000000000000000000000000000;;			Expect(len(pods.Items)).To(Equal(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("updating the pod")
0000000000000000000000000000000000000000;;			podClient.Update(name, func(pod *v1.Pod) {
0000000000000000000000000000000000000000;;				value = strconv.Itoa(time.Now().Nanosecond())
0000000000000000000000000000000000000000;;				pod.Labels["time"] = value
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			framework.ExpectNoError(f.WaitForPodRunning(pod.Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("verifying the updated pod is in kubernetes")
0000000000000000000000000000000000000000;;			selector = labels.SelectorFromSet(labels.Set(map[string]string{"time": value}))
0000000000000000000000000000000000000000;;			options = metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;			pods, err = podClient.List(options)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "failed to query for pods")
0000000000000000000000000000000000000000;;			Expect(len(pods.Items)).To(Equal(1))
0000000000000000000000000000000000000000;;			framework.Logf("Pod update OK")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should allow activeDeadlineSeconds to be updated [Conformance]", func() {
0000000000000000000000000000000000000000;;			By("creating the pod")
0000000000000000000000000000000000000000;;			name := "pod-update-activedeadlineseconds-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			value := strconv.Itoa(time.Now().Nanosecond())
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: name,
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						"name": "foo",
0000000000000000000000000000000000000000;;						"time": value,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "nginx",
0000000000000000000000000000000000000000;;							Image: "gcr.io/google_containers/nginx-slim:0.7",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("submitting the pod to kubernetes")
0000000000000000000000000000000000000000;;			podClient.CreateSync(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("verifying the pod is in kubernetes")
0000000000000000000000000000000000000000;;			selector := labels.SelectorFromSet(labels.Set(map[string]string{"time": value}))
0000000000000000000000000000000000000000;;			options := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;			pods, err := podClient.List(options)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "failed to query for pods")
0000000000000000000000000000000000000000;;			Expect(len(pods.Items)).To(Equal(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("updating the pod")
0000000000000000000000000000000000000000;;			podClient.Update(name, func(pod *v1.Pod) {
0000000000000000000000000000000000000000;;				newDeadline := int64(5)
0000000000000000000000000000000000000000;;				pod.Spec.ActiveDeadlineSeconds = &newDeadline
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			framework.ExpectNoError(f.WaitForPodTerminated(pod.Name, "DeadlineExceeded"))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should contain environment variables for services [Conformance]", func() {
0000000000000000000000000000000000000000;;			// Make a pod that will be a service.
0000000000000000000000000000000000000000;;			// This pod serves its hostname via HTTP.
0000000000000000000000000000000000000000;;			serverName := "server-envvars-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			serverPod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:   serverName,
0000000000000000000000000000000000000000;;					Labels: map[string]string{"name": serverName},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "srv",
0000000000000000000000000000000000000000;;							Image: framework.ServeHostnameImage,
0000000000000000000000000000000000000000;;							Ports: []v1.ContainerPort{{ContainerPort: 9376}},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podClient.CreateSync(serverPod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// This service exposes port 8080 of the test pod as a service on port 8765
0000000000000000000000000000000000000000;;			// TODO(filbranden): We would like to use a unique service name such as:
0000000000000000000000000000000000000000;;			//   svcName := "svc-envvars-" + randomSuffix()
0000000000000000000000000000000000000000;;			// However, that affects the name of the environment variables which are the capitalized
0000000000000000000000000000000000000000;;			// service name, so that breaks this test.  One possibility is to tweak the variable names
0000000000000000000000000000000000000000;;			// to match the service.  Another is to rethink environment variable names and possibly
0000000000000000000000000000000000000000;;			// allow overriding the prefix in the service manifest.
0000000000000000000000000000000000000000;;			svcName := "fooservice"
0000000000000000000000000000000000000000;;			svc := &v1.Service{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: svcName,
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						"name": svcName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;					Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;						Port:       8765,
0000000000000000000000000000000000000000;;						TargetPort: intstr.FromInt(8080),
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;					Selector: map[string]string{
0000000000000000000000000000000000000000;;						"name": serverName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err := f.ClientSet.Core().Services(f.Namespace.Name).Create(svc)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "failed to create service")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Make a client pod that verifies that it has the service environment variables.
0000000000000000000000000000000000000000;;			podName := "client-envvars-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			const containerName = "env3cont"
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:   podName,
0000000000000000000000000000000000000000;;					Labels: map[string]string{"name": podName},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    containerName,
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;							Command: []string{"sh", "-c", "env"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// It's possible for the Pod to be created before the Kubelet is updated with the new
0000000000000000000000000000000000000000;;			// service. In that case, we just retry.
0000000000000000000000000000000000000000;;			const maxRetries = 3
0000000000000000000000000000000000000000;;			expectedVars := []string{
0000000000000000000000000000000000000000;;				"FOOSERVICE_SERVICE_HOST=",
0000000000000000000000000000000000000000;;				"FOOSERVICE_SERVICE_PORT=",
0000000000000000000000000000000000000000;;				"FOOSERVICE_PORT=",
0000000000000000000000000000000000000000;;				"FOOSERVICE_PORT_8765_TCP_PORT=",
0000000000000000000000000000000000000000;;				"FOOSERVICE_PORT_8765_TCP_PROTO=",
0000000000000000000000000000000000000000;;				"FOOSERVICE_PORT_8765_TCP=",
0000000000000000000000000000000000000000;;				"FOOSERVICE_PORT_8765_TCP_ADDR=",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.ExpectNoErrorWithRetries(func() error {
0000000000000000000000000000000000000000;;				return f.MatchContainerOutput(pod, containerName, expectedVars, ContainSubstring)
0000000000000000000000000000000000000000;;			}, maxRetries, "Container should have service environment variables set")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should support remote command execution over websockets", func() {
0000000000000000000000000000000000000000;;			config, err := framework.LoadConfig()
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "unable to get base config")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("creating the pod")
0000000000000000000000000000000000000000;;			name := "pod-exec-websocket-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    "main",
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;							Command: []string{"/bin/sh", "-c", "echo container is alive; sleep 600"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("submitting the pod to kubernetes")
0000000000000000000000000000000000000000;;			pod = podClient.CreateSync(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			req := f.ClientSet.Core().RESTClient().Get().
0000000000000000000000000000000000000000;;				Namespace(f.Namespace.Name).
0000000000000000000000000000000000000000;;				Resource("pods").
0000000000000000000000000000000000000000;;				Name(pod.Name).
0000000000000000000000000000000000000000;;				Suffix("exec").
0000000000000000000000000000000000000000;;				Param("stderr", "1").
0000000000000000000000000000000000000000;;				Param("stdout", "1").
0000000000000000000000000000000000000000;;				Param("container", pod.Spec.Containers[0].Name).
0000000000000000000000000000000000000000;;				Param("command", "cat").
0000000000000000000000000000000000000000;;				Param("command", "/etc/resolv.conf")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			url := req.URL()
0000000000000000000000000000000000000000;;			ws, err := framework.OpenWebSocketForURL(url, config, []string{"channel.k8s.io"})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to open websocket to %s: %v", url.String(), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer ws.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;			Eventually(func() error {
0000000000000000000000000000000000000000;;				for {
0000000000000000000000000000000000000000;;					var msg []byte
0000000000000000000000000000000000000000;;					if err := websocket.Message.Receive(ws, &msg); err != nil {
0000000000000000000000000000000000000000;;						if err == io.EOF {
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						framework.Failf("Failed to read completely from websocket %s: %v", url.String(), err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if len(msg) == 0 {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if msg[0] != 1 {
0000000000000000000000000000000000000000;;						framework.Failf("Got message from server that didn't start with channel 1 (STDOUT): %v", msg)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					buf.Write(msg[1:])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if buf.Len() == 0 {
0000000000000000000000000000000000000000;;					return fmt.Errorf("Unexpected output from server")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !strings.Contains(buf.String(), "nameserver") {
0000000000000000000000000000000000000000;;					return fmt.Errorf("Expected to find 'nameserver' in %q", buf.String())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}, time.Minute, 10*time.Second).Should(BeNil())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should support retrieving logs from the container over websockets", func() {
0000000000000000000000000000000000000000;;			config, err := framework.LoadConfig()
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "unable to get base config")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("creating the pod")
0000000000000000000000000000000000000000;;			name := "pod-logs-websocket-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    "main",
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;							Command: []string{"/bin/sh", "-c", "echo container is alive; sleep 10000"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("submitting the pod to kubernetes")
0000000000000000000000000000000000000000;;			podClient.CreateSync(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			req := f.ClientSet.Core().RESTClient().Get().
0000000000000000000000000000000000000000;;				Namespace(f.Namespace.Name).
0000000000000000000000000000000000000000;;				Resource("pods").
0000000000000000000000000000000000000000;;				Name(pod.Name).
0000000000000000000000000000000000000000;;				Suffix("log").
0000000000000000000000000000000000000000;;				Param("container", pod.Spec.Containers[0].Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			url := req.URL()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ws, err := framework.OpenWebSocketForURL(url, config, []string{"binary.k8s.io"})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to open websocket to %s: %v", url.String(), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer ws.Close()
0000000000000000000000000000000000000000;;			buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				var msg []byte
0000000000000000000000000000000000000000;;				if err := websocket.Message.Receive(ws, &msg); err != nil {
0000000000000000000000000000000000000000;;					if err == io.EOF {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					framework.Failf("Failed to read completely from websocket %s: %v", url.String(), err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(strings.TrimSpace(string(msg))) == 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				buf.Write(msg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if buf.String() != "container is alive\n" {
0000000000000000000000000000000000000000;;				framework.Failf("Unexpected websocket logs:\n%s", buf.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should have their auto-restart back-off timer reset on image update [Slow]", func() {
0000000000000000000000000000000000000000;;			podName := "pod-back-off-image"
0000000000000000000000000000000000000000;;			containerName := "back-off"
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:   podName,
0000000000000000000000000000000000000000;;					Labels: map[string]string{"test": "back-off-image"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    containerName,
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;							Command: []string{"/bin/sh", "-c", "sleep 5", "/crash/missing"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			delay1, delay2 := startPodAndGetBackOffs(podClient, pod, buildBackOffDuration)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("updating the image")
0000000000000000000000000000000000000000;;			podClient.Update(podName, func(pod *v1.Pod) {
0000000000000000000000000000000000000000;;				pod.Spec.Containers[0].Image = "gcr.io/google_containers/nginx-slim:0.7"
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			time.Sleep(syncLoopFrequency)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(f.WaitForPodRunning(pod.Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("get restart delay after image update")
0000000000000000000000000000000000000000;;			delayAfterUpdate, err := getRestartDelay(podClient, podName, containerName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("timed out waiting for container restart in pod=%s/%s", podName, containerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if delayAfterUpdate > 2*delay2 || delayAfterUpdate > 2*delay1 {
0000000000000000000000000000000000000000;;				framework.Failf("updating image did not reset the back-off value in pod=%s/%s d3=%s d2=%s d1=%s", podName, containerName, delayAfterUpdate, delay1, delay2)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Slow issue #19027 (20 mins)
0000000000000000000000000000000000000000;;		It("should cap back-off at MaxContainerBackOff [Slow]", func() {
0000000000000000000000000000000000000000;;			podName := "back-off-cap"
0000000000000000000000000000000000000000;;			containerName := "back-off-cap"
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:   podName,
0000000000000000000000000000000000000000;;					Labels: map[string]string{"test": "liveness"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    containerName,
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;							Command: []string{"/bin/sh", "-c", "sleep 5", "/crash/missing"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			podClient.CreateSync(pod)
0000000000000000000000000000000000000000;;			time.Sleep(2 * kubelet.MaxContainerBackOff) // it takes slightly more than 2*x to get to a back-off of x
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// wait for a delay == capped delay of MaxContainerBackOff
0000000000000000000000000000000000000000;;			By("geting restart delay when capped")
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				delay1 time.Duration
0000000000000000000000000000000000000000;;				err    error
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			for i := 0; i < 3; i++ {
0000000000000000000000000000000000000000;;				delay1, err = getRestartDelay(podClient, podName, containerName)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("timed out waiting for container restart in pod=%s/%s", podName, containerName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if delay1 < kubelet.MaxContainerBackOff {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if (delay1 < kubelet.MaxContainerBackOff) || (delay1 > maxBackOffTolerance) {
0000000000000000000000000000000000000000;;				framework.Failf("expected %s back-off got=%s in delay1", kubelet.MaxContainerBackOff, delay1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("getting restart delay after a capped delay")
0000000000000000000000000000000000000000;;			delay2, err := getRestartDelay(podClient, podName, containerName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("timed out waiting for container restart in pod=%s/%s", podName, containerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if delay2 < kubelet.MaxContainerBackOff || delay2 > maxBackOffTolerance { // syncloop cumulative drift
0000000000000000000000000000000000000000;;				framework.Failf("expected %s back-off got=%s on delay2", kubelet.MaxContainerBackOff, delay2)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
