0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7c414f8cc84feccc71083d094122d69a5d28cad1;test/e2e/secrets.go[test/e2e/secrets.go][test/e2e/common/secrets.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package common
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Secrets", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("secrets")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			doSecretE2EWithoutMapping(f, nil /* default mode */, "secret-test-"+string(uuid.NewUUID()), nil, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume with defaultMode set [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			defaultMode := int32(0400)
0000000000000000000000000000000000000000;;			doSecretE2EWithoutMapping(f, &defaultMode, "secret-test-"+string(uuid.NewUUID()), nil, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume as non-root with defaultMode and fsGroup set [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			defaultMode := int32(0440) /* setting fsGroup sets mode to at least 440 */
0000000000000000000000000000000000000000;;			fsGroup := int64(1001)
0000000000000000000000000000000000000000;;			uid := int64(1000)
0000000000000000000000000000000000000000;;			doSecretE2EWithoutMapping(f, &defaultMode, "secret-test-"+string(uuid.NewUUID()), &fsGroup, &uid)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume with mappings [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			doSecretE2EWithMapping(f, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume with mappings and Item Mode set [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			mode := int32(0400)
0000000000000000000000000000000000000000;;			doSecretE2EWithMapping(f, &mode)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be able to mount in a volume regardless of a different secret existing with same name in different namespace [sig-storage]", func() {
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				namespace2  *v1.Namespace
0000000000000000000000000000000000000000;;				err         error
0000000000000000000000000000000000000000;;				secret2Name = "secret-test-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if namespace2, err = f.CreateNamespace("secret-namespace", nil); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create new namespace %s: %v", namespace2.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			secret2 := secretForTest(namespace2.Name, secret2Name)
0000000000000000000000000000000000000000;;			secret2.Data = map[string][]byte{
0000000000000000000000000000000000000000;;				"this_should_not_match_content_of_other_secret": []byte("similarly_this_should_not_match_content_of_other_secret\n"),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if secret2, err = f.ClientSet.Core().Secrets(namespace2.Name).Create(secret2); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test secret %s: %v", secret2.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			doSecretE2EWithoutMapping(f, nil /* default mode */, secret2.Name, nil, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable in multiple volumes in a pod [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			// This test ensures that the same secret can be mounted in multiple
0000000000000000000000000000000000000000;;			// volumes in the same pod.  This test case exists to prevent
0000000000000000000000000000000000000000;;			// regressions that break this use-case.
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				name             = "secret-test-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;				volumeName       = "secret-volume"
0000000000000000000000000000000000000000;;				volumeMountPath  = "/etc/secret-volume"
0000000000000000000000000000000000000000;;				volumeName2      = "secret-volume-2"
0000000000000000000000000000000000000000;;				volumeMountPath2 = "/etc/secret-volume-2"
0000000000000000000000000000000000000000;;				secret           = secretForTest(f.Namespace.Name, name)
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating secret with name %s", secret.Name))
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if secret, err = f.ClientSet.Core().Secrets(f.Namespace.Name).Create(secret); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test secret %s: %v", secret.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "pod-secrets-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: volumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								Secret: &v1.SecretVolumeSource{
0000000000000000000000000000000000000000;;									SecretName: name,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: volumeName2,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								Secret: &v1.SecretVolumeSource{
0000000000000000000000000000000000000000;;									SecretName: name,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "secret-volume-test",
0000000000000000000000000000000000000000;;							Image: "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;							Args: []string{
0000000000000000000000000000000000000000;;								"--file_content=/etc/secret-volume/data-1",
0000000000000000000000000000000000000000;;								"--file_mode=/etc/secret-volume/data-1"},
0000000000000000000000000000000000000000;;							VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      volumeName,
0000000000000000000000000000000000000000;;									MountPath: volumeMountPath,
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      volumeName2,
0000000000000000000000000000000000000000;;									MountPath: volumeMountPath2,
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("consume secrets", pod, 0, []string{
0000000000000000000000000000000000000000;;				"content of file \"/etc/secret-volume/data-1\": value-1",
0000000000000000000000000000000000000000;;				"mode of file \"/etc/secret-volume/data-1\": -rw-r--r--",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("optional updates should be reflected in volume [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			podLogTimeout := framework.GetPodSecretUpdateTimeout(f.ClientSet)
0000000000000000000000000000000000000000;;			containerTimeoutArg := fmt.Sprintf("--retry_time=%v", int(podLogTimeout.Seconds()))
0000000000000000000000000000000000000000;;			trueVal := true
0000000000000000000000000000000000000000;;			volumeMountPath := "/etc/secret-volumes"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			deleteName := "s-test-opt-del-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			deleteContainerName := "dels-volume-test"
0000000000000000000000000000000000000000;;			deleteVolumeName := "deletes-volume"
0000000000000000000000000000000000000000;;			deleteSecret := &v1.Secret{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;					Name:      deleteName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Data: map[string][]byte{
0000000000000000000000000000000000000000;;					"data-1": []byte("value-1"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			updateName := "s-test-opt-upd-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			updateContainerName := "upds-volume-test"
0000000000000000000000000000000000000000;;			updateVolumeName := "updates-volume"
0000000000000000000000000000000000000000;;			updateSecret := &v1.Secret{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;					Name:      updateName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Data: map[string][]byte{
0000000000000000000000000000000000000000;;					"data-1": []byte("value-1"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			createName := "s-test-opt-create-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			createContainerName := "creates-volume-test"
0000000000000000000000000000000000000000;;			createVolumeName := "creates-volume"
0000000000000000000000000000000000000000;;			createSecret := &v1.Secret{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;					Name:      createName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Data: map[string][]byte{
0000000000000000000000000000000000000000;;					"data-1": []byte("value-1"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating secret with name %s", deleteSecret.Name))
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if deleteSecret, err = f.ClientSet.Core().Secrets(f.Namespace.Name).Create(deleteSecret); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test secret %s: %v", deleteSecret.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating secret with name %s", updateSecret.Name))
0000000000000000000000000000000000000000;;			if updateSecret, err = f.ClientSet.Core().Secrets(f.Namespace.Name).Create(updateSecret); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test secret %s: %v", updateSecret.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "pod-secrets-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: deleteVolumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								Secret: &v1.SecretVolumeSource{
0000000000000000000000000000000000000000;;									SecretName: deleteName,
0000000000000000000000000000000000000000;;									Optional:   &trueVal,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: updateVolumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								Secret: &v1.SecretVolumeSource{
0000000000000000000000000000000000000000;;									SecretName: updateName,
0000000000000000000000000000000000000000;;									Optional:   &trueVal,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: createVolumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								Secret: &v1.SecretVolumeSource{
0000000000000000000000000000000000000000;;									SecretName: createName,
0000000000000000000000000000000000000000;;									Optional:   &trueVal,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    deleteContainerName,
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;							Command: []string{"/mt", "--break_on_expected_content=false", containerTimeoutArg, "--file_content_in_loop=/etc/secret-volumes/delete/data-1"},
0000000000000000000000000000000000000000;;							VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      deleteVolumeName,
0000000000000000000000000000000000000000;;									MountPath: path.Join(volumeMountPath, "delete"),
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    updateContainerName,
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;							Command: []string{"/mt", "--break_on_expected_content=false", containerTimeoutArg, "--file_content_in_loop=/etc/secret-volumes/update/data-3"},
0000000000000000000000000000000000000000;;							VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      updateVolumeName,
0000000000000000000000000000000000000000;;									MountPath: path.Join(volumeMountPath, "update"),
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    createContainerName,
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;							Command: []string{"/mt", "--break_on_expected_content=false", containerTimeoutArg, "--file_content_in_loop=/etc/secret-volumes/create/data-1"},
0000000000000000000000000000000000000000;;							VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      createVolumeName,
0000000000000000000000000000000000000000;;									MountPath: path.Join(volumeMountPath, "create"),
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("Creating the pod")
0000000000000000000000000000000000000000;;			f.PodClient().CreateSync(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pollCreateLogs := func() (string, error) {
0000000000000000000000000000000000000000;;				return framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, createContainerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Eventually(pollCreateLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("Error reading file /etc/secret-volumes/create/data-1"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pollUpdateLogs := func() (string, error) {
0000000000000000000000000000000000000000;;				return framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, updateContainerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Eventually(pollUpdateLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("Error reading file /etc/secret-volumes/update/data-3"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pollDeleteLogs := func() (string, error) {
0000000000000000000000000000000000000000;;				return framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, deleteContainerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Eventually(pollDeleteLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("value-1"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Deleting secret %v", deleteSecret.Name))
0000000000000000000000000000000000000000;;			err = f.ClientSet.Core().Secrets(f.Namespace.Name).Delete(deleteSecret.Name, &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "Failed to delete secret %q in namespace %q", deleteSecret.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Updating secret %v", updateSecret.Name))
0000000000000000000000000000000000000000;;			updateSecret.ResourceVersion = "" // to force update
0000000000000000000000000000000000000000;;			delete(updateSecret.Data, "data-1")
0000000000000000000000000000000000000000;;			updateSecret.Data["data-3"] = []byte("value-3")
0000000000000000000000000000000000000000;;			_, err = f.ClientSet.Core().Secrets(f.Namespace.Name).Update(updateSecret)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "Failed to update secret %q in namespace %q", updateSecret.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating secret with name %s", createSecret.Name))
0000000000000000000000000000000000000000;;			if createSecret, err = f.ClientSet.Core().Secrets(f.Namespace.Name).Create(createSecret); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test secret %s: %v", createSecret.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("waiting to observe update in volume")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Eventually(pollCreateLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("value-1"))
0000000000000000000000000000000000000000;;			Eventually(pollUpdateLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("value-3"))
0000000000000000000000000000000000000000;;			Eventually(pollDeleteLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("Error reading file /etc/secret-volumes/delete/data-1"))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in env vars [Conformance]", func() {
0000000000000000000000000000000000000000;;			name := "secret-test-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			secret := secretForTest(f.Namespace.Name, name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating secret with name %s", secret.Name))
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if secret, err = f.ClientSet.Core().Secrets(f.Namespace.Name).Create(secret); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test secret %s: %v", secret.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "pod-secrets-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    "secret-env-test",
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;							Command: []string{"sh", "-c", "env"},
0000000000000000000000000000000000000000;;							Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name: "SECRET_DATA",
0000000000000000000000000000000000000000;;									ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;										SecretKeyRef: &v1.SecretKeySelector{
0000000000000000000000000000000000000000;;											LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;												Name: name,
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;											Key: "data-1",
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("consume secrets", pod, 0, []string{
0000000000000000000000000000000000000000;;				"SECRET_DATA=value-1",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable via the environment [Conformance]", func() {
0000000000000000000000000000000000000000;;			name := "secret-test-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			secret := newEnvFromSecret(f.Namespace.Name, name)
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("creating secret %v/%v", f.Namespace.Name, secret.Name))
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if secret, err = f.ClientSet.Core().Secrets(f.Namespace.Name).Create(secret); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test secret %s: %v", secret.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "pod-configmaps-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    "env-test",
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;							Command: []string{"sh", "-c", "env"},
0000000000000000000000000000000000000000;;							EnvFrom: []v1.EnvFromSource{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									SecretRef: &v1.SecretEnvSource{LocalObjectReference: v1.LocalObjectReference{Name: name}},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Prefix:    "p_",
0000000000000000000000000000000000000000;;									SecretRef: &v1.SecretEnvSource{LocalObjectReference: v1.LocalObjectReference{Name: name}},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("consume secrets", pod, 0, []string{
0000000000000000000000000000000000000000;;				"data_1=value-1", "data_2=value-2", "data_3=value-3",
0000000000000000000000000000000000000000;;				"p_data_1=value-1", "p_data_2=value-2", "p_data_3=value-3",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newEnvFromSecret(namespace, name string) *v1.Secret {
0000000000000000000000000000000000000000;;		return &v1.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: map[string][]byte{
0000000000000000000000000000000000000000;;				"data_1": []byte("value-1\n"),
0000000000000000000000000000000000000000;;				"data_2": []byte("value-2\n"),
0000000000000000000000000000000000000000;;				"data_3": []byte("value-3\n"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func secretForTest(namespace, name string) *v1.Secret {
0000000000000000000000000000000000000000;;		return &v1.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: map[string][]byte{
0000000000000000000000000000000000000000;;				"data-1": []byte("value-1\n"),
0000000000000000000000000000000000000000;;				"data-2": []byte("value-2\n"),
0000000000000000000000000000000000000000;;				"data-3": []byte("value-3\n"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doSecretE2EWithoutMapping(f *framework.Framework, defaultMode *int32, secretName string,
0000000000000000000000000000000000000000;;		fsGroup *int64, uid *int64) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			volumeName      = "secret-volume"
0000000000000000000000000000000000000000;;			volumeMountPath = "/etc/secret-volume"
0000000000000000000000000000000000000000;;			secret          = secretForTest(f.Namespace.Name, secretName)
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating secret with name %s", secret.Name))
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if secret, err = f.ClientSet.Core().Secrets(f.Namespace.Name).Create(secret); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("unable to create test secret %s: %v", secret.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "pod-secrets-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: volumeName,
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							Secret: &v1.SecretVolumeSource{
0000000000000000000000000000000000000000;;								SecretName: secretName,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "secret-volume-test",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;						Args: []string{
0000000000000000000000000000000000000000;;							"--file_content=/etc/secret-volume/data-1",
0000000000000000000000000000000000000000;;							"--file_mode=/etc/secret-volume/data-1"},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      volumeName,
0000000000000000000000000000000000000000;;								MountPath: volumeMountPath,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if defaultMode != nil {
0000000000000000000000000000000000000000;;			pod.Spec.Volumes[0].VolumeSource.Secret.DefaultMode = defaultMode
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			mode := int32(0644)
0000000000000000000000000000000000000000;;			defaultMode = &mode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fsGroup != nil || uid != nil {
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext = &v1.PodSecurityContext{
0000000000000000000000000000000000000000;;				FSGroup:   fsGroup,
0000000000000000000000000000000000000000;;				RunAsUser: uid,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		modeString := fmt.Sprintf("%v", os.FileMode(*defaultMode))
0000000000000000000000000000000000000000;;		expectedOutput := []string{
0000000000000000000000000000000000000000;;			"content of file \"/etc/secret-volume/data-1\": value-1",
0000000000000000000000000000000000000000;;			"mode of file \"/etc/secret-volume/data-1\": " + modeString,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.TestContainerOutput("consume secrets", pod, 0, expectedOutput)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doSecretE2EWithMapping(f *framework.Framework, mode *int32) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			name            = "secret-test-map-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			volumeName      = "secret-volume"
0000000000000000000000000000000000000000;;			volumeMountPath = "/etc/secret-volume"
0000000000000000000000000000000000000000;;			secret          = secretForTest(f.Namespace.Name, name)
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating secret with name %s", secret.Name))
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if secret, err = f.ClientSet.Core().Secrets(f.Namespace.Name).Create(secret); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("unable to create test secret %s: %v", secret.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod-secrets-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: volumeName,
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							Secret: &v1.SecretVolumeSource{
0000000000000000000000000000000000000000;;								SecretName: name,
0000000000000000000000000000000000000000;;								Items: []v1.KeyToPath{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Key:  "data-1",
0000000000000000000000000000000000000000;;										Path: "new-path-data-1",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "secret-volume-test",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;						Args: []string{
0000000000000000000000000000000000000000;;							"--file_content=/etc/secret-volume/new-path-data-1",
0000000000000000000000000000000000000000;;							"--file_mode=/etc/secret-volume/new-path-data-1"},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      volumeName,
0000000000000000000000000000000000000000;;								MountPath: volumeMountPath,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mode != nil {
0000000000000000000000000000000000000000;;			pod.Spec.Volumes[0].VolumeSource.Secret.Items[0].Mode = mode
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			defaultItemMode := int32(0644)
0000000000000000000000000000000000000000;;			mode = &defaultItemMode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		modeString := fmt.Sprintf("%v", os.FileMode(*mode))
0000000000000000000000000000000000000000;;		expectedOutput := []string{
0000000000000000000000000000000000000000;;			"content of file \"/etc/secret-volume/new-path-data-1\": value-1",
0000000000000000000000000000000000000000;;			"mode of file \"/etc/secret-volume/new-path-data-1\": " + modeString,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.TestContainerOutput("consume secrets", pod, 0, expectedOutput)
0000000000000000000000000000000000000000;;	}
