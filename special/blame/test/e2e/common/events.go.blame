0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
5c47119888c41072610475ae817c005990cf9012;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package common
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Action func() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns true if a node update matching the predicate was emitted from the
0000000000000000000000000000000000000000;;	// system after performing the supplied action.
0000000000000000000000000000000000000000;;	func ObserveNodeUpdateAfterAction(f *framework.Framework, nodeName string, nodePredicate func(*v1.Node) bool, action Action) (bool, error) {
0000000000000000000000000000000000000000;;		observedMatchingNode := false
0000000000000000000000000000000000000000;;		nodeSelector := fields.OneTermEqualSelector("metadata.name", nodeName)
0000000000000000000000000000000000000000;;		informerStartedChan := make(chan struct{})
0000000000000000000000000000000000000000;;		var informerStartedGuard sync.Once
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, controller := cache.NewInformer(
0000000000000000000000000000000000000000;;			&cache.ListWatch{
0000000000000000000000000000000000000000;;				ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;					options.FieldSelector = nodeSelector.String()
0000000000000000000000000000000000000000;;					ls, err := f.ClientSet.Core().Nodes().List(options)
0000000000000000000000000000000000000000;;					return ls, err
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;					// Signal parent goroutine that watching has begun.
0000000000000000000000000000000000000000;;					defer informerStartedGuard.Do(func() { close(informerStartedChan) })
0000000000000000000000000000000000000000;;					options.FieldSelector = nodeSelector.String()
0000000000000000000000000000000000000000;;					w, err := f.ClientSet.Core().Nodes().Watch(options)
0000000000000000000000000000000000000000;;					return w, err
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&v1.Node{},
0000000000000000000000000000000000000000;;			0,
0000000000000000000000000000000000000000;;			cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;				UpdateFunc: func(oldObj, newObj interface{}) {
0000000000000000000000000000000000000000;;					n, ok := newObj.(*v1.Node)
0000000000000000000000000000000000000000;;					Expect(ok).To(Equal(true))
0000000000000000000000000000000000000000;;					if nodePredicate(n) {
0000000000000000000000000000000000000000;;						observedMatchingNode = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start the informer and block this goroutine waiting for the started signal.
0000000000000000000000000000000000000000;;		informerStopChan := make(chan struct{})
0000000000000000000000000000000000000000;;		defer func() { close(informerStopChan) }()
0000000000000000000000000000000000000000;;		go controller.Run(informerStopChan)
0000000000000000000000000000000000000000;;		<-informerStartedChan
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Invoke the action function.
0000000000000000000000000000000000000000;;		err := action()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Poll whether the informer has found a matching node update with a timeout.
0000000000000000000000000000000000000000;;		// Wait up 2 minutes polling every second.
0000000000000000000000000000000000000000;;		timeout := 2 * time.Minute
0000000000000000000000000000000000000000;;		interval := 1 * time.Second
0000000000000000000000000000000000000000;;		err = wait.Poll(interval, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			return observedMatchingNode, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err == nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns true if an event matching the predicate was emitted from the system
0000000000000000000000000000000000000000;;	// after performing the supplied action.
0000000000000000000000000000000000000000;;	func ObserveEventAfterAction(f *framework.Framework, eventPredicate func(*v1.Event) bool, action Action) (bool, error) {
0000000000000000000000000000000000000000;;		observedMatchingEvent := false
0000000000000000000000000000000000000000;;		informerStartedChan := make(chan struct{})
0000000000000000000000000000000000000000;;		var informerStartedGuard sync.Once
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create an informer to list/watch events from the test framework namespace.
0000000000000000000000000000000000000000;;		_, controller := cache.NewInformer(
0000000000000000000000000000000000000000;;			&cache.ListWatch{
0000000000000000000000000000000000000000;;				ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;					ls, err := f.ClientSet.Core().Events(f.Namespace.Name).List(options)
0000000000000000000000000000000000000000;;					return ls, err
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;					// Signal parent goroutine that watching has begun.
0000000000000000000000000000000000000000;;					defer informerStartedGuard.Do(func() { close(informerStartedChan) })
0000000000000000000000000000000000000000;;					w, err := f.ClientSet.Core().Events(f.Namespace.Name).Watch(options)
0000000000000000000000000000000000000000;;					return w, err
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&v1.Event{},
0000000000000000000000000000000000000000;;			0,
0000000000000000000000000000000000000000;;			cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;				AddFunc: func(obj interface{}) {
0000000000000000000000000000000000000000;;					e, ok := obj.(*v1.Event)
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Considering event: \nType = [%s], Name = [%s], Reason = [%s], Message = [%s]", e.Type, e.Name, e.Reason, e.Message))
0000000000000000000000000000000000000000;;					Expect(ok).To(Equal(true))
0000000000000000000000000000000000000000;;					if ok && eventPredicate(e) {
0000000000000000000000000000000000000000;;						observedMatchingEvent = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start the informer and block this goroutine waiting for the started signal.
0000000000000000000000000000000000000000;;		informerStopChan := make(chan struct{})
0000000000000000000000000000000000000000;;		defer func() { close(informerStopChan) }()
0000000000000000000000000000000000000000;;		go controller.Run(informerStopChan)
0000000000000000000000000000000000000000;;		<-informerStartedChan
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Invoke the action function.
0000000000000000000000000000000000000000;;		err := action()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Poll whether the informer has found a matching event with a timeout.
0000000000000000000000000000000000000000;;		// Wait up 2 minutes polling every second.
0000000000000000000000000000000000000000;;		timeout := 2 * time.Minute
0000000000000000000000000000000000000000;;		interval := 1 * time.Second
0000000000000000000000000000000000000000;;		err = wait.Poll(interval, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			return observedMatchingEvent, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err == nil, err
0000000000000000000000000000000000000000;;	}
