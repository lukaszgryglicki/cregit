0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
bb4d8a2b6c537707a32bcd27a2848b22ce9d2365;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package common
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		api "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/security/apparmor"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		appArmorProfilePrefix = "e2e-apparmor-test-"
0000000000000000000000000000000000000000;;		appArmorAllowedPath   = "/expect_allowed_write"
0000000000000000000000000000000000000000;;		appArmorDeniedPath    = "/expect_permission_denied"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AppArmorDistros are distros with AppArmor support
0000000000000000000000000000000000000000;;	var AppArmorDistros = []string{"gci", "ubuntu"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SkipIfAppArmorNotSupported() {
0000000000000000000000000000000000000000;;		framework.SkipUnlessNodeOSDistroIs(AppArmorDistros...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LoadAppArmorProfiles(f *framework.Framework) {
0000000000000000000000000000000000000000;;		_, err := createAppArmorProfileCM(f)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		_, err = createAppArmorProfileLoader(f)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateAppArmorTestPod creates a pod that tests apparmor profile enforcement. The pod exits with
0000000000000000000000000000000000000000;;	// an error code if the profile is incorrectly enforced. If runOnce is true the pod will exit after
0000000000000000000000000000000000000000;;	// a single test, otherwise it will repeat the test every 1 second until failure.
0000000000000000000000000000000000000000;;	func CreateAppArmorTestPod(f *framework.Framework, runOnce bool) *api.Pod {
0000000000000000000000000000000000000000;;		profile := "localhost/" + appArmorProfilePrefix + f.Namespace.Name
0000000000000000000000000000000000000000;;		testCmd := fmt.Sprintf(`
0000000000000000000000000000000000000000;;	if touch %[1]s; then
0000000000000000000000000000000000000000;;	  echo "FAILURE: write to %[1]s should be denied"
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	elif ! touch %[2]s; then
0000000000000000000000000000000000000000;;	  echo "FAILURE: write to %[2]s should be allowed"
0000000000000000000000000000000000000000;;	  exit 2
0000000000000000000000000000000000000000;;	elif ! grep "%[3]s" /proc/self/attr/current; then
0000000000000000000000000000000000000000;;	  echo "FAILURE: not running with expected profile %[3]s"
0000000000000000000000000000000000000000;;	  echo "found: $(cat /proc/self/attr/current)"
0000000000000000000000000000000000000000;;	  exit 3
0000000000000000000000000000000000000000;;	fi`, appArmorDeniedPath, appArmorAllowedPath, appArmorProfilePrefix+f.Namespace.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !runOnce {
0000000000000000000000000000000000000000;;			testCmd = fmt.Sprintf(`while true; do
0000000000000000000000000000000000000000;;	%s
0000000000000000000000000000000000000000;;	sleep 1
0000000000000000000000000000000000000000;;	done`, testCmd)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				GenerateName: "test-apparmor-",
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					apparmor.ContainerAnnotationKeyPrefix + "test": profile,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"test": "apparmor",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []api.Container{{
0000000000000000000000000000000000000000;;					Name:    "test",
0000000000000000000000000000000000000000;;					Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;					Command: []string{"sh", "-c", testCmd},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				RestartPolicy: api.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if runOnce {
0000000000000000000000000000000000000000;;			pod = f.PodClient().Create(pod)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.WaitForPodSuccessInNamespace(
0000000000000000000000000000000000000000;;				f.ClientSet, pod.Name, f.Namespace.Name))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			pod = f.PodClient().CreateSync(pod)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(f.WaitForPodReady(pod.Name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createAppArmorProfileCM(f *framework.Framework) (*api.ConfigMap, error) {
0000000000000000000000000000000000000000;;		profileName := appArmorProfilePrefix + f.Namespace.Name
0000000000000000000000000000000000000000;;		profile := fmt.Sprintf(`#include <tunables/global>
0000000000000000000000000000000000000000;;	profile %s flags=(attach_disconnected) {
0000000000000000000000000000000000000000;;	  #include <abstractions/base>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  file,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  deny %s w,
0000000000000000000000000000000000000000;;	  audit %s w,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`, profileName, appArmorDeniedPath, appArmorAllowedPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cm := &api.ConfigMap{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "apparmor-profiles",
0000000000000000000000000000000000000000;;				Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: map[string]string{
0000000000000000000000000000000000000000;;				profileName: profile,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Create(cm)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createAppArmorProfileLoader(f *framework.Framework) (*extensions.DaemonSet, error) {
0000000000000000000000000000000000000000;;		True := true
0000000000000000000000000000000000000000;;		// Copied from https://github.com/kubernetes/contrib/blob/master/apparmor/loader/example-configmap.yaml
0000000000000000000000000000000000000000;;		loader := &extensions.DaemonSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "apparmor-loader",
0000000000000000000000000000000000000000;;				Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.DaemonSetSpec{
0000000000000000000000000000000000000000;;				Template: api.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"name": "apparmor-loader"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: api.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []api.Container{{
0000000000000000000000000000000000000000;;							Name:  "apparmor-loader",
0000000000000000000000000000000000000000;;							Image: "gcr.io/google_containers/apparmor-loader:0.1",
0000000000000000000000000000000000000000;;							Args:  []string{"-poll", "10s", "/profiles"},
0000000000000000000000000000000000000000;;							SecurityContext: &api.SecurityContext{
0000000000000000000000000000000000000000;;								Privileged: &True,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							VolumeMounts: []api.VolumeMount{{
0000000000000000000000000000000000000000;;								Name:      "sys",
0000000000000000000000000000000000000000;;								MountPath: "/sys",
0000000000000000000000000000000000000000;;								ReadOnly:  true,
0000000000000000000000000000000000000000;;							}, {
0000000000000000000000000000000000000000;;								Name:      "apparmor-includes",
0000000000000000000000000000000000000000;;								MountPath: "/etc/apparmor.d",
0000000000000000000000000000000000000000;;								ReadOnly:  true,
0000000000000000000000000000000000000000;;							}, {
0000000000000000000000000000000000000000;;								Name:      "profiles",
0000000000000000000000000000000000000000;;								MountPath: "/profiles",
0000000000000000000000000000000000000000;;								ReadOnly:  true,
0000000000000000000000000000000000000000;;							}},
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;						Volumes: []api.Volume{{
0000000000000000000000000000000000000000;;							Name: "sys",
0000000000000000000000000000000000000000;;							VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;								HostPath: &api.HostPathVolumeSource{
0000000000000000000000000000000000000000;;									Path: "/sys",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						}, {
0000000000000000000000000000000000000000;;							Name: "apparmor-includes",
0000000000000000000000000000000000000000;;							VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;								HostPath: &api.HostPathVolumeSource{
0000000000000000000000000000000000000000;;									Path: "/etc/apparmor.d",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						}, {
0000000000000000000000000000000000000000;;							Name: "profiles",
0000000000000000000000000000000000000000;;							VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;								ConfigMap: &api.ConfigMapVolumeSource{
0000000000000000000000000000000000000000;;									LocalObjectReference: api.LocalObjectReference{
0000000000000000000000000000000000000000;;										Name: "apparmor-profiles",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.ClientSet.Extensions().DaemonSets(f.Namespace.Name).Create(loader)
0000000000000000000000000000000000000000;;	}
