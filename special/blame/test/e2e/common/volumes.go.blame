0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
93c294fdc408203b43e49cc55f140f3881b15a18;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * This test checks that various VolumeSources are working.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * There are two ways, how to test the volumes:
0000000000000000000000000000000000000000;;	 * 1) With containerized server (NFS, Ceph, Gluster, iSCSI, ...)
0000000000000000000000000000000000000000;;	 * The test creates a server pod, exporting simple 'index.html' file.
0000000000000000000000000000000000000000;;	 * Then it uses appropriate VolumeSource to import this file into a client pod
0000000000000000000000000000000000000000;;	 * and checks that the pod can see the file. It does so by importing the file
0000000000000000000000000000000000000000;;	 * into web server root and loadind the index.html from it.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * These tests work only when privileged containers are allowed, exporting
0000000000000000000000000000000000000000;;	 * various filesystems (NFS, GlusterFS, ...) usually needs some mounting or
0000000000000000000000000000000000000000;;	 * other privileged magic in the server pod.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Note that the server containers are for testing purposes only and should not
0000000000000000000000000000000000000000;;	 * be used in production.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * 2) With server outside of Kubernetes (Cinder, ...)
0000000000000000000000000000000000000000;;	 * Appropriate server (e.g. OpenStack Cinder) must exist somewhere outside
0000000000000000000000000000000000000000;;	 * the tested Kubernetes cluster. The test itself creates a new volume,
0000000000000000000000000000000000000000;;	 * and checks, that Kubernetes can use it as a volume.
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GlusterFS test is duplicated from test/e2e/volumes.go.  Any changes made there
0000000000000000000000000000000000000000;;	// should be duplicated here
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package common
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These tests need privileged containers, which are disabled by default.  Run
0000000000000000000000000000000000000000;;	// the test with "go run hack/e2e.go ... --ginkgo.focus=[Feature:Volumes]"
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("GCP Volumes", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("gcp-volume")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If 'false', the test won't clear its volumes upon completion. Useful for debugging,
0000000000000000000000000000000000000000;;		// note that namespace deletion is handled by delete-namespace flag
0000000000000000000000000000000000000000;;		clean := true
0000000000000000000000000000000000000000;;		// filled in BeforeEach
0000000000000000000000000000000000000000;;		var namespace *v1.Namespace
0000000000000000000000000000000000000000;;		var c clientset.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			framework.SkipUnlessNodeOSDistroIs("gci")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			namespace = f.Namespace
0000000000000000000000000000000000000000;;			c = f.ClientSet
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;		// NFS
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("NFSv4", func() {
0000000000000000000000000000000000000000;;			It("should be mountable for NFSv4 [sig-storage]", func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				config := framework.VolumeTestConfig{
0000000000000000000000000000000000000000;;					Namespace:   namespace.Name,
0000000000000000000000000000000000000000;;					Prefix:      "nfs",
0000000000000000000000000000000000000000;;					ServerImage: framework.NfsServerImage,
0000000000000000000000000000000000000000;;					ServerPorts: []int{2049},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					if clean {
0000000000000000000000000000000000000000;;						framework.VolumeTestCleanup(f, config)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				pod := framework.StartVolumeServer(c, config)
0000000000000000000000000000000000000000;;				serverIP := pod.Status.PodIP
0000000000000000000000000000000000000000;;				framework.Logf("NFS server IP address: %v", serverIP)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				tests := []framework.VolumeTest{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Volume: v1.VolumeSource{
0000000000000000000000000000000000000000;;							NFS: &v1.NFSVolumeSource{
0000000000000000000000000000000000000000;;								Server:   serverIP,
0000000000000000000000000000000000000000;;								Path:     "/",
0000000000000000000000000000000000000000;;								ReadOnly: true,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						File:            "index.html",
0000000000000000000000000000000000000000;;						ExpectedContent: "Hello from NFS!",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Must match content of test/images/volumes-tester/nfs/index.html
0000000000000000000000000000000000000000;;				framework.TestVolumeClient(c, config, nil, tests)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("NFSv3", func() {
0000000000000000000000000000000000000000;;			It("should be mountable for NFSv3 [sig-storage]", func() {
0000000000000000000000000000000000000000;;				config := framework.VolumeTestConfig{
0000000000000000000000000000000000000000;;					Namespace:   namespace.Name,
0000000000000000000000000000000000000000;;					Prefix:      "nfs",
0000000000000000000000000000000000000000;;					ServerImage: framework.NfsServerImage,
0000000000000000000000000000000000000000;;					ServerPorts: []int{2049},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					if clean {
0000000000000000000000000000000000000000;;						framework.VolumeTestCleanup(f, config)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;				pod := framework.StartVolumeServer(c, config)
0000000000000000000000000000000000000000;;				serverIP := pod.Status.PodIP
0000000000000000000000000000000000000000;;				framework.Logf("NFS server IP address: %v", serverIP)
0000000000000000000000000000000000000000;;				tests := []framework.VolumeTest{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Volume: v1.VolumeSource{
0000000000000000000000000000000000000000;;							NFS: &v1.NFSVolumeSource{
0000000000000000000000000000000000000000;;								Server:   serverIP,
0000000000000000000000000000000000000000;;								Path:     "/exports",
0000000000000000000000000000000000000000;;								ReadOnly: true,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						File:            "index.html",
0000000000000000000000000000000000000000;;						ExpectedContent: "Hello from NFS!",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Must match content of test/images/volume-tester/nfs/index.html
0000000000000000000000000000000000000000;;				framework.TestVolumeClient(c, config, nil, tests)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;		// Gluster
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("GlusterFS", func() {
0000000000000000000000000000000000000000;;			It("should be mountable [sig-storage]", func() {
0000000000000000000000000000000000000000;;				config := framework.VolumeTestConfig{
0000000000000000000000000000000000000000;;					Namespace:   namespace.Name,
0000000000000000000000000000000000000000;;					Prefix:      "gluster",
0000000000000000000000000000000000000000;;					ServerImage: framework.GlusterfsServerImage,
0000000000000000000000000000000000000000;;					ServerPorts: []int{24007, 24008, 49152},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					if clean {
0000000000000000000000000000000000000000;;						framework.VolumeTestCleanup(f, config)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				pod := framework.StartVolumeServer(c, config)
0000000000000000000000000000000000000000;;				serverIP := pod.Status.PodIP
0000000000000000000000000000000000000000;;				framework.Logf("Gluster server IP address: %v", serverIP)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// create Endpoints for the server
0000000000000000000000000000000000000000;;				endpoints := v1.Endpoints{
0000000000000000000000000000000000000000;;					TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;						Kind:       "Endpoints",
0000000000000000000000000000000000000000;;						APIVersion: "v1",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: config.Prefix + "-server",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Subsets: []v1.EndpointSubset{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Addresses: []v1.EndpointAddress{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									IP: serverIP,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Ports: []v1.EndpointPort{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:     "gluster",
0000000000000000000000000000000000000000;;									Port:     24007,
0000000000000000000000000000000000000000;;									Protocol: v1.ProtocolTCP,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				endClient := f.ClientSet.CoreV1().Endpoints(config.Namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					if clean {
0000000000000000000000000000000000000000;;						endClient.Delete(config.Prefix+"-server", nil)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if _, err := endClient.Create(&endpoints); err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed to create endpoints for Gluster server: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				tests := []framework.VolumeTest{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Volume: v1.VolumeSource{
0000000000000000000000000000000000000000;;							Glusterfs: &v1.GlusterfsVolumeSource{
0000000000000000000000000000000000000000;;								EndpointsName: config.Prefix + "-server",
0000000000000000000000000000000000000000;;								// 'test_vol' comes from test/images/volumes-tester/gluster/run_gluster.sh
0000000000000000000000000000000000000000;;								Path:     "test_vol",
0000000000000000000000000000000000000000;;								ReadOnly: true,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						File: "index.html",
0000000000000000000000000000000000000000;;						// Must match content of test/images/volumes-tester/gluster/index.html
0000000000000000000000000000000000000000;;						ExpectedContent: "Hello from GlusterFS!",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.TestVolumeClient(c, config, nil, tests)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
