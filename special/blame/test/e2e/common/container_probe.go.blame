0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
e5a2b2f3537019e2df07e247df66c5de1241003f;test/e2e/container_probe.go[test/e2e/container_probe.go][test/e2e/common/container_probe.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package common
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		testutils "k8s.io/kubernetes/test/utils"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		probTestContainerName       = "test-webserver"
0000000000000000000000000000000000000000;;		probTestInitialDelaySeconds = 15
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaultObservationTimeout = time.Minute * 2
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Probing container", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("container-probe")
0000000000000000000000000000000000000000;;		var podClient *framework.PodClient
0000000000000000000000000000000000000000;;		probe := webserverProbeBuilder{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			podClient = f.PodClient()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("with readiness probe should not be ready before initial delay and never restart [Conformance]", func() {
0000000000000000000000000000000000000000;;			p := podClient.Create(makePodSpec(probe.withInitialDelay().build(), nil))
0000000000000000000000000000000000000000;;			f.WaitForPodReady(p.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			p, err := podClient.Get(p.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			isReady, err := testutils.PodRunningReady(p)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			Expect(isReady).To(BeTrue(), "pod should be ready")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We assume the pod became ready when the container became ready. This
0000000000000000000000000000000000000000;;			// is true for a single container pod.
0000000000000000000000000000000000000000;;			readyTime, err := getTransitionTimeForReadyCondition(p)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			startedTime, err := getContainerStartedTime(p, probTestContainerName)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			framework.Logf("Container started at %v, pod became ready at %v", startedTime, readyTime)
0000000000000000000000000000000000000000;;			initialDelay := probTestInitialDelaySeconds * time.Second
0000000000000000000000000000000000000000;;			if readyTime.Sub(startedTime) < initialDelay {
0000000000000000000000000000000000000000;;				framework.Failf("Pod became ready before it's %v initial delay", initialDelay)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			restartCount := getRestartCount(p)
0000000000000000000000000000000000000000;;			Expect(restartCount == 0).To(BeTrue(), "pod should have a restart count of 0 but got %v", restartCount)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("with readiness probe that fails should never be ready and never restart [Conformance]", func() {
0000000000000000000000000000000000000000;;			p := podClient.Create(makePodSpec(probe.withFailing().build(), nil))
0000000000000000000000000000000000000000;;			Consistently(func() (bool, error) {
0000000000000000000000000000000000000000;;				p, err := podClient.Get(p.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return podutil.IsPodReady(p), nil
0000000000000000000000000000000000000000;;			}, 1*time.Minute, 1*time.Second).ShouldNot(BeTrue(), "pod should not be ready")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			p, err := podClient.Get(p.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			isReady, err := testutils.PodRunningReady(p)
0000000000000000000000000000000000000000;;			Expect(isReady).NotTo(BeTrue(), "pod should be not ready")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			restartCount := getRestartCount(p)
0000000000000000000000000000000000000000;;			Expect(restartCount == 0).To(BeTrue(), "pod should have a restart count of 0 but got %v", restartCount)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be restarted with a exec \"cat /tmp/health\" liveness probe [Conformance]", func() {
0000000000000000000000000000000000000000;;			runLivenessTest(f, &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:   "liveness-exec",
0000000000000000000000000000000000000000;;					Labels: map[string]string{"test": "liveness"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    "liveness",
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;							Command: []string{"/bin/sh", "-c", "echo ok >/tmp/health; sleep 10; rm -rf /tmp/health; sleep 600"},
0000000000000000000000000000000000000000;;							LivenessProbe: &v1.Probe{
0000000000000000000000000000000000000000;;								Handler: v1.Handler{
0000000000000000000000000000000000000000;;									Exec: &v1.ExecAction{
0000000000000000000000000000000000000000;;										Command: []string{"cat", "/tmp/health"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								InitialDelaySeconds: 15,
0000000000000000000000000000000000000000;;								FailureThreshold:    1,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}, 1, defaultObservationTimeout)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [Conformance]", func() {
0000000000000000000000000000000000000000;;			runLivenessTest(f, &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:   "liveness-exec",
0000000000000000000000000000000000000000;;					Labels: map[string]string{"test": "liveness"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    "liveness",
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;							Command: []string{"/bin/sh", "-c", "echo ok >/tmp/health; sleep 600"},
0000000000000000000000000000000000000000;;							LivenessProbe: &v1.Probe{
0000000000000000000000000000000000000000;;								Handler: v1.Handler{
0000000000000000000000000000000000000000;;									Exec: &v1.ExecAction{
0000000000000000000000000000000000000000;;										Command: []string{"cat", "/tmp/health"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								InitialDelaySeconds: 15,
0000000000000000000000000000000000000000;;								FailureThreshold:    1,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}, 0, defaultObservationTimeout)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be restarted with a /healthz http liveness probe [Conformance]", func() {
0000000000000000000000000000000000000000;;			runLivenessTest(f, &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:   "liveness-http",
0000000000000000000000000000000000000000;;					Labels: map[string]string{"test": "liveness"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    "liveness",
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/liveness:e2e",
0000000000000000000000000000000000000000;;							Command: []string{"/server"},
0000000000000000000000000000000000000000;;							LivenessProbe: &v1.Probe{
0000000000000000000000000000000000000000;;								Handler: v1.Handler{
0000000000000000000000000000000000000000;;									HTTPGet: &v1.HTTPGetAction{
0000000000000000000000000000000000000000;;										Path: "/healthz",
0000000000000000000000000000000000000000;;										Port: intstr.FromInt(8080),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								InitialDelaySeconds: 15,
0000000000000000000000000000000000000000;;								FailureThreshold:    1,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}, 1, defaultObservationTimeout)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Slow by design (5 min)
0000000000000000000000000000000000000000;;		It("should have monotonically increasing restart count [Conformance] [Slow]", func() {
0000000000000000000000000000000000000000;;			runLivenessTest(f, &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:   "liveness-http",
0000000000000000000000000000000000000000;;					Labels: map[string]string{"test": "liveness"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    "liveness",
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/liveness:e2e",
0000000000000000000000000000000000000000;;							Command: []string{"/server"},
0000000000000000000000000000000000000000;;							LivenessProbe: &v1.Probe{
0000000000000000000000000000000000000000;;								Handler: v1.Handler{
0000000000000000000000000000000000000000;;									HTTPGet: &v1.HTTPGetAction{
0000000000000000000000000000000000000000;;										Path: "/healthz",
0000000000000000000000000000000000000000;;										Port: intstr.FromInt(8080),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								InitialDelaySeconds: 5,
0000000000000000000000000000000000000000;;								FailureThreshold:    1,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}, 5, time.Minute*5)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should *not* be restarted with a /healthz http liveness probe [Conformance]", func() {
0000000000000000000000000000000000000000;;			runLivenessTest(f, &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:   "liveness-http",
0000000000000000000000000000000000000000;;					Labels: map[string]string{"test": "liveness"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "liveness",
0000000000000000000000000000000000000000;;							Image: "gcr.io/google_containers/nginx-slim:0.7",
0000000000000000000000000000000000000000;;							Ports: []v1.ContainerPort{{ContainerPort: 80}},
0000000000000000000000000000000000000000;;							LivenessProbe: &v1.Probe{
0000000000000000000000000000000000000000;;								Handler: v1.Handler{
0000000000000000000000000000000000000000;;									HTTPGet: &v1.HTTPGetAction{
0000000000000000000000000000000000000000;;										Path: "/",
0000000000000000000000000000000000000000;;										Port: intstr.FromInt(80),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								InitialDelaySeconds: 15,
0000000000000000000000000000000000000000;;								TimeoutSeconds:      5,
0000000000000000000000000000000000000000;;								FailureThreshold:    1,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}, 0, defaultObservationTimeout)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be restarted with a docker exec liveness probe with timeout [Conformance]", func() {
0000000000000000000000000000000000000000;;			// TODO: enable this test once the default exec handler supports timeout.
0000000000000000000000000000000000000000;;			framework.Skipf("The default exec handler, dockertools.NativeExecHandler, does not support timeouts due to a limitation in the Docker Remote API")
0000000000000000000000000000000000000000;;			runLivenessTest(f, &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:   "liveness-exec",
0000000000000000000000000000000000000000;;					Labels: map[string]string{"test": "liveness"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    "liveness",
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;							Command: []string{"/bin/sh", "-c", "sleep 600"},
0000000000000000000000000000000000000000;;							LivenessProbe: &v1.Probe{
0000000000000000000000000000000000000000;;								Handler: v1.Handler{
0000000000000000000000000000000000000000;;									Exec: &v1.ExecAction{
0000000000000000000000000000000000000000;;										Command: []string{"/bin/sh", "-c", "sleep 10"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								InitialDelaySeconds: 15,
0000000000000000000000000000000000000000;;								TimeoutSeconds:      1,
0000000000000000000000000000000000000000;;								FailureThreshold:    1,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}, 1, defaultObservationTimeout)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getContainerStartedTime(p *v1.Pod, containerName string) (time.Time, error) {
0000000000000000000000000000000000000000;;		for _, status := range p.Status.ContainerStatuses {
0000000000000000000000000000000000000000;;			if status.Name != containerName {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if status.State.Running == nil {
0000000000000000000000000000000000000000;;				return time.Time{}, fmt.Errorf("Container is not running")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return status.State.Running.StartedAt.Time, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return time.Time{}, fmt.Errorf("cannot find container named %q", containerName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTransitionTimeForReadyCondition(p *v1.Pod) (time.Time, error) {
0000000000000000000000000000000000000000;;		for _, cond := range p.Status.Conditions {
0000000000000000000000000000000000000000;;			if cond.Type == v1.PodReady {
0000000000000000000000000000000000000000;;				return cond.LastTransitionTime.Time, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return time.Time{}, fmt.Errorf("No ready condition can be found for pod")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getRestartCount(p *v1.Pod) int {
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		for _, containerStatus := range p.Status.ContainerStatuses {
0000000000000000000000000000000000000000;;			count += int(containerStatus.RestartCount)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return count
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makePodSpec(readinessProbe, livenessProbe *v1.Probe) *v1.Pod {
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "test-webserver-" + string(uuid.NewUUID())},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:           probTestContainerName,
0000000000000000000000000000000000000000;;						Image:          "gcr.io/google_containers/test-webserver:e2e",
0000000000000000000000000000000000000000;;						LivenessProbe:  livenessProbe,
0000000000000000000000000000000000000000;;						ReadinessProbe: readinessProbe,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type webserverProbeBuilder struct {
0000000000000000000000000000000000000000;;		failing      bool
0000000000000000000000000000000000000000;;		initialDelay bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b webserverProbeBuilder) withFailing() webserverProbeBuilder {
0000000000000000000000000000000000000000;;		b.failing = true
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b webserverProbeBuilder) withInitialDelay() webserverProbeBuilder {
0000000000000000000000000000000000000000;;		b.initialDelay = true
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b webserverProbeBuilder) build() *v1.Probe {
0000000000000000000000000000000000000000;;		probe := &v1.Probe{
0000000000000000000000000000000000000000;;			Handler: v1.Handler{
0000000000000000000000000000000000000000;;				HTTPGet: &v1.HTTPGetAction{
0000000000000000000000000000000000000000;;					Port: intstr.FromInt(80),
0000000000000000000000000000000000000000;;					Path: "/",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b.initialDelay {
0000000000000000000000000000000000000000;;			probe.InitialDelaySeconds = probTestInitialDelaySeconds
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b.failing {
0000000000000000000000000000000000000000;;			probe.HTTPGet.Port = intstr.FromInt(81)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return probe
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func runLivenessTest(f *framework.Framework, pod *v1.Pod, expectNumRestarts int, timeout time.Duration) {
0000000000000000000000000000000000000000;;		podClient := f.PodClient()
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;		Expect(pod.Spec.Containers).NotTo(BeEmpty())
0000000000000000000000000000000000000000;;		containerName := pod.Spec.Containers[0].Name
0000000000000000000000000000000000000000;;		// At the end of the test, clean up by removing the pod.
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			By("deleting the pod")
0000000000000000000000000000000000000000;;			podClient.Delete(pod.Name, metav1.NewDeleteOptions(0))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating pod %s in namespace %s", pod.Name, ns))
0000000000000000000000000000000000000000;;		podClient.Create(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait until the pod is not pending. (Here we need to check for something other than
0000000000000000000000000000000000000000;;		// 'Pending' other than checking for 'Running', since when failures occur, we go to
0000000000000000000000000000000000000000;;		// 'Terminated' which can cause indefinite blocking.)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.WaitForPodNotPending(f.ClientSet, ns, pod.Name),
0000000000000000000000000000000000000000;;			fmt.Sprintf("starting pod %s in namespace %s", pod.Name, ns))
0000000000000000000000000000000000000000;;		framework.Logf("Started pod %s in namespace %s", pod.Name, ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check the pod's current state and verify that restartCount is present.
0000000000000000000000000000000000000000;;		By("checking the pod's current state and verifying that restartCount is present")
0000000000000000000000000000000000000000;;		pod, err := podClient.Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, fmt.Sprintf("getting pod %s in namespace %s", pod.Name, ns))
0000000000000000000000000000000000000000;;		initialRestartCount := podutil.GetExistingContainerStatus(pod.Status.ContainerStatuses, containerName).RestartCount
0000000000000000000000000000000000000000;;		framework.Logf("Initial restart count of pod %s is %d", pod.Name, initialRestartCount)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for the restart state to be as desired.
0000000000000000000000000000000000000000;;		deadline := time.Now().Add(timeout)
0000000000000000000000000000000000000000;;		lastRestartCount := initialRestartCount
0000000000000000000000000000000000000000;;		observedRestarts := int32(0)
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Now().Before(deadline); time.Sleep(2 * time.Second) {
0000000000000000000000000000000000000000;;			pod, err = podClient.Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err, fmt.Sprintf("getting pod %s", pod.Name))
0000000000000000000000000000000000000000;;			restartCount := podutil.GetExistingContainerStatus(pod.Status.ContainerStatuses, containerName).RestartCount
0000000000000000000000000000000000000000;;			if restartCount != lastRestartCount {
0000000000000000000000000000000000000000;;				framework.Logf("Restart count of pod %s/%s is now %d (%v elapsed)",
0000000000000000000000000000000000000000;;					ns, pod.Name, restartCount, time.Since(start))
0000000000000000000000000000000000000000;;				if restartCount < lastRestartCount {
0000000000000000000000000000000000000000;;					framework.Failf("Restart count should increment monotonically: restart cont of pod %s/%s changed from %d to %d",
0000000000000000000000000000000000000000;;						ns, pod.Name, lastRestartCount, restartCount)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			observedRestarts = restartCount - initialRestartCount
0000000000000000000000000000000000000000;;			if expectNumRestarts > 0 && int(observedRestarts) >= expectNumRestarts {
0000000000000000000000000000000000000000;;				// Stop if we have observed more than expectNumRestarts restarts.
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lastRestartCount = restartCount
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we expected 0 restarts, fail if observed any restart.
0000000000000000000000000000000000000000;;		// If we expected n restarts (n > 0), fail if we observed < n restarts.
0000000000000000000000000000000000000000;;		if (expectNumRestarts == 0 && observedRestarts > 0) || (expectNumRestarts > 0 &&
0000000000000000000000000000000000000000;;			int(observedRestarts) < expectNumRestarts) {
0000000000000000000000000000000000000000;;			framework.Failf("pod %s/%s - expected number of restarts: %d, found restarts: %d",
0000000000000000000000000000000000000000;;				ns, pod.Name, expectNumRestarts, observedRestarts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
