0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6a34a68f43fd4aa9bb569913cb4f5012e1ccb700;test/e2e/configmap.go[test/e2e/configmap.go][test/e2e/common/configmap.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package common
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("ConfigMap", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("configmap")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			doConfigMapE2EWithoutMappings(f, 0, 0, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume with defaultMode set [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			defaultMode := int32(0400)
0000000000000000000000000000000000000000;;			doConfigMapE2EWithoutMappings(f, 0, 0, &defaultMode)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume as non-root with defaultMode and fsGroup set [Feature:FSGroup] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			defaultMode := int32(0440) /* setting fsGroup sets mode to at least 440 */
0000000000000000000000000000000000000000;;			doConfigMapE2EWithoutMappings(f, 1000, 1001, &defaultMode)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume as non-root [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			doConfigMapE2EWithoutMappings(f, 1000, 0, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume as non-root with FSGroup [Feature:FSGroup] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			doConfigMapE2EWithoutMappings(f, 1000, 1001, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume with mappings [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			doConfigMapE2EWithMappings(f, 0, 0, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume with mappings and Item mode set[Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			mode := int32(0400)
0000000000000000000000000000000000000000;;			doConfigMapE2EWithMappings(f, 0, 0, &mode)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume with mappings as non-root [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			doConfigMapE2EWithMappings(f, 1000, 0, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume with mappings as non-root with FSGroup [Feature:FSGroup] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			doConfigMapE2EWithMappings(f, 1000, 1001, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("updates should be reflected in volume [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			podLogTimeout := framework.GetPodSecretUpdateTimeout(f.ClientSet)
0000000000000000000000000000000000000000;;			containerTimeoutArg := fmt.Sprintf("--retry_time=%v", int(podLogTimeout.Seconds()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			name := "configmap-test-upd-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			volumeName := "configmap-volume"
0000000000000000000000000000000000000000;;			volumeMountPath := "/etc/configmap-volume"
0000000000000000000000000000000000000000;;			containerName := "configmap-volume-test"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			configMap := &v1.ConfigMap{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;					Name:      name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Data: map[string]string{
0000000000000000000000000000000000000000;;					"data-1": "value-1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating configMap with name %s", configMap.Name))
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if configMap, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Create(configMap); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test configMap %s: %v", configMap.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "pod-configmaps-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: volumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								ConfigMap: &v1.ConfigMapVolumeSource{
0000000000000000000000000000000000000000;;									LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;										Name: name,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    containerName,
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;							Command: []string{"/mt", "--break_on_expected_content=false", containerTimeoutArg, "--file_content_in_loop=/etc/configmap-volume/data-1"},
0000000000000000000000000000000000000000;;							VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      volumeName,
0000000000000000000000000000000000000000;;									MountPath: volumeMountPath,
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("Creating the pod")
0000000000000000000000000000000000000000;;			f.PodClient().CreateSync(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pollLogs := func() (string, error) {
0000000000000000000000000000000000000000;;				return framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, containerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Eventually(pollLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("value-1"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Updating configmap %v", configMap.Name))
0000000000000000000000000000000000000000;;			configMap.ResourceVersion = "" // to force update
0000000000000000000000000000000000000000;;			configMap.Data["data-1"] = "value-2"
0000000000000000000000000000000000000000;;			_, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Update(configMap)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "Failed to update configmap %q in namespace %q", configMap.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("waiting to observe update in volume")
0000000000000000000000000000000000000000;;			Eventually(pollLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("value-2"))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("optional updates should be reflected in volume [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			podLogTimeout := framework.GetPodSecretUpdateTimeout(f.ClientSet)
0000000000000000000000000000000000000000;;			containerTimeoutArg := fmt.Sprintf("--retry_time=%v", int(podLogTimeout.Seconds()))
0000000000000000000000000000000000000000;;			trueVal := true
0000000000000000000000000000000000000000;;			volumeMountPath := "/etc/configmap-volumes"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			deleteName := "cm-test-opt-del-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			deleteContainerName := "delcm-volume-test"
0000000000000000000000000000000000000000;;			deleteVolumeName := "deletecm-volume"
0000000000000000000000000000000000000000;;			deleteConfigMap := &v1.ConfigMap{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;					Name:      deleteName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Data: map[string]string{
0000000000000000000000000000000000000000;;					"data-1": "value-1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			updateName := "cm-test-opt-upd-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			updateContainerName := "updcm-volume-test"
0000000000000000000000000000000000000000;;			updateVolumeName := "updatecm-volume"
0000000000000000000000000000000000000000;;			updateConfigMap := &v1.ConfigMap{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;					Name:      updateName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Data: map[string]string{
0000000000000000000000000000000000000000;;					"data-1": "value-1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			createName := "cm-test-opt-create-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			createContainerName := "createcm-volume-test"
0000000000000000000000000000000000000000;;			createVolumeName := "createcm-volume"
0000000000000000000000000000000000000000;;			createConfigMap := &v1.ConfigMap{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;					Name:      createName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Data: map[string]string{
0000000000000000000000000000000000000000;;					"data-1": "value-1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating configMap with name %s", deleteConfigMap.Name))
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if deleteConfigMap, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Create(deleteConfigMap); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test configMap %s: %v", deleteConfigMap.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating configMap with name %s", updateConfigMap.Name))
0000000000000000000000000000000000000000;;			if updateConfigMap, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Create(updateConfigMap); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test configMap %s: %v", updateConfigMap.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "pod-configmaps-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: deleteVolumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								ConfigMap: &v1.ConfigMapVolumeSource{
0000000000000000000000000000000000000000;;									LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;										Name: deleteName,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									Optional: &trueVal,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: updateVolumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								ConfigMap: &v1.ConfigMapVolumeSource{
0000000000000000000000000000000000000000;;									LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;										Name: updateName,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									Optional: &trueVal,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: createVolumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								ConfigMap: &v1.ConfigMapVolumeSource{
0000000000000000000000000000000000000000;;									LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;										Name: createName,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									Optional: &trueVal,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    deleteContainerName,
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;							Command: []string{"/mt", "--break_on_expected_content=false", containerTimeoutArg, "--file_content_in_loop=/etc/configmap-volumes/delete/data-1"},
0000000000000000000000000000000000000000;;							VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      deleteVolumeName,
0000000000000000000000000000000000000000;;									MountPath: path.Join(volumeMountPath, "delete"),
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    updateContainerName,
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;							Command: []string{"/mt", "--break_on_expected_content=false", containerTimeoutArg, "--file_content_in_loop=/etc/configmap-volumes/update/data-3"},
0000000000000000000000000000000000000000;;							VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      updateVolumeName,
0000000000000000000000000000000000000000;;									MountPath: path.Join(volumeMountPath, "update"),
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    createContainerName,
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;							Command: []string{"/mt", "--break_on_expected_content=false", containerTimeoutArg, "--file_content_in_loop=/etc/configmap-volumes/create/data-1"},
0000000000000000000000000000000000000000;;							VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      createVolumeName,
0000000000000000000000000000000000000000;;									MountPath: path.Join(volumeMountPath, "create"),
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("Creating the pod")
0000000000000000000000000000000000000000;;			f.PodClient().CreateSync(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pollCreateLogs := func() (string, error) {
0000000000000000000000000000000000000000;;				return framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, createContainerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Eventually(pollCreateLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("Error reading file /etc/configmap-volumes/create/data-1"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pollUpdateLogs := func() (string, error) {
0000000000000000000000000000000000000000;;				return framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, updateContainerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Eventually(pollUpdateLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("Error reading file /etc/configmap-volumes/update/data-3"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pollDeleteLogs := func() (string, error) {
0000000000000000000000000000000000000000;;				return framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, deleteContainerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Eventually(pollDeleteLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("value-1"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Deleting configmap %v", deleteConfigMap.Name))
0000000000000000000000000000000000000000;;			err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Delete(deleteConfigMap.Name, &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "Failed to delete configmap %q in namespace %q", deleteConfigMap.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Updating configmap %v", updateConfigMap.Name))
0000000000000000000000000000000000000000;;			updateConfigMap.ResourceVersion = "" // to force update
0000000000000000000000000000000000000000;;			delete(updateConfigMap.Data, "data-1")
0000000000000000000000000000000000000000;;			updateConfigMap.Data["data-3"] = "value-3"
0000000000000000000000000000000000000000;;			_, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Update(updateConfigMap)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "Failed to update configmap %q in namespace %q", updateConfigMap.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating configMap with name %s", createConfigMap.Name))
0000000000000000000000000000000000000000;;			if createConfigMap, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Create(createConfigMap); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test configMap %s: %v", createConfigMap.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("waiting to observe update in volume")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Eventually(pollCreateLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("value-1"))
0000000000000000000000000000000000000000;;			Eventually(pollUpdateLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("value-3"))
0000000000000000000000000000000000000000;;			Eventually(pollDeleteLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("Error reading file /etc/configmap-volumes/delete/data-1"))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable via environment variable [Conformance]", func() {
0000000000000000000000000000000000000000;;			name := "configmap-test-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			configMap := newConfigMap(f, name)
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating configMap %v/%v", f.Namespace.Name, configMap.Name))
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if configMap, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Create(configMap); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test configMap %s: %v", configMap.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "pod-configmaps-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    "env-test",
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;							Command: []string{"sh", "-c", "env"},
0000000000000000000000000000000000000000;;							Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name: "CONFIG_DATA_1",
0000000000000000000000000000000000000000;;									ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;										ConfigMapKeyRef: &v1.ConfigMapKeySelector{
0000000000000000000000000000000000000000;;											LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;												Name: name,
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;											Key: "data-1",
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("consume configMaps", pod, 0, []string{
0000000000000000000000000000000000000000;;				"CONFIG_DATA_1=value-1",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable via the environment [Conformance]", func() {
0000000000000000000000000000000000000000;;			name := "configmap-test-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			configMap := newEnvFromConfigMap(f, name)
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating configMap %v/%v", f.Namespace.Name, configMap.Name))
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if configMap, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Create(configMap); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test configMap %s: %v", configMap.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "pod-configmaps-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    "env-test",
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;							Command: []string{"sh", "-c", "env"},
0000000000000000000000000000000000000000;;							EnvFrom: []v1.EnvFromSource{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									ConfigMapRef: &v1.ConfigMapEnvSource{LocalObjectReference: v1.LocalObjectReference{Name: name}},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Prefix:       "p_",
0000000000000000000000000000000000000000;;									ConfigMapRef: &v1.ConfigMapEnvSource{LocalObjectReference: v1.LocalObjectReference{Name: name}},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("consume configMaps", pod, 0, []string{
0000000000000000000000000000000000000000;;				"data_1=value-1", "data_2=value-2", "data_3=value-3",
0000000000000000000000000000000000000000;;				"p_data_1=value-1", "p_data_2=value-2", "p_data_3=value-3",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable in multiple volumes in the same pod [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				name             = "configmap-test-volume-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;				volumeName       = "configmap-volume"
0000000000000000000000000000000000000000;;				volumeMountPath  = "/etc/configmap-volume"
0000000000000000000000000000000000000000;;				volumeName2      = "configmap-volume-2"
0000000000000000000000000000000000000000;;				volumeMountPath2 = "/etc/configmap-volume-2"
0000000000000000000000000000000000000000;;				configMap        = newConfigMap(f, name)
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating configMap with name %s", configMap.Name))
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if configMap, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Create(configMap); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test configMap %s: %v", configMap.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "pod-configmaps-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: volumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								ConfigMap: &v1.ConfigMapVolumeSource{
0000000000000000000000000000000000000000;;									LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;										Name: name,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: volumeName2,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								ConfigMap: &v1.ConfigMapVolumeSource{
0000000000000000000000000000000000000000;;									LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;										Name: name,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "configmap-volume-test",
0000000000000000000000000000000000000000;;							Image: "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;							Args:  []string{"--file_content=/etc/configmap-volume/data-1"},
0000000000000000000000000000000000000000;;							VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      volumeName,
0000000000000000000000000000000000000000;;									MountPath: volumeMountPath,
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      volumeName2,
0000000000000000000000000000000000000000;;									MountPath: volumeMountPath2,
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("consume configMaps", pod, 0, []string{
0000000000000000000000000000000000000000;;				"content of file \"/etc/configmap-volume/data-1\": value-1",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newConfigMap(f *framework.Framework, name string) *v1.ConfigMap {
0000000000000000000000000000000000000000;;		return &v1.ConfigMap{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: map[string]string{
0000000000000000000000000000000000000000;;				"data-1": "value-1",
0000000000000000000000000000000000000000;;				"data-2": "value-2",
0000000000000000000000000000000000000000;;				"data-3": "value-3",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newEnvFromConfigMap(f *framework.Framework, name string) *v1.ConfigMap {
0000000000000000000000000000000000000000;;		return &v1.ConfigMap{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: map[string]string{
0000000000000000000000000000000000000000;;				"data_1": "value-1",
0000000000000000000000000000000000000000;;				"data_2": "value-2",
0000000000000000000000000000000000000000;;				"data_3": "value-3",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doConfigMapE2EWithoutMappings(f *framework.Framework, uid, fsGroup int64, defaultMode *int32) {
0000000000000000000000000000000000000000;;		userID := int64(uid)
0000000000000000000000000000000000000000;;		groupID := int64(fsGroup)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			name            = "configmap-test-volume-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			volumeName      = "configmap-volume"
0000000000000000000000000000000000000000;;			volumeMountPath = "/etc/configmap-volume"
0000000000000000000000000000000000000000;;			configMap       = newConfigMap(f, name)
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating configMap with name %s", configMap.Name))
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if configMap, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Create(configMap); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("unable to create test configMap %s: %v", configMap.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		one := int64(1)
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod-configmaps-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				SecurityContext: &v1.PodSecurityContext{},
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: volumeName,
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							ConfigMap: &v1.ConfigMapVolumeSource{
0000000000000000000000000000000000000000;;								LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;									Name: name,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "configmap-volume-test",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;						Args: []string{
0000000000000000000000000000000000000000;;							"--file_content=/etc/configmap-volume/data-1",
0000000000000000000000000000000000000000;;							"--file_mode=/etc/configmap-volume/data-1"},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      volumeName,
0000000000000000000000000000000000000000;;								MountPath: volumeMountPath,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy:                 v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				TerminationGracePeriodSeconds: &one,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if userID != 0 {
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext.RunAsUser = &userID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if groupID != 0 {
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext.FSGroup = &groupID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if defaultMode != nil {
0000000000000000000000000000000000000000;;			pod.Spec.Volumes[0].VolumeSource.ConfigMap.DefaultMode = defaultMode
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			mode := int32(0644)
0000000000000000000000000000000000000000;;			defaultMode = &mode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		modeString := fmt.Sprintf("%v", os.FileMode(*defaultMode))
0000000000000000000000000000000000000000;;		output := []string{
0000000000000000000000000000000000000000;;			"content of file \"/etc/configmap-volume/data-1\": value-1",
0000000000000000000000000000000000000000;;			"mode of file \"/etc/configmap-volume/data-1\": " + modeString,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.TestContainerOutput("consume configMaps", pod, 0, output)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doConfigMapE2EWithMappings(f *framework.Framework, uid, fsGroup int64, itemMode *int32) {
0000000000000000000000000000000000000000;;		userID := int64(uid)
0000000000000000000000000000000000000000;;		groupID := int64(fsGroup)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			name            = "configmap-test-volume-map-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			volumeName      = "configmap-volume"
0000000000000000000000000000000000000000;;			volumeMountPath = "/etc/configmap-volume"
0000000000000000000000000000000000000000;;			configMap       = newConfigMap(f, name)
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating configMap with name %s", configMap.Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if configMap, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Create(configMap); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("unable to create test configMap %s: %v", configMap.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		one := int64(1)
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod-configmaps-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				SecurityContext: &v1.PodSecurityContext{},
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: volumeName,
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							ConfigMap: &v1.ConfigMapVolumeSource{
0000000000000000000000000000000000000000;;								LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;									Name: name,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Items: []v1.KeyToPath{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Key:  "data-2",
0000000000000000000000000000000000000000;;										Path: "path/to/data-2",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "configmap-volume-test",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;						Args: []string{"--file_content=/etc/configmap-volume/path/to/data-2",
0000000000000000000000000000000000000000;;							"--file_mode=/etc/configmap-volume/path/to/data-2"},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      volumeName,
0000000000000000000000000000000000000000;;								MountPath: volumeMountPath,
0000000000000000000000000000000000000000;;								ReadOnly:  true,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy:                 v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				TerminationGracePeriodSeconds: &one,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if userID != 0 {
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext.RunAsUser = &userID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if groupID != 0 {
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext.FSGroup = &groupID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if itemMode != nil {
0000000000000000000000000000000000000000;;			pod.Spec.Volumes[0].VolumeSource.ConfigMap.Items[0].Mode = itemMode
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			mode := int32(0644)
0000000000000000000000000000000000000000;;			itemMode = &mode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Just check file mode if fsGroup is not set. If fsGroup is set, the
0000000000000000000000000000000000000000;;		// final mode is adjusted and we are not testing that case.
0000000000000000000000000000000000000000;;		output := []string{
0000000000000000000000000000000000000000;;			"content of file \"/etc/configmap-volume/path/to/data-2\": value-2",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fsGroup == 0 {
0000000000000000000000000000000000000000;;			modeString := fmt.Sprintf("%v", os.FileMode(*itemMode))
0000000000000000000000000000000000000000;;			output = append(output, "mode of file \"/etc/configmap-volume/path/to/data-2\": "+modeString)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.TestContainerOutput("consume configMaps", pod, 0, output)
0000000000000000000000000000000000000000;;	}
