0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
2801900f171bea43636f9ed635706503a2c17e9c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package common
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/sysctl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Sysctls", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("sysctl")
0000000000000000000000000000000000000000;;		var podClient *framework.PodClient
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testPod := func() *v1.Pod {
0000000000000000000000000000000000000000;;			podName := "sysctl-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			pod := v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:        podName,
0000000000000000000000000000000000000000;;					Annotations: map[string]string{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "test-container",
0000000000000000000000000000000000000000;;							Image: "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return &pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			podClient = f.PodClient()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should support sysctls", func() {
0000000000000000000000000000000000000000;;			pod := testPod()
0000000000000000000000000000000000000000;;			pod.Annotations[v1.SysctlsPodAnnotationKey] = v1helper.PodAnnotationsFromSysctls([]v1.Sysctl{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:  "kernel.shm_rmid_forced",
0000000000000000000000000000000000000000;;					Value: "1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			pod.Spec.Containers[0].Command = []string{"/bin/sysctl", "kernel.shm_rmid_forced"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a pod with the kernel.shm_rmid_forced sysctl")
0000000000000000000000000000000000000000;;			pod = podClient.Create(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Watching for error events or started pod")
0000000000000000000000000000000000000000;;			// watch for events instead of termination of pod because the kubelet deletes
0000000000000000000000000000000000000000;;			// failed pods without running containers. This would create a race as the pod
0000000000000000000000000000000000000000;;			// might have already been deleted here.
0000000000000000000000000000000000000000;;			ev, err := f.PodClient().WaitForErrorEventOrSuccess(pod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			if ev != nil && ev.Reason == sysctl.UnsupportedReason {
0000000000000000000000000000000000000000;;				framework.Skipf("No sysctl support in Docker <1.12")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Expect(ev).To(BeNil())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Waiting for pod completion")
0000000000000000000000000000000000000000;;			err = f.WaitForPodNoLongerRunning(pod.Name)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			pod, err = podClient.Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Checking that the pod succeeded")
0000000000000000000000000000000000000000;;			Expect(pod.Status.Phase).To(Equal(v1.PodSucceeded))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Getting logs from the pod")
0000000000000000000000000000000000000000;;			log, err := framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, pod.Spec.Containers[0].Name)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Checking that the sysctl is actually updated")
0000000000000000000000000000000000000000;;			Expect(log).To(ContainSubstring("kernel.shm_rmid_forced = 1"))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should support unsafe sysctls which are actually whitelisted", func() {
0000000000000000000000000000000000000000;;			pod := testPod()
0000000000000000000000000000000000000000;;			pod.Annotations[v1.UnsafeSysctlsPodAnnotationKey] = v1helper.PodAnnotationsFromSysctls([]v1.Sysctl{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:  "kernel.shm_rmid_forced",
0000000000000000000000000000000000000000;;					Value: "1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			pod.Spec.Containers[0].Command = []string{"/bin/sysctl", "kernel.shm_rmid_forced"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a pod with the kernel.shm_rmid_forced sysctl")
0000000000000000000000000000000000000000;;			pod = podClient.Create(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Watching for error events or started pod")
0000000000000000000000000000000000000000;;			// watch for events instead of termination of pod because the kubelet deletes
0000000000000000000000000000000000000000;;			// failed pods without running containers. This would create a race as the pod
0000000000000000000000000000000000000000;;			// might have already been deleted here.
0000000000000000000000000000000000000000;;			ev, err := f.PodClient().WaitForErrorEventOrSuccess(pod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			if ev != nil && ev.Reason == sysctl.UnsupportedReason {
0000000000000000000000000000000000000000;;				framework.Skipf("No sysctl support in Docker <1.12")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Expect(ev).To(BeNil())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Waiting for pod completion")
0000000000000000000000000000000000000000;;			err = f.WaitForPodNoLongerRunning(pod.Name)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			pod, err = podClient.Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Checking that the pod succeeded")
0000000000000000000000000000000000000000;;			Expect(pod.Status.Phase).To(Equal(v1.PodSucceeded))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Getting logs from the pod")
0000000000000000000000000000000000000000;;			log, err := framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, pod.Spec.Containers[0].Name)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Checking that the sysctl is actually updated")
0000000000000000000000000000000000000000;;			Expect(log).To(ContainSubstring("kernel.shm_rmid_forced = 1"))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should reject invalid sysctls", func() {
0000000000000000000000000000000000000000;;			pod := testPod()
0000000000000000000000000000000000000000;;			pod.Annotations[v1.SysctlsPodAnnotationKey] = v1helper.PodAnnotationsFromSysctls([]v1.Sysctl{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:  "foo-",
0000000000000000000000000000000000000000;;					Value: "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:  "kernel.shmmax",
0000000000000000000000000000000000000000;;					Value: "100000000",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:  "safe-and-unsafe",
0000000000000000000000000000000000000000;;					Value: "100000000",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			pod.Annotations[v1.UnsafeSysctlsPodAnnotationKey] = v1helper.PodAnnotationsFromSysctls([]v1.Sysctl{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:  "kernel.shmall",
0000000000000000000000000000000000000000;;					Value: "100000000",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:  "bar..",
0000000000000000000000000000000000000000;;					Value: "42",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:  "safe-and-unsafe",
0000000000000000000000000000000000000000;;					Value: "100000000",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a pod with one valid and two invalid sysctls")
0000000000000000000000000000000000000000;;			client := f.ClientSet.Core().Pods(f.Namespace.Name)
0000000000000000000000000000000000000000;;			_, err := client.Create(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Expect(err).NotTo(BeNil())
0000000000000000000000000000000000000000;;			Expect(err.Error()).To(ContainSubstring(`Invalid value: "foo-"`))
0000000000000000000000000000000000000000;;			Expect(err.Error()).To(ContainSubstring(`Invalid value: "bar.."`))
0000000000000000000000000000000000000000;;			Expect(err.Error()).To(ContainSubstring(`safe-and-unsafe`))
0000000000000000000000000000000000000000;;			Expect(err.Error()).NotTo(ContainSubstring("kernel.shmmax"))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should not launch unsafe, but not explicitly enabled sysctls on the node", func() {
0000000000000000000000000000000000000000;;			pod := testPod()
0000000000000000000000000000000000000000;;			pod.Annotations[v1.SysctlsPodAnnotationKey] = v1helper.PodAnnotationsFromSysctls([]v1.Sysctl{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:  "kernel.msgmax",
0000000000000000000000000000000000000000;;					Value: "10000000000",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a pod with a greylisted, but not whitelisted sysctl on the node")
0000000000000000000000000000000000000000;;			pod = podClient.Create(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Watching for error events or started pod")
0000000000000000000000000000000000000000;;			// watch for events instead of termination of pod because the kubelet deletes
0000000000000000000000000000000000000000;;			// failed pods without running containers. This would create a race as the pod
0000000000000000000000000000000000000000;;			// might have already been deleted here.
0000000000000000000000000000000000000000;;			ev, err := f.PodClient().WaitForErrorEventOrSuccess(pod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			if ev != nil && ev.Reason == sysctl.UnsupportedReason {
0000000000000000000000000000000000000000;;				framework.Skipf("No sysctl support in Docker <1.12")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Checking that the pod was rejected")
0000000000000000000000000000000000000000;;			Expect(ev).ToNot(BeNil())
0000000000000000000000000000000000000000;;			Expect(ev.Reason).To(Equal("SysctlForbidden"))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
