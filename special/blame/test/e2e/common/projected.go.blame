0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
786be53ab2bb3f160a2b603b450e34122308ff03;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package common
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Projected", func() {
0000000000000000000000000000000000000000;;		// Part 1/3 - Secrets
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("projected")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			doProjectedSecretE2EWithoutMapping(f, nil /* default mode */, "projected-secret-test-"+string(uuid.NewUUID()), nil, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume with defaultMode set [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			defaultMode := int32(0400)
0000000000000000000000000000000000000000;;			doProjectedSecretE2EWithoutMapping(f, &defaultMode, "projected-secret-test-"+string(uuid.NewUUID()), nil, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume as non-root with defaultMode and fsGroup set [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			defaultMode := int32(0440) /* setting fsGroup sets mode to at least 440 */
0000000000000000000000000000000000000000;;			fsGroup := int64(1001)
0000000000000000000000000000000000000000;;			uid := int64(1000)
0000000000000000000000000000000000000000;;			doProjectedSecretE2EWithoutMapping(f, &defaultMode, "projected-secret-test-"+string(uuid.NewUUID()), &fsGroup, &uid)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume with mappings [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			doProjectedSecretE2EWithMapping(f, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume with mappings and Item Mode set [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			mode := int32(0400)
0000000000000000000000000000000000000000;;			doProjectedSecretE2EWithMapping(f, &mode)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be able to mount in a volume regardless of a different secret existing with same name in different namespace [sig-storage]", func() {
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				namespace2  *v1.Namespace
0000000000000000000000000000000000000000;;				err         error
0000000000000000000000000000000000000000;;				secret2Name = "projected-secret-test-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if namespace2, err = f.CreateNamespace("secret-namespace", nil); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create new namespace %s: %v", namespace2.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			secret2 := secretForTest(namespace2.Name, secret2Name)
0000000000000000000000000000000000000000;;			secret2.Data = map[string][]byte{
0000000000000000000000000000000000000000;;				"this_should_not_match_content_of_other_secret": []byte("similarly_this_should_not_match_content_of_other_secret\n"),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if secret2, err = f.ClientSet.Core().Secrets(namespace2.Name).Create(secret2); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test secret %s: %v", secret2.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			doProjectedSecretE2EWithoutMapping(f, nil /* default mode */, secret2.Name, nil, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable in multiple volumes in a pod [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			// This test ensures that the same secret can be mounted in multiple
0000000000000000000000000000000000000000;;			// volumes in the same pod.  This test case exists to prevent
0000000000000000000000000000000000000000;;			// regressions that break this use-case.
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				name             = "projected-secret-test-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;				volumeName       = "projected-secret-volume"
0000000000000000000000000000000000000000;;				volumeMountPath  = "/etc/projected-secret-volume"
0000000000000000000000000000000000000000;;				volumeName2      = "projected-secret-volume-2"
0000000000000000000000000000000000000000;;				volumeMountPath2 = "/etc/projected-secret-volume-2"
0000000000000000000000000000000000000000;;				secret           = secretForTest(f.Namespace.Name, name)
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating secret with name %s", secret.Name))
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if secret, err = f.ClientSet.Core().Secrets(f.Namespace.Name).Create(secret); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test secret %s: %v", secret.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "pod-projected-secrets-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: volumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								Projected: &v1.ProjectedVolumeSource{
0000000000000000000000000000000000000000;;									Sources: []v1.VolumeProjection{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											Secret: &v1.SecretProjection{
0000000000000000000000000000000000000000;;												LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;													Name: name,
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: volumeName2,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								Projected: &v1.ProjectedVolumeSource{
0000000000000000000000000000000000000000;;									Sources: []v1.VolumeProjection{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											Secret: &v1.SecretProjection{
0000000000000000000000000000000000000000;;												LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;													Name: name,
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "secret-volume-test",
0000000000000000000000000000000000000000;;							Image: "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;							Args: []string{
0000000000000000000000000000000000000000;;								"--file_content=/etc/projected-secret-volume/data-1",
0000000000000000000000000000000000000000;;								"--file_mode=/etc/projected-secret-volume/data-1"},
0000000000000000000000000000000000000000;;							VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      volumeName,
0000000000000000000000000000000000000000;;									MountPath: volumeMountPath,
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      volumeName2,
0000000000000000000000000000000000000000;;									MountPath: volumeMountPath2,
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("consume secrets", pod, 0, []string{
0000000000000000000000000000000000000000;;				"content of file \"/etc/projected-secret-volume/data-1\": value-1",
0000000000000000000000000000000000000000;;				"mode of file \"/etc/projected-secret-volume/data-1\": -rw-r--r--",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("optional updates should be reflected in volume [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			podLogTimeout := framework.GetPodSecretUpdateTimeout(f.ClientSet)
0000000000000000000000000000000000000000;;			containerTimeoutArg := fmt.Sprintf("--retry_time=%v", int(podLogTimeout.Seconds()))
0000000000000000000000000000000000000000;;			trueVal := true
0000000000000000000000000000000000000000;;			volumeMountPath := "/etc/projected-secret-volumes"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			deleteName := "s-test-opt-del-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			deleteContainerName := "dels-volume-test"
0000000000000000000000000000000000000000;;			deleteVolumeName := "deletes-volume"
0000000000000000000000000000000000000000;;			deleteSecret := &v1.Secret{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;					Name:      deleteName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Data: map[string][]byte{
0000000000000000000000000000000000000000;;					"data-1": []byte("value-1"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			updateName := "s-test-opt-upd-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			updateContainerName := "upds-volume-test"
0000000000000000000000000000000000000000;;			updateVolumeName := "updates-volume"
0000000000000000000000000000000000000000;;			updateSecret := &v1.Secret{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;					Name:      updateName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Data: map[string][]byte{
0000000000000000000000000000000000000000;;					"data-1": []byte("value-1"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			createName := "s-test-opt-create-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			createContainerName := "creates-volume-test"
0000000000000000000000000000000000000000;;			createVolumeName := "creates-volume"
0000000000000000000000000000000000000000;;			createSecret := &v1.Secret{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;					Name:      createName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Data: map[string][]byte{
0000000000000000000000000000000000000000;;					"data-1": []byte("value-1"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating secret with name %s", deleteSecret.Name))
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if deleteSecret, err = f.ClientSet.Core().Secrets(f.Namespace.Name).Create(deleteSecret); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test secret %s: %v", deleteSecret.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating secret with name %s", updateSecret.Name))
0000000000000000000000000000000000000000;;			if updateSecret, err = f.ClientSet.Core().Secrets(f.Namespace.Name).Create(updateSecret); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test secret %s: %v", updateSecret.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "pod-projected-secrets-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: deleteVolumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								Projected: &v1.ProjectedVolumeSource{
0000000000000000000000000000000000000000;;									Sources: []v1.VolumeProjection{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											Secret: &v1.SecretProjection{
0000000000000000000000000000000000000000;;												LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;													Name: deleteName,
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;												Optional: &trueVal,
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: updateVolumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								Projected: &v1.ProjectedVolumeSource{
0000000000000000000000000000000000000000;;									Sources: []v1.VolumeProjection{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											Secret: &v1.SecretProjection{
0000000000000000000000000000000000000000;;												LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;													Name: updateName,
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;												Optional: &trueVal,
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: createVolumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								Projected: &v1.ProjectedVolumeSource{
0000000000000000000000000000000000000000;;									Sources: []v1.VolumeProjection{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											Secret: &v1.SecretProjection{
0000000000000000000000000000000000000000;;												LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;													Name: createName,
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;												Optional: &trueVal,
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    deleteContainerName,
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;							Command: []string{"/mt", "--break_on_expected_content=false", containerTimeoutArg, "--file_content_in_loop=/etc/projected-secret-volumes/delete/data-1"},
0000000000000000000000000000000000000000;;							VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      deleteVolumeName,
0000000000000000000000000000000000000000;;									MountPath: path.Join(volumeMountPath, "delete"),
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    updateContainerName,
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;							Command: []string{"/mt", "--break_on_expected_content=false", containerTimeoutArg, "--file_content_in_loop=/etc/projected-secret-volumes/update/data-3"},
0000000000000000000000000000000000000000;;							VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      updateVolumeName,
0000000000000000000000000000000000000000;;									MountPath: path.Join(volumeMountPath, "update"),
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    createContainerName,
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;							Command: []string{"/mt", "--break_on_expected_content=false", containerTimeoutArg, "--file_content_in_loop=/etc/projected-secret-volumes/create/data-1"},
0000000000000000000000000000000000000000;;							VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      createVolumeName,
0000000000000000000000000000000000000000;;									MountPath: path.Join(volumeMountPath, "create"),
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("Creating the pod")
0000000000000000000000000000000000000000;;			f.PodClient().CreateSync(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pollCreateLogs := func() (string, error) {
0000000000000000000000000000000000000000;;				return framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, createContainerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Eventually(pollCreateLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("Error reading file /etc/projected-secret-volumes/create/data-1"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pollUpdateLogs := func() (string, error) {
0000000000000000000000000000000000000000;;				return framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, updateContainerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Eventually(pollUpdateLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("Error reading file /etc/projected-secret-volumes/update/data-3"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pollDeleteLogs := func() (string, error) {
0000000000000000000000000000000000000000;;				return framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, deleteContainerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Eventually(pollDeleteLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("value-1"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Deleting secret %v", deleteSecret.Name))
0000000000000000000000000000000000000000;;			err = f.ClientSet.Core().Secrets(f.Namespace.Name).Delete(deleteSecret.Name, &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "Failed to delete secret %q in namespace %q", deleteSecret.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Updating secret %v", updateSecret.Name))
0000000000000000000000000000000000000000;;			updateSecret.ResourceVersion = "" // to force update
0000000000000000000000000000000000000000;;			delete(updateSecret.Data, "data-1")
0000000000000000000000000000000000000000;;			updateSecret.Data["data-3"] = []byte("value-3")
0000000000000000000000000000000000000000;;			_, err = f.ClientSet.Core().Secrets(f.Namespace.Name).Update(updateSecret)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "Failed to update secret %q in namespace %q", updateSecret.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating secret with name %s", createSecret.Name))
0000000000000000000000000000000000000000;;			if createSecret, err = f.ClientSet.Core().Secrets(f.Namespace.Name).Create(createSecret); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test secret %s: %v", createSecret.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("waiting to observe update in volume")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Eventually(pollCreateLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("value-1"))
0000000000000000000000000000000000000000;;			Eventually(pollUpdateLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("value-3"))
0000000000000000000000000000000000000000;;			Eventually(pollDeleteLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("Error reading file /etc/projected-secret-volumes/delete/data-1"))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Part 2/3 - ConfigMaps
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			doProjectedConfigMapE2EWithoutMappings(f, 0, 0, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume with defaultMode set [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			defaultMode := int32(0400)
0000000000000000000000000000000000000000;;			doProjectedConfigMapE2EWithoutMappings(f, 0, 0, &defaultMode)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume as non-root with defaultMode and fsGroup set [Feature:FSGroup] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			defaultMode := int32(0440) /* setting fsGroup sets mode to at least 440 */
0000000000000000000000000000000000000000;;			doProjectedConfigMapE2EWithoutMappings(f, 1000, 1001, &defaultMode)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume as non-root [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			doProjectedConfigMapE2EWithoutMappings(f, 1000, 0, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume as non-root with FSGroup [Feature:FSGroup] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			doProjectedConfigMapE2EWithoutMappings(f, 1000, 1001, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume with mappings [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			doProjectedConfigMapE2EWithMappings(f, 0, 0, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume with mappings and Item mode set[Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			mode := int32(0400)
0000000000000000000000000000000000000000;;			doProjectedConfigMapE2EWithMappings(f, 0, 0, &mode)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume with mappings as non-root [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			doProjectedConfigMapE2EWithMappings(f, 1000, 0, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable from pods in volume with mappings as non-root with FSGroup [Feature:FSGroup] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			doProjectedConfigMapE2EWithMappings(f, 1000, 1001, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("updates should be reflected in volume [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			podLogTimeout := framework.GetPodSecretUpdateTimeout(f.ClientSet)
0000000000000000000000000000000000000000;;			containerTimeoutArg := fmt.Sprintf("--retry_time=%v", int(podLogTimeout.Seconds()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			name := "projected-configmap-test-upd-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			volumeName := "projected-configmap-volume"
0000000000000000000000000000000000000000;;			volumeMountPath := "/etc/projected-configmap-volume"
0000000000000000000000000000000000000000;;			containerName := "projected-configmap-volume-test"
0000000000000000000000000000000000000000;;			configMap := &v1.ConfigMap{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;					Name:      name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Data: map[string]string{
0000000000000000000000000000000000000000;;					"data-1": "value-1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating projection with configMap that has name %s", configMap.Name))
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if configMap, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Create(configMap); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test configMap %s: %v", configMap.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "pod-projected-configmaps-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: volumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								Projected: &v1.ProjectedVolumeSource{
0000000000000000000000000000000000000000;;									Sources: []v1.VolumeProjection{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											ConfigMap: &v1.ConfigMapProjection{
0000000000000000000000000000000000000000;;												LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;													Name: name,
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    containerName,
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;							Command: []string{"/mt", "--break_on_expected_content=false", containerTimeoutArg, "--file_content_in_loop=/etc/projected-configmap-volume/data-1"},
0000000000000000000000000000000000000000;;							VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      volumeName,
0000000000000000000000000000000000000000;;									MountPath: volumeMountPath,
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("Creating the pod")
0000000000000000000000000000000000000000;;			f.PodClient().CreateSync(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pollLogs := func() (string, error) {
0000000000000000000000000000000000000000;;				return framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, containerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Eventually(pollLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("value-1"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Updating configmap %v", configMap.Name))
0000000000000000000000000000000000000000;;			configMap.ResourceVersion = "" // to force update
0000000000000000000000000000000000000000;;			configMap.Data["data-1"] = "value-2"
0000000000000000000000000000000000000000;;			_, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Update(configMap)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "Failed to update configmap %q in namespace %q", configMap.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("waiting to observe update in volume")
0000000000000000000000000000000000000000;;			Eventually(pollLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("value-2"))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("optional updates should be reflected in volume [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			podLogTimeout := framework.GetPodSecretUpdateTimeout(f.ClientSet)
0000000000000000000000000000000000000000;;			containerTimeoutArg := fmt.Sprintf("--retry_time=%v", int(podLogTimeout.Seconds()))
0000000000000000000000000000000000000000;;			trueVal := true
0000000000000000000000000000000000000000;;			volumeMountPath := "/etc/projected-configmap-volumes"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			deleteName := "cm-test-opt-del-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			deleteContainerName := "delcm-volume-test"
0000000000000000000000000000000000000000;;			deleteVolumeName := "deletecm-volume"
0000000000000000000000000000000000000000;;			deleteConfigMap := &v1.ConfigMap{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;					Name:      deleteName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Data: map[string]string{
0000000000000000000000000000000000000000;;					"data-1": "value-1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			updateName := "cm-test-opt-upd-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			updateContainerName := "updcm-volume-test"
0000000000000000000000000000000000000000;;			updateVolumeName := "updatecm-volume"
0000000000000000000000000000000000000000;;			updateConfigMap := &v1.ConfigMap{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;					Name:      updateName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Data: map[string]string{
0000000000000000000000000000000000000000;;					"data-1": "value-1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			createName := "cm-test-opt-create-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			createContainerName := "createcm-volume-test"
0000000000000000000000000000000000000000;;			createVolumeName := "createcm-volume"
0000000000000000000000000000000000000000;;			createConfigMap := &v1.ConfigMap{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;					Name:      createName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Data: map[string]string{
0000000000000000000000000000000000000000;;					"data-1": "value-1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating configMap with name %s", deleteConfigMap.Name))
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if deleteConfigMap, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Create(deleteConfigMap); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test configMap %s: %v", deleteConfigMap.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating configMap with name %s", updateConfigMap.Name))
0000000000000000000000000000000000000000;;			if updateConfigMap, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Create(updateConfigMap); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test configMap %s: %v", updateConfigMap.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "pod-projected-configmaps-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: deleteVolumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								Projected: &v1.ProjectedVolumeSource{
0000000000000000000000000000000000000000;;									Sources: []v1.VolumeProjection{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											ConfigMap: &v1.ConfigMapProjection{
0000000000000000000000000000000000000000;;												LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;													Name: deleteName,
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;												Optional: &trueVal,
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: updateVolumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								Projected: &v1.ProjectedVolumeSource{
0000000000000000000000000000000000000000;;									Sources: []v1.VolumeProjection{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											ConfigMap: &v1.ConfigMapProjection{
0000000000000000000000000000000000000000;;												LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;													Name: updateName,
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;												Optional: &trueVal,
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: createVolumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								Projected: &v1.ProjectedVolumeSource{
0000000000000000000000000000000000000000;;									Sources: []v1.VolumeProjection{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											ConfigMap: &v1.ConfigMapProjection{
0000000000000000000000000000000000000000;;												LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;													Name: createName,
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;												Optional: &trueVal,
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    deleteContainerName,
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;							Command: []string{"/mt", "--break_on_expected_content=false", containerTimeoutArg, "--file_content_in_loop=/etc/projected-configmap-volumes/delete/data-1"},
0000000000000000000000000000000000000000;;							VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      deleteVolumeName,
0000000000000000000000000000000000000000;;									MountPath: path.Join(volumeMountPath, "delete"),
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    updateContainerName,
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;							Command: []string{"/mt", "--break_on_expected_content=false", containerTimeoutArg, "--file_content_in_loop=/etc/projected-configmap-volumes/update/data-3"},
0000000000000000000000000000000000000000;;							VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      updateVolumeName,
0000000000000000000000000000000000000000;;									MountPath: path.Join(volumeMountPath, "update"),
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    createContainerName,
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;							Command: []string{"/mt", "--break_on_expected_content=false", containerTimeoutArg, "--file_content_in_loop=/etc/projected-configmap-volumes/create/data-1"},
0000000000000000000000000000000000000000;;							VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      createVolumeName,
0000000000000000000000000000000000000000;;									MountPath: path.Join(volumeMountPath, "create"),
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("Creating the pod")
0000000000000000000000000000000000000000;;			f.PodClient().CreateSync(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pollCreateLogs := func() (string, error) {
0000000000000000000000000000000000000000;;				return framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, createContainerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Eventually(pollCreateLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("Error reading file /etc/projected-configmap-volumes/create/data-1"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pollUpdateLogs := func() (string, error) {
0000000000000000000000000000000000000000;;				return framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, updateContainerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Eventually(pollUpdateLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("Error reading file /etc/projected-configmap-volumes/update/data-3"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pollDeleteLogs := func() (string, error) {
0000000000000000000000000000000000000000;;				return framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, deleteContainerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Eventually(pollDeleteLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("value-1"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Deleting configmap %v", deleteConfigMap.Name))
0000000000000000000000000000000000000000;;			err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Delete(deleteConfigMap.Name, &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "Failed to delete configmap %q in namespace %q", deleteConfigMap.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Updating configmap %v", updateConfigMap.Name))
0000000000000000000000000000000000000000;;			updateConfigMap.ResourceVersion = "" // to force update
0000000000000000000000000000000000000000;;			delete(updateConfigMap.Data, "data-1")
0000000000000000000000000000000000000000;;			updateConfigMap.Data["data-3"] = "value-3"
0000000000000000000000000000000000000000;;			_, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Update(updateConfigMap)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "Failed to update configmap %q in namespace %q", updateConfigMap.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating configMap with name %s", createConfigMap.Name))
0000000000000000000000000000000000000000;;			if createConfigMap, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Create(createConfigMap); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test configMap %s: %v", createConfigMap.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("waiting to observe update in volume")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Eventually(pollCreateLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("value-1"))
0000000000000000000000000000000000000000;;			Eventually(pollUpdateLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("value-3"))
0000000000000000000000000000000000000000;;			Eventually(pollDeleteLogs, podLogTimeout, framework.Poll).Should(ContainSubstring("Error reading file /etc/projected-configmap-volumes/delete/data-1"))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be consumable in multiple volumes in the same pod [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				name             = "projected-configmap-test-volume-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;				volumeName       = "projected-configmap-volume"
0000000000000000000000000000000000000000;;				volumeMountPath  = "/etc/projected-configmap-volume"
0000000000000000000000000000000000000000;;				volumeName2      = "projected-configmap-volume-2"
0000000000000000000000000000000000000000;;				volumeMountPath2 = "/etc/projected-configmap-volume-2"
0000000000000000000000000000000000000000;;				configMap        = newConfigMap(f, name)
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating configMap with name %s", configMap.Name))
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if configMap, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Create(configMap); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test configMap %s: %v", configMap.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "pod-projected-configmaps-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: volumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								Projected: &v1.ProjectedVolumeSource{
0000000000000000000000000000000000000000;;									Sources: []v1.VolumeProjection{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											ConfigMap: &v1.ConfigMapProjection{
0000000000000000000000000000000000000000;;												LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;													Name: name,
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: volumeName2,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								Projected: &v1.ProjectedVolumeSource{
0000000000000000000000000000000000000000;;									Sources: []v1.VolumeProjection{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;											ConfigMap: &v1.ConfigMapProjection{
0000000000000000000000000000000000000000;;												LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;													Name: name,
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "projected-configmap-volume-test",
0000000000000000000000000000000000000000;;							Image: "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;							Args:  []string{"--file_content=/etc/projected-configmap-volume/data-1"},
0000000000000000000000000000000000000000;;							VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      volumeName,
0000000000000000000000000000000000000000;;									MountPath: volumeMountPath,
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      volumeName2,
0000000000000000000000000000000000000000;;									MountPath: volumeMountPath2,
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("consume configMaps", pod, 0, []string{
0000000000000000000000000000000000000000;;				"content of file \"/etc/projected-configmap-volume/data-1\": value-1",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Part 3/3 - DownwardAPI
0000000000000000000000000000000000000000;;		// How long to wait for a log pod to be displayed
0000000000000000000000000000000000000000;;		const podLogTimeout = 2 * time.Minute
0000000000000000000000000000000000000000;;		var podClient *framework.PodClient
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			podClient = f.PodClient()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should provide podname only [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			podName := "downwardapi-volume-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			pod := downwardAPIVolumePodForSimpleTest(podName, "/etc/podname")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("downward API volume plugin", pod, 0, []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("%s\n", podName),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should set DefaultMode on files [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			podName := "downwardapi-volume-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			defaultMode := int32(0400)
0000000000000000000000000000000000000000;;			pod := projectedDownwardAPIVolumePodForModeTest(podName, "/etc/podname", nil, &defaultMode)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("downward API volume plugin", pod, 0, []string{
0000000000000000000000000000000000000000;;				"mode of file \"/etc/podname\": -r--------",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should set mode on item file [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			podName := "downwardapi-volume-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			mode := int32(0400)
0000000000000000000000000000000000000000;;			pod := projectedDownwardAPIVolumePodForModeTest(podName, "/etc/podname", &mode, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("downward API volume plugin", pod, 0, []string{
0000000000000000000000000000000000000000;;				"mode of file \"/etc/podname\": -r--------",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should provide podname as non-root with fsgroup [Feature:FSGroup] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			podName := "metadata-volume-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			uid := int64(1001)
0000000000000000000000000000000000000000;;			gid := int64(1234)
0000000000000000000000000000000000000000;;			pod := downwardAPIVolumePodForSimpleTest(podName, "/etc/podname")
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext = &v1.PodSecurityContext{
0000000000000000000000000000000000000000;;				RunAsUser: &uid,
0000000000000000000000000000000000000000;;				FSGroup:   &gid,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.TestContainerOutput("downward API volume plugin", pod, 0, []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("%s\n", podName),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should provide podname as non-root with fsgroup and defaultMode [Feature:FSGroup] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			podName := "metadata-volume-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			uid := int64(1001)
0000000000000000000000000000000000000000;;			gid := int64(1234)
0000000000000000000000000000000000000000;;			mode := int32(0440) /* setting fsGroup sets mode to at least 440 */
0000000000000000000000000000000000000000;;			pod := projectedDownwardAPIVolumePodForModeTest(podName, "/etc/podname", &mode, nil)
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext = &v1.PodSecurityContext{
0000000000000000000000000000000000000000;;				RunAsUser: &uid,
0000000000000000000000000000000000000000;;				FSGroup:   &gid,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.TestContainerOutput("downward API volume plugin", pod, 0, []string{
0000000000000000000000000000000000000000;;				"mode of file \"/etc/podname\": -r--r-----",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should update labels on modification [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			labels := map[string]string{}
0000000000000000000000000000000000000000;;			labels["key1"] = "value1"
0000000000000000000000000000000000000000;;			labels["key2"] = "value2"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			podName := "labelsupdate" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			pod := projectedDownwardAPIVolumePodForUpdateTest(podName, labels, map[string]string{}, "/etc/labels")
0000000000000000000000000000000000000000;;			containerName := "client-container"
0000000000000000000000000000000000000000;;			By("Creating the pod")
0000000000000000000000000000000000000000;;			podClient.CreateSync(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Eventually(func() (string, error) {
0000000000000000000000000000000000000000;;				return framework.GetPodLogs(f.ClientSet, f.Namespace.Name, podName, containerName)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;				podLogTimeout, framework.Poll).Should(ContainSubstring("key1=\"value1\"\n"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			//modify labels
0000000000000000000000000000000000000000;;			podClient.Update(podName, func(pod *v1.Pod) {
0000000000000000000000000000000000000000;;				pod.Labels["key3"] = "value3"
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Eventually(func() (string, error) {
0000000000000000000000000000000000000000;;				return framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, containerName)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;				podLogTimeout, framework.Poll).Should(ContainSubstring("key3=\"value3\"\n"))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should update annotations on modification [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			annotations := map[string]string{}
0000000000000000000000000000000000000000;;			annotations["builder"] = "bar"
0000000000000000000000000000000000000000;;			podName := "annotationupdate" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			pod := projectedDownwardAPIVolumePodForUpdateTest(podName, map[string]string{}, annotations, "/etc/annotations")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			containerName := "client-container"
0000000000000000000000000000000000000000;;			By("Creating the pod")
0000000000000000000000000000000000000000;;			podClient.CreateSync(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod, err := podClient.Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "Failed to get pod %q", pod.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Eventually(func() (string, error) {
0000000000000000000000000000000000000000;;				return framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, containerName)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;				podLogTimeout, framework.Poll).Should(ContainSubstring("builder=\"bar\"\n"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			//modify annotations
0000000000000000000000000000000000000000;;			podClient.Update(podName, func(pod *v1.Pod) {
0000000000000000000000000000000000000000;;				pod.Annotations["builder"] = "foo"
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Eventually(func() (string, error) {
0000000000000000000000000000000000000000;;				return framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, containerName)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;				podLogTimeout, framework.Poll).Should(ContainSubstring("builder=\"foo\"\n"))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should provide container's cpu limit [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			podName := "downwardapi-volume-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			pod := downwardAPIVolumeForContainerResources(podName, "/etc/cpu_limit")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("downward API volume plugin", pod, 0, []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("2\n"),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should provide container's memory limit [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			podName := "downwardapi-volume-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			pod := downwardAPIVolumeForContainerResources(podName, "/etc/memory_limit")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("downward API volume plugin", pod, 0, []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("67108864\n"),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should provide container's cpu request [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			podName := "downwardapi-volume-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			pod := downwardAPIVolumeForContainerResources(podName, "/etc/cpu_request")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("downward API volume plugin", pod, 0, []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("1\n"),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should provide container's memory request [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			podName := "downwardapi-volume-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			pod := downwardAPIVolumeForContainerResources(podName, "/etc/memory_request")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("downward API volume plugin", pod, 0, []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("33554432\n"),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should provide node allocatable (cpu) as default cpu limit if the limit is not set [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			podName := "downwardapi-volume-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			pod := downwardAPIVolumeForDefaultContainerResources(podName, "/etc/cpu_limit")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutputRegexp("downward API volume plugin", pod, 0, []string{"[1-9]"})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should provide node allocatable (memory) as default memory limit if the limit is not set [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			podName := "downwardapi-volume-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			pod := downwardAPIVolumeForDefaultContainerResources(podName, "/etc/memory_limit")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutputRegexp("downward API volume plugin", pod, 0, []string{"[1-9]"})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test multiple projections
0000000000000000000000000000000000000000;;		It("should project all components that make up the projection API [Conformance] [sig-storage] [Projection]", func() {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			podName := "projected-volume-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			secretName := "secret-projected-all-test-volume-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			configMapName := "configmap-projected-all-test-volume-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			configMap := &v1.ConfigMap{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;					Name:      configMapName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Data: map[string]string{
0000000000000000000000000000000000000000;;					"configmap-data": "configmap-value-1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			secret := &v1.Secret{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;					Name:      secretName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Data: map[string][]byte{
0000000000000000000000000000000000000000;;					"secret-data": []byte("secret-value-1"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating configMap with name %s", configMap.Name))
0000000000000000000000000000000000000000;;			if configMap, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Create(configMap); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test configMap %s: %v", configMap.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating secret with name %s", secret.Name))
0000000000000000000000000000000000000000;;			if secret, err = f.ClientSet.Core().Secrets(f.Namespace.Name).Create(secret); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test secret %s: %v", secret.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod := projectedAllVolumeBasePod(podName, secretName, configMapName, nil, nil)
0000000000000000000000000000000000000000;;			pod.Spec.Containers = []v1.Container{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:    "projected-all-volume-test",
0000000000000000000000000000000000000000;;					Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;					Command: []string{"sh", "-c", "cat /all/podname && cat /all/secret-data && cat /all/configmap-data"},
0000000000000000000000000000000000000000;;					VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:      "podinfo",
0000000000000000000000000000000000000000;;							MountPath: "/all",
0000000000000000000000000000000000000000;;							ReadOnly:  false,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.TestContainerOutput("Check all projections for projected volume plugin", pod, 0, []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("%s", podName),
0000000000000000000000000000000000000000;;				"secret-value-1",
0000000000000000000000000000000000000000;;				"configmap-value-1",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doProjectedSecretE2EWithoutMapping(f *framework.Framework, defaultMode *int32,
0000000000000000000000000000000000000000;;		secretName string, fsGroup *int64, uid *int64) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			volumeName      = "projected-secret-volume"
0000000000000000000000000000000000000000;;			volumeMountPath = "/etc/projected-secret-volume"
0000000000000000000000000000000000000000;;			secret          = secretForTest(f.Namespace.Name, secretName)
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating projection with secret that has name %s", secret.Name))
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if secret, err = f.ClientSet.Core().Secrets(f.Namespace.Name).Create(secret); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("unable to create test secret %s: %v", secret.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "pod-projected-secrets-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: volumeName,
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							Projected: &v1.ProjectedVolumeSource{
0000000000000000000000000000000000000000;;								Sources: []v1.VolumeProjection{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Secret: &v1.SecretProjection{
0000000000000000000000000000000000000000;;											LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;												Name: secretName,
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "projected-secret-volume-test",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;						Args: []string{
0000000000000000000000000000000000000000;;							"--file_content=/etc/projected-secret-volume/data-1",
0000000000000000000000000000000000000000;;							"--file_mode=/etc/projected-secret-volume/data-1"},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      volumeName,
0000000000000000000000000000000000000000;;								MountPath: volumeMountPath,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if defaultMode != nil {
0000000000000000000000000000000000000000;;			//pod.Spec.Volumes[0].VolumeSource.Projected.Sources[0].Secret.DefaultMode = defaultMode
0000000000000000000000000000000000000000;;			pod.Spec.Volumes[0].VolumeSource.Projected.DefaultMode = defaultMode
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			mode := int32(0644)
0000000000000000000000000000000000000000;;			defaultMode = &mode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fsGroup != nil || uid != nil {
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext = &v1.PodSecurityContext{
0000000000000000000000000000000000000000;;				FSGroup:   fsGroup,
0000000000000000000000000000000000000000;;				RunAsUser: uid,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		modeString := fmt.Sprintf("%v", os.FileMode(*defaultMode))
0000000000000000000000000000000000000000;;		expectedOutput := []string{
0000000000000000000000000000000000000000;;			"content of file \"/etc/projected-secret-volume/data-1\": value-1",
0000000000000000000000000000000000000000;;			"mode of file \"/etc/projected-secret-volume/data-1\": " + modeString,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.TestContainerOutput("consume secrets", pod, 0, expectedOutput)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doProjectedSecretE2EWithMapping(f *framework.Framework, mode *int32) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			name            = "projected-secret-test-map-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			volumeName      = "projected-secret-volume"
0000000000000000000000000000000000000000;;			volumeMountPath = "/etc/projected-secret-volume"
0000000000000000000000000000000000000000;;			secret          = secretForTest(f.Namespace.Name, name)
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating projection with secret that has name %s", secret.Name))
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if secret, err = f.ClientSet.Core().Secrets(f.Namespace.Name).Create(secret); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("unable to create test secret %s: %v", secret.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod-projected-secrets-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: volumeName,
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							Projected: &v1.ProjectedVolumeSource{
0000000000000000000000000000000000000000;;								Sources: []v1.VolumeProjection{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Secret: &v1.SecretProjection{
0000000000000000000000000000000000000000;;											LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;												Name: name,
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;											Items: []v1.KeyToPath{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:  "data-1",
0000000000000000000000000000000000000000;;													Path: "new-path-data-1",
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "projected-secret-volume-test",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;						Args: []string{
0000000000000000000000000000000000000000;;							"--file_content=/etc/projected-secret-volume/new-path-data-1",
0000000000000000000000000000000000000000;;							"--file_mode=/etc/projected-secret-volume/new-path-data-1"},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      volumeName,
0000000000000000000000000000000000000000;;								MountPath: volumeMountPath,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mode != nil {
0000000000000000000000000000000000000000;;			//pod.Spec.Volumes[0].VolumeSource.Projected.Sources[0].Secret.Items[0].Mode = mode
0000000000000000000000000000000000000000;;			pod.Spec.Volumes[0].VolumeSource.Projected.DefaultMode = mode
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			defaultItemMode := int32(0644)
0000000000000000000000000000000000000000;;			mode = &defaultItemMode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		modeString := fmt.Sprintf("%v", os.FileMode(*mode))
0000000000000000000000000000000000000000;;		expectedOutput := []string{
0000000000000000000000000000000000000000;;			"content of file \"/etc/projected-secret-volume/new-path-data-1\": value-1",
0000000000000000000000000000000000000000;;			"mode of file \"/etc/projected-secret-volume/new-path-data-1\": " + modeString,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.TestContainerOutput("consume secrets", pod, 0, expectedOutput)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doProjectedConfigMapE2EWithoutMappings(f *framework.Framework, uid, fsGroup int64, defaultMode *int32) {
0000000000000000000000000000000000000000;;		userID := int64(uid)
0000000000000000000000000000000000000000;;		groupID := int64(fsGroup)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			name            = "projected-configmap-test-volume-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			volumeName      = "projected-configmap-volume"
0000000000000000000000000000000000000000;;			volumeMountPath = "/etc/projected-configmap-volume"
0000000000000000000000000000000000000000;;			configMap       = newConfigMap(f, name)
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating configMap with name %s", configMap.Name))
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if configMap, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Create(configMap); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("unable to create test configMap %s: %v", configMap.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod-projected-configmaps-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				SecurityContext: &v1.PodSecurityContext{},
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: volumeName,
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							Projected: &v1.ProjectedVolumeSource{
0000000000000000000000000000000000000000;;								Sources: []v1.VolumeProjection{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										ConfigMap: &v1.ConfigMapProjection{
0000000000000000000000000000000000000000;;											LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;												Name: name,
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "projected-configmap-volume-test",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;						Args: []string{
0000000000000000000000000000000000000000;;							"--file_content=/etc/projected-configmap-volume/data-1",
0000000000000000000000000000000000000000;;							"--file_mode=/etc/projected-configmap-volume/data-1"},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      volumeName,
0000000000000000000000000000000000000000;;								MountPath: volumeMountPath,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if userID != 0 {
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext.RunAsUser = &userID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if groupID != 0 {
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext.FSGroup = &groupID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if defaultMode != nil {
0000000000000000000000000000000000000000;;			//pod.Spec.Volumes[0].VolumeSource.Projected.Sources[0].ConfigMap.DefaultMode = defaultMode
0000000000000000000000000000000000000000;;			pod.Spec.Volumes[0].VolumeSource.Projected.DefaultMode = defaultMode
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			mode := int32(0644)
0000000000000000000000000000000000000000;;			defaultMode = &mode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		modeString := fmt.Sprintf("%v", os.FileMode(*defaultMode))
0000000000000000000000000000000000000000;;		output := []string{
0000000000000000000000000000000000000000;;			"content of file \"/etc/projected-configmap-volume/data-1\": value-1",
0000000000000000000000000000000000000000;;			"mode of file \"/etc/projected-configmap-volume/data-1\": " + modeString,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.TestContainerOutput("consume configMaps", pod, 0, output)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doProjectedConfigMapE2EWithMappings(f *framework.Framework, uid, fsGroup int64, itemMode *int32) {
0000000000000000000000000000000000000000;;		userID := int64(uid)
0000000000000000000000000000000000000000;;		groupID := int64(fsGroup)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			name            = "projected-configmap-test-volume-map-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			volumeName      = "projected-configmap-volume"
0000000000000000000000000000000000000000;;			volumeMountPath = "/etc/projected-configmap-volume"
0000000000000000000000000000000000000000;;			configMap       = newConfigMap(f, name)
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating configMap with name %s", configMap.Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if configMap, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Create(configMap); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("unable to create test configMap %s: %v", configMap.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod-projected-configmaps-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				SecurityContext: &v1.PodSecurityContext{},
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: volumeName,
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							Projected: &v1.ProjectedVolumeSource{
0000000000000000000000000000000000000000;;								Sources: []v1.VolumeProjection{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										ConfigMap: &v1.ConfigMapProjection{
0000000000000000000000000000000000000000;;											LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;												Name: name,
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;											Items: []v1.KeyToPath{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Key:  "data-2",
0000000000000000000000000000000000000000;;													Path: "path/to/data-2",
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "projected-configmap-volume-test",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;						Args: []string{"--file_content=/etc/projected-configmap-volume/path/to/data-2",
0000000000000000000000000000000000000000;;							"--file_mode=/etc/projected-configmap-volume/path/to/data-2"},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      volumeName,
0000000000000000000000000000000000000000;;								MountPath: volumeMountPath,
0000000000000000000000000000000000000000;;								ReadOnly:  true,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if userID != 0 {
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext.RunAsUser = &userID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if groupID != 0 {
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext.FSGroup = &groupID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if itemMode != nil {
0000000000000000000000000000000000000000;;			//pod.Spec.Volumes[0].VolumeSource.ConfigMap.Items[0].Mode = itemMode
0000000000000000000000000000000000000000;;			pod.Spec.Volumes[0].VolumeSource.Projected.DefaultMode = itemMode
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			mode := int32(0644)
0000000000000000000000000000000000000000;;			itemMode = &mode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Just check file mode if fsGroup is not set. If fsGroup is set, the
0000000000000000000000000000000000000000;;		// final mode is adjusted and we are not testing that case.
0000000000000000000000000000000000000000;;		output := []string{
0000000000000000000000000000000000000000;;			"content of file \"/etc/projected-configmap-volume/path/to/data-2\": value-2",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fsGroup == 0 {
0000000000000000000000000000000000000000;;			modeString := fmt.Sprintf("%v", os.FileMode(*itemMode))
0000000000000000000000000000000000000000;;			output = append(output, "mode of file \"/etc/projected-configmap-volume/path/to/data-2\": "+modeString)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.TestContainerOutput("consume configMaps", pod, 0, output)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func projectedDownwardAPIVolumePodForModeTest(name, filePath string, itemMode, defaultMode *int32) *v1.Pod {
0000000000000000000000000000000000000000;;		pod := projectedDownwardAPIVolumeBasePod(name, nil, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod.Spec.Containers = []v1.Container{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name:    "client-container",
0000000000000000000000000000000000000000;;				Image:   "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;				Command: []string{"/mt", "--file_mode=" + filePath},
0000000000000000000000000000000000000000;;				VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:      "podinfo",
0000000000000000000000000000000000000000;;						MountPath: "/etc",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if itemMode != nil {
0000000000000000000000000000000000000000;;			pod.Spec.Volumes[0].VolumeSource.Projected.Sources[0].DownwardAPI.Items[0].Mode = itemMode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if defaultMode != nil {
0000000000000000000000000000000000000000;;			pod.Spec.Volumes[0].VolumeSource.Projected.DefaultMode = defaultMode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func projectedDownwardAPIVolumePodForUpdateTest(name string, labels, annotations map[string]string, filePath string) *v1.Pod {
0000000000000000000000000000000000000000;;		pod := projectedDownwardAPIVolumeBasePod(name, labels, annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod.Spec.Containers = []v1.Container{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name:    "client-container",
0000000000000000000000000000000000000000;;				Image:   "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;				Command: []string{"/mt", "--break_on_expected_content=false", "--retry_time=120", "--file_content_in_loop=" + filePath},
0000000000000000000000000000000000000000;;				VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:      "podinfo",
0000000000000000000000000000000000000000;;						MountPath: "/etc",
0000000000000000000000000000000000000000;;						ReadOnly:  false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		applyLabelsAndAnnotationsToProjectedDownwardAPIPod(labels, annotations, pod)
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func projectedDownwardAPIVolumeBasePod(name string, labels, annotations map[string]string) *v1.Pod {
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        name,
0000000000000000000000000000000000000000;;				Labels:      labels,
0000000000000000000000000000000000000000;;				Annotations: annotations,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "podinfo",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							Projected: &v1.ProjectedVolumeSource{
0000000000000000000000000000000000000000;;								Sources: []v1.VolumeProjection{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										DownwardAPI: &v1.DownwardAPIProjection{
0000000000000000000000000000000000000000;;											Items: []v1.DownwardAPIVolumeFile{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Path: "podname",
0000000000000000000000000000000000000000;;													FieldRef: &v1.ObjectFieldSelector{
0000000000000000000000000000000000000000;;														APIVersion: "v1",
0000000000000000000000000000000000000000;;														FieldPath:  "metadata.name",
0000000000000000000000000000000000000000;;													},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Path: "cpu_limit",
0000000000000000000000000000000000000000;;													ResourceFieldRef: &v1.ResourceFieldSelector{
0000000000000000000000000000000000000000;;														ContainerName: "client-container",
0000000000000000000000000000000000000000;;														Resource:      "limits.cpu",
0000000000000000000000000000000000000000;;													},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Path: "cpu_request",
0000000000000000000000000000000000000000;;													ResourceFieldRef: &v1.ResourceFieldSelector{
0000000000000000000000000000000000000000;;														ContainerName: "client-container",
0000000000000000000000000000000000000000;;														Resource:      "requests.cpu",
0000000000000000000000000000000000000000;;													},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Path: "memory_limit",
0000000000000000000000000000000000000000;;													ResourceFieldRef: &v1.ResourceFieldSelector{
0000000000000000000000000000000000000000;;														ContainerName: "client-container",
0000000000000000000000000000000000000000;;														Resource:      "limits.memory",
0000000000000000000000000000000000000000;;													},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Path: "memory_request",
0000000000000000000000000000000000000000;;													ResourceFieldRef: &v1.ResourceFieldSelector{
0000000000000000000000000000000000000000;;														ContainerName: "client-container",
0000000000000000000000000000000000000000;;														Resource:      "requests.memory",
0000000000000000000000000000000000000000;;													},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func applyLabelsAndAnnotationsToProjectedDownwardAPIPod(labels, annotations map[string]string, pod *v1.Pod) {
0000000000000000000000000000000000000000;;		if len(labels) > 0 {
0000000000000000000000000000000000000000;;			pod.Spec.Volumes[0].VolumeSource.Projected.Sources[0].DownwardAPI.Items = append(pod.Spec.Volumes[0].VolumeSource.Projected.Sources[0].DownwardAPI.Items, v1.DownwardAPIVolumeFile{
0000000000000000000000000000000000000000;;				Path: "labels",
0000000000000000000000000000000000000000;;				FieldRef: &v1.ObjectFieldSelector{
0000000000000000000000000000000000000000;;					APIVersion: "v1",
0000000000000000000000000000000000000000;;					FieldPath:  "metadata.labels",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(annotations) > 0 {
0000000000000000000000000000000000000000;;			pod.Spec.Volumes[0].VolumeSource.Projected.Sources[0].DownwardAPI.Items = append(pod.Spec.Volumes[0].VolumeSource.Projected.Sources[0].DownwardAPI.Items, v1.DownwardAPIVolumeFile{
0000000000000000000000000000000000000000;;				Path: "annotations",
0000000000000000000000000000000000000000;;				FieldRef: &v1.ObjectFieldSelector{
0000000000000000000000000000000000000000;;					APIVersion: "v1",
0000000000000000000000000000000000000000;;					FieldPath:  "metadata.annotations",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func projectedAllVolumeBasePod(podName string, secretName string, configMapName string, labels, annotations map[string]string) *v1.Pod {
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        podName,
0000000000000000000000000000000000000000;;				Labels:      labels,
0000000000000000000000000000000000000000;;				Annotations: annotations,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "podinfo",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							Projected: &v1.ProjectedVolumeSource{
0000000000000000000000000000000000000000;;								Sources: []v1.VolumeProjection{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										DownwardAPI: &v1.DownwardAPIProjection{
0000000000000000000000000000000000000000;;											Items: []v1.DownwardAPIVolumeFile{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Path: "podname",
0000000000000000000000000000000000000000;;													FieldRef: &v1.ObjectFieldSelector{
0000000000000000000000000000000000000000;;														APIVersion: "v1",
0000000000000000000000000000000000000000;;														FieldPath:  "metadata.name",
0000000000000000000000000000000000000000;;													},
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Secret: &v1.SecretProjection{
0000000000000000000000000000000000000000;;											LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;												Name: secretName,
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										ConfigMap: &v1.ConfigMapProjection{
0000000000000000000000000000000000000000;;											LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;												Name: configMapName,
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
