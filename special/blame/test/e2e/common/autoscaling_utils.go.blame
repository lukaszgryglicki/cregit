0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
2d17a596f71e6e484fbdbb8e81c690d22b42ab39;test/e2e/autoscaling_utils.go[test/e2e/autoscaling_utils.go][test/e2e/common/autoscaling_utils.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package common
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		autoscalingv1 "k8s.io/api/autoscaling/v1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		extensionsinternal "k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		testutils "k8s.io/kubernetes/test/utils"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		dynamicConsumptionTimeInSeconds = 30
0000000000000000000000000000000000000000;;		staticConsumptionTimeInSeconds  = 3600
0000000000000000000000000000000000000000;;		dynamicRequestSizeInMillicores  = 20
0000000000000000000000000000000000000000;;		dynamicRequestSizeInMegabytes   = 100
0000000000000000000000000000000000000000;;		dynamicRequestSizeCustomMetric  = 10
0000000000000000000000000000000000000000;;		port                            = 80
0000000000000000000000000000000000000000;;		targetPort                      = 8080
0000000000000000000000000000000000000000;;		timeoutRC                       = 120 * time.Second
0000000000000000000000000000000000000000;;		startServiceTimeout             = time.Minute
0000000000000000000000000000000000000000;;		startServiceInterval            = 5 * time.Second
0000000000000000000000000000000000000000;;		resourceConsumerImage           = "gcr.io/google_containers/resource_consumer:beta4"
0000000000000000000000000000000000000000;;		resourceConsumerControllerImage = "gcr.io/google_containers/resource_consumer/controller:beta4"
0000000000000000000000000000000000000000;;		rcIsNil                         = "ERROR: replicationController = nil"
0000000000000000000000000000000000000000;;		deploymentIsNil                 = "ERROR: deployment = nil"
0000000000000000000000000000000000000000;;		rsIsNil                         = "ERROR: replicaset = nil"
0000000000000000000000000000000000000000;;		invalidKind                     = "ERROR: invalid workload kind for resource consumer"
0000000000000000000000000000000000000000;;		customMetricName                = "QPS"
0000000000000000000000000000000000000000;;		serviceInitializationTimeout    = 2 * time.Minute
0000000000000000000000000000000000000000;;		serviceInitializationInterval   = 15 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		KindRC         = "ReplicationController"
0000000000000000000000000000000000000000;;		KindDeployment = "Deployment"
0000000000000000000000000000000000000000;;		KindReplicaSet = "ReplicaSet"
0000000000000000000000000000000000000000;;		subresource    = "scale"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	ResourceConsumer is a tool for testing. It helps create specified usage of CPU or memory (Warning: memory not supported)
0000000000000000000000000000000000000000;;	typical use case:
0000000000000000000000000000000000000000;;	rc.ConsumeCPU(600)
0000000000000000000000000000000000000000;;	// ... check your assumption here
0000000000000000000000000000000000000000;;	rc.ConsumeCPU(300)
0000000000000000000000000000000000000000;;	// ... check your assumption here
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	type ResourceConsumer struct {
0000000000000000000000000000000000000000;;		name                     string
0000000000000000000000000000000000000000;;		controllerName           string
0000000000000000000000000000000000000000;;		kind                     string
0000000000000000000000000000000000000000;;		framework                *framework.Framework
0000000000000000000000000000000000000000;;		cpu                      chan int
0000000000000000000000000000000000000000;;		mem                      chan int
0000000000000000000000000000000000000000;;		customMetric             chan int
0000000000000000000000000000000000000000;;		stopCPU                  chan int
0000000000000000000000000000000000000000;;		stopMem                  chan int
0000000000000000000000000000000000000000;;		stopCustomMetric         chan int
0000000000000000000000000000000000000000;;		stopWaitGroup            sync.WaitGroup
0000000000000000000000000000000000000000;;		consumptionTimeInSeconds int
0000000000000000000000000000000000000000;;		sleepTime                time.Duration
0000000000000000000000000000000000000000;;		requestSizeInMillicores  int
0000000000000000000000000000000000000000;;		requestSizeInMegabytes   int
0000000000000000000000000000000000000000;;		requestSizeCustomMetric  int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetResourceConsumerImage() string {
0000000000000000000000000000000000000000;;		return resourceConsumerImage
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDynamicResourceConsumer(name, kind string, replicas, initCPUTotal, initMemoryTotal, initCustomMetric int, cpuLimit, memLimit int64, f *framework.Framework) *ResourceConsumer {
0000000000000000000000000000000000000000;;		return newResourceConsumer(name, kind, replicas, initCPUTotal, initMemoryTotal, initCustomMetric, dynamicConsumptionTimeInSeconds,
0000000000000000000000000000000000000000;;			dynamicRequestSizeInMillicores, dynamicRequestSizeInMegabytes, dynamicRequestSizeCustomMetric, cpuLimit, memLimit, f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO this still defaults to replication controller
0000000000000000000000000000000000000000;;	func NewStaticResourceConsumer(name string, replicas, initCPUTotal, initMemoryTotal, initCustomMetric int, cpuLimit, memLimit int64, f *framework.Framework) *ResourceConsumer {
0000000000000000000000000000000000000000;;		return newResourceConsumer(name, KindRC, replicas, initCPUTotal, initMemoryTotal, initCustomMetric, staticConsumptionTimeInSeconds,
0000000000000000000000000000000000000000;;			initCPUTotal/replicas, initMemoryTotal/replicas, initCustomMetric/replicas, cpuLimit, memLimit, f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	NewResourceConsumer creates new ResourceConsumer
0000000000000000000000000000000000000000;;	initCPUTotal argument is in millicores
0000000000000000000000000000000000000000;;	initMemoryTotal argument is in megabytes
0000000000000000000000000000000000000000;;	memLimit argument is in megabytes, memLimit is a maximum amount of memory that can be consumed by a single pod
0000000000000000000000000000000000000000;;	cpuLimit argument is in millicores, cpuLimit is a maximum amount of cpu that can be consumed by a single pod
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func newResourceConsumer(name, kind string, replicas, initCPUTotal, initMemoryTotal, initCustomMetric, consumptionTimeInSeconds, requestSizeInMillicores,
0000000000000000000000000000000000000000;;		requestSizeInMegabytes int, requestSizeCustomMetric int, cpuLimit, memLimit int64, f *framework.Framework) *ResourceConsumer {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runServiceAndWorkloadForResourceConsumer(f.ClientSet, f.InternalClientset, f.Namespace.Name, name, kind, replicas, cpuLimit, memLimit)
0000000000000000000000000000000000000000;;		rc := &ResourceConsumer{
0000000000000000000000000000000000000000;;			name:                     name,
0000000000000000000000000000000000000000;;			controllerName:           name + "-ctrl",
0000000000000000000000000000000000000000;;			kind:                     kind,
0000000000000000000000000000000000000000;;			framework:                f,
0000000000000000000000000000000000000000;;			cpu:                      make(chan int),
0000000000000000000000000000000000000000;;			mem:                      make(chan int),
0000000000000000000000000000000000000000;;			customMetric:             make(chan int),
0000000000000000000000000000000000000000;;			stopCPU:                  make(chan int),
0000000000000000000000000000000000000000;;			stopMem:                  make(chan int),
0000000000000000000000000000000000000000;;			stopCustomMetric:         make(chan int),
0000000000000000000000000000000000000000;;			consumptionTimeInSeconds: consumptionTimeInSeconds,
0000000000000000000000000000000000000000;;			sleepTime:                time.Duration(consumptionTimeInSeconds) * time.Second,
0000000000000000000000000000000000000000;;			requestSizeInMillicores:  requestSizeInMillicores,
0000000000000000000000000000000000000000;;			requestSizeInMegabytes:   requestSizeInMegabytes,
0000000000000000000000000000000000000000;;			requestSizeCustomMetric:  requestSizeCustomMetric,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go rc.makeConsumeCPURequests()
0000000000000000000000000000000000000000;;		rc.ConsumeCPU(initCPUTotal)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go rc.makeConsumeMemRequests()
0000000000000000000000000000000000000000;;		rc.ConsumeMem(initMemoryTotal)
0000000000000000000000000000000000000000;;		go rc.makeConsumeCustomMetric()
0000000000000000000000000000000000000000;;		rc.ConsumeCustomMetric(initCustomMetric)
0000000000000000000000000000000000000000;;		return rc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConsumeCPU consumes given number of CPU
0000000000000000000000000000000000000000;;	func (rc *ResourceConsumer) ConsumeCPU(millicores int) {
0000000000000000000000000000000000000000;;		framework.Logf("RC %s: consume %v millicores in total", rc.name, millicores)
0000000000000000000000000000000000000000;;		rc.cpu <- millicores
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConsumeMem consumes given number of Mem
0000000000000000000000000000000000000000;;	func (rc *ResourceConsumer) ConsumeMem(megabytes int) {
0000000000000000000000000000000000000000;;		framework.Logf("RC %s: consume %v MB in total", rc.name, megabytes)
0000000000000000000000000000000000000000;;		rc.mem <- megabytes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConsumeMem consumes given number of custom metric
0000000000000000000000000000000000000000;;	func (rc *ResourceConsumer) ConsumeCustomMetric(amount int) {
0000000000000000000000000000000000000000;;		framework.Logf("RC %s: consume custom metric %v in total", rc.name, amount)
0000000000000000000000000000000000000000;;		rc.customMetric <- amount
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *ResourceConsumer) makeConsumeCPURequests() {
0000000000000000000000000000000000000000;;		defer GinkgoRecover()
0000000000000000000000000000000000000000;;		rc.stopWaitGroup.Add(1)
0000000000000000000000000000000000000000;;		defer rc.stopWaitGroup.Done()
0000000000000000000000000000000000000000;;		sleepTime := time.Duration(0)
0000000000000000000000000000000000000000;;		millicores := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case millicores = <-rc.cpu:
0000000000000000000000000000000000000000;;				framework.Logf("RC %s: setting consumption to %v millicores in total", rc.name, millicores)
0000000000000000000000000000000000000000;;			case <-time.After(sleepTime):
0000000000000000000000000000000000000000;;				framework.Logf("RC %s: sending request to consume %d millicores", rc.name, millicores)
0000000000000000000000000000000000000000;;				rc.sendConsumeCPURequest(millicores)
0000000000000000000000000000000000000000;;				sleepTime = rc.sleepTime
0000000000000000000000000000000000000000;;			case <-rc.stopCPU:
0000000000000000000000000000000000000000;;				framework.Logf("RC %s: stopping CPU consumer", rc.name)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *ResourceConsumer) makeConsumeMemRequests() {
0000000000000000000000000000000000000000;;		defer GinkgoRecover()
0000000000000000000000000000000000000000;;		rc.stopWaitGroup.Add(1)
0000000000000000000000000000000000000000;;		defer rc.stopWaitGroup.Done()
0000000000000000000000000000000000000000;;		sleepTime := time.Duration(0)
0000000000000000000000000000000000000000;;		megabytes := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case megabytes = <-rc.mem:
0000000000000000000000000000000000000000;;				framework.Logf("RC %s: setting consumption to %v MB in total", rc.name, megabytes)
0000000000000000000000000000000000000000;;			case <-time.After(sleepTime):
0000000000000000000000000000000000000000;;				framework.Logf("RC %s: sending request to consume %d MB", rc.name, megabytes)
0000000000000000000000000000000000000000;;				rc.sendConsumeMemRequest(megabytes)
0000000000000000000000000000000000000000;;				sleepTime = rc.sleepTime
0000000000000000000000000000000000000000;;			case <-rc.stopMem:
0000000000000000000000000000000000000000;;				framework.Logf("RC %s: stopping mem consumer", rc.name)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *ResourceConsumer) makeConsumeCustomMetric() {
0000000000000000000000000000000000000000;;		defer GinkgoRecover()
0000000000000000000000000000000000000000;;		rc.stopWaitGroup.Add(1)
0000000000000000000000000000000000000000;;		defer rc.stopWaitGroup.Done()
0000000000000000000000000000000000000000;;		sleepTime := time.Duration(0)
0000000000000000000000000000000000000000;;		delta := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case delta := <-rc.customMetric:
0000000000000000000000000000000000000000;;				framework.Logf("RC %s: setting bump of metric %s to %d in total", rc.name, customMetricName, delta)
0000000000000000000000000000000000000000;;			case <-time.After(sleepTime):
0000000000000000000000000000000000000000;;				framework.Logf("RC %s: sending request to consume %d of custom metric %s", rc.name, delta, customMetricName)
0000000000000000000000000000000000000000;;				rc.sendConsumeCustomMetric(delta)
0000000000000000000000000000000000000000;;				sleepTime = rc.sleepTime
0000000000000000000000000000000000000000;;			case <-rc.stopCustomMetric:
0000000000000000000000000000000000000000;;				framework.Logf("RC %s: stopping metric consumer", rc.name)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *ResourceConsumer) sendConsumeCPURequest(millicores int) {
0000000000000000000000000000000000000000;;		proxyRequest, err := framework.GetServicesProxyRequest(rc.framework.ClientSet, rc.framework.ClientSet.Core().RESTClient().Post())
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithTimeout(context.Background(), framework.SingleCallTimeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(serviceInitializationInterval, serviceInitializationTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			req := proxyRequest.Namespace(rc.framework.Namespace.Name).
0000000000000000000000000000000000000000;;				Context(ctx).
0000000000000000000000000000000000000000;;				Name(rc.controllerName).
0000000000000000000000000000000000000000;;				Suffix("ConsumeCPU").
0000000000000000000000000000000000000000;;				Param("millicores", strconv.Itoa(millicores)).
0000000000000000000000000000000000000000;;				Param("durationSec", strconv.Itoa(rc.consumptionTimeInSeconds)).
0000000000000000000000000000000000000000;;				Param("requestSizeMillicores", strconv.Itoa(rc.requestSizeInMillicores))
0000000000000000000000000000000000000000;;			framework.Logf("ConsumeCPU URL: %v", *req.URL())
0000000000000000000000000000000000000000;;			_, err := req.DoRaw()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("ConsumeCPU failure: %v", err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sendConsumeMemRequest sends POST request for memory consumption
0000000000000000000000000000000000000000;;	func (rc *ResourceConsumer) sendConsumeMemRequest(megabytes int) {
0000000000000000000000000000000000000000;;		proxyRequest, err := framework.GetServicesProxyRequest(rc.framework.ClientSet, rc.framework.ClientSet.Core().RESTClient().Post())
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithTimeout(context.Background(), framework.SingleCallTimeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(serviceInitializationInterval, serviceInitializationTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			req := proxyRequest.Namespace(rc.framework.Namespace.Name).
0000000000000000000000000000000000000000;;				Context(ctx).
0000000000000000000000000000000000000000;;				Name(rc.controllerName).
0000000000000000000000000000000000000000;;				Suffix("ConsumeMem").
0000000000000000000000000000000000000000;;				Param("megabytes", strconv.Itoa(megabytes)).
0000000000000000000000000000000000000000;;				Param("durationSec", strconv.Itoa(rc.consumptionTimeInSeconds)).
0000000000000000000000000000000000000000;;				Param("requestSizeMegabytes", strconv.Itoa(rc.requestSizeInMegabytes))
0000000000000000000000000000000000000000;;			framework.Logf("ConsumeMem URL: %v", *req.URL())
0000000000000000000000000000000000000000;;			_, err := req.DoRaw()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("ConsumeMem failure: %v", err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sendConsumeCustomMetric sends POST request for custom metric consumption
0000000000000000000000000000000000000000;;	func (rc *ResourceConsumer) sendConsumeCustomMetric(delta int) {
0000000000000000000000000000000000000000;;		proxyRequest, err := framework.GetServicesProxyRequest(rc.framework.ClientSet, rc.framework.ClientSet.Core().RESTClient().Post())
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithTimeout(context.Background(), framework.SingleCallTimeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(serviceInitializationInterval, serviceInitializationTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			req := proxyRequest.Namespace(rc.framework.Namespace.Name).
0000000000000000000000000000000000000000;;				Context(ctx).
0000000000000000000000000000000000000000;;				Name(rc.controllerName).
0000000000000000000000000000000000000000;;				Suffix("BumpMetric").
0000000000000000000000000000000000000000;;				Param("metric", customMetricName).
0000000000000000000000000000000000000000;;				Param("delta", strconv.Itoa(delta)).
0000000000000000000000000000000000000000;;				Param("durationSec", strconv.Itoa(rc.consumptionTimeInSeconds)).
0000000000000000000000000000000000000000;;				Param("requestSizeMetrics", strconv.Itoa(rc.requestSizeCustomMetric))
0000000000000000000000000000000000000000;;			framework.Logf("ConsumeCustomMetric URL: %v", *req.URL())
0000000000000000000000000000000000000000;;			_, err := req.DoRaw()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("ConsumeCustomMetric failure: %v", err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *ResourceConsumer) GetReplicas() int {
0000000000000000000000000000000000000000;;		switch rc.kind {
0000000000000000000000000000000000000000;;		case KindRC:
0000000000000000000000000000000000000000;;			replicationController, err := rc.framework.ClientSet.Core().ReplicationControllers(rc.framework.Namespace.Name).Get(rc.name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			if replicationController == nil {
0000000000000000000000000000000000000000;;				framework.Failf(rcIsNil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return int(replicationController.Status.ReadyReplicas)
0000000000000000000000000000000000000000;;		case KindDeployment:
0000000000000000000000000000000000000000;;			deployment, err := rc.framework.ClientSet.Extensions().Deployments(rc.framework.Namespace.Name).Get(rc.name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			if deployment == nil {
0000000000000000000000000000000000000000;;				framework.Failf(deploymentIsNil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return int(deployment.Status.ReadyReplicas)
0000000000000000000000000000000000000000;;		case KindReplicaSet:
0000000000000000000000000000000000000000;;			rs, err := rc.framework.ClientSet.Extensions().ReplicaSets(rc.framework.Namespace.Name).Get(rc.name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			if rs == nil {
0000000000000000000000000000000000000000;;				framework.Failf(rsIsNil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return int(rs.Status.ReadyReplicas)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			framework.Failf(invalidKind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *ResourceConsumer) WaitForReplicas(desiredReplicas int, duration time.Duration) {
0000000000000000000000000000000000000000;;		interval := 20 * time.Second
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(interval, duration, func() (bool, error) {
0000000000000000000000000000000000000000;;			replicas := rc.GetReplicas()
0000000000000000000000000000000000000000;;			framework.Logf("waiting for %d replicas (current: %d)", desiredReplicas, replicas)
0000000000000000000000000000000000000000;;			return replicas == desiredReplicas, nil // Expected number of replicas found. Exit.
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		framework.ExpectNoErrorWithOffset(1, err, "timeout waiting %v for %d replicas", duration, desiredReplicas)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *ResourceConsumer) EnsureDesiredReplicas(desiredReplicas int, duration time.Duration) {
0000000000000000000000000000000000000000;;		interval := 10 * time.Second
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(interval, duration, func() (bool, error) {
0000000000000000000000000000000000000000;;			replicas := rc.GetReplicas()
0000000000000000000000000000000000000000;;			framework.Logf("expecting there to be %d replicas (are: %d)", desiredReplicas, replicas)
0000000000000000000000000000000000000000;;			if replicas != desiredReplicas {
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("number of replicas changed unexpectedly")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return false, nil // Expected number of replicas found. Continue polling until timeout.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		// The call above always returns an error, but if it is timeout, it's OK (condition satisfied all the time).
0000000000000000000000000000000000000000;;		if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			framework.Logf("Number of replicas was stable over %v", duration)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.ExpectNoErrorWithOffset(1, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pause stops background goroutines responsible for consuming resources.
0000000000000000000000000000000000000000;;	func (rc *ResourceConsumer) Pause() {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("HPA pausing RC %s", rc.name))
0000000000000000000000000000000000000000;;		rc.stopCPU <- 0
0000000000000000000000000000000000000000;;		rc.stopMem <- 0
0000000000000000000000000000000000000000;;		rc.stopCustomMetric <- 0
0000000000000000000000000000000000000000;;		rc.stopWaitGroup.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pause starts background goroutines responsible for consuming resources.
0000000000000000000000000000000000000000;;	func (rc *ResourceConsumer) Resume() {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("HPA resuming RC %s", rc.name))
0000000000000000000000000000000000000000;;		go rc.makeConsumeCPURequests()
0000000000000000000000000000000000000000;;		go rc.makeConsumeMemRequests()
0000000000000000000000000000000000000000;;		go rc.makeConsumeCustomMetric()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *ResourceConsumer) CleanUp() {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Removing consuming RC %s", rc.name))
0000000000000000000000000000000000000000;;		close(rc.stopCPU)
0000000000000000000000000000000000000000;;		close(rc.stopMem)
0000000000000000000000000000000000000000;;		close(rc.stopCustomMetric)
0000000000000000000000000000000000000000;;		rc.stopWaitGroup.Wait()
0000000000000000000000000000000000000000;;		// Wait some time to ensure all child goroutines are finished.
0000000000000000000000000000000000000000;;		time.Sleep(10 * time.Second)
0000000000000000000000000000000000000000;;		kind, err := kindOf(rc.kind)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.DeleteResourceAndPods(rc.framework.ClientSet, rc.framework.InternalClientset, kind, rc.framework.Namespace.Name, rc.name))
0000000000000000000000000000000000000000;;		framework.ExpectNoError(rc.framework.ClientSet.Core().Services(rc.framework.Namespace.Name).Delete(rc.name, nil))
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.DeleteResourceAndPods(rc.framework.ClientSet, rc.framework.InternalClientset, api.Kind("ReplicationController"), rc.framework.Namespace.Name, rc.controllerName))
0000000000000000000000000000000000000000;;		framework.ExpectNoError(rc.framework.ClientSet.Core().Services(rc.framework.Namespace.Name).Delete(rc.controllerName, nil))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func kindOf(kind string) (schema.GroupKind, error) {
0000000000000000000000000000000000000000;;		switch kind {
0000000000000000000000000000000000000000;;		case KindRC:
0000000000000000000000000000000000000000;;			return api.Kind(kind), nil
0000000000000000000000000000000000000000;;		case KindReplicaSet:
0000000000000000000000000000000000000000;;			return extensionsinternal.Kind(kind), nil
0000000000000000000000000000000000000000;;		case KindDeployment:
0000000000000000000000000000000000000000;;			return extensionsinternal.Kind(kind), nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return schema.GroupKind{}, fmt.Errorf("Unsupported kind: %v", kind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func runServiceAndWorkloadForResourceConsumer(c clientset.Interface, internalClient internalclientset.Interface, ns, name, kind string, replicas int, cpuLimitMillis, memLimitMb int64) {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Running consuming RC %s via %s with %v replicas", name, kind, replicas))
0000000000000000000000000000000000000000;;		_, err := c.Core().Services(ns).Create(&v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       port,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(targetPort),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Selector: map[string]string{
0000000000000000000000000000000000000000;;					"name": name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rcConfig := testutils.RCConfig{
0000000000000000000000000000000000000000;;			Client:         c,
0000000000000000000000000000000000000000;;			InternalClient: internalClient,
0000000000000000000000000000000000000000;;			Image:          resourceConsumerImage,
0000000000000000000000000000000000000000;;			Name:           name,
0000000000000000000000000000000000000000;;			Namespace:      ns,
0000000000000000000000000000000000000000;;			Timeout:        timeoutRC,
0000000000000000000000000000000000000000;;			Replicas:       replicas,
0000000000000000000000000000000000000000;;			CpuRequest:     cpuLimitMillis,
0000000000000000000000000000000000000000;;			CpuLimit:       cpuLimitMillis,
0000000000000000000000000000000000000000;;			MemRequest:     memLimitMb * 1024 * 1024, // MemLimit is in bytes
0000000000000000000000000000000000000000;;			MemLimit:       memLimitMb * 1024 * 1024,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch kind {
0000000000000000000000000000000000000000;;		case KindRC:
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.RunRC(rcConfig))
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		case KindDeployment:
0000000000000000000000000000000000000000;;			dpConfig := testutils.DeploymentConfig{
0000000000000000000000000000000000000000;;				RCConfig: rcConfig,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.RunDeployment(dpConfig))
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		case KindReplicaSet:
0000000000000000000000000000000000000000;;			rsConfig := testutils.ReplicaSetConfig{
0000000000000000000000000000000000000000;;				RCConfig: rcConfig,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("creating replicaset %s in namespace %s", rsConfig.Name, rsConfig.Namespace))
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.RunReplicaSet(rsConfig))
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			framework.Failf(invalidKind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Running controller"))
0000000000000000000000000000000000000000;;		controllerName := name + "-ctrl"
0000000000000000000000000000000000000000;;		_, err = c.Core().Services(ns).Create(&v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: controllerName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       port,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(targetPort),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Selector: map[string]string{
0000000000000000000000000000000000000000;;					"name": controllerName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dnsClusterFirst := v1.DNSClusterFirst
0000000000000000000000000000000000000000;;		controllerRcConfig := testutils.RCConfig{
0000000000000000000000000000000000000000;;			Client:    c,
0000000000000000000000000000000000000000;;			Image:     resourceConsumerControllerImage,
0000000000000000000000000000000000000000;;			Name:      controllerName,
0000000000000000000000000000000000000000;;			Namespace: ns,
0000000000000000000000000000000000000000;;			Timeout:   timeoutRC,
0000000000000000000000000000000000000000;;			Replicas:  1,
0000000000000000000000000000000000000000;;			Command:   []string{"/controller", "--consumer-service-name=" + name, "--consumer-service-namespace=" + ns, "--consumer-port=80"},
0000000000000000000000000000000000000000;;			DNSPolicy: &dnsClusterFirst,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.RunRC(controllerRcConfig))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for endpoints to propagate for the controller service.
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.WaitForServiceEndpointsNum(
0000000000000000000000000000000000000000;;			c, ns, controllerName, 1, startServiceInterval, startServiceTimeout))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreateCPUHorizontalPodAutoscaler(rc *ResourceConsumer, cpu, minReplicas, maxRepl int32) *autoscalingv1.HorizontalPodAutoscaler {
0000000000000000000000000000000000000000;;		hpa := &autoscalingv1.HorizontalPodAutoscaler{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      rc.name,
0000000000000000000000000000000000000000;;				Namespace: rc.framework.Namespace.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: autoscalingv1.HorizontalPodAutoscalerSpec{
0000000000000000000000000000000000000000;;				ScaleTargetRef: autoscalingv1.CrossVersionObjectReference{
0000000000000000000000000000000000000000;;					Kind: rc.kind,
0000000000000000000000000000000000000000;;					Name: rc.name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				MinReplicas:                    &minReplicas,
0000000000000000000000000000000000000000;;				MaxReplicas:                    maxRepl,
0000000000000000000000000000000000000000;;				TargetCPUUtilizationPercentage: &cpu,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hpa, errHPA := rc.framework.ClientSet.Autoscaling().HorizontalPodAutoscalers(rc.framework.Namespace.Name).Create(hpa)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(errHPA)
0000000000000000000000000000000000000000;;		return hpa
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DeleteHorizontalPodAutoscaler(rc *ResourceConsumer, autoscalerName string) {
0000000000000000000000000000000000000000;;		rc.framework.ClientSet.Autoscaling().HorizontalPodAutoscalers(rc.framework.Namespace.Name).Delete(autoscalerName, nil)
0000000000000000000000000000000000000000;;	}
