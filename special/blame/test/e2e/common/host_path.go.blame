0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
80a221cf4c2588381d323a34fc6f840be379a652;test/e2e/host_path.go[test/e2e/host_path.go][test/e2e/common/host_path.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package common
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//TODO : Consolidate this code with the code for emptyDir.
0000000000000000000000000000000000000000;;	//This will require some smart.
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("HostPath", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("hostpath")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			// TODO permission denied cleanup failures
0000000000000000000000000000000000000000;;			//cleanup before running the test.
0000000000000000000000000000000000000000;;			_ = os.Remove("/tmp/test-file")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should give a volume the correct mode [Conformance] [sig-storage]", func() {
0000000000000000000000000000000000000000;;			source := &v1.HostPathVolumeSource{
0000000000000000000000000000000000000000;;				Path: "/tmp",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod := testPodWithHostVol(volumePath, source)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod.Spec.Containers[0].Args = []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("--fs_type=%v", volumePath),
0000000000000000000000000000000000000000;;				fmt.Sprintf("--file_mode=%v", volumePath),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.TestContainerOutput("hostPath mode", pod, 0, []string{
0000000000000000000000000000000000000000;;				"mode of file \"/test-volume\": dtrwxrwxrwx", // we expect the sticky bit (mode flag t) to be set for the dir
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This test requires mounting a folder into a container with write privileges.
0000000000000000000000000000000000000000;;		It("should support r/w [sig-storage]", func() {
0000000000000000000000000000000000000000;;			filePath := path.Join(volumePath, "test-file")
0000000000000000000000000000000000000000;;			retryDuration := 180
0000000000000000000000000000000000000000;;			source := &v1.HostPathVolumeSource{
0000000000000000000000000000000000000000;;				Path: "/tmp",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod := testPodWithHostVol(volumePath, source)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod.Spec.Containers[0].Args = []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("--new_file_0644=%v", filePath),
0000000000000000000000000000000000000000;;				fmt.Sprintf("--file_mode=%v", filePath),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod.Spec.Containers[1].Args = []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("--file_content_in_loop=%v", filePath),
0000000000000000000000000000000000000000;;				fmt.Sprintf("--retry_time=%d", retryDuration),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			//Read the content of the file with the second container to
0000000000000000000000000000000000000000;;			//verify volumes  being shared properly among containers within the pod.
0000000000000000000000000000000000000000;;			f.TestContainerOutput("hostPath r/w", pod, 1, []string{
0000000000000000000000000000000000000000;;				"content of file \"/test-volume/test-file\": mount-tester new file",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should support subPath [sig-storage]", func() {
0000000000000000000000000000000000000000;;			subPath := "sub-path"
0000000000000000000000000000000000000000;;			fileName := "test-file"
0000000000000000000000000000000000000000;;			retryDuration := 180
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			filePathInWriter := path.Join(volumePath, fileName)
0000000000000000000000000000000000000000;;			filePathInReader := path.Join(volumePath, subPath, fileName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			source := &v1.HostPathVolumeSource{
0000000000000000000000000000000000000000;;				Path: "/tmp",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod := testPodWithHostVol(volumePath, source)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Write the file in the subPath from container 0
0000000000000000000000000000000000000000;;			container := &pod.Spec.Containers[0]
0000000000000000000000000000000000000000;;			container.VolumeMounts[0].SubPath = subPath
0000000000000000000000000000000000000000;;			container.Args = []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("--new_file_0644=%v", filePathInWriter),
0000000000000000000000000000000000000000;;				fmt.Sprintf("--file_mode=%v", filePathInWriter),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Read it from outside the subPath from container 1
0000000000000000000000000000000000000000;;			pod.Spec.Containers[1].Args = []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("--file_content_in_loop=%v", filePathInReader),
0000000000000000000000000000000000000000;;				fmt.Sprintf("--retry_time=%d", retryDuration),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("hostPath subPath", pod, 1, []string{
0000000000000000000000000000000000000000;;				"content of file \"" + filePathInReader + "\": mount-tester new file",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should support existing directory subPath [sig-storage]", func() {
0000000000000000000000000000000000000000;;			framework.SkipUnlessSSHKeyPresent()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			subPath := "sub-path"
0000000000000000000000000000000000000000;;			fileName := "test-file"
0000000000000000000000000000000000000000;;			retryDuration := 180
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			filePathInWriter := path.Join(volumePath, fileName)
0000000000000000000000000000000000000000;;			filePathInReader := path.Join(volumePath, subPath, fileName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			source := &v1.HostPathVolumeSource{
0000000000000000000000000000000000000000;;				Path: "/tmp",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod := testPodWithHostVol(volumePath, source)
0000000000000000000000000000000000000000;;			nodeList := framework.GetReadySchedulableNodesOrDie(f.ClientSet)
0000000000000000000000000000000000000000;;			pod.Spec.NodeName = nodeList.Items[0].Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create the subPath directory on the host
0000000000000000000000000000000000000000;;			existing := path.Join(source.Path, subPath)
0000000000000000000000000000000000000000;;			result, err := framework.SSH(fmt.Sprintf("mkdir -p %s", existing), framework.GetNodeExternalIP(&nodeList.Items[0]), framework.TestContext.Provider)
0000000000000000000000000000000000000000;;			framework.LogSSHResult(result)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			if result.Code != 0 {
0000000000000000000000000000000000000000;;				framework.Failf("mkdir returned non-zero")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Write the file in the subPath from container 0
0000000000000000000000000000000000000000;;			container := &pod.Spec.Containers[0]
0000000000000000000000000000000000000000;;			container.VolumeMounts[0].SubPath = subPath
0000000000000000000000000000000000000000;;			container.Args = []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("--new_file_0644=%v", filePathInWriter),
0000000000000000000000000000000000000000;;				fmt.Sprintf("--file_mode=%v", filePathInWriter),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Read it from outside the subPath from container 1
0000000000000000000000000000000000000000;;			pod.Spec.Containers[1].Args = []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("--file_content_in_loop=%v", filePathInReader),
0000000000000000000000000000000000000000;;				fmt.Sprintf("--retry_time=%d", retryDuration),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("hostPath subPath", pod, 1, []string{
0000000000000000000000000000000000000000;;				"content of file \"" + filePathInReader + "\": mount-tester new file",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO consolidate common code of this test and above
0000000000000000000000000000000000000000;;		It("should support existing single file subPath [sig-storage]", func() {
0000000000000000000000000000000000000000;;			framework.SkipUnlessSSHKeyPresent()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			subPath := "sub-path-test-file"
0000000000000000000000000000000000000000;;			retryDuration := 180
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			filePathInReader := path.Join(volumePath, subPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			source := &v1.HostPathVolumeSource{
0000000000000000000000000000000000000000;;				Path: "/tmp",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod := testPodWithHostVol(volumePath, source)
0000000000000000000000000000000000000000;;			nodeList := framework.GetReadySchedulableNodesOrDie(f.ClientSet)
0000000000000000000000000000000000000000;;			pod.Spec.NodeName = nodeList.Items[0].Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create the subPath file on the host
0000000000000000000000000000000000000000;;			existing := path.Join(source.Path, subPath)
0000000000000000000000000000000000000000;;			result, err := framework.SSH(fmt.Sprintf("echo \"mount-tester new file\" > %s", existing), framework.GetNodeExternalIP(&nodeList.Items[0]), framework.TestContext.Provider)
0000000000000000000000000000000000000000;;			framework.LogSSHResult(result)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			if result.Code != 0 {
0000000000000000000000000000000000000000;;				framework.Failf("echo returned non-zero")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Mount the file to the subPath in container 0
0000000000000000000000000000000000000000;;			container := &pod.Spec.Containers[0]
0000000000000000000000000000000000000000;;			container.VolumeMounts[0].SubPath = subPath
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Read it from outside the subPath from container 1
0000000000000000000000000000000000000000;;			pod.Spec.Containers[1].Args = []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("--file_content_in_loop=%v", filePathInReader),
0000000000000000000000000000000000000000;;				fmt.Sprintf("--retry_time=%d", retryDuration),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("hostPath subPath", pod, 1, []string{
0000000000000000000000000000000000000000;;				"content of file \"" + filePathInReader + "\": mount-tester new file",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//These constants are borrowed from the other test.
0000000000000000000000000000000000000000;;	//const volumeName = "test-volume"
0000000000000000000000000000000000000000;;	const containerName1 = "test-container-1"
0000000000000000000000000000000000000000;;	const containerName2 = "test-container-2"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mount(source *v1.HostPathVolumeSource) []v1.Volume {
0000000000000000000000000000000000000000;;		return []v1.Volume{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: volumeName,
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					HostPath: source,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//TODO: To merge this with the emptyDir tests, we can make source a lambda.
0000000000000000000000000000000000000000;;	func testPodWithHostVol(path string, source *v1.HostPathVolumeSource) *v1.Pod {
0000000000000000000000000000000000000000;;		podName := "pod-host-path-test"
0000000000000000000000000000000000000000;;		privileged := true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: podName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  containerName1,
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      volumeName,
0000000000000000000000000000000000000000;;								MountPath: path,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						SecurityContext: &v1.SecurityContext{
0000000000000000000000000000000000000000;;							Privileged: &privileged,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  containerName2,
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      volumeName,
0000000000000000000000000000000000000000;;								MountPath: path,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						SecurityContext: &v1.SecurityContext{
0000000000000000000000000000000000000000;;							Privileged: &privileged,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				Volumes:       mount(source),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
