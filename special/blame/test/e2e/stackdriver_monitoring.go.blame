0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
01aeb47db56067954939868e4cc922daadf38b59;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2/google"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/common"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gcm "google.golang.org/api/monitoring/v3"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Stackdriver container metrics, as described here:
0000000000000000000000000000000000000000;;		// https://cloud.google.com/monitoring/api/metrics#gcp-container
0000000000000000000000000000000000000000;;		stackdriverMetrics = []string{
0000000000000000000000000000000000000000;;			"uptime",
0000000000000000000000000000000000000000;;			"memory/bytes_total",
0000000000000000000000000000000000000000;;			"memory/bytes_used",
0000000000000000000000000000000000000000;;			"cpu/reserved_cores",
0000000000000000000000000000000000000000;;			"cpu/usage_time",
0000000000000000000000000000000000000000;;			"memory/page_fault_count",
0000000000000000000000000000000000000000;;			"disk/bytes_used",
0000000000000000000000000000000000000000;;			"disk/bytes_total",
0000000000000000000000000000000000000000;;			"cpu/utilization",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pollFrequency = time.Second * 5
0000000000000000000000000000000000000000;;		pollTimeout   = time.Minute * 7
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rcName            = "resource-consumer"
0000000000000000000000000000000000000000;;		memoryUsed        = 64
0000000000000000000000000000000000000000;;		memoryLimit int64 = 200
0000000000000000000000000000000000000000;;		tolerance         = 0.25
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Stackdriver Monitoring", func() {
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			framework.SkipUnlessProviderIs("gke")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("stackdriver-monitoring")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should have cluster metrics [Feature:StackdriverMonitoring]", func() {
0000000000000000000000000000000000000000;;			testStackdriverMonitoring(f, 1, 100, 200)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testStackdriverMonitoring(f *framework.Framework, pods, allPodsCPU int, perPodCPU int64) {
0000000000000000000000000000000000000000;;		projectId := framework.TestContext.CloudConfig.ProjectID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx := context.Background()
0000000000000000000000000000000000000000;;		client, err := google.DefaultClient(ctx, gcm.CloudPlatformScope)
0000000000000000000000000000000000000000;;		gcmService, err := gcm.New(client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set this env var if accessing Stackdriver test endpoint (default is prod):
0000000000000000000000000000000000000000;;		// $ export STACKDRIVER_API_ENDPOINT_OVERRIDE=https://test-monitoring.sandbox.googleapis.com/
0000000000000000000000000000000000000000;;		basePathOverride := os.Getenv("STACKDRIVER_API_ENDPOINT_OVERRIDE")
0000000000000000000000000000000000000000;;		if basePathOverride != "" {
0000000000000000000000000000000000000000;;			gcmService.BasePath = basePathOverride
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rc := common.NewDynamicResourceConsumer(rcName, common.KindDeployment, pods, allPodsCPU, memoryUsed, 0, perPodCPU, memoryLimit, f)
0000000000000000000000000000000000000000;;		defer rc.CleanUp()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rc.WaitForReplicas(pods, 15*time.Minute)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metricsMap := map[string]bool{}
0000000000000000000000000000000000000000;;		pollingFunction := checkForMetrics(projectId, gcmService, time.Now(), metricsMap, allPodsCPU, perPodCPU)
0000000000000000000000000000000000000000;;		err = wait.Poll(pollFrequency, pollTimeout, pollingFunction)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Logf("Missing metrics: %+v\n", metricsMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkForMetrics(projectId string, gcmService *gcm.Service, start time.Time, metricsMap map[string]bool, cpuUsed int, cpuLimit int64) func() (bool, error) {
0000000000000000000000000000000000000000;;		return func() (bool, error) {
0000000000000000000000000000000000000000;;			counter := 0
0000000000000000000000000000000000000000;;			correctUtilization := false
0000000000000000000000000000000000000000;;			for _, metric := range stackdriverMetrics {
0000000000000000000000000000000000000000;;				metricsMap[metric] = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, metric := range stackdriverMetrics {
0000000000000000000000000000000000000000;;				// TODO: check only for metrics from this cluster
0000000000000000000000000000000000000000;;				ts, err := fetchTimeSeries(projectId, gcmService, metric, start, time.Now())
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;				if len(ts) > 0 {
0000000000000000000000000000000000000000;;					counter = counter + 1
0000000000000000000000000000000000000000;;					metricsMap[metric] = true
0000000000000000000000000000000000000000;;					framework.Logf("Received %v timeseries for metric %v\n", len(ts), metric)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					framework.Logf("No timeseries for metric %v\n", metric)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var sum float64 = 0
0000000000000000000000000000000000000000;;				switch metric {
0000000000000000000000000000000000000000;;				case "cpu/utilization":
0000000000000000000000000000000000000000;;					for _, t := range ts {
0000000000000000000000000000000000000000;;						max := t.Points[0]
0000000000000000000000000000000000000000;;						maxEnd, _ := time.Parse(time.RFC3339, max.Interval.EndTime)
0000000000000000000000000000000000000000;;						for _, p := range t.Points {
0000000000000000000000000000000000000000;;							pEnd, _ := time.Parse(time.RFC3339, p.Interval.EndTime)
0000000000000000000000000000000000000000;;							if pEnd.After(maxEnd) {
0000000000000000000000000000000000000000;;								max = p
0000000000000000000000000000000000000000;;								maxEnd, _ = time.Parse(time.RFC3339, max.Interval.EndTime)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						sum = sum + *max.Value.DoubleValue
0000000000000000000000000000000000000000;;						framework.Logf("Received %v points for metric %v\n",
0000000000000000000000000000000000000000;;							len(t.Points), metric)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					framework.Logf("Most recent cpu/utilization sum*cpu/limit: %v\n", sum*float64(cpuLimit))
0000000000000000000000000000000000000000;;					if math.Abs(sum*float64(cpuLimit)-float64(cpuUsed)) > tolerance*float64(cpuUsed) {
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						correctUtilization = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if counter < 9 || !correctUtilization {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createMetricFilter(metric string, container_name string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(`metric.type="container.googleapis.com/container/%s" AND
0000000000000000000000000000000000000000;;					resource.label.container_name="%s"`, metric, container_name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fetchTimeSeries(projectId string, gcmService *gcm.Service, metric string, start time.Time, end time.Time) ([]*gcm.TimeSeries, error) {
0000000000000000000000000000000000000000;;		response, err := gcmService.Projects.TimeSeries.
0000000000000000000000000000000000000000;;			List(fullProjectName(projectId)).
0000000000000000000000000000000000000000;;			Filter(createMetricFilter(metric, rcName)).
0000000000000000000000000000000000000000;;			IntervalStartTime(start.Format(time.RFC3339)).
0000000000000000000000000000000000000000;;			IntervalEndTime(end.Format(time.RFC3339)).
0000000000000000000000000000000000000000;;			Do()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return response.TimeSeries, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fullProjectName(name string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("projects/%s", name)
0000000000000000000000000000000000000000;;	}
