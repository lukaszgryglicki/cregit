0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
d986908489738603997f5638cd4c1b411fb5f6a9;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("LimitRange", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("limitrange")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should create a LimitRange with defaults and ensure pod has those defaults applied.", func() {
0000000000000000000000000000000000000000;;			By("Creating a LimitRange")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			min := getResourceList("50m", "100Mi")
0000000000000000000000000000000000000000;;			max := getResourceList("500m", "500Mi")
0000000000000000000000000000000000000000;;			defaultLimit := getResourceList("500m", "500Mi")
0000000000000000000000000000000000000000;;			defaultRequest := getResourceList("100m", "200Mi")
0000000000000000000000000000000000000000;;			maxLimitRequestRatio := v1.ResourceList{}
0000000000000000000000000000000000000000;;			limitRange := newLimitRange("limit-range", v1.LimitTypeContainer,
0000000000000000000000000000000000000000;;				min, max,
0000000000000000000000000000000000000000;;				defaultLimit, defaultRequest,
0000000000000000000000000000000000000000;;				maxLimitRequestRatio)
0000000000000000000000000000000000000000;;			limitRange, err := f.ClientSet.Core().LimitRanges(f.Namespace.Name).Create(limitRange)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Fetching the LimitRange to ensure it has proper values")
0000000000000000000000000000000000000000;;			limitRange, err = f.ClientSet.Core().LimitRanges(f.Namespace.Name).Get(limitRange.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			expected := v1.ResourceRequirements{Requests: defaultRequest, Limits: defaultLimit}
0000000000000000000000000000000000000000;;			actual := v1.ResourceRequirements{Requests: limitRange.Spec.Limits[0].DefaultRequest, Limits: limitRange.Spec.Limits[0].Default}
0000000000000000000000000000000000000000;;			err = equalResourceRequirement(expected, actual)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a Pod with no resource requirements")
0000000000000000000000000000000000000000;;			pod := f.NewTestPod("pod-no-resources", v1.ResourceList{}, v1.ResourceList{})
0000000000000000000000000000000000000000;;			pod, err = f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring Pod has resource requirements applied from LimitRange")
0000000000000000000000000000000000000000;;			pod, err = f.ClientSet.Core().Pods(f.Namespace.Name).Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			for i := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;				err = equalResourceRequirement(expected, pod.Spec.Containers[i].Resources)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// Print the pod to help in debugging.
0000000000000000000000000000000000000000;;					framework.Logf("Pod %+v does not have the expected requirements", pod)
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a Pod with partial resource requirements")
0000000000000000000000000000000000000000;;			pod = f.NewTestPod("pod-partial-resources", getResourceList("", "150Mi"), getResourceList("300m", ""))
0000000000000000000000000000000000000000;;			pod, err = f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring Pod has merged resource requirements applied from LimitRange")
0000000000000000000000000000000000000000;;			pod, err = f.ClientSet.Core().Pods(f.Namespace.Name).Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			// This is an interesting case, so it's worth a comment
0000000000000000000000000000000000000000;;			// If you specify a Limit, and no Request, the Limit will default to the Request
0000000000000000000000000000000000000000;;			// This means that the LimitRange.DefaultRequest will ONLY take affect if a container.resources.limit is not supplied
0000000000000000000000000000000000000000;;			expected = v1.ResourceRequirements{Requests: getResourceList("300m", "150Mi"), Limits: getResourceList("300m", "500Mi")}
0000000000000000000000000000000000000000;;			for i := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;				err = equalResourceRequirement(expected, pod.Spec.Containers[i].Resources)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// Print the pod to help in debugging.
0000000000000000000000000000000000000000;;					framework.Logf("Pod %+v does not have the expected requirements", pod)
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Failing to create a Pod with less than min resources")
0000000000000000000000000000000000000000;;			pod = f.NewTestPod(podName, getResourceList("10m", "50Mi"), v1.ResourceList{})
0000000000000000000000000000000000000000;;			pod, err = f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod)
0000000000000000000000000000000000000000;;			Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Failing to create a Pod with more than max resources")
0000000000000000000000000000000000000000;;			pod = f.NewTestPod(podName, getResourceList("600m", "600Mi"), v1.ResourceList{})
0000000000000000000000000000000000000000;;			pod, err = f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod)
0000000000000000000000000000000000000000;;			Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func equalResourceRequirement(expected v1.ResourceRequirements, actual v1.ResourceRequirements) error {
0000000000000000000000000000000000000000;;		framework.Logf("Verifying requests: expected %v with actual %v", expected.Requests, actual.Requests)
0000000000000000000000000000000000000000;;		err := equalResourceList(expected.Requests, actual.Requests)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.Logf("Verifying limits: expected %v with actual %v", expected.Limits, actual.Limits)
0000000000000000000000000000000000000000;;		err = equalResourceList(expected.Limits, actual.Limits)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func equalResourceList(expected v1.ResourceList, actual v1.ResourceList) error {
0000000000000000000000000000000000000000;;		for k, v := range expected {
0000000000000000000000000000000000000000;;			if actualValue, found := actual[k]; !found || (v.Cmp(actualValue) != 0) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("resource %v expected %v actual %v", k, v.String(), actualValue.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range actual {
0000000000000000000000000000000000000000;;			if expectedValue, found := expected[k]; !found || (v.Cmp(expectedValue) != 0) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("resource %v expected %v actual %v", k, expectedValue.String(), v.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getResourceList(cpu, memory string) v1.ResourceList {
0000000000000000000000000000000000000000;;		res := v1.ResourceList{}
0000000000000000000000000000000000000000;;		if cpu != "" {
0000000000000000000000000000000000000000;;			res[v1.ResourceCPU] = resource.MustParse(cpu)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if memory != "" {
0000000000000000000000000000000000000000;;			res[v1.ResourceMemory] = resource.MustParse(memory)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newLimitRange returns a limit range with specified data
0000000000000000000000000000000000000000;;	func newLimitRange(name string, limitType v1.LimitType,
0000000000000000000000000000000000000000;;		min, max,
0000000000000000000000000000000000000000;;		defaultLimit, defaultRequest,
0000000000000000000000000000000000000000;;		maxLimitRequestRatio v1.ResourceList) *v1.LimitRange {
0000000000000000000000000000000000000000;;		return &v1.LimitRange{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.LimitRangeSpec{
0000000000000000000000000000000000000000;;				Limits: []v1.LimitRangeItem{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:                 limitType,
0000000000000000000000000000000000000000;;						Min:                  min,
0000000000000000000000000000000000000000;;						Max:                  max,
0000000000000000000000000000000000000000;;						Default:              defaultLimit,
0000000000000000000000000000000000000000;;						DefaultRequest:       defaultRequest,
0000000000000000000000000000000000000000;;						MaxLimitRequestRatio: maxLimitRequestRatio,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
