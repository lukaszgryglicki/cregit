0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
c75aa06ad33bc2a2457c401b511fff3ec7cefa95;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const dnsTestPodHostName = "dns-querier-1"
0000000000000000000000000000000000000000;;	const dnsTestServiceName = "dns-test-service"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var dnsServiceLabelSelector = labels.Set{
0000000000000000000000000000000000000000;;		"k8s-app":                       "kube-dns",
0000000000000000000000000000000000000000;;		"kubernetes.io/cluster-service": "true",
0000000000000000000000000000000000000000;;	}.AsSelector()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createDNSPod(namespace, wheezyProbeCmd, jessieProbeCmd string, useAnnotation bool) *v1.Pod {
0000000000000000000000000000000000000000;;		dnsPod := &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "dns-test-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "results",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							EmptyDir: &v1.EmptyDirVolumeSource{},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					// TODO: Consider scraping logs instead of running a webserver.
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "webserver",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/test-webserver:e2e",
0000000000000000000000000000000000000000;;						Ports: []v1.ContainerPort{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:          "http",
0000000000000000000000000000000000000000;;								ContainerPort: 80,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      "results",
0000000000000000000000000000000000000000;;								MountPath: "/results",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:    "querier",
0000000000000000000000000000000000000000;;						Image:   "gcr.io/google_containers/dnsutils:e2e",
0000000000000000000000000000000000000000;;						Command: []string{"sh", "-c", wheezyProbeCmd},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      "results",
0000000000000000000000000000000000000000;;								MountPath: "/results",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:    "jessie-querier",
0000000000000000000000000000000000000000;;						Image:   "gcr.io/google_containers/jessie-dnsutils:e2e",
0000000000000000000000000000000000000000;;						Command: []string{"sh", "-c", jessieProbeCmd},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      "results",
0000000000000000000000000000000000000000;;								MountPath: "/results",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dnsPod.Spec.Hostname = dnsTestPodHostName
0000000000000000000000000000000000000000;;		dnsPod.Spec.Subdomain = dnsTestServiceName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return dnsPod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createProbeCommand(namesToResolve []string, hostEntries []string, ptrLookupIP string, fileNamePrefix, namespace string) (string, []string) {
0000000000000000000000000000000000000000;;		fileNames := make([]string, 0, len(namesToResolve)*2)
0000000000000000000000000000000000000000;;		probeCmd := "for i in `seq 1 600`; do "
0000000000000000000000000000000000000000;;		for _, name := range namesToResolve {
0000000000000000000000000000000000000000;;			// Resolve by TCP and UDP DNS.  Use $$(...) because $(...) is
0000000000000000000000000000000000000000;;			// expanded by kubernetes (though this won't expand so should
0000000000000000000000000000000000000000;;			// remain a literal, safe > sorry).
0000000000000000000000000000000000000000;;			lookup := "A"
0000000000000000000000000000000000000000;;			if strings.HasPrefix(name, "_") {
0000000000000000000000000000000000000000;;				lookup = "SRV"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fileName := fmt.Sprintf("%s_udp@%s", fileNamePrefix, name)
0000000000000000000000000000000000000000;;			fileNames = append(fileNames, fileName)
0000000000000000000000000000000000000000;;			probeCmd += fmt.Sprintf(`test -n "$$(dig +notcp +noall +answer +search %s %s)" && echo OK > /results/%s;`, name, lookup, fileName)
0000000000000000000000000000000000000000;;			fileName = fmt.Sprintf("%s_tcp@%s", fileNamePrefix, name)
0000000000000000000000000000000000000000;;			fileNames = append(fileNames, fileName)
0000000000000000000000000000000000000000;;			probeCmd += fmt.Sprintf(`test -n "$$(dig +tcp +noall +answer +search %s %s)" && echo OK > /results/%s;`, name, lookup, fileName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, name := range hostEntries {
0000000000000000000000000000000000000000;;			fileName := fmt.Sprintf("%s_hosts@%s", fileNamePrefix, name)
0000000000000000000000000000000000000000;;			fileNames = append(fileNames, fileName)
0000000000000000000000000000000000000000;;			probeCmd += fmt.Sprintf(`test -n "$$(getent hosts %s)" && echo OK > /results/%s;`, name, fileName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podARecByUDPFileName := fmt.Sprintf("%s_udp@PodARecord", fileNamePrefix)
0000000000000000000000000000000000000000;;		podARecByTCPFileName := fmt.Sprintf("%s_tcp@PodARecord", fileNamePrefix)
0000000000000000000000000000000000000000;;		probeCmd += fmt.Sprintf(`podARec=$$(hostname -i| awk -F. '{print $$1"-"$$2"-"$$3"-"$$4".%s.pod.cluster.local"}');`, namespace)
0000000000000000000000000000000000000000;;		probeCmd += fmt.Sprintf(`test -n "$$(dig +notcp +noall +answer +search $${podARec} A)" && echo OK > /results/%s;`, podARecByUDPFileName)
0000000000000000000000000000000000000000;;		probeCmd += fmt.Sprintf(`test -n "$$(dig +tcp +noall +answer +search $${podARec} A)" && echo OK > /results/%s;`, podARecByTCPFileName)
0000000000000000000000000000000000000000;;		fileNames = append(fileNames, podARecByUDPFileName)
0000000000000000000000000000000000000000;;		fileNames = append(fileNames, podARecByTCPFileName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ptrLookupIP) > 0 {
0000000000000000000000000000000000000000;;			ptrLookup := fmt.Sprintf("%s.in-addr.arpa.", strings.Join(reverseArray(strings.Split(ptrLookupIP, ".")), "."))
0000000000000000000000000000000000000000;;			ptrRecByUDPFileName := fmt.Sprintf("%s_udp@PTR", ptrLookupIP)
0000000000000000000000000000000000000000;;			ptrRecByTCPFileName := fmt.Sprintf("%s_tcp@PTR", ptrLookupIP)
0000000000000000000000000000000000000000;;			probeCmd += fmt.Sprintf(`test -n "$$(dig +notcp +noall +answer +search %s PTR)" && echo OK > /results/%s;`, ptrLookup, ptrRecByUDPFileName)
0000000000000000000000000000000000000000;;			probeCmd += fmt.Sprintf(`test -n "$$(dig +tcp +noall +answer +search %s PTR)" && echo OK > /results/%s;`, ptrLookup, ptrRecByTCPFileName)
0000000000000000000000000000000000000000;;			fileNames = append(fileNames, ptrRecByUDPFileName)
0000000000000000000000000000000000000000;;			fileNames = append(fileNames, ptrRecByTCPFileName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		probeCmd += "sleep 1; done"
0000000000000000000000000000000000000000;;		return probeCmd, fileNames
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createTargetedProbeCommand returns a command line that performs a DNS lookup for a specific record type
0000000000000000000000000000000000000000;;	func createTargetedProbeCommand(nameToResolve string, lookup string, fileNamePrefix string) (string, string) {
0000000000000000000000000000000000000000;;		fileName := fmt.Sprintf("%s_udp@%s", fileNamePrefix, nameToResolve)
0000000000000000000000000000000000000000;;		probeCmd := fmt.Sprintf("dig +short +tries=12 +norecurse %s %s > /results/%s", nameToResolve, lookup, fileName)
0000000000000000000000000000000000000000;;		return probeCmd, fileName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func assertFilesExist(fileNames []string, fileDir string, pod *v1.Pod, client clientset.Interface) {
0000000000000000000000000000000000000000;;		assertFilesContain(fileNames, fileDir, pod, client, false, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func assertFilesContain(fileNames []string, fileDir string, pod *v1.Pod, client clientset.Interface, check bool, expected string) {
0000000000000000000000000000000000000000;;		var failed []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.ExpectNoError(wait.Poll(time.Second*10, time.Second*600, func() (bool, error) {
0000000000000000000000000000000000000000;;			failed = []string{}
0000000000000000000000000000000000000000;;			subResourceProxyAvailable, err := framework.ServerVersionGTE(framework.SubResourcePodProxyVersion, client.Discovery())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ctx, cancel := context.WithTimeout(context.Background(), framework.SingleCallTimeout)
0000000000000000000000000000000000000000;;			defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var contents []byte
0000000000000000000000000000000000000000;;			for _, fileName := range fileNames {
0000000000000000000000000000000000000000;;				if subResourceProxyAvailable {
0000000000000000000000000000000000000000;;					contents, err = client.Core().RESTClient().Get().
0000000000000000000000000000000000000000;;						Context(ctx).
0000000000000000000000000000000000000000;;						Namespace(pod.Namespace).
0000000000000000000000000000000000000000;;						Resource("pods").
0000000000000000000000000000000000000000;;						SubResource("proxy").
0000000000000000000000000000000000000000;;						Name(pod.Name).
0000000000000000000000000000000000000000;;						Suffix(fileDir, fileName).
0000000000000000000000000000000000000000;;						Do().Raw()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					contents, err = client.Core().RESTClient().Get().
0000000000000000000000000000000000000000;;						Context(ctx).
0000000000000000000000000000000000000000;;						Prefix("proxy").
0000000000000000000000000000000000000000;;						Resource("pods").
0000000000000000000000000000000000000000;;						Namespace(pod.Namespace).
0000000000000000000000000000000000000000;;						Name(pod.Name).
0000000000000000000000000000000000000000;;						Suffix(fileDir, fileName).
0000000000000000000000000000000000000000;;						Do().Raw()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if ctx.Err() != nil {
0000000000000000000000000000000000000000;;						framework.Failf("Unable to read %s from pod %s: %v", fileName, pod.Name, err)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						framework.Logf("Unable to read %s from pod %s: %v", fileName, pod.Name, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					failed = append(failed, fileName)
0000000000000000000000000000000000000000;;				} else if check && strings.TrimSpace(string(contents)) != expected {
0000000000000000000000000000000000000000;;					framework.Logf("File %s from pod %s contains '%s' instead of '%s'", fileName, pod.Name, string(contents), expected)
0000000000000000000000000000000000000000;;					failed = append(failed, fileName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(failed) == 0 {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.Logf("Lookups using %s failed for: %v\n", pod.Name, failed)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		Expect(len(failed)).To(Equal(0))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateDNSResults(f *framework.Framework, pod *v1.Pod, fileNames []string) {
0000000000000000000000000000000000000000;;		By("submitting the pod to kubernetes")
0000000000000000000000000000000000000000;;		podClient := f.ClientSet.Core().Pods(f.Namespace.Name)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			By("deleting the pod")
0000000000000000000000000000000000000000;;			defer GinkgoRecover()
0000000000000000000000000000000000000000;;			podClient.Delete(pod.Name, metav1.NewDeleteOptions(0))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if _, err := podClient.Create(pod); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Failed to create %s pod: %v", pod.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.ExpectNoError(f.WaitForPodRunning(pod.Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("retrieving the pod")
0000000000000000000000000000000000000000;;		pod, err := podClient.Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Failed to get pod %s: %v", pod.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Try to find results for each expected name.
0000000000000000000000000000000000000000;;		By("looking for the results for each expected name from probers")
0000000000000000000000000000000000000000;;		assertFilesExist(fileNames, "results", pod, f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: probe from the host, too.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("DNS probes using %s succeeded\n", pod.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateTargetedProbeOutput(f *framework.Framework, pod *v1.Pod, fileNames []string, value string) {
0000000000000000000000000000000000000000;;		By("submitting the pod to kubernetes")
0000000000000000000000000000000000000000;;		podClient := f.ClientSet.Core().Pods(f.Namespace.Name)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			By("deleting the pod")
0000000000000000000000000000000000000000;;			defer GinkgoRecover()
0000000000000000000000000000000000000000;;			podClient.Delete(pod.Name, metav1.NewDeleteOptions(0))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if _, err := podClient.Create(pod); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Failed to create %s pod: %v", pod.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.ExpectNoError(f.WaitForPodRunning(pod.Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("retrieving the pod")
0000000000000000000000000000000000000000;;		pod, err := podClient.Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Failed to get pod %s: %v", pod.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Try to find the expected value for each expected name.
0000000000000000000000000000000000000000;;		By("looking for the results for each expected name from probers")
0000000000000000000000000000000000000000;;		assertFilesContain(fileNames, "results", pod, f.ClientSet, true, value)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("DNS probes using %s succeeded\n", pod.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func reverseArray(arr []string) []string {
0000000000000000000000000000000000000000;;		for i := 0; i < len(arr)/2; i++ {
0000000000000000000000000000000000000000;;			j := len(arr) - i - 1
0000000000000000000000000000000000000000;;			arr[i], arr[j] = arr[j], arr[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return arr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("DNS", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("dns")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should provide DNS for the cluster [Conformance]", func() {
0000000000000000000000000000000000000000;;			// All the names we need to be able to resolve.
0000000000000000000000000000000000000000;;			// TODO: Spin up a separate test service and test that dns works for that service.
0000000000000000000000000000000000000000;;			namesToResolve := []string{
0000000000000000000000000000000000000000;;				"kubernetes.default",
0000000000000000000000000000000000000000;;				"kubernetes.default.svc",
0000000000000000000000000000000000000000;;				"kubernetes.default.svc.cluster.local",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Added due to #8512. This is critical for GCE and GKE deployments.
0000000000000000000000000000000000000000;;			if framework.ProviderIs("gce", "gke") {
0000000000000000000000000000000000000000;;				namesToResolve = append(namesToResolve, "google.com")
0000000000000000000000000000000000000000;;				namesToResolve = append(namesToResolve, "metadata")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hostFQDN := fmt.Sprintf("%s.%s.%s.svc.cluster.local", dnsTestPodHostName, dnsTestServiceName, f.Namespace.Name)
0000000000000000000000000000000000000000;;			hostEntries := []string{hostFQDN, dnsTestPodHostName}
0000000000000000000000000000000000000000;;			wheezyProbeCmd, wheezyFileNames := createProbeCommand(namesToResolve, hostEntries, "", "wheezy", f.Namespace.Name)
0000000000000000000000000000000000000000;;			jessieProbeCmd, jessieFileNames := createProbeCommand(namesToResolve, hostEntries, "", "jessie", f.Namespace.Name)
0000000000000000000000000000000000000000;;			By("Running these commands on wheezy: " + wheezyProbeCmd + "\n")
0000000000000000000000000000000000000000;;			By("Running these commands on jessie: " + jessieProbeCmd + "\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Run a pod which probes DNS and exposes the results by HTTP.
0000000000000000000000000000000000000000;;			By("creating a pod to probe DNS")
0000000000000000000000000000000000000000;;			pod := createDNSPod(f.Namespace.Name, wheezyProbeCmd, jessieProbeCmd, true)
0000000000000000000000000000000000000000;;			validateDNSResults(f, pod, append(wheezyFileNames, jessieFileNames...))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should provide DNS for services [Conformance]", func() {
0000000000000000000000000000000000000000;;			// Create a test headless service.
0000000000000000000000000000000000000000;;			By("Creating a test headless service")
0000000000000000000000000000000000000000;;			testServiceSelector := map[string]string{
0000000000000000000000000000000000000000;;				"dns-test": "true",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			headlessService := framework.CreateServiceSpec(dnsTestServiceName, "", true, testServiceSelector)
0000000000000000000000000000000000000000;;			_, err := f.ClientSet.Core().Services(f.Namespace.Name).Create(headlessService)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				By("deleting the test headless service")
0000000000000000000000000000000000000000;;				defer GinkgoRecover()
0000000000000000000000000000000000000000;;				f.ClientSet.Core().Services(f.Namespace.Name).Delete(headlessService.Name, nil)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			regularService := framework.CreateServiceSpec("test-service-2", "", false, testServiceSelector)
0000000000000000000000000000000000000000;;			regularService, err = f.ClientSet.Core().Services(f.Namespace.Name).Create(regularService)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				By("deleting the test service")
0000000000000000000000000000000000000000;;				defer GinkgoRecover()
0000000000000000000000000000000000000000;;				f.ClientSet.Core().Services(f.Namespace.Name).Delete(regularService.Name, nil)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// All the names we need to be able to resolve.
0000000000000000000000000000000000000000;;			// TODO: Create more endpoints and ensure that multiple A records are returned
0000000000000000000000000000000000000000;;			// for headless service.
0000000000000000000000000000000000000000;;			namesToResolve := []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("%s", headlessService.Name),
0000000000000000000000000000000000000000;;				fmt.Sprintf("%s.%s", headlessService.Name, f.Namespace.Name),
0000000000000000000000000000000000000000;;				fmt.Sprintf("%s.%s.svc", headlessService.Name, f.Namespace.Name),
0000000000000000000000000000000000000000;;				fmt.Sprintf("_http._tcp.%s.%s.svc", headlessService.Name, f.Namespace.Name),
0000000000000000000000000000000000000000;;				fmt.Sprintf("_http._tcp.%s.%s.svc", regularService.Name, f.Namespace.Name),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			wheezyProbeCmd, wheezyFileNames := createProbeCommand(namesToResolve, nil, regularService.Spec.ClusterIP, "wheezy", f.Namespace.Name)
0000000000000000000000000000000000000000;;			jessieProbeCmd, jessieFileNames := createProbeCommand(namesToResolve, nil, regularService.Spec.ClusterIP, "jessie", f.Namespace.Name)
0000000000000000000000000000000000000000;;			By("Running these commands on wheezy: " + wheezyProbeCmd + "\n")
0000000000000000000000000000000000000000;;			By("Running these commands on jessie: " + jessieProbeCmd + "\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Run a pod which probes DNS and exposes the results by HTTP.
0000000000000000000000000000000000000000;;			By("creating a pod to probe DNS")
0000000000000000000000000000000000000000;;			pod := createDNSPod(f.Namespace.Name, wheezyProbeCmd, jessieProbeCmd, false)
0000000000000000000000000000000000000000;;			pod.ObjectMeta.Labels = testServiceSelector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			validateDNSResults(f, pod, append(wheezyFileNames, jessieFileNames...))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should provide DNS for pods for Hostname and Subdomain Annotation", func() {
0000000000000000000000000000000000000000;;			// Create a test headless service.
0000000000000000000000000000000000000000;;			By("Creating a test headless service")
0000000000000000000000000000000000000000;;			testServiceSelector := map[string]string{
0000000000000000000000000000000000000000;;				"dns-test-hostname-attribute": "true",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			serviceName := "dns-test-service-2"
0000000000000000000000000000000000000000;;			podHostname := "dns-querier-2"
0000000000000000000000000000000000000000;;			headlessService := framework.CreateServiceSpec(serviceName, "", true, testServiceSelector)
0000000000000000000000000000000000000000;;			_, err := f.ClientSet.Core().Services(f.Namespace.Name).Create(headlessService)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				By("deleting the test headless service")
0000000000000000000000000000000000000000;;				defer GinkgoRecover()
0000000000000000000000000000000000000000;;				f.ClientSet.Core().Services(f.Namespace.Name).Delete(headlessService.Name, nil)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			hostFQDN := fmt.Sprintf("%s.%s.%s.svc.cluster.local", podHostname, serviceName, f.Namespace.Name)
0000000000000000000000000000000000000000;;			hostNames := []string{hostFQDN, podHostname}
0000000000000000000000000000000000000000;;			namesToResolve := []string{hostFQDN}
0000000000000000000000000000000000000000;;			wheezyProbeCmd, wheezyFileNames := createProbeCommand(namesToResolve, hostNames, "", "wheezy", f.Namespace.Name)
0000000000000000000000000000000000000000;;			jessieProbeCmd, jessieFileNames := createProbeCommand(namesToResolve, hostNames, "", "jessie", f.Namespace.Name)
0000000000000000000000000000000000000000;;			By("Running these commands on wheezy: " + wheezyProbeCmd + "\n")
0000000000000000000000000000000000000000;;			By("Running these commands on jessie: " + jessieProbeCmd + "\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Run a pod which probes DNS and exposes the results by HTTP.
0000000000000000000000000000000000000000;;			By("creating a pod to probe DNS")
0000000000000000000000000000000000000000;;			pod1 := createDNSPod(f.Namespace.Name, wheezyProbeCmd, jessieProbeCmd, true)
0000000000000000000000000000000000000000;;			pod1.ObjectMeta.Labels = testServiceSelector
0000000000000000000000000000000000000000;;			pod1.Spec.Hostname = podHostname
0000000000000000000000000000000000000000;;			pod1.Spec.Subdomain = serviceName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			validateDNSResults(f, pod1, append(wheezyFileNames, jessieFileNames...))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should provide DNS for ExternalName services", func() {
0000000000000000000000000000000000000000;;			// TODO(xiangpengzhao): allow AWS when pull-kubernetes-e2e-kops-aws and pull-kubernetes-e2e-gce-etcd3
0000000000000000000000000000000000000000;;			// have the same "service-cluster-ip-range". See: https://github.com/kubernetes/kubernetes/issues/47224
0000000000000000000000000000000000000000;;			framework.SkipUnlessProviderIs("gce")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create a test ExternalName service.
0000000000000000000000000000000000000000;;			By("Creating a test externalName service")
0000000000000000000000000000000000000000;;			serviceName := "dns-test-service-3"
0000000000000000000000000000000000000000;;			externalNameService := framework.CreateServiceSpec(serviceName, "foo.example.com", false, nil)
0000000000000000000000000000000000000000;;			_, err := f.ClientSet.Core().Services(f.Namespace.Name).Create(externalNameService)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				By("deleting the test externalName service")
0000000000000000000000000000000000000000;;				defer GinkgoRecover()
0000000000000000000000000000000000000000;;				f.ClientSet.Core().Services(f.Namespace.Name).Delete(externalNameService.Name, nil)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			hostFQDN := fmt.Sprintf("%s.%s.svc.cluster.local", serviceName, f.Namespace.Name)
0000000000000000000000000000000000000000;;			wheezyProbeCmd, wheezyFileName := createTargetedProbeCommand(hostFQDN, "CNAME", "wheezy")
0000000000000000000000000000000000000000;;			jessieProbeCmd, jessieFileName := createTargetedProbeCommand(hostFQDN, "CNAME", "jessie")
0000000000000000000000000000000000000000;;			By("Running these commands on wheezy: " + wheezyProbeCmd + "\n")
0000000000000000000000000000000000000000;;			By("Running these commands on jessie: " + jessieProbeCmd + "\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Run a pod which probes DNS and exposes the results by HTTP.
0000000000000000000000000000000000000000;;			By("creating a pod to probe DNS")
0000000000000000000000000000000000000000;;			pod1 := createDNSPod(f.Namespace.Name, wheezyProbeCmd, jessieProbeCmd, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			validateTargetedProbeOutput(f, pod1, []string{wheezyFileName, jessieFileName}, "foo.example.com.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Test changing the externalName field
0000000000000000000000000000000000000000;;			By("changing the externalName to bar.example.com")
0000000000000000000000000000000000000000;;			_, err = framework.UpdateService(f.ClientSet, f.Namespace.Name, serviceName, func(s *v1.Service) {
0000000000000000000000000000000000000000;;				s.Spec.ExternalName = "bar.example.com"
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			wheezyProbeCmd, wheezyFileName = createTargetedProbeCommand(hostFQDN, "CNAME", "wheezy")
0000000000000000000000000000000000000000;;			jessieProbeCmd, jessieFileName = createTargetedProbeCommand(hostFQDN, "CNAME", "jessie")
0000000000000000000000000000000000000000;;			By("Running these commands on wheezy: " + wheezyProbeCmd + "\n")
0000000000000000000000000000000000000000;;			By("Running these commands on jessie: " + jessieProbeCmd + "\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Run a pod which probes DNS and exposes the results by HTTP.
0000000000000000000000000000000000000000;;			By("creating a second pod to probe DNS")
0000000000000000000000000000000000000000;;			pod2 := createDNSPod(f.Namespace.Name, wheezyProbeCmd, jessieProbeCmd, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			validateTargetedProbeOutput(f, pod2, []string{wheezyFileName, jessieFileName}, "bar.example.com.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Test changing type from ExternalName to ClusterIP
0000000000000000000000000000000000000000;;			By("changing the service to type=ClusterIP")
0000000000000000000000000000000000000000;;			_, err = framework.UpdateService(f.ClientSet, f.Namespace.Name, serviceName, func(s *v1.Service) {
0000000000000000000000000000000000000000;;				s.Spec.Type = v1.ServiceTypeClusterIP
0000000000000000000000000000000000000000;;				s.Spec.ClusterIP = "10.0.0.123"
0000000000000000000000000000000000000000;;				s.Spec.Ports = []v1.ServicePort{
0000000000000000000000000000000000000000;;					{Port: 80, Name: "http", Protocol: "TCP"},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			wheezyProbeCmd, wheezyFileName = createTargetedProbeCommand(hostFQDN, "A", "wheezy")
0000000000000000000000000000000000000000;;			jessieProbeCmd, jessieFileName = createTargetedProbeCommand(hostFQDN, "A", "jessie")
0000000000000000000000000000000000000000;;			By("Running these commands on wheezy: " + wheezyProbeCmd + "\n")
0000000000000000000000000000000000000000;;			By("Running these commands on jessie: " + jessieProbeCmd + "\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Run a pod which probes DNS and exposes the results by HTTP.
0000000000000000000000000000000000000000;;			By("creating a third pod to probe DNS")
0000000000000000000000000000000000000000;;			pod3 := createDNSPod(f.Namespace.Name, wheezyProbeCmd, jessieProbeCmd, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			validateTargetedProbeOutput(f, pod3, []string{wheezyFileName, jessieFileName}, "10.0.0.123")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
