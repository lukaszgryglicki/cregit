0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
0b2142feb49165f67c641fdf22f0b81ee371f8af;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Advanced Audit [Feature:Audit]", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("audit")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should audit API calls", func() {
0000000000000000000000000000000000000000;;			namespace := f.Namespace.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create & Delete pod
0000000000000000000000000000000000000000;;			pod := &apiv1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "audit-pod",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: apiv1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []apiv1.Container{{
0000000000000000000000000000000000000000;;						Name:  "pause",
0000000000000000000000000000000000000000;;						Image: framework.GetPauseImageName(f.ClientSet),
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.PodClient().CreateSync(pod)
0000000000000000000000000000000000000000;;			f.PodClient().DeleteSync(pod.Name, &metav1.DeleteOptions{}, framework.DefaultPodDeletionTimeout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create, Read, Delete secret
0000000000000000000000000000000000000000;;			secret := &apiv1.Secret{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "audit-secret",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Data: map[string][]byte{
0000000000000000000000000000000000000000;;					"top-secret": []byte("foo-bar"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err := f.ClientSet.Core().Secrets(f.Namespace.Name).Create(secret)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err, "failed to create audit-secret")
0000000000000000000000000000000000000000;;			_, err = f.ClientSet.Core().Secrets(f.Namespace.Name).Get(secret.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err, "failed to get audit-secret")
0000000000000000000000000000000000000000;;			err = f.ClientSet.Core().Secrets(f.Namespace.Name).Delete(secret.Name, &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err, "failed to delete audit-secret")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// /version should not be audited
0000000000000000000000000000000000000000;;			_, err = f.ClientSet.Core().RESTClient().Get().AbsPath("/version").DoRaw()
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err, "failed to query version")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expectedEvents := []auditEvent{{
0000000000000000000000000000000000000000;;				method:    "create",
0000000000000000000000000000000000000000;;				namespace: namespace,
0000000000000000000000000000000000000000;;				uri:       fmt.Sprintf("/api/v1/namespaces/%s/pods", namespace),
0000000000000000000000000000000000000000;;				response:  "201",
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				method:    "delete",
0000000000000000000000000000000000000000;;				namespace: namespace,
0000000000000000000000000000000000000000;;				uri:       fmt.Sprintf("/api/v1/namespaces/%s/pods/%s", namespace, pod.Name),
0000000000000000000000000000000000000000;;				response:  "200",
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				method:    "create",
0000000000000000000000000000000000000000;;				namespace: namespace,
0000000000000000000000000000000000000000;;				uri:       fmt.Sprintf("/api/v1/namespaces/%s/secrets", namespace),
0000000000000000000000000000000000000000;;				response:  "201",
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				method:    "get",
0000000000000000000000000000000000000000;;				namespace: namespace,
0000000000000000000000000000000000000000;;				uri:       fmt.Sprintf("/api/v1/namespaces/%s/secrets/%s", namespace, secret.Name),
0000000000000000000000000000000000000000;;				response:  "200",
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				method:    "delete",
0000000000000000000000000000000000000000;;				namespace: namespace,
0000000000000000000000000000000000000000;;				uri:       fmt.Sprintf("/api/v1/namespaces/%s/secrets/%s", namespace, secret.Name),
0000000000000000000000000000000000000000;;				response:  "200",
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;			expectAuditLines(f, expectedEvents)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type auditEvent struct {
0000000000000000000000000000000000000000;;		method, namespace, uri, response string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Search the audit log for the expected audit lines.
0000000000000000000000000000000000000000;;	func expectAuditLines(f *framework.Framework, expected []auditEvent) {
0000000000000000000000000000000000000000;;		expectations := map[auditEvent]bool{}
0000000000000000000000000000000000000000;;		for _, event := range expected {
0000000000000000000000000000000000000000;;			expectations[event] = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fetch the log stream.
0000000000000000000000000000000000000000;;		stream, err := f.ClientSet.Core().RESTClient().Get().AbsPath("/logs/kube-apiserver-audit.log").Stream()
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "could not read audit log")
0000000000000000000000000000000000000000;;		defer stream.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(stream)
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			line := scanner.Text()
0000000000000000000000000000000000000000;;			event, err := parseAuditLine(line)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If the event was expected, mark it as found.
0000000000000000000000000000000000000000;;			if _, found := expectations[event]; found {
0000000000000000000000000000000000000000;;				expectations[event] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// /version should not be audited (filtered in the policy).
0000000000000000000000000000000000000000;;			Expect(event.uri).NotTo(HavePrefix("/version"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.ExpectNoError(scanner.Err(), "error reading audit log")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for event, found := range expectations {
0000000000000000000000000000000000000000;;			Expect(found).To(BeTrue(), "Event %#v not found!", event)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseAuditLine(line string) (auditEvent, error) {
0000000000000000000000000000000000000000;;		fields := strings.Fields(line)
0000000000000000000000000000000000000000;;		if len(fields) < 3 {
0000000000000000000000000000000000000000;;			return auditEvent{}, fmt.Errorf("could not parse audit line: %s", line)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Ignore first field (timestamp)
0000000000000000000000000000000000000000;;		if fields[1] != "AUDIT:" {
0000000000000000000000000000000000000000;;			return auditEvent{}, fmt.Errorf("unexpected audit line format: %s", line)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fields = fields[2:]
0000000000000000000000000000000000000000;;		event := auditEvent{}
0000000000000000000000000000000000000000;;		for _, f := range fields {
0000000000000000000000000000000000000000;;			parts := strings.SplitN(f, "=", 2)
0000000000000000000000000000000000000000;;			if len(parts) != 2 {
0000000000000000000000000000000000000000;;				return auditEvent{}, fmt.Errorf("could not parse audit line (part: %q): %s", f, line)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			value := strings.Trim(parts[1], "\"")
0000000000000000000000000000000000000000;;			switch parts[0] {
0000000000000000000000000000000000000000;;			case "method":
0000000000000000000000000000000000000000;;				event.method = value
0000000000000000000000000000000000000000;;			case "namespace":
0000000000000000000000000000000000000000;;				event.namespace = value
0000000000000000000000000000000000000000;;			case "uri":
0000000000000000000000000000000000000000;;				event.uri = value
0000000000000000000000000000000000000000;;			case "response":
0000000000000000000000000000000000000000;;				event.response = value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return event, nil
0000000000000000000000000000000000000000;;	}
