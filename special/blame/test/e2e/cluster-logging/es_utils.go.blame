0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
57cddc74314ee1c203f913729a8118034faed4e0;test/e2e/cluster_logging_es_utils.go[test/e2e/cluster_logging_es_utils.go][test/e2e/cluster-logging/es_utils.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		meta_v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// esRetryTimeout is how long to keep retrying requesting elasticsearch for status information.
0000000000000000000000000000000000000000;;		esRetryTimeout = 5 * time.Minute
0000000000000000000000000000000000000000;;		// esRetryDelay is how much time to wait between two attempts to send a request to elasticsearch
0000000000000000000000000000000000000000;;		esRetryDelay = 5 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type esLogsProvider struct {
0000000000000000000000000000000000000000;;		Framework *framework.Framework
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newEsLogsProvider(f *framework.Framework) (*esLogsProvider, error) {
0000000000000000000000000000000000000000;;		return &esLogsProvider{Framework: f}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensures that elasticsearch is running and ready to serve requests
0000000000000000000000000000000000000000;;	func (logsProvider *esLogsProvider) Init() error {
0000000000000000000000000000000000000000;;		f := logsProvider.Framework
0000000000000000000000000000000000000000;;		// Check for the existence of the Elasticsearch service.
0000000000000000000000000000000000000000;;		By("Checking the Elasticsearch service exists.")
0000000000000000000000000000000000000000;;		s := f.ClientSet.Core().Services(api.NamespaceSystem)
0000000000000000000000000000000000000000;;		// Make a few attempts to connect. This makes the test robust against
0000000000000000000000000000000000000000;;		// being run as the first e2e test just after the e2e cluster has been created.
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < esRetryTimeout; time.Sleep(esRetryDelay) {
0000000000000000000000000000000000000000;;			if _, err = s.Get("elasticsearch-logging", meta_v1.GetOptions{}); err == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.Logf("Attempt to check for the existence of the Elasticsearch service failed after %v", time.Since(start))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for the Elasticsearch pods to enter the running state.
0000000000000000000000000000000000000000;;		By("Checking to make sure the Elasticsearch pods are running")
0000000000000000000000000000000000000000;;		labelSelector := fields.SelectorFromSet(fields.Set(map[string]string{"k8s-app": "elasticsearch-logging"})).String()
0000000000000000000000000000000000000000;;		options := meta_v1.ListOptions{LabelSelector: labelSelector}
0000000000000000000000000000000000000000;;		pods, err := f.ClientSet.Core().Pods(api.NamespaceSystem).List(options)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;			err = framework.WaitForPodRunningInNamespace(f.ClientSet, &pod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Checking to make sure we are talking to an Elasticsearch service.")
0000000000000000000000000000000000000000;;		// Perform a few checks to make sure this looks like an Elasticsearch cluster.
0000000000000000000000000000000000000000;;		var statusCode int
0000000000000000000000000000000000000000;;		err = nil
0000000000000000000000000000000000000000;;		var body []byte
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < esRetryTimeout; time.Sleep(esRetryDelay) {
0000000000000000000000000000000000000000;;			proxyRequest, errProxy := framework.GetServicesProxyRequest(f.ClientSet, f.ClientSet.Core().RESTClient().Get())
0000000000000000000000000000000000000000;;			if errProxy != nil {
0000000000000000000000000000000000000000;;				framework.Logf("After %v failed to get services proxy request: %v", time.Since(start), errProxy)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Query against the root URL for Elasticsearch.
0000000000000000000000000000000000000000;;			response := proxyRequest.Namespace(api.NamespaceSystem).
0000000000000000000000000000000000000000;;				Name("elasticsearch-logging").
0000000000000000000000000000000000000000;;				Do()
0000000000000000000000000000000000000000;;			err = response.Error()
0000000000000000000000000000000000000000;;			response.StatusCode(&statusCode)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("After %v proxy call to elasticsearch-loigging failed: %v", time.Since(start), err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if int(statusCode) != 200 {
0000000000000000000000000000000000000000;;				framework.Logf("After %v Elasticsearch cluster has a bad status: %v", time.Since(start), statusCode)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		if int(statusCode) != 200 {
0000000000000000000000000000000000000000;;			framework.Failf("Elasticsearch cluster has a bad status: %v", statusCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now assume we really are talking to an Elasticsearch instance.
0000000000000000000000000000000000000000;;		// Check the cluster health.
0000000000000000000000000000000000000000;;		By("Checking health of Elasticsearch service.")
0000000000000000000000000000000000000000;;		healthy := false
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < esRetryTimeout; time.Sleep(esRetryDelay) {
0000000000000000000000000000000000000000;;			proxyRequest, errProxy := framework.GetServicesProxyRequest(f.ClientSet, f.ClientSet.Core().RESTClient().Get())
0000000000000000000000000000000000000000;;			if errProxy != nil {
0000000000000000000000000000000000000000;;				framework.Logf("After %v failed to get services proxy request: %v", time.Since(start), errProxy)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			body, err = proxyRequest.Namespace(api.NamespaceSystem).
0000000000000000000000000000000000000000;;				Name("elasticsearch-logging").
0000000000000000000000000000000000000000;;				Suffix("_cluster/health").
0000000000000000000000000000000000000000;;				Param("level", "indices").
0000000000000000000000000000000000000000;;				DoRaw()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			health := make(map[string]interface{})
0000000000000000000000000000000000000000;;			err := json.Unmarshal(body, &health)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Bad json response from elasticsearch: %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			statusIntf, ok := health["status"]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				framework.Logf("No status field found in cluster health response: %v", health)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			status := statusIntf.(string)
0000000000000000000000000000000000000000;;			if status != "green" && status != "yellow" {
0000000000000000000000000000000000000000;;				framework.Logf("Cluster health has bad status: %v", health)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil && ok {
0000000000000000000000000000000000000000;;				healthy = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !healthy {
0000000000000000000000000000000000000000;;			return fmt.Errorf("after %v elasticsearch cluster is not healthy", esRetryTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (logsProvider *esLogsProvider) Cleanup() {
0000000000000000000000000000000000000000;;		// Nothing to do
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (logsProvider *esLogsProvider) ReadEntries(pod *loggingPod) []logEntry {
0000000000000000000000000000000000000000;;		f := logsProvider.Framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxyRequest, errProxy := framework.GetServicesProxyRequest(f.ClientSet, f.ClientSet.Core().RESTClient().Get())
0000000000000000000000000000000000000000;;		if errProxy != nil {
0000000000000000000000000000000000000000;;			framework.Logf("Failed to get services proxy request: %v", errProxy)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		query := fmt.Sprintf("kubernetes.pod_name:%s AND kubernetes.namespace_name:%s", pod.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;		framework.Logf("Sending a search request to Elasticsearch with the following query: %s", query)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ask Elasticsearch to return all the log lines that were tagged with the
0000000000000000000000000000000000000000;;		// pod name. Ask for ten times as many log lines because duplication is possible.
0000000000000000000000000000000000000000;;		body, err := proxyRequest.Namespace(api.NamespaceSystem).
0000000000000000000000000000000000000000;;			Name("elasticsearch-logging").
0000000000000000000000000000000000000000;;			Suffix("_search").
0000000000000000000000000000000000000000;;			Param("q", query).
0000000000000000000000000000000000000000;;			// Ask for more in case we included some unrelated records in our query
0000000000000000000000000000000000000000;;			Param("size", strconv.Itoa(pod.ExpectedLinesNumber*10)).
0000000000000000000000000000000000000000;;			DoRaw()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Logf("Failed to make proxy call to elasticsearch-logging: %v", err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var response map[string]interface{}
0000000000000000000000000000000000000000;;		err = json.Unmarshal(body, &response)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Logf("Failed to unmarshal response: %v", err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hits, ok := response["hits"].(map[string]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			framework.Logf("response[hits] not of the expected type: %T", response["hits"])
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h, ok := hits["hits"].([]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			framework.Logf("Hits not of the expected type: %T", hits["hits"])
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		entries := []logEntry{}
0000000000000000000000000000000000000000;;		// Iterate over the hits and populate the observed array.
0000000000000000000000000000000000000000;;		for _, e := range h {
0000000000000000000000000000000000000000;;			l, ok := e.(map[string]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				framework.Logf("Element of hit not of expected type: %T", e)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			source, ok := l["_source"].(map[string]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				framework.Logf("_source not of the expected type: %T", l["_source"])
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			msg, ok := source["log"].(string)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				framework.Logf("Log not of the expected type: %T", source["log"])
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			entries = append(entries, logEntry{Payload: msg})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return entries
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (logsProvider *esLogsProvider) FluentdApplicationName() string {
0000000000000000000000000000000000000000;;		return "fluentd-es"
0000000000000000000000000000000000000000;;	}
