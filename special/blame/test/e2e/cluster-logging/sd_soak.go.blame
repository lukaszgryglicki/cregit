0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
57cddc74314ee1c203f913729a8118034faed4e0;test/e2e/cluster_logging_gcl_load.go[test/e2e/cluster_logging_gcl_load.go][test/e2e/cluster-logging/sd_soak.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		meta_v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// maxAllowedLostFraction is the fraction of lost logs considered acceptable.
0000000000000000000000000000000000000000;;		maxAllowedLostFraction = 0.01
0000000000000000000000000000000000000000;;		// maxAllowedRestartsPerHour is the number of fluentd container restarts
0000000000000000000000000000000000000000;;		// considered acceptable. Once per hour is fine for now, as long as it
0000000000000000000000000000000000000000;;		// doesn't loose too much logs.
0000000000000000000000000000000000000000;;		maxAllowedRestartsPerHour = 1.0
0000000000000000000000000000000000000000;;		// lastPodIngestionSlack is the amount of time to wait for the last pod's
0000000000000000000000000000000000000000;;		// logs to be ingested by the logging agent.
0000000000000000000000000000000000000000;;		lastPodIngestionSlack = 5 * time.Minute
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Cluster level logging implemented by Stackdriver [Feature:StackdriverLogging] [Soak]", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("sd-logging-load")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should ingest logs from applications running for a prolonged amount of time", func() {
0000000000000000000000000000000000000000;;			sdLogsProvider, err := newSdLogsProvider(f)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err, "Failed to create Stackdriver logs provider")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = sdLogsProvider.Init()
0000000000000000000000000000000000000000;;			defer sdLogsProvider.Cleanup()
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err, "Failed to init Stackdriver logs provider")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nodes := framework.GetReadySchedulableNodesOrDie(f.ClientSet).Items
0000000000000000000000000000000000000000;;			maxPodCount := 10
0000000000000000000000000000000000000000;;			jobDuration := 1 * time.Hour
0000000000000000000000000000000000000000;;			linesPerPodPerSecond := 100
0000000000000000000000000000000000000000;;			testDuration := 21 * time.Hour
0000000000000000000000000000000000000000;;			ingestionTimeout := testDuration + 30*time.Minute
0000000000000000000000000000000000000000;;			allowedRestarts := int(math.Ceil(float64(testDuration) /
0000000000000000000000000000000000000000;;				float64(time.Hour) * maxAllowedRestartsPerHour))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			podRunDelay := time.Duration(int64(jobDuration) / int64(maxPodCount))
0000000000000000000000000000000000000000;;			podRunCount := maxPodCount*(int(testDuration/jobDuration)-1) + 1
0000000000000000000000000000000000000000;;			linesPerPod := linesPerPodPerSecond * int(jobDuration.Seconds())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pods := []*loggingPod{}
0000000000000000000000000000000000000000;;			for runIdx := 0; runIdx < podRunCount; runIdx++ {
0000000000000000000000000000000000000000;;				for nodeIdx, node := range nodes {
0000000000000000000000000000000000000000;;					podName := fmt.Sprintf("job-logs-generator-%d-%d-%d-%d", maxPodCount, linesPerPod, runIdx, nodeIdx)
0000000000000000000000000000000000000000;;					pods = append(pods, newLoggingPod(podName, node.Name, linesPerPod, jobDuration))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Running short-living pods")
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				for _, pod := range pods {
0000000000000000000000000000000000000000;;					pod.Start(f)
0000000000000000000000000000000000000000;;					time.Sleep(podRunDelay)
0000000000000000000000000000000000000000;;					defer f.PodClient().Delete(pod.Name, &meta_v1.DeleteOptions{})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Waiting until the last pod has completed
0000000000000000000000000000000000000000;;				time.Sleep(jobDuration - podRunDelay + lastPodIngestionSlack)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Waiting for all log lines to be ingested")
0000000000000000000000000000000000000000;;			config := &loggingTestConfig{
0000000000000000000000000000000000000000;;				LogsProvider:              sdLogsProvider,
0000000000000000000000000000000000000000;;				Pods:                      pods,
0000000000000000000000000000000000000000;;				IngestionTimeout:          ingestionTimeout,
0000000000000000000000000000000000000000;;				MaxAllowedLostFraction:    maxAllowedLostFraction,
0000000000000000000000000000000000000000;;				MaxAllowedFluentdRestarts: allowedRestarts,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = waitForFullLogsIngestion(f, config)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to ingest logs: %v", err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				framework.Logf("Successfully ingested all logs")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
