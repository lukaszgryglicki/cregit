0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
bfd082647ed57b69456e4c2d5e719a0690dd12a8;test/e2e/cluster_logging_utils.go[test/e2e/cluster_logging_utils.go][test/e2e/cluster-logging/utils.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		api_v1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		meta_v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/integer"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Duration of delay between any two attempts to check if all logs are ingested
0000000000000000000000000000000000000000;;		ingestionRetryDelay = 30 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Amount of requested cores for logging container in millicores
0000000000000000000000000000000000000000;;		loggingContainerCpuRequest = 10
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Amount of requested memory for logging container in bytes
0000000000000000000000000000000000000000;;		loggingContainerMemoryRequest = 10 * 1024 * 1024
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name of the container used for logging tests
0000000000000000000000000000000000000000;;		loggingContainerName = "logging-container"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Regexp, matching the contents of log entries, parsed or not
0000000000000000000000000000000000000000;;		logEntryMessageRegex = regexp.MustCompile("(?:I\\d+ \\d+:\\d+:\\d+.\\d+       \\d+ logs_generator.go:67] )?(\\d+) .*")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type logEntry struct {
0000000000000000000000000000000000000000;;		Payload string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry logEntry) getLogEntryNumber() (int, bool) {
0000000000000000000000000000000000000000;;		submatch := logEntryMessageRegex.FindStringSubmatch(entry.Payload)
0000000000000000000000000000000000000000;;		if submatch == nil || len(submatch) < 2 {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lineNumber, err := strconv.Atoi(submatch[1])
0000000000000000000000000000000000000000;;		return lineNumber, err == nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type logsProvider interface {
0000000000000000000000000000000000000000;;		Init() error
0000000000000000000000000000000000000000;;		Cleanup()
0000000000000000000000000000000000000000;;		ReadEntries(*loggingPod) []logEntry
0000000000000000000000000000000000000000;;		FluentdApplicationName() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type loggingTestConfig struct {
0000000000000000000000000000000000000000;;		LogsProvider              logsProvider
0000000000000000000000000000000000000000;;		Pods                      []*loggingPod
0000000000000000000000000000000000000000;;		IngestionTimeout          time.Duration
0000000000000000000000000000000000000000;;		MaxAllowedLostFraction    float64
0000000000000000000000000000000000000000;;		MaxAllowedFluentdRestarts int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type to track the progress of logs generating pod
0000000000000000000000000000000000000000;;	type loggingPod struct {
0000000000000000000000000000000000000000;;		// Name equals to the pod name and the container name.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// NodeName is the name of the node this pod will be
0000000000000000000000000000000000000000;;		// assigned to. Can be empty.
0000000000000000000000000000000000000000;;		NodeName string
0000000000000000000000000000000000000000;;		// Occurrences is a cache of ingested and read entries.
0000000000000000000000000000000000000000;;		Occurrences map[int]logEntry
0000000000000000000000000000000000000000;;		// ExpectedLinesNumber is the number of lines that are
0000000000000000000000000000000000000000;;		// expected to be ingested from this pod.
0000000000000000000000000000000000000000;;		ExpectedLinesNumber int
0000000000000000000000000000000000000000;;		// RunDuration is how long the pod will live.
0000000000000000000000000000000000000000;;		RunDuration time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newLoggingPod(podName string, nodeName string, totalLines int, loggingDuration time.Duration) *loggingPod {
0000000000000000000000000000000000000000;;		return &loggingPod{
0000000000000000000000000000000000000000;;			Name:                podName,
0000000000000000000000000000000000000000;;			NodeName:            nodeName,
0000000000000000000000000000000000000000;;			Occurrences:         make(map[int]logEntry),
0000000000000000000000000000000000000000;;			ExpectedLinesNumber: totalLines,
0000000000000000000000000000000000000000;;			RunDuration:         loggingDuration,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *loggingPod) Start(f *framework.Framework) {
0000000000000000000000000000000000000000;;		framework.Logf("Starting pod %s", p.Name)
0000000000000000000000000000000000000000;;		f.PodClient().Create(&api_v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: meta_v1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: p.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api_v1.PodSpec{
0000000000000000000000000000000000000000;;				RestartPolicy: api_v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				Containers: []api_v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  loggingContainerName,
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/logs-generator:v0.1.0",
0000000000000000000000000000000000000000;;						Env: []api_v1.EnvVar{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "LOGS_GENERATOR_LINES_TOTAL",
0000000000000000000000000000000000000000;;								Value: strconv.Itoa(p.ExpectedLinesNumber),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "LOGS_GENERATOR_DURATION",
0000000000000000000000000000000000000000;;								Value: p.RunDuration.String(),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Resources: api_v1.ResourceRequirements{
0000000000000000000000000000000000000000;;							Requests: api_v1.ResourceList{
0000000000000000000000000000000000000000;;								api_v1.ResourceCPU: *resource.NewMilliQuantity(
0000000000000000000000000000000000000000;;									loggingContainerCpuRequest,
0000000000000000000000000000000000000000;;									resource.DecimalSI),
0000000000000000000000000000000000000000;;								api_v1.ResourceMemory: *resource.NewQuantity(
0000000000000000000000000000000000000000;;									loggingContainerMemoryRequest,
0000000000000000000000000000000000000000;;									resource.BinarySI),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				NodeName: p.NodeName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startNewLoggingPod(f *framework.Framework, podName string, nodeName string, totalLines int, loggingDuration time.Duration) *loggingPod {
0000000000000000000000000000000000000000;;		pod := newLoggingPod(podName, nodeName, totalLines, loggingDuration)
0000000000000000000000000000000000000000;;		pod.Start(f)
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForSomeLogs(f *framework.Framework, config *loggingTestConfig) error {
0000000000000000000000000000000000000000;;		podHasIngestedLogs := make([]bool, len(config.Pods))
0000000000000000000000000000000000000000;;		podWithIngestedLogsCount := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < config.IngestionTimeout; time.Sleep(ingestionRetryDelay) {
0000000000000000000000000000000000000000;;			for podIdx, pod := range config.Pods {
0000000000000000000000000000000000000000;;				if podHasIngestedLogs[podIdx] {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				entries := config.LogsProvider.ReadEntries(pod)
0000000000000000000000000000000000000000;;				if len(entries) == 0 {
0000000000000000000000000000000000000000;;					framework.Logf("No log entries from pod %s", pod.Name)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for _, entry := range entries {
0000000000000000000000000000000000000000;;					if _, ok := entry.getLogEntryNumber(); ok {
0000000000000000000000000000000000000000;;						framework.Logf("Found some log entries from pod %s", pod.Name)
0000000000000000000000000000000000000000;;						podHasIngestedLogs[podIdx] = true
0000000000000000000000000000000000000000;;						podWithIngestedLogsCount++
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if podWithIngestedLogsCount == len(config.Pods) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if podWithIngestedLogsCount < len(config.Pods) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("some logs were ingested for %d pods out of %d", podWithIngestedLogsCount, len(config.Pods))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForFullLogsIngestion(f *framework.Framework, config *loggingTestConfig) error {
0000000000000000000000000000000000000000;;		expectedLinesNumber := 0
0000000000000000000000000000000000000000;;		for _, pod := range config.Pods {
0000000000000000000000000000000000000000;;			expectedLinesNumber += pod.ExpectedLinesNumber
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		totalMissing := expectedLinesNumber
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		missingByPod := make([]int, len(config.Pods))
0000000000000000000000000000000000000000;;		for podIdx, pod := range config.Pods {
0000000000000000000000000000000000000000;;			missingByPod[podIdx] = pod.ExpectedLinesNumber
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < config.IngestionTimeout; time.Sleep(ingestionRetryDelay) {
0000000000000000000000000000000000000000;;			missing := 0
0000000000000000000000000000000000000000;;			for podIdx, pod := range config.Pods {
0000000000000000000000000000000000000000;;				if missingByPod[podIdx] == 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				missingByPod[podIdx] = pullMissingLogsCount(config.LogsProvider, pod)
0000000000000000000000000000000000000000;;				missing += missingByPod[podIdx]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			totalMissing = missing
0000000000000000000000000000000000000000;;			if totalMissing > 0 {
0000000000000000000000000000000000000000;;				framework.Logf("Still missing %d lines in total", totalMissing)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lostFraction := float64(totalMissing) / float64(expectedLinesNumber)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if totalMissing > 0 {
0000000000000000000000000000000000000000;;			framework.Logf("After %v still missing %d lines, %.2f%% of total number of lines",
0000000000000000000000000000000000000000;;				config.IngestionTimeout, totalMissing, lostFraction*100)
0000000000000000000000000000000000000000;;			for podIdx, missing := range missingByPod {
0000000000000000000000000000000000000000;;				if missing != 0 {
0000000000000000000000000000000000000000;;					framework.Logf("Still missing %d lines for pod %v", missing, config.Pods[podIdx])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lostFraction > config.MaxAllowedLostFraction {
0000000000000000000000000000000000000000;;			return fmt.Errorf("lost %.2f%% of lines, but only loss of %.2f%% can be tolerated",
0000000000000000000000000000000000000000;;				lostFraction*100, config.MaxAllowedLostFraction*100)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fluentdPods, err := getFluentdPods(f, config.LogsProvider.FluentdApplicationName())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to get fluentd pods due to %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		maxRestartCount := 0
0000000000000000000000000000000000000000;;		for _, fluentdPod := range fluentdPods.Items {
0000000000000000000000000000000000000000;;			restartCount := int(fluentdPod.Status.ContainerStatuses[0].RestartCount)
0000000000000000000000000000000000000000;;			maxRestartCount = integer.IntMax(maxRestartCount, restartCount)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			framework.Logf("Fluentd pod %s on node %s was restarted %d times",
0000000000000000000000000000000000000000;;				fluentdPod.Name, fluentdPod.Spec.NodeName, restartCount)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if maxRestartCount > config.MaxAllowedFluentdRestarts {
0000000000000000000000000000000000000000;;			return fmt.Errorf("max fluentd pod restarts was %d, which is more than allowed %d",
0000000000000000000000000000000000000000;;				maxRestartCount, config.MaxAllowedFluentdRestarts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pullMissingLogsCount(logsProvider logsProvider, pod *loggingPod) int {
0000000000000000000000000000000000000000;;		missingOnPod, err := getMissingLinesCount(logsProvider, pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Logf("Failed to get missing lines count from pod %s due to %v", pod.Name, err)
0000000000000000000000000000000000000000;;			return pod.ExpectedLinesNumber
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return missingOnPod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getMissingLinesCount(logsProvider logsProvider, pod *loggingPod) (int, error) {
0000000000000000000000000000000000000000;;		entries := logsProvider.ReadEntries(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, entry := range entries {
0000000000000000000000000000000000000000;;			lineNumber, ok := entry.getLogEntryNumber()
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if lineNumber < 0 || lineNumber >= pod.ExpectedLinesNumber {
0000000000000000000000000000000000000000;;				framework.Logf("Unexpected line number: %d", lineNumber)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				pod.Occurrences[lineNumber] = entry
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pod.ExpectedLinesNumber - len(pod.Occurrences), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ensureSingleFluentdOnEachNode(f *framework.Framework, fluentdApplicationName string) error {
0000000000000000000000000000000000000000;;		fluentdPodList, err := getFluentdPods(f, fluentdApplicationName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fluentdPodsPerNode := make(map[string]int)
0000000000000000000000000000000000000000;;		for _, fluentdPod := range fluentdPodList.Items {
0000000000000000000000000000000000000000;;			fluentdPodsPerNode[fluentdPod.Spec.NodeName]++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeList := framework.GetReadySchedulableNodesOrDie(f.ClientSet)
0000000000000000000000000000000000000000;;		for _, node := range nodeList.Items {
0000000000000000000000000000000000000000;;			fluentdPodCount, ok := fluentdPodsPerNode[node.Name]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf("node %s doesn't have fluentd instance", node.Name)
0000000000000000000000000000000000000000;;			} else if fluentdPodCount != 1 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("node %s contains %d fluentd instaces, expected exactly one", node.Name, fluentdPodCount)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getFluentdPods(f *framework.Framework, fluentdApplicationName string) (*api_v1.PodList, error) {
0000000000000000000000000000000000000000;;		label := labels.SelectorFromSet(labels.Set(map[string]string{"k8s-app": fluentdApplicationName}))
0000000000000000000000000000000000000000;;		options := meta_v1.ListOptions{LabelSelector: label.String()}
0000000000000000000000000000000000000000;;		return f.ClientSet.Core().Pods(api.NamespaceSystem).List(options)
0000000000000000000000000000000000000000;;	}
