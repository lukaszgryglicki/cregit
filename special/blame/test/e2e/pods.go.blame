0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
00aafb4557783241eeb114503f11986cb054b183;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Pods Extended", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("pods")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Delete Grace Period", func() {
0000000000000000000000000000000000000000;;			var podClient *framework.PodClient
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				podClient = f.PodClient()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			// Flaky issue #36821.
0000000000000000000000000000000000000000;;			It("should be submitted and removed [Conformance] [Flaky]", func() {
0000000000000000000000000000000000000000;;				By("creating the pod")
0000000000000000000000000000000000000000;;				name := "pod-submit-remove-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;				value := strconv.Itoa(time.Now().Nanosecond())
0000000000000000000000000000000000000000;;				pod := &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: name,
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"name": "foo",
0000000000000000000000000000000000000000;;							"time": value,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "nginx",
0000000000000000000000000000000000000000;;								Image: "gcr.io/google_containers/nginx-slim:0.7",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("setting up watch")
0000000000000000000000000000000000000000;;				selector := labels.SelectorFromSet(labels.Set(map[string]string{"time": value}))
0000000000000000000000000000000000000000;;				options := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;				pods, err := podClient.List(options)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), "failed to query for pod")
0000000000000000000000000000000000000000;;				Expect(len(pods.Items)).To(Equal(0))
0000000000000000000000000000000000000000;;				options = metav1.ListOptions{
0000000000000000000000000000000000000000;;					LabelSelector:   selector.String(),
0000000000000000000000000000000000000000;;					ResourceVersion: pods.ListMeta.ResourceVersion,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w, err := podClient.Watch(options)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), "failed to set up watch")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("submitting the pod to kubernetes")
0000000000000000000000000000000000000000;;				podClient.Create(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("verifying the pod is in kubernetes")
0000000000000000000000000000000000000000;;				selector = labels.SelectorFromSet(labels.Set(map[string]string{"time": value}))
0000000000000000000000000000000000000000;;				options = metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;				pods, err = podClient.List(options)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), "failed to query for pod")
0000000000000000000000000000000000000000;;				Expect(len(pods.Items)).To(Equal(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("verifying pod creation was observed")
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case event, _ := <-w.ResultChan():
0000000000000000000000000000000000000000;;					if event.Type != watch.Added {
0000000000000000000000000000000000000000;;						framework.Failf("Failed to observe pod creation: %v", event)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case <-time.After(framework.PodStartTimeout):
0000000000000000000000000000000000000000;;					framework.Failf("Timeout while waiting for pod creation")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// We need to wait for the pod to be running, otherwise the deletion
0000000000000000000000000000000000000000;;				// may be carried out immediately rather than gracefully.
0000000000000000000000000000000000000000;;				framework.ExpectNoError(f.WaitForPodRunning(pod.Name))
0000000000000000000000000000000000000000;;				// save the running pod
0000000000000000000000000000000000000000;;				pod, err = podClient.Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), "failed to GET scheduled pod")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// start local proxy, so we can send graceful deletion over query string, rather than body parameter
0000000000000000000000000000000000000000;;				cmd := framework.KubectlCmd("proxy", "-p", "0")
0000000000000000000000000000000000000000;;				stdout, stderr, err := framework.StartCmdAndStreamOutput(cmd)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), "failed to start up proxy")
0000000000000000000000000000000000000000;;				defer stdout.Close()
0000000000000000000000000000000000000000;;				defer stderr.Close()
0000000000000000000000000000000000000000;;				defer framework.TryKill(cmd)
0000000000000000000000000000000000000000;;				buf := make([]byte, 128)
0000000000000000000000000000000000000000;;				var n int
0000000000000000000000000000000000000000;;				n, err = stdout.Read(buf)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), "failed to read from kubectl proxy stdout")
0000000000000000000000000000000000000000;;				output := string(buf[:n])
0000000000000000000000000000000000000000;;				proxyRegexp := regexp.MustCompile("Starting to serve on 127.0.0.1:([0-9]+)")
0000000000000000000000000000000000000000;;				match := proxyRegexp.FindStringSubmatch(output)
0000000000000000000000000000000000000000;;				Expect(len(match)).To(Equal(2))
0000000000000000000000000000000000000000;;				port, err := strconv.Atoi(match[1])
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), "failed to convert port into string")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				endpoint := fmt.Sprintf("http://localhost:%d/api/v1/namespaces/%s/pods/%s?gracePeriodSeconds=30", port, pod.Namespace, pod.Name)
0000000000000000000000000000000000000000;;				tr := &http.Transport{
0000000000000000000000000000000000000000;;					TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				client := &http.Client{Transport: tr}
0000000000000000000000000000000000000000;;				req, err := http.NewRequest("DELETE", endpoint, nil)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), "failed to create http request")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("deleting the pod gracefully")
0000000000000000000000000000000000000000;;				rsp, err := client.Do(req)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), "failed to use http client to send delete")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer rsp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("verifying the kubelet observed the termination notice")
0000000000000000000000000000000000000000;;				Expect(wait.Poll(time.Second*5, time.Second*30, func() (bool, error) {
0000000000000000000000000000000000000000;;					podList, err := framework.GetKubeletPods(f.ClientSet, pod.Spec.NodeName)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						framework.Logf("Unable to retrieve kubelet pods for node %v: %v", pod.Spec.NodeName, err)
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for _, kubeletPod := range podList.Items {
0000000000000000000000000000000000000000;;						if pod.Name != kubeletPod.Name {
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if kubeletPod.ObjectMeta.DeletionTimestamp == nil {
0000000000000000000000000000000000000000;;							framework.Logf("deletion has not yet been observed")
0000000000000000000000000000000000000000;;							return false, nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return true, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					framework.Logf("no pod exists with the name we were looking for, assuming the termination request was observed and completed")
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				})).NotTo(HaveOccurred(), "kubelet never observed the termination notice")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("verifying pod deletion was observed")
0000000000000000000000000000000000000000;;				deleted := false
0000000000000000000000000000000000000000;;				timeout := false
0000000000000000000000000000000000000000;;				var lastPod *v1.Pod
0000000000000000000000000000000000000000;;				timer := time.After(1 * time.Minute)
0000000000000000000000000000000000000000;;				for !deleted && !timeout {
0000000000000000000000000000000000000000;;					select {
0000000000000000000000000000000000000000;;					case event, _ := <-w.ResultChan():
0000000000000000000000000000000000000000;;						if event.Type == watch.Deleted {
0000000000000000000000000000000000000000;;							lastPod = event.Object.(*v1.Pod)
0000000000000000000000000000000000000000;;							deleted = true
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case <-timer:
0000000000000000000000000000000000000000;;						timeout = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !deleted {
0000000000000000000000000000000000000000;;					framework.Failf("Failed to observe pod deletion")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Expect(lastPod.DeletionTimestamp).ToNot(BeNil())
0000000000000000000000000000000000000000;;				Expect(lastPod.Spec.TerminationGracePeriodSeconds).ToNot(BeZero())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				selector = labels.SelectorFromSet(labels.Set(map[string]string{"time": value}))
0000000000000000000000000000000000000000;;				options = metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;				pods, err = podClient.List(options)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), "failed to query for pods")
0000000000000000000000000000000000000000;;				Expect(len(pods.Items)).To(Equal(0))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Pods Set QOS Class", func() {
0000000000000000000000000000000000000000;;			var podClient *framework.PodClient
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				podClient = f.PodClient()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			It("should be submitted and removed [Conformance]", func() {
0000000000000000000000000000000000000000;;				By("creating the pod")
0000000000000000000000000000000000000000;;				name := "pod-qos-class-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;				pod := &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: name,
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"name": name,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "nginx",
0000000000000000000000000000000000000000;;								Image: "gcr.io/google_containers/nginx-slim:0.7",
0000000000000000000000000000000000000000;;								Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;									Limits: v1.ResourceList{
0000000000000000000000000000000000000000;;										"cpu":    resource.MustParse("100m"),
0000000000000000000000000000000000000000;;										"memory": resource.MustParse("100Mi"),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;										"cpu":    resource.MustParse("100m"),
0000000000000000000000000000000000000000;;										"memory": resource.MustParse("100Mi"),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("submitting the pod to kubernetes")
0000000000000000000000000000000000000000;;				podClient.Create(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("verifying QOS class is set on the pod")
0000000000000000000000000000000000000000;;				pod, err := podClient.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), "failed to query for pod")
0000000000000000000000000000000000000000;;				Expect(pod.Status.QOSClass == v1.PodQOSGuaranteed)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
