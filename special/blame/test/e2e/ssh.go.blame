0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
77db392f8a3d6222aa24fb436d6085ab04253a41;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const maxNodes = 100
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("SSH", func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("ssh")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			// When adding more providers here, also implement their functionality in util.go's framework.GetSigner(...).
0000000000000000000000000000000000000000;;			framework.SkipUnlessProviderIs(framework.ProvidersWithSSH...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// This test SSH's into the node for which it needs the $HOME/.ssh/id_rsa key to be present. So
0000000000000000000000000000000000000000;;			// we should skip if the environment does not have the key (not all CI systems support this use case)
0000000000000000000000000000000000000000;;			framework.SkipUnlessSSHKeyPresent()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should SSH to all nodes and run commands", func() {
0000000000000000000000000000000000000000;;			// Get all nodes' external IPs.
0000000000000000000000000000000000000000;;			By("Getting all nodes' SSH-able IP addresses")
0000000000000000000000000000000000000000;;			hosts, err := framework.NodeSSHHosts(f.ClientSet)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Error getting node hostnames: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			testCases := []struct {
0000000000000000000000000000000000000000;;				cmd            string
0000000000000000000000000000000000000000;;				checkStdout    bool
0000000000000000000000000000000000000000;;				expectedStdout string
0000000000000000000000000000000000000000;;				expectedStderr string
0000000000000000000000000000000000000000;;				expectedCode   int
0000000000000000000000000000000000000000;;				expectedError  error
0000000000000000000000000000000000000000;;			}{
0000000000000000000000000000000000000000;;				// Keep this test first - this variant runs on all nodes.
0000000000000000000000000000000000000000;;				{`echo "Hello from $(whoami)@$(hostname)"`, false, "", "", 0, nil},
0000000000000000000000000000000000000000;;				{`echo "foo" | grep "bar"`, true, "", "", 1, nil},
0000000000000000000000000000000000000000;;				{`echo "Out" && echo "Error" >&2 && exit 7`, true, "Out", "Error", 7, nil},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i, testCase := range testCases {
0000000000000000000000000000000000000000;;				// Only run the first testcase against max 100 nodes. Run
0000000000000000000000000000000000000000;;				// the rest against the first node we find only, since
0000000000000000000000000000000000000000;;				// they're basically testing SSH semantics (and we don't
0000000000000000000000000000000000000000;;				// need to do that against each host in the cluster).
0000000000000000000000000000000000000000;;				nodes := len(hosts)
0000000000000000000000000000000000000000;;				if i > 0 {
0000000000000000000000000000000000000000;;					nodes = 1
0000000000000000000000000000000000000000;;				} else if nodes > maxNodes {
0000000000000000000000000000000000000000;;					nodes = maxNodes
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				testhosts := hosts[:nodes]
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("SSH'ing to %d nodes and running %s", len(testhosts), testCase.cmd))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for _, host := range testhosts {
0000000000000000000000000000000000000000;;					result, err := framework.SSH(testCase.cmd, host, framework.TestContext.Provider)
0000000000000000000000000000000000000000;;					stdout, stderr := strings.TrimSpace(result.Stdout), strings.TrimSpace(result.Stderr)
0000000000000000000000000000000000000000;;					if err != testCase.expectedError {
0000000000000000000000000000000000000000;;						framework.Failf("Ran %s on %s, got error %v, expected %v", testCase.cmd, host, err, testCase.expectedError)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if testCase.checkStdout && stdout != testCase.expectedStdout {
0000000000000000000000000000000000000000;;						framework.Failf("Ran %s on %s, got stdout '%s', expected '%s'", testCase.cmd, host, stdout, testCase.expectedStdout)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if stderr != testCase.expectedStderr {
0000000000000000000000000000000000000000;;						framework.Failf("Ran %s on %s, got stderr '%s', expected '%s'", testCase.cmd, host, stderr, testCase.expectedStderr)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if result.Code != testCase.expectedCode {
0000000000000000000000000000000000000000;;						framework.Failf("Ran %s on %s, got exit code %d, expected %d", testCase.cmd, host, result.Code, testCase.expectedCode)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Show stdout, stderr for logging purposes.
0000000000000000000000000000000000000000;;					if len(stdout) > 0 {
0000000000000000000000000000000000000000;;						framework.Logf("Got stdout from %s: %s", host, strings.TrimSpace(stdout))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if len(stderr) > 0 {
0000000000000000000000000000000000000000;;						framework.Logf("Got stderr from %s: %s", host, strings.TrimSpace(stderr))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Quickly test that SSH itself errors correctly.
0000000000000000000000000000000000000000;;			By("SSH'ing to a nonexistent host")
0000000000000000000000000000000000000000;;			if _, err = framework.SSH(`echo "hello"`, "i.do.not.exist", framework.TestContext.Provider); err == nil {
0000000000000000000000000000000000000000;;				framework.Failf("Expected error trying to SSH to nonexistent host.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
