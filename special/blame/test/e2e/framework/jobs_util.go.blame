0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
cd2f43c46ab57405540ab581e5d6907fcd161754;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		batch "k8s.io/api/batch/v1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// How long to wait for a job to finish.
0000000000000000000000000000000000000000;;		JobTimeout = 15 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Job selector name
0000000000000000000000000000000000000000;;		JobSelectorKey = "job"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTestJob returns a Job which does one of several testing behaviors. notTerminate starts a Job that will run
0000000000000000000000000000000000000000;;	// effectively forever. fail starts a Job that will fail immediately. succeed starts a Job that will succeed
0000000000000000000000000000000000000000;;	// immediately. randomlySucceedOrFail starts a Job that will succeed or fail randomly. failOnce fails the Job the
0000000000000000000000000000000000000000;;	// first time it is run and succeeds subsequently. name is the Name of the Job. RestartPolicy indicates the restart
0000000000000000000000000000000000000000;;	// policy of the containers in which the Pod is running. Parallelism is the Job's parallelism, and completions is the
0000000000000000000000000000000000000000;;	// Job's required number of completions.
0000000000000000000000000000000000000000;;	func NewTestJob(behavior, name string, rPol v1.RestartPolicy, parallelism, completions int32) *batch.Job {
0000000000000000000000000000000000000000;;		job := &batch.Job{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind: "Job",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: batch.JobSpec{
0000000000000000000000000000000000000000;;				Parallelism:    &parallelism,
0000000000000000000000000000000000000000;;				Completions:    &completions,
0000000000000000000000000000000000000000;;				ManualSelector: newBool(false),
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{JobSelectorKey: name},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						RestartPolicy: rPol,
0000000000000000000000000000000000000000;;						Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: "data",
0000000000000000000000000000000000000000;;								VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;									EmptyDir: &v1.EmptyDirVolumeSource{},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:    "c",
0000000000000000000000000000000000000000;;								Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;								Command: []string{},
0000000000000000000000000000000000000000;;								VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										MountPath: "/data",
0000000000000000000000000000000000000000;;										Name:      "data",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch behavior {
0000000000000000000000000000000000000000;;		case "notTerminate":
0000000000000000000000000000000000000000;;			job.Spec.Template.Spec.Containers[0].Command = []string{"sleep", "1000000"}
0000000000000000000000000000000000000000;;		case "fail":
0000000000000000000000000000000000000000;;			job.Spec.Template.Spec.Containers[0].Command = []string{"/bin/sh", "-c", "exit 1"}
0000000000000000000000000000000000000000;;		case "succeed":
0000000000000000000000000000000000000000;;			job.Spec.Template.Spec.Containers[0].Command = []string{"/bin/sh", "-c", "exit 0"}
0000000000000000000000000000000000000000;;		case "randomlySucceedOrFail":
0000000000000000000000000000000000000000;;			// Bash's $RANDOM generates pseudorandom int in range 0 - 32767.
0000000000000000000000000000000000000000;;			// Dividing by 16384 gives roughly 50/50 chance of success.
0000000000000000000000000000000000000000;;			job.Spec.Template.Spec.Containers[0].Command = []string{"/bin/sh", "-c", "exit $(( $RANDOM / 16384 ))"}
0000000000000000000000000000000000000000;;		case "failOnce":
0000000000000000000000000000000000000000;;			// Fail the first the container of the pod is run, and
0000000000000000000000000000000000000000;;			// succeed the second time. Checks for file on emptydir.
0000000000000000000000000000000000000000;;			// If present, succeed.  If not, create but fail.
0000000000000000000000000000000000000000;;			// Note that this cannot be used with RestartNever because
0000000000000000000000000000000000000000;;			// it always fails the first time for a pod.
0000000000000000000000000000000000000000;;			job.Spec.Template.Spec.Containers[0].Command = []string{"/bin/sh", "-c", "if [[ -r /data/foo ]] ; then exit 0 ; else touch /data/foo ; exit 1 ; fi"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return job
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetJob uses c to get the Job in namespace ns named name. If the returned error is nil, the returned Job is valid.
0000000000000000000000000000000000000000;;	func GetJob(c clientset.Interface, ns, name string) (*batch.Job, error) {
0000000000000000000000000000000000000000;;		return c.Batch().Jobs(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateJob uses c to create job in namespace ns. If the returned error is nil, the returned Job is valid and has
0000000000000000000000000000000000000000;;	// been created.
0000000000000000000000000000000000000000;;	func CreateJob(c clientset.Interface, ns string, job *batch.Job) (*batch.Job, error) {
0000000000000000000000000000000000000000;;		return c.Batch().Jobs(ns).Create(job)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateJob uses c to updated job in namespace ns. If the returned error is nil, the returned Job is valid and has
0000000000000000000000000000000000000000;;	// been updated.
0000000000000000000000000000000000000000;;	func UpdateJob(c clientset.Interface, ns string, job *batch.Job) (*batch.Job, error) {
0000000000000000000000000000000000000000;;		return c.Batch().Jobs(ns).Update(job)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateJobFunc updates the job object. It retries if there is a conflict, throw out error if
0000000000000000000000000000000000000000;;	// there is any other errors. name is the job name, updateFn is the function updating the
0000000000000000000000000000000000000000;;	// job object.
0000000000000000000000000000000000000000;;	func UpdateJobFunc(c clientset.Interface, ns, name string, updateFn func(job *batch.Job)) {
0000000000000000000000000000000000000000;;		ExpectNoError(wait.Poll(time.Millisecond*500, time.Second*30, func() (bool, error) {
0000000000000000000000000000000000000000;;			job, err := GetJob(c, ns, name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("failed to get pod %q: %v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			updateFn(job)
0000000000000000000000000000000000000000;;			_, err = UpdateJob(c, ns, job)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				Logf("Successfully updated job %q", name)
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if errors.IsConflict(err) {
0000000000000000000000000000000000000000;;				Logf("Conflicting update to job %q, re-get and re-update: %v", name, err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("failed to update job %q: %v", name, err)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteJob uses c to delete the Job named name in namespace ns. If the returned error is nil, the Job has been
0000000000000000000000000000000000000000;;	// deleted.
0000000000000000000000000000000000000000;;	func DeleteJob(c clientset.Interface, ns, name string) error {
0000000000000000000000000000000000000000;;		return c.Batch().Jobs(ns).Delete(name, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetJobPods returns a list of Pods belonging to a Job.
0000000000000000000000000000000000000000;;	func GetJobPods(c clientset.Interface, ns, jobName string) (*v1.PodList, error) {
0000000000000000000000000000000000000000;;		label := labels.SelectorFromSet(labels.Set(map[string]string{JobSelectorKey: jobName}))
0000000000000000000000000000000000000000;;		options := metav1.ListOptions{LabelSelector: label.String()}
0000000000000000000000000000000000000000;;		return c.CoreV1().Pods(ns).List(options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForAllJobPodsRunning wait for all pods for the Job named JobName in namespace ns to become Running.  Only use
0000000000000000000000000000000000000000;;	// when pods will run for a long time, or it will be racy.
0000000000000000000000000000000000000000;;	func WaitForAllJobPodsRunning(c clientset.Interface, ns, jobName string, parallelism int32) error {
0000000000000000000000000000000000000000;;		return wait.Poll(Poll, JobTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			pods, err := GetJobPods(c, ns, jobName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			count := int32(0)
0000000000000000000000000000000000000000;;			for _, p := range pods.Items {
0000000000000000000000000000000000000000;;				if p.Status.Phase == v1.PodRunning {
0000000000000000000000000000000000000000;;					count++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return count == parallelism, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForJobFinish uses c to wait for compeletions to complete for the Job jobName in namespace ns.
0000000000000000000000000000000000000000;;	func WaitForJobFinish(c clientset.Interface, ns, jobName string, completions int32) error {
0000000000000000000000000000000000000000;;		return wait.Poll(Poll, JobTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			curr, err := c.Batch().Jobs(ns).Get(jobName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return curr.Status.Succeeded == completions, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForJobFailure uses c to wait for up to timeout for the Job named jobName in namespace ns to fail.
0000000000000000000000000000000000000000;;	func WaitForJobFailure(c clientset.Interface, ns, jobName string, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		return wait.Poll(Poll, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			curr, err := c.Batch().Jobs(ns).Get(jobName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, c := range curr.Status.Conditions {
0000000000000000000000000000000000000000;;				if c.Type == batch.JobFailed && c.Status == v1.ConditionTrue {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckForAllJobPodsRunning uses c to check in the Job named jobName in ns is running. If the returned error is not
0000000000000000000000000000000000000000;;	// nil the returned bool is true if the Job is running.
0000000000000000000000000000000000000000;;	func CheckForAllJobPodsRunning(c clientset.Interface, ns, jobName string, parallelism int32) (bool, error) {
0000000000000000000000000000000000000000;;		label := labels.SelectorFromSet(labels.Set(map[string]string{JobSelectorKey: jobName}))
0000000000000000000000000000000000000000;;		options := metav1.ListOptions{LabelSelector: label.String()}
0000000000000000000000000000000000000000;;		pods, err := c.Core().Pods(ns).List(options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		count := int32(0)
0000000000000000000000000000000000000000;;		for _, p := range pods.Items {
0000000000000000000000000000000000000000;;			if p.Status.Phase == v1.PodRunning {
0000000000000000000000000000000000000000;;				count++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return count == parallelism, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newBool(val bool) *bool {
0000000000000000000000000000000000000000;;		p := new(bool)
0000000000000000000000000000000000000000;;		*p = val
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type updateJobFunc func(*batch.Job)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func UpdateJobWithRetries(c clientset.Interface, namespace, name string, applyUpdate updateJobFunc) (job *batch.Job, err error) {
0000000000000000000000000000000000000000;;		jobs := c.Batch().Jobs(namespace)
0000000000000000000000000000000000000000;;		var updateErr error
0000000000000000000000000000000000000000;;		pollErr := wait.PollImmediate(10*time.Millisecond, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			if job, err = jobs.Get(name, metav1.GetOptions{}); err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Apply the update, then attempt to push it to the apiserver.
0000000000000000000000000000000000000000;;			applyUpdate(job)
0000000000000000000000000000000000000000;;			if job, err = jobs.Update(job); err == nil {
0000000000000000000000000000000000000000;;				Logf("Updating job %s", name)
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			updateErr = err
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if pollErr == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			pollErr = fmt.Errorf("couldn't apply the provided updated to job %q: %v", name, updateErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return job, pollErr
0000000000000000000000000000000000000000;;	}
