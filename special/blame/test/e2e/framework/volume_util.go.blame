0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
b36c37be91e29d91a27d8a10c90a5fe317e18e72;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * This test checks that various VolumeSources are working.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * There are two ways, how to test the volumes:
0000000000000000000000000000000000000000;;	 * 1) With containerized server (NFS, Ceph, Gluster, iSCSI, ...)
0000000000000000000000000000000000000000;;	 * The test creates a server pod, exporting simple 'index.html' file.
0000000000000000000000000000000000000000;;	 * Then it uses appropriate VolumeSource to import this file into a client pod
0000000000000000000000000000000000000000;;	 * and checks that the pod can see the file. It does so by importing the file
0000000000000000000000000000000000000000;;	 * into web server root and loadind the index.html from it.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * These tests work only when privileged containers are allowed, exporting
0000000000000000000000000000000000000000;;	 * various filesystems (NFS, GlusterFS, ...) usually needs some mounting or
0000000000000000000000000000000000000000;;	 * other privileged magic in the server pod.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Note that the server containers are for testing purposes only and should not
0000000000000000000000000000000000000000;;	 * be used in production.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * 2) With server outside of Kubernetes (Cinder, ...)
0000000000000000000000000000000000000000;;	 * Appropriate server (e.g. OpenStack Cinder) must exist somewhere outside
0000000000000000000000000000000000000000;;	 * the tested Kubernetes cluster. The test itself creates a new volume,
0000000000000000000000000000000000000000;;	 * and checks, that Kubernetes can use it as a volume.
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrs "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Current supported images for e2e volume testing to be assigned to VolumeTestConfig.serverImage
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		NfsServerImage       string = "gcr.io/google_containers/volume-nfs:0.8"
0000000000000000000000000000000000000000;;		IscsiServerImage     string = "gcr.io/google_containers/volume-iscsi:0.1"
0000000000000000000000000000000000000000;;		GlusterfsServerImage string = "gcr.io/google_containers/volume-gluster:0.2"
0000000000000000000000000000000000000000;;		CephServerImage      string = "gcr.io/google_containers/volume-ceph:0.1"
0000000000000000000000000000000000000000;;		RbdServerImage       string = "gcr.io/google_containers/volume-rbd:0.1"
0000000000000000000000000000000000000000;;		BusyBoxImage         string = "gcr.io/google_containers/busybox:1.24"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Configuration of one tests. The test consist of:
0000000000000000000000000000000000000000;;	// - server pod - runs serverImage, exports ports[]
0000000000000000000000000000000000000000;;	// - client pod - does not need any special configuration
0000000000000000000000000000000000000000;;	type VolumeTestConfig struct {
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;		// Prefix of all pods. Typically the test name.
0000000000000000000000000000000000000000;;		Prefix string
0000000000000000000000000000000000000000;;		// Name of container image for the server pod.
0000000000000000000000000000000000000000;;		ServerImage string
0000000000000000000000000000000000000000;;		// Ports to export from the server pod. TCP only.
0000000000000000000000000000000000000000;;		ServerPorts []int
0000000000000000000000000000000000000000;;		// Commands to run in the container image.
0000000000000000000000000000000000000000;;		ServerCmds []string
0000000000000000000000000000000000000000;;		// Arguments to pass to the container image.
0000000000000000000000000000000000000000;;		ServerArgs []string
0000000000000000000000000000000000000000;;		// Volumes needed to be mounted to the server container from the host
0000000000000000000000000000000000000000;;		// map <host (source) path> -> <container (dst.) path>
0000000000000000000000000000000000000000;;		ServerVolumes map[string]string
0000000000000000000000000000000000000000;;		// Wait for the pod to terminate successfully
0000000000000000000000000000000000000000;;		// False indicates that the pod is long running
0000000000000000000000000000000000000000;;		WaitForCompletion bool
0000000000000000000000000000000000000000;;		// NodeName to run pod on.  Default is any node.
0000000000000000000000000000000000000000;;		NodeName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeTest contains a volume to mount into a client pod and its
0000000000000000000000000000000000000000;;	// expected content.
0000000000000000000000000000000000000000;;	type VolumeTest struct {
0000000000000000000000000000000000000000;;		Volume          v1.VolumeSource
0000000000000000000000000000000000000000;;		File            string
0000000000000000000000000000000000000000;;		ExpectedContent string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Starts a container specified by config.serverImage and exports all
0000000000000000000000000000000000000000;;	// config.serverPorts from it. The returned pod should be used to get the server
0000000000000000000000000000000000000000;;	// IP address and create appropriate VolumeSource.
0000000000000000000000000000000000000000;;	func StartVolumeServer(client clientset.Interface, config VolumeTestConfig) *v1.Pod {
0000000000000000000000000000000000000000;;		podClient := client.CoreV1().Pods(config.Namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		portCount := len(config.ServerPorts)
0000000000000000000000000000000000000000;;		serverPodPorts := make([]v1.ContainerPort, portCount)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < portCount; i++ {
0000000000000000000000000000000000000000;;			portName := fmt.Sprintf("%s-%d", config.Prefix, i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			serverPodPorts[i] = v1.ContainerPort{
0000000000000000000000000000000000000000;;				Name:          portName,
0000000000000000000000000000000000000000;;				ContainerPort: int32(config.ServerPorts[i]),
0000000000000000000000000000000000000000;;				Protocol:      v1.ProtocolTCP,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeCount := len(config.ServerVolumes)
0000000000000000000000000000000000000000;;		volumes := make([]v1.Volume, volumeCount)
0000000000000000000000000000000000000000;;		mounts := make([]v1.VolumeMount, volumeCount)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for src, dst := range config.ServerVolumes {
0000000000000000000000000000000000000000;;			mountName := fmt.Sprintf("path%d", i)
0000000000000000000000000000000000000000;;			volumes[i].Name = mountName
0000000000000000000000000000000000000000;;			volumes[i].VolumeSource.HostPath = &v1.HostPathVolumeSource{
0000000000000000000000000000000000000000;;				Path: src,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mounts[i].Name = mountName
0000000000000000000000000000000000000000;;			mounts[i].ReadOnly = false
0000000000000000000000000000000000000000;;			mounts[i].MountPath = dst
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serverPodName := fmt.Sprintf("%s-server", config.Prefix)
0000000000000000000000000000000000000000;;		By(fmt.Sprint("creating ", serverPodName, " pod"))
0000000000000000000000000000000000000000;;		privileged := new(bool)
0000000000000000000000000000000000000000;;		*privileged = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restartPolicy := v1.RestartPolicyAlways
0000000000000000000000000000000000000000;;		if config.WaitForCompletion {
0000000000000000000000000000000000000000;;			restartPolicy = v1.RestartPolicyNever
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		serverPod := &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: serverPodName,
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"role": serverPodName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  serverPodName,
0000000000000000000000000000000000000000;;						Image: config.ServerImage,
0000000000000000000000000000000000000000;;						SecurityContext: &v1.SecurityContext{
0000000000000000000000000000000000000000;;							Privileged: privileged,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Command:      config.ServerCmds,
0000000000000000000000000000000000000000;;						Args:         config.ServerArgs,
0000000000000000000000000000000000000000;;						Ports:        serverPodPorts,
0000000000000000000000000000000000000000;;						VolumeMounts: mounts,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Volumes:       volumes,
0000000000000000000000000000000000000000;;				RestartPolicy: restartPolicy,
0000000000000000000000000000000000000000;;				NodeName:      config.NodeName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var pod *v1.Pod
0000000000000000000000000000000000000000;;		serverPod, err := podClient.Create(serverPod)
0000000000000000000000000000000000000000;;		// ok if the server pod already exists. TODO: make this controllable by callers
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if apierrs.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;				Logf("Ignore \"already-exists\" error, re-get pod...")
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("re-getting the %q server pod", serverPodName))
0000000000000000000000000000000000000000;;				serverPod, err = podClient.Get(serverPodName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				ExpectNoError(err, "Cannot re-get the server pod %q: %v", serverPodName, err)
0000000000000000000000000000000000000000;;				pod = serverPod
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ExpectNoError(err, "Failed to create %q pod: %v", serverPodName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.WaitForCompletion {
0000000000000000000000000000000000000000;;			ExpectNoError(WaitForPodSuccessInNamespace(client, serverPod.Name, serverPod.Namespace))
0000000000000000000000000000000000000000;;			ExpectNoError(podClient.Delete(serverPod.Name, nil))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ExpectNoError(WaitForPodRunningInNamespace(client, serverPod))
0000000000000000000000000000000000000000;;			if pod == nil {
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("locating the %q server pod", serverPodName))
0000000000000000000000000000000000000000;;				pod, err = podClient.Get(serverPodName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				ExpectNoError(err, "Cannot locate the server pod %q: %v", serverPodName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clean both server and client pods.
0000000000000000000000000000000000000000;;	func VolumeTestCleanup(f *Framework, config VolumeTestConfig) {
0000000000000000000000000000000000000000;;		By(fmt.Sprint("cleaning the environment after ", config.Prefix))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer GinkgoRecover()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := f.ClientSet
0000000000000000000000000000000000000000;;		podClient := client.CoreV1().Pods(config.Namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := podClient.Delete(config.Prefix+"-client", nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Log the error before failing test: if the test has already failed,
0000000000000000000000000000000000000000;;			// framework.ExpectNoError() won't print anything to logs!
0000000000000000000000000000000000000000;;			glog.Warningf("Failed to delete client pod: %v", err)
0000000000000000000000000000000000000000;;			ExpectNoError(err, "Failed to delete client pod: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if config.ServerImage != "" {
0000000000000000000000000000000000000000;;			if err := f.WaitForPodTerminated(config.Prefix+"-client", ""); !apierrs.IsNotFound(err) {
0000000000000000000000000000000000000000;;				ExpectNoError(err, "Failed to wait client pod terminated: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// See issue #24100.
0000000000000000000000000000000000000000;;			// Prevent umount errors by making sure making sure the client pod exits cleanly *before* the volume server pod exits.
0000000000000000000000000000000000000000;;			By("sleeping a bit so client can stop and unmount")
0000000000000000000000000000000000000000;;			time.Sleep(20 * time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = podClient.Delete(config.Prefix+"-server", nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to delete server pod: %v", err)
0000000000000000000000000000000000000000;;				ExpectNoError(err, "Failed to delete server pod: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Start a client pod using given VolumeSource (exported by startVolumeServer())
0000000000000000000000000000000000000000;;	// and check that the pod sees expected data, e.g. from the server pod.
0000000000000000000000000000000000000000;;	// Multiple VolumeTests can be specified to mount multiple volumes to a single
0000000000000000000000000000000000000000;;	// pod.
0000000000000000000000000000000000000000;;	func TestVolumeClient(client clientset.Interface, config VolumeTestConfig, fsGroup *int64, tests []VolumeTest) {
0000000000000000000000000000000000000000;;		By(fmt.Sprint("starting ", config.Prefix, " client"))
0000000000000000000000000000000000000000;;		clientPod := &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: config.Prefix + "-client",
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"role": config.Prefix + "-client",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:       config.Prefix + "-client",
0000000000000000000000000000000000000000;;						Image:      BusyBoxImage,
0000000000000000000000000000000000000000;;						WorkingDir: "/opt",
0000000000000000000000000000000000000000;;						// An imperative and easily debuggable container which reads vol contents for
0000000000000000000000000000000000000000;;						// us to scan in the tests or by eye.
0000000000000000000000000000000000000000;;						// We expect that /opt is empty in the minimal containers which we use in this test.
0000000000000000000000000000000000000000;;						Command: []string{
0000000000000000000000000000000000000000;;							"/bin/sh",
0000000000000000000000000000000000000000;;							"-c",
0000000000000000000000000000000000000000;;							"while true ; do cat /opt/0/index.html ; sleep 2 ; ls -altrh /opt/  ; sleep 2 ; done ",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				SecurityContext: &v1.PodSecurityContext{
0000000000000000000000000000000000000000;;					SELinuxOptions: &v1.SELinuxOptions{
0000000000000000000000000000000000000000;;						Level: "s0:c0,c1",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podsNamespacer := client.CoreV1().Pods(config.Namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fsGroup != nil {
0000000000000000000000000000000000000000;;			clientPod.Spec.SecurityContext.FSGroup = fsGroup
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			volumeName := fmt.Sprintf("%s-%s-%d", config.Prefix, "volume", i)
0000000000000000000000000000000000000000;;			clientPod.Spec.Containers[0].VolumeMounts = append(clientPod.Spec.Containers[0].VolumeMounts, v1.VolumeMount{
0000000000000000000000000000000000000000;;				Name:      volumeName,
0000000000000000000000000000000000000000;;				MountPath: fmt.Sprintf("/opt/%d", i),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			clientPod.Spec.Volumes = append(clientPod.Spec.Volumes, v1.Volume{
0000000000000000000000000000000000000000;;				Name:         volumeName,
0000000000000000000000000000000000000000;;				VolumeSource: test.Volume,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clientPod, err := podsNamespacer.Create(clientPod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("Failed to create %s pod: %v", clientPod.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ExpectNoError(WaitForPodRunningInNamespace(client, clientPod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Checking that text file contents are perfect.")
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			fileName := fmt.Sprintf("/opt/%d/%s", i, test.File)
0000000000000000000000000000000000000000;;			_, err = LookForStringInPodExec(config.Namespace, clientPod.Name, []string{"cat", fileName}, test.ExpectedContent, time.Minute)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "failed: finding the contents of the mounted file %s.", fileName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fsGroup != nil {
0000000000000000000000000000000000000000;;			By("Checking fsGroup is correct.")
0000000000000000000000000000000000000000;;			_, err = LookForStringInPodExec(config.Namespace, clientPod.Name, []string{"ls", "-ld", "/opt/0"}, strconv.Itoa(int(*fsGroup)), time.Minute)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "failed: getting the right priviliges in the file %v", int(*fsGroup))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Insert index.html with given content into given volume. It does so by
0000000000000000000000000000000000000000;;	// starting and auxiliary pod which writes the file there.
0000000000000000000000000000000000000000;;	// The volume must be writable.
0000000000000000000000000000000000000000;;	func InjectHtml(client clientset.Interface, config VolumeTestConfig, volume v1.VolumeSource, content string) {
0000000000000000000000000000000000000000;;		By(fmt.Sprint("starting ", config.Prefix, " injector"))
0000000000000000000000000000000000000000;;		podClient := client.CoreV1().Pods(config.Namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		injectPod := &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: config.Prefix + "-injector",
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"role": config.Prefix + "-injector",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:    config.Prefix + "-injector",
0000000000000000000000000000000000000000;;						Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;						Command: []string{"/bin/sh"},
0000000000000000000000000000000000000000;;						Args:    []string{"-c", "echo '" + content + "' > /mnt/index.html && chmod o+rX /mnt /mnt/index.html"},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      config.Prefix + "-volume",
0000000000000000000000000000000000000000;;								MountPath: "/mnt",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				SecurityContext: &v1.PodSecurityContext{
0000000000000000000000000000000000000000;;					SELinuxOptions: &v1.SELinuxOptions{
0000000000000000000000000000000000000000;;						Level: "s0:c0,c1",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:         config.Prefix + "-volume",
0000000000000000000000000000000000000000;;						VolumeSource: volume,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			podClient.Delete(config.Prefix+"-injector", nil)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		injectPod, err := podClient.Create(injectPod)
0000000000000000000000000000000000000000;;		ExpectNoError(err, "Failed to create injector pod: %v", err)
0000000000000000000000000000000000000000;;		err = WaitForPodSuccessInNamespace(client, injectPod.Name, injectPod.Namespace)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	}
