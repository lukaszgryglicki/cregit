0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
85d1525fa9e0b72acef4da4572eaabcf8182028a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		apierrs "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		extensionsinternal "k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		deploymentutil "k8s.io/kubernetes/pkg/controller/deployment/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		testutils "k8s.io/kubernetes/test/utils"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type updateRsFunc func(d *extensions.ReplicaSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func UpdateReplicaSetWithRetries(c clientset.Interface, namespace, name string, applyUpdate updateRsFunc) (*extensions.ReplicaSet, error) {
0000000000000000000000000000000000000000;;		var rs *extensions.ReplicaSet
0000000000000000000000000000000000000000;;		var updateErr error
0000000000000000000000000000000000000000;;		pollErr := wait.PollImmediate(1*time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if rs, err = c.Extensions().ReplicaSets(namespace).Get(name, metav1.GetOptions{}); err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Apply the update, then attempt to push it to the apiserver.
0000000000000000000000000000000000000000;;			applyUpdate(rs)
0000000000000000000000000000000000000000;;			if rs, err = c.Extensions().ReplicaSets(namespace).Update(rs); err == nil {
0000000000000000000000000000000000000000;;				Logf("Updating replica set %q", name)
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			updateErr = err
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if pollErr == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			pollErr = fmt.Errorf("couldn't apply the provided updated to replicaset %q: %v", name, updateErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rs, pollErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckNewRSAnnotations check if the new RS's annotation is as expected
0000000000000000000000000000000000000000;;	func CheckNewRSAnnotations(c clientset.Interface, ns, deploymentName string, expectedAnnotations map[string]string) error {
0000000000000000000000000000000000000000;;		deployment, err := c.Extensions().Deployments(ns).Get(deploymentName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newRS, err := deploymentutil.GetNewReplicaSet(deployment, c)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range expectedAnnotations {
0000000000000000000000000000000000000000;;			// Skip checking revision annotations
0000000000000000000000000000000000000000;;			if k != deploymentutil.RevisionAnnotation && v != newRS.Annotations[k] {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Expected new RS annotations = %+v, got %+v", expectedAnnotations, newRS.Annotations)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete a ReplicaSet and all pods it spawned
0000000000000000000000000000000000000000;;	func DeleteReplicaSet(clientset clientset.Interface, internalClientset internalclientset.Interface, ns, name string) error {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("deleting ReplicaSet %s in namespace %s", name, ns))
0000000000000000000000000000000000000000;;		rc, err := clientset.Extensions().ReplicaSets(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if apierrs.IsNotFound(err) {
0000000000000000000000000000000000000000;;				Logf("ReplicaSet %s was already deleted: %v", name, err)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		reaper, err := kubectl.ReaperFor(extensionsinternal.Kind("ReplicaSet"), internalClientset)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if apierrs.IsNotFound(err) {
0000000000000000000000000000000000000000;;				Logf("ReplicaSet %s was already deleted: %v", name, err)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		err = reaper.Stop(ns, name, 0, nil)
0000000000000000000000000000000000000000;;		if apierrs.IsNotFound(err) {
0000000000000000000000000000000000000000;;			Logf("ReplicaSet %s was already deleted: %v", name, err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deleteRSTime := time.Now().Sub(startTime)
0000000000000000000000000000000000000000;;		Logf("Deleting RS %s took: %v", name, deleteRSTime)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			err = waitForReplicaSetPodsGone(clientset, rc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		terminatePodTime := time.Now().Sub(startTime) - deleteRSTime
0000000000000000000000000000000000000000;;		Logf("Terminating ReplicaSet %s pods took: %v", name, terminatePodTime)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForReplicaSetPodsGone waits until there are no pods reported under a
0000000000000000000000000000000000000000;;	// ReplicaSet selector (because the pods have completed termination).
0000000000000000000000000000000000000000;;	func waitForReplicaSetPodsGone(c clientset.Interface, rs *extensions.ReplicaSet) error {
0000000000000000000000000000000000000000;;		return wait.PollImmediate(Poll, 2*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			selector, err := metav1.LabelSelectorAsSelector(rs.Spec.Selector)
0000000000000000000000000000000000000000;;			ExpectNoError(err)
0000000000000000000000000000000000000000;;			options := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;			if pods, err := c.Core().Pods(rs.Namespace).List(options); err == nil && len(pods.Items) == 0 {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForReadyReplicaSet waits until the replica set has all of its replicas ready.
0000000000000000000000000000000000000000;;	func WaitForReadyReplicaSet(c clientset.Interface, ns, name string) error {
0000000000000000000000000000000000000000;;		err := wait.Poll(Poll, pollShortTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			rs, err := c.Extensions().ReplicaSets(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return *(rs.Spec.Replicas) == rs.Status.Replicas && *(rs.Spec.Replicas) == rs.Status.ReadyReplicas, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("replica set %q never became ready", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunReplicaSet(config testutils.ReplicaSetConfig) error {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("creating replicaset %s in namespace %s", config.Name, config.Namespace))
0000000000000000000000000000000000000000;;		config.NodeDumpFunc = DumpNodeDebugInfo
0000000000000000000000000000000000000000;;		config.ContainerDumpFunc = LogFailedContainers
0000000000000000000000000000000000000000;;		return testutils.RunReplicaSet(config)
0000000000000000000000000000000000000000;;	}
