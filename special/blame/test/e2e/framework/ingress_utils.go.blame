0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
2446bc07a6232e25e8f62b57567a4493ca708cb4;test/e2e/ingress_utils.go[test/e2e/ingress_utils.go][test/e2e/framework/ingress_utils.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"crypto/x509/pkix"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		compute "google.golang.org/api/compute/v1"
0000000000000000000000000000000000000000;;		"google.golang.org/api/googleapi"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		apierrs "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		gcecloud "k8s.io/kubernetes/pkg/cloudprovider/providers/gce"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util"
0000000000000000000000000000000000000000;;		utilexec "k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/manifest"
0000000000000000000000000000000000000000;;		testutils "k8s.io/kubernetes/test/utils"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		rsaBits  = 2048
0000000000000000000000000000000000000000;;		validFor = 365 * 24 * time.Hour
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ingress class annotation defined in ingress repository.
0000000000000000000000000000000000000000;;		ingressClass = "kubernetes.io/ingress.class"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// all cloud resources created by the ingress controller start with this
0000000000000000000000000000000000000000;;		// prefix.
0000000000000000000000000000000000000000;;		k8sPrefix = "k8s-"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// clusterDelimiter is the delimiter used by the ingress controller
0000000000000000000000000000000000000000;;		// to split uid from other naming/metadata.
0000000000000000000000000000000000000000;;		clusterDelimiter = "--"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name of the default http backend service
0000000000000000000000000000000000000000;;		defaultBackendName = "default-http-backend"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Cloud resources created by the ingress controller older than this
0000000000000000000000000000000000000000;;		// are automatically purged to prevent running out of quota.
0000000000000000000000000000000000000000;;		// TODO(37335): write soak tests and bump this up to a week.
0000000000000000000000000000000000000000;;		maxAge = 48 * time.Hour
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IngressManifestPath is the parent path to yaml test manifests.
0000000000000000000000000000000000000000;;		IngressManifestPath = "test/e2e/testing-manifests/ingress"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IngressReqTimeout is the timeout on a single http request.
0000000000000000000000000000000000000000;;		IngressReqTimeout = 10 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// healthz port used to verify glbc restarted correctly on the master.
0000000000000000000000000000000000000000;;		glbcHealthzPort = 8086
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// General cloud resource poll timeout (eg: create static ip, firewall etc)
0000000000000000000000000000000000000000;;		cloudResourcePollTimeout = 5 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name of the config-map and key the ingress controller stores its uid in.
0000000000000000000000000000000000000000;;		uidConfigMap = "ingress-uid"
0000000000000000000000000000000000000000;;		uidKey       = "uid"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GCE only allows names < 64 characters, and the loadbalancer controller inserts
0000000000000000000000000000000000000000;;		// a single character of padding.
0000000000000000000000000000000000000000;;		nameLenLimit = 62
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IngressTestJig holds the relevant state and parameters of the ingress test.
0000000000000000000000000000000000000000;;	type IngressTestJig struct {
0000000000000000000000000000000000000000;;		Client  clientset.Interface
0000000000000000000000000000000000000000;;		RootCAs map[string][]byte
0000000000000000000000000000000000000000;;		Address string
0000000000000000000000000000000000000000;;		Ingress *extensions.Ingress
0000000000000000000000000000000000000000;;		// class is the value of the annotation keyed under
0000000000000000000000000000000000000000;;		// `kubernetes.io/ingress.class`. It's added to all ingresses created by
0000000000000000000000000000000000000000;;		// this jig.
0000000000000000000000000000000000000000;;		Class string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The interval used to poll urls
0000000000000000000000000000000000000000;;		PollInterval time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IngressConformanceTests contains a closure with an entry and exit log line.
0000000000000000000000000000000000000000;;	type IngressConformanceTests struct {
0000000000000000000000000000000000000000;;		EntryLog string
0000000000000000000000000000000000000000;;		Execute  func()
0000000000000000000000000000000000000000;;		ExitLog  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateIngressComformanceTests generates an slice of sequential test cases:
0000000000000000000000000000000000000000;;	// a simple http ingress, ingress with HTTPS, ingress HTTPS with a modified hostname,
0000000000000000000000000000000000000000;;	// ingress https with a modified URLMap
0000000000000000000000000000000000000000;;	func CreateIngressComformanceTests(jig *IngressTestJig, ns string) []IngressConformanceTests {
0000000000000000000000000000000000000000;;		manifestPath := filepath.Join(IngressManifestPath, "http")
0000000000000000000000000000000000000000;;		// These constants match the manifests used in IngressManifestPath
0000000000000000000000000000000000000000;;		tlsHost := "foo.bar.com"
0000000000000000000000000000000000000000;;		tlsSecretName := "foo"
0000000000000000000000000000000000000000;;		updatedTLSHost := "foobar.com"
0000000000000000000000000000000000000000;;		updateURLMapHost := "bar.baz.com"
0000000000000000000000000000000000000000;;		updateURLMapPath := "/testurl"
0000000000000000000000000000000000000000;;		// Platform agnostic list of tests that must be satisfied by all controllers
0000000000000000000000000000000000000000;;		return []IngressConformanceTests{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fmt.Sprintf("should create a basic HTTP ingress"),
0000000000000000000000000000000000000000;;				func() { jig.CreateIngress(manifestPath, ns, map[string]string{}) },
0000000000000000000000000000000000000000;;				fmt.Sprintf("waiting for urls on basic HTTP ingress"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fmt.Sprintf("should terminate TLS for host %v", tlsHost),
0000000000000000000000000000000000000000;;				func() { jig.AddHTTPS(tlsSecretName, tlsHost) },
0000000000000000000000000000000000000000;;				fmt.Sprintf("waiting for HTTPS updates to reflect in ingress"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fmt.Sprintf("should update SSL certificate with modified hostname %v", updatedTLSHost),
0000000000000000000000000000000000000000;;				func() {
0000000000000000000000000000000000000000;;					jig.Update(func(ing *extensions.Ingress) {
0000000000000000000000000000000000000000;;						newRules := []extensions.IngressRule{}
0000000000000000000000000000000000000000;;						for _, rule := range ing.Spec.Rules {
0000000000000000000000000000000000000000;;							if rule.Host != tlsHost {
0000000000000000000000000000000000000000;;								newRules = append(newRules, rule)
0000000000000000000000000000000000000000;;								continue
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							newRules = append(newRules, extensions.IngressRule{
0000000000000000000000000000000000000000;;								Host:             updatedTLSHost,
0000000000000000000000000000000000000000;;								IngressRuleValue: rule.IngressRuleValue,
0000000000000000000000000000000000000000;;							})
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						ing.Spec.Rules = newRules
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;					jig.AddHTTPS(tlsSecretName, updatedTLSHost)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fmt.Sprintf("Waiting for updated certificates to accept requests for host %v", updatedTLSHost),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fmt.Sprintf("should update url map for host %v to expose a single url: %v", updateURLMapHost, updateURLMapPath),
0000000000000000000000000000000000000000;;				func() {
0000000000000000000000000000000000000000;;					var pathToFail string
0000000000000000000000000000000000000000;;					jig.Update(func(ing *extensions.Ingress) {
0000000000000000000000000000000000000000;;						newRules := []extensions.IngressRule{}
0000000000000000000000000000000000000000;;						for _, rule := range ing.Spec.Rules {
0000000000000000000000000000000000000000;;							if rule.Host != updateURLMapHost {
0000000000000000000000000000000000000000;;								newRules = append(newRules, rule)
0000000000000000000000000000000000000000;;								continue
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							existingPath := rule.IngressRuleValue.HTTP.Paths[0]
0000000000000000000000000000000000000000;;							pathToFail = existingPath.Path
0000000000000000000000000000000000000000;;							newRules = append(newRules, extensions.IngressRule{
0000000000000000000000000000000000000000;;								Host: updateURLMapHost,
0000000000000000000000000000000000000000;;								IngressRuleValue: extensions.IngressRuleValue{
0000000000000000000000000000000000000000;;									HTTP: &extensions.HTTPIngressRuleValue{
0000000000000000000000000000000000000000;;										Paths: []extensions.HTTPIngressPath{
0000000000000000000000000000000000000000;;											{
0000000000000000000000000000000000000000;;												Path:    updateURLMapPath,
0000000000000000000000000000000000000000;;												Backend: existingPath.Backend,
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							})
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						ing.Spec.Rules = newRules
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;					By("Checking that " + pathToFail + " is not exposed by polling for failure")
0000000000000000000000000000000000000000;;					route := fmt.Sprintf("http://%v%v", jig.Address, pathToFail)
0000000000000000000000000000000000000000;;					ExpectNoError(PollURL(route, updateURLMapHost, LoadBalancerCleanupTimeout, jig.PollInterval, &http.Client{Timeout: IngressReqTimeout}, true))
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fmt.Sprintf("Waiting for path updates to reflect in L7"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateRSACerts generates a basic self signed certificate using a key length
0000000000000000000000000000000000000000;;	// of rsaBits, valid for validFor time.
0000000000000000000000000000000000000000;;	func generateRSACerts(host string, isCA bool, keyOut, certOut io.Writer) error {
0000000000000000000000000000000000000000;;		if len(host) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Require a non-empty host for client hello")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		priv, err := rsa.GenerateKey(rand.Reader, rsaBits)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to generate key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		notBefore := time.Now()
0000000000000000000000000000000000000000;;		notAfter := notBefore.Add(validFor)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)
0000000000000000000000000000000000000000;;		serialNumber, err := rand.Int(rand.Reader, serialNumberLimit)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to generate serial number: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		template := x509.Certificate{
0000000000000000000000000000000000000000;;			SerialNumber: serialNumber,
0000000000000000000000000000000000000000;;			Subject: pkix.Name{
0000000000000000000000000000000000000000;;				CommonName:   "default",
0000000000000000000000000000000000000000;;				Organization: []string{"Acme Co"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			NotBefore: notBefore,
0000000000000000000000000000000000000000;;			NotAfter:  notAfter,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
0000000000000000000000000000000000000000;;			ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
0000000000000000000000000000000000000000;;			BasicConstraintsValid: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hosts := strings.Split(host, ",")
0000000000000000000000000000000000000000;;		for _, h := range hosts {
0000000000000000000000000000000000000000;;			if ip := net.ParseIP(h); ip != nil {
0000000000000000000000000000000000000000;;				template.IPAddresses = append(template.IPAddresses, ip)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				template.DNSNames = append(template.DNSNames, h)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isCA {
0000000000000000000000000000000000000000;;			template.IsCA = true
0000000000000000000000000000000000000000;;			template.KeyUsage |= x509.KeyUsageCertSign
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		derBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, &priv.PublicKey, priv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to create certificate: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := pem.Encode(certOut, &pem.Block{Type: "CERTIFICATE", Bytes: derBytes}); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed creating cert: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := pem.Encode(keyOut, &pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(priv)}); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed creating keay: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildTransportWithCA creates a transport for use in executing HTTPS requests with
0000000000000000000000000000000000000000;;	// the given certs. Note that the given rootCA must be configured with isCA=true.
0000000000000000000000000000000000000000;;	func buildTransportWithCA(serverName string, rootCA []byte) (*http.Transport, error) {
0000000000000000000000000000000000000000;;		pool := x509.NewCertPool()
0000000000000000000000000000000000000000;;		ok := pool.AppendCertsFromPEM(rootCA)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unable to load serverCA")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilnet.SetTransportDefaults(&http.Transport{
0000000000000000000000000000000000000000;;			TLSClientConfig: &tls.Config{
0000000000000000000000000000000000000000;;				InsecureSkipVerify: false,
0000000000000000000000000000000000000000;;				ServerName:         serverName,
0000000000000000000000000000000000000000;;				RootCAs:            pool,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildInsecureClient returns an insecure http client. Can be used for "curl -k".
0000000000000000000000000000000000000000;;	func BuildInsecureClient(timeout time.Duration) *http.Client {
0000000000000000000000000000000000000000;;		t := &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}
0000000000000000000000000000000000000000;;		return &http.Client{Timeout: timeout, Transport: utilnet.SetTransportDefaults(t)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createIngressTLSSecret creates a secret containing TLS certificates for the given Ingress.
0000000000000000000000000000000000000000;;	// If a secret with the same name already pathExists in the namespace of the
0000000000000000000000000000000000000000;;	// Ingress, it's updated.
0000000000000000000000000000000000000000;;	func createIngressTLSSecret(kubeClient clientset.Interface, ing *extensions.Ingress) (host string, rootCA, privKey []byte, err error) {
0000000000000000000000000000000000000000;;		var k, c bytes.Buffer
0000000000000000000000000000000000000000;;		tls := ing.Spec.TLS[0]
0000000000000000000000000000000000000000;;		host = strings.Join(tls.Hosts, ",")
0000000000000000000000000000000000000000;;		Logf("Generating RSA cert for host %v", host)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = generateRSACerts(host, true, &k, &c); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cert := c.Bytes()
0000000000000000000000000000000000000000;;		key := k.Bytes()
0000000000000000000000000000000000000000;;		secret := &v1.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: tls.SecretName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: map[string][]byte{
0000000000000000000000000000000000000000;;				v1.TLSCertKey:       cert,
0000000000000000000000000000000000000000;;				v1.TLSPrivateKeyKey: key,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var s *v1.Secret
0000000000000000000000000000000000000000;;		if s, err = kubeClient.Core().Secrets(ing.Namespace).Get(tls.SecretName, metav1.GetOptions{}); err == nil {
0000000000000000000000000000000000000000;;			// TODO: Retry the update. We don't really expect anything to conflict though.
0000000000000000000000000000000000000000;;			Logf("Updating secret %v in ns %v with hosts %v for ingress %v", secret.Name, secret.Namespace, host, ing.Name)
0000000000000000000000000000000000000000;;			s.Data = secret.Data
0000000000000000000000000000000000000000;;			_, err = kubeClient.Core().Secrets(ing.Namespace).Update(s)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			Logf("Creating secret %v in ns %v with hosts %v for ingress %v", secret.Name, secret.Namespace, host, ing.Name)
0000000000000000000000000000000000000000;;			_, err = kubeClient.Core().Secrets(ing.Namespace).Create(secret)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return host, cert, key, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CleanupGCEIngressController calls the GCEIngressController.Cleanup(false)
0000000000000000000000000000000000000000;;	// followed with deleting the static ip, and then a final GCEIngressController.Cleanup(true)
0000000000000000000000000000000000000000;;	func CleanupGCEIngressController(gceController *GCEIngressController) {
0000000000000000000000000000000000000000;;		pollErr := wait.Poll(5*time.Second, LoadBalancerCleanupTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			if err := gceController.Cleanup(false); err != nil {
0000000000000000000000000000000000000000;;				Logf("Monitoring glbc's cleanup of gce resources:\n%v", err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Always try to cleanup even if pollErr == nil, because the cleanup
0000000000000000000000000000000000000000;;		// routine also purges old leaked resources based on creation timestamp.
0000000000000000000000000000000000000000;;		By("Performing final delete of any remaining resources")
0000000000000000000000000000000000000000;;		if cleanupErr := gceController.Cleanup(true); cleanupErr != nil {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("WARNING: possibly leaked resources: %v\n", cleanupErr))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			By("No resources leaked.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Static-IP allocated on behalf of the test, never deleted by the
0000000000000000000000000000000000000000;;		// controller. Delete this IP only after the controller has had a chance
0000000000000000000000000000000000000000;;		// to cleanup or it might interfere with the controller, causing it to
0000000000000000000000000000000000000000;;		// throw out confusing events.
0000000000000000000000000000000000000000;;		if ipErr := wait.Poll(5*time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			if err := gceController.deleteStaticIPs(); err != nil {
0000000000000000000000000000000000000000;;				Logf("Failed to delete static-ip: %v\n", err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}); ipErr != nil {
0000000000000000000000000000000000000000;;			// If this is a persistent error, the suite will fail when we run out
0000000000000000000000000000000000000000;;			// of quota anyway.
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("WARNING: possibly leaked static IP: %v\n", ipErr))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Logging that the GLBC failed to cleanup GCE resources on ingress deletion
0000000000000000000000000000000000000000;;		// See kubernetes/ingress#431
0000000000000000000000000000000000000000;;		if pollErr != nil {
0000000000000000000000000000000000000000;;			Logf("error: L7 controller failed to delete all cloud resources on time. %v", pollErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cont *GCEIngressController) deleteForwardingRule(del bool) string {
0000000000000000000000000000000000000000;;		msg := ""
0000000000000000000000000000000000000000;;		fwList := []compute.ForwardingRule{}
0000000000000000000000000000000000000000;;		for _, regex := range []string{fmt.Sprintf("%vfw-.*%v.*", k8sPrefix, clusterDelimiter), fmt.Sprintf("%vfws-.*%v.*", k8sPrefix, clusterDelimiter)} {
0000000000000000000000000000000000000000;;			gcloudComputeResourceList("forwarding-rules", regex, cont.Cloud.ProjectID, &fwList)
0000000000000000000000000000000000000000;;			if len(fwList) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, f := range fwList {
0000000000000000000000000000000000000000;;				if !cont.canDelete(f.Name, f.CreationTimestamp, del) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if del {
0000000000000000000000000000000000000000;;					GcloudComputeResourceDelete("forwarding-rules", f.Name, cont.Cloud.ProjectID, "--global")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					msg += fmt.Sprintf("%v (forwarding rule)\n", f.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cont *GCEIngressController) deleteAddresses(del bool) string {
0000000000000000000000000000000000000000;;		msg := ""
0000000000000000000000000000000000000000;;		ipList := []compute.Address{}
0000000000000000000000000000000000000000;;		regex := fmt.Sprintf("%vfw-.*%v.*", k8sPrefix, clusterDelimiter)
0000000000000000000000000000000000000000;;		gcloudComputeResourceList("addresses", regex, cont.Cloud.ProjectID, &ipList)
0000000000000000000000000000000000000000;;		if len(ipList) != 0 {
0000000000000000000000000000000000000000;;			for _, ip := range ipList {
0000000000000000000000000000000000000000;;				if !cont.canDelete(ip.Name, ip.CreationTimestamp, del) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if del {
0000000000000000000000000000000000000000;;					GcloudComputeResourceDelete("addresses", ip.Name, cont.Cloud.ProjectID, "--global")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					msg += fmt.Sprintf("%v (static-ip)\n", ip.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cont *GCEIngressController) deleteTargetProxy(del bool) string {
0000000000000000000000000000000000000000;;		msg := ""
0000000000000000000000000000000000000000;;		tpList := []compute.TargetHttpProxy{}
0000000000000000000000000000000000000000;;		regex := fmt.Sprintf("%vtp-.*%v.*", k8sPrefix, clusterDelimiter)
0000000000000000000000000000000000000000;;		gcloudComputeResourceList("target-http-proxies", regex, cont.Cloud.ProjectID, &tpList)
0000000000000000000000000000000000000000;;		if len(tpList) != 0 {
0000000000000000000000000000000000000000;;			for _, t := range tpList {
0000000000000000000000000000000000000000;;				if !cont.canDelete(t.Name, t.CreationTimestamp, del) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if del {
0000000000000000000000000000000000000000;;					GcloudComputeResourceDelete("target-http-proxies", t.Name, cont.Cloud.ProjectID)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					msg += fmt.Sprintf("%v (target-http-proxy)\n", t.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tpsList := []compute.TargetHttpsProxy{}
0000000000000000000000000000000000000000;;		regex = fmt.Sprintf("%vtps-.*%v.*", k8sPrefix, clusterDelimiter)
0000000000000000000000000000000000000000;;		gcloudComputeResourceList("target-https-proxies", regex, cont.Cloud.ProjectID, &tpsList)
0000000000000000000000000000000000000000;;		if len(tpsList) != 0 {
0000000000000000000000000000000000000000;;			for _, t := range tpsList {
0000000000000000000000000000000000000000;;				if !cont.canDelete(t.Name, t.CreationTimestamp, del) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if del {
0000000000000000000000000000000000000000;;					GcloudComputeResourceDelete("target-https-proxies", t.Name, cont.Cloud.ProjectID)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					msg += fmt.Sprintf("%v (target-https-proxy)\n", t.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cont *GCEIngressController) deleteURLMap(del bool) (msg string) {
0000000000000000000000000000000000000000;;		gceCloud := cont.Cloud.Provider.(*gcecloud.GCECloud)
0000000000000000000000000000000000000000;;		umList, err := gceCloud.ListUrlMaps()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if cont.isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;				return msg
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Sprintf("Failed to list url maps: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(umList.Items) == 0 {
0000000000000000000000000000000000000000;;			return msg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, um := range umList.Items {
0000000000000000000000000000000000000000;;			if !cont.canDelete(um.Name, um.CreationTimestamp, del) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if del {
0000000000000000000000000000000000000000;;				Logf("Deleting url-map: %s", um.Name)
0000000000000000000000000000000000000000;;				if err := gceCloud.DeleteUrlMap(um.Name); err != nil &&
0000000000000000000000000000000000000000;;					!cont.isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;					msg += fmt.Sprintf("Failed to delete url map %v\n", um.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				msg += fmt.Sprintf("%v (url-map)\n", um.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cont *GCEIngressController) deleteBackendService(del bool) (msg string) {
0000000000000000000000000000000000000000;;		gceCloud := cont.Cloud.Provider.(*gcecloud.GCECloud)
0000000000000000000000000000000000000000;;		beList, err := gceCloud.ListGlobalBackendServices()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if cont.isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;				return msg
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Sprintf("Failed to list backend services: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(beList.Items) == 0 {
0000000000000000000000000000000000000000;;			Logf("No backend services found")
0000000000000000000000000000000000000000;;			return msg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, be := range beList.Items {
0000000000000000000000000000000000000000;;			if !cont.canDelete(be.Name, be.CreationTimestamp, del) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if del {
0000000000000000000000000000000000000000;;				Logf("Deleting backed-service: %s", be.Name)
0000000000000000000000000000000000000000;;				if err := gceCloud.DeleteGlobalBackendService(be.Name); err != nil &&
0000000000000000000000000000000000000000;;					!cont.isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;					msg += fmt.Sprintf("Failed to delete backend service %v: %v\n", be.Name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				msg += fmt.Sprintf("%v (backend-service)\n", be.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cont *GCEIngressController) deleteHTTPHealthCheck(del bool) (msg string) {
0000000000000000000000000000000000000000;;		gceCloud := cont.Cloud.Provider.(*gcecloud.GCECloud)
0000000000000000000000000000000000000000;;		hcList, err := gceCloud.ListHttpHealthChecks()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if cont.isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;				return msg
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Sprintf("Failed to list HTTP health checks: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(hcList.Items) == 0 {
0000000000000000000000000000000000000000;;			return msg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, hc := range hcList.Items {
0000000000000000000000000000000000000000;;			if !cont.canDelete(hc.Name, hc.CreationTimestamp, del) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if del {
0000000000000000000000000000000000000000;;				Logf("Deleting http-health-check: %s", hc.Name)
0000000000000000000000000000000000000000;;				if err := gceCloud.DeleteHttpHealthCheck(hc.Name); err != nil &&
0000000000000000000000000000000000000000;;					!cont.isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;					msg += fmt.Sprintf("Failed to delete HTTP health check %v\n", hc.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				msg += fmt.Sprintf("%v (http-health-check)\n", hc.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cont *GCEIngressController) deleteSSLCertificate(del bool) (msg string) {
0000000000000000000000000000000000000000;;		gceCloud := cont.Cloud.Provider.(*gcecloud.GCECloud)
0000000000000000000000000000000000000000;;		sslList, err := gceCloud.ListSslCertificates()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if cont.isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;				return msg
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Sprintf("Failed to list ssl certificates: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(sslList.Items) != 0 {
0000000000000000000000000000000000000000;;			for _, s := range sslList.Items {
0000000000000000000000000000000000000000;;				if !cont.canDelete(s.Name, s.CreationTimestamp, del) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if del {
0000000000000000000000000000000000000000;;					Logf("Deleting ssl-certificate: %s", s.Name)
0000000000000000000000000000000000000000;;					if err := gceCloud.DeleteSslCertificate(s.Name); err != nil &&
0000000000000000000000000000000000000000;;						!cont.isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;						msg += fmt.Sprintf("Failed to delete ssl certificates: %v\n", s.Name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					msg += fmt.Sprintf("%v (ssl-certificate)\n", s.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cont *GCEIngressController) deleteInstanceGroup(del bool) (msg string) {
0000000000000000000000000000000000000000;;		gceCloud := cont.Cloud.Provider.(*gcecloud.GCECloud)
0000000000000000000000000000000000000000;;		// TODO: E2E cloudprovider has only 1 zone, but the cluster can have many.
0000000000000000000000000000000000000000;;		// We need to poll on all IGs across all zones.
0000000000000000000000000000000000000000;;		igList, err := gceCloud.ListInstanceGroups(cont.Cloud.Zone)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if cont.isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;				return msg
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Sprintf("Failed to list instance groups: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(igList.Items) == 0 {
0000000000000000000000000000000000000000;;			return msg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ig := range igList.Items {
0000000000000000000000000000000000000000;;			if !cont.canDelete(ig.Name, ig.CreationTimestamp, del) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if del {
0000000000000000000000000000000000000000;;				Logf("Deleting instance-group: %s", ig.Name)
0000000000000000000000000000000000000000;;				if err := gceCloud.DeleteInstanceGroup(ig.Name, cont.Cloud.Zone); err != nil &&
0000000000000000000000000000000000000000;;					!cont.isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;					msg += fmt.Sprintf("Failed to delete instance group %v\n", ig.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				msg += fmt.Sprintf("%v (instance-group)\n", ig.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// canDelete returns true if either the name ends in a suffix matching this
0000000000000000000000000000000000000000;;	// controller's UID, or the creationTimestamp exceeds the maxAge and del is set
0000000000000000000000000000000000000000;;	// to true. Always returns false if the name doesn't match that we expect for
0000000000000000000000000000000000000000;;	// Ingress cloud resources.
0000000000000000000000000000000000000000;;	func (cont *GCEIngressController) canDelete(resourceName, creationTimestamp string, delOldResources bool) bool {
0000000000000000000000000000000000000000;;		// ignore everything not created by an ingress controller.
0000000000000000000000000000000000000000;;		splitName := strings.Split(resourceName, clusterDelimiter)
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(resourceName, k8sPrefix) || len(splitName) != 2 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Resources created by the GLBC have a "0"" appended to the end if truncation
0000000000000000000000000000000000000000;;		// occurred. Removing the zero allows the following match.
0000000000000000000000000000000000000000;;		truncatedClusterUID := splitName[1]
0000000000000000000000000000000000000000;;		if len(truncatedClusterUID) >= 1 && strings.HasSuffix(truncatedClusterUID, "0") {
0000000000000000000000000000000000000000;;			truncatedClusterUID = truncatedClusterUID[:len(truncatedClusterUID)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// always delete things that are created by the current ingress controller.
0000000000000000000000000000000000000000;;		// Because of resource name truncation, this looks for a common prefix
0000000000000000000000000000000000000000;;		if strings.HasPrefix(cont.UID, truncatedClusterUID) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !delOldResources {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		createdTime, err := time.Parse(time.RFC3339, creationTimestamp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Logf("WARNING: Failed to parse creation timestamp %v for %v: %v", creationTimestamp, resourceName, err)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if time.Since(createdTime) > maxAge {
0000000000000000000000000000000000000000;;			Logf("%v created on %v IS too old", resourceName, creationTimestamp)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetFirewallRuleName returns the name of the firewall used for the GCEIngressController.
0000000000000000000000000000000000000000;;	func (cont *GCEIngressController) GetFirewallRuleName() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%vfw-l7%v%v", k8sPrefix, clusterDelimiter, cont.UID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetFirewallRule returns the firewall used by the GCEIngressController.
0000000000000000000000000000000000000000;;	func (cont *GCEIngressController) GetFirewallRule() *compute.Firewall {
0000000000000000000000000000000000000000;;		gceCloud := cont.Cloud.Provider.(*gcecloud.GCECloud)
0000000000000000000000000000000000000000;;		fwName := cont.GetFirewallRuleName()
0000000000000000000000000000000000000000;;		fw, err := gceCloud.GetFirewall(fwName)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		return fw
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cont *GCEIngressController) deleteFirewallRule(del bool) (msg string) {
0000000000000000000000000000000000000000;;		fwList := []compute.Firewall{}
0000000000000000000000000000000000000000;;		regex := fmt.Sprintf("%vfw-l7%v.*", k8sPrefix, clusterDelimiter)
0000000000000000000000000000000000000000;;		gcloudComputeResourceList("firewall-rules", regex, cont.Cloud.ProjectID, &fwList)
0000000000000000000000000000000000000000;;		if len(fwList) != 0 {
0000000000000000000000000000000000000000;;			for _, f := range fwList {
0000000000000000000000000000000000000000;;				if !cont.canDelete(f.Name, f.CreationTimestamp, del) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if del {
0000000000000000000000000000000000000000;;					GcloudComputeResourceDelete("firewall-rules", f.Name, cont.Cloud.ProjectID)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					msg += fmt.Sprintf("%v (firewall rule)\n", f.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cont *GCEIngressController) isHTTPErrorCode(err error, code int) bool {
0000000000000000000000000000000000000000;;		apiErr, ok := err.(*googleapi.Error)
0000000000000000000000000000000000000000;;		return ok && apiErr.Code == code
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cleanup cleans up cloud resources.
0000000000000000000000000000000000000000;;	// If del is false, it simply reports existing resources without deleting them.
0000000000000000000000000000000000000000;;	// If dle is true, it deletes resources it finds acceptable (see canDelete func).
0000000000000000000000000000000000000000;;	func (cont *GCEIngressController) Cleanup(del bool) error {
0000000000000000000000000000000000000000;;		// Ordering is important here because we cannot delete resources that other
0000000000000000000000000000000000000000;;		// resources hold references to.
0000000000000000000000000000000000000000;;		errMsg := cont.deleteForwardingRule(del)
0000000000000000000000000000000000000000;;		// Static IPs are named after forwarding rules.
0000000000000000000000000000000000000000;;		errMsg += cont.deleteAddresses(del)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errMsg += cont.deleteTargetProxy(del)
0000000000000000000000000000000000000000;;		errMsg += cont.deleteURLMap(del)
0000000000000000000000000000000000000000;;		errMsg += cont.deleteBackendService(del)
0000000000000000000000000000000000000000;;		errMsg += cont.deleteHTTPHealthCheck(del)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errMsg += cont.deleteInstanceGroup(del)
0000000000000000000000000000000000000000;;		errMsg += cont.deleteFirewallRule(del)
0000000000000000000000000000000000000000;;		errMsg += cont.deleteSSLCertificate(del)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Verify instance-groups, issue #16636. Gcloud mysteriously barfs when told
0000000000000000000000000000000000000000;;		// to unmarshal instance groups into the current vendored gce-client's understanding
0000000000000000000000000000000000000000;;		// of the struct.
0000000000000000000000000000000000000000;;		if errMsg == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf(errMsg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Init initializes the GCEIngressController with an UID
0000000000000000000000000000000000000000;;	func (cont *GCEIngressController) Init() {
0000000000000000000000000000000000000000;;		uid, err := cont.getL7AddonUID()
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		cont.UID = uid
0000000000000000000000000000000000000000;;		// There's a name limit imposed by GCE. The controller will truncate.
0000000000000000000000000000000000000000;;		testName := fmt.Sprintf("k8s-fw-foo-app-X-%v--%v", cont.Ns, cont.UID)
0000000000000000000000000000000000000000;;		if len(testName) > nameLenLimit {
0000000000000000000000000000000000000000;;			Logf("WARNING: test name including cluster UID: %v is over the GCE limit of %v", testName, nameLenLimit)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			Logf("Detected cluster UID %v", cont.UID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateStaticIP allocates a random static ip with the given name. Returns a string
0000000000000000000000000000000000000000;;	// representation of the ip. Caller is expected to manage cleanup of the ip by
0000000000000000000000000000000000000000;;	// invoking deleteStaticIPs.
0000000000000000000000000000000000000000;;	func (cont *GCEIngressController) CreateStaticIP(name string) string {
0000000000000000000000000000000000000000;;		gceCloud := cont.Cloud.Provider.(*gcecloud.GCECloud)
0000000000000000000000000000000000000000;;		addr := &compute.Address{Name: name}
0000000000000000000000000000000000000000;;		if err := gceCloud.ReserveGlobalAddress(addr); err != nil {
0000000000000000000000000000000000000000;;			if delErr := gceCloud.DeleteGlobalAddress(name); delErr != nil {
0000000000000000000000000000000000000000;;				if cont.isHTTPErrorCode(delErr, http.StatusNotFound) {
0000000000000000000000000000000000000000;;					Logf("Static ip with name %v was not allocated, nothing to delete", name)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					Logf("Failed to delete static ip %v: %v", name, delErr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Failf("Failed to allocate static ip %v: %v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ip, err := gceCloud.GetGlobalAddress(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("Failed to get newly created static ip %v: %v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cont.staticIPName = ip.Name
0000000000000000000000000000000000000000;;		Logf("Reserved static ip %v: %v", cont.staticIPName, ip.Address)
0000000000000000000000000000000000000000;;		return ip.Address
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteStaticIPs delets all static-ips allocated through calls to
0000000000000000000000000000000000000000;;	// CreateStaticIP.
0000000000000000000000000000000000000000;;	func (cont *GCEIngressController) deleteStaticIPs() error {
0000000000000000000000000000000000000000;;		if cont.staticIPName != "" {
0000000000000000000000000000000000000000;;			if err := GcloudComputeResourceDelete("addresses", cont.staticIPName, cont.Cloud.ProjectID, "--global"); err == nil {
0000000000000000000000000000000000000000;;				cont.staticIPName = ""
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e2eIPs := []compute.Address{}
0000000000000000000000000000000000000000;;			gcloudComputeResourceList("addresses", "e2e-.*", cont.Cloud.ProjectID, &e2eIPs)
0000000000000000000000000000000000000000;;			ips := []string{}
0000000000000000000000000000000000000000;;			for _, ip := range e2eIPs {
0000000000000000000000000000000000000000;;				ips = append(ips, ip.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Logf("None of the remaining %d static-ips were created by this e2e: %v", len(ips), strings.Join(ips, ", "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// gcloudComputeResourceList unmarshals json output of gcloud into given out interface.
0000000000000000000000000000000000000000;;	func gcloudComputeResourceList(resource, regex, project string, out interface{}) {
0000000000000000000000000000000000000000;;		// gcloud prints a message to stderr if it has an available update
0000000000000000000000000000000000000000;;		// so we only look at stdout.
0000000000000000000000000000000000000000;;		command := []string{
0000000000000000000000000000000000000000;;			"compute", resource, "list",
0000000000000000000000000000000000000000;;			fmt.Sprintf("--regexp=%q", regex),
0000000000000000000000000000000000000000;;			fmt.Sprintf("--project=%v", project),
0000000000000000000000000000000000000000;;			"-q", "--format=json",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output, err := exec.Command("gcloud", command...).Output()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			errCode := -1
0000000000000000000000000000000000000000;;			errMsg := ""
0000000000000000000000000000000000000000;;			if exitErr, ok := err.(utilexec.ExitError); ok {
0000000000000000000000000000000000000000;;				errCode = exitErr.ExitStatus()
0000000000000000000000000000000000000000;;				errMsg = exitErr.Error()
0000000000000000000000000000000000000000;;				if osExitErr, ok := err.(*exec.ExitError); ok {
0000000000000000000000000000000000000000;;					errMsg = fmt.Sprintf("%v, stderr %v", errMsg, string(osExitErr.Stderr))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Logf("Error running gcloud command 'gcloud %s': err: %v, output: %v, status: %d, msg: %v", strings.Join(command, " "), err, string(output), errCode, errMsg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal([]byte(output), out); err != nil {
0000000000000000000000000000000000000000;;			Logf("Error unmarshalling gcloud output for %v: %v, output: %v", resource, err, string(output))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GcloudComputeResourceDelete deletes the specified compute resource by name and project.
0000000000000000000000000000000000000000;;	func GcloudComputeResourceDelete(resource, name, project string, args ...string) error {
0000000000000000000000000000000000000000;;		Logf("Deleting %v: %v", resource, name)
0000000000000000000000000000000000000000;;		argList := append([]string{"compute", resource, "delete", name, fmt.Sprintf("--project=%v", project), "-q"}, args...)
0000000000000000000000000000000000000000;;		output, err := exec.Command("gcloud", argList...).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Logf("Error deleting %v, output: %v\nerror: %+v", resource, string(output), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GcloudComputeResourceCreate creates a compute resource with a name and arguments.
0000000000000000000000000000000000000000;;	func GcloudComputeResourceCreate(resource, name, project string, args ...string) error {
0000000000000000000000000000000000000000;;		Logf("Creating %v in project %v: %v", resource, project, name)
0000000000000000000000000000000000000000;;		argsList := append([]string{"compute", resource, "create", name, fmt.Sprintf("--project=%v", project)}, args...)
0000000000000000000000000000000000000000;;		Logf("Running command: gcloud %+v", strings.Join(argsList, " "))
0000000000000000000000000000000000000000;;		output, err := exec.Command("gcloud", argsList...).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Logf("Error creating %v, output: %v\nerror: %+v", resource, string(output), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateIngress creates the Ingress and associated service/rc.
0000000000000000000000000000000000000000;;	// Required: ing.yaml, rc.yaml, svc.yaml must exist in manifestPath
0000000000000000000000000000000000000000;;	// Optional: secret.yaml, ingAnnotations
0000000000000000000000000000000000000000;;	// If ingAnnotations is specified it will overwrite any annotations in ing.yaml
0000000000000000000000000000000000000000;;	func (j *IngressTestJig) CreateIngress(manifestPath, ns string, ingAnnotations map[string]string) {
0000000000000000000000000000000000000000;;		mkpath := func(file string) string {
0000000000000000000000000000000000000000;;			return filepath.Join(TestContext.RepoRoot, manifestPath, file)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Logf("creating replication controller")
0000000000000000000000000000000000000000;;		RunKubectlOrDie("create", "-f", mkpath("rc.yaml"), fmt.Sprintf("--namespace=%v", ns))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Logf("creating service")
0000000000000000000000000000000000000000;;		RunKubectlOrDie("create", "-f", mkpath("svc.yaml"), fmt.Sprintf("--namespace=%v", ns))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if exists, _ := util.FileExists(mkpath("secret.yaml")); exists {
0000000000000000000000000000000000000000;;			Logf("creating secret")
0000000000000000000000000000000000000000;;			RunKubectlOrDie("create", "-f", mkpath("secret.yaml"), fmt.Sprintf("--namespace=%v", ns))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Logf("Parsing ingress from %v", filepath.Join(manifestPath, "ing.yaml"))
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		j.Ingress, err = manifest.IngressFromManifest(filepath.Join(manifestPath, "ing.yaml"))
0000000000000000000000000000000000000000;;		ExpectNoError(err)
0000000000000000000000000000000000000000;;		j.Ingress.Namespace = ns
0000000000000000000000000000000000000000;;		j.Ingress.Annotations = map[string]string{ingressClass: j.Class}
0000000000000000000000000000000000000000;;		for k, v := range ingAnnotations {
0000000000000000000000000000000000000000;;			j.Ingress.Annotations[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Logf(fmt.Sprintf("creating" + j.Ingress.Name + " ingress"))
0000000000000000000000000000000000000000;;		j.Ingress, err = j.Client.Extensions().Ingresses(ns).Create(j.Ingress)
0000000000000000000000000000000000000000;;		ExpectNoError(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update retrieves the ingress, performs the passed function, and then updates it.
0000000000000000000000000000000000000000;;	func (j *IngressTestJig) Update(update func(ing *extensions.Ingress)) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		ns, name := j.Ingress.Namespace, j.Ingress.Name
0000000000000000000000000000000000000000;;		for i := 0; i < 3; i++ {
0000000000000000000000000000000000000000;;			j.Ingress, err = j.Client.Extensions().Ingresses(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				Failf("failed to get ingress %q: %v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			update(j.Ingress)
0000000000000000000000000000000000000000;;			j.Ingress, err = j.Client.Extensions().Ingresses(ns).Update(j.Ingress)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				DescribeIng(j.Ingress.Namespace)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !apierrs.IsConflict(err) && !apierrs.IsServerTimeout(err) {
0000000000000000000000000000000000000000;;				Failf("failed to update ingress %q: %v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Failf("too many retries updating ingress %q", name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddHTTPS updates the ingress to use this secret for these hosts.
0000000000000000000000000000000000000000;;	func (j *IngressTestJig) AddHTTPS(secretName string, hosts ...string) {
0000000000000000000000000000000000000000;;		j.Ingress.Spec.TLS = []extensions.IngressTLS{{Hosts: hosts, SecretName: secretName}}
0000000000000000000000000000000000000000;;		// TODO: Just create the secret in GetRootCAs once we're watching secrets in
0000000000000000000000000000000000000000;;		// the ingress controller.
0000000000000000000000000000000000000000;;		_, cert, _, err := createIngressTLSSecret(j.Client, j.Ingress)
0000000000000000000000000000000000000000;;		ExpectNoError(err)
0000000000000000000000000000000000000000;;		Logf("Updating ingress %v to use secret %v for TLS termination", j.Ingress.Name, secretName)
0000000000000000000000000000000000000000;;		j.Update(func(ing *extensions.Ingress) {
0000000000000000000000000000000000000000;;			ing.Spec.TLS = []extensions.IngressTLS{{Hosts: hosts, SecretName: secretName}}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		j.RootCAs[secretName] = cert
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetRootCA returns a rootCA from the ingress test jig.
0000000000000000000000000000000000000000;;	func (j *IngressTestJig) GetRootCA(secretName string) (rootCA []byte) {
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		rootCA, ok = j.RootCAs[secretName]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			Failf("Failed to retrieve rootCAs, no recorded secret by name %v", secretName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TryDeleteIngress attempts to delete the ingress resource and logs errors if they occur.
0000000000000000000000000000000000000000;;	func (j *IngressTestJig) TryDeleteIngress() {
0000000000000000000000000000000000000000;;		err := j.Client.Extensions().Ingresses(j.Ingress.Namespace).Delete(j.Ingress.Name, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Logf("Error while deleting the ingress %v/%v: %v", j.Ingress.Namespace, j.Ingress.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForIngress waits till the ingress acquires an IP, then waits for its
0000000000000000000000000000000000000000;;	// hosts/urls to respond to a protocol check (either http or https). If
0000000000000000000000000000000000000000;;	// waitForNodePort is true, the NodePort of the Service is verified before
0000000000000000000000000000000000000000;;	// verifying the Ingress. NodePort is currently a requirement for cloudprovider
0000000000000000000000000000000000000000;;	// Ingress.
0000000000000000000000000000000000000000;;	func (j *IngressTestJig) WaitForIngress(waitForNodePort bool) {
0000000000000000000000000000000000000000;;		// Wait for the loadbalancer IP.
0000000000000000000000000000000000000000;;		address, err := WaitForIngressAddress(j.Client, j.Ingress.Namespace, j.Ingress.Name, LoadBalancerPollTimeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("Ingress failed to acquire an IP address within %v", LoadBalancerPollTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		j.Address = address
0000000000000000000000000000000000000000;;		Logf("Found address %v for ingress %v", j.Address, j.Ingress.Name)
0000000000000000000000000000000000000000;;		timeoutClient := &http.Client{Timeout: IngressReqTimeout}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check that all rules respond to a simple GET.
0000000000000000000000000000000000000000;;		for _, rules := range j.Ingress.Spec.Rules {
0000000000000000000000000000000000000000;;			proto := "http"
0000000000000000000000000000000000000000;;			if len(j.Ingress.Spec.TLS) > 0 {
0000000000000000000000000000000000000000;;				knownHosts := sets.NewString(j.Ingress.Spec.TLS[0].Hosts...)
0000000000000000000000000000000000000000;;				if knownHosts.Has(rules.Host) {
0000000000000000000000000000000000000000;;					timeoutClient.Transport, err = buildTransportWithCA(rules.Host, j.GetRootCA(j.Ingress.Spec.TLS[0].SecretName))
0000000000000000000000000000000000000000;;					ExpectNoError(err)
0000000000000000000000000000000000000000;;					proto = "https"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, p := range rules.IngressRuleValue.HTTP.Paths {
0000000000000000000000000000000000000000;;				if waitForNodePort {
0000000000000000000000000000000000000000;;					j.pollServiceNodePort(j.Ingress.Namespace, p.Backend.ServiceName, int(p.Backend.ServicePort.IntVal))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				route := fmt.Sprintf("%v://%v%v", proto, address, p.Path)
0000000000000000000000000000000000000000;;				Logf("Testing route %v host %v with simple GET", route, rules.Host)
0000000000000000000000000000000000000000;;				ExpectNoError(PollURL(route, rules.Host, LoadBalancerPollTimeout, j.PollInterval, timeoutClient, false))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifyURL polls for the given iterations, in intervals, and fails if the
0000000000000000000000000000000000000000;;	// given url returns a non-healthy http code even once.
0000000000000000000000000000000000000000;;	func (j *IngressTestJig) VerifyURL(route, host string, iterations int, interval time.Duration, httpClient *http.Client) error {
0000000000000000000000000000000000000000;;		for i := 0; i < iterations; i++ {
0000000000000000000000000000000000000000;;			b, err := SimpleGET(httpClient, route, host)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				Logf(b)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Logf("Verfied %v with host %v %d times, sleeping for %v", route, host, i, interval)
0000000000000000000000000000000000000000;;			time.Sleep(interval)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *IngressTestJig) pollServiceNodePort(ns, name string, port int) {
0000000000000000000000000000000000000000;;		// TODO: Curl all nodes?
0000000000000000000000000000000000000000;;		u, err := GetNodePortURL(j.Client, ns, name, port)
0000000000000000000000000000000000000000;;		ExpectNoError(err)
0000000000000000000000000000000000000000;;		ExpectNoError(PollURL(u, "", 30*time.Second, j.PollInterval, &http.Client{Timeout: IngressReqTimeout}, false))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetIngressNodePorts returns all related backend services' nodePorts.
0000000000000000000000000000000000000000;;	// Current GCE ingress controller allows traffic to the default HTTP backend
0000000000000000000000000000000000000000;;	// by default, so retrieve its nodePort as well.
0000000000000000000000000000000000000000;;	func (j *IngressTestJig) GetIngressNodePorts() []string {
0000000000000000000000000000000000000000;;		nodePorts := []string{}
0000000000000000000000000000000000000000;;		defaultSvc, err := j.Client.Core().Services(metav1.NamespaceSystem).Get(defaultBackendName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		nodePorts = append(nodePorts, strconv.Itoa(int(defaultSvc.Spec.Ports[0].NodePort)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backendSvcs := []string{}
0000000000000000000000000000000000000000;;		if j.Ingress.Spec.Backend != nil {
0000000000000000000000000000000000000000;;			backendSvcs = append(backendSvcs, j.Ingress.Spec.Backend.ServiceName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rule := range j.Ingress.Spec.Rules {
0000000000000000000000000000000000000000;;			for _, ingPath := range rule.HTTP.Paths {
0000000000000000000000000000000000000000;;				backendSvcs = append(backendSvcs, ingPath.Backend.ServiceName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, svcName := range backendSvcs {
0000000000000000000000000000000000000000;;			svc, err := j.Client.Core().Services(j.Ingress.Namespace).Get(svcName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			nodePorts = append(nodePorts, strconv.Itoa(int(svc.Spec.Ports[0].NodePort)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodePorts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConstructFirewallForIngress returns the expected GCE firewall rule for the ingress resource
0000000000000000000000000000000000000000;;	func (j *IngressTestJig) ConstructFirewallForIngress(gceController *GCEIngressController, nodeTags []string) *compute.Firewall {
0000000000000000000000000000000000000000;;		nodePorts := j.GetIngressNodePorts()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fw := compute.Firewall{}
0000000000000000000000000000000000000000;;		fw.Name = gceController.GetFirewallRuleName()
0000000000000000000000000000000000000000;;		fw.SourceRanges = gcecloud.LoadBalancerSrcRanges()
0000000000000000000000000000000000000000;;		fw.TargetTags = nodeTags
0000000000000000000000000000000000000000;;		fw.Allowed = []*compute.FirewallAllowed{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				IPProtocol: "tcp",
0000000000000000000000000000000000000000;;				Ports:      nodePorts,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &fw
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cont *GCEIngressController) getL7AddonUID() (string, error) {
0000000000000000000000000000000000000000;;		Logf("Retrieving UID from config map: %v/%v", metav1.NamespaceSystem, uidConfigMap)
0000000000000000000000000000000000000000;;		cm, err := cont.Client.Core().ConfigMaps(metav1.NamespaceSystem).Get(uidConfigMap, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if uid, ok := cm.Data[uidKey]; ok {
0000000000000000000000000000000000000000;;			return uid, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("Could not find cluster UID for L7 addon pod")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GCEIngressController manages implementation details of Ingress on GCE/GKE.
0000000000000000000000000000000000000000;;	type GCEIngressController struct {
0000000000000000000000000000000000000000;;		Ns           string
0000000000000000000000000000000000000000;;		rcPath       string
0000000000000000000000000000000000000000;;		UID          string
0000000000000000000000000000000000000000;;		staticIPName string
0000000000000000000000000000000000000000;;		rc           *v1.ReplicationController
0000000000000000000000000000000000000000;;		svc          *v1.Service
0000000000000000000000000000000000000000;;		Client       clientset.Interface
0000000000000000000000000000000000000000;;		Cloud        CloudConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewIngressTestJig instantiates struct with client
0000000000000000000000000000000000000000;;	func NewIngressTestJig(c clientset.Interface) *IngressTestJig {
0000000000000000000000000000000000000000;;		return &IngressTestJig{Client: c, RootCAs: map[string][]byte{}, PollInterval: LoadBalancerPollInterval}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NginxIngressController manages implementation details of Ingress on Nginx.
0000000000000000000000000000000000000000;;	type NginxIngressController struct {
0000000000000000000000000000000000000000;;		Ns         string
0000000000000000000000000000000000000000;;		rc         *v1.ReplicationController
0000000000000000000000000000000000000000;;		pod        *v1.Pod
0000000000000000000000000000000000000000;;		Client     clientset.Interface
0000000000000000000000000000000000000000;;		externalIP string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Init initializes the NginxIngressController
0000000000000000000000000000000000000000;;	func (cont *NginxIngressController) Init() {
0000000000000000000000000000000000000000;;		mkpath := func(file string) string {
0000000000000000000000000000000000000000;;			return filepath.Join(TestContext.RepoRoot, IngressManifestPath, "nginx", file)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Logf("initializing nginx ingress controller")
0000000000000000000000000000000000000000;;		RunKubectlOrDie("create", "-f", mkpath("rc.yaml"), fmt.Sprintf("--namespace=%v", cont.Ns))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rc, err := cont.Client.Core().ReplicationControllers(cont.Ns).Get("nginx-ingress-controller", metav1.GetOptions{})
0000000000000000000000000000000000000000;;		ExpectNoError(err)
0000000000000000000000000000000000000000;;		cont.rc = rc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Logf("waiting for pods with label %v", rc.Spec.Selector)
0000000000000000000000000000000000000000;;		sel := labels.SelectorFromSet(labels.Set(rc.Spec.Selector))
0000000000000000000000000000000000000000;;		ExpectNoError(testutils.WaitForPodsWithLabelRunning(cont.Client, cont.Ns, sel))
0000000000000000000000000000000000000000;;		pods, err := cont.Client.Core().Pods(cont.Ns).List(metav1.ListOptions{LabelSelector: sel.String()})
0000000000000000000000000000000000000000;;		ExpectNoError(err)
0000000000000000000000000000000000000000;;		if len(pods.Items) == 0 {
0000000000000000000000000000000000000000;;			Failf("Failed to find nginx ingress controller pods with selector %v", sel)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cont.pod = &pods.Items[0]
0000000000000000000000000000000000000000;;		cont.externalIP, err = GetHostExternalAddress(cont.Client, cont.pod)
0000000000000000000000000000000000000000;;		ExpectNoError(err)
0000000000000000000000000000000000000000;;		Logf("ingress controller running in pod %v on ip %v", cont.pod.Name, cont.externalIP)
0000000000000000000000000000000000000000;;	}
