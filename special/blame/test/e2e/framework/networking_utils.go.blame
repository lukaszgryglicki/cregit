0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
83f099ec73a314586a1e6e036808b16e46ab082d;test/e2e/kubeproxy.go[test/e2e/kubeproxy.go][test/e2e/framework/networking_utils.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/rand"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		coreclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/core/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		EndpointHttpPort      = 8080
0000000000000000000000000000000000000000;;		EndpointUdpPort       = 8081
0000000000000000000000000000000000000000;;		TestContainerHttpPort = 8080
0000000000000000000000000000000000000000;;		ClusterHttpPort       = 80
0000000000000000000000000000000000000000;;		ClusterUdpPort        = 90
0000000000000000000000000000000000000000;;		NetexecImageName      = "gcr.io/google_containers/netexec:1.7"
0000000000000000000000000000000000000000;;		HostexecImageName     = "gcr.io/google_containers/hostexec:1.2"
0000000000000000000000000000000000000000;;		testPodName           = "test-container-pod"
0000000000000000000000000000000000000000;;		hostTestPodName       = "host-test-container-pod"
0000000000000000000000000000000000000000;;		nodePortServiceName   = "node-port-service"
0000000000000000000000000000000000000000;;		// wait time between poll attempts of a Service vip and/or nodePort.
0000000000000000000000000000000000000000;;		// coupled with testTries to produce a net timeout value.
0000000000000000000000000000000000000000;;		hitEndpointRetryDelay = 2 * time.Second
0000000000000000000000000000000000000000;;		// Number of retries to hit a given set of endpoints. Needs to be high
0000000000000000000000000000000000000000;;		// because we verify iptables statistical rr loadbalancing.
0000000000000000000000000000000000000000;;		testTries = 30
0000000000000000000000000000000000000000;;		// Maximum number of pods in a test, to make test work in large clusters.
0000000000000000000000000000000000000000;;		maxNetProxyPodsCount = 10
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewNetworkingTestConfig creates and sets up a new test config helper.
0000000000000000000000000000000000000000;;	func NewNetworkingTestConfig(f *Framework) *NetworkingTestConfig {
0000000000000000000000000000000000000000;;		config := &NetworkingTestConfig{f: f, Namespace: f.Namespace.Name}
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Performing setup for networking test in namespace %v", config.Namespace))
0000000000000000000000000000000000000000;;		config.setup(getServiceSelector())
0000000000000000000000000000000000000000;;		return config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewNetworkingTestNodeE2EConfig creates and sets up a new test config helper for Node E2E.
0000000000000000000000000000000000000000;;	func NewCoreNetworkingTestConfig(f *Framework) *NetworkingTestConfig {
0000000000000000000000000000000000000000;;		config := &NetworkingTestConfig{f: f, Namespace: f.Namespace.Name}
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Performing setup for networking test in namespace %v", config.Namespace))
0000000000000000000000000000000000000000;;		config.setupCore(getServiceSelector())
0000000000000000000000000000000000000000;;		return config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getServiceSelector() map[string]string {
0000000000000000000000000000000000000000;;		By("creating a selector")
0000000000000000000000000000000000000000;;		selectorName := "selector-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;		serviceSelector := map[string]string{
0000000000000000000000000000000000000000;;			selectorName: "true",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return serviceSelector
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NetworkingTestConfig is a convenience class around some utility methods
0000000000000000000000000000000000000000;;	// for testing kubeproxy/networking/services/endpoints.
0000000000000000000000000000000000000000;;	type NetworkingTestConfig struct {
0000000000000000000000000000000000000000;;		// TestContaienrPod is a test pod running the netexec image. It is capable
0000000000000000000000000000000000000000;;		// of executing tcp/udp requests against ip:port.
0000000000000000000000000000000000000000;;		TestContainerPod *v1.Pod
0000000000000000000000000000000000000000;;		// HostTestContainerPod is a pod running with hostNetworking=true, and the
0000000000000000000000000000000000000000;;		// hostexec image.
0000000000000000000000000000000000000000;;		HostTestContainerPod *v1.Pod
0000000000000000000000000000000000000000;;		// EndpointPods are the pods belonging to the Service created by this
0000000000000000000000000000000000000000;;		// test config. Each invocation of `setup` creates a service with
0000000000000000000000000000000000000000;;		// 1 pod per node running the netexecImage.
0000000000000000000000000000000000000000;;		EndpointPods []*v1.Pod
0000000000000000000000000000000000000000;;		f            *Framework
0000000000000000000000000000000000000000;;		podClient    *PodClient
0000000000000000000000000000000000000000;;		// NodePortService is a Service with Type=NodePort spanning over all
0000000000000000000000000000000000000000;;		// endpointPods.
0000000000000000000000000000000000000000;;		NodePortService *v1.Service
0000000000000000000000000000000000000000;;		// ExternalAddrs is a list of external IPs of nodes in the cluster.
0000000000000000000000000000000000000000;;		ExternalAddrs []string
0000000000000000000000000000000000000000;;		// Nodes is a list of nodes in the cluster.
0000000000000000000000000000000000000000;;		Nodes []v1.Node
0000000000000000000000000000000000000000;;		// MaxTries is the number of retries tolerated for tests run against
0000000000000000000000000000000000000000;;		// endpoints and services created by this config.
0000000000000000000000000000000000000000;;		MaxTries int
0000000000000000000000000000000000000000;;		// The ClusterIP of the Service reated by this test config.
0000000000000000000000000000000000000000;;		ClusterIP string
0000000000000000000000000000000000000000;;		// External ip of first node for use in nodePort testing.
0000000000000000000000000000000000000000;;		NodeIP string
0000000000000000000000000000000000000000;;		// The http/udp nodePorts of the Service.
0000000000000000000000000000000000000000;;		NodeHttpPort int
0000000000000000000000000000000000000000;;		NodeUdpPort  int
0000000000000000000000000000000000000000;;		// The kubernetes namespace within which all resources for this
0000000000000000000000000000000000000000;;		// config are created
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) DialFromEndpointContainer(protocol, targetIP string, targetPort, maxTries, minTries int, expectedEps sets.String) {
0000000000000000000000000000000000000000;;		config.DialFromContainer(protocol, config.EndpointPods[0].Status.PodIP, targetIP, EndpointHttpPort, targetPort, maxTries, minTries, expectedEps)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) DialFromTestContainer(protocol, targetIP string, targetPort, maxTries, minTries int, expectedEps sets.String) {
0000000000000000000000000000000000000000;;		config.DialFromContainer(protocol, config.TestContainerPod.Status.PodIP, targetIP, TestContainerHttpPort, targetPort, maxTries, minTries, expectedEps)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// diagnoseMissingEndpoints prints debug information about the endpoints that
0000000000000000000000000000000000000000;;	// are NOT in the given list of foundEndpoints. These are the endpoints we
0000000000000000000000000000000000000000;;	// expected a response from.
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) diagnoseMissingEndpoints(foundEndpoints sets.String) {
0000000000000000000000000000000000000000;;		for _, e := range config.EndpointPods {
0000000000000000000000000000000000000000;;			if foundEndpoints.Has(e.Name) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Logf("\nOutput of kubectl describe pod %v/%v:\n", e.Namespace, e.Name)
0000000000000000000000000000000000000000;;			desc, _ := RunKubectl(
0000000000000000000000000000000000000000;;				"describe", "pod", e.Name, fmt.Sprintf("--namespace=%v", e.Namespace))
0000000000000000000000000000000000000000;;			Logf(desc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EndpointHostnames returns a set of hostnames for existing endpoints.
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) EndpointHostnames() sets.String {
0000000000000000000000000000000000000000;;		expectedEps := sets.NewString()
0000000000000000000000000000000000000000;;		for _, p := range config.EndpointPods {
0000000000000000000000000000000000000000;;			expectedEps.Insert(p.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return expectedEps
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DialFromContainers executes a curl via kubectl exec in a test container,
0000000000000000000000000000000000000000;;	// which might then translate to a tcp or udp request based on the protocol
0000000000000000000000000000000000000000;;	// argument in the url.
0000000000000000000000000000000000000000;;	// - minTries is the minimum number of curl attempts required before declaring
0000000000000000000000000000000000000000;;	//   success. Set to 0 if you'd like to return as soon as all endpoints respond
0000000000000000000000000000000000000000;;	//   at least once.
0000000000000000000000000000000000000000;;	// - maxTries is the maximum number of curl attempts. If this many attempts pass
0000000000000000000000000000000000000000;;	//   and we don't see all expected endpoints, the test fails.
0000000000000000000000000000000000000000;;	// - expectedEps is the set of endpointnames to wait for. Typically this is also
0000000000000000000000000000000000000000;;	//   the hostname reported by each pod in the service through /hostName.
0000000000000000000000000000000000000000;;	// maxTries == minTries will confirm that we see the expected endpoints and no
0000000000000000000000000000000000000000;;	// more for maxTries. Use this if you want to eg: fail a readiness check on a
0000000000000000000000000000000000000000;;	// pod and confirm it doesn't show up as an endpoint.
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) DialFromContainer(protocol, containerIP, targetIP string, containerHttpPort, targetPort, maxTries, minTries int, expectedEps sets.String) {
0000000000000000000000000000000000000000;;		cmd := fmt.Sprintf("curl -q -s 'http://%s:%d/dial?request=hostName&protocol=%s&host=%s&port=%d&tries=1'",
0000000000000000000000000000000000000000;;			containerIP,
0000000000000000000000000000000000000000;;			containerHttpPort,
0000000000000000000000000000000000000000;;			protocol,
0000000000000000000000000000000000000000;;			targetIP,
0000000000000000000000000000000000000000;;			targetPort)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eps := sets.NewString()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < maxTries; i++ {
0000000000000000000000000000000000000000;;			stdout, stderr, err := config.f.ExecShellInPodWithFullOutput(config.HostTestContainerPod.Name, cmd)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// A failure to kubectl exec counts as a try, not a hard fail.
0000000000000000000000000000000000000000;;				// Also note that we will keep failing for maxTries in tests where
0000000000000000000000000000000000000000;;				// we confirm unreachability.
0000000000000000000000000000000000000000;;				Logf("Failed to execute %q: %v, stdout: %q, stderr %q", cmd, err, stdout, stderr)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				var output map[string][]string
0000000000000000000000000000000000000000;;				if err := json.Unmarshal([]byte(stdout), &output); err != nil {
0000000000000000000000000000000000000000;;					Logf("WARNING: Failed to unmarshal curl response. Cmd %v run in %v, output: %s, err: %v",
0000000000000000000000000000000000000000;;						cmd, config.HostTestContainerPod.Name, stdout, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for _, hostName := range output["responses"] {
0000000000000000000000000000000000000000;;					trimmed := strings.TrimSpace(hostName)
0000000000000000000000000000000000000000;;					if trimmed != "" {
0000000000000000000000000000000000000000;;						eps.Insert(trimmed)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Logf("Waiting for endpoints: %v", expectedEps.Difference(eps))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check against i+1 so we exit if minTries == maxTries.
0000000000000000000000000000000000000000;;			if (eps.Equal(expectedEps) || eps.Len() == 0 && expectedEps.Len() == 0) && i+1 >= minTries {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: get rid of this delay #36281
0000000000000000000000000000000000000000;;			time.Sleep(hitEndpointRetryDelay)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.diagnoseMissingEndpoints(eps)
0000000000000000000000000000000000000000;;		Failf("Failed to find expected endpoints:\nTries %d\nCommand %v\nretrieved %v\nexpected %v\n", minTries, cmd, eps, expectedEps)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DialFromNode executes a tcp or udp request based on protocol via kubectl exec
0000000000000000000000000000000000000000;;	// in a test container running with host networking.
0000000000000000000000000000000000000000;;	// - minTries is the minimum number of curl attempts required before declaring
0000000000000000000000000000000000000000;;	//   success. Set to 0 if you'd like to return as soon as all endpoints respond
0000000000000000000000000000000000000000;;	//   at least once.
0000000000000000000000000000000000000000;;	// - maxTries is the maximum number of curl attempts. If this many attempts pass
0000000000000000000000000000000000000000;;	//   and we don't see all expected endpoints, the test fails.
0000000000000000000000000000000000000000;;	// maxTries == minTries will confirm that we see the expected endpoints and no
0000000000000000000000000000000000000000;;	// more for maxTries. Use this if you want to eg: fail a readiness check on a
0000000000000000000000000000000000000000;;	// pod and confirm it doesn't show up as an endpoint.
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) DialFromNode(protocol, targetIP string, targetPort, maxTries, minTries int, expectedEps sets.String) {
0000000000000000000000000000000000000000;;		var cmd string
0000000000000000000000000000000000000000;;		if protocol == "udp" {
0000000000000000000000000000000000000000;;			// TODO: It would be enough to pass 1s+epsilon to timeout, but unfortunately
0000000000000000000000000000000000000000;;			// busybox timeout doesn't support non-integer values.
0000000000000000000000000000000000000000;;			cmd = fmt.Sprintf("echo 'hostName' | timeout -t 2 nc -w 1 -u %s %d", targetIP, targetPort)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			cmd = fmt.Sprintf("timeout -t 15 curl -q -s --connect-timeout 1 http://%s:%d/hostName", targetIP, targetPort)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: This simply tells us that we can reach the endpoints. Check that
0000000000000000000000000000000000000000;;		// the probability of hitting a specific endpoint is roughly the same as
0000000000000000000000000000000000000000;;		// hitting any other.
0000000000000000000000000000000000000000;;		eps := sets.NewString()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		filterCmd := fmt.Sprintf("%s | grep -v '^\\s*$'", cmd)
0000000000000000000000000000000000000000;;		for i := 0; i < maxTries; i++ {
0000000000000000000000000000000000000000;;			stdout, stderr, err := config.f.ExecShellInPodWithFullOutput(config.HostTestContainerPod.Name, filterCmd)
0000000000000000000000000000000000000000;;			if err != nil || len(stderr) > 0 {
0000000000000000000000000000000000000000;;				// A failure to exec command counts as a try, not a hard fail.
0000000000000000000000000000000000000000;;				// Also note that we will keep failing for maxTries in tests where
0000000000000000000000000000000000000000;;				// we confirm unreachability.
0000000000000000000000000000000000000000;;				Logf("Failed to execute %q: %v, stdout: %q, stderr: %q", filterCmd, err, stdout, stderr)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				trimmed := strings.TrimSpace(stdout)
0000000000000000000000000000000000000000;;				if trimmed != "" {
0000000000000000000000000000000000000000;;					eps.Insert(trimmed)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check against i+1 so we exit if minTries == maxTries.
0000000000000000000000000000000000000000;;			if eps.Equal(expectedEps) && i+1 >= minTries {
0000000000000000000000000000000000000000;;				Logf("Found all expected endpoints: %+v", eps.List())
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Logf("Waiting for %+v endpoints (expected=%+v, actual=%+v)", expectedEps.Difference(eps).List(), expectedEps.List(), eps.List())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: get rid of this delay #36281
0000000000000000000000000000000000000000;;			time.Sleep(hitEndpointRetryDelay)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.diagnoseMissingEndpoints(eps)
0000000000000000000000000000000000000000;;		Failf("Failed to find expected endpoints:\nTries %d\nCommand %v\nretrieved %v\nexpected %v\n", minTries, cmd, eps, expectedEps)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetSelfURL executes a curl against the given path via kubectl exec into a
0000000000000000000000000000000000000000;;	// test container running with host networking, and fails if the output
0000000000000000000000000000000000000000;;	// doesn't match the expected string.
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) GetSelfURL(port int32, path string, expected string) {
0000000000000000000000000000000000000000;;		cmd := fmt.Sprintf("curl -i -q -s --connect-timeout 1 http://localhost:%d%s", port, path)
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Getting kube-proxy self URL %s", path))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// These are arbitrary timeouts. The curl command should pass on first try,
0000000000000000000000000000000000000000;;		// unless kubeproxy is starved/bootstrapping/restarting etc.
0000000000000000000000000000000000000000;;		const retryInterval = 1 * time.Second
0000000000000000000000000000000000000000;;		const retryTimeout = 30 * time.Second
0000000000000000000000000000000000000000;;		podName := config.HostTestContainerPod.Name
0000000000000000000000000000000000000000;;		var msg string
0000000000000000000000000000000000000000;;		if pollErr := wait.PollImmediate(retryInterval, retryTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			stdout, err := RunHostCmd(config.Namespace, podName, cmd)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				msg = fmt.Sprintf("failed executing cmd %v in %v/%v: %v", cmd, config.Namespace, podName, err)
0000000000000000000000000000000000000000;;				Logf(msg)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !strings.Contains(stdout, expected) {
0000000000000000000000000000000000000000;;				msg = fmt.Sprintf("successfully executed %v in %v/%v, but output '%v' doesn't contain expected string '%v'", cmd, config.Namespace, podName, stdout, expected)
0000000000000000000000000000000000000000;;				Logf(msg)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}); pollErr != nil {
0000000000000000000000000000000000000000;;			Logf("\nOutput of kubectl describe pod %v/%v:\n", config.Namespace, podName)
0000000000000000000000000000000000000000;;			desc, _ := RunKubectl(
0000000000000000000000000000000000000000;;				"describe", "pod", podName, fmt.Sprintf("--namespace=%v", config.Namespace))
0000000000000000000000000000000000000000;;			Logf("%s", desc)
0000000000000000000000000000000000000000;;			Failf("Timed out in %v: %v", retryTimeout, msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) createNetShellPodSpec(podName, hostname string) *v1.Pod {
0000000000000000000000000000000000000000;;		probe := &v1.Probe{
0000000000000000000000000000000000000000;;			InitialDelaySeconds: 10,
0000000000000000000000000000000000000000;;			TimeoutSeconds:      30,
0000000000000000000000000000000000000000;;			PeriodSeconds:       10,
0000000000000000000000000000000000000000;;			SuccessThreshold:    1,
0000000000000000000000000000000000000000;;			FailureThreshold:    3,
0000000000000000000000000000000000000000;;			Handler: v1.Handler{
0000000000000000000000000000000000000000;;				HTTPGet: &v1.HTTPGetAction{
0000000000000000000000000000000000000000;;					Path: "/healthz",
0000000000000000000000000000000000000000;;					Port: intstr.IntOrString{IntVal: EndpointHttpPort},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      podName,
0000000000000000000000000000000000000000;;				Namespace: config.Namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:            "webserver",
0000000000000000000000000000000000000000;;						Image:           NetexecImageName,
0000000000000000000000000000000000000000;;						ImagePullPolicy: v1.PullIfNotPresent,
0000000000000000000000000000000000000000;;						Command: []string{
0000000000000000000000000000000000000000;;							"/netexec",
0000000000000000000000000000000000000000;;							fmt.Sprintf("--http-port=%d", EndpointHttpPort),
0000000000000000000000000000000000000000;;							fmt.Sprintf("--udp-port=%d", EndpointUdpPort),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Ports: []v1.ContainerPort{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:          "http",
0000000000000000000000000000000000000000;;								ContainerPort: EndpointHttpPort,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:          "udp",
0000000000000000000000000000000000000000;;								ContainerPort: EndpointUdpPort,
0000000000000000000000000000000000000000;;								Protocol:      v1.ProtocolUDP,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						LivenessProbe:  probe,
0000000000000000000000000000000000000000;;						ReadinessProbe: probe,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				NodeSelector: map[string]string{
0000000000000000000000000000000000000000;;					"kubernetes.io/hostname": hostname,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) createTestPodSpec() *v1.Pod {
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      testPodName,
0000000000000000000000000000000000000000;;				Namespace: config.Namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:            "webserver",
0000000000000000000000000000000000000000;;						Image:           NetexecImageName,
0000000000000000000000000000000000000000;;						ImagePullPolicy: v1.PullIfNotPresent,
0000000000000000000000000000000000000000;;						Command: []string{
0000000000000000000000000000000000000000;;							"/netexec",
0000000000000000000000000000000000000000;;							fmt.Sprintf("--http-port=%d", EndpointHttpPort),
0000000000000000000000000000000000000000;;							fmt.Sprintf("--udp-port=%d", EndpointUdpPort),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Ports: []v1.ContainerPort{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:          "http",
0000000000000000000000000000000000000000;;								ContainerPort: TestContainerHttpPort,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) createNodePortService(selector map[string]string) {
0000000000000000000000000000000000000000;;		serviceSpec := &v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: nodePortServiceName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: v1.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{
0000000000000000000000000000000000000000;;					{Port: ClusterHttpPort, Name: "http", Protocol: v1.ProtocolTCP, TargetPort: intstr.FromInt(EndpointHttpPort)},
0000000000000000000000000000000000000000;;					{Port: ClusterUdpPort, Name: "udp", Protocol: v1.ProtocolUDP, TargetPort: intstr.FromInt(EndpointUdpPort)},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Selector: selector,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config.NodePortService = config.createService(serviceSpec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) DeleteNodePortService() {
0000000000000000000000000000000000000000;;		err := config.getServiceClient().Delete(config.NodePortService.Name, nil)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "error while deleting NodePortService. err:%v)", err)
0000000000000000000000000000000000000000;;		time.Sleep(15 * time.Second) // wait for kube-proxy to catch up with the service being deleted.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) createTestPods() {
0000000000000000000000000000000000000000;;		testContainerPod := config.createTestPodSpec()
0000000000000000000000000000000000000000;;		hostTestContainerPod := NewHostExecPodSpec(config.Namespace, hostTestPodName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.createPod(testContainerPod)
0000000000000000000000000000000000000000;;		config.createPod(hostTestContainerPod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ExpectNoError(config.f.WaitForPodRunning(testContainerPod.Name))
0000000000000000000000000000000000000000;;		ExpectNoError(config.f.WaitForPodRunning(hostTestContainerPod.Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		config.TestContainerPod, err = config.getPodClient().Get(testContainerPod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("Failed to retrieve %s pod: %v", testContainerPod.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.HostTestContainerPod, err = config.getPodClient().Get(hostTestContainerPod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("Failed to retrieve %s pod: %v", hostTestContainerPod.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) createService(serviceSpec *v1.Service) *v1.Service {
0000000000000000000000000000000000000000;;		_, err := config.getServiceClient().Create(serviceSpec)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Failed to create %s service: %v", serviceSpec.Name, err))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = WaitForService(config.f.ClientSet, config.Namespace, serviceSpec.Name, true, 5*time.Second, 45*time.Second)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("error while waiting for service:%s err: %v", serviceSpec.Name, err))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		createdService, err := config.getServiceClient().Get(serviceSpec.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Failed to create %s service: %v", serviceSpec.Name, err))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return createdService
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setupCore sets up the pods and core test config
0000000000000000000000000000000000000000;;	// mainly for simplified node e2e setup
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) setupCore(selector map[string]string) {
0000000000000000000000000000000000000000;;		By("Creating the service pods in kubernetes")
0000000000000000000000000000000000000000;;		podName := "netserver"
0000000000000000000000000000000000000000;;		config.EndpointPods = config.createNetProxyPods(podName, selector)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating test pods")
0000000000000000000000000000000000000000;;		config.createTestPods()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		epCount := len(config.EndpointPods)
0000000000000000000000000000000000000000;;		config.MaxTries = epCount*epCount + testTries
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setup includes setupCore and also sets up services
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) setup(selector map[string]string) {
0000000000000000000000000000000000000000;;		config.setupCore(selector)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Getting node addresses")
0000000000000000000000000000000000000000;;		ExpectNoError(WaitForAllNodesSchedulable(config.f.ClientSet, 10*time.Minute))
0000000000000000000000000000000000000000;;		nodeList := GetReadySchedulableNodesOrDie(config.f.ClientSet)
0000000000000000000000000000000000000000;;		config.ExternalAddrs = NodeAddresses(nodeList, v1.NodeExternalIP)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SkipUnlessNodeCountIsAtLeast(2)
0000000000000000000000000000000000000000;;		config.Nodes = nodeList.Items
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating the service on top of the pods in kubernetes")
0000000000000000000000000000000000000000;;		config.createNodePortService(selector)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, p := range config.NodePortService.Spec.Ports {
0000000000000000000000000000000000000000;;			switch p.Protocol {
0000000000000000000000000000000000000000;;			case v1.ProtocolUDP:
0000000000000000000000000000000000000000;;				config.NodeUdpPort = int(p.NodePort)
0000000000000000000000000000000000000000;;			case v1.ProtocolTCP:
0000000000000000000000000000000000000000;;				config.NodeHttpPort = int(p.NodePort)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config.ClusterIP = config.NodePortService.Spec.ClusterIP
0000000000000000000000000000000000000000;;		config.NodeIP = config.ExternalAddrs[0]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) cleanup() {
0000000000000000000000000000000000000000;;		nsClient := config.getNamespacesClient()
0000000000000000000000000000000000000000;;		nsList, err := nsClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			for _, ns := range nsList.Items {
0000000000000000000000000000000000000000;;				if strings.Contains(ns.Name, config.f.BaseName) && ns.Name != config.Namespace {
0000000000000000000000000000000000000000;;					nsClient.Delete(ns.Name, nil)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shuffleNodes copies nodes from the specified slice into a copy in random
0000000000000000000000000000000000000000;;	// order. It returns a new slice.
0000000000000000000000000000000000000000;;	func shuffleNodes(nodes []v1.Node) []v1.Node {
0000000000000000000000000000000000000000;;		shuffled := make([]v1.Node, len(nodes))
0000000000000000000000000000000000000000;;		perm := rand.Perm(len(nodes))
0000000000000000000000000000000000000000;;		for i, j := range perm {
0000000000000000000000000000000000000000;;			shuffled[j] = nodes[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return shuffled
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) createNetProxyPods(podName string, selector map[string]string) []*v1.Pod {
0000000000000000000000000000000000000000;;		ExpectNoError(WaitForAllNodesSchedulable(config.f.ClientSet, 10*time.Minute))
0000000000000000000000000000000000000000;;		nodeList := GetReadySchedulableNodesOrDie(config.f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// To make this test work reasonably fast in large clusters,
0000000000000000000000000000000000000000;;		// we limit the number of NetProxyPods to no more than
0000000000000000000000000000000000000000;;		// maxNetProxyPodsCount on random nodes.
0000000000000000000000000000000000000000;;		nodes := shuffleNodes(nodeList.Items)
0000000000000000000000000000000000000000;;		if len(nodes) > maxNetProxyPodsCount {
0000000000000000000000000000000000000000;;			nodes = nodes[:maxNetProxyPodsCount]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create pods, one for each node
0000000000000000000000000000000000000000;;		createdPods := make([]*v1.Pod, 0, len(nodes))
0000000000000000000000000000000000000000;;		for i, n := range nodes {
0000000000000000000000000000000000000000;;			podName := fmt.Sprintf("%s-%d", podName, i)
0000000000000000000000000000000000000000;;			hostname, _ := n.Labels["kubernetes.io/hostname"]
0000000000000000000000000000000000000000;;			pod := config.createNetShellPodSpec(podName, hostname)
0000000000000000000000000000000000000000;;			pod.ObjectMeta.Labels = selector
0000000000000000000000000000000000000000;;			createdPod := config.createPod(pod)
0000000000000000000000000000000000000000;;			createdPods = append(createdPods, createdPod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait that all of them are up
0000000000000000000000000000000000000000;;		runningPods := make([]*v1.Pod, 0, len(nodes))
0000000000000000000000000000000000000000;;		for _, p := range createdPods {
0000000000000000000000000000000000000000;;			ExpectNoError(config.f.WaitForPodReady(p.Name))
0000000000000000000000000000000000000000;;			rp, err := config.getPodClient().Get(p.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			ExpectNoError(err)
0000000000000000000000000000000000000000;;			runningPods = append(runningPods, rp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return runningPods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) DeleteNetProxyPod() {
0000000000000000000000000000000000000000;;		pod := config.EndpointPods[0]
0000000000000000000000000000000000000000;;		config.getPodClient().Delete(pod.Name, metav1.NewDeleteOptions(0))
0000000000000000000000000000000000000000;;		config.EndpointPods = config.EndpointPods[1:]
0000000000000000000000000000000000000000;;		// wait for pod being deleted.
0000000000000000000000000000000000000000;;		err := WaitForPodToDisappear(config.f.ClientSet, config.Namespace, pod.Name, labels.Everything(), time.Second, wait.ForeverTestTimeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("Failed to delete %s pod: %v", pod.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// wait for endpoint being removed.
0000000000000000000000000000000000000000;;		err = WaitForServiceEndpointsNum(config.f.ClientSet, config.Namespace, nodePortServiceName, len(config.EndpointPods), time.Second, wait.ForeverTestTimeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("Failed to remove endpoint from service: %s", nodePortServiceName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// wait for kube-proxy to catch up with the pod being deleted.
0000000000000000000000000000000000000000;;		time.Sleep(5 * time.Second)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) createPod(pod *v1.Pod) *v1.Pod {
0000000000000000000000000000000000000000;;		return config.getPodClient().Create(pod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) getPodClient() *PodClient {
0000000000000000000000000000000000000000;;		if config.podClient == nil {
0000000000000000000000000000000000000000;;			config.podClient = config.f.PodClient()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return config.podClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) getServiceClient() coreclientset.ServiceInterface {
0000000000000000000000000000000000000000;;		return config.f.ClientSet.Core().Services(config.Namespace)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *NetworkingTestConfig) getNamespacesClient() coreclientset.NamespaceInterface {
0000000000000000000000000000000000000000;;		return config.f.ClientSet.Core().Namespaces()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CheckReachabilityFromPod(expectToBeReachable bool, timeout time.Duration, namespace, pod, target string) {
0000000000000000000000000000000000000000;;		cmd := fmt.Sprintf("wget -T 5 -qO- %q", target)
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(Poll, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			_, err := RunHostCmd(namespace, pod, cmd)
0000000000000000000000000000000000000000;;			if expectToBeReachable && err != nil {
0000000000000000000000000000000000000000;;				Logf("Expect target to be reachable. But got err: %v. Retry until timeout", err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !expectToBeReachable && err == nil {
0000000000000000000000000000000000000000;;				Logf("Expect target NOT to be reachable. But it is reachable. Retry until timeout")
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Does an HTTP GET, but does not reuse TCP connections
0000000000000000000000000000000000000000;;	// This masks problems where the iptables rule has changed, but we don't see it
0000000000000000000000000000000000000000;;	// This is intended for relatively quick requests (status checks), so we set a short (5 seconds) timeout
0000000000000000000000000000000000000000;;	func httpGetNoConnectionPool(url string) (*http.Response, error) {
0000000000000000000000000000000000000000;;		return httpGetNoConnectionPoolTimeout(url, 5*time.Second)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func httpGetNoConnectionPoolTimeout(url string, timeout time.Duration) (*http.Response, error) {
0000000000000000000000000000000000000000;;		tr := utilnet.SetTransportDefaults(&http.Transport{
0000000000000000000000000000000000000000;;			DisableKeepAlives: true,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		client := &http.Client{
0000000000000000000000000000000000000000;;			Transport: tr,
0000000000000000000000000000000000000000;;			Timeout:   timeout,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return client.Get(url)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReachableHTTP(ip string, port int, request string, expect string) (bool, error) {
0000000000000000000000000000000000000000;;		return TestReachableHTTPWithContent(ip, port, request, expect, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReachableHTTPWithContent(ip string, port int, request string, expect string, content *bytes.Buffer) (bool, error) {
0000000000000000000000000000000000000000;;		return TestReachableHTTPWithContentTimeout(ip, port, request, expect, content, 5*time.Second)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReachableHTTPWithContentTimeout(ip string, port int, request string, expect string, content *bytes.Buffer, timeout time.Duration) (bool, error) {
0000000000000000000000000000000000000000;;		url := fmt.Sprintf("http://%s:%d%s", ip, port, request)
0000000000000000000000000000000000000000;;		if ip == "" {
0000000000000000000000000000000000000000;;			Failf("Got empty IP for reachability check (%s)", url)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if port == 0 {
0000000000000000000000000000000000000000;;			Failf("Got port==0 for reachability check (%s)", url)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Logf("Testing HTTP reachability of %v", url)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := httpGetNoConnectionPoolTimeout(url, timeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Logf("Got error testing for reachability of %s: %v", url, err)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Logf("Got error reading response from %s: %v", url, err)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != 200 {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("received non-success return status %q trying to access %s; got body: %s",
0000000000000000000000000000000000000000;;				resp.Status, url, string(body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.Contains(string(body), expect) {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("received response body without expected substring %q: %s", expect, string(body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if content != nil {
0000000000000000000000000000000000000000;;			content.Write(body)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNotReachableHTTP(ip string, port int) (bool, error) {
0000000000000000000000000000000000000000;;		return TestNotReachableHTTPTimeout(ip, port, 5*time.Second)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNotReachableHTTPTimeout(ip string, port int, timeout time.Duration) (bool, error) {
0000000000000000000000000000000000000000;;		url := fmt.Sprintf("http://%s:%d", ip, port)
0000000000000000000000000000000000000000;;		if ip == "" {
0000000000000000000000000000000000000000;;			Failf("Got empty IP for non-reachability check (%s)", url)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if port == 0 {
0000000000000000000000000000000000000000;;			Failf("Got port==0 for non-reachability check (%s)", url)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Logf("Testing HTTP non-reachability of %v", url)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := httpGetNoConnectionPoolTimeout(url, timeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Logf("Confirmed that %s is not reachable", url)
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp.Body.Close()
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReachableUDP(ip string, port int, request string, expect string) (bool, error) {
0000000000000000000000000000000000000000;;		uri := fmt.Sprintf("udp://%s:%d", ip, port)
0000000000000000000000000000000000000000;;		if ip == "" {
0000000000000000000000000000000000000000;;			Failf("Got empty IP for reachability check (%s)", uri)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if port == 0 {
0000000000000000000000000000000000000000;;			Failf("Got port==0 for reachability check (%s)", uri)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Logf("Testing UDP reachability of %v", uri)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		con, err := net.Dial("udp", ip+":"+strconv.Itoa(port))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Failed to dial %s:%d: %v", ip, port, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = con.Write([]byte(fmt.Sprintf("%s\n", request)))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Failed to send request: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var buf []byte = make([]byte, len(expect)+1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = con.SetDeadline(time.Now().Add(3 * time.Second))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Failed to set deadline: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = con.Read(buf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !strings.Contains(string(buf), expect) {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Failed to retrieve %q, got %q", expect, string(buf))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Logf("Successfully reached %v", uri)
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNotReachableUDP(ip string, port int, request string) (bool, error) {
0000000000000000000000000000000000000000;;		uri := fmt.Sprintf("udp://%s:%d", ip, port)
0000000000000000000000000000000000000000;;		if ip == "" {
0000000000000000000000000000000000000000;;			Failf("Got empty IP for reachability check (%s)", uri)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if port == 0 {
0000000000000000000000000000000000000000;;			Failf("Got port==0 for reachability check (%s)", uri)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Logf("Testing UDP non-reachability of %v", uri)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		con, err := net.Dial("udp", ip+":"+strconv.Itoa(port))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Logf("Confirmed that %s is not reachable", uri)
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = con.Write([]byte(fmt.Sprintf("%s\n", request)))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Logf("Confirmed that %s is not reachable", uri)
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var buf []byte = make([]byte, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = con.SetDeadline(time.Now().Add(3 * time.Second))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Failed to set deadline: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = con.Read(buf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Logf("Confirmed that %s is not reachable", uri)
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHitNodesFromOutside(externalIP string, httpPort int32, timeout time.Duration, expectedHosts sets.String) error {
0000000000000000000000000000000000000000;;		return TestHitNodesFromOutsideWithCount(externalIP, httpPort, timeout, expectedHosts, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHitNodesFromOutsideWithCount(externalIP string, httpPort int32, timeout time.Duration, expectedHosts sets.String,
0000000000000000000000000000000000000000;;		countToSucceed int) error {
0000000000000000000000000000000000000000;;		Logf("Waiting up to %v for satisfying expectedHosts for %v times", timeout, countToSucceed)
0000000000000000000000000000000000000000;;		hittedHosts := sets.NewString()
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		condition := func() (bool, error) {
0000000000000000000000000000000000000000;;			var respBody bytes.Buffer
0000000000000000000000000000000000000000;;			reached, err := TestReachableHTTPWithContentTimeout(externalIP, int(httpPort), "/hostname", "", &respBody,
0000000000000000000000000000000000000000;;				1*time.Second)
0000000000000000000000000000000000000000;;			if err != nil || !reached {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hittedHost := strings.TrimSpace(respBody.String())
0000000000000000000000000000000000000000;;			if !expectedHosts.Has(hittedHost) {
0000000000000000000000000000000000000000;;				Logf("Error hitting unexpected host: %v, reset counter: %v", hittedHost, count)
0000000000000000000000000000000000000000;;				count = 0
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !hittedHosts.Has(hittedHost) {
0000000000000000000000000000000000000000;;				hittedHosts.Insert(hittedHost)
0000000000000000000000000000000000000000;;				Logf("Missing %+v, got %+v", expectedHosts.Difference(hittedHosts), hittedHosts)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hittedHosts.Equal(expectedHosts) {
0000000000000000000000000000000000000000;;				count++
0000000000000000000000000000000000000000;;				if count >= countToSucceed {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := wait.Poll(time.Second, timeout, condition); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error waiting for expectedHosts: %v, hittedHosts: %v, count: %v, expected count: %v",
0000000000000000000000000000000000000000;;				expectedHosts, hittedHosts, count, countToSucceed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Blocks outgoing network traffic on 'node'. Then runs testFunc and returns its status.
0000000000000000000000000000000000000000;;	// At the end (even in case of errors), the network traffic is brought back to normal.
0000000000000000000000000000000000000000;;	// This function executes commands on a node so it will work only for some
0000000000000000000000000000000000000000;;	// environments.
0000000000000000000000000000000000000000;;	func TestUnderTemporaryNetworkFailure(c clientset.Interface, ns string, node *v1.Node, testFunc func()) {
0000000000000000000000000000000000000000;;		host := GetNodeExternalIP(node)
0000000000000000000000000000000000000000;;		master := GetMasterAddress(c)
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("block network traffic from node %s to the master", node.Name))
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			// This code will execute even if setting the iptables rule failed.
0000000000000000000000000000000000000000;;			// It is on purpose because we may have an error even if the new rule
0000000000000000000000000000000000000000;;			// had been inserted. (yes, we could look at the error code and ssh error
0000000000000000000000000000000000000000;;			// separately, but I prefer to stay on the safe side).
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Unblock network traffic from node %s to the master", node.Name))
0000000000000000000000000000000000000000;;			UnblockNetwork(host, master)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Logf("Waiting %v to ensure node %s is ready before beginning test...", resizeNodeReadyTimeout, node.Name)
0000000000000000000000000000000000000000;;		if !WaitForNodeToBe(c, node.Name, v1.NodeReady, true, resizeNodeReadyTimeout) {
0000000000000000000000000000000000000000;;			Failf("Node %s did not become ready within %v", node.Name, resizeNodeReadyTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		BlockNetwork(host, master)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Logf("Waiting %v for node %s to be not ready after simulated network failure", resizeNodeNotReadyTimeout, node.Name)
0000000000000000000000000000000000000000;;		if !WaitForNodeToBe(c, node.Name, v1.NodeReady, false, resizeNodeNotReadyTimeout) {
0000000000000000000000000000000000000000;;			Failf("Node %s did not become not-ready within %v", node.Name, resizeNodeNotReadyTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testFunc()
0000000000000000000000000000000000000000;;		// network traffic is unblocked in a deferred function
0000000000000000000000000000000000000000;;	}
