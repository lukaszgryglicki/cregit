0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d8dbf90e49613d61555fc17d39c191d5b9f96571;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authorizationv1beta1 "k8s.io/api/authorization/v1beta1"
0000000000000000000000000000000000000000;;		rbacv1beta1 "k8s.io/api/rbac/v1beta1"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		v1beta1authorization "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/authorization/v1beta1"
0000000000000000000000000000000000000000;;		v1beta1rbac "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/rbac/v1beta1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		policyCachePollInterval = 100 * time.Millisecond
0000000000000000000000000000000000000000;;		policyCachePollTimeout  = 5 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForAuthorizationUpdate checks if the given user can perform the named verb and action.
0000000000000000000000000000000000000000;;	// If policyCachePollTimeout is reached without the expected condition matching, an error is returned
0000000000000000000000000000000000000000;;	func WaitForAuthorizationUpdate(c v1beta1authorization.SubjectAccessReviewsGetter, user, namespace, verb string, resource schema.GroupResource, allowed bool) error {
0000000000000000000000000000000000000000;;		review := &authorizationv1beta1.SubjectAccessReview{
0000000000000000000000000000000000000000;;			Spec: authorizationv1beta1.SubjectAccessReviewSpec{
0000000000000000000000000000000000000000;;				ResourceAttributes: &authorizationv1beta1.ResourceAttributes{
0000000000000000000000000000000000000000;;					Group:     resource.Group,
0000000000000000000000000000000000000000;;					Verb:      verb,
0000000000000000000000000000000000000000;;					Resource:  resource.Resource,
0000000000000000000000000000000000000000;;					Namespace: namespace,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				User: user,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := wait.Poll(policyCachePollInterval, policyCachePollTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			response, err := c.SubjectAccessReviews().Create(review)
0000000000000000000000000000000000000000;;			// GKE doesn't enable the SAR endpoint.  Without this endpoint, we cannot determine if the policy engine
0000000000000000000000000000000000000000;;			// has adjusted as expected.  In this case, simply wait one second and hope it's up to date
0000000000000000000000000000000000000000;;			if apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				fmt.Printf("SubjectAccessReview endpoint is missing\n")
0000000000000000000000000000000000000000;;				time.Sleep(1 * time.Second)
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if response.Status.Allowed != allowed {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BindClusterRole binds the cluster role at the cluster scope
0000000000000000000000000000000000000000;;	func BindClusterRole(c v1beta1rbac.ClusterRoleBindingsGetter, clusterRole, ns string, subjects ...rbacv1beta1.Subject) {
0000000000000000000000000000000000000000;;		// Since the namespace names are unique, we can leave this lying around so we don't have to race any caches
0000000000000000000000000000000000000000;;		_, err := c.ClusterRoleBindings().Create(&rbacv1beta1.ClusterRoleBinding{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: ns + "--" + clusterRole,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			RoleRef: rbacv1beta1.RoleRef{
0000000000000000000000000000000000000000;;				APIGroup: "rbac.authorization.k8s.io",
0000000000000000000000000000000000000000;;				Kind:     "ClusterRole",
0000000000000000000000000000000000000000;;				Name:     clusterRole,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subjects: subjects,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we failed, don't fail the entire test because it may still work. RBAC may simply be disabled.
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Printf("Error binding clusterrole/%s for %q for %v\n", clusterRole, ns, subjects)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BindClusterRoleInNamespace binds the cluster role at the namespace scope
0000000000000000000000000000000000000000;;	func BindClusterRoleInNamespace(c v1beta1rbac.RoleBindingsGetter, clusterRole, ns string, subjects ...rbacv1beta1.Subject) {
0000000000000000000000000000000000000000;;		// Since the namespace names are unique, we can leave this lying around so we don't have to race any caches
0000000000000000000000000000000000000000;;		_, err := c.RoleBindings(ns).Create(&rbacv1beta1.RoleBinding{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: ns + "--" + clusterRole,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			RoleRef: rbacv1beta1.RoleRef{
0000000000000000000000000000000000000000;;				APIGroup: "rbac.authorization.k8s.io",
0000000000000000000000000000000000000000;;				Kind:     "ClusterRole",
0000000000000000000000000000000000000000;;				Name:     clusterRole,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subjects: subjects,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we failed, don't fail the entire test because it may still work. RBAC may simply be disabled.
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Printf("Error binding clusterrole/%s into %q for %v\n", clusterRole, ns, subjects)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
