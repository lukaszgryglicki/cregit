0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
d131de474cdc096e91b62dc77d478efd2c177420;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func EtcdUpgrade(target_storage, target_version string) error {
0000000000000000000000000000000000000000;;		switch TestContext.Provider {
0000000000000000000000000000000000000000;;		case "gce":
0000000000000000000000000000000000000000;;			return etcdUpgradeGCE(target_storage, target_version)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("EtcdUpgrade() is not implemented for provider %s", TestContext.Provider)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MasterUpgrade(v string) error {
0000000000000000000000000000000000000000;;		switch TestContext.Provider {
0000000000000000000000000000000000000000;;		case "gce":
0000000000000000000000000000000000000000;;			return masterUpgradeGCE(v)
0000000000000000000000000000000000000000;;		case "gke":
0000000000000000000000000000000000000000;;			return masterUpgradeGKE(v)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("MasterUpgrade() is not implemented for provider %s", TestContext.Provider)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func etcdUpgradeGCE(target_storage, target_version string) error {
0000000000000000000000000000000000000000;;		env := append(
0000000000000000000000000000000000000000;;			os.Environ(),
0000000000000000000000000000000000000000;;			"TEST_ETCD_VERSION="+target_version,
0000000000000000000000000000000000000000;;			"STORAGE_BACKEND="+target_storage,
0000000000000000000000000000000000000000;;			"TEST_ETCD_IMAGE=3.0.17")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, _, err := RunCmdEnv(env, gceUpgradeScript(), "-l", "-M")
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func masterUpgradeGCE(rawV string) error {
0000000000000000000000000000000000000000;;		env := os.Environ()
0000000000000000000000000000000000000000;;		// TODO: Remove these variables when they're no longer needed for downgrades.
0000000000000000000000000000000000000000;;		if TestContext.EtcdUpgradeVersion != "" && TestContext.EtcdUpgradeStorage != "" {
0000000000000000000000000000000000000000;;			env = append(env,
0000000000000000000000000000000000000000;;				"TEST_ETCD_VERSION="+TestContext.EtcdUpgradeVersion,
0000000000000000000000000000000000000000;;				"STORAGE_BACKEND="+TestContext.EtcdUpgradeStorage,
0000000000000000000000000000000000000000;;				"TEST_ETCD_IMAGE=3.0.17")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v := "v" + rawV
0000000000000000000000000000000000000000;;		_, _, err := RunCmdEnv(env, gceUpgradeScript(), "-M", v)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func masterUpgradeGKE(v string) error {
0000000000000000000000000000000000000000;;		Logf("Upgrading master to %q", v)
0000000000000000000000000000000000000000;;		_, _, err := RunCmd("gcloud", "container",
0000000000000000000000000000000000000000;;			"clusters",
0000000000000000000000000000000000000000;;			fmt.Sprintf("--project=%s", TestContext.CloudConfig.ProjectID),
0000000000000000000000000000000000000000;;			fmt.Sprintf("--zone=%s", TestContext.CloudConfig.Zone),
0000000000000000000000000000000000000000;;			"upgrade",
0000000000000000000000000000000000000000;;			TestContext.CloudConfig.Cluster,
0000000000000000000000000000000000000000;;			"--master",
0000000000000000000000000000000000000000;;			fmt.Sprintf("--cluster-version=%s", v),
0000000000000000000000000000000000000000;;			"--quiet")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitForSSHTunnels()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NodeUpgrade(f *Framework, v string, img string) error {
0000000000000000000000000000000000000000;;		// Perform the upgrade.
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		switch TestContext.Provider {
0000000000000000000000000000000000000000;;		case "gce":
0000000000000000000000000000000000000000;;			err = nodeUpgradeGCE(v, img)
0000000000000000000000000000000000000000;;		case "gke":
0000000000000000000000000000000000000000;;			err = nodeUpgradeGKE(v, img)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = fmt.Errorf("NodeUpgrade() is not implemented for provider %s", TestContext.Provider)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for it to complete and validate nodes are healthy.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// TODO(ihmccreery) We shouldn't have to wait for nodes to be ready in
0000000000000000000000000000000000000000;;		// GKE; the operation shouldn't return until they all are.
0000000000000000000000000000000000000000;;		Logf("Waiting up to %v for all nodes to be ready after the upgrade", RestartNodeReadyAgainTimeout)
0000000000000000000000000000000000000000;;		if _, err := CheckNodesReady(f.ClientSet, RestartNodeReadyAgainTimeout, TestContext.CloudConfig.NumNodes); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nodeUpgradeGCE(rawV, img string) error {
0000000000000000000000000000000000000000;;		v := "v" + rawV
0000000000000000000000000000000000000000;;		if img != "" {
0000000000000000000000000000000000000000;;			env := append(os.Environ(), "KUBE_NODE_OS_DISTRIBUTION="+img)
0000000000000000000000000000000000000000;;			_, _, err := RunCmdEnv(env, gceUpgradeScript(), "-N", "-o", v)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, _, err := RunCmd(gceUpgradeScript(), "-N", v)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nodeUpgradeGKE(v string, img string) error {
0000000000000000000000000000000000000000;;		Logf("Upgrading nodes to version %q and image %q", v, img)
0000000000000000000000000000000000000000;;		args := []string{
0000000000000000000000000000000000000000;;			"container",
0000000000000000000000000000000000000000;;			"clusters",
0000000000000000000000000000000000000000;;			fmt.Sprintf("--project=%s", TestContext.CloudConfig.ProjectID),
0000000000000000000000000000000000000000;;			fmt.Sprintf("--zone=%s", TestContext.CloudConfig.Zone),
0000000000000000000000000000000000000000;;			"upgrade",
0000000000000000000000000000000000000000;;			TestContext.CloudConfig.Cluster,
0000000000000000000000000000000000000000;;			fmt.Sprintf("--cluster-version=%s", v),
0000000000000000000000000000000000000000;;			"--quiet",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(img) > 0 {
0000000000000000000000000000000000000000;;			args = append(args, fmt.Sprintf("--image-type=%s", img))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, _, err := RunCmd("gcloud", args...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitForSSHTunnels()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckNodesReady waits up to nt for expect nodes accessed by c to be ready,
0000000000000000000000000000000000000000;;	// returning an error if this doesn't happen in time. It returns the names of
0000000000000000000000000000000000000000;;	// nodes it finds.
0000000000000000000000000000000000000000;;	func CheckNodesReady(c clientset.Interface, nt time.Duration, expect int) ([]string, error) {
0000000000000000000000000000000000000000;;		// First, keep getting all of the nodes until we get the number we expect.
0000000000000000000000000000000000000000;;		var nodeList *v1.NodeList
0000000000000000000000000000000000000000;;		var errLast error
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;		found := wait.Poll(Poll, nt, func() (bool, error) {
0000000000000000000000000000000000000000;;			// A rolling-update (GCE/GKE implementation of restart) can complete before the apiserver
0000000000000000000000000000000000000000;;			// knows about all of the nodes. Thus, we retry the list nodes call
0000000000000000000000000000000000000000;;			// until we get the expected number of nodes.
0000000000000000000000000000000000000000;;			nodeList, errLast = c.Core().Nodes().List(metav1.ListOptions{
0000000000000000000000000000000000000000;;				FieldSelector: fields.Set{"spec.unschedulable": "false"}.AsSelector().String()})
0000000000000000000000000000000000000000;;			if errLast != nil {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(nodeList.Items) != expect {
0000000000000000000000000000000000000000;;				errLast = fmt.Errorf("expected to find %d nodes but found only %d (%v elapsed)",
0000000000000000000000000000000000000000;;					expect, len(nodeList.Items), time.Since(start))
0000000000000000000000000000000000000000;;				Logf("%v", errLast)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}) == nil
0000000000000000000000000000000000000000;;		nodeNames := make([]string, len(nodeList.Items))
0000000000000000000000000000000000000000;;		for i, n := range nodeList.Items {
0000000000000000000000000000000000000000;;			nodeNames[i] = n.ObjectMeta.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return nodeNames, fmt.Errorf("couldn't find %d nodes within %v; last error: %v",
0000000000000000000000000000000000000000;;				expect, nt, errLast)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Logf("Successfully found %d nodes", expect)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Next, ensure in parallel that all the nodes are ready. We subtract the
0000000000000000000000000000000000000000;;		// time we spent waiting above.
0000000000000000000000000000000000000000;;		timeout := nt - time.Since(start)
0000000000000000000000000000000000000000;;		result := make(chan bool, len(nodeList.Items))
0000000000000000000000000000000000000000;;		for _, n := range nodeNames {
0000000000000000000000000000000000000000;;			n := n
0000000000000000000000000000000000000000;;			go func() { result <- WaitForNodeToBeReady(c, n, timeout) }()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		failed := false
0000000000000000000000000000000000000000;;		// TODO(mbforbes): Change to `for range` syntax once we support only Go
0000000000000000000000000000000000000000;;		// >= 1.4.
0000000000000000000000000000000000000000;;		for i := range nodeList.Items {
0000000000000000000000000000000000000000;;			_ = i
0000000000000000000000000000000000000000;;			if !<-result {
0000000000000000000000000000000000000000;;				failed = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if failed {
0000000000000000000000000000000000000000;;			return nodeNames, fmt.Errorf("at least one node failed to be ready")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodeNames, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MigTemplate (GCE-only) returns the name of the MIG template that the
0000000000000000000000000000000000000000;;	// nodes of the cluster use.
0000000000000000000000000000000000000000;;	func MigTemplate() (string, error) {
0000000000000000000000000000000000000000;;		var errLast error
0000000000000000000000000000000000000000;;		var templ string
0000000000000000000000000000000000000000;;		key := "instanceTemplate"
0000000000000000000000000000000000000000;;		if wait.Poll(Poll, SingleCallTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			// TODO(mikedanese): make this hit the compute API directly instead of
0000000000000000000000000000000000000000;;			// shelling out to gcloud.
0000000000000000000000000000000000000000;;			// An `instance-groups managed describe` call outputs what we want to stdout.
0000000000000000000000000000000000000000;;			output, _, err := retryCmd("gcloud", "compute", "instance-groups", "managed",
0000000000000000000000000000000000000000;;				fmt.Sprintf("--project=%s", TestContext.CloudConfig.ProjectID),
0000000000000000000000000000000000000000;;				"describe",
0000000000000000000000000000000000000000;;				fmt.Sprintf("--zone=%s", TestContext.CloudConfig.Zone),
0000000000000000000000000000000000000000;;				TestContext.CloudConfig.NodeInstanceGroup)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errLast = fmt.Errorf("gcloud compute instance-groups managed describe call failed with err: %v", err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// The 'describe' call probably succeeded; parse the output and try to
0000000000000000000000000000000000000000;;			// find the line that looks like "instanceTemplate: url/to/<templ>" and
0000000000000000000000000000000000000000;;			// return <templ>.
0000000000000000000000000000000000000000;;			if val := ParseKVLines(output, key); len(val) > 0 {
0000000000000000000000000000000000000000;;				url := strings.Split(val, "/")
0000000000000000000000000000000000000000;;				templ = url[len(url)-1]
0000000000000000000000000000000000000000;;				Logf("MIG group %s using template: %s", TestContext.CloudConfig.NodeInstanceGroup, templ)
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			errLast = fmt.Errorf("couldn't find %s in output to get MIG template. Output: %s", key, output)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}) != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("MigTemplate() failed with last error: %v", errLast)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return templ, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func gceUpgradeScript() string {
0000000000000000000000000000000000000000;;		if len(TestContext.GCEUpgradeScript) == 0 {
0000000000000000000000000000000000000000;;			return path.Join(TestContext.RepoRoot, "cluster/gce/upgrade.sh")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return TestContext.GCEUpgradeScript
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForSSHTunnels() {
0000000000000000000000000000000000000000;;		Logf("Waiting for SSH tunnels to establish")
0000000000000000000000000000000000000000;;		RunKubectl("run", "ssh-tunnel-test",
0000000000000000000000000000000000000000;;			"--image=gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;			"--restart=Never",
0000000000000000000000000000000000000000;;			"--command", "--",
0000000000000000000000000000000000000000;;			"echo", "Hello")
0000000000000000000000000000000000000000;;		defer RunKubectl("delete", "pod", "ssh-tunnel-test")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// allow up to a minute for new ssh tunnels to establish
0000000000000000000000000000000000000000;;		wait.PollImmediate(5*time.Second, time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			_, err := RunKubectl("logs", "ssh-tunnel-test")
0000000000000000000000000000000000000000;;			return err == nil, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
