0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
810a417105a8828955f09d5acf88ce810cfc0826;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		policyv1beta1 "k8s.io/api/policy/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/retry"
0000000000000000000000000000000000000000;;		testutils "k8s.io/kubernetes/test/utils"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// KubeProxyLagTimeout is the maximum time a kube-proxy daemon on a node is allowed
0000000000000000000000000000000000000000;;		// to not notice a Service update, such as type=NodePort.
0000000000000000000000000000000000000000;;		// TODO: This timeout should be O(10s), observed values are O(1m), 5m is very
0000000000000000000000000000000000000000;;		// liberal. Fix tracked in #20567.
0000000000000000000000000000000000000000;;		KubeProxyLagTimeout = 5 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// KubeProxyEndpointLagTimeout is the maximum time a kube-proxy daemon on a node is allowed
0000000000000000000000000000000000000000;;		// to not notice an Endpoint update.
0000000000000000000000000000000000000000;;		KubeProxyEndpointLagTimeout = 30 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// LoadBalancerLagTimeoutDefault is the maximum time a load balancer is allowed to
0000000000000000000000000000000000000000;;		// not respond after creation.
0000000000000000000000000000000000000000;;		LoadBalancerLagTimeoutDefault = 2 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// LoadBalancerLagTimeoutAWS is the delay between ELB creation and serving traffic
0000000000000000000000000000000000000000;;		// on AWS. A few minutes is typical, so use 10m.
0000000000000000000000000000000000000000;;		LoadBalancerLagTimeoutAWS = 10 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// How long to wait for a load balancer to be created/modified.
0000000000000000000000000000000000000000;;		//TODO: once support ticket 21807001 is resolved, reduce this timeout back to something reasonable
0000000000000000000000000000000000000000;;		LoadBalancerCreateTimeoutDefault = 20 * time.Minute
0000000000000000000000000000000000000000;;		LoadBalancerCreateTimeoutLarge   = 2 * time.Hour
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Time required by the loadbalancer to cleanup, proportional to numApps/Ing.
0000000000000000000000000000000000000000;;		// Bring the cleanup timeout back down to 5m once b/33588344 is resolved.
0000000000000000000000000000000000000000;;		LoadBalancerCleanupTimeout = 15 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// On average it takes ~6 minutes for a single backend to come online in GCE.
0000000000000000000000000000000000000000;;		LoadBalancerPollTimeout  = 15 * time.Minute
0000000000000000000000000000000000000000;;		LoadBalancerPollInterval = 30 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		LargeClusterMinNodesNumber = 100
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Don't test with more than 3 nodes.
0000000000000000000000000000000000000000;;		// Many tests create an endpoint per node, in large clusters, this is
0000000000000000000000000000000000000000;;		// resource and time intensive.
0000000000000000000000000000000000000000;;		MaxNodesForEndpointsTests = 3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServiceTestTimeout is used for most polling/waiting activities
0000000000000000000000000000000000000000;;		ServiceTestTimeout = 60 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This should match whatever the default/configured range is
0000000000000000000000000000000000000000;;	var ServiceNodePortRange = utilnet.PortRange{Base: 30000, Size: 2768}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A test jig to help service testing.
0000000000000000000000000000000000000000;;	type ServiceTestJig struct {
0000000000000000000000000000000000000000;;		ID     string
0000000000000000000000000000000000000000;;		Name   string
0000000000000000000000000000000000000000;;		Client clientset.Interface
0000000000000000000000000000000000000000;;		Labels map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServiceTestJig allocates and inits a new ServiceTestJig.
0000000000000000000000000000000000000000;;	func NewServiceTestJig(client clientset.Interface, name string) *ServiceTestJig {
0000000000000000000000000000000000000000;;		j := &ServiceTestJig{}
0000000000000000000000000000000000000000;;		j.Client = client
0000000000000000000000000000000000000000;;		j.Name = name
0000000000000000000000000000000000000000;;		j.ID = j.Name + "-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;		j.Labels = map[string]string{"testid": j.ID}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return j
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newServiceTemplate returns the default v1.Service template for this jig, but
0000000000000000000000000000000000000000;;	// does not actually create the Service.  The default Service has the same name
0000000000000000000000000000000000000000;;	// as the jig and exposes the given port.
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) newServiceTemplate(namespace string, proto v1.Protocol, port int32) *v1.Service {
0000000000000000000000000000000000000000;;		service := &v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Name:      j.Name,
0000000000000000000000000000000000000000;;				Labels:    j.Labels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: j.Labels,
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Protocol: proto,
0000000000000000000000000000000000000000;;						Port:     port,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return service
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateTCPServiceWithPort creates a new TCP Service with given port based on the
0000000000000000000000000000000000000000;;	// jig's defaults. Callers can provide a function to tweak the Service object before
0000000000000000000000000000000000000000;;	// it is created.
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) CreateTCPServiceWithPort(namespace string, tweak func(svc *v1.Service), port int32) *v1.Service {
0000000000000000000000000000000000000000;;		svc := j.newServiceTemplate(namespace, v1.ProtocolTCP, port)
0000000000000000000000000000000000000000;;		if tweak != nil {
0000000000000000000000000000000000000000;;			tweak(svc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result, err := j.Client.Core().Services(namespace).Create(svc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("Failed to create TCP Service %q: %v", svc.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateTCPServiceOrFail creates a new TCP Service based on the jig's
0000000000000000000000000000000000000000;;	// defaults.  Callers can provide a function to tweak the Service object before
0000000000000000000000000000000000000000;;	// it is created.
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) CreateTCPServiceOrFail(namespace string, tweak func(svc *v1.Service)) *v1.Service {
0000000000000000000000000000000000000000;;		svc := j.newServiceTemplate(namespace, v1.ProtocolTCP, 80)
0000000000000000000000000000000000000000;;		if tweak != nil {
0000000000000000000000000000000000000000;;			tweak(svc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result, err := j.Client.Core().Services(namespace).Create(svc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("Failed to create TCP Service %q: %v", svc.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateUDPServiceOrFail creates a new UDP Service based on the jig's
0000000000000000000000000000000000000000;;	// defaults.  Callers can provide a function to tweak the Service object before
0000000000000000000000000000000000000000;;	// it is created.
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) CreateUDPServiceOrFail(namespace string, tweak func(svc *v1.Service)) *v1.Service {
0000000000000000000000000000000000000000;;		svc := j.newServiceTemplate(namespace, v1.ProtocolUDP, 80)
0000000000000000000000000000000000000000;;		if tweak != nil {
0000000000000000000000000000000000000000;;			tweak(svc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result, err := j.Client.Core().Services(namespace).Create(svc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("Failed to create UDP Service %q: %v", svc.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateExternalNameServiceOrFail creates a new ExternalName type Service based on the jig's defaults.
0000000000000000000000000000000000000000;;	// Callers can provide a function to tweak the Service object before it is created.
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) CreateExternalNameServiceOrFail(namespace string, tweak func(svc *v1.Service)) *v1.Service {
0000000000000000000000000000000000000000;;		svc := &v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Name:      j.Name,
0000000000000000000000000000000000000000;;				Labels:    j.Labels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:     j.Labels,
0000000000000000000000000000000000000000;;				ExternalName: "foo.example.com",
0000000000000000000000000000000000000000;;				Type:         v1.ServiceTypeExternalName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tweak != nil {
0000000000000000000000000000000000000000;;			tweak(svc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result, err := j.Client.Core().Services(namespace).Create(svc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("Failed to create ExternalName Service %q: %v", svc.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) ChangeServiceType(namespace, name string, newType v1.ServiceType, timeout time.Duration) {
0000000000000000000000000000000000000000;;		ingressIP := ""
0000000000000000000000000000000000000000;;		svc := j.UpdateServiceOrFail(namespace, name, func(s *v1.Service) {
0000000000000000000000000000000000000000;;			for _, ing := range s.Status.LoadBalancer.Ingress {
0000000000000000000000000000000000000000;;				if ing.IP != "" {
0000000000000000000000000000000000000000;;					ingressIP = ing.IP
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.Spec.Type = newType
0000000000000000000000000000000000000000;;			s.Spec.Ports[0].NodePort = 0
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if ingressIP != "" {
0000000000000000000000000000000000000000;;			j.WaitForLoadBalancerDestroyOrFail(namespace, svc.Name, ingressIP, int(svc.Spec.Ports[0].Port), timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateOnlyLocalNodePortService creates a NodePort service with
0000000000000000000000000000000000000000;;	// ExternalTrafficPolicy set to Local and sanity checks its nodePort.
0000000000000000000000000000000000000000;;	// If createPod is true, it also creates an RC with 1 replica of
0000000000000000000000000000000000000000;;	// the standard netexec container used everywhere in this test.
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) CreateOnlyLocalNodePortService(namespace, serviceName string, createPod bool) *v1.Service {
0000000000000000000000000000000000000000;;		By("creating a service " + namespace + "/" + serviceName + " with type=NodePort and ExternalTrafficPolicy=Local")
0000000000000000000000000000000000000000;;		svc := j.CreateTCPServiceOrFail(namespace, func(svc *v1.Service) {
0000000000000000000000000000000000000000;;			svc.Spec.Type = v1.ServiceTypeNodePort
0000000000000000000000000000000000000000;;			svc.Spec.ExternalTrafficPolicy = v1.ServiceExternalTrafficPolicyTypeLocal
0000000000000000000000000000000000000000;;			svc.Spec.Ports = []v1.ServicePort{{Protocol: "TCP", Port: 80}}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if createPod {
0000000000000000000000000000000000000000;;			By("creating a pod to be part of the service " + serviceName)
0000000000000000000000000000000000000000;;			j.RunOrFail(namespace, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		j.SanityCheckService(svc, v1.ServiceTypeNodePort)
0000000000000000000000000000000000000000;;		return svc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateOnlyLocalLoadBalancerService creates a loadbalancer service with
0000000000000000000000000000000000000000;;	// ExternalTrafficPolicy set to Local and waits for it to acquire an ingress IP.
0000000000000000000000000000000000000000;;	// If createPod is true, it also creates an RC with 1 replica of
0000000000000000000000000000000000000000;;	// the standard netexec container used everywhere in this test.
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) CreateOnlyLocalLoadBalancerService(namespace, serviceName string, timeout time.Duration, createPod bool,
0000000000000000000000000000000000000000;;		tweak func(svc *v1.Service)) *v1.Service {
0000000000000000000000000000000000000000;;		By("creating a service " + namespace + "/" + serviceName + " with type=LoadBalancer and ExternalTrafficPolicy=Local")
0000000000000000000000000000000000000000;;		svc := j.CreateTCPServiceOrFail(namespace, func(svc *v1.Service) {
0000000000000000000000000000000000000000;;			svc.Spec.Type = v1.ServiceTypeLoadBalancer
0000000000000000000000000000000000000000;;			// We need to turn affinity off for our LB distribution tests
0000000000000000000000000000000000000000;;			svc.Spec.SessionAffinity = v1.ServiceAffinityNone
0000000000000000000000000000000000000000;;			svc.Spec.ExternalTrafficPolicy = v1.ServiceExternalTrafficPolicyTypeLocal
0000000000000000000000000000000000000000;;			if tweak != nil {
0000000000000000000000000000000000000000;;				tweak(svc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if createPod {
0000000000000000000000000000000000000000;;			By("creating a pod to be part of the service " + serviceName)
0000000000000000000000000000000000000000;;			j.RunOrFail(namespace, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		By("waiting for loadbalancer for service " + namespace + "/" + serviceName)
0000000000000000000000000000000000000000;;		svc = j.WaitForLoadBalancerOrFail(namespace, serviceName, timeout)
0000000000000000000000000000000000000000;;		j.SanityCheckService(svc, v1.ServiceTypeLoadBalancer)
0000000000000000000000000000000000000000;;		return svc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateLoadBalancerService creates a loadbalancer service and waits
0000000000000000000000000000000000000000;;	// for it to acquire an ingress IP.
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) CreateLoadBalancerService(namespace, serviceName string, timeout time.Duration, tweak func(svc *v1.Service)) *v1.Service {
0000000000000000000000000000000000000000;;		By("creating a service " + namespace + "/" + serviceName + " with type=LoadBalancer")
0000000000000000000000000000000000000000;;		svc := j.CreateTCPServiceOrFail(namespace, func(svc *v1.Service) {
0000000000000000000000000000000000000000;;			svc.Spec.Type = v1.ServiceTypeLoadBalancer
0000000000000000000000000000000000000000;;			// We need to turn affinity off for our LB distribution tests
0000000000000000000000000000000000000000;;			svc.Spec.SessionAffinity = v1.ServiceAffinityNone
0000000000000000000000000000000000000000;;			if tweak != nil {
0000000000000000000000000000000000000000;;				tweak(svc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("waiting for loadbalancer for service " + namespace + "/" + serviceName)
0000000000000000000000000000000000000000;;		svc = j.WaitForLoadBalancerOrFail(namespace, serviceName, timeout)
0000000000000000000000000000000000000000;;		j.SanityCheckService(svc, v1.ServiceTypeLoadBalancer)
0000000000000000000000000000000000000000;;		return svc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetNodeAddresses(node *v1.Node, addressType v1.NodeAddressType) (ips []string) {
0000000000000000000000000000000000000000;;		for j := range node.Status.Addresses {
0000000000000000000000000000000000000000;;			nodeAddress := &node.Status.Addresses[j]
0000000000000000000000000000000000000000;;			if nodeAddress.Type == addressType {
0000000000000000000000000000000000000000;;				ips = append(ips, nodeAddress.Address)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CollectAddresses(nodes *v1.NodeList, addressType v1.NodeAddressType) []string {
0000000000000000000000000000000000000000;;		ips := []string{}
0000000000000000000000000000000000000000;;		for i := range nodes.Items {
0000000000000000000000000000000000000000;;			ips = append(ips, GetNodeAddresses(&nodes.Items[i], addressType)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ips
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetNodePublicIps(c clientset.Interface) ([]string, error) {
0000000000000000000000000000000000000000;;		nodes := GetReadySchedulableNodesOrDie(c)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ips := CollectAddresses(nodes, v1.NodeExternalIP)
0000000000000000000000000000000000000000;;		return ips, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PickNodeIP(c clientset.Interface) string {
0000000000000000000000000000000000000000;;		publicIps, err := GetNodePublicIps(c)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		if len(publicIps) == 0 {
0000000000000000000000000000000000000000;;			Failf("got unexpected number (%d) of public IPs", len(publicIps))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ip := publicIps[0]
0000000000000000000000000000000000000000;;		return ip
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetEndpointNodes returns a map of nodenames:external-ip on which the
0000000000000000000000000000000000000000;;	// endpoints of the given Service are running.
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) GetEndpointNodes(svc *v1.Service) map[string][]string {
0000000000000000000000000000000000000000;;		nodes := j.GetNodes(MaxNodesForEndpointsTests)
0000000000000000000000000000000000000000;;		endpoints, err := j.Client.Core().Endpoints(svc.Namespace).Get(svc.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("Get endpoints for service %s/%s failed (%s)", svc.Namespace, svc.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(endpoints.Subsets) == 0 {
0000000000000000000000000000000000000000;;			Failf("Endpoint has no subsets, cannot determine node addresses.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		epNodes := sets.NewString()
0000000000000000000000000000000000000000;;		for _, ss := range endpoints.Subsets {
0000000000000000000000000000000000000000;;			for _, e := range ss.Addresses {
0000000000000000000000000000000000000000;;				if e.NodeName != nil {
0000000000000000000000000000000000000000;;					epNodes.Insert(*e.NodeName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeMap := map[string][]string{}
0000000000000000000000000000000000000000;;		for _, n := range nodes.Items {
0000000000000000000000000000000000000000;;			if epNodes.Has(n.Name) {
0000000000000000000000000000000000000000;;				nodeMap[n.Name] = GetNodeAddresses(&n, v1.NodeExternalIP)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodeMap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getNodes returns the first maxNodesForTest nodes. Useful in large clusters
0000000000000000000000000000000000000000;;	// where we don't eg: want to create an endpoint per node.
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) GetNodes(maxNodesForTest int) (nodes *v1.NodeList) {
0000000000000000000000000000000000000000;;		nodes = GetReadySchedulableNodesOrDie(j.Client)
0000000000000000000000000000000000000000;;		if len(nodes.Items) <= maxNodesForTest {
0000000000000000000000000000000000000000;;			maxNodesForTest = len(nodes.Items)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodes.Items = nodes.Items[:maxNodesForTest]
0000000000000000000000000000000000000000;;		return nodes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) GetNodesNames(maxNodesForTest int) []string {
0000000000000000000000000000000000000000;;		nodes := j.GetNodes(maxNodesForTest)
0000000000000000000000000000000000000000;;		nodesNames := []string{}
0000000000000000000000000000000000000000;;		for _, node := range nodes.Items {
0000000000000000000000000000000000000000;;			nodesNames = append(nodesNames, node.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodesNames
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) WaitForEndpointOnNode(namespace, serviceName, nodeName string) {
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(Poll, LoadBalancerCreateTimeoutDefault, func() (bool, error) {
0000000000000000000000000000000000000000;;			endpoints, err := j.Client.Core().Endpoints(namespace).Get(serviceName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				Logf("Get endpoints for service %s/%s failed (%s)", namespace, serviceName, err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(endpoints.Subsets) == 0 {
0000000000000000000000000000000000000000;;				Logf("Expect endpoints with subsets, got none.")
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: Handle multiple endpoints
0000000000000000000000000000000000000000;;			if len(endpoints.Subsets[0].Addresses) == 0 {
0000000000000000000000000000000000000000;;				Logf("Expected Ready endpoints - found none")
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			epHostName := *endpoints.Subsets[0].Addresses[0].NodeName
0000000000000000000000000000000000000000;;			Logf("Pod for service %s/%s is on node %s", namespace, serviceName, epHostName)
0000000000000000000000000000000000000000;;			if epHostName != nodeName {
0000000000000000000000000000000000000000;;				Logf("Found endpoint on wrong node, expected %v, got %v", nodeName, epHostName)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		ExpectNoError(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) SanityCheckService(svc *v1.Service, svcType v1.ServiceType) {
0000000000000000000000000000000000000000;;		if svc.Spec.Type != svcType {
0000000000000000000000000000000000000000;;			Failf("unexpected Spec.Type (%s) for service, expected %s", svc.Spec.Type, svcType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if svcType != v1.ServiceTypeExternalName {
0000000000000000000000000000000000000000;;			if svc.Spec.ExternalName != "" {
0000000000000000000000000000000000000000;;				Failf("unexpected Spec.ExternalName (%s) for service, expected empty", svc.Spec.ExternalName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if svc.Spec.ClusterIP != api.ClusterIPNone && svc.Spec.ClusterIP == "" {
0000000000000000000000000000000000000000;;				Failf("didn't get ClusterIP for non-ExternamName service")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if svc.Spec.ClusterIP != "" {
0000000000000000000000000000000000000000;;				Failf("unexpected Spec.ClusterIP (%s) for ExternamName service, expected empty", svc.Spec.ClusterIP)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectNodePorts := false
0000000000000000000000000000000000000000;;		if svcType != v1.ServiceTypeClusterIP && svcType != v1.ServiceTypeExternalName {
0000000000000000000000000000000000000000;;			expectNodePorts = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, port := range svc.Spec.Ports {
0000000000000000000000000000000000000000;;			hasNodePort := (port.NodePort != 0)
0000000000000000000000000000000000000000;;			if hasNodePort != expectNodePorts {
0000000000000000000000000000000000000000;;				Failf("unexpected Spec.Ports[%d].NodePort (%d) for service", i, port.NodePort)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hasNodePort {
0000000000000000000000000000000000000000;;				if !ServiceNodePortRange.Contains(int(port.NodePort)) {
0000000000000000000000000000000000000000;;					Failf("out-of-range nodePort (%d) for service", port.NodePort)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectIngress := false
0000000000000000000000000000000000000000;;		if svcType == v1.ServiceTypeLoadBalancer {
0000000000000000000000000000000000000000;;			expectIngress = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hasIngress := len(svc.Status.LoadBalancer.Ingress) != 0
0000000000000000000000000000000000000000;;		if hasIngress != expectIngress {
0000000000000000000000000000000000000000;;			Failf("unexpected number of Status.LoadBalancer.Ingress (%d) for service", len(svc.Status.LoadBalancer.Ingress))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasIngress {
0000000000000000000000000000000000000000;;			for i, ing := range svc.Status.LoadBalancer.Ingress {
0000000000000000000000000000000000000000;;				if ing.IP == "" && ing.Hostname == "" {
0000000000000000000000000000000000000000;;					Failf("unexpected Status.LoadBalancer.Ingress[%d] for service: %#v", i, ing)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateService fetches a service, calls the update function on it, and
0000000000000000000000000000000000000000;;	// then attempts to send the updated service. It tries up to 3 times in the
0000000000000000000000000000000000000000;;	// face of timeouts and conflicts.
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) UpdateService(namespace, name string, update func(*v1.Service)) (*v1.Service, error) {
0000000000000000000000000000000000000000;;		for i := 0; i < 3; i++ {
0000000000000000000000000000000000000000;;			service, err := j.Client.Core().Services(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Failed to get Service %q: %v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			update(service)
0000000000000000000000000000000000000000;;			service, err = j.Client.Core().Services(namespace).Update(service)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return service, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !errors.IsConflict(err) && !errors.IsServerTimeout(err) {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Failed to update Service %q: %v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Too many retries updating Service %q", name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateServiceOrFail fetches a service, calls the update function on it, and
0000000000000000000000000000000000000000;;	// then attempts to send the updated service. It tries up to 3 times in the
0000000000000000000000000000000000000000;;	// face of timeouts and conflicts.
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) UpdateServiceOrFail(namespace, name string, update func(*v1.Service)) *v1.Service {
0000000000000000000000000000000000000000;;		svc, err := j.UpdateService(namespace, name, update)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return svc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) ChangeServiceNodePortOrFail(namespace, name string, initial int) *v1.Service {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var service *v1.Service
0000000000000000000000000000000000000000;;		for i := 1; i < ServiceNodePortRange.Size; i++ {
0000000000000000000000000000000000000000;;			offs1 := initial - ServiceNodePortRange.Base
0000000000000000000000000000000000000000;;			offs2 := (offs1 + i) % ServiceNodePortRange.Size
0000000000000000000000000000000000000000;;			newPort := ServiceNodePortRange.Base + offs2
0000000000000000000000000000000000000000;;			service, err = j.UpdateService(namespace, name, func(s *v1.Service) {
0000000000000000000000000000000000000000;;				s.Spec.Ports[0].NodePort = int32(newPort)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil && strings.Contains(err.Error(), "provided port is already allocated") {
0000000000000000000000000000000000000000;;				Logf("tried nodePort %d, but it is in use, will try another", newPort)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Otherwise err was nil or err was a real error
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("Could not change the nodePort: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return service
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) WaitForLoadBalancerOrFail(namespace, name string, timeout time.Duration) *v1.Service {
0000000000000000000000000000000000000000;;		var service *v1.Service
0000000000000000000000000000000000000000;;		Logf("Waiting up to %v for service %q to have a LoadBalancer", timeout, name)
0000000000000000000000000000000000000000;;		pollFunc := func() (bool, error) {
0000000000000000000000000000000000000000;;			svc, err := j.Client.Core().Services(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(svc.Status.LoadBalancer.Ingress) > 0 {
0000000000000000000000000000000000000000;;				service = svc
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(Poll, timeout, pollFunc); err != nil {
0000000000000000000000000000000000000000;;			Failf("Timeout waiting for service %q to have a load balancer", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return service
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) WaitForLoadBalancerDestroyOrFail(namespace, name string, ip string, port int, timeout time.Duration) *v1.Service {
0000000000000000000000000000000000000000;;		// TODO: once support ticket 21807001 is resolved, reduce this timeout back to something reasonable
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err := EnsureLoadBalancerResourcesDeleted(ip, strconv.Itoa(port)); err != nil {
0000000000000000000000000000000000000000;;				Logf("Failed to delete cloud resources for service: %s %d (%v)", ip, port, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var service *v1.Service
0000000000000000000000000000000000000000;;		Logf("Waiting up to %v for service %q to have no LoadBalancer", timeout, name)
0000000000000000000000000000000000000000;;		pollFunc := func() (bool, error) {
0000000000000000000000000000000000000000;;			svc, err := j.Client.Core().Services(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(svc.Status.LoadBalancer.Ingress) == 0 {
0000000000000000000000000000000000000000;;				service = svc
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(Poll, timeout, pollFunc); err != nil {
0000000000000000000000000000000000000000;;			Failf("Timeout waiting for service %q to have no load balancer", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return service
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newRCTemplate returns the default v1.ReplicationController object for
0000000000000000000000000000000000000000;;	// this jig, but does not actually create the RC.  The default RC has the same
0000000000000000000000000000000000000000;;	// name as the jig and runs the "netexec" container.
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) newRCTemplate(namespace string) *v1.ReplicationController {
0000000000000000000000000000000000000000;;		var replicas int32 = 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rc := &v1.ReplicationController{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Name:      j.Name,
0000000000000000000000000000000000000000;;				Labels:    j.Labels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;				Replicas: &replicas,
0000000000000000000000000000000000000000;;				Selector: j.Labels,
0000000000000000000000000000000000000000;;				Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: j.Labels,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "netexec",
0000000000000000000000000000000000000000;;								Image: "gcr.io/google_containers/netexec:1.7",
0000000000000000000000000000000000000000;;								Args:  []string{"--http-port=80", "--udp-port=80"},
0000000000000000000000000000000000000000;;								ReadinessProbe: &v1.Probe{
0000000000000000000000000000000000000000;;									PeriodSeconds: 3,
0000000000000000000000000000000000000000;;									Handler: v1.Handler{
0000000000000000000000000000000000000000;;										HTTPGet: &v1.HTTPGetAction{
0000000000000000000000000000000000000000;;											Port: intstr.FromInt(80),
0000000000000000000000000000000000000000;;											Path: "/hostName",
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						TerminationGracePeriodSeconds: new(int64),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) AddRCAntiAffinity(rc *v1.ReplicationController) {
0000000000000000000000000000000000000000;;		var replicas int32 = 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rc.Spec.Replicas = &replicas
0000000000000000000000000000000000000000;;		if rc.Spec.Template.Spec.Affinity == nil {
0000000000000000000000000000000000000000;;			rc.Spec.Template.Spec.Affinity = &v1.Affinity{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rc.Spec.Template.Spec.Affinity.PodAntiAffinity == nil {
0000000000000000000000000000000000000000;;			rc.Spec.Template.Spec.Affinity.PodAntiAffinity = &v1.PodAntiAffinity{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rc.Spec.Template.Spec.Affinity.PodAntiAffinity.RequiredDuringSchedulingIgnoredDuringExecution = append(
0000000000000000000000000000000000000000;;			rc.Spec.Template.Spec.Affinity.PodAntiAffinity.RequiredDuringSchedulingIgnoredDuringExecution,
0000000000000000000000000000000000000000;;			v1.PodAffinityTerm{
0000000000000000000000000000000000000000;;				LabelSelector: &metav1.LabelSelector{MatchLabels: j.Labels},
0000000000000000000000000000000000000000;;				Namespaces:    nil,
0000000000000000000000000000000000000000;;				TopologyKey:   "kubernetes.io/hostname",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) CreatePDBOrFail(namespace string, rc *v1.ReplicationController) *policyv1beta1.PodDisruptionBudget {
0000000000000000000000000000000000000000;;		pdb := j.newPDBTemplate(namespace, rc)
0000000000000000000000000000000000000000;;		newPdb, err := j.Client.Policy().PodDisruptionBudgets(namespace).Create(pdb)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("Failed to create PDB %q %v", pdb.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := j.waitForPdbReady(namespace); err != nil {
0000000000000000000000000000000000000000;;			Failf("Failed waiting for PDB to be ready: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return newPdb
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newPDBTemplate returns the default policyv1beta1.PodDisruptionBudget object for
0000000000000000000000000000000000000000;;	// this jig, but does not actually create the PDB.  The default PDB specifies a
0000000000000000000000000000000000000000;;	// MinAvailable of N-1 and matches the pods created by the RC.
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) newPDBTemplate(namespace string, rc *v1.ReplicationController) *policyv1beta1.PodDisruptionBudget {
0000000000000000000000000000000000000000;;		minAvailable := intstr.FromInt(int(*rc.Spec.Replicas) - 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pdb := &policyv1beta1.PodDisruptionBudget{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Name:      j.Name,
0000000000000000000000000000000000000000;;				Labels:    j.Labels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: policyv1beta1.PodDisruptionBudgetSpec{
0000000000000000000000000000000000000000;;				MinAvailable: &minAvailable,
0000000000000000000000000000000000000000;;				Selector:     &metav1.LabelSelector{MatchLabels: j.Labels},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pdb
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunOrFail creates a ReplicationController and Pod(s) and waits for the
0000000000000000000000000000000000000000;;	// Pod(s) to be running. Callers can provide a function to tweak the RC object
0000000000000000000000000000000000000000;;	// before it is created.
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) RunOrFail(namespace string, tweak func(rc *v1.ReplicationController)) *v1.ReplicationController {
0000000000000000000000000000000000000000;;		rc := j.newRCTemplate(namespace)
0000000000000000000000000000000000000000;;		if tweak != nil {
0000000000000000000000000000000000000000;;			tweak(rc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result, err := j.Client.Core().ReplicationControllers(namespace).Create(rc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("Failed to create RC %q: %v", rc.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pods, err := j.waitForPodsCreated(namespace, int(*(rc.Spec.Replicas)))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("Failed to create pods: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := j.waitForPodsReady(namespace, pods); err != nil {
0000000000000000000000000000000000000000;;			Failf("Failed waiting for pods to be running: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) waitForPdbReady(namespace string) error {
0000000000000000000000000000000000000000;;		timeout := 2 * time.Minute
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < timeout; time.Sleep(2 * time.Second) {
0000000000000000000000000000000000000000;;			pdb, err := j.Client.Policy().PodDisruptionBudgets(namespace).Get(j.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pdb.Status.PodDisruptionsAllowed > 0 {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Errorf("Timeout waiting for PDB %q to be ready", j.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) waitForPodsCreated(namespace string, replicas int) ([]string, error) {
0000000000000000000000000000000000000000;;		timeout := 2 * time.Minute
0000000000000000000000000000000000000000;;		// List the pods, making sure we observe all the replicas.
0000000000000000000000000000000000000000;;		label := labels.SelectorFromSet(labels.Set(j.Labels))
0000000000000000000000000000000000000000;;		Logf("Waiting up to %v for %d pods to be created", timeout, replicas)
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < timeout; time.Sleep(2 * time.Second) {
0000000000000000000000000000000000000000;;			options := metav1.ListOptions{LabelSelector: label.String()}
0000000000000000000000000000000000000000;;			pods, err := j.Client.Core().Pods(namespace).List(options)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			found := []string{}
0000000000000000000000000000000000000000;;			for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;				if pod.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				found = append(found, pod.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(found) == replicas {
0000000000000000000000000000000000000000;;				Logf("Found all %d pods", replicas)
0000000000000000000000000000000000000000;;				return found, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Logf("Found %d/%d pods - will retry", len(found), replicas)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Timeout waiting for %d pods to be created", replicas)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) waitForPodsReady(namespace string, pods []string) error {
0000000000000000000000000000000000000000;;		timeout := 2 * time.Minute
0000000000000000000000000000000000000000;;		if !CheckPodsRunningReady(j.Client, namespace, pods, timeout) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Timeout waiting for %d pods to be ready", len(pods))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newNetexecPodSpec returns the pod spec of netexec pod
0000000000000000000000000000000000000000;;	func newNetexecPodSpec(podName string, httpPort, udpPort int32, hostNetwork bool) *v1.Pod {
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: podName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "netexec",
0000000000000000000000000000000000000000;;						Image: NetexecImageName,
0000000000000000000000000000000000000000;;						Command: []string{
0000000000000000000000000000000000000000;;							"/netexec",
0000000000000000000000000000000000000000;;							fmt.Sprintf("--http-port=%d", httpPort),
0000000000000000000000000000000000000000;;							fmt.Sprintf("--udp-port=%d", udpPort),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Ports: []v1.ContainerPort{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:          "http",
0000000000000000000000000000000000000000;;								ContainerPort: httpPort,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:          "udp",
0000000000000000000000000000000000000000;;								ContainerPort: udpPort,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				HostNetwork: hostNetwork,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) LaunchNetexecPodOnNode(f *Framework, nodeName, podName string, httpPort, udpPort int32, hostNetwork bool) {
0000000000000000000000000000000000000000;;		Logf("Creating netexec pod %q on node %v in namespace %q", podName, nodeName, f.Namespace.Name)
0000000000000000000000000000000000000000;;		pod := newNetexecPodSpec(podName, httpPort, udpPort, hostNetwork)
0000000000000000000000000000000000000000;;		pod.Spec.NodeName = nodeName
0000000000000000000000000000000000000000;;		pod.ObjectMeta.Labels = j.Labels
0000000000000000000000000000000000000000;;		podClient := f.ClientSet.Core().Pods(f.Namespace.Name)
0000000000000000000000000000000000000000;;		_, err := podClient.Create(pod)
0000000000000000000000000000000000000000;;		ExpectNoError(err)
0000000000000000000000000000000000000000;;		ExpectNoError(f.WaitForPodRunning(podName))
0000000000000000000000000000000000000000;;		Logf("Netexec pod  %q in namespace %q running", pod.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newEchoServerPodSpec returns the pod spec of echo server pod
0000000000000000000000000000000000000000;;	func newEchoServerPodSpec(podName string) *v1.Pod {
0000000000000000000000000000000000000000;;		port := 8080
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: podName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "echoserver",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/echoserver:1.6",
0000000000000000000000000000000000000000;;						Ports: []v1.ContainerPort{{ContainerPort: int32(port)}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LaunchEchoserverPodOnNode launches a pod serving http on port 8080 to act
0000000000000000000000000000000000000000;;	// as the target for source IP preservation test. The client's source ip would
0000000000000000000000000000000000000000;;	// be echoed back by the web server.
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) LaunchEchoserverPodOnNode(f *Framework, nodeName, podName string) {
0000000000000000000000000000000000000000;;		Logf("Creating echo server pod %q in namespace %q", podName, f.Namespace.Name)
0000000000000000000000000000000000000000;;		pod := newEchoServerPodSpec(podName)
0000000000000000000000000000000000000000;;		pod.Spec.NodeName = nodeName
0000000000000000000000000000000000000000;;		pod.ObjectMeta.Labels = j.Labels
0000000000000000000000000000000000000000;;		podClient := f.ClientSet.Core().Pods(f.Namespace.Name)
0000000000000000000000000000000000000000;;		_, err := podClient.Create(pod)
0000000000000000000000000000000000000000;;		ExpectNoError(err)
0000000000000000000000000000000000000000;;		ExpectNoError(f.WaitForPodRunning(podName))
0000000000000000000000000000000000000000;;		Logf("Echo server pod %q in namespace %q running", pod.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) TestReachableHTTP(host string, port int, timeout time.Duration) {
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(Poll, timeout, func() (bool, error) { return TestReachableHTTP(host, port, "/echo?msg=hello", "hello") }); err != nil {
0000000000000000000000000000000000000000;;			Failf("Could not reach HTTP service through %v:%v after %v: %v", host, port, timeout, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) TestNotReachableHTTP(host string, port int, timeout time.Duration) {
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(Poll, timeout, func() (bool, error) { return TestNotReachableHTTP(host, port) }); err != nil {
0000000000000000000000000000000000000000;;			Failf("Could still reach HTTP service through %v:%v after %v: %v", host, port, timeout, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) TestReachableUDP(host string, port int, timeout time.Duration) {
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(Poll, timeout, func() (bool, error) { return TestReachableUDP(host, port, "echo hello", "hello") }); err != nil {
0000000000000000000000000000000000000000;;			Failf("Could not reach UDP service through %v:%v after %v: %v", host, port, timeout, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) TestNotReachableUDP(host string, port int, timeout time.Duration) {
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(Poll, timeout, func() (bool, error) { return TestNotReachableUDP(host, port, "echo hello") }); err != nil {
0000000000000000000000000000000000000000;;			Failf("Could still reach UDP service through %v:%v after %v: %v", host, port, timeout, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) GetHTTPContent(host string, port int, timeout time.Duration, url string) bytes.Buffer {
0000000000000000000000000000000000000000;;		var body bytes.Buffer
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if pollErr := wait.PollImmediate(Poll, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			var result bool
0000000000000000000000000000000000000000;;			result, err = TestReachableHTTPWithContent(host, port, url, "", &body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				Logf("Error hitting %v:%v%v, retrying: %v", host, port, url, err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return result, nil
0000000000000000000000000000000000000000;;		}); pollErr != nil {
0000000000000000000000000000000000000000;;			Failf("Could not reach HTTP service through %v:%v%v after %v: %v", host, port, url, timeout, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return body
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testHTTPHealthCheckNodePort(ip string, port int, request string) (bool, error) {
0000000000000000000000000000000000000000;;		url := fmt.Sprintf("http://%s:%d%s", ip, port, request)
0000000000000000000000000000000000000000;;		if ip == "" || port == 0 {
0000000000000000000000000000000000000000;;			Failf("Got empty IP for reachability check (%s)", url)
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Invalid input ip or port")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Logf("Testing HTTP health check on %v", url)
0000000000000000000000000000000000000000;;		resp, err := httpGetNoConnectionPool(url)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Logf("Got error testing for reachability of %s: %v", url, err)
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Logf("Got error reading response from %s: %v", url, err)
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// HealthCheck responder returns 503 for no local endpoints
0000000000000000000000000000000000000000;;		if resp.StatusCode == 503 {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// HealthCheck responder returns 200 for non-zero local endpoints
0000000000000000000000000000000000000000;;		if resp.StatusCode == 200 {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, fmt.Errorf("Unexpected HTTP response code %s from health check responder at %s", resp.Status, url)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *ServiceTestJig) TestHTTPHealthCheckNodePort(host string, port int, request string, timeout time.Duration, expectSucceed bool, threshold int) error {
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		condition := func() (bool, error) {
0000000000000000000000000000000000000000;;			success, _ := testHTTPHealthCheckNodePort(host, port, request)
0000000000000000000000000000000000000000;;			if success && expectSucceed ||
0000000000000000000000000000000000000000;;				!success && !expectSucceed {
0000000000000000000000000000000000000000;;				count++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if count >= threshold {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(time.Second, timeout, condition); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error waiting for healthCheckNodePort: expected at least %d succeed=%v on %v%v, got %d", threshold, expectSucceed, host, port, count)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Simple helper class to avoid too much boilerplate in tests
0000000000000000000000000000000000000000;;	type ServiceTestFixture struct {
0000000000000000000000000000000000000000;;		ServiceName string
0000000000000000000000000000000000000000;;		Namespace   string
0000000000000000000000000000000000000000;;		Client      clientset.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		TestId string
0000000000000000000000000000000000000000;;		Labels map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rcs      map[string]bool
0000000000000000000000000000000000000000;;		services map[string]bool
0000000000000000000000000000000000000000;;		Name     string
0000000000000000000000000000000000000000;;		Image    string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewServerTest(client clientset.Interface, namespace string, serviceName string) *ServiceTestFixture {
0000000000000000000000000000000000000000;;		t := &ServiceTestFixture{}
0000000000000000000000000000000000000000;;		t.Client = client
0000000000000000000000000000000000000000;;		t.Namespace = namespace
0000000000000000000000000000000000000000;;		t.ServiceName = serviceName
0000000000000000000000000000000000000000;;		t.TestId = t.ServiceName + "-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;		t.Labels = map[string]string{
0000000000000000000000000000000000000000;;			"testid": t.TestId,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.rcs = make(map[string]bool)
0000000000000000000000000000000000000000;;		t.services = make(map[string]bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Name = "webserver"
0000000000000000000000000000000000000000;;		t.Image = "gcr.io/google_containers/test-webserver:e2e"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Build default config for a service (which can then be changed)
0000000000000000000000000000000000000000;;	func (t *ServiceTestFixture) BuildServiceSpec() *v1.Service {
0000000000000000000000000000000000000000;;		service := &v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      t.ServiceName,
0000000000000000000000000000000000000000;;				Namespace: t.Namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: t.Labels,
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       80,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(80),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return service
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateWebserverRC creates rc-backed pods with the well-known webserver
0000000000000000000000000000000000000000;;	// configuration and records it for cleanup.
0000000000000000000000000000000000000000;;	func (t *ServiceTestFixture) CreateWebserverRC(replicas int32) *v1.ReplicationController {
0000000000000000000000000000000000000000;;		rcSpec := RcByNamePort(t.Name, replicas, t.Image, 80, v1.ProtocolTCP, t.Labels, nil)
0000000000000000000000000000000000000000;;		rcAct, err := t.CreateRC(rcSpec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("Failed to create rc %s: %v", rcSpec.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := VerifyPods(t.Client, t.Namespace, t.Name, false, replicas); err != nil {
0000000000000000000000000000000000000000;;			Failf("Failed to create %d pods with name %s: %v", replicas, t.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rcAct
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateRC creates a replication controller and records it for cleanup.
0000000000000000000000000000000000000000;;	func (t *ServiceTestFixture) CreateRC(rc *v1.ReplicationController) (*v1.ReplicationController, error) {
0000000000000000000000000000000000000000;;		rc, err := t.Client.Core().ReplicationControllers(t.Namespace).Create(rc)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.rcs[rc.Name] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rc, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a service, and record it for cleanup
0000000000000000000000000000000000000000;;	func (t *ServiceTestFixture) CreateService(service *v1.Service) (*v1.Service, error) {
0000000000000000000000000000000000000000;;		result, err := t.Client.Core().Services(t.Namespace).Create(service)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.services[service.Name] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete a service, and remove it from the cleanup list
0000000000000000000000000000000000000000;;	func (t *ServiceTestFixture) DeleteService(serviceName string) error {
0000000000000000000000000000000000000000;;		err := t.Client.Core().Services(t.Namespace).Delete(serviceName, nil)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			delete(t.services, serviceName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *ServiceTestFixture) Cleanup() []error {
0000000000000000000000000000000000000000;;		var errs []error
0000000000000000000000000000000000000000;;		for rcName := range t.rcs {
0000000000000000000000000000000000000000;;			By("stopping RC " + rcName + " in namespace " + t.Namespace)
0000000000000000000000000000000000000000;;			err := retry.RetryOnConflict(retry.DefaultRetry, func() error {
0000000000000000000000000000000000000000;;				// First, resize the RC to 0.
0000000000000000000000000000000000000000;;				old, err := t.Client.Core().ReplicationControllers(t.Namespace).Get(rcName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				x := int32(0)
0000000000000000000000000000000000000000;;				old.Spec.Replicas = &x
0000000000000000000000000000000000000000;;				if _, err := t.Client.Core().ReplicationControllers(t.Namespace).Update(old); err != nil {
0000000000000000000000000000000000000000;;					if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO(mikedanese): Wait.
0000000000000000000000000000000000000000;;			// Then, delete the RC altogether.
0000000000000000000000000000000000000000;;			if err := t.Client.Core().ReplicationControllers(t.Namespace).Delete(rcName, nil); err != nil {
0000000000000000000000000000000000000000;;				if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					errs = append(errs, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for serviceName := range t.services {
0000000000000000000000000000000000000000;;			By("deleting service " + serviceName + " in namespace " + t.Namespace)
0000000000000000000000000000000000000000;;			err := t.Client.Core().Services(t.Namespace).Delete(serviceName, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					errs = append(errs, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return errs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetIngressPoint(ing *v1.LoadBalancerIngress) string {
0000000000000000000000000000000000000000;;		host := ing.IP
0000000000000000000000000000000000000000;;		if host == "" {
0000000000000000000000000000000000000000;;			host = ing.Hostname
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return host
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateService fetches a service, calls the update function on it,
0000000000000000000000000000000000000000;;	// and then attempts to send the updated service. It retries up to 2
0000000000000000000000000000000000000000;;	// times in the face of timeouts and conflicts.
0000000000000000000000000000000000000000;;	func UpdateService(c clientset.Interface, namespace, serviceName string, update func(*v1.Service)) (*v1.Service, error) {
0000000000000000000000000000000000000000;;		var service *v1.Service
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for i := 0; i < 3; i++ {
0000000000000000000000000000000000000000;;			service, err = c.Core().Services(namespace).Get(serviceName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return service, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			update(service)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			service, err = c.Core().Services(namespace).Update(service)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !errors.IsConflict(err) && !errors.IsServerTimeout(err) {
0000000000000000000000000000000000000000;;				return service, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return service, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetContainerPortsByPodUID(endpoints *v1.Endpoints) PortsByPodUID {
0000000000000000000000000000000000000000;;		m := PortsByPodUID{}
0000000000000000000000000000000000000000;;		for _, ss := range endpoints.Subsets {
0000000000000000000000000000000000000000;;			for _, port := range ss.Ports {
0000000000000000000000000000000000000000;;				for _, addr := range ss.Addresses {
0000000000000000000000000000000000000000;;					containerPort := port.Port
0000000000000000000000000000000000000000;;					hostPort := port.Port
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// use endpoint annotations to recover the container port in a Mesos setup
0000000000000000000000000000000000000000;;					// compare contrib/mesos/pkg/service/endpoints_controller.syncService
0000000000000000000000000000000000000000;;					key := fmt.Sprintf("k8s.mesosphere.io/containerPort_%s_%s_%d", port.Protocol, addr.IP, hostPort)
0000000000000000000000000000000000000000;;					mesosContainerPortString := endpoints.Annotations[key]
0000000000000000000000000000000000000000;;					if mesosContainerPortString != "" {
0000000000000000000000000000000000000000;;						mesosContainerPort, err := strconv.Atoi(mesosContainerPortString)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						containerPort = int32(mesosContainerPort)
0000000000000000000000000000000000000000;;						Logf("Mapped mesos host port %d to container port %d via annotation %s=%s", hostPort, containerPort, key, mesosContainerPortString)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Logf("Found pod %v, host port %d and container port %d", addr.TargetRef.UID, hostPort, containerPort)
0000000000000000000000000000000000000000;;					if _, ok := m[addr.TargetRef.UID]; !ok {
0000000000000000000000000000000000000000;;						m[addr.TargetRef.UID] = make([]int, 0)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					m[addr.TargetRef.UID] = append(m[addr.TargetRef.UID], int(containerPort))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PortsByPodName map[string][]int
0000000000000000000000000000000000000000;;	type PortsByPodUID map[types.UID][]int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func translatePodNameToUIDOrFail(c clientset.Interface, ns string, expectedEndpoints PortsByPodName) PortsByPodUID {
0000000000000000000000000000000000000000;;		portsByUID := make(PortsByPodUID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, portList := range expectedEndpoints {
0000000000000000000000000000000000000000;;			pod, err := c.Core().Pods(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				Failf("failed to get pod %s, that's pretty weird. validation failed: %s", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			portsByUID[pod.ObjectMeta.UID] = portList
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Logf("successfully translated pod names to UIDs: %v -> %v on namespace %s", expectedEndpoints, portsByUID, ns)
0000000000000000000000000000000000000000;;		return portsByUID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validatePortsOrFail(endpoints PortsByPodUID, expectedEndpoints PortsByPodUID) {
0000000000000000000000000000000000000000;;		if len(endpoints) != len(expectedEndpoints) {
0000000000000000000000000000000000000000;;			// should not happen because we check this condition before
0000000000000000000000000000000000000000;;			Failf("invalid number of endpoints got %v, expected %v", endpoints, expectedEndpoints)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for podUID := range expectedEndpoints {
0000000000000000000000000000000000000000;;			if _, ok := endpoints[podUID]; !ok {
0000000000000000000000000000000000000000;;				Failf("endpoint %v not found", podUID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(endpoints[podUID]) != len(expectedEndpoints[podUID]) {
0000000000000000000000000000000000000000;;				Failf("invalid list of ports for uid %v. Got %v, expected %v", podUID, endpoints[podUID], expectedEndpoints[podUID])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Ints(endpoints[podUID])
0000000000000000000000000000000000000000;;			sort.Ints(expectedEndpoints[podUID])
0000000000000000000000000000000000000000;;			for index := range endpoints[podUID] {
0000000000000000000000000000000000000000;;				if endpoints[podUID][index] != expectedEndpoints[podUID][index] {
0000000000000000000000000000000000000000;;					Failf("invalid list of ports for uid %v. Got %v, expected %v", podUID, endpoints[podUID], expectedEndpoints[podUID])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateEndpointsOrFail(c clientset.Interface, namespace, serviceName string, expectedEndpoints PortsByPodName) {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("waiting up to %v for service %s in namespace %s to expose endpoints %v", ServiceStartTimeout, serviceName, namespace, expectedEndpoints))
0000000000000000000000000000000000000000;;		i := 1
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < ServiceStartTimeout; time.Sleep(1 * time.Second) {
0000000000000000000000000000000000000000;;			endpoints, err := c.Core().Endpoints(namespace).Get(serviceName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				Logf("Get endpoints failed (%v elapsed, ignoring for 5s): %v", time.Since(start), err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Logf("Found endpoints %v", endpoints)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			portsByPodUID := GetContainerPortsByPodUID(endpoints)
0000000000000000000000000000000000000000;;			// Logf("Found port by pod UID %v", portsByPodUID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expectedPortsByPodUID := translatePodNameToUIDOrFail(c, namespace, expectedEndpoints)
0000000000000000000000000000000000000000;;			if len(portsByPodUID) == len(expectedEndpoints) {
0000000000000000000000000000000000000000;;				validatePortsOrFail(portsByPodUID, expectedPortsByPodUID)
0000000000000000000000000000000000000000;;				Logf("successfully validated that service %s in namespace %s exposes endpoints %v (%v elapsed)",
0000000000000000000000000000000000000000;;					serviceName, namespace, expectedEndpoints, time.Since(start))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i%5 == 0 {
0000000000000000000000000000000000000000;;				Logf("Unexpected endpoints: found %v, expected %v (%v elapsed, will retry)", portsByPodUID, expectedEndpoints, time.Since(start))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pods, err := c.Core().Pods(metav1.NamespaceAll).List(metav1.ListOptions{}); err == nil {
0000000000000000000000000000000000000000;;			for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;				Logf("Pod %s\t%s\t%s\t%s", pod.Namespace, pod.Name, pod.Spec.NodeName, pod.DeletionTimestamp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			Logf("Can't list pod debug info: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Failf("Timed out waiting for service %s in namespace %s to expose endpoints %v (%v elapsed)", serviceName, namespace, expectedEndpoints, ServiceStartTimeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StartServeHostnameService creates a replication controller that serves its hostname and a service on top of it.
0000000000000000000000000000000000000000;;	func StartServeHostnameService(c clientset.Interface, internalClient internalclientset.Interface, ns, name string, port, replicas int) ([]string, string, error) {
0000000000000000000000000000000000000000;;		podNames := make([]string, replicas)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("creating service " + name + " in namespace " + ns)
0000000000000000000000000000000000000000;;		_, err := c.Core().Services(ns).Create(&v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       int32(port),
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(9376),
0000000000000000000000000000000000000000;;					Protocol:   "TCP",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Selector: map[string]string{
0000000000000000000000000000000000000000;;					"name": name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return podNames, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var createdPods []*v1.Pod
0000000000000000000000000000000000000000;;		maxContainerFailures := 0
0000000000000000000000000000000000000000;;		config := testutils.RCConfig{
0000000000000000000000000000000000000000;;			Client:               c,
0000000000000000000000000000000000000000;;			InternalClient:       internalClient,
0000000000000000000000000000000000000000;;			Image:                ServeHostnameImage,
0000000000000000000000000000000000000000;;			Name:                 name,
0000000000000000000000000000000000000000;;			Namespace:            ns,
0000000000000000000000000000000000000000;;			PollInterval:         3 * time.Second,
0000000000000000000000000000000000000000;;			Timeout:              PodReadyBeforeTimeout,
0000000000000000000000000000000000000000;;			Replicas:             replicas,
0000000000000000000000000000000000000000;;			CreatedPods:          &createdPods,
0000000000000000000000000000000000000000;;			MaxContainerFailures: &maxContainerFailures,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = RunRC(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return podNames, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(createdPods) != replicas {
0000000000000000000000000000000000000000;;			return podNames, "", fmt.Errorf("Incorrect number of running pods: %v", len(createdPods))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range createdPods {
0000000000000000000000000000000000000000;;			podNames[i] = createdPods[i].ObjectMeta.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.StringSlice(podNames).Sort()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		service, err := c.Core().Services(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return podNames, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if service.Spec.ClusterIP == "" {
0000000000000000000000000000000000000000;;			return podNames, "", fmt.Errorf("Service IP is blank for %v", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		serviceIP := service.Spec.ClusterIP
0000000000000000000000000000000000000000;;		return podNames, serviceIP, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func StopServeHostnameService(clientset clientset.Interface, internalClientset internalclientset.Interface, ns, name string) error {
0000000000000000000000000000000000000000;;		if err := DeleteRCAndPods(clientset, internalClientset, ns, name); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := clientset.Core().Services(ns).Delete(name, nil); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifyServeHostnameServiceUp wgets the given serviceIP:servicePort from the
0000000000000000000000000000000000000000;;	// given host and from within a pod. The host is expected to be an SSH-able node
0000000000000000000000000000000000000000;;	// in the cluster. Each pod in the service is expected to echo its name. These
0000000000000000000000000000000000000000;;	// names are compared with the given expectedPods list after a sort | uniq.
0000000000000000000000000000000000000000;;	func VerifyServeHostnameServiceUp(c clientset.Interface, ns, host string, expectedPods []string, serviceIP string, servicePort int) error {
0000000000000000000000000000000000000000;;		execPodName := CreateExecPodOrFail(c, ns, "execpod-", nil)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			DeletePodOrFail(c, ns, execPodName)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Loop a bunch of times - the proxy is randomized, so we want a good
0000000000000000000000000000000000000000;;		// chance of hitting each backend at least once.
0000000000000000000000000000000000000000;;		buildCommand := func(wget string) string {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("for i in $(seq 1 %d); do %s http://%s:%d 2>&1 || true; echo; done",
0000000000000000000000000000000000000000;;				50*len(expectedPods), wget, serviceIP, servicePort)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		commands := []func() string{
0000000000000000000000000000000000000000;;			// verify service from node
0000000000000000000000000000000000000000;;			func() string {
0000000000000000000000000000000000000000;;				cmd := "set -e; " + buildCommand("wget -q --timeout=0.2 --tries=1 -O -")
0000000000000000000000000000000000000000;;				Logf("Executing cmd %q on host %v", cmd, host)
0000000000000000000000000000000000000000;;				result, err := SSH(cmd, host, TestContext.Provider)
0000000000000000000000000000000000000000;;				if err != nil || result.Code != 0 {
0000000000000000000000000000000000000000;;					LogSSHResult(result)
0000000000000000000000000000000000000000;;					Logf("error while SSH-ing to node: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return result.Stdout
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// verify service from pod
0000000000000000000000000000000000000000;;			func() string {
0000000000000000000000000000000000000000;;				cmd := buildCommand("wget -q -T 1 -O -")
0000000000000000000000000000000000000000;;				Logf("Executing cmd %q in pod %v/%v", cmd, ns, execPodName)
0000000000000000000000000000000000000000;;				// TODO: Use exec-over-http via the netexec pod instead of kubectl exec.
0000000000000000000000000000000000000000;;				output, err := RunHostCmd(ns, execPodName, cmd)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					Logf("error while kubectl execing %q in pod %v/%v: %v\nOutput: %v", cmd, ns, execPodName, err, output)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return output
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedEndpoints := sets.NewString(expectedPods...)
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("verifying service has %d reachable backends", len(expectedPods)))
0000000000000000000000000000000000000000;;		for _, cmdFunc := range commands {
0000000000000000000000000000000000000000;;			passed := false
0000000000000000000000000000000000000000;;			gotEndpoints := sets.NewString()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Retry cmdFunc for a while
0000000000000000000000000000000000000000;;			for start := time.Now(); time.Since(start) < KubeProxyLagTimeout; time.Sleep(5 * time.Second) {
0000000000000000000000000000000000000000;;				for _, endpoint := range strings.Split(cmdFunc(), "\n") {
0000000000000000000000000000000000000000;;					trimmedEp := strings.TrimSpace(endpoint)
0000000000000000000000000000000000000000;;					if trimmedEp != "" {
0000000000000000000000000000000000000000;;						gotEndpoints.Insert(trimmedEp)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// TODO: simply checking that the retrieved endpoints is a superset
0000000000000000000000000000000000000000;;				// of the expected allows us to ignore intermitten network flakes that
0000000000000000000000000000000000000000;;				// result in output like "wget timed out", but these should be rare
0000000000000000000000000000000000000000;;				// and we need a better way to track how often it occurs.
0000000000000000000000000000000000000000;;				if gotEndpoints.IsSuperset(expectedEndpoints) {
0000000000000000000000000000000000000000;;					if !gotEndpoints.Equal(expectedEndpoints) {
0000000000000000000000000000000000000000;;						Logf("Ignoring unexpected output wgetting endpoints of service %s: %v", serviceIP, gotEndpoints.Difference(expectedEndpoints))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					passed = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				Logf("Unable to reach the following endpoints of service %s: %v", serviceIP, expectedEndpoints.Difference(gotEndpoints))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !passed {
0000000000000000000000000000000000000000;;				// Sort the lists so they're easier to visually diff.
0000000000000000000000000000000000000000;;				exp := expectedEndpoints.List()
0000000000000000000000000000000000000000;;				got := gotEndpoints.List()
0000000000000000000000000000000000000000;;				sort.StringSlice(exp).Sort()
0000000000000000000000000000000000000000;;				sort.StringSlice(got).Sort()
0000000000000000000000000000000000000000;;				return fmt.Errorf("service verification failed for: %s\nexpected %v\nreceived %v", serviceIP, exp, got)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func VerifyServeHostnameServiceDown(c clientset.Interface, host string, serviceIP string, servicePort int) error {
0000000000000000000000000000000000000000;;		command := fmt.Sprintf(
0000000000000000000000000000000000000000;;			"curl -s --connect-timeout 2 http://%s:%d && exit 99", serviceIP, servicePort)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < time.Minute; time.Sleep(5 * time.Second) {
0000000000000000000000000000000000000000;;			result, err := SSH(command, host, TestContext.Provider)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				LogSSHResult(result)
0000000000000000000000000000000000000000;;				Logf("error while SSH-ing to node: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if result.Code != 99 {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Logf("service still alive - still waiting")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("waiting for service to be down timed out")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CleanupServiceResources(c clientset.Interface, loadBalancerName, zone string) {
0000000000000000000000000000000000000000;;		if TestContext.Provider == "gce" || TestContext.Provider == "gke" {
0000000000000000000000000000000000000000;;			CleanupServiceGCEResources(c, loadBalancerName, zone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: we need to add this function with other cloud providers, if there is a need.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CleanupServiceGCEResources(c clientset.Interface, loadBalancerName, zone string) {
0000000000000000000000000000000000000000;;		if pollErr := wait.Poll(5*time.Second, LoadBalancerCleanupTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			if err := CleanupGCEResources(c, loadBalancerName, zone); err != nil {
0000000000000000000000000000000000000000;;				Logf("Still waiting for glbc to cleanup: %v", err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}); pollErr != nil {
0000000000000000000000000000000000000000;;			Failf("Failed to cleanup service GCE resources.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DescribeSvc(ns string) {
0000000000000000000000000000000000000000;;		Logf("\nOutput of kubectl describe svc:\n")
0000000000000000000000000000000000000000;;		desc, _ := RunKubectl(
0000000000000000000000000000000000000000;;			"describe", "svc", fmt.Sprintf("--namespace=%v", ns))
0000000000000000000000000000000000000000;;		Logf(desc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreateServiceSpec(serviceName, externalName string, isHeadless bool, selector map[string]string) *v1.Service {
0000000000000000000000000000000000000000;;		headlessService := &v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: serviceName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: selector,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if externalName != "" {
0000000000000000000000000000000000000000;;			headlessService.Spec.Type = v1.ServiceTypeExternalName
0000000000000000000000000000000000000000;;			headlessService.Spec.ExternalName = externalName
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			headlessService.Spec.Ports = []v1.ServicePort{
0000000000000000000000000000000000000000;;				{Port: 80, Name: "http", Protocol: "TCP"},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isHeadless {
0000000000000000000000000000000000000000;;			headlessService.Spec.ClusterIP = "None"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return headlessService
0000000000000000000000000000000000000000;;	}
