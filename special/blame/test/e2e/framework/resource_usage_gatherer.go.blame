0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
9027e9a610c660d7a98aa9065dd625617d412565;test/e2e/resource_usage_gatherer.go[test/e2e/resource_usage_gatherer.go][test/e2e/framework/resource_usage_gatherer.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"text/tabwriter"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/system"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		resourceDataGatheringPeriod = 60 * time.Second
0000000000000000000000000000000000000000;;		probeDuration               = 15 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ResourceConstraint struct {
0000000000000000000000000000000000000000;;		CPUConstraint    float64
0000000000000000000000000000000000000000;;		MemoryConstraint uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SingleContainerSummary struct {
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		Cpu  float64
0000000000000000000000000000000000000000;;		Mem  uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// we can't have int here, as JSON does not accept integer keys.
0000000000000000000000000000000000000000;;	type ResourceUsageSummary map[string][]SingleContainerSummary
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ResourceUsageSummary) PrintHumanReadable() string {
0000000000000000000000000000000000000000;;		buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		w := tabwriter.NewWriter(buf, 1, 0, 1, ' ', 0)
0000000000000000000000000000000000000000;;		for perc, summaries := range *s {
0000000000000000000000000000000000000000;;			buf.WriteString(fmt.Sprintf("%v percentile:\n", perc))
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "container\tcpu(cores)\tmemory(MB)\n")
0000000000000000000000000000000000000000;;			for _, summary := range summaries {
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, "%q\t%.3f\t%.2f\n", summary.Name, summary.Cpu, float64(summary.Mem)/(1024*1024))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ResourceUsageSummary) PrintJSON() string {
0000000000000000000000000000000000000000;;		return PrettyPrintJSON(*s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ResourceUsageSummary) SummaryKind() string {
0000000000000000000000000000000000000000;;		return "ResourceUsageSummary"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func computePercentiles(timeSeries []ResourceUsagePerContainer, percentilesToCompute []int) map[int]ResourceUsagePerContainer {
0000000000000000000000000000000000000000;;		if len(timeSeries) == 0 {
0000000000000000000000000000000000000000;;			return make(map[int]ResourceUsagePerContainer)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dataMap := make(map[string]*usageDataPerContainer)
0000000000000000000000000000000000000000;;		for i := range timeSeries {
0000000000000000000000000000000000000000;;			for name, data := range timeSeries[i] {
0000000000000000000000000000000000000000;;				if dataMap[name] == nil {
0000000000000000000000000000000000000000;;					dataMap[name] = &usageDataPerContainer{
0000000000000000000000000000000000000000;;						cpuData:        make([]float64, len(timeSeries)),
0000000000000000000000000000000000000000;;						memUseData:     make([]uint64, len(timeSeries)),
0000000000000000000000000000000000000000;;						memWorkSetData: make([]uint64, len(timeSeries)),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dataMap[name].cpuData = append(dataMap[name].cpuData, data.CPUUsageInCores)
0000000000000000000000000000000000000000;;				dataMap[name].memUseData = append(dataMap[name].memUseData, data.MemoryUsageInBytes)
0000000000000000000000000000000000000000;;				dataMap[name].memWorkSetData = append(dataMap[name].memWorkSetData, data.MemoryWorkingSetInBytes)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range dataMap {
0000000000000000000000000000000000000000;;			sort.Float64s(v.cpuData)
0000000000000000000000000000000000000000;;			sort.Sort(uint64arr(v.memUseData))
0000000000000000000000000000000000000000;;			sort.Sort(uint64arr(v.memWorkSetData))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := make(map[int]ResourceUsagePerContainer)
0000000000000000000000000000000000000000;;		for _, perc := range percentilesToCompute {
0000000000000000000000000000000000000000;;			data := make(ResourceUsagePerContainer)
0000000000000000000000000000000000000000;;			for k, v := range dataMap {
0000000000000000000000000000000000000000;;				percentileIndex := int(math.Ceil(float64(len(v.cpuData)*perc)/100)) - 1
0000000000000000000000000000000000000000;;				data[k] = &ContainerResourceUsage{
0000000000000000000000000000000000000000;;					Name:                    k,
0000000000000000000000000000000000000000;;					CPUUsageInCores:         v.cpuData[percentileIndex],
0000000000000000000000000000000000000000;;					MemoryUsageInBytes:      v.memUseData[percentileIndex],
0000000000000000000000000000000000000000;;					MemoryWorkingSetInBytes: v.memWorkSetData[percentileIndex],
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result[perc] = data
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func leftMergeData(left, right map[int]ResourceUsagePerContainer) map[int]ResourceUsagePerContainer {
0000000000000000000000000000000000000000;;		result := make(map[int]ResourceUsagePerContainer)
0000000000000000000000000000000000000000;;		for percentile, data := range left {
0000000000000000000000000000000000000000;;			result[percentile] = data
0000000000000000000000000000000000000000;;			if _, ok := right[percentile]; !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k, v := range right[percentile] {
0000000000000000000000000000000000000000;;				result[percentile][k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type resourceGatherWorker struct {
0000000000000000000000000000000000000000;;		c            clientset.Interface
0000000000000000000000000000000000000000;;		nodeName     string
0000000000000000000000000000000000000000;;		wg           *sync.WaitGroup
0000000000000000000000000000000000000000;;		containerIDs []string
0000000000000000000000000000000000000000;;		stopCh       chan struct{}
0000000000000000000000000000000000000000;;		dataSeries   []ResourceUsagePerContainer
0000000000000000000000000000000000000000;;		finished     bool
0000000000000000000000000000000000000000;;		inKubemark   bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *resourceGatherWorker) singleProbe() {
0000000000000000000000000000000000000000;;		data := make(ResourceUsagePerContainer)
0000000000000000000000000000000000000000;;		if w.inKubemark {
0000000000000000000000000000000000000000;;			kubemarkData := GetKubemarkMasterComponentsResourceUsage()
0000000000000000000000000000000000000000;;			if data == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k, v := range kubemarkData {
0000000000000000000000000000000000000000;;				data[k] = &ContainerResourceUsage{
0000000000000000000000000000000000000000;;					Name: v.Name,
0000000000000000000000000000000000000000;;					MemoryWorkingSetInBytes: v.MemoryWorkingSetInBytes,
0000000000000000000000000000000000000000;;					CPUUsageInCores:         v.CPUUsageInCores,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			nodeUsage, err := getOneTimeResourceUsageOnNode(w.c, w.nodeName, probeDuration, func() []string { return w.containerIDs })
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				Logf("Error while reading data from %v: %v", w.nodeName, err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k, v := range nodeUsage {
0000000000000000000000000000000000000000;;				data[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.dataSeries = append(w.dataSeries, data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *resourceGatherWorker) gather(initialSleep time.Duration) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		defer w.wg.Done()
0000000000000000000000000000000000000000;;		defer Logf("Closing worker for %v", w.nodeName)
0000000000000000000000000000000000000000;;		defer func() { w.finished = true }()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-time.After(initialSleep):
0000000000000000000000000000000000000000;;			w.singleProbe()
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-time.After(resourceDataGatheringPeriod):
0000000000000000000000000000000000000000;;					w.singleProbe()
0000000000000000000000000000000000000000;;				case <-w.stopCh:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-w.stopCh:
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *containerResourceGatherer) getKubeSystemContainersResourceUsage(c clientset.Interface) {
0000000000000000000000000000000000000000;;		if len(g.workers) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delayPeriod := resourceDataGatheringPeriod / time.Duration(len(g.workers))
0000000000000000000000000000000000000000;;		delay := time.Duration(0)
0000000000000000000000000000000000000000;;		for i := range g.workers {
0000000000000000000000000000000000000000;;			go g.workers[i].gather(delay)
0000000000000000000000000000000000000000;;			delay += delayPeriod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.workerWg.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type containerResourceGatherer struct {
0000000000000000000000000000000000000000;;		client       clientset.Interface
0000000000000000000000000000000000000000;;		stopCh       chan struct{}
0000000000000000000000000000000000000000;;		workers      []resourceGatherWorker
0000000000000000000000000000000000000000;;		workerWg     sync.WaitGroup
0000000000000000000000000000000000000000;;		containerIDs []string
0000000000000000000000000000000000000000;;		options      ResourceGathererOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ResourceGathererOptions struct {
0000000000000000000000000000000000000000;;		inKubemark bool
0000000000000000000000000000000000000000;;		masterOnly bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewResourceUsageGatherer(c clientset.Interface, options ResourceGathererOptions) (*containerResourceGatherer, error) {
0000000000000000000000000000000000000000;;		g := containerResourceGatherer{
0000000000000000000000000000000000000000;;			client:       c,
0000000000000000000000000000000000000000;;			stopCh:       make(chan struct{}),
0000000000000000000000000000000000000000;;			containerIDs: make([]string, 0),
0000000000000000000000000000000000000000;;			options:      options,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options.inKubemark {
0000000000000000000000000000000000000000;;			g.workerWg.Add(1)
0000000000000000000000000000000000000000;;			g.workers = append(g.workers, resourceGatherWorker{
0000000000000000000000000000000000000000;;				inKubemark: true,
0000000000000000000000000000000000000000;;				stopCh:     g.stopCh,
0000000000000000000000000000000000000000;;				wg:         &g.workerWg,
0000000000000000000000000000000000000000;;				finished:   false,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			pods, err := c.Core().Pods("kube-system").List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				Logf("Error while listing Pods: %v", err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;				for _, container := range pod.Status.ContainerStatuses {
0000000000000000000000000000000000000000;;					g.containerIDs = append(g.containerIDs, container.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nodeList, err := c.Core().Nodes().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				Logf("Error while listing Nodes: %v", err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, node := range nodeList.Items {
0000000000000000000000000000000000000000;;				if !options.masterOnly || system.IsMasterNode(node.Name) {
0000000000000000000000000000000000000000;;					g.workerWg.Add(1)
0000000000000000000000000000000000000000;;					g.workers = append(g.workers, resourceGatherWorker{
0000000000000000000000000000000000000000;;						c:            c,
0000000000000000000000000000000000000000;;						nodeName:     node.Name,
0000000000000000000000000000000000000000;;						wg:           &g.workerWg,
0000000000000000000000000000000000000000;;						containerIDs: g.containerIDs,
0000000000000000000000000000000000000000;;						stopCh:       g.stopCh,
0000000000000000000000000000000000000000;;						finished:     false,
0000000000000000000000000000000000000000;;						inKubemark:   false,
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;					if options.masterOnly {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &g, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// startGatheringData blocks until stopAndSummarize is called.
0000000000000000000000000000000000000000;;	func (g *containerResourceGatherer) startGatheringData() {
0000000000000000000000000000000000000000;;		g.getKubeSystemContainersResourceUsage(g.client)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *containerResourceGatherer) stopAndSummarize(percentiles []int, constraints map[string]ResourceConstraint) (*ResourceUsageSummary, error) {
0000000000000000000000000000000000000000;;		close(g.stopCh)
0000000000000000000000000000000000000000;;		Logf("Closed stop channel. Waiting for %v workers", len(g.workers))
0000000000000000000000000000000000000000;;		finished := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			g.workerWg.Wait()
0000000000000000000000000000000000000000;;			finished <- struct{}{}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-finished:
0000000000000000000000000000000000000000;;			Logf("Waitgroup finished.")
0000000000000000000000000000000000000000;;		case <-time.After(2 * time.Minute):
0000000000000000000000000000000000000000;;			unfinished := make([]string, 0)
0000000000000000000000000000000000000000;;			for i := range g.workers {
0000000000000000000000000000000000000000;;				if !g.workers[i].finished {
0000000000000000000000000000000000000000;;					unfinished = append(unfinished, g.workers[i].nodeName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Logf("Timed out while waiting for waitgroup, some workers failed to finish: %v", unfinished)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(percentiles) == 0 {
0000000000000000000000000000000000000000;;			Logf("Warning! Empty percentile list for stopAndPrintData.")
0000000000000000000000000000000000000000;;			return &ResourceUsageSummary{}, fmt.Errorf("Failed to get any resource usage data")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data := make(map[int]ResourceUsagePerContainer)
0000000000000000000000000000000000000000;;		for i := range g.workers {
0000000000000000000000000000000000000000;;			if g.workers[i].finished {
0000000000000000000000000000000000000000;;				stats := computePercentiles(g.workers[i].dataSeries, percentiles)
0000000000000000000000000000000000000000;;				data = leftMergeData(stats, data)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Workers has been stopped. We need to gather data stored in them.
0000000000000000000000000000000000000000;;		sortedKeys := []string{}
0000000000000000000000000000000000000000;;		for name := range data[percentiles[0]] {
0000000000000000000000000000000000000000;;			sortedKeys = append(sortedKeys, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(sortedKeys)
0000000000000000000000000000000000000000;;		violatedConstraints := make([]string, 0)
0000000000000000000000000000000000000000;;		summary := make(ResourceUsageSummary)
0000000000000000000000000000000000000000;;		for _, perc := range percentiles {
0000000000000000000000000000000000000000;;			for _, name := range sortedKeys {
0000000000000000000000000000000000000000;;				usage := data[perc][name]
0000000000000000000000000000000000000000;;				summary[strconv.Itoa(perc)] = append(summary[strconv.Itoa(perc)], SingleContainerSummary{
0000000000000000000000000000000000000000;;					Name: name,
0000000000000000000000000000000000000000;;					Cpu:  usage.CPUUsageInCores,
0000000000000000000000000000000000000000;;					Mem:  usage.MemoryWorkingSetInBytes,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				// Verifying 99th percentile of resource usage
0000000000000000000000000000000000000000;;				if perc == 99 {
0000000000000000000000000000000000000000;;					// Name has a form: <pod_name>/<container_name>
0000000000000000000000000000000000000000;;					containerName := strings.Split(name, "/")[1]
0000000000000000000000000000000000000000;;					if constraint, ok := constraints[containerName]; ok {
0000000000000000000000000000000000000000;;						if usage.CPUUsageInCores > constraint.CPUConstraint {
0000000000000000000000000000000000000000;;							violatedConstraints = append(
0000000000000000000000000000000000000000;;								violatedConstraints,
0000000000000000000000000000000000000000;;								fmt.Sprintf("Container %v is using %v/%v CPU",
0000000000000000000000000000000000000000;;									name,
0000000000000000000000000000000000000000;;									usage.CPUUsageInCores,
0000000000000000000000000000000000000000;;									constraint.CPUConstraint,
0000000000000000000000000000000000000000;;								),
0000000000000000000000000000000000000000;;							)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if usage.MemoryWorkingSetInBytes > constraint.MemoryConstraint {
0000000000000000000000000000000000000000;;							violatedConstraints = append(
0000000000000000000000000000000000000000;;								violatedConstraints,
0000000000000000000000000000000000000000;;								fmt.Sprintf("Container %v is using %v/%v MB of memory",
0000000000000000000000000000000000000000;;									name,
0000000000000000000000000000000000000000;;									float64(usage.MemoryWorkingSetInBytes)/(1024*1024),
0000000000000000000000000000000000000000;;									float64(constraint.MemoryConstraint)/(1024*1024),
0000000000000000000000000000000000000000;;								),
0000000000000000000000000000000000000000;;							)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(violatedConstraints) > 0 {
0000000000000000000000000000000000000000;;			return &summary, fmt.Errorf(strings.Join(violatedConstraints, "\n"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &summary, nil
0000000000000000000000000000000000000000;;	}
