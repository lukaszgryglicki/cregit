0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
519ea2fe07e0c48a9b594cf21f9ad923ca8050e3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		apiservice "k8s.io/kubernetes/pkg/api/v1/service"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		gcecloud "k8s.io/kubernetes/pkg/cloudprovider/providers/gce"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		compute "google.golang.org/api/compute/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		FirewallTimeoutDefault = 3 * time.Minute
0000000000000000000000000000000000000000;;		FirewallTestTcpTimeout = time.Duration(1 * time.Second)
0000000000000000000000000000000000000000;;		// Set ports outside of 30000-32767, 80 and 8080 to avoid being whitelisted by the e2e cluster
0000000000000000000000000000000000000000;;		FirewallTestHttpPort = int32(29999)
0000000000000000000000000000000000000000;;		FirewallTestUdpPort  = int32(29998)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MakeFirewallNameForLBService return the expected firewall name for a LB service.
0000000000000000000000000000000000000000;;	// This should match the formatting of makeFirewallName() in pkg/cloudprovider/providers/gce/gce_loadbalancer.go
0000000000000000000000000000000000000000;;	func MakeFirewallNameForLBService(name string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("k8s-fw-%s", name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConstructFirewallForLBService returns the expected GCE firewall rule for a loadbalancer type service
0000000000000000000000000000000000000000;;	func ConstructFirewallForLBService(svc *v1.Service, nodeTag string) *compute.Firewall {
0000000000000000000000000000000000000000;;		if svc.Spec.Type != v1.ServiceTypeLoadBalancer {
0000000000000000000000000000000000000000;;			Failf("can not construct firewall rule for non-loadbalancer type service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fw := compute.Firewall{}
0000000000000000000000000000000000000000;;		fw.Name = MakeFirewallNameForLBService(cloudprovider.GetLoadBalancerName(svc))
0000000000000000000000000000000000000000;;		fw.TargetTags = []string{nodeTag}
0000000000000000000000000000000000000000;;		if svc.Spec.LoadBalancerSourceRanges == nil {
0000000000000000000000000000000000000000;;			fw.SourceRanges = []string{"0.0.0.0/0"}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			fw.SourceRanges = svc.Spec.LoadBalancerSourceRanges
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, sp := range svc.Spec.Ports {
0000000000000000000000000000000000000000;;			fw.Allowed = append(fw.Allowed, &compute.FirewallAllowed{
0000000000000000000000000000000000000000;;				IPProtocol: strings.ToLower(string(sp.Protocol)),
0000000000000000000000000000000000000000;;				Ports:      []string{strconv.Itoa(int(sp.Port))},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &fw
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MakeHealthCheckFirewallNameForLBService(clusterID, name string, isNodesHealthCheck bool) string {
0000000000000000000000000000000000000000;;		return gcecloud.MakeHealthCheckFirewallName(clusterID, name, isNodesHealthCheck)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConstructHealthCheckFirewallForLBService returns the expected GCE firewall rule for a loadbalancer type service
0000000000000000000000000000000000000000;;	func ConstructHealthCheckFirewallForLBService(clusterID string, svc *v1.Service, nodeTag string, isNodesHealthCheck bool) *compute.Firewall {
0000000000000000000000000000000000000000;;		if svc.Spec.Type != v1.ServiceTypeLoadBalancer {
0000000000000000000000000000000000000000;;			Failf("can not construct firewall rule for non-loadbalancer type service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fw := compute.Firewall{}
0000000000000000000000000000000000000000;;		fw.Name = MakeHealthCheckFirewallNameForLBService(clusterID, cloudprovider.GetLoadBalancerName(svc), isNodesHealthCheck)
0000000000000000000000000000000000000000;;		fw.TargetTags = []string{nodeTag}
0000000000000000000000000000000000000000;;		fw.SourceRanges = gcecloud.LoadBalancerSrcRanges()
0000000000000000000000000000000000000000;;		healthCheckPort := gcecloud.GetNodesHealthCheckPort()
0000000000000000000000000000000000000000;;		if !isNodesHealthCheck {
0000000000000000000000000000000000000000;;			healthCheckPort = apiservice.GetServiceHealthCheckNodePort(svc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fw.Allowed = []*compute.FirewallAllowed{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				IPProtocol: "tcp",
0000000000000000000000000000000000000000;;				Ports:      []string{fmt.Sprintf("%d", healthCheckPort)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &fw
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetInstanceTags gets tags from GCE instance with given name.
0000000000000000000000000000000000000000;;	func GetInstanceTags(cloudConfig CloudConfig, instanceName string) *compute.Tags {
0000000000000000000000000000000000000000;;		gceCloud := cloudConfig.Provider.(*gcecloud.GCECloud)
0000000000000000000000000000000000000000;;		res, err := gceCloud.GetComputeService().Instances.Get(cloudConfig.ProjectID, cloudConfig.Zone,
0000000000000000000000000000000000000000;;			instanceName).Do()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("Failed to get instance tags for %v: %v", instanceName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res.Tags
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetInstanceTags sets tags on GCE instance with given name.
0000000000000000000000000000000000000000;;	func SetInstanceTags(cloudConfig CloudConfig, instanceName, zone string, tags []string) []string {
0000000000000000000000000000000000000000;;		gceCloud := cloudConfig.Provider.(*gcecloud.GCECloud)
0000000000000000000000000000000000000000;;		// Re-get instance everytime because we need the latest fingerprint for updating metadata
0000000000000000000000000000000000000000;;		resTags := GetInstanceTags(cloudConfig, instanceName)
0000000000000000000000000000000000000000;;		_, err := gceCloud.GetComputeService().Instances.SetTags(
0000000000000000000000000000000000000000;;			cloudConfig.ProjectID, zone, instanceName,
0000000000000000000000000000000000000000;;			&compute.Tags{Fingerprint: resTags.Fingerprint, Items: tags}).Do()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("failed to set instance tags: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Logf("Sent request to set tags %v on instance: %v", tags, instanceName)
0000000000000000000000000000000000000000;;		return resTags.Items
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetNodeTags gets k8s node tag from one of the nodes
0000000000000000000000000000000000000000;;	func GetNodeTags(c clientset.Interface, cloudConfig CloudConfig) []string {
0000000000000000000000000000000000000000;;		nodes := GetReadySchedulableNodesOrDie(c)
0000000000000000000000000000000000000000;;		if len(nodes.Items) == 0 {
0000000000000000000000000000000000000000;;			Logf("GetNodeTags: Found 0 node.")
0000000000000000000000000000000000000000;;			return []string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return GetInstanceTags(cloudConfig, nodes.Items[0].Name).Items
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetInstancePrefix returns the INSTANCE_PREFIX env we set for e2e cluster.
0000000000000000000000000000000000000000;;	// From cluster/gce/config-test.sh, master name is set up using below format:
0000000000000000000000000000000000000000;;	// MASTER_NAME="${INSTANCE_PREFIX}-master"
0000000000000000000000000000000000000000;;	func GetInstancePrefix(masterName string) (string, error) {
0000000000000000000000000000000000000000;;		if !strings.HasSuffix(masterName, "-master") {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unexpected master name format: %v", masterName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return masterName[:len(masterName)-7], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetClusterName returns the CLUSTER_NAME env we set for e2e cluster.
0000000000000000000000000000000000000000;;	// From cluster/gce/config-test.sh, cluster name is set up using below format:
0000000000000000000000000000000000000000;;	// CLUSTER_NAME="${CLUSTER_NAME:-${INSTANCE_PREFIX}}"
0000000000000000000000000000000000000000;;	func GetClusterName(instancePrefix string) string {
0000000000000000000000000000000000000000;;		return instancePrefix
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetE2eFirewalls returns all firewall rules we create for an e2e cluster.
0000000000000000000000000000000000000000;;	// From cluster/gce/util.sh, all firewall rules should be consistent with the ones created by startup scripts.
0000000000000000000000000000000000000000;;	func GetE2eFirewalls(masterName, masterTag, nodeTag, network, clusterIpRange string) []*compute.Firewall {
0000000000000000000000000000000000000000;;		instancePrefix, err := GetInstancePrefix(masterName)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		clusterName := GetClusterName(instancePrefix)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fws := []*compute.Firewall{}
0000000000000000000000000000000000000000;;		fws = append(fws, &compute.Firewall{
0000000000000000000000000000000000000000;;			Name:         clusterName + "-default-internal-master",
0000000000000000000000000000000000000000;;			SourceRanges: []string{"10.0.0.0/8"},
0000000000000000000000000000000000000000;;			TargetTags:   []string{masterTag},
0000000000000000000000000000000000000000;;			Allowed: []*compute.FirewallAllowed{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "tcp",
0000000000000000000000000000000000000000;;					Ports:      []string{"1-2379"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "tcp",
0000000000000000000000000000000000000000;;					Ports:      []string{"2382-65535"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "udp",
0000000000000000000000000000000000000000;;					Ports:      []string{"1-65535"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "icmp",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fws = append(fws, &compute.Firewall{
0000000000000000000000000000000000000000;;			Name:         clusterName + "-default-internal-node",
0000000000000000000000000000000000000000;;			SourceRanges: []string{"10.0.0.0/8"},
0000000000000000000000000000000000000000;;			TargetTags:   []string{nodeTag},
0000000000000000000000000000000000000000;;			Allowed: []*compute.FirewallAllowed{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "tcp",
0000000000000000000000000000000000000000;;					Ports:      []string{"1-65535"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "udp",
0000000000000000000000000000000000000000;;					Ports:      []string{"1-65535"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "icmp",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fws = append(fws, &compute.Firewall{
0000000000000000000000000000000000000000;;			Name:         network + "-default-ssh",
0000000000000000000000000000000000000000;;			SourceRanges: []string{"0.0.0.0/0"},
0000000000000000000000000000000000000000;;			Allowed: []*compute.FirewallAllowed{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "tcp",
0000000000000000000000000000000000000000;;					Ports:      []string{"22"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fws = append(fws, &compute.Firewall{
0000000000000000000000000000000000000000;;			Name:       masterName + "-etcd",
0000000000000000000000000000000000000000;;			SourceTags: []string{masterTag},
0000000000000000000000000000000000000000;;			TargetTags: []string{masterTag},
0000000000000000000000000000000000000000;;			Allowed: []*compute.FirewallAllowed{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "tcp",
0000000000000000000000000000000000000000;;					Ports:      []string{"2380"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "tcp",
0000000000000000000000000000000000000000;;					Ports:      []string{"2381"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fws = append(fws, &compute.Firewall{
0000000000000000000000000000000000000000;;			Name:         masterName + "-https",
0000000000000000000000000000000000000000;;			SourceRanges: []string{"0.0.0.0/0"},
0000000000000000000000000000000000000000;;			TargetTags:   []string{masterTag},
0000000000000000000000000000000000000000;;			Allowed: []*compute.FirewallAllowed{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "tcp",
0000000000000000000000000000000000000000;;					Ports:      []string{"443"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fws = append(fws, &compute.Firewall{
0000000000000000000000000000000000000000;;			Name:         nodeTag + "-all",
0000000000000000000000000000000000000000;;			SourceRanges: []string{clusterIpRange},
0000000000000000000000000000000000000000;;			TargetTags:   []string{nodeTag},
0000000000000000000000000000000000000000;;			Allowed: []*compute.FirewallAllowed{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "tcp",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "udp",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "icmp",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "esp",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "ah",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "sctp",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fws = append(fws, &compute.Firewall{
0000000000000000000000000000000000000000;;			Name:         nodeTag + "-" + instancePrefix + "-http-alt",
0000000000000000000000000000000000000000;;			SourceRanges: []string{"0.0.0.0/0"},
0000000000000000000000000000000000000000;;			TargetTags:   []string{nodeTag},
0000000000000000000000000000000000000000;;			Allowed: []*compute.FirewallAllowed{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "tcp",
0000000000000000000000000000000000000000;;					Ports:      []string{"80"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "tcp",
0000000000000000000000000000000000000000;;					Ports:      []string{"8080"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fws = append(fws, &compute.Firewall{
0000000000000000000000000000000000000000;;			Name:         nodeTag + "-" + instancePrefix + "-nodeports",
0000000000000000000000000000000000000000;;			SourceRanges: []string{"0.0.0.0/0"},
0000000000000000000000000000000000000000;;			TargetTags:   []string{nodeTag},
0000000000000000000000000000000000000000;;			Allowed: []*compute.FirewallAllowed{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "tcp",
0000000000000000000000000000000000000000;;					Ports:      []string{"30000-32767"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: "udp",
0000000000000000000000000000000000000000;;					Ports:      []string{"30000-32767"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return fws
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PackProtocolsPortsFromFirewall packs protocols and ports in an unified way for verification.
0000000000000000000000000000000000000000;;	func PackProtocolsPortsFromFirewall(alloweds []*compute.FirewallAllowed) []string {
0000000000000000000000000000000000000000;;		protocolPorts := []string{}
0000000000000000000000000000000000000000;;		for _, allowed := range alloweds {
0000000000000000000000000000000000000000;;			for _, port := range allowed.Ports {
0000000000000000000000000000000000000000;;				protocolPorts = append(protocolPorts, strings.ToLower(allowed.IPProtocol+"/"+port))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return protocolPorts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SameStringArray verifies whether two string arrays have the same strings, return error if not.
0000000000000000000000000000000000000000;;	// Order does not matter.
0000000000000000000000000000000000000000;;	// When `include` is set to true, verifies whether result includes all elements from expected.
0000000000000000000000000000000000000000;;	func SameStringArray(result, expected []string, include bool) error {
0000000000000000000000000000000000000000;;		res := sets.NewString(result...)
0000000000000000000000000000000000000000;;		exp := sets.NewString(expected...)
0000000000000000000000000000000000000000;;		if !include {
0000000000000000000000000000000000000000;;			diff := res.Difference(exp)
0000000000000000000000000000000000000000;;			if len(diff) != 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("found differences: %v", diff)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if !res.IsSuperset(exp) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("some elements are missing: expected %v, got %v", expected, result)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifyFirewallRule verifies whether the result firewall is consistent with the expected firewall.
0000000000000000000000000000000000000000;;	// When `portsSubset` is false, match given ports exactly. Otherwise, only check ports are included.
0000000000000000000000000000000000000000;;	func VerifyFirewallRule(res, exp *compute.Firewall, network string, portsSubset bool) error {
0000000000000000000000000000000000000000;;		if res == nil || exp == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("res and exp must not be nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if res.Name != exp.Name {
0000000000000000000000000000000000000000;;			return fmt.Errorf("incorrect name: %v, expected %v", res.Name, exp.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Sample Network value: https://www.googleapis.com/compute/v1/projects/{project-id}/global/networks/e2e
0000000000000000000000000000000000000000;;		if !strings.HasSuffix(res.Network, "/"+network) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("incorrect network: %v, expected ends with: %v", res.Network, "/"+network)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := SameStringArray(PackProtocolsPortsFromFirewall(res.Allowed),
0000000000000000000000000000000000000000;;			PackProtocolsPortsFromFirewall(exp.Allowed), portsSubset); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("incorrect allowed protocols ports: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := SameStringArray(res.SourceRanges, exp.SourceRanges, false); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("incorrect source ranges %v, expected %v: %v", res.SourceRanges, exp.SourceRanges, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := SameStringArray(res.SourceTags, exp.SourceTags, false); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("incorrect source tags %v, expected %v: %v", res.SourceTags, exp.SourceTags, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := SameStringArray(res.TargetTags, exp.TargetTags, false); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("incorrect target tags %v, expected %v: %v", res.TargetTags, exp.TargetTags, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func WaitForFirewallRule(gceCloud *gcecloud.GCECloud, fwName string, exist bool, timeout time.Duration) (*compute.Firewall, error) {
0000000000000000000000000000000000000000;;		Logf("Waiting up to %v for firewall %v exist=%v", timeout, fwName, exist)
0000000000000000000000000000000000000000;;		var fw *compute.Firewall
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		condition := func() (bool, error) {
0000000000000000000000000000000000000000;;			fw, err = gceCloud.GetFirewall(fwName)
0000000000000000000000000000000000000000;;			if err != nil && exist ||
0000000000000000000000000000000000000000;;				err == nil && !exist ||
0000000000000000000000000000000000000000;;				err != nil && !exist && !IsGoogleAPIHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(5*time.Second, timeout, condition); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error waiting for firewall %v exist=%v", fwName, exist)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fw, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetClusterID(c clientset.Interface) (string, error) {
0000000000000000000000000000000000000000;;		cm, err := c.Core().ConfigMaps(metav1.NamespaceSystem).Get(gcecloud.UIDConfigMapName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil || cm == nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("error getting cluster ID: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clusterID, clusterIDExists := cm.Data[gcecloud.UIDCluster]
0000000000000000000000000000000000000000;;		providerID, providerIDExists := cm.Data[gcecloud.UIDProvider]
0000000000000000000000000000000000000000;;		if !clusterIDExists {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("cluster ID not set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if providerIDExists {
0000000000000000000000000000000000000000;;			return providerID, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clusterID, nil
0000000000000000000000000000000000000000;;	}
