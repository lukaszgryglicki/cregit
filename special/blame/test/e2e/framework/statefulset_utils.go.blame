0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
23e6e0d7074962817554d82608eba0c21c60cac6;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apps "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrs "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/manifest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Poll interval for StatefulSet tests
0000000000000000000000000000000000000000;;		StatefulSetPoll = 10 * time.Second
0000000000000000000000000000000000000000;;		// Timeout interval for StatefulSet operations
0000000000000000000000000000000000000000;;		StatefulSetTimeout = 10 * time.Minute
0000000000000000000000000000000000000000;;		// Timeout for stateful pods to change state
0000000000000000000000000000000000000000;;		StatefulPodTimeout = 5 * time.Minute
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateStatefulSetService creates a Headless Service with Name name and Selector set to match labels.
0000000000000000000000000000000000000000;;	func CreateStatefulSetService(name string, labels map[string]string) *v1.Service {
0000000000000000000000000000000000000000;;		headlessService := &v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: labels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headlessService.Spec.Ports = []v1.ServicePort{
0000000000000000000000000000000000000000;;			{Port: 80, Name: "http", Protocol: "TCP"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headlessService.Spec.ClusterIP = "None"
0000000000000000000000000000000000000000;;		return headlessService
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatefulSetTester is a struct that contains utility methods for testing StatefulSet related functionality. It uses a
0000000000000000000000000000000000000000;;	// clientset.Interface to communicate with the API server.
0000000000000000000000000000000000000000;;	type StatefulSetTester struct {
0000000000000000000000000000000000000000;;		c clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewStatefulSetTester creates a StatefulSetTester that uses c to interact with the API server.
0000000000000000000000000000000000000000;;	func NewStatefulSetTester(c clientset.Interface) *StatefulSetTester {
0000000000000000000000000000000000000000;;		return &StatefulSetTester{c}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetStatefulSet gets the StatefulSet named name in namespace.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) GetStatefulSet(namespace, name string) *apps.StatefulSet {
0000000000000000000000000000000000000000;;		ss, err := s.c.Apps().StatefulSets(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("Failed to get StatefulSet %s/%s: %v", namespace, name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ss
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateStatefulSet creates a StatefulSet from the manifest at manifestPath in the Namespace ns using kubectl create.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) CreateStatefulSet(manifestPath, ns string) *apps.StatefulSet {
0000000000000000000000000000000000000000;;		mkpath := func(file string) string {
0000000000000000000000000000000000000000;;			return filepath.Join(manifestPath, file)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Logf("Parsing statefulset from %v", mkpath("statefulset.yaml"))
0000000000000000000000000000000000000000;;		ss, err := manifest.StatefulSetFromManifest(mkpath("statefulset.yaml"), ns)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Logf("Parsing service from %v", mkpath("service.yaml"))
0000000000000000000000000000000000000000;;		svc, err := manifest.SvcFromManifest(mkpath("service.yaml"))
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Logf(fmt.Sprintf("creating " + ss.Name + " service"))
0000000000000000000000000000000000000000;;		_, err = s.c.CoreV1().Services(ns).Create(svc)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Logf(fmt.Sprintf("creating statefulset %v/%v with %d replicas and selector %+v", ss.Namespace, ss.Name, *(ss.Spec.Replicas), ss.Spec.Selector))
0000000000000000000000000000000000000000;;		_, err = s.c.AppsV1beta1().StatefulSets(ns).Create(ss)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		s.WaitForRunningAndReady(*ss.Spec.Replicas, ss)
0000000000000000000000000000000000000000;;		return ss
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckMount checks that the mount at mountPath is valid for all Pods in ss.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) CheckMount(ss *apps.StatefulSet, mountPath string) error {
0000000000000000000000000000000000000000;;		for _, cmd := range []string{
0000000000000000000000000000000000000000;;			// Print inode, size etc
0000000000000000000000000000000000000000;;			fmt.Sprintf("ls -idlh %v", mountPath),
0000000000000000000000000000000000000000;;			// Print subdirs
0000000000000000000000000000000000000000;;			fmt.Sprintf("find %v", mountPath),
0000000000000000000000000000000000000000;;			// Try writing
0000000000000000000000000000000000000000;;			fmt.Sprintf("touch %v", filepath.Join(mountPath, fmt.Sprintf("%v", time.Now().UnixNano()))),
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			if err := s.ExecInStatefulPods(ss, cmd); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to execute %v, error: %v", cmd, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExecInStatefulPods executes cmd in all Pods in ss. If a error occurs it is returned and cmd is not execute in any subsequent Pods.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) ExecInStatefulPods(ss *apps.StatefulSet, cmd string) error {
0000000000000000000000000000000000000000;;		podList := s.GetPodList(ss)
0000000000000000000000000000000000000000;;		for _, statefulPod := range podList.Items {
0000000000000000000000000000000000000000;;			stdout, err := RunHostCmd(statefulPod.Namespace, statefulPod.Name, cmd)
0000000000000000000000000000000000000000;;			Logf("stdout of %v on %v: %v", cmd, statefulPod.Name, stdout)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckHostname verifies that all Pods in ss have the correct Hostname. If the returned error is not nil than verification failed.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) CheckHostname(ss *apps.StatefulSet) error {
0000000000000000000000000000000000000000;;		cmd := "printf $(hostname)"
0000000000000000000000000000000000000000;;		podList := s.GetPodList(ss)
0000000000000000000000000000000000000000;;		for _, statefulPod := range podList.Items {
0000000000000000000000000000000000000000;;			hostname, err := RunHostCmd(statefulPod.Namespace, statefulPod.Name, cmd)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hostname != statefulPod.Name {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unexpected hostname (%s) and stateful pod name (%s) not equal", hostname, statefulPod.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Saturate waits for all Pods in ss to become Running and Ready.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) Saturate(ss *apps.StatefulSet) {
0000000000000000000000000000000000000000;;		var i int32
0000000000000000000000000000000000000000;;		for i = 0; i < *(ss.Spec.Replicas); i++ {
0000000000000000000000000000000000000000;;			Logf("Waiting for stateful pod at index " + fmt.Sprintf("%v", i+1) + " to enter Running")
0000000000000000000000000000000000000000;;			s.WaitForRunningAndReady(i+1, ss)
0000000000000000000000000000000000000000;;			Logf("Marking stateful pod at index " + fmt.Sprintf("%v", i) + " healthy")
0000000000000000000000000000000000000000;;			s.SetHealthy(ss)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteStatefulPodAtIndex deletes the Pod with ordinal index in ss.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) DeleteStatefulPodAtIndex(index int, ss *apps.StatefulSet) {
0000000000000000000000000000000000000000;;		name := getStatefulSetPodNameAtIndex(index, ss)
0000000000000000000000000000000000000000;;		noGrace := int64(0)
0000000000000000000000000000000000000000;;		if err := s.c.Core().Pods(ss.Namespace).Delete(name, &metav1.DeleteOptions{GracePeriodSeconds: &noGrace}); err != nil {
0000000000000000000000000000000000000000;;			Failf("Failed to delete stateful pod %v for StatefulSet %v/%v: %v", name, ss.Namespace, ss.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifyStatefulPodFunc is a func that examines a StatefulSetPod.
0000000000000000000000000000000000000000;;	type VerifyStatefulPodFunc func(*v1.Pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifyPodAtIndex applies a visitor patter to the Pod at index in ss. verify is is applied to the Pod to "visit" it.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) VerifyPodAtIndex(index int, ss *apps.StatefulSet, verify VerifyStatefulPodFunc) {
0000000000000000000000000000000000000000;;		name := getStatefulSetPodNameAtIndex(index, ss)
0000000000000000000000000000000000000000;;		pod, err := s.c.Core().Pods(ss.Namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Failed to get stateful pod %s for StatefulSet %s/%s", name, ss.Namespace, ss.Name))
0000000000000000000000000000000000000000;;		verify(pod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getStatefulSetPodNameAtIndex(index int, ss *apps.StatefulSet) string {
0000000000000000000000000000000000000000;;		// TODO: we won't use "-index" as the name strategy forever,
0000000000000000000000000000000000000000;;		// pull the name out from an identity mapper.
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%v-%v", ss.Name, index)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scale scales ss to count replicas.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) Scale(ss *apps.StatefulSet, count int32) error {
0000000000000000000000000000000000000000;;		name := ss.Name
0000000000000000000000000000000000000000;;		ns := ss.Namespace
0000000000000000000000000000000000000000;;		s.update(ns, name, func(ss *apps.StatefulSet) { *(ss.Spec.Replicas) = count })
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var statefulPodList *v1.PodList
0000000000000000000000000000000000000000;;		pollErr := wait.PollImmediate(StatefulSetPoll, StatefulSetTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			statefulPodList = s.GetPodList(ss)
0000000000000000000000000000000000000000;;			if int32(len(statefulPodList.Items)) == count {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if pollErr != nil {
0000000000000000000000000000000000000000;;			unhealthy := []string{}
0000000000000000000000000000000000000000;;			for _, statefulPod := range statefulPodList.Items {
0000000000000000000000000000000000000000;;				delTs, phase, readiness := statefulPod.DeletionTimestamp, statefulPod.Status.Phase, podutil.IsPodReady(&statefulPod)
0000000000000000000000000000000000000000;;				if delTs != nil || phase != v1.PodRunning || !readiness {
0000000000000000000000000000000000000000;;					unhealthy = append(unhealthy, fmt.Sprintf("%v: deletion %v, phase %v, readiness %v", statefulPod.Name, delTs, phase, readiness))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to scale statefulset to %d in %v. Remaining pods:\n%v", count, StatefulSetTimeout, unhealthy)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateReplicas updates the replicas of ss to count.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) UpdateReplicas(ss *apps.StatefulSet, count int32) {
0000000000000000000000000000000000000000;;		s.update(ss.Namespace, ss.Name, func(ss *apps.StatefulSet) { ss.Spec.Replicas = &count })
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Restart scales ss to 0 and then back to its previous number of replicas.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) Restart(ss *apps.StatefulSet) {
0000000000000000000000000000000000000000;;		oldReplicas := *(ss.Spec.Replicas)
0000000000000000000000000000000000000000;;		ExpectNoError(s.Scale(ss, 0))
0000000000000000000000000000000000000000;;		s.update(ss.Namespace, ss.Name, func(ss *apps.StatefulSet) { *(ss.Spec.Replicas) = oldReplicas })
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) update(ns, name string, update func(ss *apps.StatefulSet)) {
0000000000000000000000000000000000000000;;		for i := 0; i < 3; i++ {
0000000000000000000000000000000000000000;;			ss, err := s.c.Apps().StatefulSets(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				Failf("failed to get statefulset %q: %v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			update(ss)
0000000000000000000000000000000000000000;;			ss, err = s.c.Apps().StatefulSets(ns).Update(ss)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !apierrs.IsConflict(err) && !apierrs.IsServerTimeout(err) {
0000000000000000000000000000000000000000;;				Failf("failed to update statefulset %q: %v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Failf("too many retries draining statefulset %q", name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPodList gets the current Pods in ss.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) GetPodList(ss *apps.StatefulSet) *v1.PodList {
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(ss.Spec.Selector)
0000000000000000000000000000000000000000;;		ExpectNoError(err)
0000000000000000000000000000000000000000;;		podList, err := s.c.Core().Pods(ss.Namespace).List(metav1.ListOptions{LabelSelector: selector.String()})
0000000000000000000000000000000000000000;;		ExpectNoError(err)
0000000000000000000000000000000000000000;;		return podList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfirmStatefulPodCount asserts that the current number of Pods in ss is count waiting up to timeout for ss to
0000000000000000000000000000000000000000;;	// to scale to count.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) ConfirmStatefulPodCount(count int, ss *apps.StatefulSet, timeout time.Duration, hard bool) {
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;		deadline := start.Add(timeout)
0000000000000000000000000000000000000000;;		for t := time.Now(); t.Before(deadline); t = time.Now() {
0000000000000000000000000000000000000000;;			podList := s.GetPodList(ss)
0000000000000000000000000000000000000000;;			statefulPodCount := len(podList.Items)
0000000000000000000000000000000000000000;;			if statefulPodCount != count {
0000000000000000000000000000000000000000;;				logPodStates(podList.Items)
0000000000000000000000000000000000000000;;				if hard {
0000000000000000000000000000000000000000;;					Failf("StatefulSet %v scaled unexpectedly scaled to %d -> %d replicas", ss.Name, count, len(podList.Items))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					Logf("StatefulSet %v has not reached scale %d, at %d", ss.Name, count, statefulPodCount)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				time.Sleep(1 * time.Second)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Logf("Verifying statefulset %v doesn't scale past %d for another %+v", ss.Name, count, deadline.Sub(t))
0000000000000000000000000000000000000000;;			time.Sleep(1 * time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) waitForRunning(numStatefulPods int32, ss *apps.StatefulSet, shouldBeReady bool) {
0000000000000000000000000000000000000000;;		pollErr := wait.PollImmediate(StatefulSetPoll, StatefulSetTimeout,
0000000000000000000000000000000000000000;;			func() (bool, error) {
0000000000000000000000000000000000000000;;				podList := s.GetPodList(ss)
0000000000000000000000000000000000000000;;				if int32(len(podList.Items)) < numStatefulPods {
0000000000000000000000000000000000000000;;					Logf("Found %d stateful pods, waiting for %d", len(podList.Items), numStatefulPods)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if int32(len(podList.Items)) > numStatefulPods {
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("Too many pods scheduled, expected %d got %d", numStatefulPods, len(podList.Items))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, p := range podList.Items {
0000000000000000000000000000000000000000;;					isReady := podutil.IsPodReady(&p)
0000000000000000000000000000000000000000;;					desiredReadiness := shouldBeReady == isReady
0000000000000000000000000000000000000000;;					Logf("Waiting for pod %v to enter %v - Ready=%v, currently %v - Ready=%v", p.Name, v1.PodRunning, shouldBeReady, p.Status.Phase, isReady)
0000000000000000000000000000000000000000;;					if p.Status.Phase != v1.PodRunning || !desiredReadiness {
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		if pollErr != nil {
0000000000000000000000000000000000000000;;			Failf("Failed waiting for pods to enter running: %v", pollErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForState periodically polls for the ss and its pods until the until function returns either true or an error
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) WaitForState(ss *apps.StatefulSet, until func(*apps.StatefulSet, *v1.PodList) (bool, error)) {
0000000000000000000000000000000000000000;;		pollErr := wait.PollImmediate(StatefulSetPoll, StatefulSetTimeout,
0000000000000000000000000000000000000000;;			func() (bool, error) {
0000000000000000000000000000000000000000;;				ssGet, err := s.c.Apps().StatefulSets(ss.Namespace).Get(ss.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				podList := s.GetPodList(ssGet)
0000000000000000000000000000000000000000;;				return until(ssGet, podList)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		if pollErr != nil {
0000000000000000000000000000000000000000;;			Failf("Failed waiting for state update: %v", pollErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForStatus waits for the StatefulSetStatus's ObservedGeneration to be greater than or equal to set's Generation.
0000000000000000000000000000000000000000;;	// The returned StatefulSet contains such a StatefulSetStatus
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) WaitForStatus(set *apps.StatefulSet) *apps.StatefulSet {
0000000000000000000000000000000000000000;;		s.WaitForState(set, func(set2 *apps.StatefulSet, pods *v1.PodList) (bool, error) {
0000000000000000000000000000000000000000;;			if set2.Status.ObservedGeneration != nil && *set2.Status.ObservedGeneration >= set.Generation {
0000000000000000000000000000000000000000;;				set = set2
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return set
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForRunningAndReady waits for numStatefulPods in ss to be Running and Ready.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) WaitForRunningAndReady(numStatefulPods int32, ss *apps.StatefulSet) {
0000000000000000000000000000000000000000;;		s.waitForRunning(numStatefulPods, ss, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForPodReady waits for the Pod named podName in set to exist and have a Ready condition.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) WaitForPodReady(set *apps.StatefulSet, podName string) (*apps.StatefulSet, *v1.PodList) {
0000000000000000000000000000000000000000;;		var pods *v1.PodList
0000000000000000000000000000000000000000;;		s.WaitForState(set, func(set2 *apps.StatefulSet, pods2 *v1.PodList) (bool, error) {
0000000000000000000000000000000000000000;;			set = set2
0000000000000000000000000000000000000000;;			pods = pods2
0000000000000000000000000000000000000000;;			for i := range pods.Items {
0000000000000000000000000000000000000000;;				if pods.Items[i].Name == podName {
0000000000000000000000000000000000000000;;					return podutil.IsPodReady(&pods.Items[i]), nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return set, pods
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForPodNotReady waist for the Pod named podName in set to exist and to not have a Ready condition.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) WaitForPodNotReady(set *apps.StatefulSet, podName string) (*apps.StatefulSet, *v1.PodList) {
0000000000000000000000000000000000000000;;		var pods *v1.PodList
0000000000000000000000000000000000000000;;		s.WaitForState(set, func(set2 *apps.StatefulSet, pods2 *v1.PodList) (bool, error) {
0000000000000000000000000000000000000000;;			set = set2
0000000000000000000000000000000000000000;;			pods = pods2
0000000000000000000000000000000000000000;;			for i := range pods.Items {
0000000000000000000000000000000000000000;;				if pods.Items[i].Name == podName {
0000000000000000000000000000000000000000;;					return !podutil.IsPodReady(&pods.Items[i]), nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return set, pods
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForRollingUpdate waits for all Pods in set to exist and have the correct revision and for the RollingUpdate to
0000000000000000000000000000000000000000;;	// complete. set must have a RollingUpdateStatefulSetStrategyType.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) WaitForRollingUpdate(set *apps.StatefulSet) (*apps.StatefulSet, *v1.PodList) {
0000000000000000000000000000000000000000;;		var pods *v1.PodList
0000000000000000000000000000000000000000;;		if set.Spec.UpdateStrategy.Type != apps.RollingUpdateStatefulSetStrategyType {
0000000000000000000000000000000000000000;;			Failf("StatefulSet %s/%s attempt to wait for rolling update with updateStrategy %s",
0000000000000000000000000000000000000000;;				set.Namespace,
0000000000000000000000000000000000000000;;				set.Name,
0000000000000000000000000000000000000000;;				set.Spec.UpdateStrategy.Type)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.WaitForState(set, func(set2 *apps.StatefulSet, pods2 *v1.PodList) (bool, error) {
0000000000000000000000000000000000000000;;			set = set2
0000000000000000000000000000000000000000;;			pods = pods2
0000000000000000000000000000000000000000;;			if len(pods.Items) < int(*set.Spec.Replicas) {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if set.Status.UpdateRevision != set.Status.CurrentRevision {
0000000000000000000000000000000000000000;;				Logf("Waiting for StatefulSet %s/%s to complete update",
0000000000000000000000000000000000000000;;					set.Namespace,
0000000000000000000000000000000000000000;;					set.Name,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;				s.SortStatefulPods(pods)
0000000000000000000000000000000000000000;;				for i := range pods.Items {
0000000000000000000000000000000000000000;;					if pods.Items[i].Labels[apps.StatefulSetRevisionLabel] != set.Status.UpdateRevision {
0000000000000000000000000000000000000000;;						Logf("Waiting for Pod %s/%s to have revision %s update revision %s",
0000000000000000000000000000000000000000;;							pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;							pods.Items[i].Name,
0000000000000000000000000000000000000000;;							set.Status.UpdateRevision,
0000000000000000000000000000000000000000;;							pods.Items[i].Labels[apps.StatefulSetRevisionLabel])
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return set, pods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForPartitionedRollingUpdate waits for all Pods in set to exist and have the correct revision. set must have
0000000000000000000000000000000000000000;;	// a RollingUpdateStatefulSetStrategyType with a non-nil RollingUpdate and Partition. All Pods with ordinals less
0000000000000000000000000000000000000000;;	// than or equal to the Partition are expected to be at set's current revision. All other Pods are expected to be
0000000000000000000000000000000000000000;;	// at its update revision.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) WaitForPartitionedRollingUpdate(set *apps.StatefulSet) (*apps.StatefulSet, *v1.PodList) {
0000000000000000000000000000000000000000;;		var pods *v1.PodList
0000000000000000000000000000000000000000;;		if set.Spec.UpdateStrategy.Type != apps.RollingUpdateStatefulSetStrategyType {
0000000000000000000000000000000000000000;;			Failf("StatefulSet %s/%s attempt to wait for partitioned update with updateStrategy %s",
0000000000000000000000000000000000000000;;				set.Namespace,
0000000000000000000000000000000000000000;;				set.Name,
0000000000000000000000000000000000000000;;				set.Spec.UpdateStrategy.Type)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if set.Spec.UpdateStrategy.RollingUpdate == nil || set.Spec.UpdateStrategy.RollingUpdate.Partition == nil {
0000000000000000000000000000000000000000;;			Failf("StatefulSet %s/%s attempt to wait for partitioned update with nil RollingUpdate or nil Partition",
0000000000000000000000000000000000000000;;				set.Namespace,
0000000000000000000000000000000000000000;;				set.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.WaitForState(set, func(set2 *apps.StatefulSet, pods2 *v1.PodList) (bool, error) {
0000000000000000000000000000000000000000;;			set = set2
0000000000000000000000000000000000000000;;			pods = pods2
0000000000000000000000000000000000000000;;			partition := int(*set.Spec.UpdateStrategy.RollingUpdate.Partition)
0000000000000000000000000000000000000000;;			if len(pods.Items) < int(*set.Spec.Replicas) {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if partition <= 0 && set.Status.UpdateRevision != set.Status.CurrentRevision {
0000000000000000000000000000000000000000;;				Logf("Waiting for StatefulSet %s/%s to complete update",
0000000000000000000000000000000000000000;;					set.Namespace,
0000000000000000000000000000000000000000;;					set.Name,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;				s.SortStatefulPods(pods)
0000000000000000000000000000000000000000;;				for i := range pods.Items {
0000000000000000000000000000000000000000;;					if pods.Items[i].Labels[apps.StatefulSetRevisionLabel] != set.Status.UpdateRevision {
0000000000000000000000000000000000000000;;						Logf("Waiting for Pod %s/%s to have revision %s update revision %s",
0000000000000000000000000000000000000000;;							pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;							pods.Items[i].Name,
0000000000000000000000000000000000000000;;							set.Status.UpdateRevision,
0000000000000000000000000000000000000000;;							pods.Items[i].Labels[apps.StatefulSetRevisionLabel])
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				for i := int(*set.Spec.Replicas) - 1; i >= partition; i-- {
0000000000000000000000000000000000000000;;					if pods.Items[i].Labels[apps.StatefulSetRevisionLabel] != set.Status.UpdateRevision {
0000000000000000000000000000000000000000;;						Logf("Waiting for Pod %s/%s to have revision %s update revision %s",
0000000000000000000000000000000000000000;;							pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;							pods.Items[i].Name,
0000000000000000000000000000000000000000;;							set.Status.UpdateRevision,
0000000000000000000000000000000000000000;;							pods.Items[i].Labels[apps.StatefulSetRevisionLabel])
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return set, pods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForRunningAndReady waits for numStatefulPods in ss to be Running and not Ready.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) WaitForRunningAndNotReady(numStatefulPods int32, ss *apps.StatefulSet) {
0000000000000000000000000000000000000000;;		s.waitForRunning(numStatefulPods, ss, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BreakProbe breaks the readiness probe for Nginx StatefulSet containers in ss.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) BreakProbe(ss *apps.StatefulSet, probe *v1.Probe) error {
0000000000000000000000000000000000000000;;		path := probe.HTTPGet.Path
0000000000000000000000000000000000000000;;		if path == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Path expected to be not empty: %v", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd := fmt.Sprintf("mv -v /usr/share/nginx/html%v /tmp/", path)
0000000000000000000000000000000000000000;;		return s.ExecInStatefulPods(ss, cmd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BreakProbe breaks the readiness probe for Nginx StatefulSet containers in pod.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) BreakPodProbe(ss *apps.StatefulSet, pod *v1.Pod, probe *v1.Probe) error {
0000000000000000000000000000000000000000;;		path := probe.HTTPGet.Path
0000000000000000000000000000000000000000;;		if path == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Path expected to be not empty: %v", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd := fmt.Sprintf("mv -v /usr/share/nginx/html%v /tmp/", path)
0000000000000000000000000000000000000000;;		stdout, err := RunHostCmd(pod.Namespace, pod.Name, cmd)
0000000000000000000000000000000000000000;;		Logf("stdout of %v on %v: %v", cmd, pod.Name, stdout)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RestoreProbe restores the readiness probe for Nginx StatefulSet containers in ss.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) RestoreProbe(ss *apps.StatefulSet, probe *v1.Probe) error {
0000000000000000000000000000000000000000;;		path := probe.HTTPGet.Path
0000000000000000000000000000000000000000;;		if path == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Path expected to be not empty: %v", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd := fmt.Sprintf("mv -v /tmp%v /usr/share/nginx/html/", path)
0000000000000000000000000000000000000000;;		return s.ExecInStatefulPods(ss, cmd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RestoreProbe restores the readiness probe for Nginx StatefulSet containers in pod.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) RestorePodProbe(ss *apps.StatefulSet, pod *v1.Pod, probe *v1.Probe) error {
0000000000000000000000000000000000000000;;		path := probe.HTTPGet.Path
0000000000000000000000000000000000000000;;		if path == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Path expected to be not empty: %v", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd := fmt.Sprintf("mv -v /tmp%v /usr/share/nginx/html/", path)
0000000000000000000000000000000000000000;;		stdout, err := RunHostCmd(pod.Namespace, pod.Name, cmd)
0000000000000000000000000000000000000000;;		Logf("stdout of %v on %v: %v", cmd, pod.Name, stdout)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetHealthy updates the StatefulSet InitAnnotation to true in order to set a StatefulSet Pod to be Running and Ready.
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) SetHealthy(ss *apps.StatefulSet) {
0000000000000000000000000000000000000000;;		podList := s.GetPodList(ss)
0000000000000000000000000000000000000000;;		markedHealthyPod := ""
0000000000000000000000000000000000000000;;		for _, pod := range podList.Items {
0000000000000000000000000000000000000000;;			if pod.Status.Phase != v1.PodRunning {
0000000000000000000000000000000000000000;;				Failf("Found pod in %v cannot set health", pod.Status.Phase)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if IsStatefulSetPodInitialized(pod) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if markedHealthyPod != "" {
0000000000000000000000000000000000000000;;				Failf("Found multiple non-healthy stateful pods: %v and %v", pod.Name, markedHealthyPod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p, err := UpdatePodWithRetries(s.c, pod.Namespace, pod.Name, func(update *v1.Pod) {
0000000000000000000000000000000000000000;;				update.Annotations[apps.StatefulSetInitAnnotation] = "true"
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			ExpectNoError(err)
0000000000000000000000000000000000000000;;			Logf("Set annotation %v to %v on pod %v", apps.StatefulSetInitAnnotation, p.Annotations[apps.StatefulSetInitAnnotation], pod.Name)
0000000000000000000000000000000000000000;;			markedHealthyPod = pod.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForStatusReadyReplicas waits for the ss.Status.ReadyReplicas to be equal to expectedReplicas
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) WaitForStatusReadyReplicas(ss *apps.StatefulSet, expectedReplicas int32) {
0000000000000000000000000000000000000000;;		Logf("Waiting for statefulset status.replicas updated to %d", expectedReplicas)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns, name := ss.Namespace, ss.Name
0000000000000000000000000000000000000000;;		pollErr := wait.PollImmediate(StatefulSetPoll, StatefulSetTimeout,
0000000000000000000000000000000000000000;;			func() (bool, error) {
0000000000000000000000000000000000000000;;				ssGet, err := s.c.Apps().StatefulSets(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if *ssGet.Status.ObservedGeneration < ss.Generation {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if ssGet.Status.ReadyReplicas != expectedReplicas {
0000000000000000000000000000000000000000;;					Logf("Waiting for stateful set status to become %d, currently %d", expectedReplicas, ssGet.Status.Replicas)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		if pollErr != nil {
0000000000000000000000000000000000000000;;			Failf("Failed waiting for stateful set status.readyReplicas updated to %d: %v", expectedReplicas, pollErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForStatusReplicas waits for the ss.Status.Replicas to be equal to expectedReplicas
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) WaitForStatusReplicas(ss *apps.StatefulSet, expectedReplicas int32) {
0000000000000000000000000000000000000000;;		Logf("Waiting for statefulset status.replicas updated to %d", expectedReplicas)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns, name := ss.Namespace, ss.Name
0000000000000000000000000000000000000000;;		pollErr := wait.PollImmediate(StatefulSetPoll, StatefulSetTimeout,
0000000000000000000000000000000000000000;;			func() (bool, error) {
0000000000000000000000000000000000000000;;				ssGet, err := s.c.Apps().StatefulSets(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if *ssGet.Status.ObservedGeneration < ss.Generation {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if ssGet.Status.Replicas != expectedReplicas {
0000000000000000000000000000000000000000;;					Logf("Waiting for stateful set status to become %d, currently %d", expectedReplicas, ssGet.Status.Replicas)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		if pollErr != nil {
0000000000000000000000000000000000000000;;			Failf("Failed waiting for stateful set status.replicas updated to %d: %v", expectedReplicas, pollErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckServiceName asserts that the ServiceName for ss is equivalent to expectedServiceName.
0000000000000000000000000000000000000000;;	func (p *StatefulSetTester) CheckServiceName(ss *apps.StatefulSet, expectedServiceName string) error {
0000000000000000000000000000000000000000;;		Logf("Checking if statefulset spec.serviceName is %s", expectedServiceName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expectedServiceName != ss.Spec.ServiceName {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Wrong service name governing statefulset. Expected %s got %s",
0000000000000000000000000000000000000000;;				expectedServiceName, ss.Spec.ServiceName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SortStatefulPods sorts pods by their ordinals
0000000000000000000000000000000000000000;;	func (s *StatefulSetTester) SortStatefulPods(pods *v1.PodList) {
0000000000000000000000000000000000000000;;		sort.Sort(statefulPodsByOrdinal(pods.Items))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteAllStatefulSets deletes all StatefulSet API Objects in Namespace ns.
0000000000000000000000000000000000000000;;	func DeleteAllStatefulSets(c clientset.Interface, ns string) {
0000000000000000000000000000000000000000;;		sst := &StatefulSetTester{c: c}
0000000000000000000000000000000000000000;;		ssList, err := c.Apps().StatefulSets(ns).List(metav1.ListOptions{LabelSelector: labels.Everything().String()})
0000000000000000000000000000000000000000;;		ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scale down each statefulset, then delete it completely.
0000000000000000000000000000000000000000;;		// Deleting a pvc without doing this will leak volumes, #25101.
0000000000000000000000000000000000000000;;		errList := []string{}
0000000000000000000000000000000000000000;;		for _, ss := range ssList.Items {
0000000000000000000000000000000000000000;;			Logf("Scaling statefulset %v to 0", ss.Name)
0000000000000000000000000000000000000000;;			if err := sst.Scale(&ss, 0); err != nil {
0000000000000000000000000000000000000000;;				errList = append(errList, fmt.Sprintf("%v", err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sst.WaitForStatusReplicas(&ss, 0)
0000000000000000000000000000000000000000;;			Logf("Deleting statefulset %v", ss.Name)
0000000000000000000000000000000000000000;;			// Use OrphanDependents=false so it's deleted synchronously.
0000000000000000000000000000000000000000;;			// We already made sure the Pods are gone inside Scale().
0000000000000000000000000000000000000000;;			if err := c.Apps().StatefulSets(ss.Namespace).Delete(ss.Name, &metav1.DeleteOptions{OrphanDependents: new(bool)}); err != nil {
0000000000000000000000000000000000000000;;				errList = append(errList, fmt.Sprintf("%v", err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pvs are global, so we need to wait for the exact ones bound to the statefulset pvcs.
0000000000000000000000000000000000000000;;		pvNames := sets.NewString()
0000000000000000000000000000000000000000;;		// TODO: Don't assume all pvcs in the ns belong to a statefulset
0000000000000000000000000000000000000000;;		pvcPollErr := wait.PollImmediate(StatefulSetPoll, StatefulSetTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			pvcList, err := c.Core().PersistentVolumeClaims(ns).List(metav1.ListOptions{LabelSelector: labels.Everything().String()})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				Logf("WARNING: Failed to list pvcs, retrying %v", err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, pvc := range pvcList.Items {
0000000000000000000000000000000000000000;;				pvNames.Insert(pvc.Spec.VolumeName)
0000000000000000000000000000000000000000;;				// TODO: Double check that there are no pods referencing the pvc
0000000000000000000000000000000000000000;;				Logf("Deleting pvc: %v with volume %v", pvc.Name, pvc.Spec.VolumeName)
0000000000000000000000000000000000000000;;				if err := c.Core().PersistentVolumeClaims(ns).Delete(pvc.Name, nil); err != nil {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if pvcPollErr != nil {
0000000000000000000000000000000000000000;;			errList = append(errList, fmt.Sprintf("Timeout waiting for pvc deletion."))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pollErr := wait.PollImmediate(StatefulSetPoll, StatefulSetTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			pvList, err := c.Core().PersistentVolumes().List(metav1.ListOptions{LabelSelector: labels.Everything().String()})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				Logf("WARNING: Failed to list pvs, retrying %v", err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			waitingFor := []string{}
0000000000000000000000000000000000000000;;			for _, pv := range pvList.Items {
0000000000000000000000000000000000000000;;				if pvNames.Has(pv.Name) {
0000000000000000000000000000000000000000;;					waitingFor = append(waitingFor, fmt.Sprintf("%v: %+v", pv.Name, pv.Status))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(waitingFor) == 0 {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Logf("Still waiting for pvs of statefulset to disappear:\n%v", strings.Join(waitingFor, "\n"))
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if pollErr != nil {
0000000000000000000000000000000000000000;;			errList = append(errList, fmt.Sprintf("Timeout waiting for pv provisioner to delete pvs, this might mean the test leaked pvs."))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(errList) != 0 {
0000000000000000000000000000000000000000;;			ExpectNoError(fmt.Errorf("%v", strings.Join(errList, "\n")))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsStatefulSetPodInitialized returns true if pod's StatefulSetInitAnnotation exists and is set to true.
0000000000000000000000000000000000000000;;	func IsStatefulSetPodInitialized(pod v1.Pod) bool {
0000000000000000000000000000000000000000;;		initialized, ok := pod.Annotations[apps.StatefulSetInitAnnotation]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		inited, err := strconv.ParseBool(initialized)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Failf("Couldn't parse statefulset init annotations %v", initialized)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return inited
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewStatefulSetPVC returns a PersistentVolumeClaim named name, for testing StatefulSets.
0000000000000000000000000000000000000000;;	func NewStatefulSetPVC(name string) v1.PersistentVolumeClaim {
0000000000000000000000000000000000000000;;		return v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					"volume.alpha.kubernetes.io/storage-class": "anything",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;					v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;					Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceStorage: *resource.NewQuantity(1, resource.BinarySI),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewStatefulSet creates a new NGINX StatefulSet for testing. The StatefulSet is named name, is in namespace ns,
0000000000000000000000000000000000000000;;	// statefulPodsMounts are the mounts that will be backed by PVs. podsMounts are the mounts that are mounted directly
0000000000000000000000000000000000000000;;	// to the Pod. labels are the labels that will be usd for the StatefulSet selector.
0000000000000000000000000000000000000000;;	func NewStatefulSet(name, ns, governingSvcName string, replicas int32, statefulPodMounts []v1.VolumeMount, podMounts []v1.VolumeMount, labels map[string]string) *apps.StatefulSet {
0000000000000000000000000000000000000000;;		mounts := append(statefulPodMounts, podMounts...)
0000000000000000000000000000000000000000;;		claims := []v1.PersistentVolumeClaim{}
0000000000000000000000000000000000000000;;		for _, m := range statefulPodMounts {
0000000000000000000000000000000000000000;;			claims = append(claims, NewStatefulSetPVC(m.Name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vols := []v1.Volume{}
0000000000000000000000000000000000000000;;		for _, m := range podMounts {
0000000000000000000000000000000000000000;;			vols = append(vols, v1.Volume{
0000000000000000000000000000000000000000;;				Name: m.Name,
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					HostPath: &v1.HostPathVolumeSource{
0000000000000000000000000000000000000000;;						Path: fmt.Sprintf("/tmp/%v", m.Name),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &apps.StatefulSet{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "StatefulSet",
0000000000000000000000000000000000000000;;				APIVersion: "apps/v1beta1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: apps.StatefulSetSpec{
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;					MatchLabels: labels,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Replicas: func(i int32) *int32 { return &i }(replicas),
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels:      labels,
0000000000000000000000000000000000000000;;						Annotations: map[string]string{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:         "nginx",
0000000000000000000000000000000000000000;;								Image:        "gcr.io/google_containers/nginx-slim:0.7",
0000000000000000000000000000000000000000;;								VolumeMounts: mounts,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Volumes: vols,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				UpdateStrategy:       apps.StatefulSetUpdateStrategy{Type: apps.RollingUpdateStatefulSetStrategyType},
0000000000000000000000000000000000000000;;				VolumeClaimTemplates: claims,
0000000000000000000000000000000000000000;;				ServiceName:          governingSvcName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetStatefulSetInitializedAnnotation sets teh StatefulSetInitAnnotation to value.
0000000000000000000000000000000000000000;;	func SetStatefulSetInitializedAnnotation(ss *apps.StatefulSet, value string) {
0000000000000000000000000000000000000000;;		ss.Spec.Template.ObjectMeta.Annotations["pod.alpha.kubernetes.io/initialized"] = value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var statefulPodRegex = regexp.MustCompile("(.*)-([0-9]+)$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getStatefulPodOrdinal(pod *v1.Pod) int {
0000000000000000000000000000000000000000;;		ordinal := -1
0000000000000000000000000000000000000000;;		subMatches := statefulPodRegex.FindStringSubmatch(pod.Name)
0000000000000000000000000000000000000000;;		if len(subMatches) < 3 {
0000000000000000000000000000000000000000;;			return ordinal
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i, err := strconv.ParseInt(subMatches[2], 10, 32); err == nil {
0000000000000000000000000000000000000000;;			ordinal = int(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ordinal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type statefulPodsByOrdinal []v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sp statefulPodsByOrdinal) Len() int {
0000000000000000000000000000000000000000;;		return len(sp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sp statefulPodsByOrdinal) Swap(i, j int) {
0000000000000000000000000000000000000000;;		sp[i], sp[j] = sp[j], sp[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sp statefulPodsByOrdinal) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return getStatefulPodOrdinal(&sp[i]) < getStatefulPodOrdinal(&sp[j])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type updateStatefulSetFunc func(*apps.StatefulSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func UpdateStatefulSetWithRetries(c clientset.Interface, namespace, name string, applyUpdate updateStatefulSetFunc) (statefulSet *apps.StatefulSet, err error) {
0000000000000000000000000000000000000000;;		statefulSets := c.Apps().StatefulSets(namespace)
0000000000000000000000000000000000000000;;		var updateErr error
0000000000000000000000000000000000000000;;		pollErr := wait.Poll(10*time.Millisecond, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			if statefulSet, err = statefulSets.Get(name, metav1.GetOptions{}); err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Apply the update, then attempt to push it to the apiserver.
0000000000000000000000000000000000000000;;			applyUpdate(statefulSet)
0000000000000000000000000000000000000000;;			if statefulSet, err = statefulSets.Update(statefulSet); err == nil {
0000000000000000000000000000000000000000;;				Logf("Updating stateful set %s", name)
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			updateErr = err
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if pollErr == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			pollErr = fmt.Errorf("couldn't apply the provided updated to stateful set %q: %v", name, updateErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return statefulSet, pollErr
0000000000000000000000000000000000000000;;	}
