0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
85d1525fa9e0b72acef4da4572eaabcf8182028a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		extensionsinternal "k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		deploymentutil "k8s.io/kubernetes/pkg/controller/deployment/util"
0000000000000000000000000000000000000000;;		labelsutil "k8s.io/kubernetes/pkg/util/labels"
0000000000000000000000000000000000000000;;		testutils "k8s.io/kubernetes/test/utils"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type updateDeploymentFunc func(d *extensions.Deployment)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func UpdateDeploymentWithRetries(c clientset.Interface, namespace, name string, applyUpdate updateDeploymentFunc) (*extensions.Deployment, error) {
0000000000000000000000000000000000000000;;		var deployment *extensions.Deployment
0000000000000000000000000000000000000000;;		var updateErr error
0000000000000000000000000000000000000000;;		pollErr := wait.PollImmediate(1*time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if deployment, err = c.Extensions().Deployments(namespace).Get(name, metav1.GetOptions{}); err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Apply the update, then attempt to push it to the apiserver.
0000000000000000000000000000000000000000;;			applyUpdate(deployment)
0000000000000000000000000000000000000000;;			if deployment, err = c.Extensions().Deployments(namespace).Update(deployment); err == nil {
0000000000000000000000000000000000000000;;				Logf("Updating deployment %s", name)
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			updateErr = err
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if pollErr == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			pollErr = fmt.Errorf("couldn't apply the provided updated to deployment %q: %v", name, updateErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return deployment, pollErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Waits for the deployment to clean up old rcs.
0000000000000000000000000000000000000000;;	func WaitForDeploymentOldRSsNum(c clientset.Interface, ns, deploymentName string, desiredRSNum int) error {
0000000000000000000000000000000000000000;;		var oldRSs []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;		var d *extensions.Deployment
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pollErr := wait.PollImmediate(Poll, 5*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			deployment, err := c.Extensions().Deployments(ns).Get(deploymentName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d = deployment
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, oldRSs, err = deploymentutil.GetOldReplicaSets(deployment, c)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return len(oldRSs) == desiredRSNum, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if pollErr == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			pollErr = fmt.Errorf("%d old replica sets were not cleaned up for deployment %q", len(oldRSs)-desiredRSNum, deploymentName)
0000000000000000000000000000000000000000;;			logReplicaSetsOfDeployment(d, oldRSs, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pollErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func logReplicaSetsOfDeployment(deployment *extensions.Deployment, allOldRSs []*extensions.ReplicaSet, newRS *extensions.ReplicaSet) {
0000000000000000000000000000000000000000;;		testutils.LogReplicaSetsOfDeployment(deployment, allOldRSs, newRS, Logf)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func WaitForObservedDeployment(c clientset.Interface, ns, deploymentName string, desiredGeneration int64) error {
0000000000000000000000000000000000000000;;		return deploymentutil.WaitForObservedDeployment(func() (*extensions.Deployment, error) {
0000000000000000000000000000000000000000;;			return c.Extensions().Deployments(ns).Get(deploymentName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		}, desiredGeneration, Poll, 1*time.Minute)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func WaitForDeploymentWithCondition(c clientset.Interface, ns, deploymentName, reason string, condType extensions.DeploymentConditionType) error {
0000000000000000000000000000000000000000;;		var deployment *extensions.Deployment
0000000000000000000000000000000000000000;;		pollErr := wait.PollImmediate(time.Second, 5*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			d, err := c.Extensions().Deployments(ns).Get(deploymentName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			deployment = d
0000000000000000000000000000000000000000;;			cond := deploymentutil.GetDeploymentCondition(deployment.Status, condType)
0000000000000000000000000000000000000000;;			return cond != nil && cond.Reason == reason, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if pollErr == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			pollErr = fmt.Errorf("deployment %q never updated with the desired condition and reason: %v", deployment.Name, deployment.Status.Conditions)
0000000000000000000000000000000000000000;;			_, allOldRSs, newRS, err := deploymentutil.GetAllReplicaSets(deployment, c)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				logReplicaSetsOfDeployment(deployment, allOldRSs, newRS)
0000000000000000000000000000000000000000;;				logPodsOfDeployment(c, deployment, append(allOldRSs, newRS))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pollErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForDeploymentRevisionAndImage waits for the deployment's and its new RS's revision and container image to match the given revision and image.
0000000000000000000000000000000000000000;;	// Note that deployment revision and its new RS revision should be updated shortly most of the time, but an overwhelmed RS controller
0000000000000000000000000000000000000000;;	// may result in taking longer to relabel a RS.
0000000000000000000000000000000000000000;;	func WaitForDeploymentRevisionAndImage(c clientset.Interface, ns, deploymentName string, revision, image string) error {
0000000000000000000000000000000000000000;;		return testutils.WaitForDeploymentRevisionAndImage(c, ns, deploymentName, revision, image, Logf, Poll, pollLongTimeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDeployment(deploymentName string, replicas int32, podLabels map[string]string, imageName, image string, strategyType extensions.DeploymentStrategyType) *extensions.Deployment {
0000000000000000000000000000000000000000;;		zero := int64(0)
0000000000000000000000000000000000000000;;		return &extensions.Deployment{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: deploymentName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.DeploymentSpec{
0000000000000000000000000000000000000000;;				Replicas: &replicas,
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{MatchLabels: podLabels},
0000000000000000000000000000000000000000;;				Strategy: extensions.DeploymentStrategy{
0000000000000000000000000000000000000000;;					Type: strategyType,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: podLabels,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						TerminationGracePeriodSeconds: &zero,
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  imageName,
0000000000000000000000000000000000000000;;								Image: image,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Waits for the deployment status to become valid (i.e. max unavailable and max surge aren't violated anymore).
0000000000000000000000000000000000000000;;	// Note that the status should stay valid at all times unless shortly after a scaling event or the deployment is just created.
0000000000000000000000000000000000000000;;	// To verify that the deployment status is valid and wait for the rollout to finish, use WaitForDeploymentStatus instead.
0000000000000000000000000000000000000000;;	func WaitForDeploymentStatusValid(c clientset.Interface, d *extensions.Deployment) error {
0000000000000000000000000000000000000000;;		return testutils.WaitForDeploymentStatusValid(c, d, Logf, Poll, pollLongTimeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Waits for the deployment to reach desired state.
0000000000000000000000000000000000000000;;	// Returns an error if the deployment's rolling update strategy (max unavailable or max surge) is broken at any times.
0000000000000000000000000000000000000000;;	func WaitForDeploymentStatus(c clientset.Interface, d *extensions.Deployment) error {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			oldRSs, allOldRSs, allRSs []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;			newRS                     *extensions.ReplicaSet
0000000000000000000000000000000000000000;;			deployment                *extensions.Deployment
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := wait.Poll(Poll, 5*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			deployment, err = c.Extensions().Deployments(d.Namespace).Get(d.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			oldRSs, allOldRSs, newRS, err = deploymentutil.GetAllReplicaSets(deployment, c)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if newRS == nil {
0000000000000000000000000000000000000000;;				// New RS hasn't been created yet.
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allRSs = append(oldRSs, newRS)
0000000000000000000000000000000000000000;;			// The old/new ReplicaSets need to contain the pod-template-hash label
0000000000000000000000000000000000000000;;			for i := range allRSs {
0000000000000000000000000000000000000000;;				if !labelsutil.SelectorHasLabel(allRSs[i].Spec.Selector, extensions.DefaultDeploymentUniqueLabelKey) {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			totalCreated := deploymentutil.GetReplicaCountForReplicaSets(allRSs)
0000000000000000000000000000000000000000;;			maxCreated := *(deployment.Spec.Replicas) + deploymentutil.MaxSurge(*deployment)
0000000000000000000000000000000000000000;;			if totalCreated > maxCreated {
0000000000000000000000000000000000000000;;				logReplicaSetsOfDeployment(deployment, allOldRSs, newRS)
0000000000000000000000000000000000000000;;				logPodsOfDeployment(c, deployment, allRSs)
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("total pods created: %d, more than the max allowed: %d", totalCreated, maxCreated)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			minAvailable := deploymentutil.MinAvailable(deployment)
0000000000000000000000000000000000000000;;			if deployment.Status.AvailableReplicas < minAvailable {
0000000000000000000000000000000000000000;;				logReplicaSetsOfDeployment(deployment, allOldRSs, newRS)
0000000000000000000000000000000000000000;;				logPodsOfDeployment(c, deployment, allRSs)
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("total pods available: %d, less than the min required: %d", deployment.Status.AvailableReplicas, minAvailable)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// When the deployment status and its underlying resources reach the desired state, we're done
0000000000000000000000000000000000000000;;			return deploymentutil.DeploymentComplete(deployment, &deployment.Status), nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			logReplicaSetsOfDeployment(deployment, allOldRSs, newRS)
0000000000000000000000000000000000000000;;			logPodsOfDeployment(c, deployment, allRSs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error waiting for deployment %q status to match expectation: %v", d.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForDeploymentUpdatedReplicasLTE waits for given deployment to be observed by the controller and has at least a number of updatedReplicas
0000000000000000000000000000000000000000;;	func WaitForDeploymentUpdatedReplicasLTE(c clientset.Interface, ns, deploymentName string, minUpdatedReplicas int32, desiredGeneration int64) error {
0000000000000000000000000000000000000000;;		err := wait.Poll(Poll, 5*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			deployment, err := c.Extensions().Deployments(ns).Get(deploymentName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if deployment.Status.ObservedGeneration >= desiredGeneration && deployment.Status.UpdatedReplicas >= minUpdatedReplicas {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error waiting for deployment %s to have at least %d updpatedReplicas: %v", deploymentName, minUpdatedReplicas, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForDeploymentRollbackCleared waits for given deployment either started rolling back or doesn't need to rollback.
0000000000000000000000000000000000000000;;	// Note that rollback should be cleared shortly, so we only wait for 1 minute here to fail early.
0000000000000000000000000000000000000000;;	func WaitForDeploymentRollbackCleared(c clientset.Interface, ns, deploymentName string) error {
0000000000000000000000000000000000000000;;		err := wait.Poll(Poll, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			deployment, err := c.Extensions().Deployments(ns).Get(deploymentName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Rollback not set or is kicked off
0000000000000000000000000000000000000000;;			if deployment.Spec.RollbackTo == nil {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error waiting for deployment %s rollbackTo to be cleared: %v", deploymentName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WatchRecreateDeployment watches Recreate deployments and ensures no new pods will run at the same time with
0000000000000000000000000000000000000000;;	// old pods.
0000000000000000000000000000000000000000;;	func WatchRecreateDeployment(c clientset.Interface, d *extensions.Deployment) error {
0000000000000000000000000000000000000000;;		if d.Spec.Strategy.Type != extensions.RecreateDeploymentStrategyType {
0000000000000000000000000000000000000000;;			return fmt.Errorf("deployment %q does not use a Recreate strategy: %s", d.Name, d.Spec.Strategy.Type)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w, err := c.Extensions().Deployments(d.Namespace).Watch(metav1.SingleObject(metav1.ObjectMeta{Name: d.Name, ResourceVersion: d.ResourceVersion}))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := d.Status
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		condition := func(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;			d := event.Object.(*extensions.Deployment)
0000000000000000000000000000000000000000;;			status = d.Status
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if d.Status.UpdatedReplicas > 0 && d.Status.Replicas != d.Status.UpdatedReplicas {
0000000000000000000000000000000000000000;;				_, allOldRSs, err := deploymentutil.GetOldReplicaSets(d, c)
0000000000000000000000000000000000000000;;				newRS, nerr := deploymentutil.GetNewReplicaSet(d, c)
0000000000000000000000000000000000000000;;				if err == nil && nerr == nil {
0000000000000000000000000000000000000000;;					Logf("%+v", d)
0000000000000000000000000000000000000000;;					logReplicaSetsOfDeployment(d, allOldRSs, newRS)
0000000000000000000000000000000000000000;;					logPodsOfDeployment(c, d, append(allOldRSs, newRS))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("deployment %q is running new pods alongside old pods: %#v", d.Name, status)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return *(d.Spec.Replicas) == d.Status.Replicas &&
0000000000000000000000000000000000000000;;				*(d.Spec.Replicas) == d.Status.UpdatedReplicas &&
0000000000000000000000000000000000000000;;				d.Generation <= d.Status.ObservedGeneration, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = watch.Until(2*time.Minute, w, condition)
0000000000000000000000000000000000000000;;		if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("deployment %q never completed: %#v", d.Name, status)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ScaleDeployment(clientset clientset.Interface, internalClientset internalclientset.Interface, ns, name string, size uint, wait bool) error {
0000000000000000000000000000000000000000;;		return ScaleResource(clientset, internalClientset, ns, name, size, wait, extensionsinternal.Kind("Deployment"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunDeployment(config testutils.DeploymentConfig) error {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("creating deployment %s in namespace %s", config.Name, config.Namespace))
0000000000000000000000000000000000000000;;		config.NodeDumpFunc = DumpNodeDebugInfo
0000000000000000000000000000000000000000;;		config.ContainerDumpFunc = LogFailedContainers
0000000000000000000000000000000000000000;;		return testutils.RunDeployment(config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func logPodsOfDeployment(c clientset.Interface, deployment *extensions.Deployment, rsList []*extensions.ReplicaSet) {
0000000000000000000000000000000000000000;;		testutils.LogPodsOfDeployment(c, deployment, rsList, Logf)
0000000000000000000000000000000000000000;;	}
