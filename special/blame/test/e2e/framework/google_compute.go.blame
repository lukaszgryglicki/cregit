0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
e971596a168e24cf7afdc7e4f383d7d6b2cea422;test/e2e/google_compute.go[test/e2e/google_compute.go][test/e2e/framework/google_compute.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/gce"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: These should really just use the GCE API client library or at least use
0000000000000000000000000000000000000000;;	// better formatted output from the --format flag.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreateGCEStaticIP(name string) (string, error) {
0000000000000000000000000000000000000000;;		// gcloud compute --project "abshah-kubernetes-001" addresses create "test-static-ip" --region "us-central1"
0000000000000000000000000000000000000000;;		// abshah@abhidesk:~/go/src/code.google.com/p/google-api-go-client/compute/v1$ gcloud compute --project "abshah-kubernetes-001" addresses create "test-static-ip" --region "us-central1"
0000000000000000000000000000000000000000;;		// Created [https://www.googleapis.com/compute/v1/projects/abshah-kubernetes-001/regions/us-central1/addresses/test-static-ip].
0000000000000000000000000000000000000000;;		// NAME           REGION      ADDRESS       STATUS
0000000000000000000000000000000000000000;;		// test-static-ip us-central1 104.197.143.7 RESERVED
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var outputBytes []byte
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		region, err := gce.GetGCERegion(TestContext.CloudConfig.Zone)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to convert zone to region: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("Creating static IP with name %q in project %q in region %q", name, TestContext.CloudConfig.ProjectID, region)
0000000000000000000000000000000000000000;;		for attempts := 0; attempts < 4; attempts++ {
0000000000000000000000000000000000000000;;			outputBytes, err = exec.Command("gcloud", "compute", "addresses", "create",
0000000000000000000000000000000000000000;;				name, "--project", TestContext.CloudConfig.ProjectID,
0000000000000000000000000000000000000000;;				"--region", region, "-q", "--format=yaml").CombinedOutput()
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Errorf("output from failed attempt to create static IP: %s", outputBytes)
0000000000000000000000000000000000000000;;			time.Sleep(time.Duration(5*attempts) * time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Ditch the error, since the stderr in the output is what actually contains
0000000000000000000000000000000000000000;;			// any useful info.
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to create static IP: %s", outputBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output := string(outputBytes)
0000000000000000000000000000000000000000;;		if strings.Contains(output, "RESERVED") {
0000000000000000000000000000000000000000;;			r, _ := regexp.Compile("[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+")
0000000000000000000000000000000000000000;;			staticIP := r.FindString(output)
0000000000000000000000000000000000000000;;			if staticIP == "" {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("static IP not found in gcloud command output: %v", output)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return staticIP, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("static IP %q could not be reserved: %v", name, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DeleteGCEStaticIP(name string) error {
0000000000000000000000000000000000000000;;		// gcloud compute --project "abshah-kubernetes-001" addresses create "test-static-ip" --region "us-central1"
0000000000000000000000000000000000000000;;		// abshah@abhidesk:~/go/src/code.google.com/p/google-api-go-client/compute/v1$ gcloud compute --project "abshah-kubernetes-001" addresses create "test-static-ip" --region "us-central1"
0000000000000000000000000000000000000000;;		// Created [https://www.googleapis.com/compute/v1/projects/abshah-kubernetes-001/regions/us-central1/addresses/test-static-ip].
0000000000000000000000000000000000000000;;		// NAME           REGION      ADDRESS       STATUS
0000000000000000000000000000000000000000;;		// test-static-ip us-central1 104.197.143.7 RESERVED
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		region, err := gce.GetGCERegion(TestContext.CloudConfig.Zone)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to convert zone to region: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("Deleting static IP with name %q in project %q in region %q", name, TestContext.CloudConfig.ProjectID, region)
0000000000000000000000000000000000000000;;		outputBytes, err := exec.Command("gcloud", "compute", "addresses", "delete",
0000000000000000000000000000000000000000;;			name, "--project", TestContext.CloudConfig.ProjectID,
0000000000000000000000000000000000000000;;			"--region", region, "-q").CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Ditch the error, since the stderr in the output is what actually contains
0000000000000000000000000000000000000000;;			// any useful info.
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to delete static IP %q: %v", name, string(outputBytes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns master & node image string, or error
0000000000000000000000000000000000000000;;	func lookupClusterImageSources() (string, string, error) {
0000000000000000000000000000000000000000;;		// Given args for a gcloud compute command, run it with other args, and return the values,
0000000000000000000000000000000000000000;;		// whether separated by newlines, commas or semicolons.
0000000000000000000000000000000000000000;;		gcloudf := func(argv ...string) ([]string, error) {
0000000000000000000000000000000000000000;;			args := []string{"compute"}
0000000000000000000000000000000000000000;;			args = append(args, argv...)
0000000000000000000000000000000000000000;;			args = append(args, "--project", TestContext.CloudConfig.ProjectID,
0000000000000000000000000000000000000000;;				"--zone", TestContext.CloudConfig.Zone)
0000000000000000000000000000000000000000;;			outputBytes, err := exec.Command("gcloud", args...).CombinedOutput()
0000000000000000000000000000000000000000;;			str := strings.Replace(string(outputBytes), ",", "\n", -1)
0000000000000000000000000000000000000000;;			str = strings.Replace(str, ";", "\n", -1)
0000000000000000000000000000000000000000;;			lines := strings.Split(str, "\n")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				Logf("lookupDiskImageSources: gcloud error with [%#v]; err:%v", argv, err)
0000000000000000000000000000000000000000;;				for _, l := range lines {
0000000000000000000000000000000000000000;;					Logf(" > %s", l)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return lines, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Given a GCE instance, look through its disks, finding one that has a sourceImage
0000000000000000000000000000000000000000;;		host2image := func(instance string) (string, error) {
0000000000000000000000000000000000000000;;			// gcloud compute instances describe {INSTANCE} --format="get(disks[].source)"
0000000000000000000000000000000000000000;;			// gcloud compute disks describe {DISKURL} --format="get(sourceImage)"
0000000000000000000000000000000000000000;;			disks, err := gcloudf("instances", "describe", instance, "--format=get(disks[].source)")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			} else if len(disks) == 0 {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("instance %q had no findable disks", instance)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Loop over disks, looking for the boot disk
0000000000000000000000000000000000000000;;			for _, disk := range disks {
0000000000000000000000000000000000000000;;				lines, err := gcloudf("disks", "describe", disk, "--format=get(sourceImage)")
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return "", err
0000000000000000000000000000000000000000;;				} else if len(lines) > 0 && lines[0] != "" {
0000000000000000000000000000000000000000;;					return lines[0], nil // break, we're done
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("instance %q had no disk with a sourceImage", instance)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// gcloud compute instance-groups list-instances {GROUPNAME} --format="get(instance)"
0000000000000000000000000000000000000000;;		nodeName := ""
0000000000000000000000000000000000000000;;		instGroupName := strings.Split(TestContext.CloudConfig.NodeInstanceGroup, ",")[0]
0000000000000000000000000000000000000000;;		if lines, err := gcloudf("instance-groups", "list-instances", instGroupName, "--format=get(instance)"); err != nil {
0000000000000000000000000000000000000000;;			return "", "", err
0000000000000000000000000000000000000000;;		} else if len(lines) == 0 {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("no instances inside instance-group %q", instGroupName)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			nodeName = lines[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeImg, err := host2image(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		frags := strings.Split(nodeImg, "/")
0000000000000000000000000000000000000000;;		nodeImg = frags[len(frags)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		masterName := TestContext.CloudConfig.MasterName
0000000000000000000000000000000000000000;;		masterImg, err := host2image(masterName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		frags = strings.Split(masterImg, "/")
0000000000000000000000000000000000000000;;		masterImg = frags[len(frags)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return masterImg, nodeImg, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LogClusterImageSources() {
0000000000000000000000000000000000000000;;		masterImg, nodeImg, err := lookupClusterImageSources()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Logf("Cluster image sources lookup failed: %v\n", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Logf("cluster-master-image: %s", masterImg)
0000000000000000000000000000000000000000;;		Logf("cluster-node-image: %s", nodeImg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		images := map[string]string{
0000000000000000000000000000000000000000;;			"master_os_image": masterImg,
0000000000000000000000000000000000000000;;			"node_os_image":   nodeImg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		outputBytes, _ := json.MarshalIndent(images, "", "  ")
0000000000000000000000000000000000000000;;		filePath := filepath.Join(TestContext.ReportDir, "images.json")
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(filePath, outputBytes, 0644); err != nil {
0000000000000000000000000000000000000000;;			Logf("cluster images sources, could not write to %q: %v", filePath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
