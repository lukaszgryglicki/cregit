0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
892119c0408632cd6c37f33876746e6e8788124b;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/remotecommand"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExecOptions passed to ExecWithOptions
0000000000000000000000000000000000000000;;	type ExecOptions struct {
0000000000000000000000000000000000000000;;		Command []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Namespace     string
0000000000000000000000000000000000000000;;		PodName       string
0000000000000000000000000000000000000000;;		ContainerName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Stdin         io.Reader
0000000000000000000000000000000000000000;;		CaptureStdout bool
0000000000000000000000000000000000000000;;		CaptureStderr bool
0000000000000000000000000000000000000000;;		// If false, whitespace in std{err,out} will be removed.
0000000000000000000000000000000000000000;;		PreserveWhitespace bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExecWithOptions executes a command in the specified container,
0000000000000000000000000000000000000000;;	// returning stdout, stderr and error. `options` allowed for
0000000000000000000000000000000000000000;;	// additional parameters to be passed.
0000000000000000000000000000000000000000;;	func (f *Framework) ExecWithOptions(options ExecOptions) (string, string, error) {
0000000000000000000000000000000000000000;;		Logf("ExecWithOptions %+v", options)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config, err := LoadConfig()
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "failed to load restclient config")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const tty = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := f.ClientSet.Core().RESTClient().Post().
0000000000000000000000000000000000000000;;			Resource("pods").
0000000000000000000000000000000000000000;;			Name(options.PodName).
0000000000000000000000000000000000000000;;			Namespace(options.Namespace).
0000000000000000000000000000000000000000;;			SubResource("exec").
0000000000000000000000000000000000000000;;			Param("container", options.ContainerName)
0000000000000000000000000000000000000000;;		req.VersionedParams(&v1.PodExecOptions{
0000000000000000000000000000000000000000;;			Container: options.ContainerName,
0000000000000000000000000000000000000000;;			Command:   options.Command,
0000000000000000000000000000000000000000;;			Stdin:     options.Stdin != nil,
0000000000000000000000000000000000000000;;			Stdout:    options.CaptureStdout,
0000000000000000000000000000000000000000;;			Stderr:    options.CaptureStderr,
0000000000000000000000000000000000000000;;			TTY:       tty,
0000000000000000000000000000000000000000;;		}, api.ParameterCodec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var stdout, stderr bytes.Buffer
0000000000000000000000000000000000000000;;		err = execute("POST", req.URL(), config, options.Stdin, &stdout, &stderr, tty)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options.PreserveWhitespace {
0000000000000000000000000000000000000000;;			return stdout.String(), stderr.String(), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.TrimSpace(stdout.String()), strings.TrimSpace(stderr.String()), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExecCommandInContainerWithFullOutput executes a command in the
0000000000000000000000000000000000000000;;	// specified container and return stdout, stderr and error
0000000000000000000000000000000000000000;;	func (f *Framework) ExecCommandInContainerWithFullOutput(podName, containerName string, cmd ...string) (string, string, error) {
0000000000000000000000000000000000000000;;		return f.ExecWithOptions(ExecOptions{
0000000000000000000000000000000000000000;;			Command:       cmd,
0000000000000000000000000000000000000000;;			Namespace:     f.Namespace.Name,
0000000000000000000000000000000000000000;;			PodName:       podName,
0000000000000000000000000000000000000000;;			ContainerName: containerName,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Stdin:              nil,
0000000000000000000000000000000000000000;;			CaptureStdout:      true,
0000000000000000000000000000000000000000;;			CaptureStderr:      true,
0000000000000000000000000000000000000000;;			PreserveWhitespace: false,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExecCommandInContainer executes a command in the specified container.
0000000000000000000000000000000000000000;;	func (f *Framework) ExecCommandInContainer(podName, containerName string, cmd ...string) string {
0000000000000000000000000000000000000000;;		stdout, stderr, err := f.ExecCommandInContainerWithFullOutput(podName, containerName, cmd...)
0000000000000000000000000000000000000000;;		Logf("Exec stderr: %q", stderr)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(),
0000000000000000000000000000000000000000;;			"failed to execute command in pod %v, container %v: %v",
0000000000000000000000000000000000000000;;			podName, containerName, err)
0000000000000000000000000000000000000000;;		return stdout
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framework) ExecShellInContainer(podName, containerName string, cmd string) string {
0000000000000000000000000000000000000000;;		return f.ExecCommandInContainer(podName, containerName, "/bin/sh", "-c", cmd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framework) ExecCommandInPod(podName string, cmd ...string) string {
0000000000000000000000000000000000000000;;		pod, err := f.PodClient().Get(podName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "failed to get pod")
0000000000000000000000000000000000000000;;		Expect(pod.Spec.Containers).NotTo(BeEmpty())
0000000000000000000000000000000000000000;;		return f.ExecCommandInContainer(podName, pod.Spec.Containers[0].Name, cmd...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framework) ExecCommandInPodWithFullOutput(podName string, cmd ...string) (string, string, error) {
0000000000000000000000000000000000000000;;		pod, err := f.PodClient().Get(podName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "failed to get pod")
0000000000000000000000000000000000000000;;		Expect(pod.Spec.Containers).NotTo(BeEmpty())
0000000000000000000000000000000000000000;;		return f.ExecCommandInContainerWithFullOutput(podName, pod.Spec.Containers[0].Name, cmd...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framework) ExecShellInPod(podName string, cmd string) string {
0000000000000000000000000000000000000000;;		return f.ExecCommandInPod(podName, "/bin/sh", "-c", cmd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framework) ExecShellInPodWithFullOutput(podName string, cmd string) (string, string, error) {
0000000000000000000000000000000000000000;;		return f.ExecCommandInPodWithFullOutput(podName, "/bin/sh", "-c", cmd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func execute(method string, url *url.URL, config *restclient.Config, stdin io.Reader, stdout, stderr io.Writer, tty bool) error {
0000000000000000000000000000000000000000;;		exec, err := remotecommand.NewSPDYExecutor(config, method, url)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return exec.Stream(remotecommand.StreamOptions{
0000000000000000000000000000000000000000;;			Stdin:  stdin,
0000000000000000000000000000000000000000;;			Stdout: stdout,
0000000000000000000000000000000000000000;;			Stderr: stderr,
0000000000000000000000000000000000000000;;			Tty:    tty,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
