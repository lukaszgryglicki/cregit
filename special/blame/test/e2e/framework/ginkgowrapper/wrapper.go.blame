0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
e8787f497b28f5f20145426dc3c2b1e3363fe536;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package ginkgowrapper wraps Ginkgo Fail and Skip functions to panic
0000000000000000000000000000000000000000;;	// with structured data instead of a constant string.
0000000000000000000000000000000000000000;;	package ginkgowrapper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"runtime/debug"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FailurePanic is the value that will be panicked from Fail.
0000000000000000000000000000000000000000;;	type FailurePanic struct {
0000000000000000000000000000000000000000;;		Message        string // The failure message passed to Fail
0000000000000000000000000000000000000000;;		Filename       string // The filename that is the source of the failure
0000000000000000000000000000000000000000;;		Line           int    // The line number of the filename that is the source of the failure
0000000000000000000000000000000000000000;;		FullStackTrace string // A full stack trace starting at the source of the failure
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String makes FailurePanic look like the old Ginkgo panic when printed.
0000000000000000000000000000000000000000;;	func (FailurePanic) String() string { return ginkgo.GINKGO_PANIC }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fail wraps ginkgo.Fail so that it panics with more useful
0000000000000000000000000000000000000000;;	// information about the failure. This function will panic with a
0000000000000000000000000000000000000000;;	// FailurePanic.
0000000000000000000000000000000000000000;;	func Fail(message string, callerSkip ...int) {
0000000000000000000000000000000000000000;;		skip := 1
0000000000000000000000000000000000000000;;		if len(callerSkip) > 0 {
0000000000000000000000000000000000000000;;			skip += callerSkip[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, file, line, _ := runtime.Caller(skip)
0000000000000000000000000000000000000000;;		fp := FailurePanic{
0000000000000000000000000000000000000000;;			Message:        message,
0000000000000000000000000000000000000000;;			Filename:       file,
0000000000000000000000000000000000000000;;			Line:           line,
0000000000000000000000000000000000000000;;			FullStackTrace: pruneStack(skip),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			e := recover()
0000000000000000000000000000000000000000;;			if e != nil {
0000000000000000000000000000000000000000;;				panic(fp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo.Fail(message, skip)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SkipPanic is the value that will be panicked from Skip.
0000000000000000000000000000000000000000;;	type SkipPanic struct {
0000000000000000000000000000000000000000;;		Message        string // The failure message passed to Fail
0000000000000000000000000000000000000000;;		Filename       string // The filename that is the source of the failure
0000000000000000000000000000000000000000;;		Line           int    // The line number of the filename that is the source of the failure
0000000000000000000000000000000000000000;;		FullStackTrace string // A full stack trace starting at the source of the failure
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String makes SkipPanic look like the old Ginkgo panic when printed.
0000000000000000000000000000000000000000;;	func (SkipPanic) String() string { return ginkgo.GINKGO_PANIC }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Skip wraps ginkgo.Skip so that it panics with more useful
0000000000000000000000000000000000000000;;	// information about why the test is being skipped. This function will
0000000000000000000000000000000000000000;;	// panic with a SkipPanic.
0000000000000000000000000000000000000000;;	func Skip(message string, callerSkip ...int) {
0000000000000000000000000000000000000000;;		skip := 1
0000000000000000000000000000000000000000;;		if len(callerSkip) > 0 {
0000000000000000000000000000000000000000;;			skip += callerSkip[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, file, line, _ := runtime.Caller(skip)
0000000000000000000000000000000000000000;;		sp := SkipPanic{
0000000000000000000000000000000000000000;;			Message:        message,
0000000000000000000000000000000000000000;;			Filename:       file,
0000000000000000000000000000000000000000;;			Line:           line,
0000000000000000000000000000000000000000;;			FullStackTrace: pruneStack(skip),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			e := recover()
0000000000000000000000000000000000000000;;			if e != nil {
0000000000000000000000000000000000000000;;				panic(sp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo.Skip(message, skip)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ginkgo adds a lot of test running infrastructure to the stack, so
0000000000000000000000000000000000000000;;	// we filter those out
0000000000000000000000000000000000000000;;	var stackSkipPattern = regexp.MustCompile(`onsi/ginkgo`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pruneStack(skip int) string {
0000000000000000000000000000000000000000;;		skip += 2 // one for pruneStack and one for debug.Stack
0000000000000000000000000000000000000000;;		stack := debug.Stack()
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(bytes.NewBuffer(stack))
0000000000000000000000000000000000000000;;		var prunedStack []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// skip the top of the stack
0000000000000000000000000000000000000000;;		for i := 0; i < 2*skip+1; i++ {
0000000000000000000000000000000000000000;;			scanner.Scan()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			if stackSkipPattern.Match(scanner.Bytes()) {
0000000000000000000000000000000000000000;;				scanner.Scan() // these come in pairs
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				prunedStack = append(prunedStack, scanner.Text())
0000000000000000000000000000000000000000;;				scanner.Scan() // these come in pairs
0000000000000000000000000000000000000000;;				prunedStack = append(prunedStack, scanner.Text())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strings.Join(prunedStack, "\n")
0000000000000000000000000000000000000000;;	}
