0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
893d04ff1a70e499dad3c00c72123203c5d74733;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/perftype"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(random-liu): Change the tests to actually use PerfData from the beginning instead of
0000000000000000000000000000000000000000;;	// translating one to the other here.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// currentApiCallMetricsVersion is the current apicall performance metrics version. We should
0000000000000000000000000000000000000000;;	// bump up the version each time we make incompatible change to the metrics.
0000000000000000000000000000000000000000;;	const currentApiCallMetricsVersion = "v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ApiCallToPerfData transforms APIResponsiveness to PerfData.
0000000000000000000000000000000000000000;;	func ApiCallToPerfData(apicalls *APIResponsiveness) *perftype.PerfData {
0000000000000000000000000000000000000000;;		perfData := &perftype.PerfData{Version: currentApiCallMetricsVersion}
0000000000000000000000000000000000000000;;		for _, apicall := range apicalls.APICalls {
0000000000000000000000000000000000000000;;			item := perftype.DataItem{
0000000000000000000000000000000000000000;;				Data: map[string]float64{
0000000000000000000000000000000000000000;;					"Perc50": float64(apicall.Latency.Perc50) / 1000000, // us -> ms
0000000000000000000000000000000000000000;;					"Perc90": float64(apicall.Latency.Perc90) / 1000000,
0000000000000000000000000000000000000000;;					"Perc99": float64(apicall.Latency.Perc99) / 1000000,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Unit: "ms",
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"Verb":        apicall.Verb,
0000000000000000000000000000000000000000;;					"Resource":    apicall.Resource,
0000000000000000000000000000000000000000;;					"Subresource": apicall.Subresource,
0000000000000000000000000000000000000000;;					"Count":       fmt.Sprintf("%v", apicall.Count),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			perfData.DataItems = append(perfData.DataItems, item)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return perfData
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodStartupLatencyToPerfData transforms PodStartupLatency to PerfData.
0000000000000000000000000000000000000000;;	func PodStartupLatencyToPerfData(latency *PodStartupLatency) *perftype.PerfData {
0000000000000000000000000000000000000000;;		perfData := &perftype.PerfData{Version: currentApiCallMetricsVersion}
0000000000000000000000000000000000000000;;		item := perftype.DataItem{
0000000000000000000000000000000000000000;;			Data: map[string]float64{
0000000000000000000000000000000000000000;;				"Perc50":  float64(latency.Latency.Perc50) / 1000000, // us -> ms
0000000000000000000000000000000000000000;;				"Perc90":  float64(latency.Latency.Perc90) / 1000000,
0000000000000000000000000000000000000000;;				"Perc99":  float64(latency.Latency.Perc99) / 1000000,
0000000000000000000000000000000000000000;;				"Perc100": float64(latency.Latency.Perc100) / 1000000,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Unit: "ms",
0000000000000000000000000000000000000000;;			Labels: map[string]string{
0000000000000000000000000000000000000000;;				"Metric": "pod_startup",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		perfData.DataItems = append(perfData.DataItems, item)
0000000000000000000000000000000000000000;;		return perfData
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CurrentKubeletPerfMetricsVersion is the current kubelet performance metrics
0000000000000000000000000000000000000000;;	// version. This is used by mutiple perf related data structures. We should
0000000000000000000000000000000000000000;;	// bump up the version each time we make an incompatible change to the metrics.
0000000000000000000000000000000000000000;;	const CurrentKubeletPerfMetricsVersion = "v2"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceUsageToPerfData transforms ResourceUsagePerNode to PerfData. Notice that this function
0000000000000000000000000000000000000000;;	// only cares about memory usage, because cpu usage information will be extracted from NodesCPUSummary.
0000000000000000000000000000000000000000;;	func ResourceUsageToPerfData(usagePerNode ResourceUsagePerNode) *perftype.PerfData {
0000000000000000000000000000000000000000;;		return ResourceUsageToPerfDataWithLabels(usagePerNode, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CPUUsageToPerfData transforms NodesCPUSummary to PerfData.
0000000000000000000000000000000000000000;;	func CPUUsageToPerfData(usagePerNode NodesCPUSummary) *perftype.PerfData {
0000000000000000000000000000000000000000;;		return CPUUsageToPerfDataWithLabels(usagePerNode, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrintPerfData prints the perfdata in json format with PerfResultTag prefix.
0000000000000000000000000000000000000000;;	// If an error occurs, nothing will be printed.
0000000000000000000000000000000000000000;;	func PrintPerfData(p *perftype.PerfData) {
0000000000000000000000000000000000000000;;		// Notice that we must make sure the perftype.PerfResultEnd is in a new line.
0000000000000000000000000000000000000000;;		if str := PrettyPrintJSON(p); str != "" {
0000000000000000000000000000000000000000;;			Logf("%s %s\n%s", perftype.PerfResultTag, str, perftype.PerfResultEnd)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceUsageToPerfDataWithLabels transforms ResourceUsagePerNode to PerfData with additional labels.
0000000000000000000000000000000000000000;;	// Notice that this function only cares about memory usage, because cpu usage information will be extracted from NodesCPUSummary.
0000000000000000000000000000000000000000;;	func ResourceUsageToPerfDataWithLabels(usagePerNode ResourceUsagePerNode, labels map[string]string) *perftype.PerfData {
0000000000000000000000000000000000000000;;		items := []perftype.DataItem{}
0000000000000000000000000000000000000000;;		for node, usages := range usagePerNode {
0000000000000000000000000000000000000000;;			for c, usage := range usages {
0000000000000000000000000000000000000000;;				item := perftype.DataItem{
0000000000000000000000000000000000000000;;					Data: map[string]float64{
0000000000000000000000000000000000000000;;						"memory":     float64(usage.MemoryUsageInBytes) / (1024 * 1024),
0000000000000000000000000000000000000000;;						"workingset": float64(usage.MemoryWorkingSetInBytes) / (1024 * 1024),
0000000000000000000000000000000000000000;;						"rss":        float64(usage.MemoryRSSInBytes) / (1024 * 1024),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Unit: "MB",
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						"node":      node,
0000000000000000000000000000000000000000;;						"container": c,
0000000000000000000000000000000000000000;;						"datatype":  "resource",
0000000000000000000000000000000000000000;;						"resource":  "memory",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				items = append(items, item)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &perftype.PerfData{
0000000000000000000000000000000000000000;;			Version:   CurrentKubeletPerfMetricsVersion,
0000000000000000000000000000000000000000;;			DataItems: items,
0000000000000000000000000000000000000000;;			Labels:    labels,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CPUUsageToPerfDataWithLabels transforms NodesCPUSummary to PerfData with additional labels.
0000000000000000000000000000000000000000;;	func CPUUsageToPerfDataWithLabels(usagePerNode NodesCPUSummary, labels map[string]string) *perftype.PerfData {
0000000000000000000000000000000000000000;;		items := []perftype.DataItem{}
0000000000000000000000000000000000000000;;		for node, usages := range usagePerNode {
0000000000000000000000000000000000000000;;			for c, usage := range usages {
0000000000000000000000000000000000000000;;				data := map[string]float64{}
0000000000000000000000000000000000000000;;				for perc, value := range usage {
0000000000000000000000000000000000000000;;					data[fmt.Sprintf("Perc%02.0f", perc*100)] = value * 1000
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				item := perftype.DataItem{
0000000000000000000000000000000000000000;;					Data: data,
0000000000000000000000000000000000000000;;					Unit: "mCPU",
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						"node":      node,
0000000000000000000000000000000000000000;;						"container": c,
0000000000000000000000000000000000000000;;						"datatype":  "resource",
0000000000000000000000000000000000000000;;						"resource":  "cpu",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				items = append(items, item)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &perftype.PerfData{
0000000000000000000000000000000000000000;;			Version:   CurrentKubeletPerfMetricsVersion,
0000000000000000000000000000000000000000;;			DataItems: items,
0000000000000000000000000000000000000000;;			Labels:    labels,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
