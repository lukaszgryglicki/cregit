0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
fc957932ab9379651ffc6c0dbcee1b36e8d533c0;test/e2e/pvutil.go[test/e2e/pvutil.go][test/e2e/framework/pv_util.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/awserr"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/session"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/service/ec2"
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		"google.golang.org/api/googleapi"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrs "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		awscloud "k8s.io/kubernetes/pkg/cloudprovider/providers/aws"
0000000000000000000000000000000000000000;;		gcecloud "k8s.io/kubernetes/pkg/cloudprovider/providers/gce"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		PDRetryTimeout    = 5 * time.Minute
0000000000000000000000000000000000000000;;		PDRetryPollTime   = 5 * time.Second
0000000000000000000000000000000000000000;;		VolumeSelectorKey = "e2e-pv-pool"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Map of all PVs used in the multi pv-pvc tests. The key is the PV's name, which is
0000000000000000000000000000000000000000;;	// guaranteed to be unique. The value is {} (empty struct) since we're only interested
0000000000000000000000000000000000000000;;	// in the PV's name and if it is present. We must always Get the pv object before
0000000000000000000000000000000000000000;;	// referencing any of its values, eg its ClaimRef.
0000000000000000000000000000000000000000;;	type pvval struct{}
0000000000000000000000000000000000000000;;	type PVMap map[string]pvval
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Map of all PVCs used in the multi pv-pvc tests. The key is "namespace/pvc.Name". The
0000000000000000000000000000000000000000;;	// value is {} (empty struct) since we're only interested in the PVC's name and if it is
0000000000000000000000000000000000000000;;	// present. We must always Get the pvc object before referencing any of its values, eg.
0000000000000000000000000000000000000000;;	// its VolumeName.
0000000000000000000000000000000000000000;;	// Note: It's unsafe to add keys to a map in a loop. Their insertion in the map is
0000000000000000000000000000000000000000;;	//   unpredictable and can result in the same key being iterated over again.
0000000000000000000000000000000000000000;;	type pvcval struct{}
0000000000000000000000000000000000000000;;	type PVCMap map[types.NamespacedName]pvcval
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumeConfig is consumed by MakePersistentVolume() to generate a PV object
0000000000000000000000000000000000000000;;	// for varying storage options (NFS, ceph, glusterFS, etc.).
0000000000000000000000000000000000000000;;	// (+optional) prebind holds a pre-bound PVC
0000000000000000000000000000000000000000;;	// Example pvSource:
0000000000000000000000000000000000000000;;	//	pvSource: api.PersistentVolumeSource{
0000000000000000000000000000000000000000;;	//		NFS: &api.NFSVolumeSource{
0000000000000000000000000000000000000000;;	//	 		...
0000000000000000000000000000000000000000;;	//	 	},
0000000000000000000000000000000000000000;;	//	 }
0000000000000000000000000000000000000000;;	type PersistentVolumeConfig struct {
0000000000000000000000000000000000000000;;		PVSource         v1.PersistentVolumeSource
0000000000000000000000000000000000000000;;		Prebind          *v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;		ReclaimPolicy    v1.PersistentVolumeReclaimPolicy
0000000000000000000000000000000000000000;;		NamePrefix       string
0000000000000000000000000000000000000000;;		Labels           labels.Set
0000000000000000000000000000000000000000;;		StorageClassName string
0000000000000000000000000000000000000000;;		NodeAffinity     *v1.NodeAffinity
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumeClaimConfig is consumed by MakePersistentVolumeClaim() to generate a PVC object.
0000000000000000000000000000000000000000;;	// AccessModes defaults to all modes (RWO, RWX, ROX) if left empty
0000000000000000000000000000000000000000;;	// (+optional) Annotations defines the PVC's annotations
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PersistentVolumeClaimConfig struct {
0000000000000000000000000000000000000000;;		AccessModes      []v1.PersistentVolumeAccessMode
0000000000000000000000000000000000000000;;		Annotations      map[string]string
0000000000000000000000000000000000000000;;		Selector         *metav1.LabelSelector
0000000000000000000000000000000000000000;;		StorageClassName *string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clean up a pv and pvc in a single pv/pvc test case.
0000000000000000000000000000000000000000;;	// Note: delete errors are appended to []error so that we can attempt to delete both the pvc and pv.
0000000000000000000000000000000000000000;;	func PVPVCCleanup(c clientset.Interface, ns string, pv *v1.PersistentVolume, pvc *v1.PersistentVolumeClaim) []error {
0000000000000000000000000000000000000000;;		var errs []error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pvc != nil {
0000000000000000000000000000000000000000;;			err := DeletePersistentVolumeClaim(c, pvc.Name, ns)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, fmt.Errorf("failed to delete PVC %q: %v", pvc.Name, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			Logf("pvc is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv != nil {
0000000000000000000000000000000000000000;;			err := DeletePersistentVolume(c, pv.Name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, fmt.Errorf("failed to delete PV %q: %v", pv.Name, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			Logf("pv is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clean up pvs and pvcs in multi-pv-pvc test cases. Entries found in the pv and claim maps are
0000000000000000000000000000000000000000;;	// deleted as long as the Delete api call succeeds.
0000000000000000000000000000000000000000;;	// Note: delete errors are appended to []error so that as many pvcs and pvs as possible are deleted.
0000000000000000000000000000000000000000;;	func PVPVCMapCleanup(c clientset.Interface, ns string, pvols PVMap, claims PVCMap) []error {
0000000000000000000000000000000000000000;;		var errs []error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for pvcKey := range claims {
0000000000000000000000000000000000000000;;			err := DeletePersistentVolumeClaim(c, pvcKey.Name, ns)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, fmt.Errorf("failed to delete PVC %q: %v", pvcKey.Name, err))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				delete(claims, pvcKey)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for pvKey := range pvols {
0000000000000000000000000000000000000000;;			err := DeletePersistentVolume(c, pvKey)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, fmt.Errorf("failed to delete PV %q: %v", pvKey, err))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				delete(pvols, pvKey)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete the PV.
0000000000000000000000000000000000000000;;	func DeletePersistentVolume(c clientset.Interface, pvName string) error {
0000000000000000000000000000000000000000;;		if c != nil && len(pvName) > 0 {
0000000000000000000000000000000000000000;;			Logf("Deleting PersistentVolume %q", pvName)
0000000000000000000000000000000000000000;;			err := c.CoreV1().PersistentVolumes().Delete(pvName, nil)
0000000000000000000000000000000000000000;;			if err != nil && !apierrs.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("PV Delete API error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete the Claim
0000000000000000000000000000000000000000;;	func DeletePersistentVolumeClaim(c clientset.Interface, pvcName string, ns string) error {
0000000000000000000000000000000000000000;;		if c != nil && len(pvcName) > 0 {
0000000000000000000000000000000000000000;;			Logf("Deleting PersistentVolumeClaim %q", pvcName)
0000000000000000000000000000000000000000;;			err := c.CoreV1().PersistentVolumeClaims(ns).Delete(pvcName, nil)
0000000000000000000000000000000000000000;;			if err != nil && !apierrs.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("PVC Delete API error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete the PVC and wait for the PV to enter its expected phase. Validate that the PV
0000000000000000000000000000000000000000;;	// has been reclaimed (assumption here about reclaimPolicy). Caller tells this func which
0000000000000000000000000000000000000000;;	// phase value to expect for the pv bound to the to-be-deleted claim.
0000000000000000000000000000000000000000;;	func DeletePVCandValidatePV(c clientset.Interface, ns string, pvc *v1.PersistentVolumeClaim, pv *v1.PersistentVolume, expectPVPhase v1.PersistentVolumePhase) error {
0000000000000000000000000000000000000000;;		pvname := pvc.Spec.VolumeName
0000000000000000000000000000000000000000;;		Logf("Deleting PVC %v to trigger reclamation of PV %v", pvc.Name, pvname)
0000000000000000000000000000000000000000;;		err := DeletePersistentVolumeClaim(c, pvc.Name, ns)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for the PV's phase to return to be `expectPVPhase`
0000000000000000000000000000000000000000;;		Logf("Waiting for reclaim process to complete.")
0000000000000000000000000000000000000000;;		err = WaitForPersistentVolumePhase(expectPVPhase, c, pv.Name, 1*time.Second, 300*time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("pv %q phase did not become %v: %v", pv.Name, expectPVPhase, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// examine the pv's ClaimRef and UID and compare to expected values
0000000000000000000000000000000000000000;;		pv, err = c.CoreV1().PersistentVolumes().Get(pv.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("PV Get API error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cr := pv.Spec.ClaimRef
0000000000000000000000000000000000000000;;		if expectPVPhase == v1.VolumeAvailable {
0000000000000000000000000000000000000000;;			if cr != nil && len(cr.UID) > 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("PV is 'Available' but ClaimRef.UID is not empty")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if expectPVPhase == v1.VolumeBound {
0000000000000000000000000000000000000000;;			if cr == nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("PV is 'Bound' but ClaimRef is nil")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(cr.UID) == 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("PV is 'Bound' but ClaimRef.UID is empty")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Logf("PV %v now in %q phase", pv.Name, expectPVPhase)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wraps deletePVCandValidatePV() by calling the function in a loop over the PV map. Only bound PVs
0000000000000000000000000000000000000000;;	// are deleted. Validates that the claim was deleted and the PV is in the expected Phase (Released,
0000000000000000000000000000000000000000;;	// Available, Bound).
0000000000000000000000000000000000000000;;	// Note: if there are more claims than pvs then some of the remaining claims may bind to just made
0000000000000000000000000000000000000000;;	//   available pvs.
0000000000000000000000000000000000000000;;	func DeletePVCandValidatePVGroup(c clientset.Interface, ns string, pvols PVMap, claims PVCMap, expectPVPhase v1.PersistentVolumePhase) error {
0000000000000000000000000000000000000000;;		var boundPVs, deletedPVCs int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for pvName := range pvols {
0000000000000000000000000000000000000000;;			pv, err := c.CoreV1().PersistentVolumes().Get(pvName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("PV Get API error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cr := pv.Spec.ClaimRef
0000000000000000000000000000000000000000;;			// if pv is bound then delete the pvc it is bound to
0000000000000000000000000000000000000000;;			if cr != nil && len(cr.Name) > 0 {
0000000000000000000000000000000000000000;;				boundPVs++
0000000000000000000000000000000000000000;;				// Assert bound PVC is tracked in this test. Failing this might
0000000000000000000000000000000000000000;;				// indicate external PVCs interfering with the test.
0000000000000000000000000000000000000000;;				pvcKey := makePvcKey(ns, cr.Name)
0000000000000000000000000000000000000000;;				if _, found := claims[pvcKey]; !found {
0000000000000000000000000000000000000000;;					return fmt.Errorf("internal: claims map is missing pvc %q", pvcKey)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// get the pvc for the delete call below
0000000000000000000000000000000000000000;;				pvc, err := c.CoreV1().PersistentVolumeClaims(ns).Get(cr.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					if err = DeletePVCandValidatePV(c, ns, pvc, pv, expectPVPhase); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if !apierrs.IsNotFound(err) {
0000000000000000000000000000000000000000;;					return fmt.Errorf("PVC Get API error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// delete pvckey from map even if apierrs.IsNotFound above is true and thus the
0000000000000000000000000000000000000000;;				// claim was not actually deleted here
0000000000000000000000000000000000000000;;				delete(claims, pvcKey)
0000000000000000000000000000000000000000;;				deletedPVCs++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if boundPVs != deletedPVCs {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expect number of bound PVs (%v) to equal number of deleted PVCs (%v)", boundPVs, deletedPVCs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// create the PV resource. Fails test on error.
0000000000000000000000000000000000000000;;	func createPV(c clientset.Interface, pv *v1.PersistentVolume) (*v1.PersistentVolume, error) {
0000000000000000000000000000000000000000;;		pv, err := c.CoreV1().PersistentVolumes().Create(pv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("PV Create API error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pv, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// create the PVC resource. Fails test on error.
0000000000000000000000000000000000000000;;	func CreatePVC(c clientset.Interface, ns string, pvc *v1.PersistentVolumeClaim) (*v1.PersistentVolumeClaim, error) {
0000000000000000000000000000000000000000;;		pvc, err := c.CoreV1().PersistentVolumeClaims(ns).Create(pvc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("PVC Create API error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pvc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a PVC followed by the PV based on the passed in nfs-server ip and
0000000000000000000000000000000000000000;;	// namespace. If the "preBind" bool is true then pre-bind the PV to the PVC
0000000000000000000000000000000000000000;;	// via the PV's ClaimRef. Return the pv and pvc to reflect the created objects.
0000000000000000000000000000000000000000;;	// Note: in the pre-bind case the real PVC name, which is generated, is not
0000000000000000000000000000000000000000;;	//   known until after the PVC is instantiated. This is why the pvc is created
0000000000000000000000000000000000000000;;	//   before the pv.
0000000000000000000000000000000000000000;;	func CreatePVCPV(c clientset.Interface, pvConfig PersistentVolumeConfig, pvcConfig PersistentVolumeClaimConfig, ns string, preBind bool) (*v1.PersistentVolume, *v1.PersistentVolumeClaim, error) {
0000000000000000000000000000000000000000;;		// make the pvc spec
0000000000000000000000000000000000000000;;		pvc := MakePersistentVolumeClaim(pvcConfig, ns)
0000000000000000000000000000000000000000;;		preBindMsg := ""
0000000000000000000000000000000000000000;;		if preBind {
0000000000000000000000000000000000000000;;			preBindMsg = " pre-bound"
0000000000000000000000000000000000000000;;			pvConfig.Prebind = pvc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// make the pv spec
0000000000000000000000000000000000000000;;		pv := MakePersistentVolume(pvConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating a PVC followed by a%s PV", preBindMsg))
0000000000000000000000000000000000000000;;		pvc, err := CreatePVC(c, ns, pvc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// instantiate the pv, handle pre-binding by ClaimRef if needed
0000000000000000000000000000000000000000;;		if preBind {
0000000000000000000000000000000000000000;;			pv.Spec.ClaimRef.Name = pvc.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pv, err = createPV(c, pv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, pvc, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pv, pvc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a PV followed by the PVC based on the passed in nfs-server ip and
0000000000000000000000000000000000000000;;	// namespace. If the "preBind" bool is true then pre-bind the PVC to the PV
0000000000000000000000000000000000000000;;	// via the PVC's VolumeName. Return the pv and pvc to reflect the created
0000000000000000000000000000000000000000;;	// objects.
0000000000000000000000000000000000000000;;	// Note: in the pre-bind case the real PV name, which is generated, is not
0000000000000000000000000000000000000000;;	//   known until after the PV is instantiated. This is why the pv is created
0000000000000000000000000000000000000000;;	//   before the pvc.
0000000000000000000000000000000000000000;;	func CreatePVPVC(c clientset.Interface, pvConfig PersistentVolumeConfig, pvcConfig PersistentVolumeClaimConfig, ns string, preBind bool) (*v1.PersistentVolume, *v1.PersistentVolumeClaim, error) {
0000000000000000000000000000000000000000;;		preBindMsg := ""
0000000000000000000000000000000000000000;;		if preBind {
0000000000000000000000000000000000000000;;			preBindMsg = " pre-bound"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Logf("Creating a PV followed by a%s PVC", preBindMsg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// make the pv and pvc definitions
0000000000000000000000000000000000000000;;		pv := MakePersistentVolume(pvConfig)
0000000000000000000000000000000000000000;;		pvc := MakePersistentVolumeClaim(pvcConfig, ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// instantiate the pv
0000000000000000000000000000000000000000;;		pv, err := createPV(c, pv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// instantiate the pvc, handle pre-binding by VolumeName if needed
0000000000000000000000000000000000000000;;		if preBind {
0000000000000000000000000000000000000000;;			pvc.Spec.VolumeName = pv.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pvc, err = CreatePVC(c, ns, pvc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return pv, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pv, pvc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create the desired number of PVs and PVCs and return them in separate maps. If the
0000000000000000000000000000000000000000;;	// number of PVs != the number of PVCs then the min of those two counts is the number of
0000000000000000000000000000000000000000;;	// PVs expected to bind. If a Create error occurs, the returned maps may contain pv and pvc
0000000000000000000000000000000000000000;;	// entries for the resources that were successfully created. In other words, when the caller
0000000000000000000000000000000000000000;;	// sees an error returned, it needs to decide what to do about entries in the maps.
0000000000000000000000000000000000000000;;	// Note: when the test suite deletes the namespace orphaned pvcs and pods are deleted. However,
0000000000000000000000000000000000000000;;	//   orphaned pvs are not deleted and will remain after the suite completes.
0000000000000000000000000000000000000000;;	func CreatePVsPVCs(numpvs, numpvcs int, c clientset.Interface, ns string, pvConfig PersistentVolumeConfig, pvcConfig PersistentVolumeClaimConfig) (PVMap, PVCMap, error) {
0000000000000000000000000000000000000000;;		pvMap := make(PVMap, numpvs)
0000000000000000000000000000000000000000;;		pvcMap := make(PVCMap, numpvcs)
0000000000000000000000000000000000000000;;		extraPVCs := 0
0000000000000000000000000000000000000000;;		extraPVs := numpvs - numpvcs
0000000000000000000000000000000000000000;;		if extraPVs < 0 {
0000000000000000000000000000000000000000;;			extraPVCs = -extraPVs
0000000000000000000000000000000000000000;;			extraPVs = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pvsToCreate := numpvs - extraPVs // want the min(numpvs, numpvcs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create pvs and pvcs
0000000000000000000000000000000000000000;;		for i := 0; i < pvsToCreate; i++ {
0000000000000000000000000000000000000000;;			pv, pvc, err := CreatePVPVC(c, pvConfig, pvcConfig, ns, false)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return pvMap, pvcMap, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pvMap[pv.Name] = pvval{}
0000000000000000000000000000000000000000;;			pvcMap[makePvcKey(ns, pvc.Name)] = pvcval{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create extra pvs or pvcs as needed
0000000000000000000000000000000000000000;;		for i := 0; i < extraPVs; i++ {
0000000000000000000000000000000000000000;;			pv := MakePersistentVolume(pvConfig)
0000000000000000000000000000000000000000;;			pv, err := createPV(c, pv)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return pvMap, pvcMap, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pvMap[pv.Name] = pvval{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < extraPVCs; i++ {
0000000000000000000000000000000000000000;;			pvc := MakePersistentVolumeClaim(pvcConfig, ns)
0000000000000000000000000000000000000000;;			pvc, err := CreatePVC(c, ns, pvc)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return pvMap, pvcMap, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pvcMap[makePvcKey(ns, pvc.Name)] = pvcval{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pvMap, pvcMap, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait for the pv and pvc to bind to each other.
0000000000000000000000000000000000000000;;	func WaitOnPVandPVC(c clientset.Interface, ns string, pv *v1.PersistentVolume, pvc *v1.PersistentVolumeClaim) error {
0000000000000000000000000000000000000000;;		// Wait for newly created PVC to bind to the PV
0000000000000000000000000000000000000000;;		Logf("Waiting for PV %v to bind to PVC %v", pv.Name, pvc.Name)
0000000000000000000000000000000000000000;;		err := WaitForPersistentVolumeClaimPhase(v1.ClaimBound, c, ns, pvc.Name, 3*time.Second, 300*time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("PVC %q did not become Bound: %v", pvc.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for PersistentVolume.Status.Phase to be Bound, which it should be
0000000000000000000000000000000000000000;;		// since the PVC is already bound.
0000000000000000000000000000000000000000;;		err = WaitForPersistentVolumePhase(v1.VolumeBound, c, pv.Name, 3*time.Second, 300*time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("PV %q did not become Bound: %v", pv.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Re-get the pv and pvc objects
0000000000000000000000000000000000000000;;		pv, err = c.CoreV1().PersistentVolumes().Get(pv.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("PV Get API error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pvc, err = c.CoreV1().PersistentVolumeClaims(ns).Get(pvc.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("PVC Get API error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The pv and pvc are both bound, but to each other?
0000000000000000000000000000000000000000;;		// Check that the PersistentVolume.ClaimRef matches the PVC
0000000000000000000000000000000000000000;;		if pv.Spec.ClaimRef == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("PV %q ClaimRef is nil", pv.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.ClaimRef.Name != pvc.Name {
0000000000000000000000000000000000000000;;			return fmt.Errorf("PV %q ClaimRef's name (%q) should be %q", pv.Name, pv.Spec.ClaimRef.Name, pvc.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pvc.Spec.VolumeName != pv.Name {
0000000000000000000000000000000000000000;;			return fmt.Errorf("PVC %q VolumeName (%q) should be %q", pvc.Name, pvc.Spec.VolumeName, pv.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.ClaimRef.UID != pvc.UID {
0000000000000000000000000000000000000000;;			return fmt.Errorf("PV %q ClaimRef's UID (%q) should be %q", pv.Name, pv.Spec.ClaimRef.UID, pvc.UID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Search for bound PVs and PVCs by examining pvols for non-nil claimRefs.
0000000000000000000000000000000000000000;;	// NOTE: Each iteration waits for a maximum of 3 minutes per PV and, if the PV is bound,
0000000000000000000000000000000000000000;;	//   up to 3 minutes for the PVC. When the number of PVs != number of PVCs, this can lead
0000000000000000000000000000000000000000;;	//   to situations where the maximum wait times are reached several times in succession,
0000000000000000000000000000000000000000;;	//   extending test time. Thus, it is recommended to keep the delta between PVs and PVCs
0000000000000000000000000000000000000000;;	//   small.
0000000000000000000000000000000000000000;;	func WaitAndVerifyBinds(c clientset.Interface, ns string, pvols PVMap, claims PVCMap, testExpected bool) error {
0000000000000000000000000000000000000000;;		var actualBinds int
0000000000000000000000000000000000000000;;		expectedBinds := len(pvols)
0000000000000000000000000000000000000000;;		if expectedBinds > len(claims) { // want the min of # pvs or #pvcs
0000000000000000000000000000000000000000;;			expectedBinds = len(claims)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for pvName := range pvols {
0000000000000000000000000000000000000000;;			err := WaitForPersistentVolumePhase(v1.VolumeBound, c, pvName, 3*time.Second, 180*time.Second)
0000000000000000000000000000000000000000;;			if err != nil && len(pvols) > len(claims) {
0000000000000000000000000000000000000000;;				Logf("WARN: pv %v is not bound after max wait", pvName)
0000000000000000000000000000000000000000;;				Logf("      This may be ok since there are more pvs than pvcs")
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("PV %q did not become Bound: %v", pvName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pv, err := c.CoreV1().PersistentVolumes().Get(pvName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("PV Get API error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cr := pv.Spec.ClaimRef
0000000000000000000000000000000000000000;;			if cr != nil && len(cr.Name) > 0 {
0000000000000000000000000000000000000000;;				// Assert bound pvc is a test resource. Failing assertion could
0000000000000000000000000000000000000000;;				// indicate non-test PVC interference or a bug in the test
0000000000000000000000000000000000000000;;				pvcKey := makePvcKey(ns, cr.Name)
0000000000000000000000000000000000000000;;				if _, found := claims[pvcKey]; !found {
0000000000000000000000000000000000000000;;					return fmt.Errorf("internal: claims map is missing pvc %q", pvcKey)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err := WaitForPersistentVolumeClaimPhase(v1.ClaimBound, c, ns, cr.Name, 3*time.Second, 180*time.Second)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("PVC %q did not become Bound: %v", cr.Name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				actualBinds++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if testExpected && actualBinds != expectedBinds {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expect number of bound PVs (%v) to equal number of claims (%v)", actualBinds, expectedBinds)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test the pod's exit code to be zero.
0000000000000000000000000000000000000000;;	func testPodSuccessOrFail(c clientset.Interface, ns string, pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		By("Pod should terminate with exitcode 0 (success)")
0000000000000000000000000000000000000000;;		if err := WaitForPodSuccessInNamespace(c, pod.Name, ns); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("pod %q failed to reach Success: %v", pod.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Logf("Pod %v succeeded ", pod.Name)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Deletes the passed-in pod and waits for the pod to be terminated. Resilient to the pod
0000000000000000000000000000000000000000;;	// not existing.
0000000000000000000000000000000000000000;;	func DeletePodWithWait(f *Framework, c clientset.Interface, pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		if pod == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Logf("Deleting pod %v", pod.Name)
0000000000000000000000000000000000000000;;		err := c.CoreV1().Pods(pod.Namespace).Delete(pod.Name, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if apierrs.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return nil // assume pod was deleted already
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Errorf("pod Get API error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait for pod to terminate
0000000000000000000000000000000000000000;;		err = f.WaitForPodTerminated(pod.Name, "")
0000000000000000000000000000000000000000;;		if err != nil && !apierrs.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error deleting pod %q: %v", pod.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if apierrs.IsNotFound(err) {
0000000000000000000000000000000000000000;;			Logf("Ignore \"not found\" error above. Pod %q successfully deleted", pod.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create the test pod, wait for (hopefully) success, and then delete the pod.
0000000000000000000000000000000000000000;;	// Note: need named return value so that the err assignment in the defer sets the returned error.
0000000000000000000000000000000000000000;;	//       Has been shown to be necessary using Go 1.7.
0000000000000000000000000000000000000000;;	func CreateWaitAndDeletePod(f *Framework, c clientset.Interface, ns string, pvc *v1.PersistentVolumeClaim) (err error) {
0000000000000000000000000000000000000000;;		Logf("Creating nfs test pod")
0000000000000000000000000000000000000000;;		pod := MakeWritePod(ns, pvc)
0000000000000000000000000000000000000000;;		runPod, err := c.CoreV1().Pods(ns).Create(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("pod Create API error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			delErr := DeletePodWithWait(f, c, runPod)
0000000000000000000000000000000000000000;;			if err == nil { // don't override previous err value
0000000000000000000000000000000000000000;;				err = delErr // assign to returned err, can be nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = testPodSuccessOrFail(c, ns, runPod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("pod %q did not exit with Success: %v", runPod.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return // note: named return value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sanity check for GCE testing.  Verify the persistent disk attached to the node.
0000000000000000000000000000000000000000;;	func VerifyGCEDiskAttached(diskName string, nodeName types.NodeName) (bool, error) {
0000000000000000000000000000000000000000;;		gceCloud, err := GetGCECloud()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("GetGCECloud error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		isAttached, err := gceCloud.DiskIsAttached(diskName, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("cannot verify if GCE disk is attached: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return isAttached, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return a pvckey struct.
0000000000000000000000000000000000000000;;	func makePvcKey(ns, name string) types.NamespacedName {
0000000000000000000000000000000000000000;;		return types.NamespacedName{Namespace: ns, Name: name}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a PV definition based on the nfs server IP. If the PVC is not nil
0000000000000000000000000000000000000000;;	// then the PV is defined with a ClaimRef which includes the PVC's namespace.
0000000000000000000000000000000000000000;;	// If the PVC is nil then the PV is not defined with a ClaimRef.  If no reclaimPolicy
0000000000000000000000000000000000000000;;	// is assigned, assumes "Retain". Specs are expected to match the test's PVC.
0000000000000000000000000000000000000000;;	// Note: the passed-in claim does not have a name until it is created and thus the PV's
0000000000000000000000000000000000000000;;	//   ClaimRef cannot be completely filled-in in this func. Therefore, the ClaimRef's name
0000000000000000000000000000000000000000;;	//   is added later in CreatePVCPV.
0000000000000000000000000000000000000000;;	func MakePersistentVolume(pvConfig PersistentVolumeConfig) *v1.PersistentVolume {
0000000000000000000000000000000000000000;;		var claimRef *v1.ObjectReference
0000000000000000000000000000000000000000;;		// If the reclaimPolicy is not provided, assume Retain
0000000000000000000000000000000000000000;;		if pvConfig.ReclaimPolicy == "" {
0000000000000000000000000000000000000000;;			Logf("PV ReclaimPolicy unspecified, default: Retain")
0000000000000000000000000000000000000000;;			pvConfig.ReclaimPolicy = v1.PersistentVolumeReclaimRetain
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pvConfig.Prebind != nil {
0000000000000000000000000000000000000000;;			claimRef = &v1.ObjectReference{
0000000000000000000000000000000000000000;;				Name:      pvConfig.Prebind.Name,
0000000000000000000000000000000000000000;;				Namespace: pvConfig.Prebind.Namespace,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pv := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				GenerateName: pvConfig.NamePrefix,
0000000000000000000000000000000000000000;;				Labels:       pvConfig.Labels,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					volumehelper.VolumeGidAnnotationKey: "777",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeReclaimPolicy: pvConfig.ReclaimPolicy,
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceName(v1.ResourceStorage): resource.MustParse("2Gi"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PersistentVolumeSource: pvConfig.PVSource,
0000000000000000000000000000000000000000;;				AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;					v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;					v1.ReadOnlyMany,
0000000000000000000000000000000000000000;;					v1.ReadWriteMany,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ClaimRef:         claimRef,
0000000000000000000000000000000000000000;;				StorageClassName: pvConfig.StorageClassName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := helper.StorageNodeAffinityToAlphaAnnotation(pv.Annotations, pvConfig.NodeAffinity)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Logf("Setting storage node affinity failed: %v", err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pv
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a PVC definition based on the namespace.
0000000000000000000000000000000000000000;;	// Note: if this PVC is intended to be pre-bound to a PV, whose name is not
0000000000000000000000000000000000000000;;	//   known until the PV is instantiated, then the func CreatePVPVC will add
0000000000000000000000000000000000000000;;	//   pvc.Spec.VolumeName to this claim.
0000000000000000000000000000000000000000;;	func MakePersistentVolumeClaim(cfg PersistentVolumeClaimConfig, ns string) *v1.PersistentVolumeClaim {
0000000000000000000000000000000000000000;;		// Specs are expected to match this test's PersistentVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(cfg.AccessModes) == 0 {
0000000000000000000000000000000000000000;;			Logf("AccessModes unspecified, default: all modes (RWO, RWX, ROX).")
0000000000000000000000000000000000000000;;			cfg.AccessModes = append(cfg.AccessModes, v1.ReadWriteOnce, v1.ReadOnlyMany, v1.ReadOnlyMany)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				GenerateName: "pvc-",
0000000000000000000000000000000000000000;;				Namespace:    ns,
0000000000000000000000000000000000000000;;				Annotations:  cfg.Annotations,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				Selector:    cfg.Selector,
0000000000000000000000000000000000000000;;				AccessModes: cfg.AccessModes,
0000000000000000000000000000000000000000;;				Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;					Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): resource.MustParse("1Gi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				StorageClassName: cfg.StorageClassName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPDWithRetry(zone string) (string, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < PDRetryTimeout; time.Sleep(PDRetryPollTime) {
0000000000000000000000000000000000000000;;			newDiskName, err := createPD(zone)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				Logf("Couldn't create a new PD, sleeping 5 seconds: %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Logf("Successfully created a new PD: %q.", newDiskName)
0000000000000000000000000000000000000000;;			return newDiskName, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreatePDWithRetry() (string, error) {
0000000000000000000000000000000000000000;;		return createPDWithRetry("")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreatePDWithRetryAndZone(zone string) (string, error) {
0000000000000000000000000000000000000000;;		return createPDWithRetry(zone)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DeletePDWithRetry(diskName string) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < PDRetryTimeout; time.Sleep(PDRetryPollTime) {
0000000000000000000000000000000000000000;;			err = deletePD(diskName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				Logf("Couldn't delete PD %q, sleeping %v: %v", diskName, PDRetryPollTime, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Logf("Successfully deleted PD %q.", diskName)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("unable to delete PD %q: %v", diskName, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPD(zone string) (string, error) {
0000000000000000000000000000000000000000;;		if zone == "" {
0000000000000000000000000000000000000000;;			zone = TestContext.CloudConfig.Zone
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if TestContext.Provider == "gce" || TestContext.Provider == "gke" {
0000000000000000000000000000000000000000;;			pdName := fmt.Sprintf("%s-%s", TestContext.Prefix, string(uuid.NewUUID()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			gceCloud, err := GetGCECloud()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tags := map[string]string{}
0000000000000000000000000000000000000000;;			err = gceCloud.CreateDisk(pdName, gcecloud.DiskTypeSSD, zone, 10 /* sizeGb */, tags)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return pdName, nil
0000000000000000000000000000000000000000;;		} else if TestContext.Provider == "aws" {
0000000000000000000000000000000000000000;;			client := ec2.New(session.New())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			request := &ec2.CreateVolumeInput{}
0000000000000000000000000000000000000000;;			request.AvailabilityZone = aws.String(zone)
0000000000000000000000000000000000000000;;			request.Size = aws.Int64(10)
0000000000000000000000000000000000000000;;			request.VolumeType = aws.String(awscloud.DefaultVolumeType)
0000000000000000000000000000000000000000;;			response, err := client.CreateVolume(request)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			az := aws.StringValue(response.AvailabilityZone)
0000000000000000000000000000000000000000;;			awsID := aws.StringValue(response.VolumeId)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			volumeName := "aws://" + az + "/" + awsID
0000000000000000000000000000000000000000;;			return volumeName, nil
0000000000000000000000000000000000000000;;		} else if TestContext.Provider == "azure" {
0000000000000000000000000000000000000000;;			pdName := fmt.Sprintf("%s-%s", TestContext.Prefix, string(uuid.NewUUID()))
0000000000000000000000000000000000000000;;			azureCloud, err := GetAzureCloud()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, diskUri, _, err := azureCloud.CreateVolume(pdName, "" /* account */, "" /* sku */, "" /* location */, 1 /* sizeGb */)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return diskUri, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("provider does not support volume creation")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deletePD(pdName string) error {
0000000000000000000000000000000000000000;;		if TestContext.Provider == "gce" || TestContext.Provider == "gke" {
0000000000000000000000000000000000000000;;			gceCloud, err := GetGCECloud()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = gceCloud.DeleteDisk(pdName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if gerr, ok := err.(*googleapi.Error); ok && len(gerr.Errors) > 0 && gerr.Errors[0].Reason == "notFound" {
0000000000000000000000000000000000000000;;					// PD already exists, ignore error.
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Logf("error deleting PD %q: %v", pdName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else if TestContext.Provider == "aws" {
0000000000000000000000000000000000000000;;			client := ec2.New(session.New())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tokens := strings.Split(pdName, "/")
0000000000000000000000000000000000000000;;			awsVolumeID := tokens[len(tokens)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			request := &ec2.DeleteVolumeInput{VolumeId: aws.String(awsVolumeID)}
0000000000000000000000000000000000000000;;			_, err := client.DeleteVolume(request)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if awsError, ok := err.(awserr.Error); ok && awsError.Code() == "InvalidVolume.NotFound" {
0000000000000000000000000000000000000000;;					Logf("volume deletion implicitly succeeded because volume %q does not exist.", pdName)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return fmt.Errorf("error deleting EBS volumes: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else if TestContext.Provider == "azure" {
0000000000000000000000000000000000000000;;			azureCloud, err := GetAzureCloud()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			diskName := pdName[(strings.LastIndex(pdName, "/") + 1):]
0000000000000000000000000000000000000000;;			err = azureCloud.DeleteVolume(diskName, pdName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				Logf("failed to delete Azure volume %q: %v", pdName, err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return fmt.Errorf("provider does not support volume deletion")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a pod definition based on the namespace. The pod references the PVC's
0000000000000000000000000000000000000000;;	// name.
0000000000000000000000000000000000000000;;	func MakeWritePod(ns string, pvc *v1.PersistentVolumeClaim) *v1.Pod {
0000000000000000000000000000000000000000;;		return MakePod(ns, []*v1.PersistentVolumeClaim{pvc}, true, "touch /mnt/volume1/SUCCESS && (id -G | grep -E '\\b777\\b')")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a pod definition based on the namespace. The pod references the PVC's
0000000000000000000000000000000000000000;;	// name.  A slice of BASH commands can be supplied as args to be run by the pod
0000000000000000000000000000000000000000;;	func MakePod(ns string, pvclaims []*v1.PersistentVolumeClaim, isPrivileged bool, command string) *v1.Pod {
0000000000000000000000000000000000000000;;		if len(command) == 0 {
0000000000000000000000000000000000000000;;			command = "while true; do sleep 1; done"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podSpec := &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				GenerateName: "pvc-tester-",
0000000000000000000000000000000000000000;;				Namespace:    ns,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:    "write-pod",
0000000000000000000000000000000000000000;;						Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;						Command: []string{"/bin/sh"},
0000000000000000000000000000000000000000;;						Args:    []string{"-c", command},
0000000000000000000000000000000000000000;;						SecurityContext: &v1.SecurityContext{
0000000000000000000000000000000000000000;;							Privileged: &isPrivileged,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyOnFailure,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var volumeMounts = make([]v1.VolumeMount, len(pvclaims))
0000000000000000000000000000000000000000;;		var volumes = make([]v1.Volume, len(pvclaims))
0000000000000000000000000000000000000000;;		for index, pvclaim := range pvclaims {
0000000000000000000000000000000000000000;;			volumename := fmt.Sprintf("volume%v", index+1)
0000000000000000000000000000000000000000;;			volumeMounts[index] = v1.VolumeMount{Name: volumename, MountPath: "/mnt/" + volumename}
0000000000000000000000000000000000000000;;			volumes[index] = v1.Volume{Name: volumename, VolumeSource: v1.VolumeSource{PersistentVolumeClaim: &v1.PersistentVolumeClaimVolumeSource{ClaimName: pvclaim.Name, ReadOnly: false}}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podSpec.Spec.Containers[0].VolumeMounts = volumeMounts
0000000000000000000000000000000000000000;;		podSpec.Spec.Volumes = volumes
0000000000000000000000000000000000000000;;		return podSpec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// create pod with given claims
0000000000000000000000000000000000000000;;	func CreatePod(client clientset.Interface, namespace string, pvclaims []*v1.PersistentVolumeClaim, isPrivileged bool, command string) (*v1.Pod, error) {
0000000000000000000000000000000000000000;;		pod := MakePod(namespace, pvclaims, isPrivileged, command)
0000000000000000000000000000000000000000;;		pod, err := client.CoreV1().Pods(namespace).Create(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("pod Create API error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Waiting for pod to be running
0000000000000000000000000000000000000000;;		err = WaitForPodNameRunningInNamespace(client, pod.Name, namespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return pod, fmt.Errorf("pod %q is not Running: %v", pod.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// get fresh pod info
0000000000000000000000000000000000000000;;		pod, err = client.CoreV1().Pods(namespace).Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return pod, fmt.Errorf("pod Get API error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Define and create a pod with a mounted PV.  Pod runs infinite loop until killed.
0000000000000000000000000000000000000000;;	func CreateClientPod(c clientset.Interface, ns string, pvc *v1.PersistentVolumeClaim) (*v1.Pod, error) {
0000000000000000000000000000000000000000;;		return CreatePod(c, ns, []*v1.PersistentVolumeClaim{pvc}, true, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wait until all pvcs phase set to bound
0000000000000000000000000000000000000000;;	func WaitForPVClaimBoundPhase(client clientset.Interface, pvclaims []*v1.PersistentVolumeClaim) ([]*v1.PersistentVolume, error) {
0000000000000000000000000000000000000000;;		persistentvolumes := make([]*v1.PersistentVolume, len(pvclaims))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, claim := range pvclaims {
0000000000000000000000000000000000000000;;			err := WaitForPersistentVolumeClaimPhase(v1.ClaimBound, client, claim.Namespace, claim.Name, Poll, ClaimProvisionTimeout)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return persistentvolumes, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Get new copy of the claim
0000000000000000000000000000000000000000;;			claim, err = client.CoreV1().PersistentVolumeClaims(claim.Namespace).Get(claim.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return persistentvolumes, fmt.Errorf("PVC Get API error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Get the bounded PV
0000000000000000000000000000000000000000;;			persistentvolumes[index], err = client.CoreV1().PersistentVolumes().Get(claim.Spec.VolumeName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return persistentvolumes, fmt.Errorf("PV Get API error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return persistentvolumes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreatePVSource(zone string) (*v1.PersistentVolumeSource, error) {
0000000000000000000000000000000000000000;;		diskName, err := CreatePDWithRetryAndZone(zone)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if TestContext.Provider == "gce" || TestContext.Provider == "gke" {
0000000000000000000000000000000000000000;;			return &v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;				GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;					PDName:   diskName,
0000000000000000000000000000000000000000;;					FSType:   "ext3",
0000000000000000000000000000000000000000;;					ReadOnly: false,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		} else if TestContext.Provider == "aws" {
0000000000000000000000000000000000000000;;			return &v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;				AWSElasticBlockStore: &v1.AWSElasticBlockStoreVolumeSource{
0000000000000000000000000000000000000000;;					VolumeID: diskName,
0000000000000000000000000000000000000000;;					FSType:   "ext3",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Provider not supported")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DeletePVSource(pvSource *v1.PersistentVolumeSource) error {
0000000000000000000000000000000000000000;;		if TestContext.Provider == "gce" || TestContext.Provider == "gke" {
0000000000000000000000000000000000000000;;			return DeletePDWithRetry(pvSource.GCEPersistentDisk.PDName)
0000000000000000000000000000000000000000;;		} else if TestContext.Provider == "aws" {
0000000000000000000000000000000000000000;;			return DeletePDWithRetry(pvSource.AWSElasticBlockStore.VolumeID)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Provider not supported")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
