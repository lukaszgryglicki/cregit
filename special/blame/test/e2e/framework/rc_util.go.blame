0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
85d1525fa9e0b72acef4da4572eaabcf8182028a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		testutils "k8s.io/kubernetes/test/utils"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RcByNamePort returns a ReplicationController with specified name and port
0000000000000000000000000000000000000000;;	func RcByNamePort(name string, replicas int32, image string, port int, protocol v1.Protocol,
0000000000000000000000000000000000000000;;		labels map[string]string, gracePeriod *int64) *v1.ReplicationController {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return RcByNameContainer(name, replicas, image, labels, v1.Container{
0000000000000000000000000000000000000000;;			Name:  name,
0000000000000000000000000000000000000000;;			Image: image,
0000000000000000000000000000000000000000;;			Ports: []v1.ContainerPort{{ContainerPort: int32(port), Protocol: protocol}},
0000000000000000000000000000000000000000;;		}, gracePeriod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RcByNameContainer returns a ReplicationControoler with specified name and container
0000000000000000000000000000000000000000;;	func RcByNameContainer(name string, replicas int32, image string, labels map[string]string, c v1.Container,
0000000000000000000000000000000000000000;;		gracePeriod *int64) *v1.ReplicationController {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		zeroGracePeriod := int64(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add "name": name to the labels, overwriting if it exists.
0000000000000000000000000000000000000000;;		labels["name"] = name
0000000000000000000000000000000000000000;;		if gracePeriod == nil {
0000000000000000000000000000000000000000;;			gracePeriod = &zeroGracePeriod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &v1.ReplicationController{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "ReplicationController",
0000000000000000000000000000000000000000;;				APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;				Replicas: func(i int32) *int32 { return &i }(replicas),
0000000000000000000000000000000000000000;;				Selector: map[string]string{
0000000000000000000000000000000000000000;;					"name": name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: labels,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers:                    []v1.Container{c},
0000000000000000000000000000000000000000;;						TerminationGracePeriodSeconds: gracePeriod,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScaleRCByLabels scales an RC via ns/label lookup. If replicas == 0 it waits till
0000000000000000000000000000000000000000;;	// none are running, otherwise it does what a synchronous scale operation would do.
0000000000000000000000000000000000000000;;	func ScaleRCByLabels(clientset clientset.Interface, internalClientset internalclientset.Interface, ns string, l map[string]string, replicas uint) error {
0000000000000000000000000000000000000000;;		listOpts := metav1.ListOptions{LabelSelector: labels.SelectorFromSet(labels.Set(l)).String()}
0000000000000000000000000000000000000000;;		rcs, err := clientset.Core().ReplicationControllers(ns).List(listOpts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rcs.Items) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("RC with labels %v not found in ns %v", l, ns)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Logf("Scaling %v RCs with labels %v in ns %v to %v replicas.", len(rcs.Items), l, ns, replicas)
0000000000000000000000000000000000000000;;		for _, labelRC := range rcs.Items {
0000000000000000000000000000000000000000;;			name := labelRC.Name
0000000000000000000000000000000000000000;;			if err := ScaleRC(clientset, internalClientset, ns, name, replicas, false); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rc, err := clientset.Core().ReplicationControllers(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if replicas == 0 {
0000000000000000000000000000000000000000;;				ps, err := podStoreForSelector(clientset, rc.Namespace, labels.SelectorFromSet(rc.Spec.Selector))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer ps.Stop()
0000000000000000000000000000000000000000;;				if err = waitForPodsGone(ps, 10*time.Second, 10*time.Minute); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("error while waiting for pods gone %s: %v", name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if err := testutils.WaitForPodsWithLabelRunning(
0000000000000000000000000000000000000000;;					clientset, ns, labels.SelectorFromSet(labels.Set(rc.Spec.Selector))); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type updateRcFunc func(d *v1.ReplicationController)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func UpdateReplicationControllerWithRetries(c clientset.Interface, namespace, name string, applyUpdate updateRcFunc) (*v1.ReplicationController, error) {
0000000000000000000000000000000000000000;;		var rc *v1.ReplicationController
0000000000000000000000000000000000000000;;		var updateErr error
0000000000000000000000000000000000000000;;		pollErr := wait.PollImmediate(10*time.Millisecond, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if rc, err = c.Core().ReplicationControllers(namespace).Get(name, metav1.GetOptions{}); err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Apply the update, then attempt to push it to the apiserver.
0000000000000000000000000000000000000000;;			applyUpdate(rc)
0000000000000000000000000000000000000000;;			if rc, err = c.Core().ReplicationControllers(namespace).Update(rc); err == nil {
0000000000000000000000000000000000000000;;				Logf("Updating replication controller %q", name)
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			updateErr = err
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if pollErr == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			pollErr = fmt.Errorf("couldn't apply the provided updated to rc %q: %v", name, updateErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rc, pollErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteRCAndWaitForGC deletes only the Replication Controller and waits for GC to delete the pods.
0000000000000000000000000000000000000000;;	func DeleteRCAndWaitForGC(c clientset.Interface, ns, name string) error {
0000000000000000000000000000000000000000;;		return DeleteResourceAndWaitForGC(c, api.Kind("ReplicationController"), ns, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DeleteRCAndPods(clientset clientset.Interface, internalClientset internalclientset.Interface, ns, name string) error {
0000000000000000000000000000000000000000;;		return DeleteResourceAndPods(clientset, internalClientset, api.Kind("ReplicationController"), ns, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ScaleRC(clientset clientset.Interface, internalClientset internalclientset.Interface, ns, name string, size uint, wait bool) error {
0000000000000000000000000000000000000000;;		return ScaleResource(clientset, internalClientset, ns, name, size, wait, api.Kind("ReplicationController"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunRC(config testutils.RCConfig) error {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("creating replication controller %s in namespace %s", config.Name, config.Namespace))
0000000000000000000000000000000000000000;;		config.NodeDumpFunc = DumpNodeDebugInfo
0000000000000000000000000000000000000000;;		config.ContainerDumpFunc = LogFailedContainers
0000000000000000000000000000000000000000;;		return testutils.RunRC(config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForRCPodToDisappear returns nil if the pod from the given replication controller (described by rcName) no longer exists.
0000000000000000000000000000000000000000;;	// In case of failure or too long waiting time, an error is returned.
0000000000000000000000000000000000000000;;	func WaitForRCPodToDisappear(c clientset.Interface, ns, rcName, podName string) error {
0000000000000000000000000000000000000000;;		label := labels.SelectorFromSet(labels.Set(map[string]string{"name": rcName}))
0000000000000000000000000000000000000000;;		// NodeController evicts pod after 5 minutes, so we need timeout greater than that to observe effects.
0000000000000000000000000000000000000000;;		// The grace period must be set to 0 on the pod for it to be deleted during the partition.
0000000000000000000000000000000000000000;;		// Otherwise, it goes to the 'Terminating' state till the kubelet confirms deletion.
0000000000000000000000000000000000000000;;		return WaitForPodToDisappear(c, ns, podName, label, 20*time.Second, 10*time.Minute)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForReplicationController waits until the RC appears (exist == true), or disappears (exist == false)
0000000000000000000000000000000000000000;;	func WaitForReplicationController(c clientset.Interface, namespace, name string, exist bool, interval, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(interval, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			_, err := c.Core().ReplicationControllers(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				Logf("Get ReplicationController %s in namespace %s failed (%v).", name, namespace, err)
0000000000000000000000000000000000000000;;				return !exist, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				Logf("ReplicationController %s in namespace %s found.", name, namespace)
0000000000000000000000000000000000000000;;				return exist, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			stateMsg := map[bool]string{true: "to appear", false: "to disappear"}
0000000000000000000000000000000000000000;;			return fmt.Errorf("error waiting for ReplicationController %s/%s %s: %v", namespace, name, stateMsg[exist], err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForReplicationControllerwithSelector waits until any RC with given selector appears (exist == true), or disappears (exist == false)
0000000000000000000000000000000000000000;;	func WaitForReplicationControllerwithSelector(c clientset.Interface, namespace string, selector labels.Selector, exist bool, interval,
0000000000000000000000000000000000000000;;		timeout time.Duration) error {
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(interval, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			rcs, err := c.Core().ReplicationControllers(namespace).List(metav1.ListOptions{LabelSelector: selector.String()})
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case len(rcs.Items) != 0:
0000000000000000000000000000000000000000;;				Logf("ReplicationController with %s in namespace %s found.", selector.String(), namespace)
0000000000000000000000000000000000000000;;				return exist, nil
0000000000000000000000000000000000000000;;			case len(rcs.Items) == 0:
0000000000000000000000000000000000000000;;				Logf("ReplicationController with %s in namespace %s disappeared.", selector.String(), namespace)
0000000000000000000000000000000000000000;;				return !exist, nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				Logf("List ReplicationController with %s in namespace %s failed: %v", selector.String(), namespace, err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			stateMsg := map[bool]string{true: "to appear", false: "to disappear"}
0000000000000000000000000000000000000000;;			return fmt.Errorf("error waiting for ReplicationControllers with %s in namespace %s %s: %v", selector.String(), namespace, stateMsg[exist], err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validatorFn is the function which is individual tests will implement.
0000000000000000000000000000000000000000;;	// we may want it to return more than just an error, at some point.
0000000000000000000000000000000000000000;;	type validatorFn func(c clientset.Interface, podID string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateController is a generic mechanism for testing RC's that are running.
0000000000000000000000000000000000000000;;	// It takes a container name, a test name, and a validator function which is plugged in by a specific test.
0000000000000000000000000000000000000000;;	// "containername": this is grepped for.
0000000000000000000000000000000000000000;;	// "containerImage" : this is the name of the image we expect to be launched.  Not to confuse w/ images (kitten.jpg)  which are validated.
0000000000000000000000000000000000000000;;	// "testname":  which gets bubbled up to the logging/failure messages if errors happen.
0000000000000000000000000000000000000000;;	// "validator" function: This function is given a podID and a client, and it can do some specific validations that way.
0000000000000000000000000000000000000000;;	func ValidateController(c clientset.Interface, containerImage string, replicas int, containername string, testname string, validator validatorFn, ns string) {
0000000000000000000000000000000000000000;;		getPodsTemplate := "--template={{range.items}}{{.metadata.name}} {{end}}"
0000000000000000000000000000000000000000;;		// NB: kubectl adds the "exists" function to the standard template functions.
0000000000000000000000000000000000000000;;		// This lets us check to see if the "running" entry exists for each of the containers
0000000000000000000000000000000000000000;;		// we care about. Exists will never return an error and it's safe to check a chain of
0000000000000000000000000000000000000000;;		// things, any one of which may not exist. In the below template, all of info,
0000000000000000000000000000000000000000;;		// containername, and running might be nil, so the normal index function isn't very
0000000000000000000000000000000000000000;;		// helpful.
0000000000000000000000000000000000000000;;		// This template is unit-tested in kubectl, so if you change it, update the unit test.
0000000000000000000000000000000000000000;;		// You can read about the syntax here: http://golang.org/pkg/text/template/.
0000000000000000000000000000000000000000;;		getContainerStateTemplate := fmt.Sprintf(`--template={{if (exists . "status" "containerStatuses")}}{{range .status.containerStatuses}}{{if (and (eq .name "%s") (exists . "state" "running"))}}true{{end}}{{end}}{{end}}`, containername)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		getImageTemplate := fmt.Sprintf(`--template={{if (exists . "status" "containerStatuses")}}{{range .status.containerStatuses}}{{if eq .name "%s"}}{{.image}}{{end}}{{end}}{{end}}`, containername)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("waiting for all containers in %s pods to come up.", testname)) //testname should be selector
0000000000000000000000000000000000000000;;	waitLoop:
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < PodStartTimeout; time.Sleep(5 * time.Second) {
0000000000000000000000000000000000000000;;			getPodsOutput := RunKubectlOrDie("get", "pods", "-o", "template", getPodsTemplate, "-l", testname, fmt.Sprintf("--namespace=%v", ns))
0000000000000000000000000000000000000000;;			pods := strings.Fields(getPodsOutput)
0000000000000000000000000000000000000000;;			if numPods := len(pods); numPods != replicas {
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Replicas for %s: expected=%d actual=%d", testname, replicas, numPods))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var runningPods []string
0000000000000000000000000000000000000000;;			for _, podID := range pods {
0000000000000000000000000000000000000000;;				running := RunKubectlOrDie("get", "pods", podID, "-o", "template", getContainerStateTemplate, fmt.Sprintf("--namespace=%v", ns))
0000000000000000000000000000000000000000;;				if running != "true" {
0000000000000000000000000000000000000000;;					Logf("%s is created but not running", podID)
0000000000000000000000000000000000000000;;					continue waitLoop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				currentImage := RunKubectlOrDie("get", "pods", podID, "-o", "template", getImageTemplate, fmt.Sprintf("--namespace=%v", ns))
0000000000000000000000000000000000000000;;				if currentImage != containerImage {
0000000000000000000000000000000000000000;;					Logf("%s is created but running wrong image; expected: %s, actual: %s", podID, containerImage, currentImage)
0000000000000000000000000000000000000000;;					continue waitLoop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Call the generic validator function here.
0000000000000000000000000000000000000000;;				// This might validate for example, that (1) getting a url works and (2) url is serving correct content.
0000000000000000000000000000000000000000;;				if err := validator(c, podID); err != nil {
0000000000000000000000000000000000000000;;					Logf("%s is running right image but validator function failed: %v", podID, err)
0000000000000000000000000000000000000000;;					continue waitLoop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Logf("%s is verified up and running", podID)
0000000000000000000000000000000000000000;;				runningPods = append(runningPods, podID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If we reach here, then all our checks passed.
0000000000000000000000000000000000000000;;			if len(runningPods) == replicas {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Reaching here means that one of more checks failed multiple times.  Assuming its not a race condition, something is broken.
0000000000000000000000000000000000000000;;		Failf("Timed out after %v seconds waiting for %s pods to reach valid state", PodStartTimeout.Seconds(), testname)
0000000000000000000000000000000000000000;;	}
