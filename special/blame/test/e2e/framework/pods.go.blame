0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2019ba2c3aa31c14511c89fd7bf5341a175cee77;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		v1core "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/events"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/sysctl"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const DefaultPodDeletionTimeout = 3 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ImageWhiteList is the images used in the current test suite. It should be initialized in test suite and
0000000000000000000000000000000000000000;;	// the images in the white list should be pre-pulled in the test suite.  Currently, this is only used by
0000000000000000000000000000000000000000;;	// node e2e test.
0000000000000000000000000000000000000000;;	var ImageWhiteList sets.String
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convenience method for getting a pod client interface in the framework's namespace,
0000000000000000000000000000000000000000;;	// possibly applying test-suite specific transformations to the pod spec, e.g. for
0000000000000000000000000000000000000000;;	// node e2e pod scheduling.
0000000000000000000000000000000000000000;;	func (f *Framework) PodClient() *PodClient {
0000000000000000000000000000000000000000;;		return &PodClient{
0000000000000000000000000000000000000000;;			f:            f,
0000000000000000000000000000000000000000;;			PodInterface: f.ClientSet.Core().Pods(f.Namespace.Name),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convenience method for getting a pod client interface in an alternative namespace,
0000000000000000000000000000000000000000;;	// possibly applying test-suite specific transformations to the pod spec, e.g. for
0000000000000000000000000000000000000000;;	// node e2e pod scheduling.
0000000000000000000000000000000000000000;;	func (f *Framework) PodClientNS(namespace string) *PodClient {
0000000000000000000000000000000000000000;;		return &PodClient{
0000000000000000000000000000000000000000;;			f:            f,
0000000000000000000000000000000000000000;;			PodInterface: f.ClientSet.Core().Pods(namespace),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PodClient struct {
0000000000000000000000000000000000000000;;		f *Framework
0000000000000000000000000000000000000000;;		v1core.PodInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create creates a new pod according to the framework specifications (don't wait for it to start).
0000000000000000000000000000000000000000;;	func (c *PodClient) Create(pod *v1.Pod) *v1.Pod {
0000000000000000000000000000000000000000;;		c.mungeSpec(pod)
0000000000000000000000000000000000000000;;		p, err := c.PodInterface.Create(pod)
0000000000000000000000000000000000000000;;		ExpectNoError(err, "Error creating Pod")
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateSync creates a new pod according to the framework specifications in the given namespace, and waits for it to start.
0000000000000000000000000000000000000000;;	func (c *PodClient) CreateSyncInNamespace(pod *v1.Pod, namespace string) *v1.Pod {
0000000000000000000000000000000000000000;;		p := c.Create(pod)
0000000000000000000000000000000000000000;;		ExpectNoError(WaitForPodNameRunningInNamespace(c.f.ClientSet, p.Name, namespace))
0000000000000000000000000000000000000000;;		// Get the newest pod after it becomes running, some status may change after pod created, such as pod ip.
0000000000000000000000000000000000000000;;		p, err := c.Get(p.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		ExpectNoError(err)
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateSync creates a new pod according to the framework specifications, and wait for it to start.
0000000000000000000000000000000000000000;;	func (c *PodClient) CreateSync(pod *v1.Pod) *v1.Pod {
0000000000000000000000000000000000000000;;		return c.CreateSyncInNamespace(pod, c.f.Namespace.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateBatch create a batch of pods. All pods are created before waiting.
0000000000000000000000000000000000000000;;	func (c *PodClient) CreateBatch(pods []*v1.Pod) []*v1.Pod {
0000000000000000000000000000000000000000;;		ps := make([]*v1.Pod, len(pods))
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		for i, pod := range pods {
0000000000000000000000000000000000000000;;			wg.Add(1)
0000000000000000000000000000000000000000;;			go func(i int, pod *v1.Pod) {
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;				defer GinkgoRecover()
0000000000000000000000000000000000000000;;				ps[i] = c.CreateSync(pod)
0000000000000000000000000000000000000000;;			}(i, pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		return ps
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update updates the pod object. It retries if there is a conflict, throw out error if
0000000000000000000000000000000000000000;;	// there is any other errors. name is the pod name, updateFn is the function updating the
0000000000000000000000000000000000000000;;	// pod object.
0000000000000000000000000000000000000000;;	func (c *PodClient) Update(name string, updateFn func(pod *v1.Pod)) {
0000000000000000000000000000000000000000;;		ExpectNoError(wait.Poll(time.Millisecond*500, time.Second*30, func() (bool, error) {
0000000000000000000000000000000000000000;;			pod, err := c.PodInterface.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("failed to get pod %q: %v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			updateFn(pod)
0000000000000000000000000000000000000000;;			_, err = c.PodInterface.Update(pod)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				Logf("Successfully updated pod %q", name)
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if errors.IsConflict(err) {
0000000000000000000000000000000000000000;;				Logf("Conflicting update to pod %q, re-get and re-update: %v", name, err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("failed to update pod %q: %v", name, err)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteSync deletes the pod and wait for the pod to disappear for `timeout`. If the pod doesn't
0000000000000000000000000000000000000000;;	// disappear before the timeout, it will fail the test.
0000000000000000000000000000000000000000;;	func (c *PodClient) DeleteSync(name string, options *metav1.DeleteOptions, timeout time.Duration) {
0000000000000000000000000000000000000000;;		c.DeleteSyncInNamespace(name, c.f.Namespace.Name, options, timeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteSyncInNamespace deletes the pod from the namespace and wait for the pod to disappear for `timeout`. If the pod doesn't
0000000000000000000000000000000000000000;;	// disappear before the timeout, it will fail the test.
0000000000000000000000000000000000000000;;	func (c *PodClient) DeleteSyncInNamespace(name string, namespace string, options *metav1.DeleteOptions, timeout time.Duration) {
0000000000000000000000000000000000000000;;		err := c.Delete(name, options)
0000000000000000000000000000000000000000;;		if err != nil && !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			Failf("Failed to delete pod %q: %v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Expect(WaitForPodToDisappear(c.f.ClientSet, namespace, name, labels.Everything(),
0000000000000000000000000000000000000000;;			2*time.Second, timeout)).To(Succeed(), "wait for pod %q to disappear", name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mungeSpec apply test-suite specific transformations to the pod spec.
0000000000000000000000000000000000000000;;	func (c *PodClient) mungeSpec(pod *v1.Pod) {
0000000000000000000000000000000000000000;;		if !TestContext.NodeE2E {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Expect(pod.Spec.NodeName).To(Or(BeZero(), Equal(TestContext.NodeName)), "Test misconfigured")
0000000000000000000000000000000000000000;;		pod.Spec.NodeName = TestContext.NodeName
0000000000000000000000000000000000000000;;		// Node e2e does not support the default DNSClusterFirst policy. Set
0000000000000000000000000000000000000000;;		// the policy to DNSDefault, which is configured per node.
0000000000000000000000000000000000000000;;		pod.Spec.DNSPolicy = v1.DNSDefault
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PrepullImages only works for node e2e now. For cluster e2e, image prepull is not enforced,
0000000000000000000000000000000000000000;;		// we should not munge ImagePullPolicy for cluster e2e pods.
0000000000000000000000000000000000000000;;		if !TestContext.PrepullImages {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If prepull is enabled, munge the container spec to make sure the images are not pulled
0000000000000000000000000000000000000000;;		// during the test.
0000000000000000000000000000000000000000;;		for i := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			c := &pod.Spec.Containers[i]
0000000000000000000000000000000000000000;;			if c.ImagePullPolicy == v1.PullAlways {
0000000000000000000000000000000000000000;;				// If the image pull policy is PullAlways, the image doesn't need to be in
0000000000000000000000000000000000000000;;				// the white list or pre-pulled, because the image is expected to be pulled
0000000000000000000000000000000000000000;;				// in the test anyway.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If the image policy is not PullAlways, the image must be in the white list and
0000000000000000000000000000000000000000;;			// pre-pulled.
0000000000000000000000000000000000000000;;			Expect(ImageWhiteList.Has(c.Image)).To(BeTrue(), "Image %q is not in the white list, consider adding it to CommonImageWhiteList in test/e2e/common/util.go or NodeImageWhiteList in test/e2e_node/image_list.go", c.Image)
0000000000000000000000000000000000000000;;			// Do not pull images during the tests because the images in white list should have
0000000000000000000000000000000000000000;;			// been prepulled.
0000000000000000000000000000000000000000;;			c.ImagePullPolicy = v1.PullNever
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(random-liu): Move pod wait function into this file
0000000000000000000000000000000000000000;;	// WaitForSuccess waits for pod to succeed.
0000000000000000000000000000000000000000;;	func (c *PodClient) WaitForSuccess(name string, timeout time.Duration) {
0000000000000000000000000000000000000000;;		f := c.f
0000000000000000000000000000000000000000;;		Expect(WaitForPodCondition(f.ClientSet, f.Namespace.Name, name, "success or failure", timeout,
0000000000000000000000000000000000000000;;			func(pod *v1.Pod) (bool, error) {
0000000000000000000000000000000000000000;;				switch pod.Status.Phase {
0000000000000000000000000000000000000000;;				case v1.PodFailed:
0000000000000000000000000000000000000000;;					return true, fmt.Errorf("pod %q failed with reason: %q, message: %q", name, pod.Status.Reason, pod.Status.Message)
0000000000000000000000000000000000000000;;				case v1.PodSucceeded:
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)).To(Succeed(), "wait for pod %q to success", name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForSuccess waits for pod to succeed or an error event for that pod.
0000000000000000000000000000000000000000;;	func (c *PodClient) WaitForErrorEventOrSuccess(pod *v1.Pod) (*v1.Event, error) {
0000000000000000000000000000000000000000;;		var ev *v1.Event
0000000000000000000000000000000000000000;;		err := wait.Poll(Poll, PodStartTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			evnts, err := c.f.ClientSet.Core().Events(pod.Namespace).Search(api.Scheme, pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("error in listing events: %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, e := range evnts.Items {
0000000000000000000000000000000000000000;;				switch e.Reason {
0000000000000000000000000000000000000000;;				case events.KillingContainer, events.FailedToCreateContainer, sysctl.UnsupportedReason, sysctl.ForbiddenReason:
0000000000000000000000000000000000000000;;					ev = &e
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				case events.StartedContainer:
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					// ignore all other errors
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return ev, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MatchContainerOutput gets output of a container and match expected regexp in the output.
0000000000000000000000000000000000000000;;	func (c *PodClient) MatchContainerOutput(name string, containerName string, expectedRegexp string) error {
0000000000000000000000000000000000000000;;		f := c.f
0000000000000000000000000000000000000000;;		output, err := GetPodLogs(f.ClientSet, f.Namespace.Name, name, containerName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to get output for container %q of pod %q", containerName, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		regex, err := regexp.Compile(expectedRegexp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to compile regexp %q: %v", expectedRegexp, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !regex.MatchString(output) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to match regexp %q in output %q", expectedRegexp, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
