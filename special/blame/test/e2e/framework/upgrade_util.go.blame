0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
d48c732fff37321bdf4a0685a9e477dba32d5954;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/version"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RealVersion turns a version constants into a version string deployable on
0000000000000000000000000000000000000000;;	// GKE.  See hack/get-build.sh for more information.
0000000000000000000000000000000000000000;;	func RealVersion(s string) (string, error) {
0000000000000000000000000000000000000000;;		Logf("Getting real version for %q", s)
0000000000000000000000000000000000000000;;		v, _, err := RunCmd(path.Join(TestContext.RepoRoot, "hack/get-build.sh"), "-v", s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return v, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Logf("Version for %q is %q", s, v)
0000000000000000000000000000000000000000;;		return strings.TrimPrefix(strings.TrimSpace(v), "v"), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func traceRouteToMaster() {
0000000000000000000000000000000000000000;;		path, err := exec.LookPath("traceroute")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Logf("Could not find traceroute program")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := exec.Command(path, "-I", GetMasterHost())
0000000000000000000000000000000000000000;;		out, err := cmd.Output()
0000000000000000000000000000000000000000;;		if len(out) != 0 {
0000000000000000000000000000000000000000;;			Logf(string(out))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if exiterr, ok := err.(*exec.ExitError); err != nil && ok {
0000000000000000000000000000000000000000;;			Logf("error while running traceroute: %s", exiterr.Stderr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CheckMasterVersion(c clientset.Interface, want string) error {
0000000000000000000000000000000000000000;;		Logf("Checking master version")
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var v *version.Info
0000000000000000000000000000000000000000;;		waitErr := wait.PollImmediate(5*time.Second, 2*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			v, err = c.Discovery().ServerVersion()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				traceRouteToMaster()
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if waitErr != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("CheckMasterVersion() couldn't get the master version: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We do prefix trimming and then matching because:
0000000000000000000000000000000000000000;;		// want looks like:  0.19.3-815-g50e67d4
0000000000000000000000000000000000000000;;		// got  looks like: v0.19.3-815-g50e67d4034e858-dirty
0000000000000000000000000000000000000000;;		got := strings.TrimPrefix(v.GitVersion, "v")
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(got, want) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("master had kube-apiserver version %s which does not start with %s",
0000000000000000000000000000000000000000;;				got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Logf("Master is at version %s", want)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CheckNodesVersions(cs clientset.Interface, want string) error {
0000000000000000000000000000000000000000;;		l := GetReadySchedulableNodesOrDie(cs)
0000000000000000000000000000000000000000;;		for _, n := range l.Items {
0000000000000000000000000000000000000000;;			// We do prefix trimming and then matching because:
0000000000000000000000000000000000000000;;			// want   looks like:  0.19.3-815-g50e67d4
0000000000000000000000000000000000000000;;			// kv/kvp look  like: v0.19.3-815-g50e67d4034e858-dirty
0000000000000000000000000000000000000000;;			kv, kpv := strings.TrimPrefix(n.Status.NodeInfo.KubeletVersion, "v"),
0000000000000000000000000000000000000000;;				strings.TrimPrefix(n.Status.NodeInfo.KubeProxyVersion, "v")
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(kv, want) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("node %s had kubelet version %s which does not start with %s",
0000000000000000000000000000000000000000;;					n.ObjectMeta.Name, kv, want)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(kpv, want) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("node %s had kube-proxy version %s which does not start with %s",
0000000000000000000000000000000000000000;;					n.ObjectMeta.Name, kpv, want)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
