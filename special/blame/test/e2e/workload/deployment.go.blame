0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
01c38b773f05f607b44ea0ee1dcd0f913cf0299f;test/e2e/deployment.go[test/e2e/deployment.go][test/e2e/workload/deployment.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package workload
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/davecgh/go-spew/spew"
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		extensionsinternal "k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		extensionsclient "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		deploymentutil "k8s.io/kubernetes/pkg/controller/deployment/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		testutil "k8s.io/kubernetes/test/utils"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		dRetryPeriod  = 2 * time.Second
0000000000000000000000000000000000000000;;		dRetryTimeout = 5 * time.Minute
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		nilRs *extensions.ReplicaSet
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("Deployment", func() {
0000000000000000000000000000000000000000;;		var ns string
0000000000000000000000000000000000000000;;		var c clientset.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		AfterEach(func() {
0000000000000000000000000000000000000000;;			failureTrap(c, ns)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("deployment")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			c = f.ClientSet
0000000000000000000000000000000000000000;;			ns = f.Namespace.Name
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("deployment reaping should cascade to its replica sets and pods", func() {
0000000000000000000000000000000000000000;;			testDeleteDeployment(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		It("RollingUpdateDeployment should delete old pods and create new ones", func() {
0000000000000000000000000000000000000000;;			testRollingUpdateDeployment(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		It("RecreateDeployment should delete old pods and create new ones", func() {
0000000000000000000000000000000000000000;;			testRecreateDeployment(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		It("deployment should delete old replica sets", func() {
0000000000000000000000000000000000000000;;			testDeploymentCleanUpPolicy(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		It("deployment should support rollover", func() {
0000000000000000000000000000000000000000;;			testRolloverDeployment(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		It("paused deployment should be ignored by the controller", func() {
0000000000000000000000000000000000000000;;			testPausedDeployment(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		It("deployment should support rollback", func() {
0000000000000000000000000000000000000000;;			testRollbackDeployment(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		It("deployment should support rollback when there's replica set with no revision", func() {
0000000000000000000000000000000000000000;;			testRollbackDeploymentRSNoRevision(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		It("deployment should label adopted RSs and pods", func() {
0000000000000000000000000000000000000000;;			testDeploymentLabelAdopted(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		It("paused deployment should be able to scale", func() {
0000000000000000000000000000000000000000;;			testScalePausedDeployment(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		It("scaled rollout deployment should not block on annotation check", func() {
0000000000000000000000000000000000000000;;			testScaledRolloutDeployment(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		It("overlapping deployment should not fight with each other", func() {
0000000000000000000000000000000000000000;;			testOverlappingDeployment(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		It("lack of progress should be reported in the deployment status", func() {
0000000000000000000000000000000000000000;;			testFailedDeployment(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		It("iterative rollouts should eventually progress", func() {
0000000000000000000000000000000000000000;;			testIterativeDeployments(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		It("test Deployment ReplicaSet orphaning and adoption regarding controllerRef", func() {
0000000000000000000000000000000000000000;;			testDeploymentsControllerRef(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		It("deployment can avoid hash collisions", func() {
0000000000000000000000000000000000000000;;			testDeploymentHashCollisionAvoidance(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		// TODO: add tests that cover deployment.Spec.MinReadySeconds once we solved clock-skew issues
0000000000000000000000000000000000000000;;		// See https://github.com/kubernetes/kubernetes/issues/29229
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func failureTrap(c clientset.Interface, ns string) {
0000000000000000000000000000000000000000;;		deployments, err := c.Extensions().Deployments(ns).List(metav1.ListOptions{LabelSelector: labels.Everything().String()})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Logf("Could not list Deployments in namespace %q: %v", ns, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range deployments.Items {
0000000000000000000000000000000000000000;;			d := deployments.Items[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			framework.Logf(spew.Sprintf("Deployment %q:\n%+v\n", d.Name, d))
0000000000000000000000000000000000000000;;			_, allOldRSs, newRS, err := deploymentutil.GetAllReplicaSets(&d, c)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Could not list ReplicaSets for Deployment %q: %v", d.Name, err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			testutil.LogReplicaSetsOfDeployment(&d, allOldRSs, newRS, framework.Logf)
0000000000000000000000000000000000000000;;			rsList := allOldRSs
0000000000000000000000000000000000000000;;			if newRS != nil {
0000000000000000000000000000000000000000;;				rsList = append(rsList, newRS)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			testutil.LogPodsOfDeployment(c, &d, rsList, framework.Logf)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We need print all the ReplicaSets if there are no Deployment object created
0000000000000000000000000000000000000000;;		if len(deployments.Items) != 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.Logf("Log out all the ReplicaSets if there is no deployment created")
0000000000000000000000000000000000000000;;		rss, err := c.ExtensionsV1beta1().ReplicaSets(ns).List(metav1.ListOptions{LabelSelector: labels.Everything().String()})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Logf("Could not list ReplicaSets in namespace %q: %v", ns, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rs := range rss.Items {
0000000000000000000000000000000000000000;;			framework.Logf(spew.Sprintf("ReplicaSet %q:\n%+v\n", rs.Name, rs))
0000000000000000000000000000000000000000;;			selector, err := metav1.LabelSelectorAsSelector(rs.Spec.Selector)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("failed to get selector of ReplicaSet %s: %v", rs.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			options := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;			podList, err := c.Core().Pods(rs.Namespace).List(options)
0000000000000000000000000000000000000000;;			for _, pod := range podList.Items {
0000000000000000000000000000000000000000;;				framework.Logf(spew.Sprintf("pod: %q:\n%+v\n", pod.Name, pod))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func intOrStrP(num int) *intstr.IntOrString {
0000000000000000000000000000000000000000;;		intstr := intstr.FromInt(num)
0000000000000000000000000000000000000000;;		return &intstr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDeploymentRollback(name string, annotations map[string]string, revision int64) *extensions.DeploymentRollback {
0000000000000000000000000000000000000000;;		return &extensions.DeploymentRollback{
0000000000000000000000000000000000000000;;			Name:               name,
0000000000000000000000000000000000000000;;			UpdatedAnnotations: annotations,
0000000000000000000000000000000000000000;;			RollbackTo:         extensions.RollbackConfig{Revision: revision},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkDeploymentRevision checks if the input deployment's and its new replica set's revision and images are as expected.
0000000000000000000000000000000000000000;;	func checkDeploymentRevision(c clientset.Interface, ns, deploymentName, revision, imageName, image string) (*extensions.Deployment, *extensions.ReplicaSet) {
0000000000000000000000000000000000000000;;		deployment, err := c.Extensions().Deployments(ns).Get(deploymentName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		// Check revision of the new replica set of this deployment
0000000000000000000000000000000000000000;;		newRS, err := deploymentutil.GetNewReplicaSet(deployment, c)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(newRS).NotTo(Equal(nilRs))
0000000000000000000000000000000000000000;;		Expect(newRS.Annotations).NotTo(Equal(nil))
0000000000000000000000000000000000000000;;		Expect(newRS.Annotations[deploymentutil.RevisionAnnotation]).Should(Equal(revision))
0000000000000000000000000000000000000000;;		// Check revision of This deployment
0000000000000000000000000000000000000000;;		Expect(deployment.Annotations).NotTo(Equal(nil))
0000000000000000000000000000000000000000;;		Expect(deployment.Annotations[deploymentutil.RevisionAnnotation]).Should(Equal(revision))
0000000000000000000000000000000000000000;;		if len(imageName) > 0 {
0000000000000000000000000000000000000000;;			// Check the image the new replica set creates
0000000000000000000000000000000000000000;;			Expect(newRS.Spec.Template.Spec.Containers[0].Name).Should(Equal(imageName))
0000000000000000000000000000000000000000;;			Expect(newRS.Spec.Template.Spec.Containers[0].Image).Should(Equal(image))
0000000000000000000000000000000000000000;;			// Check the image the deployment creates
0000000000000000000000000000000000000000;;			Expect(deployment.Spec.Template.Spec.Containers[0].Name).Should(Equal(imageName))
0000000000000000000000000000000000000000;;			Expect(deployment.Spec.Template.Spec.Containers[0].Image).Should(Equal(image))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return deployment, newRS
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func stopDeployment(c clientset.Interface, internalClient internalclientset.Interface, ns, deploymentName string) {
0000000000000000000000000000000000000000;;		deployment, err := c.Extensions().Deployments(ns).Get(deploymentName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Deleting deployment %s", deploymentName)
0000000000000000000000000000000000000000;;		reaper, err := kubectl.ReaperFor(extensionsinternal.Kind("Deployment"), internalClient)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		timeout := 1 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = reaper.Stop(ns, deployment.Name, timeout, metav1.NewDeleteOptions(0))
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Ensuring deployment %s was deleted", deploymentName)
0000000000000000000000000000000000000000;;		_, err = c.Extensions().Deployments(ns).Get(deployment.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(errors.IsNotFound(err)).To(BeTrue())
0000000000000000000000000000000000000000;;		framework.Logf("Ensuring deployment %s's RSes were deleted", deploymentName)
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(deployment.Spec.Selector)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		options := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;		rss, err := c.Extensions().ReplicaSets(ns).List(options)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(rss.Items).Should(HaveLen(0))
0000000000000000000000000000000000000000;;		framework.Logf("Ensuring deployment %s's Pods were deleted", deploymentName)
0000000000000000000000000000000000000000;;		var pods *v1.PodList
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(time.Second, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			pods, err = c.Core().Pods(ns).List(options)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Pods may be created by overlapping deployments right after this deployment is deleted, ignore them
0000000000000000000000000000000000000000;;			if len(pods.Items) == 0 {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Err : %s\n. Failed to remove deployment %s pods : %+v", err, deploymentName, pods)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testDeleteDeployment(f *framework.Framework) {
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;		c := f.ClientSet
0000000000000000000000000000000000000000;;		internalClient := f.InternalClientset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deploymentName := "test-new-deployment"
0000000000000000000000000000000000000000;;		podLabels := map[string]string{"name": NginxImageName}
0000000000000000000000000000000000000000;;		replicas := int32(1)
0000000000000000000000000000000000000000;;		framework.Logf("Creating simple deployment %s", deploymentName)
0000000000000000000000000000000000000000;;		d := framework.NewDeployment(deploymentName, replicas, podLabels, NginxImageName, NginxImage, extensions.RollingUpdateDeploymentStrategyType)
0000000000000000000000000000000000000000;;		d.Annotations = map[string]string{"test": "should-copy-to-replica-set", v1.LastAppliedConfigAnnotation: "should-not-copy-to-replica-set"}
0000000000000000000000000000000000000000;;		deploy, err := c.Extensions().Deployments(ns).Create(d)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for it to be updated to revision 1
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRevisionAndImage(c, ns, deploymentName, "1", NginxImage)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentStatusValid(c, deploy)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deployment, err := c.Extensions().Deployments(ns).Get(deploymentName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		newRS, err := deploymentutil.GetNewReplicaSet(deployment, c)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(newRS).NotTo(Equal(nilRs))
0000000000000000000000000000000000000000;;		stopDeployment(c, internalClient, ns, deploymentName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testRollingUpdateDeployment(f *framework.Framework) {
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;		c := f.ClientSet
0000000000000000000000000000000000000000;;		// Create nginx pods.
0000000000000000000000000000000000000000;;		deploymentPodLabels := map[string]string{"name": "sample-pod"}
0000000000000000000000000000000000000000;;		rsPodLabels := map[string]string{
0000000000000000000000000000000000000000;;			"name": "sample-pod",
0000000000000000000000000000000000000000;;			"pod":  NginxImageName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rsName := "test-rolling-update-controller"
0000000000000000000000000000000000000000;;		replicas := int32(1)
0000000000000000000000000000000000000000;;		rsRevision := "3546343826724305832"
0000000000000000000000000000000000000000;;		annotations := make(map[string]string)
0000000000000000000000000000000000000000;;		annotations[deploymentutil.RevisionAnnotation] = rsRevision
0000000000000000000000000000000000000000;;		rs := newRS(rsName, replicas, rsPodLabels, NginxImageName, NginxImage)
0000000000000000000000000000000000000000;;		rs.Annotations = annotations
0000000000000000000000000000000000000000;;		framework.Logf("Creating replica set %q (going to be adopted)", rs.Name)
0000000000000000000000000000000000000000;;		_, err := c.Extensions().ReplicaSets(ns).Create(rs)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		// Verify that the required pods have come up.
0000000000000000000000000000000000000000;;		err = framework.VerifyPodsRunning(c, ns, "sample-pod", false, replicas)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "error in waiting for pods to come up: %s", err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a deployment to delete nginx pods and instead bring up redis pods.
0000000000000000000000000000000000000000;;		deploymentName := "test-rolling-update-deployment"
0000000000000000000000000000000000000000;;		framework.Logf("Creating deployment %q", deploymentName)
0000000000000000000000000000000000000000;;		d := framework.NewDeployment(deploymentName, replicas, deploymentPodLabels, RedisImageName, RedisImage, extensions.RollingUpdateDeploymentStrategyType)
0000000000000000000000000000000000000000;;		deploy, err := c.Extensions().Deployments(ns).Create(d)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for it to be updated to revision 3546343826724305833.
0000000000000000000000000000000000000000;;		framework.Logf("Ensuring deployment %q gets the next revision from the one the adopted replica set %q has", deploy.Name, rs.Name)
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRevisionAndImage(c, ns, deploymentName, "3546343826724305833", RedisImage)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Ensuring status for deployment %q is the expected", deploy.Name)
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentStatusValid(c, deploy)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// There should be 1 old RS (nginx-controller, which is adopted)
0000000000000000000000000000000000000000;;		framework.Logf("Ensuring deployment %q has one old replica set (the one it adopted)", deploy.Name)
0000000000000000000000000000000000000000;;		deployment, err := c.Extensions().Deployments(ns).Get(deploymentName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		_, allOldRSs, err := deploymentutil.GetOldReplicaSets(deployment, c)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(len(allOldRSs)).Should(Equal(1))
0000000000000000000000000000000000000000;;		// The old RS should contain pod-template-hash in its selector, label, and template label
0000000000000000000000000000000000000000;;		Expect(len(allOldRSs[0].Labels[extensions.DefaultDeploymentUniqueLabelKey])).Should(BeNumerically(">", 0))
0000000000000000000000000000000000000000;;		Expect(len(allOldRSs[0].Spec.Selector.MatchLabels[extensions.DefaultDeploymentUniqueLabelKey])).Should(BeNumerically(">", 0))
0000000000000000000000000000000000000000;;		Expect(len(allOldRSs[0].Spec.Template.Labels[extensions.DefaultDeploymentUniqueLabelKey])).Should(BeNumerically(">", 0))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testRecreateDeployment(f *framework.Framework) {
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;		c := f.ClientSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a deployment that brings up redis pods.
0000000000000000000000000000000000000000;;		deploymentName := "test-recreate-deployment"
0000000000000000000000000000000000000000;;		framework.Logf("Creating deployment %q", deploymentName)
0000000000000000000000000000000000000000;;		d := framework.NewDeployment(deploymentName, int32(1), map[string]string{"name": "sample-pod-3"}, RedisImageName, RedisImage, extensions.RecreateDeploymentStrategyType)
0000000000000000000000000000000000000000;;		deployment, err := c.Extensions().Deployments(ns).Create(d)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for it to be updated to revision 1
0000000000000000000000000000000000000000;;		framework.Logf("Waiting deployment %q to be updated to revision 1", deploymentName)
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRevisionAndImage(c, ns, deploymentName, "1", RedisImage)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Waiting deployment %q to complete", deploymentName)
0000000000000000000000000000000000000000;;		Expect(framework.WaitForDeploymentStatusValid(c, deployment)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update deployment to delete redis pods and bring up nginx pods.
0000000000000000000000000000000000000000;;		framework.Logf("Triggering a new rollout for deployment %q", deploymentName)
0000000000000000000000000000000000000000;;		deployment, err = framework.UpdateDeploymentWithRetries(c, ns, deploymentName, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;			update.Spec.Template.Spec.Containers[0].Name = NginxImageName
0000000000000000000000000000000000000000;;			update.Spec.Template.Spec.Containers[0].Image = NginxImage
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Watching deployment %q to verify that new pods will not run with olds pods", deploymentName)
0000000000000000000000000000000000000000;;		Expect(framework.WatchRecreateDeployment(c, deployment)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testDeploymentCleanUpPolicy tests that deployment supports cleanup policy
0000000000000000000000000000000000000000;;	func testDeploymentCleanUpPolicy(f *framework.Framework) {
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;		c := f.ClientSet
0000000000000000000000000000000000000000;;		// Create nginx pods.
0000000000000000000000000000000000000000;;		deploymentPodLabels := map[string]string{"name": "cleanup-pod"}
0000000000000000000000000000000000000000;;		rsPodLabels := map[string]string{
0000000000000000000000000000000000000000;;			"name": "cleanup-pod",
0000000000000000000000000000000000000000;;			"pod":  NginxImageName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rsName := "test-cleanup-controller"
0000000000000000000000000000000000000000;;		replicas := int32(1)
0000000000000000000000000000000000000000;;		revisionHistoryLimit := util.Int32Ptr(0)
0000000000000000000000000000000000000000;;		_, err := c.Extensions().ReplicaSets(ns).Create(newRS(rsName, replicas, rsPodLabels, NginxImageName, NginxImage))
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify that the required pods have come up.
0000000000000000000000000000000000000000;;		err = framework.VerifyPodsRunning(c, ns, "cleanup-pod", false, replicas)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "error in waiting for pods to come up: %v", err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a deployment to delete nginx pods and instead bring up redis pods.
0000000000000000000000000000000000000000;;		deploymentName := "test-cleanup-deployment"
0000000000000000000000000000000000000000;;		framework.Logf("Creating deployment %s", deploymentName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods, err := c.Core().Pods(ns).List(metav1.ListOptions{LabelSelector: labels.Everything().String()})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "Failed to query for pods: %v", err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options := metav1.ListOptions{
0000000000000000000000000000000000000000;;			ResourceVersion: pods.ListMeta.ResourceVersion,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;		w, err := c.Core().Pods(ns).Watch(options)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			// There should be only one pod being created, which is the pod with the redis image.
0000000000000000000000000000000000000000;;			// The old RS shouldn't create new pod when deployment controller adding pod template hash label to its selector.
0000000000000000000000000000000000000000;;			numPodCreation := 1
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case event, _ := <-w.ResultChan():
0000000000000000000000000000000000000000;;					if event.Type != watch.Added {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					numPodCreation--
0000000000000000000000000000000000000000;;					if numPodCreation < 0 {
0000000000000000000000000000000000000000;;						framework.Failf("Expect only one pod creation, the second creation event: %#v\n", event)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					pod, ok := event.Object.(*v1.Pod)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						framework.Failf("Expect event Object to be a pod")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if pod.Spec.Containers[0].Name != RedisImageName {
0000000000000000000000000000000000000000;;						framework.Failf("Expect the created pod to have container name %s, got pod %#v\n", RedisImageName, pod)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case <-stopCh:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		d := framework.NewDeployment(deploymentName, replicas, deploymentPodLabels, RedisImageName, RedisImage, extensions.RollingUpdateDeploymentStrategyType)
0000000000000000000000000000000000000000;;		d.Spec.RevisionHistoryLimit = revisionHistoryLimit
0000000000000000000000000000000000000000;;		_, err = c.Extensions().Deployments(ns).Create(d)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Waiting for deployment %s history to be cleaned up", deploymentName))
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentOldRSsNum(c, ns, deploymentName, int(*revisionHistoryLimit))
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testRolloverDeployment tests that deployment supports rollover.
0000000000000000000000000000000000000000;;	// i.e. we can change desired state and kick off rolling update, then change desired state again before it finishes.
0000000000000000000000000000000000000000;;	func testRolloverDeployment(f *framework.Framework) {
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;		c := f.ClientSet
0000000000000000000000000000000000000000;;		podName := "rollover-pod"
0000000000000000000000000000000000000000;;		deploymentPodLabels := map[string]string{"name": podName}
0000000000000000000000000000000000000000;;		rsPodLabels := map[string]string{
0000000000000000000000000000000000000000;;			"name": podName,
0000000000000000000000000000000000000000;;			"pod":  NginxImageName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rsName := "test-rollover-controller"
0000000000000000000000000000000000000000;;		rsReplicas := int32(1)
0000000000000000000000000000000000000000;;		_, err := c.Extensions().ReplicaSets(ns).Create(newRS(rsName, rsReplicas, rsPodLabels, NginxImageName, NginxImage))
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		// Verify that the required pods have come up.
0000000000000000000000000000000000000000;;		err = framework.VerifyPodsRunning(c, ns, podName, false, rsReplicas)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "error in waiting for pods to come up: %v", err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for replica set to become ready before adopting it.
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for pods owned by replica set %q to become ready", rsName)
0000000000000000000000000000000000000000;;		Expect(framework.WaitForReadyReplicaSet(c, ns, rsName)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a deployment to delete nginx pods and instead bring up redis-slave pods.
0000000000000000000000000000000000000000;;		// We use a nonexistent image here, so that we make sure it won't finish
0000000000000000000000000000000000000000;;		deploymentName, deploymentImageName := "test-rollover-deployment", "redis-slave"
0000000000000000000000000000000000000000;;		deploymentReplicas := int32(1)
0000000000000000000000000000000000000000;;		deploymentImage := "gcr.io/google_samples/gb-redisslave:nonexistent"
0000000000000000000000000000000000000000;;		deploymentStrategyType := extensions.RollingUpdateDeploymentStrategyType
0000000000000000000000000000000000000000;;		framework.Logf("Creating deployment %q", deploymentName)
0000000000000000000000000000000000000000;;		newDeployment := framework.NewDeployment(deploymentName, deploymentReplicas, deploymentPodLabels, deploymentImageName, deploymentImage, deploymentStrategyType)
0000000000000000000000000000000000000000;;		newDeployment.Spec.Strategy.RollingUpdate = &extensions.RollingUpdateDeployment{
0000000000000000000000000000000000000000;;			MaxUnavailable: intOrStrP(0),
0000000000000000000000000000000000000000;;			MaxSurge:       intOrStrP(1),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newDeployment.Spec.MinReadySeconds = int32(10)
0000000000000000000000000000000000000000;;		_, err = c.Extensions().Deployments(ns).Create(newDeployment)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify that the pods were scaled up and down as expected.
0000000000000000000000000000000000000000;;		deployment, err := c.Extensions().Deployments(ns).Get(deploymentName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		framework.Logf("Make sure deployment %q performs scaling operations", deploymentName)
0000000000000000000000000000000000000000;;		// Make sure the deployment starts to scale up and down replica sets by checking if its updated replicas >= 1
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentUpdatedReplicasLTE(c, ns, deploymentName, deploymentReplicas, deployment.Generation)
0000000000000000000000000000000000000000;;		// Check if it's updated to revision 1 correctly
0000000000000000000000000000000000000000;;		framework.Logf("Check revision of new replica set for deployment %q", deploymentName)
0000000000000000000000000000000000000000;;		_, newRS := checkDeploymentRevision(c, ns, deploymentName, "1", deploymentImageName, deploymentImage)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Ensure that both replica sets have 1 created replica")
0000000000000000000000000000000000000000;;		oldRS, err := c.Extensions().ReplicaSets(ns).Get(rsName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		ensureReplicas(oldRS, int32(1))
0000000000000000000000000000000000000000;;		newRS, err = c.Extensions().ReplicaSets(ns).Get(newRS.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		ensureReplicas(newRS, int32(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The deployment is stuck, update it to rollover the above 2 ReplicaSets and bring up redis pods.
0000000000000000000000000000000000000000;;		framework.Logf("Rollover old replica sets for deployment %q with new image update", deploymentName)
0000000000000000000000000000000000000000;;		updatedDeploymentImageName, updatedDeploymentImage := RedisImageName, RedisImage
0000000000000000000000000000000000000000;;		deployment, err = framework.UpdateDeploymentWithRetries(c, ns, newDeployment.Name, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;			update.Spec.Template.Spec.Containers[0].Name = updatedDeploymentImageName
0000000000000000000000000000000000000000;;			update.Spec.Template.Spec.Containers[0].Image = updatedDeploymentImage
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use observedGeneration to determine if the controller noticed the pod template update.
0000000000000000000000000000000000000000;;		framework.Logf("Wait deployment %q to be observed by the deployment controller", deploymentName)
0000000000000000000000000000000000000000;;		err = framework.WaitForObservedDeployment(c, ns, deploymentName, deployment.Generation)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for it to be updated to revision 2
0000000000000000000000000000000000000000;;		framework.Logf("Wait for revision update of deployment %q to 2", deploymentName)
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRevisionAndImage(c, ns, deploymentName, "2", updatedDeploymentImage)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Make sure deployment %q is complete", deploymentName)
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentStatus(c, deployment)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Ensure that both old replica sets have no replicas")
0000000000000000000000000000000000000000;;		oldRS, err = c.Extensions().ReplicaSets(ns).Get(rsName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		ensureReplicas(oldRS, int32(0))
0000000000000000000000000000000000000000;;		// Not really the new replica set anymore but we GET by name so that's fine.
0000000000000000000000000000000000000000;;		newRS, err = c.Extensions().ReplicaSets(ns).Get(newRS.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		ensureReplicas(newRS, int32(0))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ensureReplicas(rs *extensions.ReplicaSet, replicas int32) {
0000000000000000000000000000000000000000;;		Expect(*rs.Spec.Replicas).Should(Equal(replicas))
0000000000000000000000000000000000000000;;		Expect(rs.Status.Replicas).Should(Equal(replicas))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Can be moved to a unit test.
0000000000000000000000000000000000000000;;	func testPausedDeployment(f *framework.Framework) {
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;		c := f.ClientSet
0000000000000000000000000000000000000000;;		deploymentName := "test-paused-deployment"
0000000000000000000000000000000000000000;;		podLabels := map[string]string{"name": NginxImageName}
0000000000000000000000000000000000000000;;		d := framework.NewDeployment(deploymentName, 1, podLabels, NginxImageName, NginxImage, extensions.RollingUpdateDeploymentStrategyType)
0000000000000000000000000000000000000000;;		d.Spec.Paused = true
0000000000000000000000000000000000000000;;		tgps := int64(1)
0000000000000000000000000000000000000000;;		d.Spec.Template.Spec.TerminationGracePeriodSeconds = &tgps
0000000000000000000000000000000000000000;;		framework.Logf("Creating paused deployment %s", deploymentName)
0000000000000000000000000000000000000000;;		_, err := c.Extensions().Deployments(ns).Create(d)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		// Check that deployment is created fine.
0000000000000000000000000000000000000000;;		deployment, err := c.Extensions().Deployments(ns).Get(deploymentName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify that there is no latest state realized for the new deployment.
0000000000000000000000000000000000000000;;		rs, err := deploymentutil.GetNewReplicaSet(deployment, c)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(rs).To(Equal(nilRs))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update the deployment to run
0000000000000000000000000000000000000000;;		deployment, err = framework.UpdateDeploymentWithRetries(c, ns, d.Name, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;			update.Spec.Paused = false
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use observedGeneration to determine if the controller noticed the resume.
0000000000000000000000000000000000000000;;		err = framework.WaitForObservedDeployment(c, ns, deploymentName, deployment.Generation)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(deployment.Spec.Selector)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;		w, err := c.Extensions().ReplicaSets(ns).Watch(opts)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-w.ResultChan():
0000000000000000000000000000000000000000;;			// this is it
0000000000000000000000000000000000000000;;		case <-time.After(time.Minute):
0000000000000000000000000000000000000000;;			err = fmt.Errorf("expected a new replica set to be created")
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pause the deployment and delete the replica set.
0000000000000000000000000000000000000000;;		// The paused deployment shouldn't recreate a new one.
0000000000000000000000000000000000000000;;		deployment, err = framework.UpdateDeploymentWithRetries(c, ns, d.Name, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;			update.Spec.Paused = true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use observedGeneration to determine if the controller noticed the pause.
0000000000000000000000000000000000000000;;		err = framework.WaitForObservedDeployment(c, ns, deploymentName, deployment.Generation)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update the deployment template - the new replicaset should stay the same
0000000000000000000000000000000000000000;;		framework.Logf("Updating paused deployment %q", deploymentName)
0000000000000000000000000000000000000000;;		newTGPS := int64(0)
0000000000000000000000000000000000000000;;		deployment, err = framework.UpdateDeploymentWithRetries(c, ns, d.Name, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;			update.Spec.Template.Spec.TerminationGracePeriodSeconds = &newTGPS
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = framework.WaitForObservedDeployment(c, ns, deploymentName, deployment.Generation)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Looking for new replicaset for paused deployment %q (there should be none)", deploymentName)
0000000000000000000000000000000000000000;;		newRS, err := deploymentutil.GetNewReplicaSet(deployment, c)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(newRS).To(Equal(nilRs))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, allOldRs, err := deploymentutil.GetOldReplicaSets(deployment, c)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		if len(allOldRs) != 1 {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("expected an old replica set")
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.Logf("Comparing deployment diff with old replica set %q", allOldRs[0].Name)
0000000000000000000000000000000000000000;;		if *allOldRs[0].Spec.Template.Spec.TerminationGracePeriodSeconds == newTGPS {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("TerminationGracePeriodSeconds on the replica set should be %d but is %d", tgps, newTGPS)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testRollbackDeployment tests that a deployment is created (revision 1) and updated (revision 2), and
0000000000000000000000000000000000000000;;	// then rollback to revision 1 (should update template to revision 1, and then update revision 1 to 3),
0000000000000000000000000000000000000000;;	// and then rollback to last revision.
0000000000000000000000000000000000000000;;	func testRollbackDeployment(f *framework.Framework) {
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;		c := f.ClientSet
0000000000000000000000000000000000000000;;		podName := "nginx"
0000000000000000000000000000000000000000;;		deploymentPodLabels := map[string]string{"name": podName}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 1. Create a deployment to create nginx pods.
0000000000000000000000000000000000000000;;		deploymentName, deploymentImageName := "test-rollback-deployment", NginxImageName
0000000000000000000000000000000000000000;;		deploymentReplicas := int32(1)
0000000000000000000000000000000000000000;;		deploymentImage := NginxImage
0000000000000000000000000000000000000000;;		deploymentStrategyType := extensions.RollingUpdateDeploymentStrategyType
0000000000000000000000000000000000000000;;		framework.Logf("Creating deployment %s", deploymentName)
0000000000000000000000000000000000000000;;		d := framework.NewDeployment(deploymentName, deploymentReplicas, deploymentPodLabels, deploymentImageName, deploymentImage, deploymentStrategyType)
0000000000000000000000000000000000000000;;		createAnnotation := map[string]string{"action": "create", "author": "node"}
0000000000000000000000000000000000000000;;		d.Annotations = createAnnotation
0000000000000000000000000000000000000000;;		deploy, err := c.Extensions().Deployments(ns).Create(d)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for it to be updated to revision 1
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRevisionAndImage(c, ns, deploymentName, "1", deploymentImage)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentStatusValid(c, deploy)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Current newRS annotation should be "create"
0000000000000000000000000000000000000000;;		err = framework.CheckNewRSAnnotations(c, ns, deploymentName, createAnnotation)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 2. Update the deployment to create redis pods.
0000000000000000000000000000000000000000;;		updatedDeploymentImage := RedisImage
0000000000000000000000000000000000000000;;		updatedDeploymentImageName := RedisImageName
0000000000000000000000000000000000000000;;		updateAnnotation := map[string]string{"action": "update", "log": "I need to update it"}
0000000000000000000000000000000000000000;;		deployment, err := framework.UpdateDeploymentWithRetries(c, ns, d.Name, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;			update.Spec.Template.Spec.Containers[0].Name = updatedDeploymentImageName
0000000000000000000000000000000000000000;;			update.Spec.Template.Spec.Containers[0].Image = updatedDeploymentImage
0000000000000000000000000000000000000000;;			update.Annotations = updateAnnotation
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use observedGeneration to determine if the controller noticed the pod template update.
0000000000000000000000000000000000000000;;		err = framework.WaitForObservedDeployment(c, ns, deploymentName, deployment.Generation)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for it to be updated to revision 2
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRevisionAndImage(c, ns, deploymentName, "2", updatedDeploymentImage)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentStatus(c, deployment)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Current newRS annotation should be "update"
0000000000000000000000000000000000000000;;		err = framework.CheckNewRSAnnotations(c, ns, deploymentName, updateAnnotation)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 3. Update the deploymentRollback to rollback to revision 1
0000000000000000000000000000000000000000;;		revision := int64(1)
0000000000000000000000000000000000000000;;		framework.Logf("rolling back deployment %s to revision %d", deploymentName, revision)
0000000000000000000000000000000000000000;;		rollback := newDeploymentRollback(deploymentName, nil, revision)
0000000000000000000000000000000000000000;;		err = c.Extensions().Deployments(ns).Rollback(rollback)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for the deployment to start rolling back
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRollbackCleared(c, ns, deploymentName)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		// TODO: report RollbackDone in deployment status and check it here
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for it to be updated to revision 3
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRevisionAndImage(c, ns, deploymentName, "3", deploymentImage)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentStatus(c, deployment)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Current newRS annotation should be "create", after the rollback
0000000000000000000000000000000000000000;;		err = framework.CheckNewRSAnnotations(c, ns, deploymentName, createAnnotation)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 4. Update the deploymentRollback to rollback to last revision
0000000000000000000000000000000000000000;;		revision = 0
0000000000000000000000000000000000000000;;		framework.Logf("rolling back deployment %s to last revision", deploymentName)
0000000000000000000000000000000000000000;;		rollback = newDeploymentRollback(deploymentName, nil, revision)
0000000000000000000000000000000000000000;;		err = c.Extensions().Deployments(ns).Rollback(rollback)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRollbackCleared(c, ns, deploymentName)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for it to be updated to revision 4
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRevisionAndImage(c, ns, deploymentName, "4", updatedDeploymentImage)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentStatus(c, deployment)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Current newRS annotation should be "update", after the rollback
0000000000000000000000000000000000000000;;		err = framework.CheckNewRSAnnotations(c, ns, deploymentName, updateAnnotation)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testRollbackDeploymentRSNoRevision tests that deployment supports rollback even when there's old replica set without revision.
0000000000000000000000000000000000000000;;	// An old replica set without revision is created, and then a deployment is created (v1). The deployment shouldn't add revision
0000000000000000000000000000000000000000;;	// annotation to the old replica set. Then rollback the deployment to last revision, and it should fail.
0000000000000000000000000000000000000000;;	// Then update the deployment to v2 and rollback it to v1 should succeed, now the deployment
0000000000000000000000000000000000000000;;	// becomes v3. Then rollback the deployment to v10 (doesn't exist in history) should fail.
0000000000000000000000000000000000000000;;	// Finally, rollback the deployment (v3) to v3 should be no-op.
0000000000000000000000000000000000000000;;	// TODO: When we finished reporting rollback status in deployment status, check the rollback status here in each case.
0000000000000000000000000000000000000000;;	func testRollbackDeploymentRSNoRevision(f *framework.Framework) {
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;		c := f.ClientSet
0000000000000000000000000000000000000000;;		podName := "nginx"
0000000000000000000000000000000000000000;;		deploymentPodLabels := map[string]string{"name": podName}
0000000000000000000000000000000000000000;;		rsPodLabels := map[string]string{
0000000000000000000000000000000000000000;;			"name": podName,
0000000000000000000000000000000000000000;;			"pod":  NginxImageName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create an old RS without revision
0000000000000000000000000000000000000000;;		rsName := "test-rollback-no-revision-controller"
0000000000000000000000000000000000000000;;		rsReplicas := int32(0)
0000000000000000000000000000000000000000;;		rs := newRS(rsName, rsReplicas, rsPodLabels, NginxImageName, NginxImage)
0000000000000000000000000000000000000000;;		rs.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;		rs.Annotations["make"] = "difference"
0000000000000000000000000000000000000000;;		_, err := c.Extensions().ReplicaSets(ns).Create(rs)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 1. Create a deployment to create nginx pods, which have different template than the replica set created above.
0000000000000000000000000000000000000000;;		deploymentName, deploymentImageName := "test-rollback-no-revision-deployment", NginxImageName
0000000000000000000000000000000000000000;;		deploymentReplicas := int32(1)
0000000000000000000000000000000000000000;;		deploymentImage := NginxImage
0000000000000000000000000000000000000000;;		deploymentStrategyType := extensions.RollingUpdateDeploymentStrategyType
0000000000000000000000000000000000000000;;		framework.Logf("Creating deployment %s", deploymentName)
0000000000000000000000000000000000000000;;		d := framework.NewDeployment(deploymentName, deploymentReplicas, deploymentPodLabels, deploymentImageName, deploymentImage, deploymentStrategyType)
0000000000000000000000000000000000000000;;		deploy, err := c.Extensions().Deployments(ns).Create(d)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for it to be updated to revision 1
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRevisionAndImage(c, ns, deploymentName, "1", deploymentImage)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentStatusValid(c, deploy)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check that the replica set we created still doesn't contain revision information
0000000000000000000000000000000000000000;;		rs, err = c.Extensions().ReplicaSets(ns).Get(rsName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(rs.Annotations[deploymentutil.RevisionAnnotation]).Should(Equal(""))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 2. Update the deploymentRollback to rollback to last revision
0000000000000000000000000000000000000000;;		//    Since there's only 1 revision in history, it should stay as revision 1
0000000000000000000000000000000000000000;;		revision := int64(0)
0000000000000000000000000000000000000000;;		framework.Logf("rolling back deployment %s to last revision", deploymentName)
0000000000000000000000000000000000000000;;		rollback := newDeploymentRollback(deploymentName, nil, revision)
0000000000000000000000000000000000000000;;		err = c.Extensions().Deployments(ns).Rollback(rollback)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for the deployment to start rolling back
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRollbackCleared(c, ns, deploymentName)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		// TODO: report RollbackRevisionNotFound in deployment status and check it here
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The pod template shouldn't change since there's no last revision
0000000000000000000000000000000000000000;;		// Check if the deployment is still revision 1 and still has the old pod template
0000000000000000000000000000000000000000;;		checkDeploymentRevision(c, ns, deploymentName, "1", deploymentImageName, deploymentImage)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 3. Update the deployment to create redis pods.
0000000000000000000000000000000000000000;;		updatedDeploymentImage := RedisImage
0000000000000000000000000000000000000000;;		updatedDeploymentImageName := RedisImageName
0000000000000000000000000000000000000000;;		deployment, err := framework.UpdateDeploymentWithRetries(c, ns, d.Name, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;			update.Spec.Template.Spec.Containers[0].Name = updatedDeploymentImageName
0000000000000000000000000000000000000000;;			update.Spec.Template.Spec.Containers[0].Image = updatedDeploymentImage
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use observedGeneration to determine if the controller noticed the pod template update.
0000000000000000000000000000000000000000;;		err = framework.WaitForObservedDeployment(c, ns, deploymentName, deployment.Generation)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for it to be updated to revision 2
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRevisionAndImage(c, ns, deploymentName, "2", updatedDeploymentImage)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentStatus(c, deployment)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 4. Update the deploymentRollback to rollback to revision 1
0000000000000000000000000000000000000000;;		revision = 1
0000000000000000000000000000000000000000;;		framework.Logf("rolling back deployment %s to revision %d", deploymentName, revision)
0000000000000000000000000000000000000000;;		rollback = newDeploymentRollback(deploymentName, nil, revision)
0000000000000000000000000000000000000000;;		err = c.Extensions().Deployments(ns).Rollback(rollback)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for the deployment to start rolling back
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRollbackCleared(c, ns, deploymentName)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		// TODO: report RollbackDone in deployment status and check it here
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The pod template should be updated to the one in revision 1
0000000000000000000000000000000000000000;;		// Wait for it to be updated to revision 3
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRevisionAndImage(c, ns, deploymentName, "3", deploymentImage)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentStatus(c, deployment)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 5. Update the deploymentRollback to rollback to revision 10
0000000000000000000000000000000000000000;;		//    Since there's no revision 10 in history, it should stay as revision 3
0000000000000000000000000000000000000000;;		revision = 10
0000000000000000000000000000000000000000;;		framework.Logf("rolling back deployment %s to revision %d", deploymentName, revision)
0000000000000000000000000000000000000000;;		rollback = newDeploymentRollback(deploymentName, nil, revision)
0000000000000000000000000000000000000000;;		err = c.Extensions().Deployments(ns).Rollback(rollback)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for the deployment to start rolling back
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRollbackCleared(c, ns, deploymentName)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		// TODO: report RollbackRevisionNotFound in deployment status and check it here
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The pod template shouldn't change since there's no revision 10
0000000000000000000000000000000000000000;;		// Check if it's still revision 3 and still has the old pod template
0000000000000000000000000000000000000000;;		checkDeploymentRevision(c, ns, deploymentName, "3", deploymentImageName, deploymentImage)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 6. Update the deploymentRollback to rollback to revision 3
0000000000000000000000000000000000000000;;		//    Since it's already revision 3, it should be no-op
0000000000000000000000000000000000000000;;		revision = 3
0000000000000000000000000000000000000000;;		framework.Logf("rolling back deployment %s to revision %d", deploymentName, revision)
0000000000000000000000000000000000000000;;		rollback = newDeploymentRollback(deploymentName, nil, revision)
0000000000000000000000000000000000000000;;		err = c.Extensions().Deployments(ns).Rollback(rollback)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for the deployment to start rolling back
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRollbackCleared(c, ns, deploymentName)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		// TODO: report RollbackTemplateUnchanged in deployment status and check it here
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The pod template shouldn't change since it's already revision 3
0000000000000000000000000000000000000000;;		// Check if it's still revision 3 and still has the old pod template
0000000000000000000000000000000000000000;;		checkDeploymentRevision(c, ns, deploymentName, "3", deploymentImageName, deploymentImage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testDeploymentLabelAdopted(f *framework.Framework) {
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;		c := f.ClientSet
0000000000000000000000000000000000000000;;		// Create nginx pods.
0000000000000000000000000000000000000000;;		podName := "nginx"
0000000000000000000000000000000000000000;;		podLabels := map[string]string{"name": podName}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rsName := "test-adopted-controller"
0000000000000000000000000000000000000000;;		replicas := int32(1)
0000000000000000000000000000000000000000;;		image := NginxImage
0000000000000000000000000000000000000000;;		_, err := c.Extensions().ReplicaSets(ns).Create(newRS(rsName, replicas, podLabels, podName, image))
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		// Verify that the required pods have come up.
0000000000000000000000000000000000000000;;		err = framework.VerifyPodsRunning(c, ns, podName, false, replicas)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "error in waiting for pods to come up: %v", err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a nginx deployment to adopt the old rs.
0000000000000000000000000000000000000000;;		deploymentName := "test-adopted-deployment"
0000000000000000000000000000000000000000;;		framework.Logf("Creating deployment %s", deploymentName)
0000000000000000000000000000000000000000;;		deploy, err := c.Extensions().Deployments(ns).Create(framework.NewDeployment(deploymentName, replicas, podLabels, podName, image, extensions.RollingUpdateDeploymentStrategyType))
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for it to be updated to revision 1
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRevisionAndImage(c, ns, deploymentName, "1", image)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The RS and pods should be relabeled before the status is updated by syncRollingUpdateDeployment
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentStatusValid(c, deploy)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// There should be no old RSs (overlapping RS)
0000000000000000000000000000000000000000;;		deployment, err := c.Extensions().Deployments(ns).Get(deploymentName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		oldRSs, allOldRSs, newRS, err := deploymentutil.GetAllReplicaSets(deployment, c)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(len(oldRSs)).Should(Equal(0))
0000000000000000000000000000000000000000;;		Expect(len(allOldRSs)).Should(Equal(0))
0000000000000000000000000000000000000000;;		// New RS should contain pod-template-hash in its selector, label, and template label
0000000000000000000000000000000000000000;;		err = framework.CheckRSHashLabel(newRS)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		// All pods targeted by the deployment should contain pod-template-hash in their labels, and there should be only 3 pods
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(deployment.Spec.Selector)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		options := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;		pods, err := c.Core().Pods(ns).List(options)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		err = framework.CheckPodHashLabel(pods)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(int32(len(pods.Items))).Should(Equal(replicas))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Can be moved to a unit test.
0000000000000000000000000000000000000000;;	func testScalePausedDeployment(f *framework.Framework) {
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;		c := f.ClientSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podLabels := map[string]string{"name": NginxImageName}
0000000000000000000000000000000000000000;;		replicas := int32(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a nginx deployment.
0000000000000000000000000000000000000000;;		deploymentName := "nginx-deployment"
0000000000000000000000000000000000000000;;		d := framework.NewDeployment(deploymentName, replicas, podLabels, NginxImageName, NginxImage, extensions.RollingUpdateDeploymentStrategyType)
0000000000000000000000000000000000000000;;		framework.Logf("Creating deployment %q", deploymentName)
0000000000000000000000000000000000000000;;		_, err := c.Extensions().Deployments(ns).Create(d)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check that deployment is created fine.
0000000000000000000000000000000000000000;;		deployment, err := c.Extensions().Deployments(ns).Get(deploymentName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = framework.WaitForObservedDeployment(c, ns, deploymentName, deployment.Generation)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for deployment %q to have no running pods", deploymentName)
0000000000000000000000000000000000000000;;		Expect(framework.WaitForDeploymentUpdatedReplicasLTE(c, ns, deploymentName, replicas, deployment.Generation))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pause the deployment and try to scale it.
0000000000000000000000000000000000000000;;		framework.Logf("Pause deployment %q before scaling it up", deploymentName)
0000000000000000000000000000000000000000;;		deployment, err = framework.UpdateDeploymentWithRetries(c, ns, d.Name, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;			update.Spec.Paused = true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = framework.WaitForObservedDeployment(c, ns, deploymentName, deployment.Generation)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scale the paused deployment.
0000000000000000000000000000000000000000;;		framework.Logf("Scaling up the paused deployment %q", deploymentName)
0000000000000000000000000000000000000000;;		newReplicas := int32(1)
0000000000000000000000000000000000000000;;		deployment, err = framework.UpdateDeploymentWithRetries(c, ns, deployment.Name, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;			update.Spec.Replicas = &newReplicas
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = framework.WaitForObservedDeployment(c, ns, deploymentName, deployment.Generation)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs, err := deploymentutil.GetNewReplicaSet(deployment, c)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(*(rs.Spec.Replicas)).Should(Equal(newReplicas))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testScaledRolloutDeployment(f *framework.Framework) {
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;		c := f.ClientSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podLabels := map[string]string{"name": NginxImageName}
0000000000000000000000000000000000000000;;		replicas := int32(10)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a nginx deployment.
0000000000000000000000000000000000000000;;		deploymentName := "nginx"
0000000000000000000000000000000000000000;;		d := framework.NewDeployment(deploymentName, replicas, podLabels, NginxImageName, NginxImage, extensions.RollingUpdateDeploymentStrategyType)
0000000000000000000000000000000000000000;;		d.Spec.Strategy.RollingUpdate = new(extensions.RollingUpdateDeployment)
0000000000000000000000000000000000000000;;		d.Spec.Strategy.RollingUpdate.MaxSurge = intOrStrP(3)
0000000000000000000000000000000000000000;;		d.Spec.Strategy.RollingUpdate.MaxUnavailable = intOrStrP(2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Creating deployment %q", deploymentName)
0000000000000000000000000000000000000000;;		deployment, err := c.Extensions().Deployments(ns).Create(d)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for observed generation %d", deployment.Generation)
0000000000000000000000000000000000000000;;		Expect(framework.WaitForObservedDeployment(c, ns, deploymentName, deployment.Generation)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify that the required pods have come up.
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for all required pods to come up")
0000000000000000000000000000000000000000;;		err = framework.VerifyPodsRunning(f.ClientSet, ns, NginxImageName, false, *(deployment.Spec.Replicas))
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "error in waiting for pods to come up: %v", err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for deployment %q to complete", deployment.Name)
0000000000000000000000000000000000000000;;		Expect(framework.WaitForDeploymentStatusValid(c, deployment)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		first, err := deploymentutil.GetNewReplicaSet(deployment, c)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update the deployment with a non-existent image so that the new replica set will be blocked.
0000000000000000000000000000000000000000;;		framework.Logf("Updating deployment %q with a non-existent image", deploymentName)
0000000000000000000000000000000000000000;;		deployment, err = framework.UpdateDeploymentWithRetries(c, ns, d.Name, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;			update.Spec.Template.Spec.Containers[0].Image = "nginx:404"
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for observed generation %d", deployment.Generation)
0000000000000000000000000000000000000000;;		err = framework.WaitForObservedDeployment(c, ns, deploymentName, deployment.Generation)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deployment, err = c.Extensions().Deployments(ns).Get(deploymentName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if deployment.Status.AvailableReplicas < deploymentutil.MinAvailable(deployment) {
0000000000000000000000000000000000000000;;			Expect(fmt.Errorf("Observed %d available replicas, less than min required %d", deployment.Status.AvailableReplicas, deploymentutil.MinAvailable(deployment))).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Checking that the replica sets for %q are synced", deploymentName)
0000000000000000000000000000000000000000;;		second, err := deploymentutil.GetNewReplicaSet(deployment, c)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		first, err = c.Extensions().ReplicaSets(first.Namespace).Get(first.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		firstCond := replicaSetHasDesiredReplicas(c.Extensions(), first)
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(10*time.Millisecond, 1*time.Minute, firstCond)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secondCond := replicaSetHasDesiredReplicas(c.Extensions(), second)
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(10*time.Millisecond, 1*time.Minute, secondCond)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Updating the size (up) and template at the same time for deployment %q", deploymentName)
0000000000000000000000000000000000000000;;		newReplicas := int32(20)
0000000000000000000000000000000000000000;;		deployment, err = framework.UpdateDeploymentWithRetries(c, ns, deployment.Name, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;			update.Spec.Replicas = &newReplicas
0000000000000000000000000000000000000000;;			update.Spec.Template.Spec.Containers[0].Image = NautilusImage
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = framework.WaitForObservedDeployment(c, ns, deploymentName, deployment.Generation)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for deployment status to sync (current available: %d, minimum available: %d)", deployment.Status.AvailableReplicas, deploymentutil.MinAvailable(deployment))
0000000000000000000000000000000000000000;;		Expect(framework.WaitForDeploymentStatusValid(c, deployment)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oldRSs, _, rs, err := deploymentutil.GetAllReplicaSets(deployment, c)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rs := range append(oldRSs, rs) {
0000000000000000000000000000000000000000;;			framework.Logf("Ensuring replica set %q has the correct desiredReplicas annotation", rs.Name)
0000000000000000000000000000000000000000;;			desired, ok := deploymentutil.GetDesiredReplicasAnnotation(rs)
0000000000000000000000000000000000000000;;			if !ok || desired == *(deployment.Spec.Replicas) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = fmt.Errorf("unexpected desiredReplicas annotation %d for replica set %q", desired, rs.Name)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update the deployment with a non-existent image so that the new replica set will be blocked.
0000000000000000000000000000000000000000;;		framework.Logf("Updating deployment %q with a non-existent image", deploymentName)
0000000000000000000000000000000000000000;;		deployment, err = framework.UpdateDeploymentWithRetries(c, ns, d.Name, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;			update.Spec.Template.Spec.Containers[0].Image = "nginx:404"
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for observed generation %d", deployment.Generation)
0000000000000000000000000000000000000000;;		err = framework.WaitForObservedDeployment(c, ns, deploymentName, deployment.Generation)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deployment, err = c.Extensions().Deployments(ns).Get(deploymentName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if deployment.Status.AvailableReplicas < deploymentutil.MinAvailable(deployment) {
0000000000000000000000000000000000000000;;			Expect(fmt.Errorf("Observed %d available replicas, less than min required %d", deployment.Status.AvailableReplicas, deploymentutil.MinAvailable(deployment))).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Checking that the replica sets for %q are synced", deploymentName)
0000000000000000000000000000000000000000;;		oldRs, err := c.Extensions().ReplicaSets(rs.Namespace).Get(rs.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newRs, err := deploymentutil.GetNewReplicaSet(deployment, c)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oldCond := replicaSetHasDesiredReplicas(c.Extensions(), oldRs)
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(10*time.Millisecond, 1*time.Minute, oldCond)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newCond := replicaSetHasDesiredReplicas(c.Extensions(), newRs)
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(10*time.Millisecond, 1*time.Minute, newCond)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Updating the size (down) and template at the same time for deployment %q", deploymentName)
0000000000000000000000000000000000000000;;		newReplicas = int32(5)
0000000000000000000000000000000000000000;;		deployment, err = framework.UpdateDeploymentWithRetries(c, ns, deployment.Name, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;			update.Spec.Replicas = &newReplicas
0000000000000000000000000000000000000000;;			update.Spec.Template.Spec.Containers[0].Image = KittenImage
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = framework.WaitForObservedDeployment(c, ns, deploymentName, deployment.Generation)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for deployment status to sync (current available: %d, minimum available: %d)", deployment.Status.AvailableReplicas, deploymentutil.MinAvailable(deployment))
0000000000000000000000000000000000000000;;		Expect(framework.WaitForDeploymentStatusValid(c, deployment)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oldRSs, _, rs, err = deploymentutil.GetAllReplicaSets(deployment, c)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rs := range append(oldRSs, rs) {
0000000000000000000000000000000000000000;;			framework.Logf("Ensuring replica set %q has the correct desiredReplicas annotation", rs.Name)
0000000000000000000000000000000000000000;;			desired, ok := deploymentutil.GetDesiredReplicasAnnotation(rs)
0000000000000000000000000000000000000000;;			if !ok || desired == *(deployment.Spec.Replicas) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = fmt.Errorf("unexpected desiredReplicas annotation %d for replica set %q", desired, rs.Name)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testOverlappingDeployment(f *framework.Framework) {
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;		c := f.ClientSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create first deployment.
0000000000000000000000000000000000000000;;		deploymentName := "first-deployment"
0000000000000000000000000000000000000000;;		podLabels := map[string]string{"name": RedisImageName}
0000000000000000000000000000000000000000;;		replicas := int32(1)
0000000000000000000000000000000000000000;;		framework.Logf("Creating deployment %q", deploymentName)
0000000000000000000000000000000000000000;;		d := framework.NewDeployment(deploymentName, replicas, podLabels, RedisImageName, RedisImage, extensions.RollingUpdateDeploymentStrategyType)
0000000000000000000000000000000000000000;;		deploy, err := c.Extensions().Deployments(ns).Create(d)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "Failed creating the first deployment")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for it to be updated to revision 1
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRevisionAndImage(c, ns, deploy.Name, "1", RedisImage)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "The first deployment failed to update to revision 1")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create second deployment with overlapping selector.
0000000000000000000000000000000000000000;;		deploymentName = "second-deployment"
0000000000000000000000000000000000000000;;		framework.Logf("Creating deployment %q with overlapping selector", deploymentName)
0000000000000000000000000000000000000000;;		podLabels["other-label"] = "random-label"
0000000000000000000000000000000000000000;;		d = framework.NewDeployment(deploymentName, replicas, podLabels, NginxImageName, NginxImage, extensions.RollingUpdateDeploymentStrategyType)
0000000000000000000000000000000000000000;;		deployOverlapping, err := c.Extensions().Deployments(ns).Create(d)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "Failed creating the second deployment")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for it to be updated to revision 1
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRevisionAndImage(c, ns, deployOverlapping.Name, "1", NginxImage)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "The second deployment failed to update to revision 1")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Both deployments should proceed independently.
0000000000000000000000000000000000000000;;		framework.Logf("Checking each deployment creates its own replica set")
0000000000000000000000000000000000000000;;		options := metav1.ListOptions{}
0000000000000000000000000000000000000000;;		rsList, err := c.Extensions().ReplicaSets(ns).List(options)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "Failed listing all replica sets in namespace %s", ns)
0000000000000000000000000000000000000000;;		Expect(rsList.Items).To(HaveLen(2))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testFailedDeployment(f *framework.Framework) {
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;		c := f.ClientSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podLabels := map[string]string{"name": NginxImageName}
0000000000000000000000000000000000000000;;		replicas := int32(1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a nginx deployment.
0000000000000000000000000000000000000000;;		deploymentName := "progress-check"
0000000000000000000000000000000000000000;;		nonExistentImage := "nginx:not-there"
0000000000000000000000000000000000000000;;		ten := int32(10)
0000000000000000000000000000000000000000;;		d := framework.NewDeployment(deploymentName, replicas, podLabels, NginxImageName, nonExistentImage, extensions.RecreateDeploymentStrategyType)
0000000000000000000000000000000000000000;;		d.Spec.ProgressDeadlineSeconds = &ten
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Creating deployment %q with progressDeadlineSeconds set to %ds and a non-existent image", deploymentName, ten)
0000000000000000000000000000000000000000;;		deployment, err := c.Extensions().Deployments(ns).Create(d)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for deployment %q new replica set to come up", deploymentName)
0000000000000000000000000000000000000000;;		Expect(framework.WaitForDeploymentUpdatedReplicasLTE(c, ns, deploymentName, replicas, deployment.Generation))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Checking deployment %q for a timeout condition", deploymentName)
0000000000000000000000000000000000000000;;		Expect(framework.WaitForDeploymentWithCondition(c, ns, deploymentName, deploymentutil.TimedOutReason, extensions.DeploymentProgressing)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Updating deployment %q with a good image", deploymentName)
0000000000000000000000000000000000000000;;		deployment, err = framework.UpdateDeploymentWithRetries(c, ns, deployment.Name, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;			update.Spec.Template.Spec.Containers[0].Image = NginxImage
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for deployment %q new replica set to come up", deploymentName)
0000000000000000000000000000000000000000;;		Expect(framework.WaitForDeploymentUpdatedReplicasLTE(c, ns, deploymentName, replicas, deployment.Generation))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for deployment %q status", deploymentName)
0000000000000000000000000000000000000000;;		Expect(framework.WaitForDeploymentStatusValid(c, deployment)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Checking deployment %q for a complete condition", deploymentName)
0000000000000000000000000000000000000000;;		Expect(framework.WaitForDeploymentWithCondition(c, ns, deploymentName, deploymentutil.NewRSAvailableReason, extensions.DeploymentProgressing)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func randomScale(d *extensions.Deployment, i int) {
0000000000000000000000000000000000000000;;		switch r := rand.Float32(); {
0000000000000000000000000000000000000000;;		case r < 0.3:
0000000000000000000000000000000000000000;;			framework.Logf("%02d: scaling up", i)
0000000000000000000000000000000000000000;;			*(d.Spec.Replicas)++
0000000000000000000000000000000000000000;;		case r < 0.6:
0000000000000000000000000000000000000000;;			if *(d.Spec.Replicas) > 1 {
0000000000000000000000000000000000000000;;				framework.Logf("%02d: scaling down", i)
0000000000000000000000000000000000000000;;				*(d.Spec.Replicas)--
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testIterativeDeployments(f *framework.Framework) {
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;		c := f.ClientSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podLabels := map[string]string{"name": NginxImageName}
0000000000000000000000000000000000000000;;		replicas := int32(6)
0000000000000000000000000000000000000000;;		zero := int64(0)
0000000000000000000000000000000000000000;;		two := int32(2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a nginx deployment.
0000000000000000000000000000000000000000;;		deploymentName := "nginx"
0000000000000000000000000000000000000000;;		thirty := int32(30)
0000000000000000000000000000000000000000;;		d := framework.NewDeployment(deploymentName, replicas, podLabels, NginxImageName, NginxImage, extensions.RollingUpdateDeploymentStrategyType)
0000000000000000000000000000000000000000;;		d.Spec.ProgressDeadlineSeconds = &thirty
0000000000000000000000000000000000000000;;		d.Spec.RevisionHistoryLimit = &two
0000000000000000000000000000000000000000;;		d.Spec.Template.Spec.TerminationGracePeriodSeconds = &zero
0000000000000000000000000000000000000000;;		framework.Logf("Creating deployment %q", deploymentName)
0000000000000000000000000000000000000000;;		deployment, err := c.Extensions().Deployments(ns).Create(d)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		iterations := 20
0000000000000000000000000000000000000000;;		for i := 0; i < iterations; i++ {
0000000000000000000000000000000000000000;;			if r := rand.Float32(); r < 0.6 {
0000000000000000000000000000000000000000;;				time.Sleep(time.Duration(float32(i) * r * float32(time.Second)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch n := rand.Float32(); {
0000000000000000000000000000000000000000;;			case n < 0.2:
0000000000000000000000000000000000000000;;				// trigger a new deployment
0000000000000000000000000000000000000000;;				framework.Logf("%02d: triggering a new rollout for deployment %q", i, deployment.Name)
0000000000000000000000000000000000000000;;				deployment, err = framework.UpdateDeploymentWithRetries(c, ns, deployment.Name, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;					newEnv := v1.EnvVar{Name: "A", Value: fmt.Sprintf("%d", i)}
0000000000000000000000000000000000000000;;					update.Spec.Template.Spec.Containers[0].Env = append(update.Spec.Template.Spec.Containers[0].Env, newEnv)
0000000000000000000000000000000000000000;;					randomScale(update, i)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case n < 0.4:
0000000000000000000000000000000000000000;;				// rollback to the previous version
0000000000000000000000000000000000000000;;				framework.Logf("%02d: rolling back a rollout for deployment %q", i, deployment.Name)
0000000000000000000000000000000000000000;;				deployment, err = framework.UpdateDeploymentWithRetries(c, ns, deployment.Name, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;					rollbackTo := &extensions.RollbackConfig{Revision: 0}
0000000000000000000000000000000000000000;;					update.Spec.RollbackTo = rollbackTo
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case n < 0.6:
0000000000000000000000000000000000000000;;				// just scaling
0000000000000000000000000000000000000000;;				framework.Logf("%02d: scaling deployment %q", i, deployment.Name)
0000000000000000000000000000000000000000;;				deployment, err = framework.UpdateDeploymentWithRetries(c, ns, deployment.Name, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;					randomScale(update, i)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case n < 0.8:
0000000000000000000000000000000000000000;;				// toggling the deployment
0000000000000000000000000000000000000000;;				if deployment.Spec.Paused {
0000000000000000000000000000000000000000;;					framework.Logf("%02d: pausing deployment %q", i, deployment.Name)
0000000000000000000000000000000000000000;;					deployment, err = framework.UpdateDeploymentWithRetries(c, ns, deployment.Name, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;						update.Spec.Paused = true
0000000000000000000000000000000000000000;;						randomScale(update, i)
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					framework.Logf("%02d: resuming deployment %q", i, deployment.Name)
0000000000000000000000000000000000000000;;					deployment, err = framework.UpdateDeploymentWithRetries(c, ns, deployment.Name, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;						update.Spec.Paused = false
0000000000000000000000000000000000000000;;						randomScale(update, i)
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// arbitrarily delete deployment pods
0000000000000000000000000000000000000000;;				framework.Logf("%02d: arbitrarily deleting one or more deployment pods for deployment %q", i, deployment.Name)
0000000000000000000000000000000000000000;;				selector, err := metav1.LabelSelectorAsSelector(deployment.Spec.Selector)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				opts := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;				podList, err := c.Core().Pods(ns).List(opts)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				if len(podList.Items) == 0 {
0000000000000000000000000000000000000000;;					framework.Logf("%02d: no deployment pods to delete", i)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for p := range podList.Items {
0000000000000000000000000000000000000000;;					if rand.Float32() < 0.5 {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					name := podList.Items[p].Name
0000000000000000000000000000000000000000;;					framework.Logf("%02d: deleting deployment pod %q", i, name)
0000000000000000000000000000000000000000;;					err := c.Core().Pods(ns).Delete(name, nil)
0000000000000000000000000000000000000000;;					if err != nil && !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;						Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// unpause the deployment if we end up pausing it
0000000000000000000000000000000000000000;;		deployment, err = c.Extensions().Deployments(ns).Get(deployment.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		if deployment.Spec.Paused {
0000000000000000000000000000000000000000;;			deployment, err = framework.UpdateDeploymentWithRetries(c, ns, deployment.Name, func(update *extensions.Deployment) {
0000000000000000000000000000000000000000;;				update.Spec.Paused = false
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for deployment %q to be observed by the controller", deploymentName)
0000000000000000000000000000000000000000;;		Expect(framework.WaitForObservedDeployment(c, ns, deploymentName, deployment.Generation)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for deployment %q status", deploymentName)
0000000000000000000000000000000000000000;;		Expect(framework.WaitForDeploymentStatusValid(c, deployment)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Checking deployment %q for a complete condition", deploymentName)
0000000000000000000000000000000000000000;;		Expect(framework.WaitForDeploymentWithCondition(c, ns, deploymentName, deploymentutil.NewRSAvailableReason, extensions.DeploymentProgressing)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func replicaSetHasDesiredReplicas(rsClient extensionsclient.ReplicaSetsGetter, replicaSet *extensions.ReplicaSet) wait.ConditionFunc {
0000000000000000000000000000000000000000;;		desiredGeneration := replicaSet.Generation
0000000000000000000000000000000000000000;;		return func() (bool, error) {
0000000000000000000000000000000000000000;;			rs, err := rsClient.ReplicaSets(replicaSet.Namespace).Get(replicaSet.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return rs.Status.ObservedGeneration >= desiredGeneration && rs.Status.Replicas == *(rs.Spec.Replicas), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testDeploymentsControllerRef(f *framework.Framework) {
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;		c := f.ClientSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deploymentName := "test-orphan-deployment"
0000000000000000000000000000000000000000;;		framework.Logf("Creating Deployment %q", deploymentName)
0000000000000000000000000000000000000000;;		podLabels := map[string]string{"name": NginxImageName}
0000000000000000000000000000000000000000;;		replicas := int32(1)
0000000000000000000000000000000000000000;;		d := framework.NewDeployment(deploymentName, replicas, podLabels, NginxImageName, NginxImage, extensions.RollingUpdateDeploymentStrategyType)
0000000000000000000000000000000000000000;;		deploy, err := c.Extensions().Deployments(ns).Create(d)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentStatusValid(c, deploy)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Checking its ReplicaSet has the right controllerRef")
0000000000000000000000000000000000000000;;		err = checkDeploymentReplicaSetsControllerRef(c, ns, deploy.UID, podLabels)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Deleting Deployment %q and orphaning its ReplicaSets", deploymentName)
0000000000000000000000000000000000000000;;		err = orphanDeploymentReplicaSets(c, deploy)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Wait for the ReplicaSet to be orphaned")
0000000000000000000000000000000000000000;;		err = wait.Poll(dRetryPeriod, dRetryTimeout, waitDeploymentReplicaSetsOrphaned(c, ns, podLabels))
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "error waiting for Deployment ReplicaSet to be orphaned")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deploymentName = "test-adopt-deployment"
0000000000000000000000000000000000000000;;		framework.Logf("Creating Deployment %q to adopt the ReplicaSet", deploymentName)
0000000000000000000000000000000000000000;;		d = framework.NewDeployment(deploymentName, replicas, podLabels, NginxImageName, NginxImage, extensions.RollingUpdateDeploymentStrategyType)
0000000000000000000000000000000000000000;;		deploy, err = c.Extensions().Deployments(ns).Create(d)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentStatusValid(c, deploy)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for the ReplicaSet to have the right controllerRef")
0000000000000000000000000000000000000000;;		err = checkDeploymentReplicaSetsControllerRef(c, ns, deploy.UID, podLabels)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitDeploymentReplicaSetsControllerRef(c clientset.Interface, ns string, uid types.UID, label map[string]string) func() (bool, error) {
0000000000000000000000000000000000000000;;		return func() (bool, error) {
0000000000000000000000000000000000000000;;			err := checkDeploymentReplicaSetsControllerRef(c, ns, uid, label)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkDeploymentReplicaSetsControllerRef(c clientset.Interface, ns string, uid types.UID, label map[string]string) error {
0000000000000000000000000000000000000000;;		rsList := listDeploymentReplicaSets(c, ns, label)
0000000000000000000000000000000000000000;;		for _, rs := range rsList.Items {
0000000000000000000000000000000000000000;;			// This rs is adopted only when its controller ref is update
0000000000000000000000000000000000000000;;			if controllerRef := controller.GetControllerOf(&rs); controllerRef == nil || controllerRef.UID != uid {
0000000000000000000000000000000000000000;;				return fmt.Errorf("ReplicaSet %s has unexpected controllerRef %v", rs.Name, controllerRef)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitDeploymentReplicaSetsOrphaned(c clientset.Interface, ns string, label map[string]string) func() (bool, error) {
0000000000000000000000000000000000000000;;		return func() (bool, error) {
0000000000000000000000000000000000000000;;			rsList := listDeploymentReplicaSets(c, ns, label)
0000000000000000000000000000000000000000;;			for _, rs := range rsList.Items {
0000000000000000000000000000000000000000;;				// This rs is orphaned only when controller ref is cleared
0000000000000000000000000000000000000000;;				if controllerRef := controller.GetControllerOf(&rs); controllerRef != nil {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func listDeploymentReplicaSets(c clientset.Interface, ns string, label map[string]string) *extensions.ReplicaSetList {
0000000000000000000000000000000000000000;;		selector := labels.Set(label).AsSelector()
0000000000000000000000000000000000000000;;		options := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;		rsList, err := c.Extensions().ReplicaSets(ns).List(options)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(len(rsList.Items)).To(BeNumerically(">", 0))
0000000000000000000000000000000000000000;;		return rsList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func orphanDeploymentReplicaSets(c clientset.Interface, d *extensions.Deployment) error {
0000000000000000000000000000000000000000;;		trueVar := true
0000000000000000000000000000000000000000;;		deleteOptions := &metav1.DeleteOptions{OrphanDependents: &trueVar}
0000000000000000000000000000000000000000;;		deleteOptions.Preconditions = metav1.NewUIDPreconditions(string(d.UID))
0000000000000000000000000000000000000000;;		return c.Extensions().Deployments(d.Namespace).Delete(d.Name, deleteOptions)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testDeploymentHashCollisionAvoidance(f *framework.Framework) {
0000000000000000000000000000000000000000;;		ns := f.Namespace.Name
0000000000000000000000000000000000000000;;		c := f.ClientSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deploymentName := "test-hash-collision"
0000000000000000000000000000000000000000;;		framework.Logf("Creating Deployment %q", deploymentName)
0000000000000000000000000000000000000000;;		podLabels := map[string]string{"name": NginxImageName}
0000000000000000000000000000000000000000;;		d := framework.NewDeployment(deploymentName, int32(0), podLabels, NginxImageName, NginxImage, extensions.RollingUpdateDeploymentStrategyType)
0000000000000000000000000000000000000000;;		deployment, err := c.Extensions().Deployments(ns).Create(d)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRevisionAndImage(c, ns, deploymentName, "1", NginxImage)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Switch this to do a non-cascading deletion of the Deployment, mutate the ReplicaSet
0000000000000000000000000000000000000000;;		// once it has no owner reference, then recreate the Deployment if we ever proceed with
0000000000000000000000000000000000000000;;		// https://github.com/kubernetes/kubernetes/issues/44237
0000000000000000000000000000000000000000;;		framework.Logf("Mock a hash collision")
0000000000000000000000000000000000000000;;		newRS, err := deploymentutil.GetNewReplicaSet(deployment, c)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		var nilRs *extensions.ReplicaSet
0000000000000000000000000000000000000000;;		Expect(newRS).NotTo(Equal(nilRs))
0000000000000000000000000000000000000000;;		_, err = framework.UpdateReplicaSetWithRetries(c, ns, newRS.Name, func(update *extensions.ReplicaSet) {
0000000000000000000000000000000000000000;;			*update.Spec.Template.Spec.TerminationGracePeriodSeconds = int64(5)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Expect deployment collision counter to increment")
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(time.Second, time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			d, err := c.Extensions().Deployments(ns).Get(deploymentName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("cannot get deployment %q: %v", deploymentName, err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.Logf(spew.Sprintf("deployment status: %#v", d.Status))
0000000000000000000000000000000000000000;;			return d.Status.CollisionCount != nil && *d.Status.CollisionCount == int64(1), nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Failed to increment collision counter for deployment %q: %v", deploymentName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Expect a new ReplicaSet to be created")
0000000000000000000000000000000000000000;;		err = framework.WaitForDeploymentRevisionAndImage(c, ns, deploymentName, "2", NginxImage)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	}
