0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
c1b60d772eced72df62dcc96ad41f0e8b2f41f7b;test/e2e/petset.go[test/e2e/petset.go][test/e2e/workload/statefulset.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package workload
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		apps "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		klabels "k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		zookeeperManifestPath   = "test/e2e/testing-manifests/statefulset/zookeeper"
0000000000000000000000000000000000000000;;		mysqlGaleraManifestPath = "test/e2e/testing-manifests/statefulset/mysql-galera"
0000000000000000000000000000000000000000;;		redisManifestPath       = "test/e2e/testing-manifests/statefulset/redis"
0000000000000000000000000000000000000000;;		cockroachDBManifestPath = "test/e2e/testing-manifests/statefulset/cockroachdb"
0000000000000000000000000000000000000000;;		// We don't restart MySQL cluster regardless of restartCluster, since MySQL doesn't handle restart well
0000000000000000000000000000000000000000;;		restartCluster = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Timeout for reads from databases running on stateful pods.
0000000000000000000000000000000000000000;;		readTimeout = 60 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GCE Quota requirements: 3 pds, one per stateful pod manifest declared above.
0000000000000000000000000000000000000000;;	// GCE Api requirements: nodes and master need storage r/w permissions.
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("StatefulSet", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("statefulset")
0000000000000000000000000000000000000000;;		var ns string
0000000000000000000000000000000000000000;;		var c clientset.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			c = f.ClientSet
0000000000000000000000000000000000000000;;			ns = f.Namespace.Name
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Basic StatefulSet functionality [StatefulSetBasic]", func() {
0000000000000000000000000000000000000000;;			ssName := "ss"
0000000000000000000000000000000000000000;;			labels := map[string]string{
0000000000000000000000000000000000000000;;				"foo": "bar",
0000000000000000000000000000000000000000;;				"baz": "blah",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			headlessSvcName := "test"
0000000000000000000000000000000000000000;;			var statefulPodMounts, podMounts []v1.VolumeMount
0000000000000000000000000000000000000000;;			var ss *apps.StatefulSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				statefulPodMounts = []v1.VolumeMount{{Name: "datadir", MountPath: "/data/"}}
0000000000000000000000000000000000000000;;				podMounts = []v1.VolumeMount{{Name: "home", MountPath: "/home"}}
0000000000000000000000000000000000000000;;				ss = framework.NewStatefulSet(ssName, ns, headlessSvcName, 2, statefulPodMounts, podMounts, labels)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Creating service " + headlessSvcName + " in namespace " + ns)
0000000000000000000000000000000000000000;;				headlessService := framework.CreateServiceSpec(headlessSvcName, "", true, labels)
0000000000000000000000000000000000000000;;				_, err := c.Core().Services(ns).Create(headlessService)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				if CurrentGinkgoTestDescription().Failed {
0000000000000000000000000000000000000000;;					framework.DumpDebugInfo(c, ns)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.Logf("Deleting all statefulset in ns %v", ns)
0000000000000000000000000000000000000000;;				framework.DeleteAllStatefulSets(c, ns)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should provide basic identity", func() {
0000000000000000000000000000000000000000;;				By("Creating statefulset " + ssName + " in namespace " + ns)
0000000000000000000000000000000000000000;;				*(ss.Spec.Replicas) = 3
0000000000000000000000000000000000000000;;				framework.SetStatefulSetInitializedAnnotation(ss, "false")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				_, err := c.Apps().StatefulSets(ns).Create(ss)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				sst := framework.NewStatefulSetTester(c)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Saturating stateful set " + ss.Name)
0000000000000000000000000000000000000000;;				sst.Saturate(ss)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Verifying statefulset mounted data directory is usable")
0000000000000000000000000000000000000000;;				framework.ExpectNoError(sst.CheckMount(ss, "/data"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Verifying statefulset provides a stable hostname for each pod")
0000000000000000000000000000000000000000;;				framework.ExpectNoError(sst.CheckHostname(ss))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Verifying statefulset set proper service name")
0000000000000000000000000000000000000000;;				framework.ExpectNoError(sst.CheckServiceName(ss, headlessSvcName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				cmd := "echo $(hostname) > /data/hostname; sync;"
0000000000000000000000000000000000000000;;				By("Running " + cmd + " in all stateful pods")
0000000000000000000000000000000000000000;;				framework.ExpectNoError(sst.ExecInStatefulPods(ss, cmd))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Restarting statefulset " + ss.Name)
0000000000000000000000000000000000000000;;				sst.Restart(ss)
0000000000000000000000000000000000000000;;				sst.Saturate(ss)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Verifying statefulset mounted data directory is usable")
0000000000000000000000000000000000000000;;				framework.ExpectNoError(sst.CheckMount(ss, "/data"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				cmd = "if [ \"$(cat /data/hostname)\" = \"$(hostname)\" ]; then exit 0; else exit 1; fi"
0000000000000000000000000000000000000000;;				By("Running " + cmd + " in all stateful pods")
0000000000000000000000000000000000000000;;				framework.ExpectNoError(sst.ExecInStatefulPods(ss, cmd))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should adopt matching orphans and release non-matching pods", func() {
0000000000000000000000000000000000000000;;				By("Creating statefulset " + ssName + " in namespace " + ns)
0000000000000000000000000000000000000000;;				*(ss.Spec.Replicas) = 1
0000000000000000000000000000000000000000;;				framework.SetStatefulSetInitializedAnnotation(ss, "false")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Replace ss with the one returned from Create() so it has the UID.
0000000000000000000000000000000000000000;;				// Save Kind since it won't be populated in the returned ss.
0000000000000000000000000000000000000000;;				kind := ss.Kind
0000000000000000000000000000000000000000;;				ss, err := c.Apps().StatefulSets(ns).Create(ss)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				ss.Kind = kind
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				sst := framework.NewStatefulSetTester(c)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Saturating stateful set " + ss.Name)
0000000000000000000000000000000000000000;;				sst.Saturate(ss)
0000000000000000000000000000000000000000;;				pods := sst.GetPodList(ss)
0000000000000000000000000000000000000000;;				Expect(pods.Items).To(HaveLen(int(*ss.Spec.Replicas)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Checking that stateful set pods are created with ControllerRef")
0000000000000000000000000000000000000000;;				pod := pods.Items[0]
0000000000000000000000000000000000000000;;				controllerRef := controller.GetControllerOf(&pod)
0000000000000000000000000000000000000000;;				Expect(controllerRef).ToNot(BeNil())
0000000000000000000000000000000000000000;;				Expect(controllerRef.Kind).To(Equal(ss.Kind))
0000000000000000000000000000000000000000;;				Expect(controllerRef.Name).To(Equal(ss.Name))
0000000000000000000000000000000000000000;;				Expect(controllerRef.UID).To(Equal(ss.UID))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Orphaning one of the stateful set's pods")
0000000000000000000000000000000000000000;;				f.PodClient().Update(pod.Name, func(pod *v1.Pod) {
0000000000000000000000000000000000000000;;					pod.OwnerReferences = nil
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Checking that the stateful set readopts the pod")
0000000000000000000000000000000000000000;;				Expect(framework.WaitForPodCondition(c, pod.Namespace, pod.Name, "adopted", framework.StatefulSetTimeout,
0000000000000000000000000000000000000000;;					func(pod *v1.Pod) (bool, error) {
0000000000000000000000000000000000000000;;						controllerRef := controller.GetControllerOf(pod)
0000000000000000000000000000000000000000;;						if controllerRef == nil {
0000000000000000000000000000000000000000;;							return false, nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if controllerRef.Kind != ss.Kind || controllerRef.Name != ss.Name || controllerRef.UID != ss.UID {
0000000000000000000000000000000000000000;;							return false, fmt.Errorf("pod has wrong controllerRef: %v", controllerRef)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return true, nil
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				)).To(Succeed(), "wait for pod %q to be readopted", pod.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Removing the labels from one of the stateful set's pods")
0000000000000000000000000000000000000000;;				prevLabels := pod.Labels
0000000000000000000000000000000000000000;;				f.PodClient().Update(pod.Name, func(pod *v1.Pod) {
0000000000000000000000000000000000000000;;					pod.Labels = nil
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Checking that the stateful set releases the pod")
0000000000000000000000000000000000000000;;				Expect(framework.WaitForPodCondition(c, pod.Namespace, pod.Name, "released", framework.StatefulSetTimeout,
0000000000000000000000000000000000000000;;					func(pod *v1.Pod) (bool, error) {
0000000000000000000000000000000000000000;;						controllerRef := controller.GetControllerOf(pod)
0000000000000000000000000000000000000000;;						if controllerRef != nil {
0000000000000000000000000000000000000000;;							return false, nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return true, nil
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				)).To(Succeed(), "wait for pod %q to be released", pod.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// If we don't do this, the test leaks the Pod and PVC.
0000000000000000000000000000000000000000;;				By("Readding labels to the stateful set's pod")
0000000000000000000000000000000000000000;;				f.PodClient().Update(pod.Name, func(pod *v1.Pod) {
0000000000000000000000000000000000000000;;					pod.Labels = prevLabels
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Checking that the stateful set readopts the pod")
0000000000000000000000000000000000000000;;				Expect(framework.WaitForPodCondition(c, pod.Namespace, pod.Name, "adopted", framework.StatefulSetTimeout,
0000000000000000000000000000000000000000;;					func(pod *v1.Pod) (bool, error) {
0000000000000000000000000000000000000000;;						controllerRef := controller.GetControllerOf(pod)
0000000000000000000000000000000000000000;;						if controllerRef == nil {
0000000000000000000000000000000000000000;;							return false, nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if controllerRef.Kind != ss.Kind || controllerRef.Name != ss.Name || controllerRef.UID != ss.UID {
0000000000000000000000000000000000000000;;							return false, fmt.Errorf("pod has wrong controllerRef: %v", controllerRef)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return true, nil
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				)).To(Succeed(), "wait for pod %q to be readopted", pod.Name)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should not deadlock when a pod's predecessor fails", func() {
0000000000000000000000000000000000000000;;				By("Creating statefulset " + ssName + " in namespace " + ns)
0000000000000000000000000000000000000000;;				*(ss.Spec.Replicas) = 2
0000000000000000000000000000000000000000;;				framework.SetStatefulSetInitializedAnnotation(ss, "false")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				_, err := c.Apps().StatefulSets(ns).Create(ss)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				sst := framework.NewStatefulSetTester(c)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				sst.WaitForRunningAndReady(1, ss)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Marking stateful pod at index 0 as healthy.")
0000000000000000000000000000000000000000;;				sst.SetHealthy(ss)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Waiting for stateful pod at index 1 to enter running.")
0000000000000000000000000000000000000000;;				sst.WaitForRunningAndReady(2, ss)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Now we have 1 healthy and 1 unhealthy stateful pod. Deleting the healthy stateful pod should *not*
0000000000000000000000000000000000000000;;				// create a new stateful pod till the remaining stateful pod becomes healthy, which won't happen till
0000000000000000000000000000000000000000;;				// we set the healthy bit.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Deleting healthy stateful pod at index 0.")
0000000000000000000000000000000000000000;;				sst.DeleteStatefulPodAtIndex(0, ss)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Confirming stateful pod at index 0 is recreated.")
0000000000000000000000000000000000000000;;				sst.WaitForRunningAndReady(2, ss)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Deleting unhealthy stateful pod at index 1.")
0000000000000000000000000000000000000000;;				sst.DeleteStatefulPodAtIndex(1, ss)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Confirming all stateful pods in statefulset are created.")
0000000000000000000000000000000000000000;;				sst.Saturate(ss)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should perform rolling updates and roll backs of template modifications", func() {
0000000000000000000000000000000000000000;;				By("Creating a new StatefulSet")
0000000000000000000000000000000000000000;;				testProbe := &v1.Probe{Handler: v1.Handler{HTTPGet: &v1.HTTPGetAction{
0000000000000000000000000000000000000000;;					Path: "/index.html",
0000000000000000000000000000000000000000;;					Port: intstr.IntOrString{IntVal: 80}}}}
0000000000000000000000000000000000000000;;				ss := framework.NewStatefulSet("ss2", ns, headlessSvcName, 3, nil, nil, labels)
0000000000000000000000000000000000000000;;				ss.Spec.Template.Spec.Containers[0].ReadinessProbe = testProbe
0000000000000000000000000000000000000000;;				ss, err := c.Apps().StatefulSets(ns).Create(ss)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				sst := framework.NewStatefulSetTester(c)
0000000000000000000000000000000000000000;;				sst.WaitForRunningAndReady(*ss.Spec.Replicas, ss)
0000000000000000000000000000000000000000;;				ss = sst.WaitForStatus(ss)
0000000000000000000000000000000000000000;;				currentRevision, updateRevision := ss.Status.CurrentRevision, ss.Status.UpdateRevision
0000000000000000000000000000000000000000;;				Expect(currentRevision).To(Equal(updateRevision),
0000000000000000000000000000000000000000;;					fmt.Sprintf("StatefulSet %s/%s created with update revision %s not equal to current revision %s",
0000000000000000000000000000000000000000;;						ss.Namespace, ss.Name, updateRevision, currentRevision))
0000000000000000000000000000000000000000;;				pods := sst.GetPodList(ss)
0000000000000000000000000000000000000000;;				for i := range pods.Items {
0000000000000000000000000000000000000000;;					Expect(pods.Items[i].Labels[apps.StatefulSetRevisionLabel]).To(Equal(currentRevision),
0000000000000000000000000000000000000000;;						fmt.Sprintf("Pod %s/%s revision %s is not equal to current revision %s",
0000000000000000000000000000000000000000;;							pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;							pods.Items[i].Name,
0000000000000000000000000000000000000000;;							pods.Items[i].Labels[apps.StatefulSetRevisionLabel],
0000000000000000000000000000000000000000;;							currentRevision))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sst.SortStatefulPods(pods)
0000000000000000000000000000000000000000;;				sst.BreakPodProbe(ss, &pods.Items[1], testProbe)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				ss, pods = sst.WaitForPodNotReady(ss, pods.Items[1].Name)
0000000000000000000000000000000000000000;;				newImage := NewNginxImage
0000000000000000000000000000000000000000;;				oldImage := ss.Spec.Template.Spec.Containers[0].Image
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Updating StatefulSet template: update image from %s to %s", oldImage, newImage))
0000000000000000000000000000000000000000;;				Expect(oldImage).NotTo(Equal(newImage), "Incorrect test setup: should update to a different image")
0000000000000000000000000000000000000000;;				ss, err = framework.UpdateStatefulSetWithRetries(c, ns, ss.Name, func(update *apps.StatefulSet) {
0000000000000000000000000000000000000000;;					update.Spec.Template.Spec.Containers[0].Image = newImage
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Creating a new revision")
0000000000000000000000000000000000000000;;				ss = sst.WaitForStatus(ss)
0000000000000000000000000000000000000000;;				currentRevision, updateRevision = ss.Status.CurrentRevision, ss.Status.UpdateRevision
0000000000000000000000000000000000000000;;				Expect(currentRevision).NotTo(Equal(updateRevision),
0000000000000000000000000000000000000000;;					"Current revision should not equal update revision during rolling update")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Updating Pods in reverse ordinal order")
0000000000000000000000000000000000000000;;				pods = sst.GetPodList(ss)
0000000000000000000000000000000000000000;;				sst.SortStatefulPods(pods)
0000000000000000000000000000000000000000;;				sst.RestorePodProbe(ss, &pods.Items[1], testProbe)
0000000000000000000000000000000000000000;;				ss, pods = sst.WaitForPodReady(ss, pods.Items[1].Name)
0000000000000000000000000000000000000000;;				ss, pods = sst.WaitForRollingUpdate(ss)
0000000000000000000000000000000000000000;;				Expect(ss.Status.CurrentRevision).To(Equal(updateRevision),
0000000000000000000000000000000000000000;;					fmt.Sprintf("StatefulSet %s/%s current revision %s does not equal updste revision %s on update completion",
0000000000000000000000000000000000000000;;						ss.Namespace,
0000000000000000000000000000000000000000;;						ss.Name,
0000000000000000000000000000000000000000;;						ss.Status.CurrentRevision,
0000000000000000000000000000000000000000;;						updateRevision))
0000000000000000000000000000000000000000;;				for i := range pods.Items {
0000000000000000000000000000000000000000;;					Expect(pods.Items[i].Spec.Containers[0].Image).To(Equal(newImage),
0000000000000000000000000000000000000000;;						fmt.Sprintf(" Pod %s/%s has image %s not have new image %s",
0000000000000000000000000000000000000000;;							pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;							pods.Items[i].Name,
0000000000000000000000000000000000000000;;							pods.Items[i].Spec.Containers[0].Image,
0000000000000000000000000000000000000000;;							newImage))
0000000000000000000000000000000000000000;;					Expect(pods.Items[i].Labels[apps.StatefulSetRevisionLabel]).To(Equal(updateRevision),
0000000000000000000000000000000000000000;;						fmt.Sprintf("Pod %s/%s revision %s is not equal to update revision %s",
0000000000000000000000000000000000000000;;							pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;							pods.Items[i].Name,
0000000000000000000000000000000000000000;;							pods.Items[i].Labels[apps.StatefulSetRevisionLabel],
0000000000000000000000000000000000000000;;							updateRevision))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Rolling back to a previous revision")
0000000000000000000000000000000000000000;;				sst.BreakPodProbe(ss, &pods.Items[1], testProbe)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				ss, pods = sst.WaitForPodNotReady(ss, pods.Items[1].Name)
0000000000000000000000000000000000000000;;				priorRevision := currentRevision
0000000000000000000000000000000000000000;;				currentRevision, updateRevision = ss.Status.CurrentRevision, ss.Status.UpdateRevision
0000000000000000000000000000000000000000;;				ss, err = framework.UpdateStatefulSetWithRetries(c, ns, ss.Name, func(update *apps.StatefulSet) {
0000000000000000000000000000000000000000;;					update.Spec.Template.Spec.Containers[0].Image = oldImage
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				ss = sst.WaitForStatus(ss)
0000000000000000000000000000000000000000;;				currentRevision, updateRevision = ss.Status.CurrentRevision, ss.Status.UpdateRevision
0000000000000000000000000000000000000000;;				Expect(currentRevision).NotTo(Equal(updateRevision),
0000000000000000000000000000000000000000;;					"Current revision should not equal update revision during roll bakc")
0000000000000000000000000000000000000000;;				Expect(priorRevision).To(Equal(updateRevision),
0000000000000000000000000000000000000000;;					"Prior revision should equal update revision during roll back")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Rolling back update in reverse ordinal order")
0000000000000000000000000000000000000000;;				pods = sst.GetPodList(ss)
0000000000000000000000000000000000000000;;				sst.SortStatefulPods(pods)
0000000000000000000000000000000000000000;;				sst.RestorePodProbe(ss, &pods.Items[1], testProbe)
0000000000000000000000000000000000000000;;				ss, pods = sst.WaitForPodReady(ss, pods.Items[1].Name)
0000000000000000000000000000000000000000;;				ss, pods = sst.WaitForRollingUpdate(ss)
0000000000000000000000000000000000000000;;				Expect(ss.Status.CurrentRevision).To(Equal(priorRevision),
0000000000000000000000000000000000000000;;					fmt.Sprintf("StatefulSet %s/%s current revision %s does not equal prior revision %s on rollback completion",
0000000000000000000000000000000000000000;;						ss.Namespace,
0000000000000000000000000000000000000000;;						ss.Name,
0000000000000000000000000000000000000000;;						ss.Status.CurrentRevision,
0000000000000000000000000000000000000000;;						updateRevision))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for i := range pods.Items {
0000000000000000000000000000000000000000;;					Expect(pods.Items[i].Spec.Containers[0].Image).To(Equal(oldImage),
0000000000000000000000000000000000000000;;						fmt.Sprintf("Pod %s/%s has image %s not equal to previous image %s",
0000000000000000000000000000000000000000;;							pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;							pods.Items[i].Name,
0000000000000000000000000000000000000000;;							pods.Items[i].Spec.Containers[0].Image,
0000000000000000000000000000000000000000;;							oldImage))
0000000000000000000000000000000000000000;;					Expect(pods.Items[i].Labels[apps.StatefulSetRevisionLabel]).To(Equal(priorRevision),
0000000000000000000000000000000000000000;;						fmt.Sprintf("Pod %s/%s revision %s is not equal to prior revision %s",
0000000000000000000000000000000000000000;;							pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;							pods.Items[i].Name,
0000000000000000000000000000000000000000;;							pods.Items[i].Labels[apps.StatefulSetRevisionLabel],
0000000000000000000000000000000000000000;;							priorRevision))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should perform canary updates and phased rolling updates of template modifications", func() {
0000000000000000000000000000000000000000;;				By("Creating a new StaefulSet")
0000000000000000000000000000000000000000;;				testProbe := &v1.Probe{Handler: v1.Handler{HTTPGet: &v1.HTTPGetAction{
0000000000000000000000000000000000000000;;					Path: "/index.html",
0000000000000000000000000000000000000000;;					Port: intstr.IntOrString{IntVal: 80}}}}
0000000000000000000000000000000000000000;;				ss := framework.NewStatefulSet("ss2", ns, headlessSvcName, 3, nil, nil, labels)
0000000000000000000000000000000000000000;;				ss.Spec.Template.Spec.Containers[0].ReadinessProbe = testProbe
0000000000000000000000000000000000000000;;				ss.Spec.UpdateStrategy = apps.StatefulSetUpdateStrategy{
0000000000000000000000000000000000000000;;					Type: apps.RollingUpdateStatefulSetStrategyType,
0000000000000000000000000000000000000000;;					RollingUpdate: func() *apps.RollingUpdateStatefulSetStrategy {
0000000000000000000000000000000000000000;;						return &apps.RollingUpdateStatefulSetStrategy{
0000000000000000000000000000000000000000;;							Partition: func() *int32 {
0000000000000000000000000000000000000000;;								i := int32(3)
0000000000000000000000000000000000000000;;								return &i
0000000000000000000000000000000000000000;;							}()}
0000000000000000000000000000000000000000;;					}(),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ss, err := c.Apps().StatefulSets(ns).Create(ss)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				sst := framework.NewStatefulSetTester(c)
0000000000000000000000000000000000000000;;				sst.WaitForRunningAndReady(*ss.Spec.Replicas, ss)
0000000000000000000000000000000000000000;;				ss = sst.WaitForStatus(ss)
0000000000000000000000000000000000000000;;				currentRevision, updateRevision := ss.Status.CurrentRevision, ss.Status.UpdateRevision
0000000000000000000000000000000000000000;;				Expect(currentRevision).To(Equal(updateRevision),
0000000000000000000000000000000000000000;;					fmt.Sprintf("StatefulSet %s/%s created with update revision %s not equal to current revision %s",
0000000000000000000000000000000000000000;;						ss.Namespace, ss.Name, updateRevision, currentRevision))
0000000000000000000000000000000000000000;;				pods := sst.GetPodList(ss)
0000000000000000000000000000000000000000;;				for i := range pods.Items {
0000000000000000000000000000000000000000;;					Expect(pods.Items[i].Labels[apps.StatefulSetRevisionLabel]).To(Equal(currentRevision),
0000000000000000000000000000000000000000;;						fmt.Sprintf("Pod %s/%s revision %s is not equal to currentRevision %s",
0000000000000000000000000000000000000000;;							pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;							pods.Items[i].Name,
0000000000000000000000000000000000000000;;							pods.Items[i].Labels[apps.StatefulSetRevisionLabel],
0000000000000000000000000000000000000000;;							currentRevision))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newImage := NewNginxImage
0000000000000000000000000000000000000000;;				oldImage := ss.Spec.Template.Spec.Containers[0].Image
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Updating stateful set template: update image from %s to %s", oldImage, newImage))
0000000000000000000000000000000000000000;;				Expect(oldImage).NotTo(Equal(newImage), "Incorrect test setup: should update to a different image")
0000000000000000000000000000000000000000;;				ss, err = framework.UpdateStatefulSetWithRetries(c, ns, ss.Name, func(update *apps.StatefulSet) {
0000000000000000000000000000000000000000;;					update.Spec.Template.Spec.Containers[0].Image = newImage
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Creating a new revision")
0000000000000000000000000000000000000000;;				ss = sst.WaitForStatus(ss)
0000000000000000000000000000000000000000;;				currentRevision, updateRevision = ss.Status.CurrentRevision, ss.Status.UpdateRevision
0000000000000000000000000000000000000000;;				Expect(currentRevision).NotTo(Equal(updateRevision),
0000000000000000000000000000000000000000;;					"Current revision should not equal update revision during rolling update")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Not applying an update when the partition is greater than the number of replicas")
0000000000000000000000000000000000000000;;				for i := range pods.Items {
0000000000000000000000000000000000000000;;					Expect(pods.Items[i].Spec.Containers[0].Image).To(Equal(oldImage),
0000000000000000000000000000000000000000;;						fmt.Sprintf("Pod %s/%s has image %s not equal to current image %s",
0000000000000000000000000000000000000000;;							pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;							pods.Items[i].Name,
0000000000000000000000000000000000000000;;							pods.Items[i].Spec.Containers[0].Image,
0000000000000000000000000000000000000000;;							oldImage))
0000000000000000000000000000000000000000;;					Expect(pods.Items[i].Labels[apps.StatefulSetRevisionLabel]).To(Equal(currentRevision),
0000000000000000000000000000000000000000;;						fmt.Sprintf("Pod %s/%s has revision %s not equal to current revision %s",
0000000000000000000000000000000000000000;;							pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;							pods.Items[i].Name,
0000000000000000000000000000000000000000;;							pods.Items[i].Labels[apps.StatefulSetRevisionLabel],
0000000000000000000000000000000000000000;;							currentRevision))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("By performing a canary update")
0000000000000000000000000000000000000000;;				ss.Spec.UpdateStrategy = apps.StatefulSetUpdateStrategy{
0000000000000000000000000000000000000000;;					Type: apps.RollingUpdateStatefulSetStrategyType,
0000000000000000000000000000000000000000;;					RollingUpdate: func() *apps.RollingUpdateStatefulSetStrategy {
0000000000000000000000000000000000000000;;						return &apps.RollingUpdateStatefulSetStrategy{
0000000000000000000000000000000000000000;;							Partition: func() *int32 {
0000000000000000000000000000000000000000;;								i := int32(2)
0000000000000000000000000000000000000000;;								return &i
0000000000000000000000000000000000000000;;							}()}
0000000000000000000000000000000000000000;;					}(),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ss, err = framework.UpdateStatefulSetWithRetries(c, ns, ss.Name, func(update *apps.StatefulSet) {
0000000000000000000000000000000000000000;;					update.Spec.UpdateStrategy = apps.StatefulSetUpdateStrategy{
0000000000000000000000000000000000000000;;						Type: apps.RollingUpdateStatefulSetStrategyType,
0000000000000000000000000000000000000000;;						RollingUpdate: func() *apps.RollingUpdateStatefulSetStrategy {
0000000000000000000000000000000000000000;;							return &apps.RollingUpdateStatefulSetStrategy{
0000000000000000000000000000000000000000;;								Partition: func() *int32 {
0000000000000000000000000000000000000000;;									i := int32(2)
0000000000000000000000000000000000000000;;									return &i
0000000000000000000000000000000000000000;;								}()}
0000000000000000000000000000000000000000;;						}(),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				ss, pods = sst.WaitForPartitionedRollingUpdate(ss)
0000000000000000000000000000000000000000;;				for i := range pods.Items {
0000000000000000000000000000000000000000;;					if i < int(*ss.Spec.UpdateStrategy.RollingUpdate.Partition) {
0000000000000000000000000000000000000000;;						Expect(pods.Items[i].Spec.Containers[0].Image).To(Equal(oldImage),
0000000000000000000000000000000000000000;;							fmt.Sprintf("Pod %s/%s has image %s not equal to current image %s",
0000000000000000000000000000000000000000;;								pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;								pods.Items[i].Name,
0000000000000000000000000000000000000000;;								pods.Items[i].Spec.Containers[0].Image,
0000000000000000000000000000000000000000;;								oldImage))
0000000000000000000000000000000000000000;;						Expect(pods.Items[i].Labels[apps.StatefulSetRevisionLabel]).To(Equal(currentRevision),
0000000000000000000000000000000000000000;;							fmt.Sprintf("Pod %s/%s has revision %s not equal to current revision %s",
0000000000000000000000000000000000000000;;								pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;								pods.Items[i].Name,
0000000000000000000000000000000000000000;;								pods.Items[i].Labels[apps.StatefulSetRevisionLabel],
0000000000000000000000000000000000000000;;								currentRevision))
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						Expect(pods.Items[i].Spec.Containers[0].Image).To(Equal(newImage),
0000000000000000000000000000000000000000;;							fmt.Sprintf("Pod %s/%s has image %s not equal to new image  %s",
0000000000000000000000000000000000000000;;								pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;								pods.Items[i].Name,
0000000000000000000000000000000000000000;;								pods.Items[i].Spec.Containers[0].Image,
0000000000000000000000000000000000000000;;								newImage))
0000000000000000000000000000000000000000;;						Expect(pods.Items[i].Labels[apps.StatefulSetRevisionLabel]).To(Equal(updateRevision),
0000000000000000000000000000000000000000;;							fmt.Sprintf("Pod %s/%s has revision %s not equal to new revision %s",
0000000000000000000000000000000000000000;;								pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;								pods.Items[i].Name,
0000000000000000000000000000000000000000;;								pods.Items[i].Labels[apps.StatefulSetRevisionLabel],
0000000000000000000000000000000000000000;;								updateRevision))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Restoring Pods to the correct revision when they are deleted")
0000000000000000000000000000000000000000;;				sst.DeleteStatefulPodAtIndex(0, ss)
0000000000000000000000000000000000000000;;				sst.DeleteStatefulPodAtIndex(2, ss)
0000000000000000000000000000000000000000;;				sst.WaitForRunningAndReady(3, ss)
0000000000000000000000000000000000000000;;				ss = sst.GetStatefulSet(ss.Namespace, ss.Name)
0000000000000000000000000000000000000000;;				pods = sst.GetPodList(ss)
0000000000000000000000000000000000000000;;				for i := range pods.Items {
0000000000000000000000000000000000000000;;					if i < int(*ss.Spec.UpdateStrategy.RollingUpdate.Partition) {
0000000000000000000000000000000000000000;;						Expect(pods.Items[i].Spec.Containers[0].Image).To(Equal(oldImage),
0000000000000000000000000000000000000000;;							fmt.Sprintf("Pod %s/%s has image %s not equal to current image %s",
0000000000000000000000000000000000000000;;								pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;								pods.Items[i].Name,
0000000000000000000000000000000000000000;;								pods.Items[i].Spec.Containers[0].Image,
0000000000000000000000000000000000000000;;								oldImage))
0000000000000000000000000000000000000000;;						Expect(pods.Items[i].Labels[apps.StatefulSetRevisionLabel]).To(Equal(currentRevision),
0000000000000000000000000000000000000000;;							fmt.Sprintf("Pod %s/%s has revision %s not equal to current revision %s",
0000000000000000000000000000000000000000;;								pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;								pods.Items[i].Name,
0000000000000000000000000000000000000000;;								pods.Items[i].Labels[apps.StatefulSetRevisionLabel],
0000000000000000000000000000000000000000;;								currentRevision))
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						Expect(pods.Items[i].Spec.Containers[0].Image).To(Equal(newImage),
0000000000000000000000000000000000000000;;							fmt.Sprintf("Pod %s/%s has image %s not equal to new image  %s",
0000000000000000000000000000000000000000;;								pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;								pods.Items[i].Name,
0000000000000000000000000000000000000000;;								pods.Items[i].Spec.Containers[0].Image,
0000000000000000000000000000000000000000;;								newImage))
0000000000000000000000000000000000000000;;						Expect(pods.Items[i].Labels[apps.StatefulSetRevisionLabel]).To(Equal(updateRevision),
0000000000000000000000000000000000000000;;							fmt.Sprintf("Pod %s/%s has revision %s not equal to new revision %s",
0000000000000000000000000000000000000000;;								pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;								pods.Items[i].Name,
0000000000000000000000000000000000000000;;								pods.Items[i].Labels[apps.StatefulSetRevisionLabel],
0000000000000000000000000000000000000000;;								updateRevision))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Performing a phased rolling update")
0000000000000000000000000000000000000000;;				for i := int(*ss.Spec.UpdateStrategy.RollingUpdate.Partition) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;					ss, err = framework.UpdateStatefulSetWithRetries(c, ns, ss.Name, func(update *apps.StatefulSet) {
0000000000000000000000000000000000000000;;						update.Spec.UpdateStrategy = apps.StatefulSetUpdateStrategy{
0000000000000000000000000000000000000000;;							Type: apps.RollingUpdateStatefulSetStrategyType,
0000000000000000000000000000000000000000;;							RollingUpdate: func() *apps.RollingUpdateStatefulSetStrategy {
0000000000000000000000000000000000000000;;								j := int32(i)
0000000000000000000000000000000000000000;;								return &apps.RollingUpdateStatefulSetStrategy{
0000000000000000000000000000000000000000;;									Partition: &j,
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}(),
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					ss, pods = sst.WaitForPartitionedRollingUpdate(ss)
0000000000000000000000000000000000000000;;					for i := range pods.Items {
0000000000000000000000000000000000000000;;						if i < int(*ss.Spec.UpdateStrategy.RollingUpdate.Partition) {
0000000000000000000000000000000000000000;;							Expect(pods.Items[i].Spec.Containers[0].Image).To(Equal(oldImage),
0000000000000000000000000000000000000000;;								fmt.Sprintf("Pod %s/%s has image %s not equal to current image %s",
0000000000000000000000000000000000000000;;									pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;									pods.Items[i].Name,
0000000000000000000000000000000000000000;;									pods.Items[i].Spec.Containers[0].Image,
0000000000000000000000000000000000000000;;									oldImage))
0000000000000000000000000000000000000000;;							Expect(pods.Items[i].Labels[apps.StatefulSetRevisionLabel]).To(Equal(currentRevision),
0000000000000000000000000000000000000000;;								fmt.Sprintf("Pod %s/%s has revision %s not equal to current revision %s",
0000000000000000000000000000000000000000;;									pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;									pods.Items[i].Name,
0000000000000000000000000000000000000000;;									pods.Items[i].Labels[apps.StatefulSetRevisionLabel],
0000000000000000000000000000000000000000;;									currentRevision))
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							Expect(pods.Items[i].Spec.Containers[0].Image).To(Equal(newImage),
0000000000000000000000000000000000000000;;								fmt.Sprintf("Pod %s/%s has image %s not equal to new image  %s",
0000000000000000000000000000000000000000;;									pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;									pods.Items[i].Name,
0000000000000000000000000000000000000000;;									pods.Items[i].Spec.Containers[0].Image,
0000000000000000000000000000000000000000;;									newImage))
0000000000000000000000000000000000000000;;							Expect(pods.Items[i].Labels[apps.StatefulSetRevisionLabel]).To(Equal(updateRevision),
0000000000000000000000000000000000000000;;								fmt.Sprintf("Pod %s/%s has revision %s not equal to new revision %s",
0000000000000000000000000000000000000000;;									pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;									pods.Items[i].Name,
0000000000000000000000000000000000000000;;									pods.Items[i].Labels[apps.StatefulSetRevisionLabel],
0000000000000000000000000000000000000000;;									updateRevision))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				Expect(ss.Status.CurrentRevision).To(Equal(updateRevision),
0000000000000000000000000000000000000000;;					fmt.Sprintf("StatefulSet %s/%s current revision %s does not equal update revison %s on update completion",
0000000000000000000000000000000000000000;;						ss.Namespace,
0000000000000000000000000000000000000000;;						ss.Name,
0000000000000000000000000000000000000000;;						ss.Status.CurrentRevision,
0000000000000000000000000000000000000000;;						updateRevision))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should implement legacy replacement when the update strategy is OnDelete", func() {
0000000000000000000000000000000000000000;;				By("Creating a new StatefulSet")
0000000000000000000000000000000000000000;;				testProbe := &v1.Probe{Handler: v1.Handler{HTTPGet: &v1.HTTPGetAction{
0000000000000000000000000000000000000000;;					Path: "/index.html",
0000000000000000000000000000000000000000;;					Port: intstr.IntOrString{IntVal: 80}}}}
0000000000000000000000000000000000000000;;				ss := framework.NewStatefulSet("ss2", ns, headlessSvcName, 3, nil, nil, labels)
0000000000000000000000000000000000000000;;				ss.Spec.Template.Spec.Containers[0].ReadinessProbe = testProbe
0000000000000000000000000000000000000000;;				ss.Spec.UpdateStrategy = apps.StatefulSetUpdateStrategy{
0000000000000000000000000000000000000000;;					Type: apps.OnDeleteStatefulSetStrategyType,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ss, err := c.Apps().StatefulSets(ns).Create(ss)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				sst := framework.NewStatefulSetTester(c)
0000000000000000000000000000000000000000;;				sst.WaitForRunningAndReady(*ss.Spec.Replicas, ss)
0000000000000000000000000000000000000000;;				ss = sst.WaitForStatus(ss)
0000000000000000000000000000000000000000;;				currentRevision, updateRevision := ss.Status.CurrentRevision, ss.Status.UpdateRevision
0000000000000000000000000000000000000000;;				Expect(currentRevision).To(Equal(updateRevision),
0000000000000000000000000000000000000000;;					fmt.Sprintf("StatefulSet %s/%s created with update revision %s not equal to current revision %s",
0000000000000000000000000000000000000000;;						ss.Namespace, ss.Name, updateRevision, currentRevision))
0000000000000000000000000000000000000000;;				pods := sst.GetPodList(ss)
0000000000000000000000000000000000000000;;				for i := range pods.Items {
0000000000000000000000000000000000000000;;					Expect(pods.Items[i].Labels[apps.StatefulSetRevisionLabel]).To(Equal(currentRevision),
0000000000000000000000000000000000000000;;						fmt.Sprintf("Pod %s/%s revision %s is not equal to current revision %s",
0000000000000000000000000000000000000000;;							pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;							pods.Items[i].Name,
0000000000000000000000000000000000000000;;							pods.Items[i].Labels[apps.StatefulSetRevisionLabel],
0000000000000000000000000000000000000000;;							currentRevision))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Restoring Pods to the current revision")
0000000000000000000000000000000000000000;;				sst.DeleteStatefulPodAtIndex(0, ss)
0000000000000000000000000000000000000000;;				sst.DeleteStatefulPodAtIndex(1, ss)
0000000000000000000000000000000000000000;;				sst.DeleteStatefulPodAtIndex(2, ss)
0000000000000000000000000000000000000000;;				sst.WaitForRunningAndReady(3, ss)
0000000000000000000000000000000000000000;;				ss = sst.GetStatefulSet(ss.Namespace, ss.Name)
0000000000000000000000000000000000000000;;				pods = sst.GetPodList(ss)
0000000000000000000000000000000000000000;;				for i := range pods.Items {
0000000000000000000000000000000000000000;;					Expect(pods.Items[i].Labels[apps.StatefulSetRevisionLabel]).To(Equal(currentRevision),
0000000000000000000000000000000000000000;;						fmt.Sprintf("Pod %s/%s revision %s is not equal to current revision %s",
0000000000000000000000000000000000000000;;							pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;							pods.Items[i].Name,
0000000000000000000000000000000000000000;;							pods.Items[i].Labels[apps.StatefulSetRevisionLabel],
0000000000000000000000000000000000000000;;							currentRevision))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newImage := NewNginxImage
0000000000000000000000000000000000000000;;				oldImage := ss.Spec.Template.Spec.Containers[0].Image
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Updating stateful set template: update image from %s to %s", oldImage, newImage))
0000000000000000000000000000000000000000;;				Expect(oldImage).NotTo(Equal(newImage), "Incorrect test setup: should update to a different image")
0000000000000000000000000000000000000000;;				ss, err = framework.UpdateStatefulSetWithRetries(c, ns, ss.Name, func(update *apps.StatefulSet) {
0000000000000000000000000000000000000000;;					update.Spec.Template.Spec.Containers[0].Image = newImage
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Creating a new revision")
0000000000000000000000000000000000000000;;				ss = sst.WaitForStatus(ss)
0000000000000000000000000000000000000000;;				currentRevision, updateRevision = ss.Status.CurrentRevision, ss.Status.UpdateRevision
0000000000000000000000000000000000000000;;				Expect(currentRevision).NotTo(Equal(updateRevision),
0000000000000000000000000000000000000000;;					"Current revision should not equal update revision during rolling update")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Recreating Pods at the new revision")
0000000000000000000000000000000000000000;;				sst.DeleteStatefulPodAtIndex(0, ss)
0000000000000000000000000000000000000000;;				sst.DeleteStatefulPodAtIndex(1, ss)
0000000000000000000000000000000000000000;;				sst.DeleteStatefulPodAtIndex(2, ss)
0000000000000000000000000000000000000000;;				sst.WaitForRunningAndReady(3, ss)
0000000000000000000000000000000000000000;;				ss = sst.GetStatefulSet(ss.Namespace, ss.Name)
0000000000000000000000000000000000000000;;				pods = sst.GetPodList(ss)
0000000000000000000000000000000000000000;;				for i := range pods.Items {
0000000000000000000000000000000000000000;;					Expect(pods.Items[i].Spec.Containers[0].Image).To(Equal(newImage),
0000000000000000000000000000000000000000;;						fmt.Sprintf("Pod %s/%s has image %s not equal to new image %s",
0000000000000000000000000000000000000000;;							pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;							pods.Items[i].Name,
0000000000000000000000000000000000000000;;							pods.Items[i].Spec.Containers[0].Image,
0000000000000000000000000000000000000000;;							newImage))
0000000000000000000000000000000000000000;;					Expect(pods.Items[i].Labels[apps.StatefulSetRevisionLabel]).To(Equal(updateRevision),
0000000000000000000000000000000000000000;;						fmt.Sprintf("Pod %s/%s has revision %s not equal to current revision %s",
0000000000000000000000000000000000000000;;							pods.Items[i].Namespace,
0000000000000000000000000000000000000000;;							pods.Items[i].Name,
0000000000000000000000000000000000000000;;							pods.Items[i].Labels[apps.StatefulSetRevisionLabel],
0000000000000000000000000000000000000000;;							updateRevision))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("Scaling should happen in predictable order and halt if any stateful pod is unhealthy", func() {
0000000000000000000000000000000000000000;;				psLabels := klabels.Set(labels)
0000000000000000000000000000000000000000;;				By("Initializing watcher for selector " + psLabels.String())
0000000000000000000000000000000000000000;;				watcher, err := f.ClientSet.Core().Pods(ns).Watch(metav1.ListOptions{
0000000000000000000000000000000000000000;;					LabelSelector: psLabels.AsSelector().String(),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Creating stateful set " + ssName + " in namespace " + ns)
0000000000000000000000000000000000000000;;				testProbe := &v1.Probe{Handler: v1.Handler{HTTPGet: &v1.HTTPGetAction{
0000000000000000000000000000000000000000;;					Path: "/index.html",
0000000000000000000000000000000000000000;;					Port: intstr.IntOrString{IntVal: 80}}}}
0000000000000000000000000000000000000000;;				ss := framework.NewStatefulSet(ssName, ns, headlessSvcName, 1, nil, nil, psLabels)
0000000000000000000000000000000000000000;;				ss.Spec.Template.Spec.Containers[0].ReadinessProbe = testProbe
0000000000000000000000000000000000000000;;				ss, err = c.Apps().StatefulSets(ns).Create(ss)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Waiting until all stateful set " + ssName + " replicas will be running in namespace " + ns)
0000000000000000000000000000000000000000;;				sst := framework.NewStatefulSetTester(c)
0000000000000000000000000000000000000000;;				sst.WaitForRunningAndReady(*ss.Spec.Replicas, ss)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Confirming that stateful set scale up will halt with unhealthy stateful pod")
0000000000000000000000000000000000000000;;				sst.BreakProbe(ss, testProbe)
0000000000000000000000000000000000000000;;				sst.WaitForRunningAndNotReady(*ss.Spec.Replicas, ss)
0000000000000000000000000000000000000000;;				sst.WaitForStatusReadyReplicas(ss, 0)
0000000000000000000000000000000000000000;;				sst.UpdateReplicas(ss, 3)
0000000000000000000000000000000000000000;;				sst.ConfirmStatefulPodCount(1, ss, 10*time.Second, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Scaling up stateful set " + ssName + " to 3 replicas and waiting until all of them will be running in namespace " + ns)
0000000000000000000000000000000000000000;;				sst.RestoreProbe(ss, testProbe)
0000000000000000000000000000000000000000;;				sst.WaitForRunningAndReady(3, ss)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Verifying that stateful set " + ssName + " was scaled up in order")
0000000000000000000000000000000000000000;;				expectedOrder := []string{ssName + "-0", ssName + "-1", ssName + "-2"}
0000000000000000000000000000000000000000;;				_, err = watch.Until(framework.StatefulSetTimeout, watcher, func(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;					if event.Type != watch.Added {
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					pod := event.Object.(*v1.Pod)
0000000000000000000000000000000000000000;;					if pod.Name == expectedOrder[0] {
0000000000000000000000000000000000000000;;						expectedOrder = expectedOrder[1:]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return len(expectedOrder) == 0, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Scale down will halt with unhealthy stateful pod")
0000000000000000000000000000000000000000;;				watcher, err = f.ClientSet.Core().Pods(ns).Watch(metav1.ListOptions{
0000000000000000000000000000000000000000;;					LabelSelector: psLabels.AsSelector().String(),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				sst.BreakProbe(ss, testProbe)
0000000000000000000000000000000000000000;;				sst.WaitForStatusReadyReplicas(ss, 0)
0000000000000000000000000000000000000000;;				sst.WaitForRunningAndNotReady(3, ss)
0000000000000000000000000000000000000000;;				sst.UpdateReplicas(ss, 0)
0000000000000000000000000000000000000000;;				sst.ConfirmStatefulPodCount(3, ss, 10*time.Second, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Scaling down stateful set " + ssName + " to 0 replicas and waiting until none of pods will run in namespace" + ns)
0000000000000000000000000000000000000000;;				sst.RestoreProbe(ss, testProbe)
0000000000000000000000000000000000000000;;				sst.Scale(ss, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Verifying that stateful set " + ssName + " was scaled down in reverse order")
0000000000000000000000000000000000000000;;				expectedOrder = []string{ssName + "-2", ssName + "-1", ssName + "-0"}
0000000000000000000000000000000000000000;;				_, err = watch.Until(framework.StatefulSetTimeout, watcher, func(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;					if event.Type != watch.Deleted {
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					pod := event.Object.(*v1.Pod)
0000000000000000000000000000000000000000;;					if pod.Name == expectedOrder[0] {
0000000000000000000000000000000000000000;;						expectedOrder = expectedOrder[1:]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return len(expectedOrder) == 0, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("Burst scaling should run to completion even with unhealthy pods", func() {
0000000000000000000000000000000000000000;;				psLabels := klabels.Set(labels)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Creating stateful set " + ssName + " in namespace " + ns)
0000000000000000000000000000000000000000;;				testProbe := &v1.Probe{Handler: v1.Handler{HTTPGet: &v1.HTTPGetAction{
0000000000000000000000000000000000000000;;					Path: "/index.html",
0000000000000000000000000000000000000000;;					Port: intstr.IntOrString{IntVal: 80}}}}
0000000000000000000000000000000000000000;;				ss := framework.NewStatefulSet(ssName, ns, headlessSvcName, 1, nil, nil, psLabels)
0000000000000000000000000000000000000000;;				ss.Spec.PodManagementPolicy = apps.ParallelPodManagement
0000000000000000000000000000000000000000;;				ss.Spec.Template.Spec.Containers[0].ReadinessProbe = testProbe
0000000000000000000000000000000000000000;;				ss, err := c.Apps().StatefulSets(ns).Create(ss)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Waiting until all stateful set " + ssName + " replicas will be running in namespace " + ns)
0000000000000000000000000000000000000000;;				sst := framework.NewStatefulSetTester(c)
0000000000000000000000000000000000000000;;				sst.WaitForRunningAndReady(*ss.Spec.Replicas, ss)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Confirming that stateful set scale up will not halt with unhealthy stateful pod")
0000000000000000000000000000000000000000;;				sst.BreakProbe(ss, testProbe)
0000000000000000000000000000000000000000;;				sst.WaitForRunningAndNotReady(*ss.Spec.Replicas, ss)
0000000000000000000000000000000000000000;;				sst.WaitForStatusReadyReplicas(ss, 0)
0000000000000000000000000000000000000000;;				sst.UpdateReplicas(ss, 3)
0000000000000000000000000000000000000000;;				sst.ConfirmStatefulPodCount(3, ss, 10*time.Second, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Scaling up stateful set " + ssName + " to 3 replicas and waiting until all of them will be running in namespace " + ns)
0000000000000000000000000000000000000000;;				sst.RestoreProbe(ss, testProbe)
0000000000000000000000000000000000000000;;				sst.WaitForRunningAndReady(3, ss)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Scale down will not halt with unhealthy stateful pod")
0000000000000000000000000000000000000000;;				sst.BreakProbe(ss, testProbe)
0000000000000000000000000000000000000000;;				sst.WaitForStatusReadyReplicas(ss, 0)
0000000000000000000000000000000000000000;;				sst.WaitForRunningAndNotReady(3, ss)
0000000000000000000000000000000000000000;;				sst.UpdateReplicas(ss, 0)
0000000000000000000000000000000000000000;;				sst.ConfirmStatefulPodCount(0, ss, 10*time.Second, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Scaling down stateful set " + ssName + " to 0 replicas and waiting until none of pods will run in namespace" + ns)
0000000000000000000000000000000000000000;;				sst.RestoreProbe(ss, testProbe)
0000000000000000000000000000000000000000;;				sst.Scale(ss, 0)
0000000000000000000000000000000000000000;;				sst.WaitForStatusReadyReplicas(ss, 0)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("Should recreate evicted statefulset", func() {
0000000000000000000000000000000000000000;;				podName := "test-pod"
0000000000000000000000000000000000000000;;				statefulPodName := ssName + "-0"
0000000000000000000000000000000000000000;;				By("Looking for a node to schedule stateful set and pod")
0000000000000000000000000000000000000000;;				nodes := framework.GetReadySchedulableNodesOrDie(f.ClientSet)
0000000000000000000000000000000000000000;;				node := nodes.Items[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Creating pod with conflicting port in namespace " + f.Namespace.Name)
0000000000000000000000000000000000000000;;				conflictingPort := v1.ContainerPort{HostPort: 21017, ContainerPort: 21017, Name: "conflict"}
0000000000000000000000000000000000000000;;				pod := &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: podName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "nginx",
0000000000000000000000000000000000000000;;								Image: "gcr.io/google_containers/nginx-slim:0.7",
0000000000000000000000000000000000000000;;								Ports: []v1.ContainerPort{conflictingPort},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						NodeName: node.Name,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pod, err := f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Creating statefulset with conflicting port in namespace " + f.Namespace.Name)
0000000000000000000000000000000000000000;;				ss := framework.NewStatefulSet(ssName, f.Namespace.Name, headlessSvcName, 1, nil, nil, labels)
0000000000000000000000000000000000000000;;				statefulPodContainer := &ss.Spec.Template.Spec.Containers[0]
0000000000000000000000000000000000000000;;				statefulPodContainer.Ports = append(statefulPodContainer.Ports, conflictingPort)
0000000000000000000000000000000000000000;;				ss.Spec.Template.Spec.NodeName = node.Name
0000000000000000000000000000000000000000;;				_, err = f.ClientSet.Apps().StatefulSets(f.Namespace.Name).Create(ss)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Waiting until pod " + podName + " will start running in namespace " + f.Namespace.Name)
0000000000000000000000000000000000000000;;				if err := f.WaitForPodRunning(podName); err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Pod %v did not start running: %v", podName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var initialStatefulPodUID types.UID
0000000000000000000000000000000000000000;;				By("Waiting until stateful pod " + statefulPodName + " will be recreated and deleted at least once in namespace " + f.Namespace.Name)
0000000000000000000000000000000000000000;;				w, err := f.ClientSet.Core().Pods(f.Namespace.Name).Watch(metav1.SingleObject(metav1.ObjectMeta{Name: statefulPodName}))
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;				// we need to get UID from pod in any state and wait until stateful set controller will remove pod atleast once
0000000000000000000000000000000000000000;;				_, err = watch.Until(framework.StatefulPodTimeout, w, func(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;					pod := event.Object.(*v1.Pod)
0000000000000000000000000000000000000000;;					switch event.Type {
0000000000000000000000000000000000000000;;					case watch.Deleted:
0000000000000000000000000000000000000000;;						framework.Logf("Observed delete event for stateful pod %v in namespace %v", pod.Name, pod.Namespace)
0000000000000000000000000000000000000000;;						if initialStatefulPodUID == "" {
0000000000000000000000000000000000000000;;							return false, nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return true, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					framework.Logf("Observed stateful pod in namespace: %v, name: %v, uid: %v, status phase: %v. Waiting for statefulset controller to delete.",
0000000000000000000000000000000000000000;;						pod.Namespace, pod.Name, pod.UID, pod.Status.Phase)
0000000000000000000000000000000000000000;;					initialStatefulPodUID = pod.UID
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Pod %v expected to be re-created at least once", statefulPodName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Removing pod with conflicting port in namespace " + f.Namespace.Name)
0000000000000000000000000000000000000000;;				err = f.ClientSet.Core().Pods(f.Namespace.Name).Delete(pod.Name, metav1.NewDeleteOptions(0))
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Waiting when stateful pod " + statefulPodName + " will be recreated in namespace " + f.Namespace.Name + " and will be in running state")
0000000000000000000000000000000000000000;;				// we may catch delete event, thats why we are waiting for running phase like this, and not with watch.Until
0000000000000000000000000000000000000000;;				Eventually(func() error {
0000000000000000000000000000000000000000;;					statefulPod, err := f.ClientSet.Core().Pods(f.Namespace.Name).Get(statefulPodName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if statefulPod.Status.Phase != v1.PodRunning {
0000000000000000000000000000000000000000;;						return fmt.Errorf("Pod %v is not in running phase: %v", statefulPod.Name, statefulPod.Status.Phase)
0000000000000000000000000000000000000000;;					} else if statefulPod.UID == initialStatefulPodUID {
0000000000000000000000000000000000000000;;						return fmt.Errorf("Pod %v wasn't recreated: %v == %v", statefulPod.Name, statefulPod.UID, initialStatefulPodUID)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}, framework.StatefulPodTimeout, 2*time.Second).Should(BeNil())
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Deploy clustered applications [Feature:StatefulSet] [Slow]", func() {
0000000000000000000000000000000000000000;;			var sst *framework.StatefulSetTester
0000000000000000000000000000000000000000;;			var appTester *clusterAppTester
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				sst = framework.NewStatefulSetTester(c)
0000000000000000000000000000000000000000;;				appTester = &clusterAppTester{tester: sst, ns: ns}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				if CurrentGinkgoTestDescription().Failed {
0000000000000000000000000000000000000000;;					framework.DumpDebugInfo(c, ns)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.Logf("Deleting all statefulset in ns %v", ns)
0000000000000000000000000000000000000000;;				framework.DeleteAllStatefulSets(c, ns)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should creating a working zookeeper cluster", func() {
0000000000000000000000000000000000000000;;				appTester.statefulPod = &zookeeperTester{tester: sst}
0000000000000000000000000000000000000000;;				appTester.run()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should creating a working redis cluster", func() {
0000000000000000000000000000000000000000;;				appTester.statefulPod = &redisTester{tester: sst}
0000000000000000000000000000000000000000;;				appTester.run()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should creating a working mysql cluster", func() {
0000000000000000000000000000000000000000;;				appTester.statefulPod = &mysqlGaleraTester{tester: sst}
0000000000000000000000000000000000000000;;				appTester.run()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should creating a working CockroachDB cluster", func() {
0000000000000000000000000000000000000000;;				appTester.statefulPod = &cockroachDBTester{tester: sst}
0000000000000000000000000000000000000000;;				appTester.run()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func kubectlExecWithRetries(args ...string) (out string) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for i := 0; i < 3; i++ {
0000000000000000000000000000000000000000;;			if out, err = framework.RunKubectl(args...); err == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.Logf("Retrying %v:\nerror %v\nstdout %v", args, err, out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.Failf("Failed to execute \"%v\" with retries: %v", args, err)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type statefulPodTester interface {
0000000000000000000000000000000000000000;;		deploy(ns string) *apps.StatefulSet
0000000000000000000000000000000000000000;;		write(statefulPodIndex int, kv map[string]string)
0000000000000000000000000000000000000000;;		read(statefulPodIndex int, key string) string
0000000000000000000000000000000000000000;;		name() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type clusterAppTester struct {
0000000000000000000000000000000000000000;;		ns          string
0000000000000000000000000000000000000000;;		statefulPod statefulPodTester
0000000000000000000000000000000000000000;;		tester      *framework.StatefulSetTester
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *clusterAppTester) run() {
0000000000000000000000000000000000000000;;		By("Deploying " + c.statefulPod.name())
0000000000000000000000000000000000000000;;		ss := c.statefulPod.deploy(c.ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating foo:bar in member with index 0")
0000000000000000000000000000000000000000;;		c.statefulPod.write(0, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch c.statefulPod.(type) {
0000000000000000000000000000000000000000;;		case *mysqlGaleraTester:
0000000000000000000000000000000000000000;;			// Don't restart MySQL cluster since it doesn't handle restarts well
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if restartCluster {
0000000000000000000000000000000000000000;;				By("Restarting stateful set " + ss.Name)
0000000000000000000000000000000000000000;;				c.tester.Restart(ss)
0000000000000000000000000000000000000000;;				c.tester.WaitForRunningAndReady(*ss.Spec.Replicas, ss)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Reading value under foo from member with index 2")
0000000000000000000000000000000000000000;;		if err := pollReadWithTimeout(c.statefulPod, 2, "foo", "bar"); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type zookeeperTester struct {
0000000000000000000000000000000000000000;;		ss     *apps.StatefulSet
0000000000000000000000000000000000000000;;		tester *framework.StatefulSetTester
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *zookeeperTester) name() string {
0000000000000000000000000000000000000000;;		return "zookeeper"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *zookeeperTester) deploy(ns string) *apps.StatefulSet {
0000000000000000000000000000000000000000;;		z.ss = z.tester.CreateStatefulSet(zookeeperManifestPath, ns)
0000000000000000000000000000000000000000;;		return z.ss
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *zookeeperTester) write(statefulPodIndex int, kv map[string]string) {
0000000000000000000000000000000000000000;;		name := fmt.Sprintf("%v-%d", z.ss.Name, statefulPodIndex)
0000000000000000000000000000000000000000;;		ns := fmt.Sprintf("--namespace=%v", z.ss.Namespace)
0000000000000000000000000000000000000000;;		for k, v := range kv {
0000000000000000000000000000000000000000;;			cmd := fmt.Sprintf("/opt/zookeeper/bin/zkCli.sh create /%v %v", k, v)
0000000000000000000000000000000000000000;;			framework.Logf(framework.RunKubectlOrDie("exec", ns, name, "--", "/bin/sh", "-c", cmd))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *zookeeperTester) read(statefulPodIndex int, key string) string {
0000000000000000000000000000000000000000;;		name := fmt.Sprintf("%v-%d", z.ss.Name, statefulPodIndex)
0000000000000000000000000000000000000000;;		ns := fmt.Sprintf("--namespace=%v", z.ss.Namespace)
0000000000000000000000000000000000000000;;		cmd := fmt.Sprintf("/opt/zookeeper/bin/zkCli.sh get /%v", key)
0000000000000000000000000000000000000000;;		return lastLine(framework.RunKubectlOrDie("exec", ns, name, "--", "/bin/sh", "-c", cmd))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mysqlGaleraTester struct {
0000000000000000000000000000000000000000;;		ss     *apps.StatefulSet
0000000000000000000000000000000000000000;;		tester *framework.StatefulSetTester
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *mysqlGaleraTester) name() string {
0000000000000000000000000000000000000000;;		return "mysql: galera"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *mysqlGaleraTester) mysqlExec(cmd, ns, podName string) string {
0000000000000000000000000000000000000000;;		cmd = fmt.Sprintf("/usr/bin/mysql -u root -B -e '%v'", cmd)
0000000000000000000000000000000000000000;;		// TODO: Find a readiness probe for mysql that guarantees writes will
0000000000000000000000000000000000000000;;		// succeed and ditch retries. Current probe only reads, so there's a window
0000000000000000000000000000000000000000;;		// for a race.
0000000000000000000000000000000000000000;;		return kubectlExecWithRetries(fmt.Sprintf("--namespace=%v", ns), "exec", podName, "--", "/bin/sh", "-c", cmd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *mysqlGaleraTester) deploy(ns string) *apps.StatefulSet {
0000000000000000000000000000000000000000;;		m.ss = m.tester.CreateStatefulSet(mysqlGaleraManifestPath, ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Deployed statefulset %v, initializing database", m.ss.Name)
0000000000000000000000000000000000000000;;		for _, cmd := range []string{
0000000000000000000000000000000000000000;;			"create database statefulset;",
0000000000000000000000000000000000000000;;			"use statefulset; create table foo (k varchar(20), v varchar(20));",
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			framework.Logf(m.mysqlExec(cmd, ns, fmt.Sprintf("%v-0", m.ss.Name)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m.ss
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *mysqlGaleraTester) write(statefulPodIndex int, kv map[string]string) {
0000000000000000000000000000000000000000;;		name := fmt.Sprintf("%v-%d", m.ss.Name, statefulPodIndex)
0000000000000000000000000000000000000000;;		for k, v := range kv {
0000000000000000000000000000000000000000;;			cmd := fmt.Sprintf("use  statefulset; insert into foo (k, v) values (\"%v\", \"%v\");", k, v)
0000000000000000000000000000000000000000;;			framework.Logf(m.mysqlExec(cmd, m.ss.Namespace, name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *mysqlGaleraTester) read(statefulPodIndex int, key string) string {
0000000000000000000000000000000000000000;;		name := fmt.Sprintf("%v-%d", m.ss.Name, statefulPodIndex)
0000000000000000000000000000000000000000;;		return lastLine(m.mysqlExec(fmt.Sprintf("use statefulset; select v from foo where k=\"%v\";", key), m.ss.Namespace, name))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type redisTester struct {
0000000000000000000000000000000000000000;;		ss     *apps.StatefulSet
0000000000000000000000000000000000000000;;		tester *framework.StatefulSetTester
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *redisTester) name() string {
0000000000000000000000000000000000000000;;		return "redis: master/slave"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *redisTester) redisExec(cmd, ns, podName string) string {
0000000000000000000000000000000000000000;;		cmd = fmt.Sprintf("/opt/redis/redis-cli -h %v %v", podName, cmd)
0000000000000000000000000000000000000000;;		return framework.RunKubectlOrDie(fmt.Sprintf("--namespace=%v", ns), "exec", podName, "--", "/bin/sh", "-c", cmd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *redisTester) deploy(ns string) *apps.StatefulSet {
0000000000000000000000000000000000000000;;		m.ss = m.tester.CreateStatefulSet(redisManifestPath, ns)
0000000000000000000000000000000000000000;;		return m.ss
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *redisTester) write(statefulPodIndex int, kv map[string]string) {
0000000000000000000000000000000000000000;;		name := fmt.Sprintf("%v-%d", m.ss.Name, statefulPodIndex)
0000000000000000000000000000000000000000;;		for k, v := range kv {
0000000000000000000000000000000000000000;;			framework.Logf(m.redisExec(fmt.Sprintf("SET %v %v", k, v), m.ss.Namespace, name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *redisTester) read(statefulPodIndex int, key string) string {
0000000000000000000000000000000000000000;;		name := fmt.Sprintf("%v-%d", m.ss.Name, statefulPodIndex)
0000000000000000000000000000000000000000;;		return lastLine(m.redisExec(fmt.Sprintf("GET %v", key), m.ss.Namespace, name))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cockroachDBTester struct {
0000000000000000000000000000000000000000;;		ss     *apps.StatefulSet
0000000000000000000000000000000000000000;;		tester *framework.StatefulSetTester
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cockroachDBTester) name() string {
0000000000000000000000000000000000000000;;		return "CockroachDB"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cockroachDBTester) cockroachDBExec(cmd, ns, podName string) string {
0000000000000000000000000000000000000000;;		cmd = fmt.Sprintf("/cockroach/cockroach sql --insecure --host %s.cockroachdb -e \"%v\"", podName, cmd)
0000000000000000000000000000000000000000;;		return framework.RunKubectlOrDie(fmt.Sprintf("--namespace=%v", ns), "exec", podName, "--", "/bin/sh", "-c", cmd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cockroachDBTester) deploy(ns string) *apps.StatefulSet {
0000000000000000000000000000000000000000;;		c.ss = c.tester.CreateStatefulSet(cockroachDBManifestPath, ns)
0000000000000000000000000000000000000000;;		framework.Logf("Deployed statefulset %v, initializing database", c.ss.Name)
0000000000000000000000000000000000000000;;		for _, cmd := range []string{
0000000000000000000000000000000000000000;;			"CREATE DATABASE IF NOT EXISTS foo;",
0000000000000000000000000000000000000000;;			"CREATE TABLE IF NOT EXISTS foo.bar (k STRING PRIMARY KEY, v STRING);",
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			framework.Logf(c.cockroachDBExec(cmd, ns, fmt.Sprintf("%v-0", c.ss.Name)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.ss
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cockroachDBTester) write(statefulPodIndex int, kv map[string]string) {
0000000000000000000000000000000000000000;;		name := fmt.Sprintf("%v-%d", c.ss.Name, statefulPodIndex)
0000000000000000000000000000000000000000;;		for k, v := range kv {
0000000000000000000000000000000000000000;;			cmd := fmt.Sprintf("UPSERT INTO foo.bar VALUES ('%v', '%v');", k, v)
0000000000000000000000000000000000000000;;			framework.Logf(c.cockroachDBExec(cmd, c.ss.Namespace, name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (c *cockroachDBTester) read(statefulPodIndex int, key string) string {
0000000000000000000000000000000000000000;;		name := fmt.Sprintf("%v-%d", c.ss.Name, statefulPodIndex)
0000000000000000000000000000000000000000;;		return lastLine(c.cockroachDBExec(fmt.Sprintf("SELECT v FROM foo.bar WHERE k='%v';", key), c.ss.Namespace, name))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lastLine(out string) string {
0000000000000000000000000000000000000000;;		outLines := strings.Split(strings.Trim(out, "\n"), "\n")
0000000000000000000000000000000000000000;;		return outLines[len(outLines)-1]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pollReadWithTimeout(statefulPod statefulPodTester, statefulPodNumber int, key, expectedVal string) error {
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(time.Second, readTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			val := statefulPod.read(statefulPodNumber, key)
0000000000000000000000000000000000000000;;			if val == "" {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			} else if val != expectedVal {
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("expected value %v, found %v", expectedVal, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			return fmt.Errorf("timed out when trying to read value for key %v from stateful pod %d", key, statefulPodNumber)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
