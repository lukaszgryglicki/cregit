0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
530cbe02f3e7b288eb81f2e6e2dd9265ccf5c566;test/e2e/replica_set.go[test/e2e/replica_set.go][test/e2e/workload/replica_set.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package workload
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/replicaset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRS(rsName string, replicas int32, rsPodLabels map[string]string, imageName string, image string) *extensions.ReplicaSet {
0000000000000000000000000000000000000000;;		zero := int64(0)
0000000000000000000000000000000000000000;;		return &extensions.ReplicaSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: rsName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.ReplicaSetSpec{
0000000000000000000000000000000000000000;;				Replicas: &replicas,
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: rsPodLabels,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						TerminationGracePeriodSeconds: &zero,
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  imageName,
0000000000000000000000000000000000000000;;								Image: image,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPodQuota(name, number string) *v1.ResourceQuota {
0000000000000000000000000000000000000000;;		return &v1.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ResourceQuotaSpec{
0000000000000000000000000000000000000000;;				Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourcePods: resource.MustParse(number),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("ReplicaSet", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("replicaset")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should serve a basic image on each replica with a public image [Conformance]", func() {
0000000000000000000000000000000000000000;;			testReplicaSetServeImageOrFail(f, "basic", framework.ServeHostnameImage)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should serve a basic image on each replica with a private image", func() {
0000000000000000000000000000000000000000;;			// requires private images
0000000000000000000000000000000000000000;;			framework.SkipUnlessProviderIs("gce", "gke")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			testReplicaSetServeImageOrFail(f, "private", "gcr.io/k8s-authenticated-test/serve_hostname:v1.4")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should surface a failure condition on a common issue like exceeded quota", func() {
0000000000000000000000000000000000000000;;			testReplicaSetConditionCheck(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should adopt matching pods on creation", func() {
0000000000000000000000000000000000000000;;			testRSAdoptMatchingOrphans(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should release no longer matching pods", func() {
0000000000000000000000000000000000000000;;			testRSReleaseControlledNotMatching(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A basic test to check the deployment of an image using a ReplicaSet. The
0000000000000000000000000000000000000000;;	// image serves its hostname which is checked for each replica.
0000000000000000000000000000000000000000;;	func testReplicaSetServeImageOrFail(f *framework.Framework, test string, image string) {
0000000000000000000000000000000000000000;;		name := "my-hostname-" + test + "-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;		replicas := int32(1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a ReplicaSet for a service that serves its hostname.
0000000000000000000000000000000000000000;;		// The source for the Docker containter kubernetes/serve_hostname is
0000000000000000000000000000000000000000;;		// in contrib/for-demos/serve_hostname
0000000000000000000000000000000000000000;;		framework.Logf("Creating ReplicaSet %s", name)
0000000000000000000000000000000000000000;;		newRS := newRS(name, replicas, map[string]string{"name": name}, name, image)
0000000000000000000000000000000000000000;;		newRS.Spec.Template.Spec.Containers[0].Ports = []v1.ContainerPort{{ContainerPort: 9376}}
0000000000000000000000000000000000000000;;		_, err := f.ClientSet.Extensions().ReplicaSets(f.Namespace.Name).Create(newRS)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check that pods for the new RS were created.
0000000000000000000000000000000000000000;;		// TODO: Maybe switch PodsCreated to just check owner references.
0000000000000000000000000000000000000000;;		pods, err := framework.PodsCreated(f.ClientSet, f.Namespace.Name, name, replicas)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for the pods to enter the running state. Waiting loops until the pods
0000000000000000000000000000000000000000;;		// are running so non-running pods cause a timeout for this test.
0000000000000000000000000000000000000000;;		framework.Logf("Ensuring a pod for ReplicaSet %q is running", name)
0000000000000000000000000000000000000000;;		running := int32(0)
0000000000000000000000000000000000000000;;		for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;			if pod.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = f.WaitForPodRunning(pod.Name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				updatePod, getErr := f.ClientSet.Core().Pods(f.Namespace.Name).Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if getErr == nil {
0000000000000000000000000000000000000000;;					err = fmt.Errorf("Pod %q never run (phase: %s, conditions: %+v): %v", updatePod.Name, updatePod.Status.Phase, updatePod.Status.Conditions, err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					err = fmt.Errorf("Pod %q never run: %v", pod.Name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			framework.Logf("Pod %q is running (conditions: %+v)", pod.Name, pod.Status.Conditions)
0000000000000000000000000000000000000000;;			running++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sanity check
0000000000000000000000000000000000000000;;		if running != replicas {
0000000000000000000000000000000000000000;;			Expect(fmt.Errorf("unexpected number of running pods: %+v", pods.Items)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify that something is listening.
0000000000000000000000000000000000000000;;		framework.Logf("Trying to dial the pod")
0000000000000000000000000000000000000000;;		retryTimeout := 2 * time.Minute
0000000000000000000000000000000000000000;;		retryInterval := 5 * time.Second
0000000000000000000000000000000000000000;;		label := labels.SelectorFromSet(labels.Set(map[string]string{"name": name}))
0000000000000000000000000000000000000000;;		err = wait.Poll(retryInterval, retryTimeout, framework.PodProxyResponseChecker(f.ClientSet, f.Namespace.Name, label, name, true, pods).CheckAllResponses)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Did not get expected responses within the timeout period of %.2f seconds.", retryTimeout.Seconds())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// 1. Create a quota restricting pods in the current namespace to 2.
0000000000000000000000000000000000000000;;	// 2. Create a replica set that wants to run 3 pods.
0000000000000000000000000000000000000000;;	// 3. Check replica set conditions for a ReplicaFailure condition.
0000000000000000000000000000000000000000;;	// 4. Scale down the replica set and observe the condition is gone.
0000000000000000000000000000000000000000;;	func testReplicaSetConditionCheck(f *framework.Framework) {
0000000000000000000000000000000000000000;;		c := f.ClientSet
0000000000000000000000000000000000000000;;		namespace := f.Namespace.Name
0000000000000000000000000000000000000000;;		name := "condition-test"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating quota %q that allows only two pods to run in the current namespace", name))
0000000000000000000000000000000000000000;;		quota := newPodQuota(name, "2")
0000000000000000000000000000000000000000;;		_, err := c.Core().ResourceQuotas(namespace).Create(quota)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(1*time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			quota, err = c.Core().ResourceQuotas(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			quantity := resource.MustParse("2")
0000000000000000000000000000000000000000;;			podQuota := quota.Status.Hard[v1.ResourcePods]
0000000000000000000000000000000000000000;;			return (&podQuota).Cmp(quantity) == 0, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("resource quota %q never synced", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating replica set %q that asks for more than the allowed pod quota", name))
0000000000000000000000000000000000000000;;		rs := newRS(name, 3, map[string]string{"name": name}, NginxImageName, NginxImage)
0000000000000000000000000000000000000000;;		rs, err = c.Extensions().ReplicaSets(namespace).Create(rs)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Checking replica set %q has the desired failure condition set", name))
0000000000000000000000000000000000000000;;		generation := rs.Generation
0000000000000000000000000000000000000000;;		conditions := rs.Status.Conditions
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(1*time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			rs, err = c.Extensions().ReplicaSets(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if generation > rs.Status.ObservedGeneration {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			conditions = rs.Status.Conditions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cond := replicaset.GetCondition(rs.Status, extensions.ReplicaSetReplicaFailure)
0000000000000000000000000000000000000000;;			return cond != nil, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("rs controller never added the failure condition for replica set %q: %#v", name, conditions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Scaling down replica set %q to satisfy pod quota", name))
0000000000000000000000000000000000000000;;		rs, err = framework.UpdateReplicaSetWithRetries(c, namespace, name, func(update *extensions.ReplicaSet) {
0000000000000000000000000000000000000000;;			x := int32(2)
0000000000000000000000000000000000000000;;			update.Spec.Replicas = &x
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Checking replica set %q has no failure condition set", name))
0000000000000000000000000000000000000000;;		generation = rs.Generation
0000000000000000000000000000000000000000;;		conditions = rs.Status.Conditions
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(1*time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			rs, err = c.Extensions().ReplicaSets(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if generation > rs.Status.ObservedGeneration {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			conditions = rs.Status.Conditions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cond := replicaset.GetCondition(rs.Status, extensions.ReplicaSetReplicaFailure)
0000000000000000000000000000000000000000;;			return cond == nil, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("rs controller never removed the failure condition for rs %q: %#v", name, conditions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testRSAdoptMatchingOrphans(f *framework.Framework) {
0000000000000000000000000000000000000000;;		name := "pod-adoption"
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Given a Pod with a 'name' label %s is created", name))
0000000000000000000000000000000000000000;;		p := f.PodClient().CreateSync(&v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"name": name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  name,
0000000000000000000000000000000000000000;;						Image: NginxImageName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("When a replicaset with a matching selector is created")
0000000000000000000000000000000000000000;;		replicas := int32(1)
0000000000000000000000000000000000000000;;		rsSt := newRS(name, replicas, map[string]string{"name": name}, name, NginxImageName)
0000000000000000000000000000000000000000;;		rsSt.Spec.Selector = &metav1.LabelSelector{MatchLabels: map[string]string{"name": name}}
0000000000000000000000000000000000000000;;		rs, err := f.ClientSet.Extensions().ReplicaSets(f.Namespace.Name).Create(rsSt)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Then the orphan pod is adopted")
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(1*time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			p2, err := f.ClientSet.Core().Pods(f.Namespace.Name).Get(p.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			// The Pod p should either be adopted or deleted by the ReplicaSet
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			for _, owner := range p2.OwnerReferences {
0000000000000000000000000000000000000000;;				if *owner.Controller && owner.UID == rs.UID {
0000000000000000000000000000000000000000;;					// pod adopted
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// pod still not adopted
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testRSReleaseControlledNotMatching(f *framework.Framework) {
0000000000000000000000000000000000000000;;		name := "pod-release"
0000000000000000000000000000000000000000;;		By("Given a ReplicaSet is created")
0000000000000000000000000000000000000000;;		replicas := int32(1)
0000000000000000000000000000000000000000;;		rsSt := newRS(name, replicas, map[string]string{"name": name}, name, NginxImageName)
0000000000000000000000000000000000000000;;		rsSt.Spec.Selector = &metav1.LabelSelector{MatchLabels: map[string]string{"name": name}}
0000000000000000000000000000000000000000;;		rs, err := f.ClientSet.Extensions().ReplicaSets(f.Namespace.Name).Create(rsSt)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("When the matched label of one of its pods change")
0000000000000000000000000000000000000000;;		pods, err := framework.PodsCreated(f.ClientSet, f.Namespace.Name, rs.Name, replicas)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := pods.Items[0]
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(1*time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			pod, err := f.ClientSet.Core().Pods(f.Namespace.Name).Get(p.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod.Labels = map[string]string{"name": "not-matching-name"}
0000000000000000000000000000000000000000;;			_, err = f.ClientSet.Core().Pods(f.Namespace.Name).Update(pod)
0000000000000000000000000000000000000000;;			if err != nil && errors.IsConflict(err) {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Then the pod is released")
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(1*time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			p2, err := f.ClientSet.Core().Pods(f.Namespace.Name).Get(p.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			for _, owner := range p2.OwnerReferences {
0000000000000000000000000000000000000000;;				if *owner.Controller && owner.UID == rs.UID {
0000000000000000000000000000000000000000;;					// pod still belonging to the replicaset
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// pod already released
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	}
