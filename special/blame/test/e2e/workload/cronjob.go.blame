0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
5d6abb1f383f5f9d7fdfd12e111631919a539e2e;test/e2e/scheduledjob.go[test/e2e/scheduledjob.go][test/e2e/workload/cronjob.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package workload
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		batchv1 "k8s.io/api/batch/v1"
0000000000000000000000000000000000000000;;		batchv2alpha1 "k8s.io/api/batch/v2alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		batchinternal "k8s.io/kubernetes/pkg/apis/batch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/job"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// How long to wait for a cronjob
0000000000000000000000000000000000000000;;		cronJobTimeout = 5 * time.Minute
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("CronJob", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("cronjob")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sleepCommand := []string{"sleep", "300"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pod will complete instantly
0000000000000000000000000000000000000000;;		successCommand := []string{"/bin/true"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			framework.SkipIfMissingResource(f.ClientPool, CronJobGroupVersionResource, f.Namespace.Name)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// multiple jobs running at once
0000000000000000000000000000000000000000;;		It("should schedule multiple jobs concurrently", func() {
0000000000000000000000000000000000000000;;			By("Creating a cronjob")
0000000000000000000000000000000000000000;;			cronJob := newTestCronJob("concurrent", "*/1 * * * ?", batchv2alpha1.AllowConcurrent,
0000000000000000000000000000000000000000;;				sleepCommand, nil)
0000000000000000000000000000000000000000;;			cronJob, err := createCronJob(f.ClientSet, f.Namespace.Name, cronJob)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring more than one job is running at a time")
0000000000000000000000000000000000000000;;			err = waitForActiveJobs(f.ClientSet, f.Namespace.Name, cronJob.Name, 2)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring at least two running jobs exists by listing jobs explicitly")
0000000000000000000000000000000000000000;;			jobs, err := f.ClientSet.Batch().Jobs(f.Namespace.Name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			activeJobs, _ := filterActiveJobs(jobs)
0000000000000000000000000000000000000000;;			Expect(len(activeJobs) >= 2).To(BeTrue())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Removing cronjob")
0000000000000000000000000000000000000000;;			err = deleteCronJob(f.ClientSet, f.Namespace.Name, cronJob.Name)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// suspended should not schedule jobs
0000000000000000000000000000000000000000;;		It("should not schedule jobs when suspended [Slow]", func() {
0000000000000000000000000000000000000000;;			By("Creating a suspended cronjob")
0000000000000000000000000000000000000000;;			cronJob := newTestCronJob("suspended", "*/1 * * * ?", batchv2alpha1.AllowConcurrent,
0000000000000000000000000000000000000000;;				sleepCommand, nil)
0000000000000000000000000000000000000000;;			t := true
0000000000000000000000000000000000000000;;			cronJob.Spec.Suspend = &t
0000000000000000000000000000000000000000;;			cronJob, err := createCronJob(f.ClientSet, f.Namespace.Name, cronJob)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring no jobs are scheduled")
0000000000000000000000000000000000000000;;			err = waitForNoJobs(f.ClientSet, f.Namespace.Name, cronJob.Name, false)
0000000000000000000000000000000000000000;;			Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring no job exists by listing jobs explicitly")
0000000000000000000000000000000000000000;;			jobs, err := f.ClientSet.Batch().Jobs(f.Namespace.Name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(jobs.Items).To(HaveLen(0))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Removing cronjob")
0000000000000000000000000000000000000000;;			err = deleteCronJob(f.ClientSet, f.Namespace.Name, cronJob.Name)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// only single active job is allowed for ForbidConcurrent
0000000000000000000000000000000000000000;;		It("should not schedule new jobs when ForbidConcurrent [Slow]", func() {
0000000000000000000000000000000000000000;;			By("Creating a ForbidConcurrent cronjob")
0000000000000000000000000000000000000000;;			cronJob := newTestCronJob("forbid", "*/1 * * * ?", batchv2alpha1.ForbidConcurrent,
0000000000000000000000000000000000000000;;				sleepCommand, nil)
0000000000000000000000000000000000000000;;			cronJob, err := createCronJob(f.ClientSet, f.Namespace.Name, cronJob)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring a job is scheduled")
0000000000000000000000000000000000000000;;			err = waitForActiveJobs(f.ClientSet, f.Namespace.Name, cronJob.Name, 1)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring exactly one is scheduled")
0000000000000000000000000000000000000000;;			cronJob, err = getCronJob(f.ClientSet, f.Namespace.Name, cronJob.Name)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(cronJob.Status.Active).Should(HaveLen(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring exactly one running job exists by listing jobs explicitly")
0000000000000000000000000000000000000000;;			jobs, err := f.ClientSet.Batch().Jobs(f.Namespace.Name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			activeJobs, _ := filterActiveJobs(jobs)
0000000000000000000000000000000000000000;;			Expect(activeJobs).To(HaveLen(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring no more jobs are scheduled")
0000000000000000000000000000000000000000;;			err = waitForActiveJobs(f.ClientSet, f.Namespace.Name, cronJob.Name, 2)
0000000000000000000000000000000000000000;;			Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Removing cronjob")
0000000000000000000000000000000000000000;;			err = deleteCronJob(f.ClientSet, f.Namespace.Name, cronJob.Name)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// only single active job is allowed for ReplaceConcurrent
0000000000000000000000000000000000000000;;		It("should replace jobs when ReplaceConcurrent", func() {
0000000000000000000000000000000000000000;;			By("Creating a ReplaceConcurrent cronjob")
0000000000000000000000000000000000000000;;			cronJob := newTestCronJob("replace", "*/1 * * * ?", batchv2alpha1.ReplaceConcurrent,
0000000000000000000000000000000000000000;;				sleepCommand, nil)
0000000000000000000000000000000000000000;;			cronJob, err := createCronJob(f.ClientSet, f.Namespace.Name, cronJob)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring a job is scheduled")
0000000000000000000000000000000000000000;;			err = waitForActiveJobs(f.ClientSet, f.Namespace.Name, cronJob.Name, 1)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring exactly one is scheduled")
0000000000000000000000000000000000000000;;			cronJob, err = getCronJob(f.ClientSet, f.Namespace.Name, cronJob.Name)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(cronJob.Status.Active).Should(HaveLen(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring exactly one running job exists by listing jobs explicitly")
0000000000000000000000000000000000000000;;			jobs, err := f.ClientSet.Batch().Jobs(f.Namespace.Name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			activeJobs, _ := filterActiveJobs(jobs)
0000000000000000000000000000000000000000;;			Expect(activeJobs).To(HaveLen(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring the job is replaced with a new one")
0000000000000000000000000000000000000000;;			err = waitForJobReplaced(f.ClientSet, f.Namespace.Name, jobs.Items[0].Name)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Removing cronjob")
0000000000000000000000000000000000000000;;			err = deleteCronJob(f.ClientSet, f.Namespace.Name, cronJob.Name)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// shouldn't give us unexpected warnings
0000000000000000000000000000000000000000;;		It("should not emit unexpected warnings", func() {
0000000000000000000000000000000000000000;;			By("Creating a cronjob")
0000000000000000000000000000000000000000;;			cronJob := newTestCronJob("concurrent", "*/1 * * * ?", batchv2alpha1.AllowConcurrent,
0000000000000000000000000000000000000000;;				nil, nil)
0000000000000000000000000000000000000000;;			cronJob, err := createCronJob(f.ClientSet, f.Namespace.Name, cronJob)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring at least two jobs and at least one finished job exists by listing jobs explicitly")
0000000000000000000000000000000000000000;;			err = waitForJobsAtLeast(f.ClientSet, f.Namespace.Name, 2)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			err = waitForAnyFinishedJob(f.ClientSet, f.Namespace.Name)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring no unexpected event has happened")
0000000000000000000000000000000000000000;;			err = checkNoEventWithReason(f.ClientSet, f.Namespace.Name, cronJob.Name, []string{"MissingJob", "UnexpectedJob"})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Removing cronjob")
0000000000000000000000000000000000000000;;			err = deleteCronJob(f.ClientSet, f.Namespace.Name, cronJob.Name)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// deleted jobs should be removed from the active list
0000000000000000000000000000000000000000;;		It("should remove from active list jobs that have been deleted", func() {
0000000000000000000000000000000000000000;;			By("Creating a ForbidConcurrent cronjob")
0000000000000000000000000000000000000000;;			cronJob := newTestCronJob("forbid", "*/1 * * * ?", batchv2alpha1.ForbidConcurrent,
0000000000000000000000000000000000000000;;				sleepCommand, nil)
0000000000000000000000000000000000000000;;			cronJob, err := createCronJob(f.ClientSet, f.Namespace.Name, cronJob)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring a job is scheduled")
0000000000000000000000000000000000000000;;			err = waitForActiveJobs(f.ClientSet, f.Namespace.Name, cronJob.Name, 1)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring exactly one is scheduled")
0000000000000000000000000000000000000000;;			cronJob, err = getCronJob(f.ClientSet, f.Namespace.Name, cronJob.Name)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(cronJob.Status.Active).Should(HaveLen(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Deleting the job")
0000000000000000000000000000000000000000;;			job := cronJob.Status.Active[0]
0000000000000000000000000000000000000000;;			reaper, err := kubectl.ReaperFor(batchinternal.Kind("Job"), f.InternalClientset)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			timeout := 1 * time.Minute
0000000000000000000000000000000000000000;;			err = reaper.Stop(f.Namespace.Name, job.Name, timeout, metav1.NewDeleteOptions(0))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring job was deleted")
0000000000000000000000000000000000000000;;			_, err = framework.GetJob(f.ClientSet, f.Namespace.Name, job.Name)
0000000000000000000000000000000000000000;;			Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(errors.IsNotFound(err)).To(BeTrue())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring there are no active jobs in the cronjob")
0000000000000000000000000000000000000000;;			err = waitForNoJobs(f.ClientSet, f.Namespace.Name, cronJob.Name, true)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring MissingJob event has occured")
0000000000000000000000000000000000000000;;			err = checkNoEventWithReason(f.ClientSet, f.Namespace.Name, cronJob.Name, []string{"MissingJob"})
0000000000000000000000000000000000000000;;			Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Removing cronjob")
0000000000000000000000000000000000000000;;			err = deleteCronJob(f.ClientSet, f.Namespace.Name, cronJob.Name)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cleanup of successful finished jobs, with limit of one successful job
0000000000000000000000000000000000000000;;		It("should delete successful finished jobs with limit of one successful job", func() {
0000000000000000000000000000000000000000;;			By("Creating a AllowConcurrent cronjob with custom history limits")
0000000000000000000000000000000000000000;;			successLimit := int32(1)
0000000000000000000000000000000000000000;;			cronJob := newTestCronJob("concurrent-limit", "*/1 * * * ?", batchv2alpha1.AllowConcurrent,
0000000000000000000000000000000000000000;;				successCommand, &successLimit)
0000000000000000000000000000000000000000;;			cronJob, err := createCronJob(f.ClientSet, f.Namespace.Name, cronJob)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Job is going to complete instantly: do not check for an active job
0000000000000000000000000000000000000000;;			// as we are most likely to miss it
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring a finished job exists")
0000000000000000000000000000000000000000;;			err = waitForAnyFinishedJob(f.ClientSet, f.Namespace.Name)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring a finished job exists by listing jobs explicitly")
0000000000000000000000000000000000000000;;			jobs, err := f.ClientSet.Batch().Jobs(f.Namespace.Name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			_, finishedJobs := filterActiveJobs(jobs)
0000000000000000000000000000000000000000;;			Expect(len(finishedJobs) == 1).To(BeTrue())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Job should get deleted when the next job finishes the next minute
0000000000000000000000000000000000000000;;			By("Ensuring this job does not exist anymore")
0000000000000000000000000000000000000000;;			err = waitForJobNotExist(f.ClientSet, f.Namespace.Name, finishedJobs[0])
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring there is 1 finished job by listing jobs explicitly")
0000000000000000000000000000000000000000;;			jobs, err = f.ClientSet.Batch().Jobs(f.Namespace.Name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			_, finishedJobs = filterActiveJobs(jobs)
0000000000000000000000000000000000000000;;			Expect(len(finishedJobs) == 1).To(BeTrue())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Removing cronjob")
0000000000000000000000000000000000000000;;			err = deleteCronJob(f.ClientSet, f.Namespace.Name, cronJob.Name)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newTestCronJob returns a cronjob which does one of several testing behaviors.
0000000000000000000000000000000000000000;;	func newTestCronJob(name, schedule string, concurrencyPolicy batchv2alpha1.ConcurrencyPolicy,
0000000000000000000000000000000000000000;;		command []string, successfulJobsHistoryLimit *int32) *batchv2alpha1.CronJob {
0000000000000000000000000000000000000000;;		parallelism := int32(1)
0000000000000000000000000000000000000000;;		completions := int32(1)
0000000000000000000000000000000000000000;;		sj := &batchv2alpha1.CronJob{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind: "CronJob",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: batchv2alpha1.CronJobSpec{
0000000000000000000000000000000000000000;;				Schedule:          schedule,
0000000000000000000000000000000000000000;;				ConcurrencyPolicy: concurrencyPolicy,
0000000000000000000000000000000000000000;;				JobTemplate: batchv2alpha1.JobTemplateSpec{
0000000000000000000000000000000000000000;;					Spec: batchv1.JobSpec{
0000000000000000000000000000000000000000;;						Parallelism: &parallelism,
0000000000000000000000000000000000000000;;						Completions: &completions,
0000000000000000000000000000000000000000;;						Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;							Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;								RestartPolicy: v1.RestartPolicyOnFailure,
0000000000000000000000000000000000000000;;								Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name: "data",
0000000000000000000000000000000000000000;;										VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;											EmptyDir: &v1.EmptyDirVolumeSource{},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Containers: []v1.Container{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name:  "c",
0000000000000000000000000000000000000000;;										Image: "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;										VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;											{
0000000000000000000000000000000000000000;;												MountPath: "/data",
0000000000000000000000000000000000000000;;												Name:      "data",
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sj.Spec.SuccessfulJobsHistoryLimit = successfulJobsHistoryLimit
0000000000000000000000000000000000000000;;		if command != nil {
0000000000000000000000000000000000000000;;			sj.Spec.JobTemplate.Spec.Template.Spec.Containers[0].Command = command
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sj
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createCronJob(c clientset.Interface, ns string, cronJob *batchv2alpha1.CronJob) (*batchv2alpha1.CronJob, error) {
0000000000000000000000000000000000000000;;		return c.BatchV2alpha1().CronJobs(ns).Create(cronJob)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getCronJob(c clientset.Interface, ns, name string) (*batchv2alpha1.CronJob, error) {
0000000000000000000000000000000000000000;;		return c.BatchV2alpha1().CronJobs(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deleteCronJob(c clientset.Interface, ns, name string) error {
0000000000000000000000000000000000000000;;		return c.BatchV2alpha1().CronJobs(ns).Delete(name, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait for at least given amount of active jobs.
0000000000000000000000000000000000000000;;	func waitForActiveJobs(c clientset.Interface, ns, cronJobName string, active int) error {
0000000000000000000000000000000000000000;;		return wait.Poll(framework.Poll, cronJobTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			curr, err := c.BatchV2alpha1().CronJobs(ns).Get(cronJobName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return len(curr.Status.Active) >= active, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait for jobs to appear in the active list of a cronjob or not.
0000000000000000000000000000000000000000;;	// When failIfNonEmpty is set, this fails if the active set of jobs is still non-empty after
0000000000000000000000000000000000000000;;	// the timeout. When failIfNonEmpty is not set, this fails if the active set of jobs is still
0000000000000000000000000000000000000000;;	// empty after the timeout.
0000000000000000000000000000000000000000;;	func waitForNoJobs(c clientset.Interface, ns, jobName string, failIfNonEmpty bool) error {
0000000000000000000000000000000000000000;;		return wait.Poll(framework.Poll, cronJobTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			curr, err := c.BatchV2alpha1().CronJobs(ns).Get(jobName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if failIfNonEmpty {
0000000000000000000000000000000000000000;;				return len(curr.Status.Active) == 0, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return len(curr.Status.Active) != 0, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait for a job to not exist by listing jobs explicitly.
0000000000000000000000000000000000000000;;	func waitForJobNotExist(c clientset.Interface, ns string, targetJob *batchv1.Job) error {
0000000000000000000000000000000000000000;;		return wait.Poll(framework.Poll, cronJobTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			jobs, err := c.Batch().Jobs(ns).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, finishedJobs := filterActiveJobs(jobs)
0000000000000000000000000000000000000000;;			for _, job := range finishedJobs {
0000000000000000000000000000000000000000;;				if targetJob.Namespace == job.Namespace && targetJob.Name == job.Name {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait for a job to be replaced with a new one.
0000000000000000000000000000000000000000;;	func waitForJobReplaced(c clientset.Interface, ns, previousJobName string) error {
0000000000000000000000000000000000000000;;		return wait.Poll(framework.Poll, cronJobTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			jobs, err := c.Batch().Jobs(ns).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Ignore Jobs pending deletion, since deletion of Jobs is now asynchronous.
0000000000000000000000000000000000000000;;			aliveJobs := filterNotDeletedJobs(jobs)
0000000000000000000000000000000000000000;;			if len(aliveJobs) > 1 {
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("More than one job is running %+v", jobs.Items)
0000000000000000000000000000000000000000;;			} else if len(aliveJobs) == 0 {
0000000000000000000000000000000000000000;;				framework.Logf("Warning: Found 0 jobs in namespace %v", ns)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return aliveJobs[0].Name != previousJobName, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForJobsAtLeast waits for at least a number of jobs to appear.
0000000000000000000000000000000000000000;;	func waitForJobsAtLeast(c clientset.Interface, ns string, atLeast int) error {
0000000000000000000000000000000000000000;;		return wait.Poll(framework.Poll, cronJobTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			jobs, err := c.Batch().Jobs(ns).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return len(jobs.Items) >= atLeast, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForAnyFinishedJob waits for any completed job to appear.
0000000000000000000000000000000000000000;;	func waitForAnyFinishedJob(c clientset.Interface, ns string) error {
0000000000000000000000000000000000000000;;		return wait.Poll(framework.Poll, cronJobTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			jobs, err := c.Batch().Jobs(ns).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := range jobs.Items {
0000000000000000000000000000000000000000;;				if job.IsJobFinished(&jobs.Items[i]) {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkNoEventWithReason checks no events with a reason within a list has occured
0000000000000000000000000000000000000000;;	func checkNoEventWithReason(c clientset.Interface, ns, cronJobName string, reasons []string) error {
0000000000000000000000000000000000000000;;		sj, err := c.BatchV2alpha1().CronJobs(ns).Get(cronJobName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error in getting cronjob %s/%s: %v", ns, cronJobName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		events, err := c.Core().Events(ns).Search(api.Scheme, sj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error in listing events: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, e := range events.Items {
0000000000000000000000000000000000000000;;			for _, reason := range reasons {
0000000000000000000000000000000000000000;;				if e.Reason == reason {
0000000000000000000000000000000000000000;;					return fmt.Errorf("Found event with reason %s: %#v", reason, e)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// filterNotDeletedJobs returns the job list without any jobs that are pending
0000000000000000000000000000000000000000;;	// deletion.
0000000000000000000000000000000000000000;;	func filterNotDeletedJobs(jobs *batchv1.JobList) []*batchv1.Job {
0000000000000000000000000000000000000000;;		var alive []*batchv1.Job
0000000000000000000000000000000000000000;;		for i := range jobs.Items {
0000000000000000000000000000000000000000;;			job := &jobs.Items[i]
0000000000000000000000000000000000000000;;			if job.DeletionTimestamp == nil {
0000000000000000000000000000000000000000;;				alive = append(alive, job)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return alive
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func filterActiveJobs(jobs *batchv1.JobList) (active []*batchv1.Job, finished []*batchv1.Job) {
0000000000000000000000000000000000000000;;		for i := range jobs.Items {
0000000000000000000000000000000000000000;;			j := jobs.Items[i]
0000000000000000000000000000000000000000;;			if !job.IsJobFinished(&j) {
0000000000000000000000000000000000000000;;				active = append(active, &j)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				finished = append(finished, &j)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
