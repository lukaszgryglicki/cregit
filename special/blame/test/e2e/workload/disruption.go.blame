0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
4325c13d8eb490cf00e39f8c28840a5533d59174;test/e2e/disruption.go[test/e2e/disruption.go][test/e2e/workload/disruption.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package workload
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		policy "k8s.io/api/policy/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// schedulingTimeout is longer specifically because sometimes we need to wait
0000000000000000000000000000000000000000;;	// awhile to guarantee that we've been patient waiting for something ordinary
0000000000000000000000000000000000000000;;	// to happen: a pod to get scheduled and move into Ready
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		bigClusterSize    = 7
0000000000000000000000000000000000000000;;		schedulingTimeout = 10 * time.Minute
0000000000000000000000000000000000000000;;		timeout           = 60 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("DisruptionController", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("disruption")
0000000000000000000000000000000000000000;;		var ns string
0000000000000000000000000000000000000000;;		var cs *kubernetes.Clientset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			cs = f.StagingClient
0000000000000000000000000000000000000000;;			ns = f.Namespace.Name
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should create a PodDisruptionBudget", func() {
0000000000000000000000000000000000000000;;			createPDBMinAvailableOrDie(cs, ns, intstr.FromString("1%"))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should update PodDisruptionBudget status", func() {
0000000000000000000000000000000000000000;;			createPDBMinAvailableOrDie(cs, ns, intstr.FromInt(2))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			createPodsOrDie(cs, ns, 3)
0000000000000000000000000000000000000000;;			waitForPodsOrDie(cs, ns, 3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Since disruptionAllowed starts out 0, if we see it ever become positive,
0000000000000000000000000000000000000000;;			// that means the controller is working.
0000000000000000000000000000000000000000;;			err := wait.PollImmediate(framework.Poll, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;				pdb, err := cs.Policy().PodDisruptionBudgets(ns).Get("foo", metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return pdb.Status.PodDisruptionsAllowed > 0, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		evictionCases := []struct {
0000000000000000000000000000000000000000;;			description        string
0000000000000000000000000000000000000000;;			minAvailable       intstr.IntOrString
0000000000000000000000000000000000000000;;			maxUnavailable     intstr.IntOrString
0000000000000000000000000000000000000000;;			podCount           int
0000000000000000000000000000000000000000;;			replicaSetSize     int32
0000000000000000000000000000000000000000;;			shouldDeny         bool
0000000000000000000000000000000000000000;;			exclusive          bool
0000000000000000000000000000000000000000;;			skipForBigClusters bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:    "no PDB",
0000000000000000000000000000000000000000;;				minAvailable:   intstr.FromString(""),
0000000000000000000000000000000000000000;;				maxUnavailable: intstr.FromString(""),
0000000000000000000000000000000000000000;;				podCount:       1,
0000000000000000000000000000000000000000;;				shouldDeny:     false,
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				description:    "too few pods, absolute",
0000000000000000000000000000000000000000;;				minAvailable:   intstr.FromInt(2),
0000000000000000000000000000000000000000;;				maxUnavailable: intstr.FromString(""),
0000000000000000000000000000000000000000;;				podCount:       2,
0000000000000000000000000000000000000000;;				shouldDeny:     true,
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				description:    "enough pods, absolute",
0000000000000000000000000000000000000000;;				minAvailable:   intstr.FromInt(2),
0000000000000000000000000000000000000000;;				maxUnavailable: intstr.FromString(""),
0000000000000000000000000000000000000000;;				podCount:       3,
0000000000000000000000000000000000000000;;				shouldDeny:     false,
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				description:    "enough pods, replicaSet, percentage",
0000000000000000000000000000000000000000;;				minAvailable:   intstr.FromString("90%"),
0000000000000000000000000000000000000000;;				maxUnavailable: intstr.FromString(""),
0000000000000000000000000000000000000000;;				replicaSetSize: 10,
0000000000000000000000000000000000000000;;				exclusive:      false,
0000000000000000000000000000000000000000;;				shouldDeny:     false,
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				description:    "too few pods, replicaSet, percentage",
0000000000000000000000000000000000000000;;				minAvailable:   intstr.FromString("90%"),
0000000000000000000000000000000000000000;;				maxUnavailable: intstr.FromString(""),
0000000000000000000000000000000000000000;;				replicaSetSize: 10,
0000000000000000000000000000000000000000;;				exclusive:      true,
0000000000000000000000000000000000000000;;				shouldDeny:     true,
0000000000000000000000000000000000000000;;				// This tests assumes that there is less than replicaSetSize nodes in the cluster.
0000000000000000000000000000000000000000;;				skipForBigClusters: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:    "maxUnavailable allow single eviction, percentage",
0000000000000000000000000000000000000000;;				minAvailable:   intstr.FromString(""),
0000000000000000000000000000000000000000;;				maxUnavailable: intstr.FromString("10%"),
0000000000000000000000000000000000000000;;				replicaSetSize: 10,
0000000000000000000000000000000000000000;;				exclusive:      false,
0000000000000000000000000000000000000000;;				shouldDeny:     false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:    "maxUnavailable deny evictions, integer",
0000000000000000000000000000000000000000;;				minAvailable:   intstr.FromString(""),
0000000000000000000000000000000000000000;;				maxUnavailable: intstr.FromInt(1),
0000000000000000000000000000000000000000;;				replicaSetSize: 10,
0000000000000000000000000000000000000000;;				exclusive:      true,
0000000000000000000000000000000000000000;;				shouldDeny:     true,
0000000000000000000000000000000000000000;;				// This tests assumes that there is less than replicaSetSize nodes in the cluster.
0000000000000000000000000000000000000000;;				skipForBigClusters: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range evictionCases {
0000000000000000000000000000000000000000;;			c := evictionCases[i]
0000000000000000000000000000000000000000;;			expectation := "should allow an eviction"
0000000000000000000000000000000000000000;;			if c.shouldDeny {
0000000000000000000000000000000000000000;;				expectation = "should not allow an eviction"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			It(fmt.Sprintf("evictions: %s => %s", c.description, expectation), func() {
0000000000000000000000000000000000000000;;				if c.skipForBigClusters {
0000000000000000000000000000000000000000;;					framework.SkipUnlessNodeCountIsAtMost(bigClusterSize - 1)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				createPodsOrDie(cs, ns, c.podCount)
0000000000000000000000000000000000000000;;				if c.replicaSetSize > 0 {
0000000000000000000000000000000000000000;;					createReplicaSetOrDie(cs, ns, c.replicaSetSize, c.exclusive)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if c.minAvailable.String() != "" {
0000000000000000000000000000000000000000;;					createPDBMinAvailableOrDie(cs, ns, c.minAvailable)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if c.maxUnavailable.String() != "" {
0000000000000000000000000000000000000000;;					createPDBMaxUnavailableOrDie(cs, ns, c.maxUnavailable)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Locate a running pod.
0000000000000000000000000000000000000000;;				var pod v1.Pod
0000000000000000000000000000000000000000;;				err := wait.PollImmediate(framework.Poll, schedulingTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;					podList, err := cs.Pods(ns).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return false, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					for i := range podList.Items {
0000000000000000000000000000000000000000;;						if podList.Items[i].Status.Phase == v1.PodRunning {
0000000000000000000000000000000000000000;;							pod = podList.Items[i]
0000000000000000000000000000000000000000;;							return true, nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				e := &policy.Eviction{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      pod.Name,
0000000000000000000000000000000000000000;;						Namespace: ns,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if c.shouldDeny {
0000000000000000000000000000000000000000;;					// Since disruptionAllowed starts out false, wait at least 60s hoping that
0000000000000000000000000000000000000000;;					// this gives the controller enough time to have truly set the status.
0000000000000000000000000000000000000000;;					time.Sleep(timeout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					err = cs.Pods(ns).Evict(e)
0000000000000000000000000000000000000000;;					Expect(err).Should(MatchError("Cannot evict pod as it would violate the pod's disruption budget."))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Only wait for running pods in the "allow" case
0000000000000000000000000000000000000000;;					// because one of shouldDeny cases relies on the
0000000000000000000000000000000000000000;;					// replicaSet not fitting on the cluster.
0000000000000000000000000000000000000000;;					waitForPodsOrDie(cs, ns, c.podCount+int(c.replicaSetSize))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Since disruptionAllowed starts out false, if an eviction is ever allowed,
0000000000000000000000000000000000000000;;					// that means the controller is working.
0000000000000000000000000000000000000000;;					err = wait.PollImmediate(framework.Poll, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;						err = cs.Pods(ns).Evict(e)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return false, nil
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							return true, nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPDBMinAvailableOrDie(cs *kubernetes.Clientset, ns string, minAvailable intstr.IntOrString) {
0000000000000000000000000000000000000000;;		pdb := policy.PodDisruptionBudget{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: policy.PodDisruptionBudgetSpec{
0000000000000000000000000000000000000000;;				Selector:     &metav1.LabelSelector{MatchLabels: map[string]string{"foo": "bar"}},
0000000000000000000000000000000000000000;;				MinAvailable: &minAvailable,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := cs.Policy().PodDisruptionBudgets(ns).Create(&pdb)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPDBMaxUnavailableOrDie(cs *kubernetes.Clientset, ns string, maxUnavailable intstr.IntOrString) {
0000000000000000000000000000000000000000;;		pdb := policy.PodDisruptionBudget{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: policy.PodDisruptionBudgetSpec{
0000000000000000000000000000000000000000;;				Selector:       &metav1.LabelSelector{MatchLabels: map[string]string{"foo": "bar"}},
0000000000000000000000000000000000000000;;				MaxUnavailable: &maxUnavailable,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := cs.Policy().PodDisruptionBudgets(ns).Create(&pdb)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPodsOrDie(cs *kubernetes.Clientset, ns string, n int) {
0000000000000000000000000000000000000000;;		for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      fmt.Sprintf("pod-%d", i),
0000000000000000000000000000000000000000;;					Namespace: ns,
0000000000000000000000000000000000000000;;					Labels:    map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "busybox",
0000000000000000000000000000000000000000;;							Image: "gcr.io/google_containers/echoserver:1.6",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					RestartPolicy: v1.RestartPolicyAlways,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err := cs.Pods(ns).Create(pod)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err, "Creating pod %q in namespace %q", pod.Name, ns)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForPodsOrDie(cs *kubernetes.Clientset, ns string, n int) {
0000000000000000000000000000000000000000;;		By("Waiting for all pods to be running")
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(framework.Poll, schedulingTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			pods, err := cs.Core().Pods(ns).List(metav1.ListOptions{LabelSelector: "foo=bar"})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pods == nil {
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("pods is nil")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(pods.Items) < n {
0000000000000000000000000000000000000000;;				framework.Logf("pods: %v < %v", len(pods.Items), n)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ready := 0
0000000000000000000000000000000000000000;;			for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;				if pods.Items[i].Status.Phase == v1.PodRunning {
0000000000000000000000000000000000000000;;					ready++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ready < n {
0000000000000000000000000000000000000000;;				framework.Logf("running pods: %v < %v", ready, n)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Waiting for pods in namespace %q to be ready", ns)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createReplicaSetOrDie(cs *kubernetes.Clientset, ns string, size int32, exclusive bool) {
0000000000000000000000000000000000000000;;		container := v1.Container{
0000000000000000000000000000000000000000;;			Name:  "busybox",
0000000000000000000000000000000000000000;;			Image: "gcr.io/google_containers/echoserver:1.6",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if exclusive {
0000000000000000000000000000000000000000;;			container.Ports = []v1.ContainerPort{
0000000000000000000000000000000000000000;;				{HostPort: 5555, ContainerPort: 5555},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs := &extensions.ReplicaSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "rs",
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.ReplicaSetSpec{
0000000000000000000000000000000000000000;;				Replicas: &size,
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;					MatchLabels: map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{container},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := cs.Extensions().ReplicaSets(ns).Create(rs)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Creating replica set %q in namespace %q", rs.Name, ns)
0000000000000000000000000000000000000000;;	}
