0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
7378a0cb38d21d9c5b6304002e679b9e0c9d364d;test/e2e/basic.go[test/e2e/basic.go][test/e2e/workload/rc.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package workload
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/replication"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("ReplicationController", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("replication-controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should serve a basic image on each replica with a public image [Conformance]", func() {
0000000000000000000000000000000000000000;;			TestReplicationControllerServeImageOrFail(f, "basic", framework.ServeHostnameImage)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should serve a basic image on each replica with a private image", func() {
0000000000000000000000000000000000000000;;			// requires private images
0000000000000000000000000000000000000000;;			framework.SkipUnlessProviderIs("gce", "gke")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			TestReplicationControllerServeImageOrFail(f, "private", "gcr.io/k8s-authenticated-test/serve_hostname:v1.4")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should surface a failure condition on a common issue like exceeded quota", func() {
0000000000000000000000000000000000000000;;			testReplicationControllerConditionCheck(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should adopt matching pods on creation", func() {
0000000000000000000000000000000000000000;;			testRCAdoptMatchingOrphans(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should release no longer matching pods", func() {
0000000000000000000000000000000000000000;;			testRCReleaseControlledNotMatching(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRC(rsName string, replicas int32, rcPodLabels map[string]string, imageName string, image string) *v1.ReplicationController {
0000000000000000000000000000000000000000;;		zero := int64(0)
0000000000000000000000000000000000000000;;		return &v1.ReplicationController{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: rsName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;				Replicas: func(i int32) *int32 { return &i }(replicas),
0000000000000000000000000000000000000000;;				Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: rcPodLabels,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						TerminationGracePeriodSeconds: &zero,
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  imageName,
0000000000000000000000000000000000000000;;								Image: image,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A basic test to check the deployment of an image using
0000000000000000000000000000000000000000;;	// a replication controller. The image serves its hostname
0000000000000000000000000000000000000000;;	// which is checked for each replica.
0000000000000000000000000000000000000000;;	func TestReplicationControllerServeImageOrFail(f *framework.Framework, test string, image string) {
0000000000000000000000000000000000000000;;		name := "my-hostname-" + test + "-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;		replicas := int32(1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a replication controller for a service
0000000000000000000000000000000000000000;;		// that serves its hostname.
0000000000000000000000000000000000000000;;		// The source for the Docker containter kubernetes/serve_hostname is
0000000000000000000000000000000000000000;;		// in contrib/for-demos/serve_hostname
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating replication controller %s", name))
0000000000000000000000000000000000000000;;		newRC := newRC(name, replicas, map[string]string{"name": name}, name, image)
0000000000000000000000000000000000000000;;		newRC.Spec.Template.Spec.Containers[0].Ports = []v1.ContainerPort{{ContainerPort: 9376}}
0000000000000000000000000000000000000000;;		_, err := f.ClientSet.Core().ReplicationControllers(f.Namespace.Name).Create(newRC)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check that pods for the new RC were created.
0000000000000000000000000000000000000000;;		// TODO: Maybe switch PodsCreated to just check owner references.
0000000000000000000000000000000000000000;;		pods, err := framework.PodsCreated(f.ClientSet, f.Namespace.Name, name, replicas)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for the pods to enter the running state. Waiting loops until the pods
0000000000000000000000000000000000000000;;		// are running so non-running pods cause a timeout for this test.
0000000000000000000000000000000000000000;;		framework.Logf("Ensuring all pods for ReplicationController %q are running", name)
0000000000000000000000000000000000000000;;		running := int32(0)
0000000000000000000000000000000000000000;;		for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;			if pod.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = f.WaitForPodRunning(pod.Name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				updatePod, getErr := f.ClientSet.Core().Pods(f.Namespace.Name).Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if getErr == nil {
0000000000000000000000000000000000000000;;					err = fmt.Errorf("Pod %q never run (phase: %s, conditions: %+v): %v", updatePod.Name, updatePod.Status.Phase, updatePod.Status.Conditions, err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					err = fmt.Errorf("Pod %q never run: %v", pod.Name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			framework.Logf("Pod %q is running (conditions: %+v)", pod.Name, pod.Status.Conditions)
0000000000000000000000000000000000000000;;			running++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sanity check
0000000000000000000000000000000000000000;;		if running != replicas {
0000000000000000000000000000000000000000;;			Expect(fmt.Errorf("unexpected number of running pods: %+v", pods.Items)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify that something is listening.
0000000000000000000000000000000000000000;;		framework.Logf("Trying to dial the pod")
0000000000000000000000000000000000000000;;		retryTimeout := 2 * time.Minute
0000000000000000000000000000000000000000;;		retryInterval := 5 * time.Second
0000000000000000000000000000000000000000;;		label := labels.SelectorFromSet(labels.Set(map[string]string{"name": name}))
0000000000000000000000000000000000000000;;		err = wait.Poll(retryInterval, retryTimeout, framework.PodProxyResponseChecker(f.ClientSet, f.Namespace.Name, label, name, true, pods).CheckAllResponses)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Did not get expected responses within the timeout period of %.2f seconds.", retryTimeout.Seconds())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// 1. Create a quota restricting pods in the current namespace to 2.
0000000000000000000000000000000000000000;;	// 2. Create a replication controller that wants to run 3 pods.
0000000000000000000000000000000000000000;;	// 3. Check replication controller conditions for a ReplicaFailure condition.
0000000000000000000000000000000000000000;;	// 4. Relax quota or scale down the controller and observe the condition is gone.
0000000000000000000000000000000000000000;;	func testReplicationControllerConditionCheck(f *framework.Framework) {
0000000000000000000000000000000000000000;;		c := f.ClientSet
0000000000000000000000000000000000000000;;		namespace := f.Namespace.Name
0000000000000000000000000000000000000000;;		name := "condition-test"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Creating quota %q that allows only two pods to run in the current namespace", name)
0000000000000000000000000000000000000000;;		quota := newPodQuota(name, "2")
0000000000000000000000000000000000000000;;		_, err := c.Core().ResourceQuotas(namespace).Create(quota)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(1*time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			quota, err = c.Core().ResourceQuotas(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podQuota := quota.Status.Hard[v1.ResourcePods]
0000000000000000000000000000000000000000;;			quantity := resource.MustParse("2")
0000000000000000000000000000000000000000;;			return (&podQuota).Cmp(quantity) == 0, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("resource quota %q never synced", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating rc %q that asks for more than the allowed pod quota", name))
0000000000000000000000000000000000000000;;		rc := newRC(name, 3, map[string]string{"name": name}, NginxImageName, NginxImage)
0000000000000000000000000000000000000000;;		rc, err = c.Core().ReplicationControllers(namespace).Create(rc)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Checking rc %q has the desired failure condition set", name))
0000000000000000000000000000000000000000;;		generation := rc.Generation
0000000000000000000000000000000000000000;;		conditions := rc.Status.Conditions
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(1*time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			rc, err = c.Core().ReplicationControllers(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if generation > rc.Status.ObservedGeneration {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			conditions = rc.Status.Conditions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cond := replication.GetCondition(rc.Status, v1.ReplicationControllerReplicaFailure)
0000000000000000000000000000000000000000;;			return cond != nil, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("rc manager never added the failure condition for rc %q: %#v", name, conditions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Scaling down rc %q to satisfy pod quota", name))
0000000000000000000000000000000000000000;;		rc, err = framework.UpdateReplicationControllerWithRetries(c, namespace, name, func(update *v1.ReplicationController) {
0000000000000000000000000000000000000000;;			x := int32(2)
0000000000000000000000000000000000000000;;			update.Spec.Replicas = &x
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Checking rc %q has no failure condition set", name))
0000000000000000000000000000000000000000;;		generation = rc.Generation
0000000000000000000000000000000000000000;;		conditions = rc.Status.Conditions
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(1*time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			rc, err = c.Core().ReplicationControllers(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if generation > rc.Status.ObservedGeneration {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			conditions = rc.Status.Conditions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cond := replication.GetCondition(rc.Status, v1.ReplicationControllerReplicaFailure)
0000000000000000000000000000000000000000;;			return cond == nil, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("rc manager never removed the failure condition for rc %q: %#v", name, conditions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testRCAdoptMatchingOrphans(f *framework.Framework) {
0000000000000000000000000000000000000000;;		name := "pod-adoption"
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Given a Pod with a 'name' label %s is created", name))
0000000000000000000000000000000000000000;;		p := f.PodClient().CreateSync(&v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"name": name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  name,
0000000000000000000000000000000000000000;;						Image: NginxImageName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("When a replication controller with a matching selector is created")
0000000000000000000000000000000000000000;;		replicas := int32(1)
0000000000000000000000000000000000000000;;		rcSt := newRC(name, replicas, map[string]string{"name": name}, name, NginxImageName)
0000000000000000000000000000000000000000;;		rcSt.Spec.Selector = map[string]string{"name": name}
0000000000000000000000000000000000000000;;		rc, err := f.ClientSet.Core().ReplicationControllers(f.Namespace.Name).Create(rcSt)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Then the orphan pod is adopted")
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(1*time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			p2, err := f.ClientSet.Core().Pods(f.Namespace.Name).Get(p.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			// The Pod p should either be adopted or deleted by the RC
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			for _, owner := range p2.OwnerReferences {
0000000000000000000000000000000000000000;;				if *owner.Controller && owner.UID == rc.UID {
0000000000000000000000000000000000000000;;					// pod adopted
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// pod still not adopted
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testRCReleaseControlledNotMatching(f *framework.Framework) {
0000000000000000000000000000000000000000;;		name := "pod-release"
0000000000000000000000000000000000000000;;		By("Given a ReplicationController is created")
0000000000000000000000000000000000000000;;		replicas := int32(1)
0000000000000000000000000000000000000000;;		rcSt := newRC(name, replicas, map[string]string{"name": name}, name, NginxImageName)
0000000000000000000000000000000000000000;;		rcSt.Spec.Selector = map[string]string{"name": name}
0000000000000000000000000000000000000000;;		rc, err := f.ClientSet.Core().ReplicationControllers(f.Namespace.Name).Create(rcSt)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("When the matched label of one of its pods change")
0000000000000000000000000000000000000000;;		pods, err := framework.PodsCreated(f.ClientSet, f.Namespace.Name, rc.Name, replicas)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := pods.Items[0]
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(1*time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			pod, err := f.ClientSet.Core().Pods(f.Namespace.Name).Get(p.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod.Labels = map[string]string{"name": "not-matching-name"}
0000000000000000000000000000000000000000;;			_, err = f.ClientSet.Core().Pods(f.Namespace.Name).Update(pod)
0000000000000000000000000000000000000000;;			if err != nil && errors.IsConflict(err) {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Then the pod is released")
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(1*time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			p2, err := f.ClientSet.Core().Pods(f.Namespace.Name).Get(p.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			for _, owner := range p2.OwnerReferences {
0000000000000000000000000000000000000000;;				if *owner.Controller && owner.UID == rc.UID {
0000000000000000000000000000000000000000;;					// pod still belonging to the replication controller
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// pod already released
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	}
