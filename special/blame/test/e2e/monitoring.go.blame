0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
61319b1be77a71cf2a81dd4b5035a918eb4fe03b;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		influxdb "github.com/influxdata/influxdb/client/v2"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Monitoring", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("monitoring")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			framework.SkipUnlessProviderIs("gce")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should verify monitoring pods and all cluster nodes are available on influxdb using heapster.", func() {
0000000000000000000000000000000000000000;;			testMonitoringUsingHeapsterInfluxdb(f.ClientSet)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		influxdbService       = "monitoring-influxdb"
0000000000000000000000000000000000000000;;		influxdbDatabaseName  = "k8s"
0000000000000000000000000000000000000000;;		podlistQuery          = "show tag values from \"cpu/usage\" with key = pod_name"
0000000000000000000000000000000000000000;;		nodelistQuery         = "show tag values from \"cpu/usage\" with key = nodename"
0000000000000000000000000000000000000000;;		sleepBetweenAttempts  = 5 * time.Second
0000000000000000000000000000000000000000;;		testTimeout           = 5 * time.Minute
0000000000000000000000000000000000000000;;		initializationTimeout = 5 * time.Minute
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		rcLabels         = []string{"heapster", "influxGrafana"}
0000000000000000000000000000000000000000;;		expectedServices = map[string]bool{
0000000000000000000000000000000000000000;;			influxdbService:      false,
0000000000000000000000000000000000000000;;			"monitoring-grafana": false,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Query sends a command to the server and returns the Response
0000000000000000000000000000000000000000;;	func Query(c clientset.Interface, query string) (*influxdb.Response, error) {
0000000000000000000000000000000000000000;;		subResourceProxyAvailable, err := framework.ServerVersionGTE(framework.SubResourceServiceAndNodeProxyVersion, c.Discovery())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithTimeout(context.Background(), framework.SingleCallTimeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var result []byte
0000000000000000000000000000000000000000;;		if subResourceProxyAvailable {
0000000000000000000000000000000000000000;;			result, err = c.Core().RESTClient().Get().
0000000000000000000000000000000000000000;;				Context(ctx).
0000000000000000000000000000000000000000;;				Namespace("kube-system").
0000000000000000000000000000000000000000;;				Resource("services").
0000000000000000000000000000000000000000;;				Name(influxdbService+":api").
0000000000000000000000000000000000000000;;				SubResource("proxy").
0000000000000000000000000000000000000000;;				Suffix("query").
0000000000000000000000000000000000000000;;				Param("q", query).
0000000000000000000000000000000000000000;;				Param("db", influxdbDatabaseName).
0000000000000000000000000000000000000000;;				Param("epoch", "s").
0000000000000000000000000000000000000000;;				Do().
0000000000000000000000000000000000000000;;				Raw()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			result, err = c.Core().RESTClient().Get().
0000000000000000000000000000000000000000;;				Context(ctx).
0000000000000000000000000000000000000000;;				Prefix("proxy").
0000000000000000000000000000000000000000;;				Namespace("kube-system").
0000000000000000000000000000000000000000;;				Resource("services").
0000000000000000000000000000000000000000;;				Name(influxdbService+":api").
0000000000000000000000000000000000000000;;				Suffix("query").
0000000000000000000000000000000000000000;;				Param("q", query).
0000000000000000000000000000000000000000;;				Param("db", influxdbDatabaseName).
0000000000000000000000000000000000000000;;				Param("epoch", "s").
0000000000000000000000000000000000000000;;				Do().
0000000000000000000000000000000000000000;;				Raw()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if ctx.Err() != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to query influx db: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var response influxdb.Response
0000000000000000000000000000000000000000;;		dec := json.NewDecoder(bytes.NewReader(result))
0000000000000000000000000000000000000000;;		dec.UseNumber()
0000000000000000000000000000000000000000;;		err = dec.Decode(&response)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &response, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyExpectedRcsExistAndGetExpectedPods(c clientset.Interface) ([]string, error) {
0000000000000000000000000000000000000000;;		expectedPods := []string{}
0000000000000000000000000000000000000000;;		// Iterate over the labels that identify the replication controllers that we
0000000000000000000000000000000000000000;;		// want to check. The rcLabels contains the value values for the k8s-app key
0000000000000000000000000000000000000000;;		// that identify the replication controllers that we want to check. Using a label
0000000000000000000000000000000000000000;;		// rather than an explicit name is preferred because the names will typically have
0000000000000000000000000000000000000000;;		// a version suffix e.g. heapster-monitoring-v1 and this will change after a rolling
0000000000000000000000000000000000000000;;		// update e.g. to heapster-monitoring-v2. By using a label query we can check for the
0000000000000000000000000000000000000000;;		// situation when a heapster-monitoring-v1 and heapster-monitoring-v2 replication controller
0000000000000000000000000000000000000000;;		// is running (which would be an error except during a rolling update).
0000000000000000000000000000000000000000;;		for _, rcLabel := range rcLabels {
0000000000000000000000000000000000000000;;			selector := labels.Set{"k8s-app": rcLabel}.AsSelector()
0000000000000000000000000000000000000000;;			options := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;			deploymentList, err := c.Extensions().Deployments(metav1.NamespaceSystem).List(options)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rcList, err := c.Core().ReplicationControllers(metav1.NamespaceSystem).List(options)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			psList, err := c.Apps().StatefulSets(metav1.NamespaceSystem).List(options)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if (len(rcList.Items) + len(deploymentList.Items) + len(psList.Items)) != 1 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("expected to find one replica for RC or deployment with label %s but got %d",
0000000000000000000000000000000000000000;;					rcLabel, len(rcList.Items))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Check all the replication controllers.
0000000000000000000000000000000000000000;;			for _, rc := range rcList.Items {
0000000000000000000000000000000000000000;;				selector := labels.Set(rc.Spec.Selector).AsSelector()
0000000000000000000000000000000000000000;;				options := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;				podList, err := c.Core().Pods(metav1.NamespaceSystem).List(options)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, pod := range podList.Items {
0000000000000000000000000000000000000000;;					if pod.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					expectedPods = append(expectedPods, pod.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Do the same for all deployments.
0000000000000000000000000000000000000000;;			for _, rc := range deploymentList.Items {
0000000000000000000000000000000000000000;;				selector := labels.Set(rc.Spec.Selector.MatchLabels).AsSelector()
0000000000000000000000000000000000000000;;				options := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;				podList, err := c.Core().Pods(metav1.NamespaceSystem).List(options)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, pod := range podList.Items {
0000000000000000000000000000000000000000;;					if pod.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					expectedPods = append(expectedPods, pod.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// And for pet sets.
0000000000000000000000000000000000000000;;			for _, ps := range psList.Items {
0000000000000000000000000000000000000000;;				selector := labels.Set(ps.Spec.Selector.MatchLabels).AsSelector()
0000000000000000000000000000000000000000;;				options := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;				podList, err := c.Core().Pods(metav1.NamespaceSystem).List(options)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, pod := range podList.Items {
0000000000000000000000000000000000000000;;					if pod.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					expectedPods = append(expectedPods, pod.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return expectedPods, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectedServicesExist(c clientset.Interface) error {
0000000000000000000000000000000000000000;;		serviceList, err := c.Core().Services(metav1.NamespaceSystem).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, service := range serviceList.Items {
0000000000000000000000000000000000000000;;			if _, ok := expectedServices[service.Name]; ok {
0000000000000000000000000000000000000000;;				expectedServices[service.Name] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for service, found := range expectedServices {
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Service %q not found", service)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getAllNodesInCluster(c clientset.Interface) ([]string, error) {
0000000000000000000000000000000000000000;;		// It should be OK to list unschedulable Nodes here.
0000000000000000000000000000000000000000;;		nodeList, err := c.Core().Nodes().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := []string{}
0000000000000000000000000000000000000000;;		for _, node := range nodeList.Items {
0000000000000000000000000000000000000000;;			result = append(result, node.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getInfluxdbData(c clientset.Interface, query string, tag string) (map[string]bool, error) {
0000000000000000000000000000000000000000;;		response, err := Query(c, query)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(response.Results) != 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("expected only one result from Influxdb for query %q. Got %+v", query, response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(response.Results[0].Series) != 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("expected exactly one series for query %q.", query)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(response.Results[0].Series[0].Columns) != 2 {
0000000000000000000000000000000000000000;;			framework.Failf("Expected two columns for query %q. Found %v", query, response.Results[0].Series[0].Columns)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := map[string]bool{}
0000000000000000000000000000000000000000;;		for _, value := range response.Results[0].Series[0].Values {
0000000000000000000000000000000000000000;;			name := value[1].(string)
0000000000000000000000000000000000000000;;			result[name] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectedItemsExist(expectedItems []string, actualItems map[string]bool) bool {
0000000000000000000000000000000000000000;;		if len(actualItems) < len(expectedItems) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range expectedItems {
0000000000000000000000000000000000000000;;			if _, found := actualItems[item]; !found {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validatePodsAndNodes(c clientset.Interface, expectedPods, expectedNodes []string) bool {
0000000000000000000000000000000000000000;;		pods, err := getInfluxdbData(c, podlistQuery, "pod_id")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// We don't fail the test here because the influxdb service might still not be running.
0000000000000000000000000000000000000000;;			framework.Logf("failed to query list of pods from influxdb. Query: %q, Err: %v", podlistQuery, err)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodes, err := getInfluxdbData(c, nodelistQuery, "hostname")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Logf("failed to query list of nodes from influxdb. Query: %q, Err: %v", nodelistQuery, err)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !expectedItemsExist(expectedPods, pods) {
0000000000000000000000000000000000000000;;			framework.Logf("failed to find all expected Pods.\nExpected: %v\nActual: %v", expectedPods, pods)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !expectedItemsExist(expectedNodes, nodes) {
0000000000000000000000000000000000000000;;			framework.Logf("failed to find all expected Nodes.\nExpected: %v\nActual: %v", expectedNodes, nodes)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testMonitoringUsingHeapsterInfluxdb(c clientset.Interface) {
0000000000000000000000000000000000000000;;		// Check if heapster pods and services are up.
0000000000000000000000000000000000000000;;		var expectedPods []string
0000000000000000000000000000000000000000;;		rcErr := fmt.Errorf("failed to verify expected RCs within timeout")
0000000000000000000000000000000000000000;;		serviceErr := fmt.Errorf("failed to verify expected services within timeout")
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(sleepBetweenAttempts, initializationTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			expectedPods, rcErr = verifyExpectedRcsExistAndGetExpectedPods(c)
0000000000000000000000000000000000000000;;			if rcErr != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Waiting for expected RCs (got error: %v)", rcErr)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			serviceErr = expectedServicesExist(c)
0000000000000000000000000000000000000000;;			if serviceErr != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Waiting for expected services (got error: %v)", serviceErr)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.ExpectNoError(rcErr)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(serviceErr)
0000000000000000000000000000000000000000;;			framework.Failf("Failed to verify RCs and services within timeout: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedNodes, err := getAllNodesInCluster(c)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if validatePodsAndNodes(c, expectedPods, expectedNodes) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if time.Since(startTime) >= testTimeout {
0000000000000000000000000000000000000000;;				// temporary workaround to help debug issue #12765
0000000000000000000000000000000000000000;;				printDebugInfo(c)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			time.Sleep(sleepBetweenAttempts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.Failf("monitoring using heapster and influxdb test failed")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printDebugInfo(c clientset.Interface) {
0000000000000000000000000000000000000000;;		set := labels.Set{"k8s-app": "heapster"}
0000000000000000000000000000000000000000;;		options := metav1.ListOptions{LabelSelector: set.AsSelector().String()}
0000000000000000000000000000000000000000;;		podList, err := c.Core().Pods(metav1.NamespaceSystem).List(options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Logf("Error while listing pods %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pod := range podList.Items {
0000000000000000000000000000000000000000;;			framework.Logf("Kubectl output:\n%v",
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("log", pod.Name, "--namespace=kube-system", "--container=heapster"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
