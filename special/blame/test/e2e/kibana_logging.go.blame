0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
e672c315d57429ca3b51b8eea86fba769781af67;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Kibana Logging Instances Is Alive [Feature:Elasticsearch]", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("kibana-logging")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			// TODO: For now assume we are only testing cluster logging with Elasticsearch
0000000000000000000000000000000000000000;;			// and Kibana on GCE. Once we are sure that Elasticsearch and Kibana cluster level logging
0000000000000000000000000000000000000000;;			// works for other providers we should widen this scope of this test.
0000000000000000000000000000000000000000;;			framework.SkipUnlessProviderIs("gce")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should check that the Kibana logging instance is alive", func() {
0000000000000000000000000000000000000000;;			ClusterLevelLoggingWithKibana(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		kibanaKey   = "k8s-app"
0000000000000000000000000000000000000000;;		kibanaValue = "kibana-logging"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClusterLevelLoggingWithKibana is an end to end test that checks to see if Kibana is alive.
0000000000000000000000000000000000000000;;	func ClusterLevelLoggingWithKibana(f *framework.Framework) {
0000000000000000000000000000000000000000;;		// graceTime is how long to keep retrying requests for status information.
0000000000000000000000000000000000000000;;		const graceTime = 20 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check for the existence of the Kibana service.
0000000000000000000000000000000000000000;;		By("Checking the Kibana service exists.")
0000000000000000000000000000000000000000;;		s := f.ClientSet.Core().Services(metav1.NamespaceSystem)
0000000000000000000000000000000000000000;;		// Make a few attempts to connect. This makes the test robust against
0000000000000000000000000000000000000000;;		// being run as the first e2e test just after the e2e cluster has been created.
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < graceTime; time.Sleep(5 * time.Second) {
0000000000000000000000000000000000000000;;			if _, err = s.Get("kibana-logging", metav1.GetOptions{}); err == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.Logf("Attempt to check for the existence of the Kibana service failed after %v", time.Since(start))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for the Kibana pod(s) to enter the running state.
0000000000000000000000000000000000000000;;		By("Checking to make sure the Kibana pods are running")
0000000000000000000000000000000000000000;;		label := labels.SelectorFromSet(labels.Set(map[string]string{kibanaKey: kibanaValue}))
0000000000000000000000000000000000000000;;		options := metav1.ListOptions{LabelSelector: label.String()}
0000000000000000000000000000000000000000;;		pods, err := f.ClientSet.Core().Pods(metav1.NamespaceSystem).List(options)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;			err = framework.WaitForPodRunningInNamespace(f.ClientSet, &pod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Checking to make sure we get a response from the Kibana UI.")
0000000000000000000000000000000000000000;;		err = nil
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < graceTime; time.Sleep(5 * time.Second) {
0000000000000000000000000000000000000000;;			proxyRequest, errProxy := framework.GetServicesProxyRequest(f.ClientSet, f.ClientSet.Core().RESTClient().Get())
0000000000000000000000000000000000000000;;			if errProxy != nil {
0000000000000000000000000000000000000000;;				framework.Logf("After %v failed to get services proxy request: %v", time.Since(start), errProxy)
0000000000000000000000000000000000000000;;				err = errProxy
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ctx, cancel := context.WithTimeout(context.Background(), framework.SingleCallTimeout)
0000000000000000000000000000000000000000;;			defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Query against the root URL for Kibana.
0000000000000000000000000000000000000000;;			_, err = proxyRequest.Namespace(metav1.NamespaceSystem).
0000000000000000000000000000000000000000;;				Context(ctx).
0000000000000000000000000000000000000000;;				Name("kibana-logging").
0000000000000000000000000000000000000000;;				DoRaw()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if ctx.Err() != nil {
0000000000000000000000000000000000000000;;					framework.Failf("After %v proxy call to kibana-logging failed: %v", time.Since(start), err)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.Logf("After %v proxy call to kibana-logging failed: %v", time.Since(start), err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	}
