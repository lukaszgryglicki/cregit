0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
ca32caac3865328aaceb137425681e2fd25c1e44;test/e2e/vsphere_volume_diskformat.go[test/e2e/vsphere_volume_diskformat.go][test/e2e/storage/vsphere_volume_diskformat.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/find"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		k8stype "k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		vsphere "k8s.io/kubernetes/pkg/cloudprovider/providers/vsphere"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Test to verify diskformat specified in storage-class is being honored while volume creation.
0000000000000000000000000000000000000000;;		Valid and supported options are eagerzeroedthick, zeroedthick and thin
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Steps
0000000000000000000000000000000000000000;;		1. Create StorageClass with diskformat set to valid type
0000000000000000000000000000000000000000;;		2. Create PVC which uses the StorageClass created in step 1.
0000000000000000000000000000000000000000;;		3. Wait for PV to be provisioned.
0000000000000000000000000000000000000000;;		4. Wait for PVC's status to become Bound
0000000000000000000000000000000000000000;;		5. Create pod using PVC on specific node.
0000000000000000000000000000000000000000;;		6. Wait for Disk to be attached to the node.
0000000000000000000000000000000000000000;;		7. Get node VM's devices and find PV's Volume Disk.
0000000000000000000000000000000000000000;;		8. Get Backing Info of the Volume Disk and obtain EagerlyScrub and ThinProvisioned
0000000000000000000000000000000000000000;;		9. Based on the value of EagerlyScrub and ThinProvisioned, verify diskformat is correct.
0000000000000000000000000000000000000000;;		10. Delete pod and Wait for Volume Disk to be detached from the Node.
0000000000000000000000000000000000000000;;		11. Delete PVC, PV and Storage Class
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("Volume Disk Format", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("volume-disk-format")
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			client            clientset.Interface
0000000000000000000000000000000000000000;;			namespace         string
0000000000000000000000000000000000000000;;			nodeName          string
0000000000000000000000000000000000000000;;			isNodeLabeled     bool
0000000000000000000000000000000000000000;;			nodeKeyValueLabel map[string]string
0000000000000000000000000000000000000000;;			nodeLabelValue    string
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			framework.SkipUnlessProviderIs("vsphere")
0000000000000000000000000000000000000000;;			client = f.ClientSet
0000000000000000000000000000000000000000;;			namespace = f.Namespace.Name
0000000000000000000000000000000000000000;;			nodeList := framework.GetReadySchedulableNodesOrDie(f.ClientSet)
0000000000000000000000000000000000000000;;			if len(nodeList.Items) != 0 {
0000000000000000000000000000000000000000;;				nodeName = nodeList.Items[0].Name
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				framework.Failf("Unable to find ready and schedulable Node")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !isNodeLabeled {
0000000000000000000000000000000000000000;;				nodeLabelValue := "vsphere_e2e_" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;				nodeKeyValueLabel = make(map[string]string)
0000000000000000000000000000000000000000;;				nodeKeyValueLabel["vsphere_e2e_label"] = nodeLabelValue
0000000000000000000000000000000000000000;;				framework.AddOrUpdateLabelOnNode(client, nodeName, "vsphere_e2e_label", nodeLabelValue)
0000000000000000000000000000000000000000;;				isNodeLabeled = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		framework.AddCleanupAction(func() {
0000000000000000000000000000000000000000;;			if len(nodeLabelValue) > 0 {
0000000000000000000000000000000000000000;;				framework.RemoveLabelOffNode(client, nodeName, "vsphere_e2e_label")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("verify disk format type - eagerzeroedthick is honored for dynamically provisioned pv using storageclass", func() {
0000000000000000000000000000000000000000;;			By("Invoking Test for diskformat: eagerzeroedthick")
0000000000000000000000000000000000000000;;			invokeTest(f, client, namespace, nodeName, nodeKeyValueLabel, "eagerzeroedthick")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		It("verify disk format type - zeroedthick is honored for dynamically provisioned pv using storageclass", func() {
0000000000000000000000000000000000000000;;			By("Invoking Test for diskformat: zeroedthick")
0000000000000000000000000000000000000000;;			invokeTest(f, client, namespace, nodeName, nodeKeyValueLabel, "zeroedthick")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		It("verify disk format type - thin is honored for dynamically provisioned pv using storageclass", func() {
0000000000000000000000000000000000000000;;			By("Invoking Test for diskformat: thin")
0000000000000000000000000000000000000000;;			invokeTest(f, client, namespace, nodeName, nodeKeyValueLabel, "thin")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func invokeTest(f *framework.Framework, client clientset.Interface, namespace string, nodeName string, nodeKeyValueLabel map[string]string, diskFormat string) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Invoking Test for DiskFomat: %s", diskFormat)
0000000000000000000000000000000000000000;;		scParameters := make(map[string]string)
0000000000000000000000000000000000000000;;		scParameters["diskformat"] = diskFormat
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating Storage Class With DiskFormat")
0000000000000000000000000000000000000000;;		storageClassSpec := getVSphereStorageClassSpec("thinsc", scParameters)
0000000000000000000000000000000000000000;;		storageclass, err := client.StorageV1().StorageClasses().Create(storageClassSpec)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer client.StorageV1().StorageClasses().Delete(storageclass.Name, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating PVC using the Storage Class")
0000000000000000000000000000000000000000;;		pvclaimSpec := getVSphereClaimSpecWithStorageClassAnnotation(namespace, storageclass)
0000000000000000000000000000000000000000;;		pvclaim, err := client.CoreV1().PersistentVolumeClaims(namespace).Create(pvclaimSpec)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			client.CoreV1().PersistentVolumeClaims(namespace).Delete(pvclaimSpec.Name, nil)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Waiting for claim to be in bound phase")
0000000000000000000000000000000000000000;;		err = framework.WaitForPersistentVolumeClaimPhase(v1.ClaimBound, client, pvclaim.Namespace, pvclaim.Name, framework.Poll, framework.ClaimProvisionTimeout)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get new copy of the claim
0000000000000000000000000000000000000000;;		pvclaim, err = client.CoreV1().PersistentVolumeClaims(pvclaim.Namespace).Get(pvclaim.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the bound PV
0000000000000000000000000000000000000000;;		pv, err := client.CoreV1().PersistentVolumes().Get(pvclaim.Spec.VolumeName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			PV is required to be attached to the Node. so that using govmomi API we can grab Disk's Backing Info
0000000000000000000000000000000000000000;;			to check EagerlyScrub and ThinProvisioned property
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;		By("Creating pod to attach PV to the node")
0000000000000000000000000000000000000000;;		// Create pod to attach Volume to Node
0000000000000000000000000000000000000000;;		podSpec := getVSpherePodSpecWithClaim(pvclaim.Name, nodeKeyValueLabel, "while true ; do sleep 2 ; done")
0000000000000000000000000000000000000000;;		pod, err := client.CoreV1().Pods(namespace).Create(podSpec)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vsp, err := vsphere.GetVSphere()
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		verifyVSphereDiskAttached(vsp, pv.Spec.VsphereVolume.VolumePath, k8stype.NodeName(nodeName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Waiting for pod to be running")
0000000000000000000000000000000000000000;;		Expect(framework.WaitForPodNameRunningInNamespace(client, pod.Name, namespace)).To(Succeed())
0000000000000000000000000000000000000000;;		Expect(verifyDiskFormat(nodeName, pv.Spec.VsphereVolume.VolumePath, diskFormat)).To(BeTrue(), "DiskFormat Verification Failed")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var volumePaths []string
0000000000000000000000000000000000000000;;		volumePaths = append(volumePaths, pv.Spec.VsphereVolume.VolumePath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Delete pod and wait for volume to be detached from node")
0000000000000000000000000000000000000000;;		deletePodAndWaitForVolumeToDetach(f, client, pod, vsp, nodeName, volumePaths)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyDiskFormat(nodeName string, pvVolumePath string, diskFormat string) bool {
0000000000000000000000000000000000000000;;		By("Verifing disk format")
0000000000000000000000000000000000000000;;		eagerlyScrub := false
0000000000000000000000000000000000000000;;		thinProvisioned := false
0000000000000000000000000000000000000000;;		diskFound := false
0000000000000000000000000000000000000000;;		pvvmdkfileName := filepath.Base(pvVolumePath) + filepath.Ext(pvVolumePath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		govMoMiClient, err := vsphere.GetgovmomiClient(nil)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f := find.NewFinder(govMoMiClient.Client, true)
0000000000000000000000000000000000000000;;		ctx, _ := context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;		vm, err := f.VirtualMachine(ctx, os.Getenv("VSPHERE_WORKING_DIR")+nodeName)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vmDevices, err := vm.Device(ctx)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		disks := vmDevices.SelectByType((*types.VirtualDisk)(nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, disk := range disks {
0000000000000000000000000000000000000000;;			backing := disk.GetVirtualDevice().Backing.(*types.VirtualDiskFlatVer2BackingInfo)
0000000000000000000000000000000000000000;;			backingFileName := filepath.Base(backing.FileName) + filepath.Ext(backing.FileName)
0000000000000000000000000000000000000000;;			if backingFileName == pvvmdkfileName {
0000000000000000000000000000000000000000;;				diskFound = true
0000000000000000000000000000000000000000;;				if backing.EagerlyScrub != nil {
0000000000000000000000000000000000000000;;					eagerlyScrub = *backing.EagerlyScrub
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if backing.ThinProvisioned != nil {
0000000000000000000000000000000000000000;;					thinProvisioned = *backing.ThinProvisioned
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Expect(diskFound).To(BeTrue(), "Failed to find disk")
0000000000000000000000000000000000000000;;		isDiskFormatCorrect := false
0000000000000000000000000000000000000000;;		if diskFormat == "eagerzeroedthick" {
0000000000000000000000000000000000000000;;			if eagerlyScrub == true && thinProvisioned == false {
0000000000000000000000000000000000000000;;				isDiskFormatCorrect = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if diskFormat == "zeroedthick" {
0000000000000000000000000000000000000000;;			if eagerlyScrub == false && thinProvisioned == false {
0000000000000000000000000000000000000000;;				isDiskFormatCorrect = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if diskFormat == "thin" {
0000000000000000000000000000000000000000;;			if eagerlyScrub == false && thinProvisioned == true {
0000000000000000000000000000000000000000;;				isDiskFormatCorrect = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return isDiskFormatCorrect
0000000000000000000000000000000000000000;;	}
