0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
d01e7fe5ceb5c93f3cf24c15a8b2c85be2676673;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		storage "k8s.io/api/storage/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		k8stype "k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/vsphere"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Test to verify fstype specified in storage-class is being honored after volume creation.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Steps
0000000000000000000000000000000000000000;;		1. Create StorageClass with fstype set to valid type (default case included).
0000000000000000000000000000000000000000;;		2. Create PVC which uses the StorageClass created in step 1.
0000000000000000000000000000000000000000;;		3. Wait for PV to be provisioned.
0000000000000000000000000000000000000000;;		4. Wait for PVC's status to become Bound.
0000000000000000000000000000000000000000;;		5. Create pod using PVC on specific node.
0000000000000000000000000000000000000000;;		6. Wait for Disk to be attached to the node.
0000000000000000000000000000000000000000;;		7. Execute command in the pod to get fstype.
0000000000000000000000000000000000000000;;		8. Delete pod and Wait for Volume Disk to be detached from the Node.
0000000000000000000000000000000000000000;;		9. Delete PVC, PV and Storage Class.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("vsphere Volume fstype", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("volume-fstype")
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			client       clientset.Interface
0000000000000000000000000000000000000000;;			namespace    string
0000000000000000000000000000000000000000;;			storageclass *storage.StorageClass
0000000000000000000000000000000000000000;;			pvclaim      *v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			framework.SkipUnlessProviderIs("vsphere")
0000000000000000000000000000000000000000;;			client = f.ClientSet
0000000000000000000000000000000000000000;;			namespace = f.Namespace.Name
0000000000000000000000000000000000000000;;			nodeList := framework.GetReadySchedulableNodesOrDie(f.ClientSet)
0000000000000000000000000000000000000000;;			Expect(len(nodeList.Items)).NotTo(BeZero(), "Unable to find ready and schedulable Node")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		AfterEach(func() {
0000000000000000000000000000000000000000;;			var scDeleteError error
0000000000000000000000000000000000000000;;			var pvDeleteError error
0000000000000000000000000000000000000000;;			if storageclass != nil {
0000000000000000000000000000000000000000;;				scDeleteError = client.StorageV1beta1().StorageClasses().Delete(storageclass.Name, nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pvclaim != nil {
0000000000000000000000000000000000000000;;				pvDeleteError = client.CoreV1().PersistentVolumeClaims(namespace).Delete(pvclaim.Name, nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.ExpectNoError(scDeleteError)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(pvDeleteError)
0000000000000000000000000000000000000000;;			storageclass = nil
0000000000000000000000000000000000000000;;			pvclaim = nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("verify fstype - ext3 formatted volume", func() {
0000000000000000000000000000000000000000;;			By("Invoking Test for fstype: ext3")
0000000000000000000000000000000000000000;;			storageclass, pvclaim = invokeTestForFstype(f, client, namespace, "ext3", "ext3")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("verify disk format type - default value should be ext4", func() {
0000000000000000000000000000000000000000;;			By("Invoking Test for fstype: Default Value")
0000000000000000000000000000000000000000;;			storageclass, pvclaim = invokeTestForFstype(f, client, namespace, "", "ext4")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func invokeTestForFstype(f *framework.Framework, client clientset.Interface, namespace string, fstype string, expectedContent string) (*storage.StorageClass, *v1.PersistentVolumeClaim) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Invoking Test for fstype: %s", fstype)
0000000000000000000000000000000000000000;;		scParameters := make(map[string]string)
0000000000000000000000000000000000000000;;		scParameters["fstype"] = fstype
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating Storage Class With Fstype")
0000000000000000000000000000000000000000;;		storageClassSpec := getVSphereStorageClassSpec("fstype", scParameters)
0000000000000000000000000000000000000000;;		storageclass, err := client.StorageV1().StorageClasses().Create(storageClassSpec)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating PVC using the Storage Class")
0000000000000000000000000000000000000000;;		pvclaimSpec := getVSphereClaimSpecWithStorageClassAnnotation(namespace, storageclass)
0000000000000000000000000000000000000000;;		pvclaim, err := client.CoreV1().PersistentVolumeClaims(namespace).Create(pvclaimSpec)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Waiting for claim to be in bound phase")
0000000000000000000000000000000000000000;;		err = framework.WaitForPersistentVolumeClaimPhase(v1.ClaimBound, client, pvclaim.Namespace, pvclaim.Name, framework.Poll, framework.ClaimProvisionTimeout)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get new copy of the claim
0000000000000000000000000000000000000000;;		pvclaim, err = client.CoreV1().PersistentVolumeClaims(pvclaim.Namespace).Get(pvclaim.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the bound PV
0000000000000000000000000000000000000000;;		pv, err := client.CoreV1().PersistentVolumes().Get(pvclaim.Spec.VolumeName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating pod to attach PV to the node")
0000000000000000000000000000000000000000;;		// Create pod to attach Volume to Node
0000000000000000000000000000000000000000;;		podSpec := getVSpherePodSpecWithClaim(pvclaim.Name, nil, "/bin/df -T /mnt/test | /bin/awk 'FNR == 2 {print $2}' > /mnt/test/fstype && while true ; do sleep 2 ; done")
0000000000000000000000000000000000000000;;		pod, err := client.CoreV1().Pods(namespace).Create(podSpec)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Waiting for pod to be running")
0000000000000000000000000000000000000000;;		Expect(framework.WaitForPodNameRunningInNamespace(client, pod.Name, namespace)).To(Succeed())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod, err = client.CoreV1().Pods(namespace).Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Asserts: Right disk is attached to the pod
0000000000000000000000000000000000000000;;		vsp, err := vsphere.GetVSphere()
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		isAttached, err := verifyVSphereDiskAttached(vsp, pv.Spec.VsphereVolume.VolumePath, k8stype.NodeName(pod.Spec.NodeName))
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(isAttached).To(BeTrue(), "disk is not attached with the node")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = framework.LookForStringInPodExec(namespace, pod.Name, []string{"/bin/cat", "/mnt/test/fstype"}, expectedContent, time.Minute)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var volumePaths []string
0000000000000000000000000000000000000000;;		volumePaths = append(volumePaths, pv.Spec.VsphereVolume.VolumePath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Delete pod and wait for volume to be detached from node")
0000000000000000000000000000000000000000;;		deletePodAndWaitForVolumeToDetach(f, client, pod, vsp, pod.Spec.NodeName, volumePaths)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return storageclass, pvclaim
0000000000000000000000000000000000000000;;	}
