0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
7016b0c20024fcbd009308d00247c5b0d20b9faf;test/e2e/persistent_volumes.go[test/e2e/persistent_volumes.go][test/e2e/storage/persistent_volumes.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate PV/PVC, create and verify writer pod, delete the PVC, and validate the PV's
0000000000000000000000000000000000000000;;	// phase. Note: the PV is deleted in the AfterEach, not here.
0000000000000000000000000000000000000000;;	func completeTest(f *framework.Framework, c clientset.Interface, ns string, pv *v1.PersistentVolume, pvc *v1.PersistentVolumeClaim) {
0000000000000000000000000000000000000000;;		// 1. verify that the PV and PVC have bound correctly
0000000000000000000000000000000000000000;;		By("Validating the PV-PVC binding")
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.WaitOnPVandPVC(c, ns, pv, pvc))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 2. create the nfs writer pod, test if the write was successful,
0000000000000000000000000000000000000000;;		//    then delete the pod and verify that it was deleted
0000000000000000000000000000000000000000;;		By("Checking pod has write access to PersistentVolume")
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.CreateWaitAndDeletePod(f, c, ns, pvc))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 3. delete the PVC, wait for PV to become "Released"
0000000000000000000000000000000000000000;;		By("Deleting the PVC to invoke the reclaim policy.")
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.DeletePVCandValidatePV(c, ns, pvc, pv, v1.VolumeReleased))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate pairs of PVs and PVCs, create and verify writer pod, delete PVC and validate
0000000000000000000000000000000000000000;;	// PV. Ensure each step succeeds.
0000000000000000000000000000000000000000;;	// Note: the PV is deleted in the AfterEach, not here.
0000000000000000000000000000000000000000;;	// Note: this func is serialized, we wait for each pod to be deleted before creating the
0000000000000000000000000000000000000000;;	//   next pod. Adding concurrency is a TODO item.
0000000000000000000000000000000000000000;;	func completeMultiTest(f *framework.Framework, c clientset.Interface, ns string, pvols framework.PVMap, claims framework.PVCMap, expectPhase v1.PersistentVolumePhase) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 1. verify each PV permits write access to a client pod
0000000000000000000000000000000000000000;;		By("Checking pod has write access to PersistentVolumes")
0000000000000000000000000000000000000000;;		for pvcKey := range claims {
0000000000000000000000000000000000000000;;			pvc, err := c.CoreV1().PersistentVolumeClaims(pvcKey.Namespace).Get(pvcKey.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("error getting pvc %q: %v", pvcKey.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(pvc.Spec.VolumeName) == 0 {
0000000000000000000000000000000000000000;;				continue // claim is not bound
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// sanity test to ensure our maps are in sync
0000000000000000000000000000000000000000;;			_, found := pvols[pvc.Spec.VolumeName]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return fmt.Errorf("internal: pvols map is missing volume %q", pvc.Spec.VolumeName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: currently a serialized test of each PV
0000000000000000000000000000000000000000;;			if err = framework.CreateWaitAndDeletePod(f, c, pvcKey.Namespace, pvc); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 2. delete each PVC, wait for its bound PV to reach `expectedPhase`
0000000000000000000000000000000000000000;;		By("Deleting PVCs to invoke reclaim policy")
0000000000000000000000000000000000000000;;		if err = framework.DeletePVCandValidatePVGroup(c, ns, pvols, claims, expectPhase); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// initNFSserverPod wraps volumes.go's startVolumeServer to return a running nfs host pod
0000000000000000000000000000000000000000;;	// commonly used by persistent volume testing
0000000000000000000000000000000000000000;;	func initNFSserverPod(c clientset.Interface, ns string) *v1.Pod {
0000000000000000000000000000000000000000;;		return framework.StartVolumeServer(c, framework.VolumeTestConfig{
0000000000000000000000000000000000000000;;			Namespace:   ns,
0000000000000000000000000000000000000000;;			Prefix:      "nfs",
0000000000000000000000000000000000000000;;			ServerImage: framework.NfsServerImage,
0000000000000000000000000000000000000000;;			ServerPorts: []int{2049},
0000000000000000000000000000000000000000;;			ServerArgs:  []string{"-G", "777", "/exports"},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("PersistentVolumes", func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// global vars for the Context()s and It()'s below
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("pv")
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			c         clientset.Interface
0000000000000000000000000000000000000000;;			ns        string
0000000000000000000000000000000000000000;;			pvConfig  framework.PersistentVolumeConfig
0000000000000000000000000000000000000000;;			pvcConfig framework.PersistentVolumeClaimConfig
0000000000000000000000000000000000000000;;			volLabel  labels.Set
0000000000000000000000000000000000000000;;			selector  *metav1.LabelSelector
0000000000000000000000000000000000000000;;			pv        *v1.PersistentVolume
0000000000000000000000000000000000000000;;			pvc       *v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;			err       error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			c = f.ClientSet
0000000000000000000000000000000000000000;;			ns = f.Namespace.Name
0000000000000000000000000000000000000000;;			// Enforce binding only within test space via selector labels
0000000000000000000000000000000000000000;;			volLabel = labels.Set{framework.VolumeSelectorKey: ns}
0000000000000000000000000000000000000000;;			selector = metav1.SetAsLabelSelector(volLabel)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Testing configurations of a single a PV/PVC pair, multiple evenly paired PVs/PVCs,
0000000000000000000000000000000000000000;;		// and multiple unevenly paired PV/PVCs
0000000000000000000000000000000000000000;;		SIGDescribe("PersistentVolumes:NFS", func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				nfsServerPod *v1.Pod
0000000000000000000000000000000000000000;;				serverIP     string
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				framework.Logf("[BeforeEach] Creating NFS Server Pod")
0000000000000000000000000000000000000000;;				nfsServerPod = initNFSserverPod(c, ns)
0000000000000000000000000000000000000000;;				serverIP = nfsServerPod.Status.PodIP
0000000000000000000000000000000000000000;;				framework.Logf("[BeforeEach] Configuring PersistentVolume")
0000000000000000000000000000000000000000;;				pvConfig = framework.PersistentVolumeConfig{
0000000000000000000000000000000000000000;;					NamePrefix: "nfs-",
0000000000000000000000000000000000000000;;					Labels:     volLabel,
0000000000000000000000000000000000000000;;					PVSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						NFS: &v1.NFSVolumeSource{
0000000000000000000000000000000000000000;;							Server:   serverIP,
0000000000000000000000000000000000000000;;							Path:     "/exports",
0000000000000000000000000000000000000000;;							ReadOnly: false,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pvcConfig = framework.PersistentVolumeClaimConfig{
0000000000000000000000000000000000000000;;					Annotations: map[string]string{
0000000000000000000000000000000000000000;;						v1.BetaStorageClassAnnotation: "",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Selector: selector,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				framework.ExpectNoError(framework.DeletePodWithWait(f, c, nfsServerPod), "AfterEach: Failed to delete pod ", nfsServerPod.Name)
0000000000000000000000000000000000000000;;				pv, pvc = nil, nil
0000000000000000000000000000000000000000;;				pvConfig, pvcConfig = framework.PersistentVolumeConfig{}, framework.PersistentVolumeClaimConfig{}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Context("with Single PV - PVC pairs", func() {
0000000000000000000000000000000000000000;;				// Note: this is the only code where the pv is deleted.
0000000000000000000000000000000000000000;;				AfterEach(func() {
0000000000000000000000000000000000000000;;					framework.Logf("AfterEach: Cleaning up test resources.")
0000000000000000000000000000000000000000;;					if errs := framework.PVPVCCleanup(c, ns, pv, pvc); len(errs) > 0 {
0000000000000000000000000000000000000000;;						framework.Failf("AfterEach: Failed to delete PVC and/or PV. Errors: %v", utilerrors.NewAggregate(errs))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Individual tests follow:
0000000000000000000000000000000000000000;;				//
0000000000000000000000000000000000000000;;				// Create an nfs PV, then a claim that matches the PV, and a pod that
0000000000000000000000000000000000000000;;				// contains the claim. Verify that the PV and PVC bind correctly, and
0000000000000000000000000000000000000000;;				// that the pod can write to the nfs volume.
0000000000000000000000000000000000000000;;				It("should create a non-pre-bound PV and PVC: test write access ", func() {
0000000000000000000000000000000000000000;;					pv, pvc, err = framework.CreatePVPVC(c, pvConfig, pvcConfig, ns, false)
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					completeTest(f, c, ns, pv, pvc)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Create a claim first, then a nfs PV that matches the claim, and a
0000000000000000000000000000000000000000;;				// pod that contains the claim. Verify that the PV and PVC bind
0000000000000000000000000000000000000000;;				// correctly, and that the pod can write to the nfs volume.
0000000000000000000000000000000000000000;;				It("create a PVC and non-pre-bound PV: test write access", func() {
0000000000000000000000000000000000000000;;					pv, pvc, err = framework.CreatePVCPV(c, pvConfig, pvcConfig, ns, false)
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					completeTest(f, c, ns, pv, pvc)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Create a claim first, then a pre-bound nfs PV that matches the claim,
0000000000000000000000000000000000000000;;				// and a pod that contains the claim. Verify that the PV and PVC bind
0000000000000000000000000000000000000000;;				// correctly, and that the pod can write to the nfs volume.
0000000000000000000000000000000000000000;;				It("create a PVC and a pre-bound PV: test write access", func() {
0000000000000000000000000000000000000000;;					pv, pvc, err = framework.CreatePVCPV(c, pvConfig, pvcConfig, ns, true)
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					completeTest(f, c, ns, pv, pvc)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Create a nfs PV first, then a pre-bound PVC that matches the PV,
0000000000000000000000000000000000000000;;				// and a pod that contains the claim. Verify that the PV and PVC bind
0000000000000000000000000000000000000000;;				// correctly, and that the pod can write to the nfs volume.
0000000000000000000000000000000000000000;;				It("create a PV and a pre-bound PVC: test write access", func() {
0000000000000000000000000000000000000000;;					pv, pvc, err = framework.CreatePVPVC(c, pvConfig, pvcConfig, ns, true)
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					completeTest(f, c, ns, pv, pvc)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create multiple pvs and pvcs, all in the same namespace. The PVs-PVCs are
0000000000000000000000000000000000000000;;			// verified to bind, though it's not known in advanced which PV will bind to
0000000000000000000000000000000000000000;;			// which claim. For each pv-pvc pair create a pod that writes to the nfs mount.
0000000000000000000000000000000000000000;;			// Note: when the number of PVs exceeds the number of PVCs the max binding wait
0000000000000000000000000000000000000000;;			//   time will occur for each PV in excess. This is expected but the delta
0000000000000000000000000000000000000000;;			//   should be kept small so that the tests aren't unnecessarily slow.
0000000000000000000000000000000000000000;;			// Note: future tests may wish to incorporate the following:
0000000000000000000000000000000000000000;;			//   a) pre-binding, b) create pvcs before pvs, c) create pvcs and pods
0000000000000000000000000000000000000000;;			//   in different namespaces.
0000000000000000000000000000000000000000;;			Context("with multiple PVs and PVCs all in same ns", func() {
0000000000000000000000000000000000000000;;				// scope the pv and pvc maps to be available in the AfterEach
0000000000000000000000000000000000000000;;				// note: these maps are created fresh in CreatePVsPVCs()
0000000000000000000000000000000000000000;;				var pvols framework.PVMap
0000000000000000000000000000000000000000;;				var claims framework.PVCMap
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				AfterEach(func() {
0000000000000000000000000000000000000000;;					framework.Logf("AfterEach: deleting %v PVCs and %v PVs...", len(claims), len(pvols))
0000000000000000000000000000000000000000;;					errs := framework.PVPVCMapCleanup(c, ns, pvols, claims)
0000000000000000000000000000000000000000;;					if len(errs) > 0 {
0000000000000000000000000000000000000000;;						errmsg := []string{}
0000000000000000000000000000000000000000;;						for _, e := range errs {
0000000000000000000000000000000000000000;;							errmsg = append(errmsg, e.Error())
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						framework.Failf("AfterEach: Failed to delete 1 or more PVs/PVCs. Errors: %v", strings.Join(errmsg, "; "))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Create 2 PVs and 4 PVCs.
0000000000000000000000000000000000000000;;				// Note: PVs are created before claims and no pre-binding
0000000000000000000000000000000000000000;;				It("should create 2 PVs and 4 PVCs: test write access", func() {
0000000000000000000000000000000000000000;;					numPVs, numPVCs := 2, 4
0000000000000000000000000000000000000000;;					pvols, claims, err = framework.CreatePVsPVCs(numPVs, numPVCs, c, ns, pvConfig, pvcConfig)
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					framework.ExpectNoError(framework.WaitAndVerifyBinds(c, ns, pvols, claims, true))
0000000000000000000000000000000000000000;;					framework.ExpectNoError(completeMultiTest(f, c, ns, pvols, claims, v1.VolumeReleased))
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Create 3 PVs and 3 PVCs.
0000000000000000000000000000000000000000;;				// Note: PVs are created before claims and no pre-binding
0000000000000000000000000000000000000000;;				It("should create 3 PVs and 3 PVCs: test write access", func() {
0000000000000000000000000000000000000000;;					numPVs, numPVCs := 3, 3
0000000000000000000000000000000000000000;;					pvols, claims, err = framework.CreatePVsPVCs(numPVs, numPVCs, c, ns, pvConfig, pvcConfig)
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					framework.ExpectNoError(framework.WaitAndVerifyBinds(c, ns, pvols, claims, true))
0000000000000000000000000000000000000000;;					framework.ExpectNoError(completeMultiTest(f, c, ns, pvols, claims, v1.VolumeReleased))
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Create 4 PVs and 2 PVCs.
0000000000000000000000000000000000000000;;				// Note: PVs are created before claims and no pre-binding.
0000000000000000000000000000000000000000;;				It("should create 4 PVs and 2 PVCs: test write access [Slow]", func() {
0000000000000000000000000000000000000000;;					numPVs, numPVCs := 4, 2
0000000000000000000000000000000000000000;;					pvols, claims, err = framework.CreatePVsPVCs(numPVs, numPVCs, c, ns, pvConfig, pvcConfig)
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					framework.ExpectNoError(framework.WaitAndVerifyBinds(c, ns, pvols, claims, true))
0000000000000000000000000000000000000000;;					framework.ExpectNoError(completeMultiTest(f, c, ns, pvols, claims, v1.VolumeReleased))
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// This Context isolates and tests the "Recycle" reclaim behavior.  On deprecation of the
0000000000000000000000000000000000000000;;			// Recycler, this entire context can be removed without affecting the test suite or leaving behind
0000000000000000000000000000000000000000;;			// dead code.
0000000000000000000000000000000000000000;;			Context("when invoking the Recycle reclaim policy", func() {
0000000000000000000000000000000000000000;;				BeforeEach(func() {
0000000000000000000000000000000000000000;;					pvConfig.ReclaimPolicy = v1.PersistentVolumeReclaimRecycle
0000000000000000000000000000000000000000;;					pv, pvc, err = framework.CreatePVPVC(c, pvConfig, pvcConfig, ns, false)
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred(), "BeforeEach: Failed to create PV/PVC")
0000000000000000000000000000000000000000;;					framework.ExpectNoError(framework.WaitOnPVandPVC(c, ns, pv, pvc), "BeforeEach: WaitOnPVandPVC failed")
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				AfterEach(func() {
0000000000000000000000000000000000000000;;					framework.Logf("AfterEach: Cleaning up test resources.")
0000000000000000000000000000000000000000;;					if errs := framework.PVPVCCleanup(c, ns, pv, pvc); len(errs) > 0 {
0000000000000000000000000000000000000000;;						framework.Failf("AfterEach: Failed to delete PVC and/or PV. Errors: %v", utilerrors.NewAggregate(errs))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// This It() tests a scenario where a PV is written to by a Pod, recycled, then the volume checked
0000000000000000000000000000000000000000;;				// for files. If files are found, the checking Pod fails, failing the test.  Otherwise, the pod
0000000000000000000000000000000000000000;;				// (and test) succeed.
0000000000000000000000000000000000000000;;				It("should test that a PV becomes Available and is clean after the PVC is deleted.", func() {
0000000000000000000000000000000000000000;;					By("Writing to the volume.")
0000000000000000000000000000000000000000;;					pod := framework.MakeWritePod(ns, pvc)
0000000000000000000000000000000000000000;;					pod, err = c.CoreV1().Pods(ns).Create(pod)
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					framework.ExpectNoError(framework.WaitForPodSuccessInNamespace(c, pod.Name, ns))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					By("Deleting the claim")
0000000000000000000000000000000000000000;;					framework.ExpectNoError(framework.DeletePVCandValidatePV(c, ns, pvc, pv, v1.VolumeAvailable))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					By("Re-mounting the volume.")
0000000000000000000000000000000000000000;;					pvc = framework.MakePersistentVolumeClaim(pvcConfig, ns)
0000000000000000000000000000000000000000;;					pvc, err = framework.CreatePVC(c, ns, pvc)
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					framework.ExpectNoError(framework.WaitForPersistentVolumeClaimPhase(v1.ClaimBound, c, ns, pvc.Name, 2*time.Second, 60*time.Second), "Failed to reach 'Bound' for PVC ", pvc.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// If a file is detected in /mnt, fail the pod and do not restart it.
0000000000000000000000000000000000000000;;					By("Verifying the mount has been cleaned.")
0000000000000000000000000000000000000000;;					mount := pod.Spec.Containers[0].VolumeMounts[0].MountPath
0000000000000000000000000000000000000000;;					pod = framework.MakePod(ns, []*v1.PersistentVolumeClaim{pvc}, true, fmt.Sprintf("[ $(ls -A %s | wc -l) -eq 0 ] && exit 0 || exit 1", mount))
0000000000000000000000000000000000000000;;					pod, err = c.CoreV1().Pods(ns).Create(pod)
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					framework.ExpectNoError(framework.WaitForPodSuccessInNamespace(c, pod.Name, ns))
0000000000000000000000000000000000000000;;					framework.Logf("Pod exited without failure; the volume has been recycled.")
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
