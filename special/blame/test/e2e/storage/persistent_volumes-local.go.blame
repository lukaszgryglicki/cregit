0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
dbdf50f8516add395b3319d262dfdc178ab5d770;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type localTestConfig struct {
0000000000000000000000000000000000000000;;		ns     string
0000000000000000000000000000000000000000;;		nodes  *v1.NodeList
0000000000000000000000000000000000000000;;		client clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type localTestVolume struct {
0000000000000000000000000000000000000000;;		// Node that the volume is on
0000000000000000000000000000000000000000;;		node *v1.Node
0000000000000000000000000000000000000000;;		// Path to the volume on the host node
0000000000000000000000000000000000000000;;		hostDir string
0000000000000000000000000000000000000000;;		// Path to the volume in the local util container
0000000000000000000000000000000000000000;;		containerDir string
0000000000000000000000000000000000000000;;		// PVC for this volume
0000000000000000000000000000000000000000;;		pvc *v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;		// PV for this volume
0000000000000000000000000000000000000000;;		pv *v1.PersistentVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// TODO: This may not be available/writable on all images.
0000000000000000000000000000000000000000;;		hostBase      = "/tmp"
0000000000000000000000000000000000000000;;		containerBase = "/myvol"
0000000000000000000000000000000000000000;;		// Path to the first volume in the test containers
0000000000000000000000000000000000000000;;		// created via createLocalPod or makeLocalPod
0000000000000000000000000000000000000000;;		// leveraging pv_util.MakePod
0000000000000000000000000000000000000000;;		volumeDir = "/mnt/volume1"
0000000000000000000000000000000000000000;;		// testFile created in setupLocalVolume
0000000000000000000000000000000000000000;;		testFile = "test-file"
0000000000000000000000000000000000000000;;		// testFileContent writtent into testFile
0000000000000000000000000000000000000000;;		testFileContent = "test-file-content"
0000000000000000000000000000000000000000;;		testSC          = "local-test-storageclass"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("PersistentVolumes-local [Feature:LocalPersistentVolumes] [Serial]", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("persistent-local-volumes-test")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			config *localTestConfig
0000000000000000000000000000000000000000;;			node0  *v1.Node
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get all the schedulable nodes
0000000000000000000000000000000000000000;;			nodes := framework.GetReadySchedulableNodesOrDie(f.ClientSet)
0000000000000000000000000000000000000000;;			Expect(len(nodes.Items)).NotTo(BeZero(), "No available nodes for scheduling")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			config = &localTestConfig{
0000000000000000000000000000000000000000;;				ns:     f.Namespace.Name,
0000000000000000000000000000000000000000;;				client: f.ClientSet,
0000000000000000000000000000000000000000;;				nodes:  nodes,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Choose the first node
0000000000000000000000000000000000000000;;			node0 = &config.nodes.Items[0]
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Context("when one pod requests one prebound PVC", func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var testVol *localTestVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				testVol = setupLocalVolumePVCPV(config, node0)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				cleanupLocalVolume(config, testVol)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should be able to mount and read from the volume using one-command containers", func() {
0000000000000000000000000000000000000000;;				By("Creating a pod to read from the PV")
0000000000000000000000000000000000000000;;				//testFileContent was written during setupLocalVolume
0000000000000000000000000000000000000000;;				_, readCmd := createWriteAndReadCmds(volumeDir, testFile, "" /*writeTestFileContent*/)
0000000000000000000000000000000000000000;;				podSpec := makeLocalPod(config, testVol, readCmd)
0000000000000000000000000000000000000000;;				f.TestContainerOutput("pod reads PV", podSpec, 0, []string{testFileContent})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should be able to mount and write to the volume using one-command containers", func() {
0000000000000000000000000000000000000000;;				By("Creating a pod to write to the PV")
0000000000000000000000000000000000000000;;				writeCmd, readCmd := createWriteAndReadCmds(volumeDir, testFile, testVol.hostDir /*writeTestFileContent*/)
0000000000000000000000000000000000000000;;				writeThenReadCmd := fmt.Sprintf("%s;%s", writeCmd, readCmd)
0000000000000000000000000000000000000000;;				podSpec := makeLocalPod(config, testVol, writeThenReadCmd)
0000000000000000000000000000000000000000;;				f.TestContainerOutput("pod writes to PV", podSpec, 0, []string{testVol.hostDir})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should be able to mount volume and read from pod1", func() {
0000000000000000000000000000000000000000;;				By("Creating pod1")
0000000000000000000000000000000000000000;;				pod1, pod1Err := createLocalPod(config, testVol)
0000000000000000000000000000000000000000;;				Expect(pod1Err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				pod1NodeName, pod1NodeNameErr := podNodeName(config, pod1)
0000000000000000000000000000000000000000;;				Expect(pod1NodeNameErr).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				framework.Logf("pod1 %q created on Node %q", pod1.Name, pod1NodeName)
0000000000000000000000000000000000000000;;				Expect(pod1NodeName).To(Equal(node0.Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Reading in pod1")
0000000000000000000000000000000000000000;;				//testFileContent was written during setupLocalVolume
0000000000000000000000000000000000000000;;				_, readCmd := createWriteAndReadCmds(volumeDir, testFile, "" /*writeTestFileContent*/)
0000000000000000000000000000000000000000;;				readOut := podRWCmdExec(pod1, readCmd)
0000000000000000000000000000000000000000;;				Expect(readOut).To(ContainSubstring(testFileContent)) /*aka writeTestFileContents*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Deleting pod1")
0000000000000000000000000000000000000000;;				framework.DeletePodOrFail(config.client, config.ns, pod1.Name)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should be able to mount volume and write from pod1", func() {
0000000000000000000000000000000000000000;;				By("Creating pod1")
0000000000000000000000000000000000000000;;				pod1, pod1Err := createLocalPod(config, testVol)
0000000000000000000000000000000000000000;;				Expect(pod1Err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				pod1NodeName, pod1NodeNameErr := podNodeName(config, pod1)
0000000000000000000000000000000000000000;;				Expect(pod1NodeNameErr).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				framework.Logf("pod1 %q created on Node %q", pod1.Name, pod1NodeName)
0000000000000000000000000000000000000000;;				Expect(pod1NodeName).To(Equal(node0.Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Writing in pod1")
0000000000000000000000000000000000000000;;				writeCmd, _ := createWriteAndReadCmds(volumeDir, testFile, testVol.hostDir /*writeTestFileContent*/)
0000000000000000000000000000000000000000;;				podRWCmdExec(pod1, writeCmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Deleting pod1")
0000000000000000000000000000000000000000;;				framework.DeletePodOrFail(config.client, config.ns, pod1.Name)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Context("when two pods request one prebound PVC one after other", func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var testVol *localTestVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				testVol = setupLocalVolumePVCPV(config, node0)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				cleanupLocalVolume(config, testVol)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should be able to mount volume, write from pod1, and read from pod2 using one-command containers", func() {
0000000000000000000000000000000000000000;;				By("Creating pod1 to write to the PV")
0000000000000000000000000000000000000000;;				writeCmd, readCmd := createWriteAndReadCmds(volumeDir, testFile, testVol.hostDir /*writeTestFileContent*/)
0000000000000000000000000000000000000000;;				writeThenReadCmd := fmt.Sprintf("%s;%s", writeCmd, readCmd)
0000000000000000000000000000000000000000;;				podSpec1 := makeLocalPod(config, testVol, writeThenReadCmd)
0000000000000000000000000000000000000000;;				f.TestContainerOutput("pod writes to PV", podSpec1, 0, []string{testVol.hostDir})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Creating pod2 to read from the PV")
0000000000000000000000000000000000000000;;				podSpec2 := makeLocalPod(config, testVol, readCmd)
0000000000000000000000000000000000000000;;				f.TestContainerOutput("pod reads PV", podSpec2, 0, []string{testVol.hostDir})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should be able to mount volume in two pods one after other, write from pod1, and read from pod2", func() {
0000000000000000000000000000000000000000;;				By("Creating pod1")
0000000000000000000000000000000000000000;;				pod1, pod1Err := createLocalPod(config, testVol)
0000000000000000000000000000000000000000;;				Expect(pod1Err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				framework.ExpectNoError(framework.WaitForPodRunningInNamespace(config.client, pod1))
0000000000000000000000000000000000000000;;				pod1NodeName, pod1NodeNameErr := podNodeName(config, pod1)
0000000000000000000000000000000000000000;;				Expect(pod1NodeNameErr).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				framework.Logf("Pod1 %q created on Node %q", pod1.Name, pod1NodeName)
0000000000000000000000000000000000000000;;				Expect(pod1NodeName).To(Equal(node0.Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				writeCmd, readCmd := createWriteAndReadCmds(volumeDir, testFile, testVol.hostDir /*writeTestFileContent*/)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Writing in pod1")
0000000000000000000000000000000000000000;;				podRWCmdExec(pod1, writeCmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Deleting pod1")
0000000000000000000000000000000000000000;;				framework.DeletePodOrFail(config.client, config.ns, pod1.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Creating pod2")
0000000000000000000000000000000000000000;;				pod2, pod2Err := createLocalPod(config, testVol)
0000000000000000000000000000000000000000;;				Expect(pod2Err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				framework.ExpectNoError(framework.WaitForPodRunningInNamespace(config.client, pod2))
0000000000000000000000000000000000000000;;				pod2NodeName, pod2NodeNameErr := podNodeName(config, pod2)
0000000000000000000000000000000000000000;;				Expect(pod2NodeNameErr).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				framework.Logf("Pod2 %q created on Node %q", pod2.Name, pod2NodeName)
0000000000000000000000000000000000000000;;				Expect(pod2NodeName).To(Equal(node0.Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Reading in pod2")
0000000000000000000000000000000000000000;;				readOut := podRWCmdExec(pod2, readCmd)
0000000000000000000000000000000000000000;;				Expect(readOut).To(ContainSubstring(testVol.hostDir)) /*aka writeTestFileContents*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Deleting pod2")
0000000000000000000000000000000000000000;;				framework.DeletePodOrFail(config.client, config.ns, pod2.Name)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Context("when two pods request one prebound PVC at the same time", func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var testVol *localTestVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				testVol = setupLocalVolumePVCPV(config, node0)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				cleanupLocalVolume(config, testVol)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should be able to mount volume in two pods at the same time, write from pod1, and read from pod2", func() {
0000000000000000000000000000000000000000;;				By("Creating pod1 to write to the PV")
0000000000000000000000000000000000000000;;				pod1, pod1Err := createLocalPod(config, testVol)
0000000000000000000000000000000000000000;;				Expect(pod1Err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				framework.ExpectNoError(framework.WaitForPodRunningInNamespace(config.client, pod1))
0000000000000000000000000000000000000000;;				pod1NodeName, pod1NodeNameErr := podNodeName(config, pod1)
0000000000000000000000000000000000000000;;				Expect(pod1NodeNameErr).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				framework.Logf("Pod1 %q created on Node %q", pod1.Name, pod1NodeName)
0000000000000000000000000000000000000000;;				Expect(pod1NodeName).To(Equal(node0.Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Creating pod2 to read from the PV")
0000000000000000000000000000000000000000;;				pod2, pod2Err := createLocalPod(config, testVol)
0000000000000000000000000000000000000000;;				Expect(pod2Err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				framework.ExpectNoError(framework.WaitForPodRunningInNamespace(config.client, pod2))
0000000000000000000000000000000000000000;;				pod2NodeName, pod2NodeNameErr := podNodeName(config, pod2)
0000000000000000000000000000000000000000;;				Expect(pod2NodeNameErr).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				framework.Logf("Pod2 %q created on Node %q", pod2.Name, pod2NodeName)
0000000000000000000000000000000000000000;;				Expect(pod2NodeName).To(Equal(node0.Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				writeCmd, readCmd := createWriteAndReadCmds(volumeDir, testFile, testVol.hostDir /*writeTestFileContent*/)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Writing in pod1")
0000000000000000000000000000000000000000;;				podRWCmdExec(pod1, writeCmd)
0000000000000000000000000000000000000000;;				By("Reading in pod2")
0000000000000000000000000000000000000000;;				readOut := podRWCmdExec(pod2, readCmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Expect(readOut).To(ContainSubstring(testVol.hostDir)) /*aka writeTestFileContents*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Deleting pod1")
0000000000000000000000000000000000000000;;				framework.DeletePodOrFail(config.client, config.ns, pod1.Name)
0000000000000000000000000000000000000000;;				By("Deleting pod2")
0000000000000000000000000000000000000000;;				framework.DeletePodOrFail(config.client, config.ns, pod2.Name)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// podNode wraps RunKubectl to get node where pod is running
0000000000000000000000000000000000000000;;	func podNodeName(config *localTestConfig, pod *v1.Pod) (string, error) {
0000000000000000000000000000000000000000;;		runtimePod, runtimePodErr := config.client.Core().Pods(pod.Namespace).Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		return runtimePod.Spec.NodeName, runtimePodErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Launches a pod with hostpath volume on a specific node to setup a directory to use
0000000000000000000000000000000000000000;;	// for the local PV
0000000000000000000000000000000000000000;;	func setupLocalVolume(config *localTestConfig, node *v1.Node) *localTestVolume {
0000000000000000000000000000000000000000;;		testDirName := "local-volume-test-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;		testDir := filepath.Join(containerBase, testDirName)
0000000000000000000000000000000000000000;;		hostDir := filepath.Join(hostBase, testDirName)
0000000000000000000000000000000000000000;;		//populate volume with testFile containing testFileContent
0000000000000000000000000000000000000000;;		writeCmd, _ := createWriteAndReadCmds(testDir, testFile, testFileContent)
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating local volume on node %q at path %q", node.Name, hostDir))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runLocalUtil(config, node.Name, writeCmd)
0000000000000000000000000000000000000000;;		return &localTestVolume{
0000000000000000000000000000000000000000;;			node:         node,
0000000000000000000000000000000000000000;;			hostDir:      hostDir,
0000000000000000000000000000000000000000;;			containerDir: testDir,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Deletes the PVC/PV, and launches a pod with hostpath volume to remove the test directory
0000000000000000000000000000000000000000;;	func cleanupLocalVolume(config *localTestConfig, volume *localTestVolume) {
0000000000000000000000000000000000000000;;		if volume == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Cleaning up PVC and PV")
0000000000000000000000000000000000000000;;		errs := framework.PVPVCCleanup(config.client, config.ns, volume.pv, volume.pvc)
0000000000000000000000000000000000000000;;		if len(errs) > 0 {
0000000000000000000000000000000000000000;;			framework.Failf("Failed to delete PV and/or PVC: %v", utilerrors.NewAggregate(errs))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Removing the test directory")
0000000000000000000000000000000000000000;;		removeCmd := fmt.Sprintf("rm -r %s", volume.containerDir)
0000000000000000000000000000000000000000;;		runLocalUtil(config, volume.node.Name, removeCmd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func runLocalUtil(config *localTestConfig, nodeName, cmd string) {
0000000000000000000000000000000000000000;;		framework.StartVolumeServer(config.client, framework.VolumeTestConfig{
0000000000000000000000000000000000000000;;			Namespace:   config.ns,
0000000000000000000000000000000000000000;;			Prefix:      "local-volume-init",
0000000000000000000000000000000000000000;;			ServerImage: framework.BusyBoxImage,
0000000000000000000000000000000000000000;;			ServerCmds:  []string{"/bin/sh"},
0000000000000000000000000000000000000000;;			ServerArgs:  []string{"-c", cmd},
0000000000000000000000000000000000000000;;			ServerVolumes: map[string]string{
0000000000000000000000000000000000000000;;				hostBase: containerBase,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			WaitForCompletion: true,
0000000000000000000000000000000000000000;;			NodeName:          nodeName,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeLocalPVCConfig() framework.PersistentVolumeClaimConfig {
0000000000000000000000000000000000000000;;		sc := testSC
0000000000000000000000000000000000000000;;		return framework.PersistentVolumeClaimConfig{
0000000000000000000000000000000000000000;;			AccessModes:      []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce},
0000000000000000000000000000000000000000;;			StorageClassName: &sc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeLocalPVConfig(volume *localTestVolume) framework.PersistentVolumeConfig {
0000000000000000000000000000000000000000;;		// TODO: hostname may not be the best option
0000000000000000000000000000000000000000;;		nodeKey := "kubernetes.io/hostname"
0000000000000000000000000000000000000000;;		if volume.node.Labels == nil {
0000000000000000000000000000000000000000;;			framework.Failf("Node does not have labels")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeValue, found := volume.node.Labels[nodeKey]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			framework.Failf("Node does not have required label %q", nodeKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return framework.PersistentVolumeConfig{
0000000000000000000000000000000000000000;;			PVSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;				Local: &v1.LocalVolumeSource{
0000000000000000000000000000000000000000;;					Path: volume.hostDir,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			NamePrefix:       "local-pv",
0000000000000000000000000000000000000000;;			StorageClassName: testSC,
0000000000000000000000000000000000000000;;			NodeAffinity: &v1.NodeAffinity{
0000000000000000000000000000000000000000;;				RequiredDuringSchedulingIgnoredDuringExecution: &v1.NodeSelector{
0000000000000000000000000000000000000000;;					NodeSelectorTerms: []v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							MatchExpressions: []v1.NodeSelectorRequirement{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Key:      nodeKey,
0000000000000000000000000000000000000000;;									Operator: v1.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;									Values:   []string{nodeValue},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates a PVC and PV with prebinding
0000000000000000000000000000000000000000;;	func createLocalPVCPV(config *localTestConfig, volume *localTestVolume) {
0000000000000000000000000000000000000000;;		pvcConfig := makeLocalPVCConfig()
0000000000000000000000000000000000000000;;		pvConfig := makeLocalPVConfig(volume)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		volume.pv, volume.pvc, err = framework.CreatePVPVC(config.client, pvConfig, pvcConfig, config.ns, true)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.WaitOnPVandPVC(config.client, config.ns, volume.pv, volume.pvc))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeLocalPod(config *localTestConfig, volume *localTestVolume, cmd string) *v1.Pod {
0000000000000000000000000000000000000000;;		return framework.MakePod(config.ns, []*v1.PersistentVolumeClaim{volume.pvc}, false, cmd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createLocalPod(config *localTestConfig, volume *localTestVolume) (*v1.Pod, error) {
0000000000000000000000000000000000000000;;		return framework.CreatePod(config.client, config.ns, []*v1.PersistentVolumeClaim{volume.pvc}, false, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create corresponding write and read commands
0000000000000000000000000000000000000000;;	// to be executed inside containers with local PV attached
0000000000000000000000000000000000000000;;	func createWriteAndReadCmds(testFileDir string, testFile string, writeTestFileContent string) (writeCmd string, readCmd string) {
0000000000000000000000000000000000000000;;		testFilePath := filepath.Join(testFileDir, testFile)
0000000000000000000000000000000000000000;;		writeCmd = fmt.Sprintf("mkdir -p %s; echo %s > %s", testFileDir, writeTestFileContent, testFilePath)
0000000000000000000000000000000000000000;;		readCmd = fmt.Sprintf("cat %s", testFilePath)
0000000000000000000000000000000000000000;;		return writeCmd, readCmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Execute a read or write command in a pod.
0000000000000000000000000000000000000000;;	// Fail on error
0000000000000000000000000000000000000000;;	func podRWCmdExec(pod *v1.Pod, cmd string) string {
0000000000000000000000000000000000000000;;		out, err := podExec(pod, cmd)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Initialize test volume on node
0000000000000000000000000000000000000000;;	// and create local PVC and PV
0000000000000000000000000000000000000000;;	func setupLocalVolumePVCPV(config *localTestConfig, node *v1.Node) *localTestVolume {
0000000000000000000000000000000000000000;;		By("Initializing test volume")
0000000000000000000000000000000000000000;;		testVol := setupLocalVolume(config, node)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating local PVC and PV")
0000000000000000000000000000000000000000;;		createLocalPVCPV(config, testVol)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return testVol
0000000000000000000000000000000000000000;;	}
