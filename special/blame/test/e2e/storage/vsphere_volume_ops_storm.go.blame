0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
4316a6cf12a03675408d86f74afa59ee2b1c5d99;test/e2e/vsphere_volume_ops_storm.go[test/e2e/vsphere_volume_ops_storm.go][test/e2e/storage/vsphere_volume_ops_storm.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		storage "k8s.io/api/storage/v1"
0000000000000000000000000000000000000000;;		k8stype "k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		vsphere "k8s.io/kubernetes/pkg/cloudprovider/providers/vsphere"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Test to perform Disk Ops storm.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Steps
0000000000000000000000000000000000000000;;	    	1. Create storage class for thin Provisioning.
0000000000000000000000000000000000000000;;	    	2. Create 30 PVCs using above storage class in annotation, requesting 2 GB files.
0000000000000000000000000000000000000000;;	    	3. Wait until all disks are ready and all PVs and PVCs get bind. (CreateVolume storm)
0000000000000000000000000000000000000000;;	    	4. Create pod to mount volumes using PVCs created in step 2. (AttachDisk storm)
0000000000000000000000000000000000000000;;	    	5. Wait for pod status to be running.
0000000000000000000000000000000000000000;;	    	6. Verify all volumes accessible and available in the pod.
0000000000000000000000000000000000000000;;	    	7. Delete pod.
0000000000000000000000000000000000000000;;	    	8. wait until volumes gets detached. (DetachDisk storm)
0000000000000000000000000000000000000000;;	    	9. Delete all PVCs. This should delete all Disks. (DeleteVolume storm)
0000000000000000000000000000000000000000;;			10. Delete storage class.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("vsphere volume operations storm", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("volume-ops-storm")
0000000000000000000000000000000000000000;;		const DEFAULT_VOLUME_OPS_SCALE = 30
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			client            clientset.Interface
0000000000000000000000000000000000000000;;			namespace         string
0000000000000000000000000000000000000000;;			storageclass      *storage.StorageClass
0000000000000000000000000000000000000000;;			pvclaims          []*v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;			persistentvolumes []*v1.PersistentVolume
0000000000000000000000000000000000000000;;			err               error
0000000000000000000000000000000000000000;;			volume_ops_scale  int
0000000000000000000000000000000000000000;;			vsp               *vsphere.VSphere
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			framework.SkipUnlessProviderIs("vsphere")
0000000000000000000000000000000000000000;;			client = f.ClientSet
0000000000000000000000000000000000000000;;			namespace = f.Namespace.Name
0000000000000000000000000000000000000000;;			nodeList := framework.GetReadySchedulableNodesOrDie(f.ClientSet)
0000000000000000000000000000000000000000;;			if len(nodeList.Items) == 0 {
0000000000000000000000000000000000000000;;				framework.Failf("Unable to find ready and schedulable Node")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if os.Getenv("VOLUME_OPS_SCALE") != "" {
0000000000000000000000000000000000000000;;				volume_ops_scale, err = strconv.Atoi(os.Getenv("VOLUME_OPS_SCALE"))
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				volume_ops_scale = DEFAULT_VOLUME_OPS_SCALE
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pvclaims = make([]*v1.PersistentVolumeClaim, volume_ops_scale)
0000000000000000000000000000000000000000;;			vsp, err = vsphere.GetVSphere()
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		AfterEach(func() {
0000000000000000000000000000000000000000;;			By("Deleting PVCs")
0000000000000000000000000000000000000000;;			for _, claim := range pvclaims {
0000000000000000000000000000000000000000;;				framework.DeletePersistentVolumeClaim(client, claim.Name, namespace)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("Deleting StorageClass")
0000000000000000000000000000000000000000;;			err = client.StorageV1().StorageClasses().Delete(storageclass.Name, nil)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should create pod with many volumes and verify no attach call fails", func() {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Running test with VOLUME_OPS_SCALE: %v", volume_ops_scale))
0000000000000000000000000000000000000000;;			By("Creating Storage Class")
0000000000000000000000000000000000000000;;			scParameters := make(map[string]string)
0000000000000000000000000000000000000000;;			scParameters["diskformat"] = "thin"
0000000000000000000000000000000000000000;;			storageclass, err = client.StorageV1().StorageClasses().Create(getVSphereStorageClassSpec("thinsc", scParameters))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating PVCs using the Storage Class")
0000000000000000000000000000000000000000;;			count := 0
0000000000000000000000000000000000000000;;			for count < volume_ops_scale {
0000000000000000000000000000000000000000;;				pvclaims[count], err = framework.CreatePVC(client, namespace, getVSphereClaimSpecWithStorageClassAnnotation(namespace, storageclass))
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				count++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Waiting for all claims to be in bound phase")
0000000000000000000000000000000000000000;;			persistentvolumes, err = framework.WaitForPVClaimBoundPhase(client, pvclaims)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating pod to attach PVs to the node")
0000000000000000000000000000000000000000;;			pod, err := framework.CreatePod(client, namespace, pvclaims, false, "")
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Verify all volumes are accessible and available in the pod")
0000000000000000000000000000000000000000;;			verifyVSphereVolumesAccessible(pod, persistentvolumes, vsp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Deleting pod")
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.DeletePodWithWait(f, client, pod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Waiting for volumes to be detached from the node")
0000000000000000000000000000000000000000;;			for _, pv := range persistentvolumes {
0000000000000000000000000000000000000000;;				waitForVSphereDiskToDetach(vsp, pv.Spec.VsphereVolume.VolumePath, k8stype.NodeName(pod.Spec.NodeName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
